<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Syst Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Syst Biol</journal-id>
    <journal-title-group>
      <journal-title>BMC Systems Biology</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1752-0509</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3517402</article-id>
    <article-id pub-id-type="publisher-id">1752-0509-6-116</article-id>
    <article-id pub-id-type="pmid">22932419</article-id>
    <article-id pub-id-type="doi">10.1186/1752-0509-6-116</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Continuous time boolean modeling for biological signaling: application of Gillespie algorithm</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Stoll</surname>
          <given-names>Gautier</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>gautier.stoll@curie.fr</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Viara</surname>
          <given-names>Eric</given-names>
        </name>
        <xref ref-type="aff" rid="I4">4</xref>
        <email>viara@sysra.com</email>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Barillot</surname>
          <given-names>Emmanuel</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>emmanuel.barillot@curie.fr</email>
      </contrib>
      <contrib contrib-type="author" id="A4">
        <name>
          <surname>Calzone</surname>
          <given-names>Laurence</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>laurence.calzone@curie.fr</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Institut Curie, 26 rue d’Ulm, Paris, F-75248 France</aff>
    <aff id="I2"><label>2</label>INSERM, Paris, U900, F-75248 France</aff>
    <aff id="I3"><label>3</label>Mines ParisTech, Fontainebleau, F-77300 France</aff>
    <aff id="I4"><label>4</label>Sysra, Yerres, F-91330 France</aff>
    <pub-date pub-type="collection">
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>29</day>
      <month>8</month>
      <year>2012</year>
    </pub-date>
    <volume>6</volume>
    <fpage>116</fpage>
    <lpage>116</lpage>
    <history>
      <date date-type="received">
        <day>4</day>
        <month>4</month>
        <year>2012</year>
      </date>
      <date date-type="accepted">
        <day>15</day>
        <month>8</month>
        <year>2012</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright ©2012 Stoll et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2012</copyright-year>
      <copyright-holder>Stoll et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (
<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1752-0509/6/116"/>
    <abstract>
      <sec>
        <title/>
        <p>Mathematical modeling is used as a Systems Biology tool to answer biological questions, and more precisely, to validate a network that describes biological observations and predict the effect of perturbations. This article presents an algorithm for modeling biological networks in a discrete framework with continuous time.</p>
      </sec>
      <sec>
        <title>Background</title>
        <p>There exist two major types of mathematical modeling approaches: (1) quantitative modeling, representing various chemical species concentrations by real numbers, mainly based on differential equations and chemical kinetics formalism; (2) and qualitative modeling, representing chemical species concentrations or activities by a finite set of discrete values. Both approaches answer particular (and often different) biological questions. Qualitative modeling approach permits a simple and less detailed description of the biological systems, efficiently describes stable state identification but remains inconvenient in describing the transient kinetics leading to these states. In this context, time is represented by discrete steps. Quantitative modeling, on the other hand, can describe more accurately the dynamical behavior of biological processes as it follows the evolution of concentration or activities of chemical species as a function of time, but requires an important amount of information on the parameters difficult to find in the literature.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>Here, we propose a modeling framework based on a qualitative approach that is intrinsically continuous in time. The algorithm presented in this article fills the gap between qualitative and quantitative modeling. It is based on continuous time Markov process applied on a Boolean state space. In order to describe the temporal evolution of the biological process we wish to model, we explicitly specify the transition rates for each node. For that purpose, we built a language that can be seen as a generalization of Boolean equations. Mathematically, this approach can be translated in a set of ordinary differential equations on probability distributions. We developed a C++ software, MaBoSS, that is able to simulate such a system by applying Kinetic Monte-Carlo (or Gillespie algorithm) on the Boolean state space. This software, parallelized and optimized, computes the temporal evolution of probability distributions and estimates stationary distributions.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>Applications of the Boolean Kinetic Monte-Carlo are demonstrated for three qualitative models: a toy model, a published model of p53/Mdm2 interaction and a published model of the mammalian cell cycle. Our approach allows to describe kinetic phenomena which were difficult to handle in the original models. In particular, transient effects are represented by time dependent probability distributions, interpretable in terms of cell populations.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>Boolean modeling</kwd>
      <kwd>Continuous time</kwd>
      <kwd>Markov process</kwd>
      <kwd>Gillespie algorithm</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Mathematical models of signaling pathways are tools that answer biological questions. The most commonly used mathematical formalisms to answer these questions are ordinary differential equations (ODEs) and Boolean modeling.</p>
    <p>Ordinary differential equations (ODEs) have been widely utilized to model signaling pathways. It is the most natural formalism for translating detailed reaction networks into a mathematical model. Indeed, equations can be directly derived using mass action laws, Michaelis-Menten kinetics or Hill functions for each reaction according to the observed behaviors. This framework has limitations, though. The first one concerns the difficulty to assign values to the kinetic parameters of the model. Ideally, these parameters would be extracted from experimental data. However, they are often chosen by the modeler so as to fit qualitatively the expected phenotypes. The second limitation concerns the cell population heterogeneity. In this case, ODEs are no longer appropriate since the approach is deterministic and thus focuses on the average behavior. To include non-determinism, an ODE model needs to be transformed into a stochastic chemical model. In this formalism, a master equation is written on the probabilities of the number of molecules for each species. In the translation process, the same parameters used in ODEs (more particularly in ODEs written with mass action law) can be used in the master equation, but in this case, the number of initial conditions explodes along with the computation time.</p>
    <p>Boolean (or logical) formalism is another formalism used to model signaling pathways where genes/proteins are parameterized by 0s and 1s only. It is the most natural formalism to translate an influence network into a mathematical model. In such networks, each node corresponds to a species and each arrow to an interaction or an influence (positive or negative). In a Boolean model, a logical rule linking the inputs is assigned to each node. As a result, there are no real parameter values to adjust besides choosing the appropriate logical rules that best describe the system. In this paper, we will refer to a state in which each node of the influence network has a Boolean value as a network state, and the set of all possible transitions between the network states as a transition graph. There are two types of transition graphs, one deduced from the synchronous update strategy
[<xref ref-type="bibr" rid="B1">1</xref>], for which all the nodes that can be updated are updated in one transition, and another one deduced from the asynchronous update strategy
[<xref ref-type="bibr" rid="B2">2</xref>], for which only one node, of all the possible nodes, is updated in one transition. In the Boolean formalism, each transition can be interpreted as a “time” step, though this “time” does not characterize real biological time but rather an event. Stochasticity is an important aspect when studying cell populations. In Boolean framework, it can be applied: on nodes (by randomly flipping a node state
[<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B4">4</xref>]), on the logical rules (by allowing to change an AND gate into an OR gate
[<xref ref-type="bibr" rid="B5">5</xref>]), and on the update rules (by defining the probability and the priority of changing one particular Boolean value before others in an asynchronous strategy
[<xref ref-type="bibr" rid="B6">6</xref>] or by adding noise to the whole system in a synchronous strategy
[<xref ref-type="bibr" rid="B7">7</xref>]). One of the main drawbacks of the Boolean approach is the explosion of solutions. In an asynchronous update strategy, the size of the transition graph can reach 2<sup>#nodes</sup>.</p>
    <p>Both logical and continuous frameworks have advantages and disadvantages above-mentioned. We propose here to combine some of the advantages of both approaches in an algorithm that we call the “Boolean Kinetic Monte-Carlo” algorithm (BKMC). It consists of a natural generalization of the asynchronous Boolean dynamics
[<xref ref-type="bibr" rid="B2">2</xref>], with a direct probabilistic interpretation. In BKMC framework, the dynamics is parameterized by a biological time and the order of update is noisy, which is less strict than priority classes introduced in GINsim
[<xref ref-type="bibr" rid="B8">8</xref>]. A BKMC model is specified by logical rules as in regular Boolean models but with a more precise information: a numerical rate is added for each transition of each node.</p>
    <p>BKMC is not intended to replace existing tools but rather to complement them. It is best suited to model signaling pathways in the following cases: </p>
    <p>• The model is based on an influence network, because BKMC is a generalization of the asynchronous Boolean dynamics. See “Examples” section. Note that this is a common requirement for most of Boolean software.</p>
    <p>• The model describes processes for which information about the duration of a biological process is known, because in BKMC, time is parameterized by a real number. This is typically the case when studying developmental biology, where animal models provide time changes of gene/protein activities
[<xref ref-type="bibr" rid="B9">9</xref>].</p>
    <p>• The model describes heterogeneous cell population behavior, because BKMC has a probabilistic interpretation. For example, modeling heterogeneous cell population can help understand tissue formation based on cell differentiation
[<xref ref-type="bibr" rid="B10">10</xref>].</p>
    <p>• The model can contain many nodes (up to 64 in the present implementation), because BKMC is a simulation algorithm that converges fast. This can be useful for big models that have already been modeled with a discrete time Boolean method
[<xref ref-type="bibr" rid="B11">11</xref>], in order to obtain a finer description of transient effects (see webpage for examples of published models:
<ext-link ext-link-type="uri" xlink:href="https://maboss.curie.fr">https://maboss.curie.fr</ext-link>).</p>
    <p>Previous published works have also introduced a continuous time approach in the Boolean framework(
[<xref ref-type="bibr" rid="B12">12</xref>-<xref ref-type="bibr" rid="B18">18</xref>]). In this article, we will first review some of these works and present BKMC algorithm. We will then describe the C++ software, MaBoSS, developed to implement BKMC algorithm and finally illustrate its use with three examples, a toy model, a published model of p53-MDM2 interaction and a published model of the mammalian cell cycle.</p>
    <p>All abbreviations, definitions, algorithms and estimates used in this article can be found in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>. Throughout the article, all terms that are italicized are defined in the Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Definitions”.</p>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <sec>
      <title>BKMC for continuous time Boolean model</title>
      <sec>
        <title>Continuous time in Boolean modeling: past and present</title>
        <p>In Boolean approaches for modeling networks, the state of each node of the network is defined by a Boolean value (node state) and the network state by the set of node states. Any dynamics in the transition graph is represented by sequences of network states. A node state is based on the sign of the input arrows and the logic that links them. The dynamics can be deterministic in the case of synchronized update
[<xref ref-type="bibr" rid="B1">1</xref>], or non-deterministic in the case of asynchronized update
[<xref ref-type="bibr" rid="B2">2</xref>] or probabilistic Boolean networks
[<xref ref-type="bibr" rid="B7">7</xref>].</p>
        <p>The difficulty to interpret the dynamics in terms of biological time has led to several works that have generalized Boolean approaches. These approaches can be divided in two classes that we call explicit and implicit time for discrete steps.</p>
        <p>The explicit time for discrete steps consists of adding a real parameter to each node state. These parameters correspond to the time associated to each node state before it flips to another one (
[<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>]). Because data about these time lengths are difficult to extract from experimental studies, some works have included noise in the definition of these parameters
[<xref ref-type="bibr" rid="B18">18</xref>]. The drawback of this method is that the computation of the Boolean model becomes sensitive to both the type of noise and the initial conditions. As a result, these time parameters become new parameters that need to be tuned carefully and thus add complexity to the modeling.</p>
        <p>The implicit time for discrete steps consists of adding a probability to each transition of the transition graph in the case of non-deterministic transitions (asynchronous case). It is argued that these probabilities could be interpreted as specifying the duration of a biological process. As an illustration, let us assume a small network of two nodes, A and B. At time t, A and B are inactive: [AB] = [00]. In the transition graph, there exist two possible transitions at t+1: [00] → [01] and [00] → [10]. If the first transition has a significant higher probability than the second one, then we can conclude that B will have a higher tendency to activate before A. Therefore, it is equivalent to say that the activation of B is faster than the activation of A. Thus, in this case, the notion of time is implicitly modeled by setting probability transitions. In particular, priority rules, in the asynchronous strategy, consist of putting some of these probabilities to zero
[<xref ref-type="bibr" rid="B6">6</xref>]. In our example, if B is faster than A then the probability of the transition [00] → [10] is zero. As a result, the prioritized nodes always activate before the others. From a different perspective but keeping the same idea, Vahedi and colleagues
[<xref ref-type="bibr" rid="B14">14</xref>] have set up a method to deduce explicitly these probabilities from the duration of each discrete step. With the implementation of implicit time in a Boolean model, the dynamics remains difficult to interpret in terms of biological time.</p>
        <p>As an alternative to these approaches, we propose BKMC algorithm.</p>
      </sec>
      <sec>
        <title>Properties of BKMC algorithm</title>
        <p>BKMC algorithm was built such as to meet the following principles: </p>
        <p>• The state of each node is given by a Boolean number (0 or 1), referred to as node state;</p>
        <p>• The state of the network is given by the set of node states, referred to as network state;</p>
        <p>• The update of a node state is based on the signs linking the incoming arrows of this node and the logic;</p>
        <p>• Time is represented by a real number;</p>
        <p>• Evolution is stochastic.</p>
        <p>We choose to describe the time evolution of network states by a Markov process with continuous time, applied to the asynchronous transition graph. Therefore, the dynamics is defined by transition rates inserted in a master equation (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1).</p>
      </sec>
      <sec>
        <title>Markov process for Boolean model</title>
        <p>Consider a network of <italic>n</italic> nodes (or agents, that can represent any species, <italic>i.e.</italic> mRNA, proteins, complexes, <italic>etc.</italic>). In a Boolean framework, the network state of the system is described by a vector <bold>S</bold> of Boolean values, <italic>i.e.</italic><italic>S</italic><sub><italic>i</italic></sub>∈{0,1},<italic>i </italic>= 1,…,<italic>n</italic> where <italic>S</italic><sub><italic>i</italic></sub> is the state of the node <italic>i</italic>. The set of all possible network states, also referred to as the network state space, will be called Σ.</p>
        <p>A stochastic description of the state evolution is represented by a <italic>stochastic process</italic><italic>s</italic>:<italic>t </italic>↦<italic> s</italic>(<italic>t</italic>) defined on
<inline-formula><mml:math id="M1" name="1752-0509-6-116-i1" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo>⊂</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:math></inline-formula> applied on the network state space, where <italic>I</italic> is an interval: for each time
<inline-formula><mml:math id="M2" name="1752-0509-6-116-i2" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo>⊂</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:math></inline-formula>, <italic>s</italic>(<italic>t</italic>) represents a random variable applied on the network state space. Thus, the probability of these random variables is written as: </p>
        <p>
          <disp-formula id="bmcM1">
            <label>(1)</label>
            <mml:math id="M3" name="1752-0509-6-116-i3" overflow="scroll">
              <mml:mtable class="align" columnalign="right left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:mi>t</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="1em"/>
                    <mml:mo>∈</mml:mo>
                  </mml:mtd>
                  <mml:mtd class="align-2">
                    <mml:mo>[</mml:mo>
                    <mml:mn>0</mml:mn>
                    <mml:mo>,</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>]</mml:mo>
                    <mml:mspace width="0.3em"/>
                    <mml:mspace width="0.3em"/>
                    <mml:mtext>for any state</mml:mtext>
                    <mml:mspace width="0.3em"/>
                    <mml:mspace width="0.3em"/>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi>Σ</mml:mi>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mtext>with</mml:mtext>
                    <mml:munder>
                      <mml:mrow>
                        <mml:mo mathsize="big">∑</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mo>∈</mml:mo>
                        <mml:mi mathvariant="normal">Σ</mml:mi>
                      </mml:mrow>
                    </mml:munder>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:mi>t</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width=".45em"/>
                    <mml:mo>=</mml:mo>
                  </mml:mtd>
                  <mml:mtd class="align-2">
                    <mml:mn>1</mml:mn>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>Notice that for all <italic>t</italic>, <italic>s</italic>(<italic>t</italic>) are not independent, therefore
<inline-formula><mml:math id="M4" name="1752-0509-6-116-i4" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula>. From now on, we define
<inline-formula><mml:math id="M5" name="1752-0509-6-116-i5" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> as <italic>instantaneous probabilities</italic>. Since the instantaneous probabilities do not define the full stochastic process, all possible joint probabilities should also be defined.</p>
        <p>In order to simplify the stochastic process, Markov property is imposed. It can be expressed in the following way: “the conditional probabilities in the future, related to the present and the past, depend only on the present” (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1 for the mathematical definition). The formal definition of a <italic>Markov process</italic> is a stochastic process with the Markov property.</p>
        <p>Any Markov process can be defined by (see Van Kampen
[<xref ref-type="bibr" rid="B19">19</xref>], chapter IV): </p>
        <p>1. An initial condition: </p>
        <p>
          <disp-formula id="bmcM2">
            <label>(2)</label>
            <mml:math id="M6" name="1752-0509-6-116-i6" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mn>0</mml:mn>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mspace width="2.77695pt"/>
              <mml:mo>;</mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mi mathvariant="normal">Σ</mml:mi>
            </mml:math>
          </disp-formula>
        </p>
        <p>2. Conditional probabilities (of a single condition): </p>
        <p>
          <disp-formula id="bmcM3">
            <label>(3)</label>
            <mml:math id="M7" name="1752-0509-6-116-i7" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>t</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>|</mml:mo>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:mfenced>
              <mml:mspace width="2.77695pt"/>
              <mml:mo>;</mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>∈</mml:mo>
              <mml:mi mathvariant="normal">Σ</mml:mi>
              <mml:mspace width="2.77695pt"/>
              <mml:mo>;</mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>,</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mi>I</mml:mi>
              <mml:mo>;</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>&lt;</mml:mo>
              <mml:mi>t</mml:mi>
            </mml:math>
          </disp-formula>
        </p>
        <p>Concerning time, two cases can be considered: </p>
        <p>• If time is discrete: <italic>t </italic>∈<italic> I </italic>= {<italic>t</italic><sub>0</sub>,
<italic>t</italic><sub>1</sub>,⋯}, it can be shown that all possible conditional probabilities are function of transition probabilities
[<xref ref-type="bibr" rid="B20">20</xref>]:
<inline-formula><mml:math id="M8" name="1752-0509-6-116-i8" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula>. In that case, a Markov process is often named a Markov chain.</p>
        <p>• If time is continuous: <italic>t </italic>∈<italic> I </italic>= [<italic>a</italic>,
<italic>b</italic>], it can be shown that all possible conditional probabilities are function of <italic>transition rates</italic>[<xref ref-type="bibr" rid="B19">19</xref>]:
<inline-formula><mml:math id="M9" name="1752-0509-6-116-i9" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>∞</mml:mi><mml:mo>]</mml:mo></mml:math></inline-formula>.</p>
        <p>Notice that a discrete time Markov process can be derived from continuous time Markov process, and is called a <italic>Jump Process</italic> with the following transition probabilities: </p>
        <p>
          <disp-formula>
            <mml:math id="M10" name="1752-0509-6-116-i10" overflow="scroll">
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>≡</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:munder>
                    <mml:mrow>
                      <mml:mo>∑</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mo>∈</mml:mo>
                      <mml:mi mathvariant="normal">Σ</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
            </mml:math>
          </disp-formula>
        </p>
        <p>If the transition probabilities or transition rates are time independent, the Markov process is called a <italic>time independent Markov process</italic>. In BKMC, only this case will be considered. For a time independent Markov process, the <italic>transition graph</italic> can be defined as follows: a transition graph is a graph in Σ, with an edge between <bold>S</bold> and <bold>S</bold><sup><italic>′</italic></sup> if and only if
<inline-formula><mml:math id="M11" name="1752-0509-6-116-i11" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> (or
<inline-formula><mml:math id="M12" name="1752-0509-6-116-i12" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> if time is discrete).</p>
      </sec>
      <sec>
        <title>Asynchronous Boolean dynamics as a discrete time Markov process</title>
        <p>Asynchronous Boolean dynamics
[<xref ref-type="bibr" rid="B2">2</xref>] is widely used in Boolean modeling. It can be easily interpreted as a discrete time Markov process
[<xref ref-type="bibr" rid="B21">21</xref>,<xref ref-type="bibr" rid="B22">22</xref>] as shown below.</p>
        <p>In the case of asynchronous Boolean dynamics, the system is given by <italic>n</italic> nodes (or agents), with a set of directed arrows linking these nodes and defining a network. For each node <italic>i</italic>, a Boolean logic <italic>B</italic><sub><italic>i</italic></sub>(<bold>S</bold>) is specified and depends only on the nodes <italic>j</italic> for which there exists an arrow from node <italic>j</italic> to <italic>i</italic> (<italic>e.g.</italic><italic>B</italic><sub>1</sub> =<italic> S</italic><sub>3</sub> AND NOT<italic>S</italic><sub>4</sub>, where <italic>S</italic><sub>3</sub> and <italic>S</italic><sub>4</sub> are the Boolean values of nodes 3 and 4 respectively, and <italic>B</italic><sub>1</sub>is the Boolean logic of node 1). The notion of <italic>asynchronous transition</italic> (AT) can be defined as a pair of network states
<inline-formula><mml:math id="M13" name="1752-0509-6-116-i13" overflow="scroll"><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:math></inline-formula>, written
<inline-formula><mml:math id="M14" name="1752-0509-6-116-i14" overflow="scroll"><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math></inline-formula> such that </p>
        <p>
          <disp-formula id="bmcM4">
            <label>(4)</label>
            <mml:math id="M15" name="1752-0509-6-116-i15" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>=</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>B</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mspace width="0.3em"/>
                    <mml:mtext>for a given</mml:mtext>
                    <mml:mspace width="0.3em"/>
                    <mml:mi>j</mml:mi>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>=</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mspace width="0.3em"/>
                    <mml:mtext>for</mml:mtext>
                    <mml:mspace width="0.3em"/>
                    <mml:mi>i</mml:mi>
                    <mml:mo>≠</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>To define a Markov process, the transition probabilities
<inline-formula><mml:math id="M16" name="1752-0509-6-116-i16" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula> can be defined: given two network states <bold>S</bold> and <bold>S</bold><sup><italic>′</italic></sup>, let <italic>γ</italic>(<bold>S</bold>) be the number of asynchronous transitions from <bold>S</bold> to all possible states <bold>S</bold><sup><italic>′</italic></sup>. Then </p>
        <p>
          <disp-formula id="bmcM5">
            <label>(5)</label>
            <mml:math id="M17" name="1752-0509-6-116-i17" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="-6.0pt"/>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>|</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>/</mml:mo>
                    <mml:mi>γ</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>if</mml:mtext>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>→</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>is an AT</mml:mtext>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="-6.0pt"/>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>|</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mo>=</mml:mo>
                    <mml:mn>0</mml:mn>
                    <mml:mtext>if</mml:mtext>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>→</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>is not an AT</mml:mtext>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>In this formalism, the asynchronous Boolean dynamics completely defines a discrete time Markov process when the initial condition is specified. Notice that here the transition probabilities are time independent, <italic>i.e.</italic><inline-formula><mml:math id="M18" name="1752-0509-6-116-i18" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula>. Therefore, the approaches, mentioned in section “Continuous time in Boolean modeling: past and present”, that introduce time implicitly by adding probabilities to each transition of the transition graph, can be seen as a generalization of the definition of <italic>γ</italic>(<bold>S</bold>).</p>
      </sec>
      <sec>
        <title>Continuous time Markov process as a generalization of asynchronous Boolean dynamics</title>
        <p>To transform the discrete time Markov process described above in a continuous time Markov process, transition probabilities should be replaced by transition rates
<inline-formula><mml:math id="M19" name="1752-0509-6-116-i19" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>. In that case, conditional probabilities are computed by solving a master equation (equation 2 in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1). We present below the corresponding numerical algorithm, the <italic>Kinetic Monte-Carlo</italic> algorithm
[<xref ref-type="bibr" rid="B23">23</xref>].</p>
        <p>Because we want a generalization of the asynchronous Boolean dynamics, transition rates
<inline-formula><mml:math id="M20" name="1752-0509-6-116-i20" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula> are non-zero <underline>only if</underline><bold> S</bold> and <bold>S</bold><sup><italic>′</italic></sup> differ by only one node. In that case, each Boolean logic <italic>B</italic><sub><italic>i</italic></sub>(<bold>S</bold>)is replaced by two functions
<inline-formula><mml:math id="M21" name="1752-0509-6-116-i21" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mtext>up/down</mml:mtext></mml:mrow></mml:msubsup><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>∞</mml:mi><mml:mo>[</mml:mo></mml:math></inline-formula>. The transition rates are defined as follows: if <italic>i</italic> is the node that differs from <bold>S</bold> and <bold>S</bold><sup><italic>′</italic></sup>, then </p>
        <p>
          <disp-formula id="bmcM6">
            <label>(6)</label>
            <mml:math id="M22" name="1752-0509-6-116-i22" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>ρ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mo>→</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">up</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>if</mml:mtext>
                    <mml:mspace width=".3em"/>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:mn>0</mml:mn>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>ρ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mo>→</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mtext>down</mml:mtext>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>if</mml:mtext>
                    <mml:mspace width=".3em"/>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>R</italic><sub><italic>i</italic></sub><sup>up</sup> corresponds to the activation rate of node <italic>i</italic>, and <italic>R</italic><sub><italic>i</italic></sub><sup>down</sup> corresponds to the inactivation rate of node <italic>i</italic>. Therefore, the continuous Markov process is completely defined by all these <italic>R</italic><sup>up/down</sup> and an initial condition.</p>
      </sec>
      <sec>
        <title>Asymptotic behavior of continuous time Markov process</title>
        <p>In the case of continuous time Markov process, instantaneous probabilities always converge to a stationary distribution (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 2, section 1.2). A <italic>stationary distribution</italic> of a given Markov process corresponds to the set of instantaneous probabilities of a stationary Markov process which has the same transition probabilities (or transition rates) as the given discrete (or continuous) time Markov process. A <italic>stationary Markov process</italic> has the following property: for every joint probability
<inline-formula><mml:math id="M23" name="1752-0509-6-116-i23" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow></mml:mfenced></mml:math></inline-formula> and ∀<italic>τ</italic>: </p>
        <p>
          <disp-formula id="bmcM7">
            <label>(7)</label>
            <mml:math id="M24" name="1752-0509-6-116-i24" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1"/>
                  <mml:mtd class="align-2">
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mo>…</mml:mo>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1"/>
                  <mml:mtd class="align-2">
                    <mml:mspace width="2.77695pt"/>
                    <mml:mspace width="2.77695pt"/>
                    <mml:mo>=</mml:mo>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>+</mml:mo>
                        <mml:mi>τ</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>+</mml:mo>
                        <mml:mi>τ</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mo>…</mml:mo>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>Notice that instantaneous probabilities
<inline-formula><mml:math id="M25" name="1752-0509-6-116-i25" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> of a stationary stochastic process are time independent.</p>
        <p>The asymptotic behavior of a continuous time Markov process can be detailed by using the concept of <italic>indecomposable stationary distributions</italic>: indecomposable stationary distributions are stationary distributions that cannot be expressed as a linear combination of different stationary distributions. A linear combination of stationary distributions is also a stationary distribution, since instantaneous probabilities are solutions of a master equation which is linear (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 2, section 1.1). Therefore, a complete description of the asymptotic behavior is given by the linear combination of indecomposable stationary distributions to which the Markov process converges.</p>
      </sec>
      <sec>
        <title>Oscillations and cycles</title>
        <p>In order to describe a periodic behavior, the notion of cycle and oscillation for a continuous time Markov process is defined precisely.</p>
        <p>A <italic>cycle</italic> is a loop in the transition graph. This is a topological characterization in the transition graph that does not depend on the exact value of the transition rates. It can be shown that a cycle with no outgoing edges corresponds to an indecomposable stationary distribution (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 1, section 1.2).</p>
        <p>The question is then to link the notion of cycle to that of periodic behavior of instantaneous probabilities. The set of instantaneous probabilities cannot be perfectly periodic. They can display a damped oscillating behavior, or none at all (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.3). A <italic>damped oscillatory</italic> Markov process can be formally defined as a continuous time process that has at least one instantaneous probability with an infinite number of extrema.</p>
        <p>According to theorems described in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref> (“Basic information on Markov process”, theorems 6-8 and Corollary 3, section 1.3), a necessary condition for having damped oscillations is that the transition matrix has at least one non-real eigenvalue (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 4, section 1.1). In that case, there always exists an initial condition that produces damped oscillations. For the transition matrix to have a non-real eigenvalue, a Markov process needs to have a cycle. However, the reverse is not true: a Markov process with a cycle does not necessarily imply the existence of a non-real eigenvalue in the transition matrix. In the toy model of a single cycle, presented in the “Examples” section, non-real eigenvalues may or may not exist, according to different values of transition rates.</p>
      </sec>
      <sec>
        <title>BKMC: Kinetic Monte-Carlo (Gillespie algorithm) applied to continuous time asynchronous Boolean Dynamics</title>
        <p>It has been previously stated that a continuous time Markov process is completely defined by its initial condition and its transition rates. For computing any conditional probability (and any joint probability), a set of linear differential equations has to be solved (the master equation). Theoretically, the master equation can be solved exactly by computing the exponential of the transition matrix (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 5, section 1.1). However, because the size of this transition matrix is 2<sup><italic>n</italic></sup>×2<sup><italic>n</italic></sup>, the computation soon becomes impossible if <italic>n</italic> is large. To remedy this problem, it is possible to use a simulation algorithm that samples the probability space by computing time trajectories in the transition graph.</p>
        <p>The Kinetic Monte-Carlo
[<xref ref-type="bibr" rid="B23">23</xref>] (or Gillespie algorithm
[<xref ref-type="bibr" rid="B24">24</xref>]) is a simple algorithm for exploring the probability space of a Markov process defined by a set of transition rates. In fact, it can be understood as a formal definition of a continuous time Markov process. This algorithm produces a set of <italic>realizations</italic> or <italic>stochastic trajectories</italic> of the Markov process, given a set of uniform random numbers in [0,1]. By definition, a trajectory
<inline-formula><mml:math id="M26" name="1752-0509-6-116-i26" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> is a function from a time window [0,<italic>t</italic><sub>max</sub> to Σ. The set of stochastic trajectories represents the given Markov process in the sense that these trajectories can be used to compute probabilities. A finite set of these trajectories is produced, then, from this finite set, probabilities are estimated (as described in “Methods” section). The algorithm is based on an iterative step: from a state <bold>S</bold> at time <italic>t</italic><sub>0</sub>(given two uniform random numbers), it produces a transition time <italic>δt</italic> and a new state
<inline-formula><mml:math id="M27" name="1752-0509-6-116-i27" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>, with the following interpretation: the trajectory
<inline-formula><mml:math id="M28" name="1752-0509-6-116-i28" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> is such that
<inline-formula><mml:math id="M29" name="1752-0509-6-116-i29" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:math></inline-formula> for <italic>t</italic>∈<italic>t</italic><sub>0</sub><italic>t</italic><sub>0</sub> + <italic>δt</italic> and
<inline-formula><mml:math id="M30" name="1752-0509-6-116-i30" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>δt</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. Iteration of this step is done until a specified maximum time is reached. The initial state of each trajectory is based on the (probabilistic) initial condition that also needs to be specified.</p>
        <p>The exact iterative procedure is the following. Given <bold>S</bold> and two uniform random numbers <italic>u</italic>,<italic>u</italic><sup><italic>′</italic></sup>∈[0,1]: </p>
        <p>1. Compute the total rate of possible transitions for leaving state <bold>S</bold>:
<inline-formula><mml:math id="M31" name="1752-0509-6-116-i31" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mtext>tot</mml:mtext></mml:mrow></mml:msub><mml:mo>≡</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
        <p>2. Compute the time of the transition:
<inline-formula><mml:math id="M32" name="1752-0509-6-116-i32" overflow="scroll"><mml:mi>δt</mml:mi><mml:mo>≡</mml:mo><mml:mo>−</mml:mo><mml:mo>log</mml:mo><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mtext>tot</mml:mtext></mml:mrow></mml:msub></mml:math></inline-formula></p>
        <p>3. Order the possible new states
<inline-formula><mml:math id="M33" name="1752-0509-6-116-i33" overflow="scroll"><mml:msup><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mspace width="0.3em"/></mml:math></inline-formula> and their respective transition rates
<inline-formula><mml:math id="M34" name="1752-0509-6-116-i34" overflow="scroll"><mml:msup><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo mathvariant="bold">(</mml:mo><mml:mi mathvariant="bold">j</mml:mi><mml:mo mathvariant="bold">)</mml:mo></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
        <p>4. Compute the new state
<inline-formula><mml:math id="M35" name="1752-0509-6-116-i35" overflow="scroll"><mml:msup><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> such that
<inline-formula><mml:math id="M36" name="1752-0509-6-116-i36" overflow="scroll"><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mtext>tot</mml:mtext></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>≤</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> (by convention, <italic>ρ</italic><sup>(0)</sup>=0).</p>
        <p>This algorithm will be referred to as <italic>Boolean Kinetic Monte-Carlo</italic> or BKMC.</p>
      </sec>
    </sec>
    <sec>
      <title>Practical use of BKMC, through MaBoSS tool</title>
      <p>Biological data are translated into an influence network with logical rules associated to each node of the network. The value of one node depends on the value of the input nodes. For BKMC, another layer of information is provided when compared to the standard definition of Boolean models: transition rates are provided for all nodes, specifying the rates at which the node turns on and off. This refinement conserves the simplicity of Boolean description but allows to reproduce more accurately the observed biological dynamics. The parameters do not need to be exact as it is the case for nonlinear ordinary differential equation models, but they can be used to illustrate the relative speed of reactions. We developed a software tool, MaBoSS, that applies BKMC algorithm. MaBoSS stands for Markov Boolean Stochastic Simulator.</p>
      <sec>
        <title>How to build a mathematical model using MaBoSS</title>
        <p>Once MaBoSS is installed (see webpage for instructions,
<ext-link ext-link-type="uri" xlink:href="https://maboss.curie.fr">https://maboss.curie.fr</ext-link>), the protocol to follow to simulate a model can be described in four steps: </p>
        <p>1. Create the model using MaBoSS language in a file (myfile.bnd, for instance): (a) write the logic for each node, and (b) assign values to each transition rate.</p>
        <p>2. Create the configuration file (myfile.cfg, for instance) to define the simulation parameters.</p>
        <p>3. Run MaBoSS (the order of the arguments does not matter):</p>
        <p>
          <monospace>MaBoSS -c myfile.cfg -o myfile_out myfile.bnd</monospace>
        </p>
        <p>(we assume that MaBoSS is accessible through you PATH).MaBoSS creates three output files: </p>
        <p>• <monospace>myfile_out_proptraj.csv</monospace></p>
        <p>This file contains the network state probabilities on a time window, the entropy, the transition entropy and the Hamming distance distribution (see “Methods”)</p>
        <p>• <monospace>myfile_out_statdist.csv</monospace></p>
        <p>This file contains the stationary distribution characterization (see “Methods”)</p>
        <p>• <monospace>myfile_out_run.txt</monospace></p>
        <p>This file contains a summary of MaBoSS simulation run.</p>
        <p>4. Import output csv files in Excel or R and generate your graphs.</p>
      </sec>
      <sec>
        <title>Transition rates in MaBoSS</title>
        <p>MaBoSS defines transition rates
<inline-formula><mml:math id="M37" name="1752-0509-6-116-i37" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula> by the functions <italic>R</italic><sub><italic>i</italic></sub><sup>up/down</sup> (<bold>S</bold>) (see equations 6). The functions can be written using all Boolean operators (AND, OR, NOT, XOR), arithmetic operators (+,-,*,/), comparison operators and the conditional operator (?:). Examples of the use of the language are given below to illustrate three different cases: (1) different speeds for different inputs, (2) buffering effect and (3) the translation of discrete variables (with three values: 0, 1 and 2) into a Boolean model. </p>
        <p>1. Modeling different speeds for different inputs.Suppose that C is activated by A or B, but that B can activate C faster than A, and that C is inactivated when A and B are absent. In this case, we write: </p>
        <p>
          <monospace>node C {</monospace>
        </p>
        <p>
          <monospace> rate_up = B ? $kb : (A ? $ka : 0.0);</monospace>
        </p>
        <p>
          <monospace> rate_down = !(A &amp; B ) ? 1.0 : 0.0;</monospace>
        </p>
        <p> }</p>
        <p> When C is off (equal to 0), it is activated by B at a speed $kb. If B is absent, then C is activated by A at a speed $ka. If both are absent, C is not activated. Note that if both A and B are present, because of the way the logic is written in this particular case, C is activated at the highest speed, the speed $kb. When C is on (equal to 1), it is inactivated at a rate equal to 1 in the absence of both A and B.</p>
        <p> To implement the synergistic effect of A and B, <italic>i.e.</italic> when both A and B are on, C is activated at a rate $kab, then we can write:</p>
        <p>
          <monospace>node C {</monospace>
        </p>
        <p>
          <monospace>rate_up = (A &amp; !B ? $ka : 0.0)+(B &amp; !A ? $kb : 0.0) + (A &amp; B ? $kab : 0.0);</monospace>
        </p>
        <p>
          <monospace> rate_down = !(A &amp; B ) ? 1.0 : 0.0;</monospace>
        </p>
        <p> }</p>
        <p>2. Modeling buffering effect.Suppose that B is activated by A, but that B can remain active a long time after A has shut down. For that, it is enough to define different speeds of activation and inactivation:</p>
        <p>
          <monospace>node B {</monospace>
        </p>
        <p>
          <monospace>rate_up = A ? 2.0 : 0.0;</monospace>
        </p>
        <p>
          <monospace>rate_down = A ? 0.0 : 0.001;</monospace>
        </p>
        <p>}</p>
        <p> B is activated by A at a rate equal to 2. When A is turned off, B is inactivated more slowly at a rate equal to 0.001.</p>
        <p>3. Modeling different levels for a given node.Suppose that B is activated by A, but if the activity of A is maintained, B can reach a second level. For this, we define a second node B_h (for “B high”) with the following rules:</p>
        <p>
          <monospace>node B {</monospace>
        </p>
        <p>
          <monospace>rate_up = A ? 1.0 : 0.0; </monospace>
        </p>
        <p>
          <monospace>rate_down = (A | B_h) ? 0.0 : 1.0;</monospace>
        </p>
        <p>}</p>
        <p>
          <monospace>node B_h {</monospace>
        </p>
        <p>
          <monospace>rate_up = (A &amp; B) ? 1.0 : 0.0;</monospace>
        </p>
        <p>
          <monospace>rate_down = (A) ? 0.0 : 1.0;</monospace>
        </p>
        <p>}</p>
        <p> In this example, B is separated in two variables: B which corresponds to the first level of B and B_h which corresponds to the higher level of B. B is activated by A at a rate equal to 1. If A disappears before B has reached its second level B_h then B is turned off at a rate equal to 1. If A is maintained and B is active, then B_h is activated at a rate equal to 1. When A is turned off, B_h is inactivated at a rate equal to 1.</p>
      </sec>
      <sec>
        <title>Simulation parameters in MaBoSS</title>
        <p>To simulate a model in MaBoSS, a set of parameters needs to be adjusted (see “Parameter list” in the reference card available in the webpage). MaBoSS assigns default values, however, they need to be tuned for each model to achieve optimal performances: the best balance between the convergence of estimates and the computation time needs to be found. Therefore, several simulations should be run with different sets of parameters for best tuning. </p>
        <p>• Internal nodes: <italic>node.is_internal</italic>As explained in “Methods” (in “Initial conditions and outputs”), internal nodes correspond to species that are not measured explicitly. Practically, the higher the number of internal nodes, the better the convergence of the BKMC algorithm.</p>
        <p>• Time window for probabilities: <italic>timetick</italic>This parameter is used to compute estimates of network state probabilities (see “Network state probabilities on a time window” in “Methods”). A time window can be set as the minimum time needed for nodes to change their states. This parameter also controls the convergence of probability estimates. The larger the time window, the better the convergence of probability estimates.</p>
        <p>• Maximum time: <italic>max_time</italic>MaBoSS produces trajectories for a predefined amount of time, set by the parameter max_time. If the time of the biological process is known, then the maximum time parameter can be explicitly set. If the time of the biological process is not known, then there exists a more empirical way to set the maximum time. It is advised to choose a maximum time parameter that is slightly bigger than the inverse of the smallest transition rate.Note that the computing time in MaBoSS is proportional to this maximum time. Moreover, the choice of the maximum time impacts the stationary distribution estimates: a longer maximum time increases the quality of these estimates.</p>
        <p>• Number of trajectories: <italic>sample_count</italic>This parameter directly controls the quality of BKMC estimation algorithm. Practically, the convergence of the estimates increases as the number of trajectories is increased.</p>
        <p>• Number of trajectories (<italic>statdist_traj_count</italic>) and similarity threshold (<italic>statsdist_cluster_threshold</italic>) for stationary distribution estimatesThe <italic>statdist_traj_count</italic> parameter corresponds to a subset of trajectories used only for stationary distribution estimates. To avoid explosion of computing time, this parameter needs to be lower than the number of trajectories (rather than equal to).The <italic>statsdist_cluster_threshold</italic> parameter corresponds to the threshold for constructing the clusters of stationary distribution estimates. Ideally, it should be set to a high value (close to 1). However, if the threshold is too high then the clustering algorithm might not be efficient.</p>
      </sec>
      <sec>
        <title>Comparison with biological data</title>
        <p>Each node of the network should account for different levels of activity of the corresponding species (mRNA, protein, protein complex, etc.). It is possible to have more than two levels for one node, as shown in the example “Modeling different levels for a given node”.</p>
        <p>It is possible to extract the transition rates from experimental data, using the following property: the rate of a given transition is the inverse of the mean time for this transition to happen. It should be noticed than BKMC is an algorithm based on a linear equation (Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 2, section 1.1); therefore, small variations of transition rates will not affect the qualitative behavior of the model.</p>
        <p>BKMC algorithm provides estimates of the network state probabilities over time. These probabilities can be interpreted in terms of a cell population. The asymptotic behavior of a model, represented by a linear combination of indecomposable stationary distributions, can be interpreted as a combination of cell sub-populations. Indeed, a sub-population can be defined by network states with non-zero probability in the indecomposable stationary distribution. Therefore, a cell in a sub-population can only evolved in this sub-population (Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 1, section 1.2 and from the definition of strongly connected component with no outgoing edges).</p>
      </sec>
      <sec>
        <title>Comparison of MaBoSS with other existing tools for qualitative modeling</title>
        <p>MaBoSS contributes to the effort of tool development for qualitative modeling of biological networks. We propose to compare MaBoSS to some existing tools. However, it is difficult to compare the performance of these tools since each of them achieves different purposes and provides different outputs. As an alternative, we recapitulate, in Figure
<xref ref-type="fig" rid="F1">1</xref>, the characteristics and implications for each software. Some tools may be more appropriate than others according to the type of input, network size and expected output. Figure
<xref ref-type="fig" rid="F1">1</xref> is intended to help the users decide which software to use in a practical situation. We consider the following tools: GINsim
[<xref ref-type="bibr" rid="B8">8</xref>], CellNetAnalyzer
[<xref ref-type="bibr" rid="B25">25</xref>], BoolNet
[<xref ref-type="bibr" rid="B26">26</xref>], GNA
[<xref ref-type="bibr" rid="B27">27</xref>], and SQUAD
[<xref ref-type="bibr" rid="B28">28</xref>]. This list is not exhaustive but informs on where MaBoSS stands.</p>
        <fig id="F1" position="float">
          <label>Figure 1</label>
          <caption>
            <p><bold>Comparison of tools for discrete modeling, biological implication.</bold> Comparison table of the following tools: MaBoSS, GINsim, CellNetAnalyzer, BoolNet, GNA, SQUAD. Technical aspects are provided, along with the inputs/outputs relations between a model and data. The last row illustrates graphically the typical outputs that can be obtained from each tool.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-1"/>
        </fig>
        <p>As an illustration, the third example of the “Examples” section below, the mammalian cell cycle, was implemented in three of the tools presented in Figure
<xref ref-type="fig" rid="F1">1</xref>: MaBoSS, GINsim, BoolNet (see Additional file
<xref ref-type="supplementary-material" rid="S2">2</xref> “Model of the mammalian cell cycle with GINsim, BoolNet and MaBoSS.” for details of the results).</p>
      </sec>
    </sec>
    <sec>
      <title>Examples</title>
      <p>We have applied BKMC algorithm to three models of different sizes. The first one is a toy model illustrating the dynamics of a single cycle; the second one is a published Boolean model of p53-Mdm2 response to DNA damage and illustrates a multi-level case; and the third one is a published Boolean model of mammalian cell cycle regulation. Note that MaBoSS has been used for these three examples, but Markov process can be computed directly for the two first ones, without our BKMC algorithm because these models are small enough (by computing exponential of transition matrix, see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1), as proposed in
[<xref ref-type="bibr" rid="B16">16</xref>]. BKMC is best suited for larger networks, when the network state space is too large to be computed with standard existing tools (&gt;∼2<sup>10</sup>). The first two examples were chosen for their simplicity, and because they illustrate how global characterizations (entropy and transition entropy, see “Entropiesł::bel sect:entropies” in “Methods”) can be used. The third example shows the use of BKMC/MaBoSS for a more consequent and complex model for which the analysis is not obvious.</p>
      <p>For the purpose of this article, we built the transition graphs for the first two examples (with GINsim
[<xref ref-type="bibr" rid="B8">8</xref>]) in order to help the reasoning. However, it is important to note that BKMC algorithm does not construct the transition graph explicitly.</p>
      <p>All input files and results are given in the webpage of MaBoSS (
<ext-link ext-link-type="uri" xlink:href="https://maboss.curie.fr">https://maboss.curie.fr</ext-link>) with additional examples.</p>
      <sec>
        <title>Toy model of a single cycle</title>
        <p>We consider three species, A, B and C, where A is activated by C and inhibited by B, B is activated by A and C is activated by A or B (Figure
<xref ref-type="fig" rid="F2">2</xref>a).</p>
        <fig id="F2" position="float">
          <label>Figure 2</label>
          <caption>
            <p><bold>Toy model.</bold> Toy model of a single cycle. <bold>(a)</bold> Influence network. <bold>(b)</bold> Logical rules and transition rates of the model. <bold>(c)</bold> Simulation parameters.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-2"/>
        </fig>
        <p>The model is defined within the language of MaBoSS by a set of logical rules associated to each node (Figure
<xref ref-type="fig" rid="F2">2</xref>b) and simulation parameters set for optimal performances (Figure
<xref ref-type="fig" rid="F2">2</xref>c). The associated transition graph, generated by GINsim, is shown in Figure
<xref ref-type="fig" rid="F3">3</xref>.</p>
        <fig id="F3" position="float">
          <label>Figure 3</label>
          <caption>
            <p><bold>Transition graph of the toy model.</bold> Transition graph for the toy model (generated by GINsim). The node states should be read as [ABC] = [<sup>∗∗∗</sup>]. [ABC]=[100] corresponds to a state in which only A is active. The nodes in green belong to a cycle, the node in red is the fixed point and the other nodes are in blue.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-3"/>
        </fig>
        <p>The only stationary distribution is the fixed point [ABC]=[000]. We study two cases: when the rate of the transition from state [001] to state [000] (corresponding to the inactivation of C) is fast and when this rate is slow. We will refer to this transition rate as the <italic>escape rate</italic>. For both cases, we plot the time trajectories of the probabilities of the fixed point [ABC]=[000] and of the probabilities of A active [ABC]=[1<sup>∗∗</sup>] where <sup>∗</sup>can be either 1 or 0, along with the trajectories of the entropy and the transition entropy.</p>
        <p>In the first case, when the escape rate is fast, we set the parameter for the transition to a high value (rate_up = 10). In Figure
<xref ref-type="fig" rid="F4">4</xref>, we notice that the probability that [ABC] is equal to [000] converges to 1. We can conclude that [ABC]=[000] is a fixed point. In addition, the entropy and the transition entropy converge to 0. With BKMC, these properties confirm that [ABC]=[000] is a fixed point. The peak in the trajectory of the entropy (between times 0 and 0.6) corresponds to a set of states that are transiently activated before reaching the fixed point.</p>
        <fig id="F4" position="float">
          <label>Figure 4</label>
          <caption>
            <p><bold>MaBoSS outputs of the toy model with fast escape rate.</bold> BKMC algorithm is applied to the toy model, with a fast escape rate. Trajectory of the network state probabilities [ABC]=[000] and [ABC]=[1<sup>∗∗</sup>] (where <sup>∗</sup>can be either 0 or 1), the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted. Because the probability of [ABC]=[000] converges to 1, [ABC]=[000] is a fixed point. The asymptotic behavior of both the entropy and the transition entropy is also the signature of a fixed point.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-4"/>
        </fig>
        <p>In the second case, when the escape rate is slow, we set the parameter for the transition to a low value (rate_down = 10<sup>−5</sup>). As illustrated in Figure
<xref ref-type="fig" rid="F5">5</xref>, the transition entropy is and remains close to zero but the entropy does not converge to zero, which is the signature of a cyclic stationary distribution (see “Entropiesł::bel sect:entropies” in “Methods”). This corresponds to the cycle [111] → [011] → [001] → [101] in the transition graph (Figure
<xref ref-type="fig" rid="F3">3</xref>). However, as seen in the transition graph, one state in the cycle has an outgoing edge that leads to the fixed point (through the transition [001] → [000] in Figure
<xref ref-type="fig" rid="F3">3</xref>). If the trajectories are plotted on a larger time scale (Figure
<xref ref-type="fig" rid="F6">6</xref>), the entropy eventually converges to 0 and the trajectory of the fixed point converges to 1, which corresponds to the case of fast escape rate. Since the value of the transition entropy of Figure
<xref ref-type="fig" rid="F5">5</xref> is not exactly zero, but 10<sup>−4</sup>, it can be anticipated that the cyclic behavior is not stable. We can conclude on stable cyclic behaviors only when the transition entropy is exactly 0.</p>
        <fig id="F5" position="float">
          <label>Figure 5</label>
          <caption>
            <p><bold>MaBoSS outputs of the toy model with slow escape rate.</bold> BKMC algorithm is applied to the toy model, with a slow escape rate. Trajectory of the network state probabilities [ABC]=[000] and [ABC]=[1**], the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted. The asymptotic behavior of both the entropy and the transition entropy seems to be the signature of a cycle.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-5"/>
        </fig>
        <fig id="F6" position="float">
          <label>Figure 6</label>
          <caption>
            <p><bold>MaBoSS outputs of toy model with slow escape rate, large time scale.</bold> BKMC algorithm is applied to the toy model, with a slow escape rate, plotted on a larger time scale. Trajectory of probabilities ([ABC]=[000] and [ABC]=[1**]), the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted. On a large time scale, the asymptotic behavior of both the entropy and the transition entropy is similar to the case of the fast escape rate (Figure
<xref ref-type="fig" rid="F3">3</xref>).</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-6"/>
        </fig>
        <p>By considering the spectrum of the transition matrix (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1 and proof of theorem 4), it can be proven that the model with a slow escape rate is a damped oscillatory process whereas the model with a large escape rate is not. As mentioned previously, a cycle in the transition graph may or may not lead to an oscillatory behavior. Moreover, if the transition entropy seems to converge to a small value on a small time scale, and the entropy does not, this behavior illustrates the case of a transient cycle in the transition graph.</p>
      </sec>
      <sec>
        <title>p53-Mdm2 signaling</title>
        <p>We consider a model of p53 response to DNA damage
[<xref ref-type="bibr" rid="B18">18</xref>]. p53 interacts with Mdm2, which appears in two forms, cytoplasmic and nuclear. On one hand, p53 upregulates the level of cytoplasmic Mdm2 (Mdm2c), which is then transported into the nucleus, and inhibits the export of nuclear Mdm2 (Mdm2n). On the other hand, nuclear Mdm2 (Mdm2n) facilitates the degradation of p53 through ubiquitination. In the model, stress regulates the level of DNA damage (Dam), which in turn participates in the degradation process of Mdm2 in the nucleus. p53 inhibits DNA damage signal by promoting DNA repair. Here, stress is not shown explicitly (Figure
<xref ref-type="fig" rid="F7">7</xref>a).</p>
        <fig id="F7" position="float">
          <label>Figure 7</label>
          <caption>
            <p><bold>Model of p53 response to DNA damage.</bold> Model of p53 response to DNA damage. <bold>(a)</bold> Influence network. <bold>(b)</bold> Logical rules and transition rates of the model. <bold>(c)</bold> Simulation parameters.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-7"/>
        </fig>
        <p>The model is written in MaBoSS, with two levels of p53 (Figure
<xref ref-type="fig" rid="F7">7</xref>b), as it is done in Abou-Jaoudé <italic>et al.</italic>[<xref ref-type="bibr" rid="B18">18</xref>] with the appropriate simulation parameters (Figure
<xref ref-type="fig" rid="F7">7</xref>c). The associated transition graph, also generated by GINsim, is given in Figure
<xref ref-type="fig" rid="F8">8</xref>. It shows the existence of two cycles and of a fixed point [p53 Mdm2C Mdm2N Dam] = [0010] where nuclear Mdm2 is on and the rest is off.</p>
        <fig id="F8" position="float">
          <label>Figure 8</label>
          <caption>
            <p><bold>Transition graph of the model of p53 response to DNA damage.</bold> Transition graph of the p53 model (generated by GINsim). The node states should be read as [p53 Mdm2C Mdm2N Dam] = [<sup>∗∗∗∗</sup>] (where <sup>∗</sup>can be either 0 or 1). For instance, [p53 Mdm2C Mdm2N Dam]=[1000] corresponds to a state in which only p53 (at its level 1) is active. The nodes in green and the nodes in light blue belong to two cycles, the node in red is the fixed point and the other nodes are in dark blue.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-8"/>
        </fig>
        <p>In order to represent the activity of p53, the trajectories of the probabilities of all network states with p53 equal to 1 and with p53 equal to 2 are plotted (Figure
<xref ref-type="fig" rid="F9">9</xref>, upper panel), with the initial condition: [p53 Mdm2C Mdm2N Dam] = [0<sup>∗</sup>11] and for the situation when p53 is set to its highest value (2 equivalent to p53_h) and thus can promote Mdm2 cytoplasmic activity.</p>
        <fig id="F9" position="float">
          <label>Figure 9</label>
          <caption>
            <p><bold>MaBoSS outputs of the model of p53 response to DNA damage.</bold> Trajectories of the network state probabilities of [p53 Mdm2C Mdm2N Dam] = [1<sup>∗∗∗</sup>] and of [p53 Mdm2C Mdm2N Dam] = [2<sup>∗∗∗</sup>], the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-9"/>
        </fig>
        <p>The qualitative results obtained with MaBoSS are similar to those of Abou-Jaoudé and colleagues. However, at the level of cell population, some discrepancies appear: in Figure
<xref ref-type="fig" rid="F9">9</xref>, no damped oscillations can be seen as opposed to Figure
<xref ref-type="fig" rid="F8">8</xref> of their article. The reason is that, in their computations, the noise imposed on time is defined by a square distribution on a limited time frame, whereas in BKMC, Markovian hypotheses imply that the noise distribution is more spread out from 0 to infinity. The consequence is that synchronization is lost very fast. Damped oscillations could be observed with BKMC with a particular set of parameters: fast activation of p53 and slow degradation of p53 (results not shown).</p>
        <p>With MaBoSS, we clearly interpret the system as a population and not as a single cell. In addition, we can simulate different contexts, presented in the initial article as different models, within one single model that uses different simulation parameters to account for these contexts.</p>
        <p>Note that the existence of transient cycles, as shown in the toy model, can be deduced from the trajectory of the entropy that is significantly higher than the trajectory of the transition entropy (which is non-zero, therefore the transient cycles are not stable) (Figure
<xref ref-type="fig" rid="F9">9</xref>, lower panel).</p>
      </sec>
      <sec>
        <title>Mammalian cell cycle</title>
        <p>For the last example, we propose a model of the mammalian cell cycle initially published as on ODE model by Novák and Tyson
[<xref ref-type="bibr" rid="B29">29</xref>] and translated into a Boolean model by Fauré and colleagues
[<xref ref-type="bibr" rid="B6">6</xref>]. The latter model encompasses 10 nodes, which describe the mechanisms controlling the activity of the different CDK/cyclin complexes, the main actors of cell cycle regulation and the dynamics of entry into the cell cycle in presence of growth factors.</p>
        <p>We implement the logical rules of the published model in MaBoSS and define two parameter values for the transition rates: a slow one (set to 1) and a fast one (set to 10). The choice between slow and fast rates for each transition is based on the choice made in the published Boolean model: different priority classes were used in mixed discrete a/synchronous simulation and corresponded to the differences in speed of cellular processes such as transcription, degradation and protein modification. We could, of course, refine the analysis by setting different rates for each transition. The network, the logical rules and the simulation parameters can be found on the webpage.</p>
        <p>As mentioned before, MaBoSS can provide two types of outputs: the probabilities of different network states over time (along with the entropy and transition entropy) and the indecomposable stationary distributions.</p>
        <p>We consider two biological cases, in the presence of growth factors where the cell enters its division cycle and in the absence of growth factors where the cell is stuck in a G1-like state (state preceding replication of DNA). In the model, the activity of CyclinD (CycD), a G1-cyclin, illustrates the presence of growth factors. In our simulations, we set an initial condition corresponding to a G1 state with two CDK/cyclin inhibitors, p27 and cdh1, on, and with CyclinD on in order to account for the external growth signal. We plot the trajectories of the probabilities of all the cyclins A, B and E (Figure
<xref ref-type="fig" rid="F10">10</xref>, upper panel). The cyclins’ activities exhibit an oscillatory behavior. Each oscillation can be interpreted as a cell division cycle. However, these oscillations are damped. This can be explained by the fact that these probabilities should be interpreted at the cell population level and after few cycles, the cells become desynchronized. Moreover the trajectories of the entropy and the transition entropy exhibit the signature of cyclic attractors (Figure
<xref ref-type="fig" rid="F10">10</xref>, lower panel).</p>
        <fig id="F10" position="float">
          <label>Figure 10</label>
          <caption>
            <p><bold>MaBoSS outputs of the model of the mammalian cell cycle: trajectories of probabilities.</bold> BKMC algorithm is applied to the mammalian cell cycle model, with an initial condition corresponding to a G1 state in the presence of growth factors (CyclinD is on). Trajectories of the cyclins probabilities, the entropy (<italic>H</italic>), transition entropy (<italic>TH</italic>) are plotted. The asymptotic behavior corresponds to the first indecomposable stationary distribution identified in Figure
<xref ref-type="fig" rid="F10">10</xref>.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-10"/>
        </fig>
        <p>The indecomposable stationary distributions are identified by the clustering algorithm of MaBoSS and illustrated in Figure
<xref ref-type="fig" rid="F11">11</xref>. The two clusters in Figure
<xref ref-type="fig" rid="F11">11</xref>a show the two types of solutions for random initial conditions: one multi-cyclic solution when CyclinD is on, and which corresponds to the distribution of network states of the asymptotic solution of Figure
<xref ref-type="fig" rid="F11">11</xref>b, and one fixed point corresponding to a G1 arrest when CyclinD is off (Figure
<xref ref-type="fig" rid="F11">11</xref>c).</p>
        <fig id="F11" position="float">
          <label>Figure 11</label>
          <caption>
            <p><bold>MaBoSS outputs of the model of the mammalian cell cycle: stationary distributions.</bold> BKMC algorithm is applied to the mammalian cell cycle model, with random initial conditions. Results of the clustering algorithm that associates a cluster to each indecomposable stationary distribution. <bold>(a)</bold> Probability of reaching each identified cluster; these probabilities are estimated by the proportion of trajectories that belong to each cluster. <bold>(b)</bold> First estimated cluster that can be interpreted as a desynchronized population of cells that are dividing. <bold>(c)</bold> Second estimated cluster, corresponding to a fixed point, that can be interpreted as a G1 cell cycle arrest with no growth factors.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-11"/>
        </fig>
        <p>These two indecomposable stationary distributions correspond to the two attractors identified by discrete time modeling in Fauré <italic>et al.</italic> In the discrete time algorithm, the asymptotic behavior is described in terms of attractors (sub-parts of the transition graph); in our algorithm, the asymptotic behavior is described in terms of network state probability distributions.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>We have presented a new algorithm, Boolean Kinetic Monte-Carlo or BKMC, applicable to dynamical simulation of signaling networks based on continuous time in the Boolean framework. BKMC algorithm is a natural generalization of the asynchronous Boolean dynamics
[<xref ref-type="bibr" rid="B2">2</xref>], with time trajectories that can be interpreted in terms of biological time. The variables of the Boolean model represent biological species and the parameters represent rates of activation or inactivation of these species that, ideally, could be deduced from experimental data.</p>
    <p>We applied this algorithm to three different models: a toy model that illustrates a simple cyclic behavior, a published model of p53 response to DNA damage, and a published model of mammalian cell cycle dynamics.</p>
    <p>This algorithm is provided within a freely available software, MaBoSS, that can run BKMC algorithm on networks up to 64 nodes in the present version. The construction of a model uses a specific language that introduces logical rules and transition rates of node activation/inactivation in a flexible manner. The software provides global and semi-global outputs of the model dynamics that can be interpreted as signatures of the dynamical behaviors. These interpretations become particularly useful when the network state space is too large to be handled. The convergence of BKMC algorithm can be controlled by tuning some simulation parameters: maximum time of the simulation, number of trajectories, length of a time window on which the average of probabilities is performed, and the threshold for the definition of stationary distribution clusters.</p>
    <p>The next step is to apply BKMC algorithm with MaBoSS on other existing large signaling networks, <italic>e.g.</italic> EGFR pathway
[<xref ref-type="bibr" rid="B30">30</xref>], the apoptosis pathway
[<xref ref-type="bibr" rid="B31">31</xref>], etc. The translation of existing Boolean models in MaBoSS is straightforward but requires the addition of transition rates. In these future works, we expect to illustrate the advantage of BKMC on other simulation algorithms. Moreover, in future developments of MaBoSS, we plan to introduce methods for sensitivity analyses, refine approximation methods used in BKMC, and generalize Markov property.</p>
    <p>We also expect to implement MaBoSS in broadly used software environments for Boolean modeling, like GINsim
[<xref ref-type="bibr" rid="B8">8</xref>] or CellNetAnalyzer
[<xref ref-type="bibr" rid="B25">25</xref>].</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>BKMC generates stochastic trajectories. In this section, we describe how we use and interpret these trajectories.</p>
    <sec>
      <title/>
      <sec>
        <title>Network state probabilities on a time window</title>
        <p>To relate continuous time probabilities to real processes, an observable time window <italic>Δt</italic> is defined. A discrete time (
<inline-formula><mml:math id="M38" name="1752-0509-6-116-i38" overflow="scroll"><mml:mi>τ</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi></mml:math></inline-formula>) stochastic process <italic>s</italic>(<italic>τ</italic>) (that is not necessary Markovian) can be extracted from the continuous time Markov process: </p>
        <p>
          <disp-formula id="bmcM8">
            <label>(8)</label>
            <mml:math id="M39" name="1752-0509-6-116-i39" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>≡</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:mfrac>
              <mml:msubsup>
                <mml:mrow>
                  <mml:mo mathsize="big">∫</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>τ</mml:mi>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>)</mml:mo>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:msubsup>
              <mml:mtext mathvariant="italic">dt</mml:mtext>
              <mml:mspace width="2.77695pt"/>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>t</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>BKMC is used for estimating
<inline-formula><mml:math id="M40" name="1752-0509-6-116-i40" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> as follows: </p>
        <p>1. <bold>Estimate for one trajectory.</bold> For each trajectory <italic>j</italic>, compute the time for which the system is in state <bold>S</bold>, in the window [<italic>τΔt</italic>,(<italic>τ</italic> + 1)<italic>Δt</italic>]. Divide this time by <italic>Δt</italic>. Obtain an estimate of
<inline-formula><mml:math id="M41" name="1752-0509-6-116-i41" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> for trajectory <italic>j</italic>, <italic>i.e.</italic><inline-formula><mml:math id="M42" name="1752-0509-6-116-i42" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>.</p>
        <p>2. <bold>Estimate for a set of trajectories.</bold> Compute the average over <italic>j</italic> of all
<inline-formula><mml:math id="M43" name="1752-0509-6-116-i43" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> to obtain
<inline-formula><mml:math id="M44" name="1752-0509-6-116-i44" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>. Compute the error of this average (
<inline-formula><mml:math id="M45" name="1752-0509-6-116-i45" overflow="scroll"><mml:msqrt><mml:mrow><mml:mtext>Var</mml:mtext><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:mtext># trajectories</mml:mtext></mml:mrow></mml:msqrt></mml:math></inline-formula>).</p>
      </sec>
      <sec>
        <title>Entropies</title>
        <p>Once
<inline-formula><mml:math id="M46" name="1752-0509-6-116-i46" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> is computed, the entropy <italic>H</italic>(<italic>τ</italic>) can be estimated: </p>
        <p>
          <disp-formula id="bmcM9">
            <label>(9)</label>
            <mml:math id="M47" name="1752-0509-6-116-i47" overflow="scroll">
              <mml:mi>H</mml:mi>
              <mml:mo>(</mml:mo>
              <mml:mi>τ</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mo>−</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:msub>
                <mml:mrow>
                  <mml:mo>log</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msub>
              <mml:mfenced open="(" close=")">
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                  <mml:mfenced open="[" close="]">
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                      <mml:mo>(</mml:mo>
                      <mml:mi>τ</mml:mi>
                      <mml:mo>)</mml:mo>
                      <mml:mo>=</mml:mo>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                </mml:mrow>
              </mml:mfenced>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>The entropy measures the disorder of the system. Maximum entropy means that all states have the same probability; a zero entropy means that one of the states has a probability of one. The estimation of the entropy can be seen as a global characterization of a full probability distribution by a single real number. The choice of
<inline-formula><mml:math id="M48" name="1752-0509-6-116-i48" overflow="scroll"><mml:msub><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> allows the interpretation of <italic>H</italic>(<italic>τ</italic>) in an easier manner: 2<sup><italic>H</italic>(<italic>τ</italic>)</sup>is an estimate of the number of states that have a non-negligible probability in the time window [<italic>τΔt</italic>,(<italic>τ</italic> + 1)<italic>Δt</italic>]. A more computer-like interpretation of <italic>H</italic>(<italic>τ</italic>) is the number of bits that are necessary for describing states of non-negligible probability.</p>
        <p>The <italic>Transition Entropy</italic><italic>TH</italic> is a finer measure that characterizes the system at the level of a single trajectory. It can be computed in the following way: for each state <bold>S</bold>, there exists a set of possible transitions
<inline-formula><mml:math id="M49" name="1752-0509-6-116-i49" overflow="scroll"><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. For each of these transitions, a probability is associated: </p>
        <p>
          <disp-formula id="bmcM10">
            <label>(10)</label>
            <mml:math id="M50" name="1752-0509-6-116-i50" overflow="scroll">
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>≡</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:munder>
                    <mml:mrow>
                      <mml:mo>∑</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:munder>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mo>′</mml:mo>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mi>.</mml:mi>
            </mml:math>
          </disp-formula>
        </p>
        <p>By convention,
<inline-formula><mml:math id="M51" name="1752-0509-6-116-i51" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> if there is no transition from <bold>S </bold>to any other state.</p>
        <p>Therefore, the transition entropy <italic>TH</italic> can be associated to each state <bold>S</bold>: </p>
        <p>
          <disp-formula id="bmcM11">
            <label>(11)</label>
            <mml:math id="M52" name="1752-0509-6-116-i52" overflow="scroll">
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mo>−</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:munder>
              <mml:msub>
                <mml:mrow>
                  <mml:mo>log</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msub>
              <mml:mo>(</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>)</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
            </mml:math>
          </disp-formula>
        </p>
        <p>Similarly, <italic>TH</italic>(<bold>S</bold>) = 0 if there is no transition from <bold>S</bold> to any other state. The transition entropy on a time window <italic>TH</italic>(<italic>τ</italic>) is defined as: </p>
        <p>
          <disp-formula>
            <mml:math id="M53" name="1752-0509-6-116-i53" overflow="scroll">
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi>τ</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>)</mml:mo>
            </mml:math>
          </disp-formula>
        </p>
        <p>This transition entropy is estimated in the following way: </p>
        <p>1. <bold>Estimate for one trajectory.</bold> For each trajectory <italic>j</italic>, compute the set Φ of visited states <bold>S</bold> in the time window [<italic>τΔt</italic>,(<italic>τ</italic> + 1)<italic>Δt</italic>] and their respective duration <italic>μ</italic><sub><bold>S</bold></sub>. The estimated transition entropy is: </p>
        <p>
          <disp-formula id="bmcM12">
            <label>(12)</label>
            <mml:math id="M54" name="1752-0509-6-116-i54" overflow="scroll">
              <mml:msub>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mrow>
                      <mml:mtext mathvariant="italic">TH</mml:mtext>
                      <mml:mo>(</mml:mo>
                      <mml:mi>τ</mml:mi>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>Φ</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>μ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:mfrac>
            </mml:math>
          </disp-formula>
        </p>
        <p>2. <bold>Estimate for a set of trajectories.</bold> Compute the average over <italic>j</italic> of all
<inline-formula><mml:math id="M55" name="1752-0509-6-116-i55" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mtext mathvariant="italic">TH</mml:mtext><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> to obtain
<inline-formula><mml:math id="M56" name="1752-0509-6-116-i56" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mtext mathvariant="italic">TH</mml:mtext><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula>. Compute the error of this average (
<inline-formula><mml:math id="M57" name="1752-0509-6-116-i57" overflow="scroll"><mml:msqrt><mml:mrow><mml:mtext>Var</mml:mtext><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mrow><mml:mtext mathvariant="italic">TH</mml:mtext><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:mtext># trajectories</mml:mtext></mml:mrow></mml:msqrt></mml:math></inline-formula>).</p>
        <p>This transition entropy is a way to measure how deterministic the dynamics is. If the transition entropy is always zero, the system can only make a transition to a given state.</p>
        <p>If probability distributions on a time window tend to constant values (or tend to a stationary distribution), the entropy and the transition entropy can help characterize this stationary distribution such that: </p>
        <p>• A fixed point has zero entropy and zero transition entropy,</p>
        <p>• A cyclic stationary distribution has non-zero entropy and zero transition entropy.</p>
        <p>Entropy and transition entropy can be considered as “global characterizations” of the model: for a given time window, they always consist of two real numbers, whatever the size of the network is.</p>
      </sec>
      <sec>
        <title>Hamming distance distribution</title>
        <p>The <italic>Hamming Distance</italic> between two states <bold>S</bold>and <bold>S</bold><sup><italic>′</italic></sup> is the number of nodes that have different node states between <bold>S</bold>and <bold>S</bold><sup><italic>′</italic></sup>: </p>
        <p>
          <disp-formula id="bmcM13">
            <label>(13)</label>
            <mml:math id="M58" name="1752-0509-6-116-i58" overflow="scroll">
              <mml:mtext mathvariant="italic">HD</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>)</mml:mo>
              <mml:mo>≡</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mo>(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>δ</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:msubsup>
                    <mml:mrow>
                      <mml:mi>S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msubsup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>)</mml:mo>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>δ</italic> is the Kronecker delta (
<inline-formula><mml:math id="M59" name="1752-0509-6-116-i59" overflow="scroll"><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> if <italic>S</italic><sub><italic>i </italic></sub>=<italic> S</italic><sub><italic>i</italic></sub><sup><italic>′</italic></sup>,
<inline-formula><mml:math id="M60" name="1752-0509-6-116-i60" overflow="scroll"><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> if <italic>S</italic><sub><italic>i </italic></sub>≠<italic> S</italic><sub><italic>i</italic></sub><sup><italic>′</italic></sup>). Given a reference state <bold>S</bold><sub>ref</sub>, the Hamming distance distribution (over time) is given by: </p>
        <p>
          <disp-formula id="bmcM14">
            <label>(14)</label>
            <mml:math id="M61" name="1752-0509-6-116-i61" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mo>(</mml:mo>
              <mml:mtext mathvariant="italic">HD</mml:mtext>
              <mml:mo>,</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>t</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>δ</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mtext mathvariant="italic">HD</mml:mtext>
                  <mml:mo>,</mml:mo>
                  <mml:mtext mathvariant="italic">HD</mml:mtext>
                  <mml:mo>(</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mtext>ref</mml:mtext>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:msub>
            </mml:math>
          </disp-formula>
        </p>
        <p>The estimation of the Hamming distance distribution on a time window <bold>P</bold>(<italic>HD</italic>,<italic>τ</italic>) is similar to that of stochastic probabilities on a time window.</p>
        <p>The Hamming distance distribution is a useful characterization when the set of instantaneous probabilities is compared to a reference state (<bold>S</bold><sub>ref</sub>). In that case, the Hamming distance distribution describes how far this set is to this reference state. The Hamming distance distribution can be considered as a “semi-global” characterization of time evolution: for a given time window, the size of this characterization is the number of nodes (to be compared with probabilities on a time window whose size is 2<sup>#nodes</sup>).</p>
      </sec>
      <sec>
        <title>Input, internal, output and reference nodes</title>
        <p><italic>Input Nodes</italic> are defined as the nodes for which the initial condition is fixed. Therefore, each trajectory of BKMC starts with fixed values of input nodes and random values of other nodes.</p>
        <p><italic>Internal nodes</italic> are nodes that are not considered for computing probability distributions, entropies and transition entropies. <italic>Output nodes</italic> are nodes that are not internal. Technically, probabilities are summed up over network states that differ only by the state of internal nodes. These internal nodes are only used for generating time trajectories with BKMC algorithm. Usually, nodes are chosen to be internal when the corresponding species is not measured experimentally. Mathematically, it is equivalent to transform the original Markov process to a new stochastic process (that is not necessary Markovian) defined on a new network state space. This new state space is defined by the states of the output nodes. This raises the question of the transition entropy <italic>TH</italic>: formally, this notion has only a sense within Markovian processes, <italic>i.e.</italic> when there are no internal nodes. Here, we generalize the notion of transition entropy even in the case of internal nodes. Suppose that the system is in state <bold>S</bold>: </p>
        <p>• If the only possible transitions from state <bold>S </bold>to any other state consist of flipping an internal node, the transition entropy is zero.</p>
        <p>• If there is, at least, one transition from state <bold>S </bold>to another state that flips an output node, then only the output nodes will be considered for computing probabilities in equation 10. In particular,
<inline-formula><mml:math id="M62" name="1752-0509-6-116-i62" overflow="scroll"><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:math></inline-formula> is computed only on output node flipping events.</p>
        <p><italic>Reference nodes</italic> are nodes for which a reference node state is specified and for which the Hamming distance is computed. In this framework, a reference state is composed of reference nodes for which the node state is known and non-reference nodes for which the node state is unknown. Note that non-reference nodes may differ from internal nodes.</p>
      </sec>
      <sec>
        <title>Stationary distribution characterization</title>
        <p>It can be shown (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 2, section 1.2) that instantaneous probabilities of a continuous time Markov process converge to a stationary distribution. Fixed points and cycles are two special cases of stationary distributions. They can be identified by the asymptotic behavior of entropy and transition entropy (this works only if no nodes are internal): </p>
        <p>• If both the transition entropy and the entropy converge to zero, then the process converges to a fixed point.</p>
        <p>• if the transition entropy converges to zero and the entropy does not, then the process converges to a cycle.</p>
        <p>More generally, the complete description of the Markov process asymptotic behavior can be expressed as a linear combination of the indecomposable stationary distributions.</p>
        <p>A set of finite trajectories, produced by BKMC, can be used to estimate the set of indecomposable stationary distributions. Consider a trajectory
<inline-formula><mml:math id="M63" name="1752-0509-6-116-i63" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>]</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>⋯</mml:mo><mml:mspace width="0.3em"/><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:math></inline-formula>. Let
<inline-formula><mml:math id="M64" name="1752-0509-6-116-i64" overflow="scroll"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>≡</mml:mo><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>. The estimation of the associated indecomposable stationary probability distribution (<italic>s</italic><sub>0</sub>) is done by averaging over the whole trajectory: </p>
        <p>
          <disp-formula id="bmcM15">
            <label>(15)</label>
            <mml:math id="M65" name="1752-0509-6-116-i65" overflow="scroll">
              <mml:mover accent="true">
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mo>^</mml:mo>
              </mml:mover>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>T</mml:mi>
                </mml:mrow>
              </mml:mfrac>
              <mml:msubsup>
                <mml:mrow>
                  <mml:mo mathsize="big">∫</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>0</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>T</mml:mi>
                </mml:mrow>
              </mml:msubsup>
              <mml:mtext mathvariant="italic">dt</mml:mtext>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>I</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>(</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>)</mml:mo>
            </mml:math>
          </disp-formula>
        </p>
        <p>Therefore, a set of indecomposable stationary distribution estimates can be obtained by a set of trajectories. These indecomposable stationary distribution estimates should be clustered in groups, where each group consists of estimates for the same indecomposable stationary distribution. For that, we use the fact that two indecomposable stationary distributions are identical if they have the same support, <italic>i.e.</italic> the same set of network states with non-zero probabilities (shown in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, theorem 2, section 1.2). Therefore, it is possible to quantify how similar two indecomposable stationary distribution estimates are. A <italic>similarity coefficient</italic><inline-formula><mml:math id="M66" name="1752-0509-6-116-i66" overflow="scroll"><mml:mi>D</mml:mi><mml:mo>(</mml:mo><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msubsup><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:math></inline-formula>, given two stationary distribution estimates <italic>s</italic><sub>0</sub><sup>(<italic>i</italic>)</sup> and <italic>s</italic><sub>0</sub><sup>(<italic>i</italic>)</sup> , is defined: </p>
        <p>
          <disp-formula id="bmcM16">
            <label>(16)</label>
            <mml:math id="M67" name="1752-0509-6-116-i67" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mi>D</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>j</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>)</mml:mo>
                    <mml:mo>≡</mml:mo>
                    <mml:mfenced open="(" close=")">
                      <mml:mrow>
                        <mml:munder>
                          <mml:mrow>
                            <mml:mo mathsize="big">∑</mml:mo>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                            <mml:mo>∈</mml:mo>
                            <mml:mtext>support</mml:mtext>
                            <mml:mo>(</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>,</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:munder>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="3em"/>
                    <mml:mspace width="3em"/>
                    <mml:mspace width="1em"/>
                    <mml:mo>×</mml:mo>
                    <mml:mfenced open="(" close=")">
                      <mml:mrow>
                        <mml:munder>
                          <mml:mrow>
                            <mml:mo mathsize="big">∑</mml:mo>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi mathvariant="bold">S</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>′</mml:mi>
                              </mml:mrow>
                            </mml:msup>
                            <mml:mo>∈</mml:mo>
                            <mml:mtext>support</mml:mtext>
                            <mml:mo>(</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>,</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:munder>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi mathvariant="bold">S</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>′</mml:mi>
                              </mml:mrow>
                            </mml:msup>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>where </p>
        <p>
          <disp-formula id="bmcM17">
            <label>(17)</label>
            <mml:math id="M68" name="1752-0509-6-116-i68" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mtext>support</mml:mtext>
                    <mml:mo>(</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>j</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>)</mml:mo>
                    <mml:mo>≡</mml:mo>
                    <mml:mfenced open="{">
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mtext>such that</mml:mtext>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="3em"/>
                    <mml:mspace width="3em"/>
                    <mml:mspace width="3em"/>
                    <mml:mspace width="1em"/>
                    <mml:mfenced close="}">
                      <mml:mrow>
                        <mml:mo>×</mml:mo>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                        </mml:mfenced>
                        <mml:mo>&gt;</mml:mo>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>Clusters can be constructed when a similarity threshold <italic>α</italic> is provided. A cluster of stationary distributions is defined as follows: </p>
        <p>
          <disp-formula id="bmcM18">
            <label>(18)</label>
            <mml:math id="M69" name="1752-0509-6-116-i69" overflow="scroll">
              <mml:mi mathvariant="script">C</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mfenced open="{" close="}">
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>|</mml:mo>
                  <mml:mspace width="2.77695pt"/>
                  <mml:mo>∃</mml:mo>
                  <mml:msubsup>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msubsup>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mtext>s. t.</mml:mtext>
                  <mml:mi>D</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:msubsup>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msubsup>
                  <mml:mo>)</mml:mo>
                  <mml:mo>≥</mml:mo>
                  <mml:mi>α</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>For each cluster
<inline-formula><mml:math id="M70" name="1752-0509-6-116-i70" overflow="scroll"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula>, a distribution estimate
<inline-formula><mml:math id="M71" name="1752-0509-6-116-i71" overflow="scroll"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>, associated to an indecomposable stationary distribution, can be defined: </p>
        <p>
          <disp-formula id="bmcM19">
            <label>(19)</label>
            <mml:math id="M72" name="1752-0509-6-116-i72" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="script">C</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>|</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mo>|</mml:mo>
                </mml:mrow>
              </mml:mfrac>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>Errors on this estimate can be computed by: </p>
        <p>
          <disp-formula id="bmcM20">
            <label>(20)</label>
            <mml:math id="M73" name="1752-0509-6-116-i73" overflow="scroll">
              <mml:mtext>Err</mml:mtext>
              <mml:mfenced open="(" close=")">
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                  <mml:mfenced open="[" close="]">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="script">C</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>=</mml:mo>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:msqrt>
                <mml:mrow>
                  <mml:mtext>Var</mml:mtext>
                  <mml:mo>(</mml:mo>
                  <mml:mi mathvariant="bold">P</mml:mi>
                  <mml:mfenced open="[" close="]">
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                  <mml:mo>,</mml:mo>
                  <mml:mi>s</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>/</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mo>|</mml:mo>
                </mml:mrow>
              </mml:msqrt>
            </mml:math>
          </disp-formula>
        </p>
        <p>Notice that this clustering procedure has no sense if the process is not Markovian; therefore, no nodes are considered as internal.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Abbreviations</title>
    <p>BKMC: Boolean Kinetic Monte-Carlo; AT: Asynchronous transition; ODEs: Ordinary differential equations; MaBoSS: Markov Boolean Stochastic Simulator.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors’ contributions</title>
    <p>G. Stoll organized the project, set up the algorithms, participated in writing the software, set up the examples and wrote the article. E. Viara wrote the software and participated in setting up the algorithms. E. Barillot participated in discussions and corrected the manuscript. L. Calzone organized the project, set up the examples and wrote the article. All authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Supplementary material.</bold> Basic information on Markov process, abbreviations, definitions and algorithms.</p>
      </caption>
      <media xlink:href="1752-0509-6-116-S1.pdf" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="S2">
      <caption>
        <title>Additional file 2</title>
        <p><bold>Model of the mammalian cell cycle with GINsim, BoolNet and MaBoSS.</bold> The cell cycle presented in the “Examples” section has been modeled using three tools: GINsim, BoolNet, and MaBoSS. The results for each tool are presented: (1) GINsim provides steady state solutions and transition graphs for two different initial conditions: when CycD=0 and CycD=1. For the synchronous strategy, the transition graph can be visualized whereas for the asynchronous strategy, it is not easy to read or use; BoolNet constructs two graphical representations of the trajectories based on synchronous update strategy, for the case of CycD=0 (steady state) and CycD=1 (cycle); (3) MaBoSS estimates indecomposable stationary distributions for the case of CycD=0 (one fixed point, not shown) and CycD=1 (distribution of probabilities of different network states), and time-dependent activities of the cyclins showing damped oscillations. All results are coherent but are presented differently with a different focus for each tool.</p>
      </caption>
      <media xlink:href="1752-0509-6-116-S2.pdf" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>This project was supported by the Institut National du Cancer (SybEwing project), the Agence National de la Recherche (Calamar project). The research leading to these results has received funding from the European Community’s Seventh Framework Programme (FP7/2007-2013) under grant agreement nb HEALTH-F4-2007-200767 for APO-SYS and nb FP7-HEALTH-2010-259348 for ASSET. GS, EB and LC are members of the team “Computational Systems Biology of Cancer”, Equipe labellisée par la Ligue Nationale Contre le Cancer. We’d like to thank Camille Sabbah, Jacques Rougemont, Denis Thieffry, Elisabeth Remy, Luca Grieco and Andrei Zinovyev.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kauffman</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Homeostasis and differentiation in random genetic control networks</article-title>
        <source>Nature</source>
        <year>1969</year>
        <volume>224</volume>
        <fpage>177</fpage>
        <lpage>178</lpage>
        <pub-id pub-id-type="doi">10.1038/224177a0</pub-id>
        <pub-id pub-id-type="pmid">5343519</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Thomas</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Regulatory networks seen as asynchronous automata: a logical description</article-title>
        <source>J Theor Biol</source>
        <year>1991</year>
        <volume>153</volume>
        <fpage>1</fpage>
        <lpage>23</lpage>
        <pub-id pub-id-type="doi">10.1016/S0022-5193(05)80350-9</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Stoll</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Rougemont</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Naef</surname>
          <given-names>F</given-names>
        </name>
        <article-title>Few crucial links assure checkpoint efficiency in the yeast cell-cycle network</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>20</issue>
        <fpage>2539</fpage>
        <lpage>2546</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl432</pub-id>
        <pub-id pub-id-type="pmid">16895923</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Stoll</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Bischofberger</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Rougemont</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Naef</surname>
          <given-names>F</given-names>
        </name>
        <article-title>Stabilizing patterning in the Drosophila segment polarity network by selecting models in silico</article-title>
        <source>Biosystems</source>
        <year>2010</year>
        <volume>102</volume>
        <fpage>3</fpage>
        <lpage>10</lpage>
        <pub-id pub-id-type="doi">10.1016/j.biosystems.2010.07.014</pub-id>
        <pub-id pub-id-type="pmid">20655356</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Garg</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Mohanram</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Di Cara</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>De Micheli</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Xenarios</surname>
          <given-names>I</given-names>
        </name>
        <article-title>Modeling stochasticity and robustness in gene regulatory networks</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>12</issue>
        <fpage>i101—i109</fpage>
        <pub-id pub-id-type="pmid">19477975</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Fauré</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Thieffry</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Naldi</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Dynamical analysis of a generic Boolean model for the control of the mammalian cell cycle</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>14</issue>
        <fpage>e124—e131</fpage>
        <pub-id pub-id-type="pmid">16873462</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Shmulevich</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Dougherty</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Probabilistic Boolean networks: a rule-based uncertainty model for gene regulatory networks</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <issue>2</issue>
        <fpage>261</fpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/18.2.261</pub-id>
        <pub-id pub-id-type="pmid">11847074</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gonzalez</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Naldi</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Sanchez</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Thieffry</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <article-title>GINsim: a software suite for the qualitative modelling, simulation and analysis of regulatory networks</article-title>
        <source>Biosystems</source>
        <year>2006</year>
        <volume>84</volume>
        <issue>2</issue>
        <fpage>91</fpage>
        <lpage>100</lpage>
        <pub-id pub-id-type="doi">10.1016/j.biosystems.2005.10.003</pub-id>
        <pub-id pub-id-type="pmid">16434137</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wunderlich</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>DePace</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Modeling transcriptional networks in Drosophila development at multiple scales</article-title>
        <source>Curr Opin Genet Dev</source>
        <year>2011</year>
        <volume>21</volume>
        <issue>6</issue>
        <fpage>711</fpage>
        <lpage>718</lpage>
        <pub-id pub-id-type="doi">10.1016/j.gde.2011.07.005</pub-id>
        <pub-id pub-id-type="pmid">21889888</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>MacArthur</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Ma’ayan</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Lemischka</surname>
          <given-names>I</given-names>
        </name>
        <article-title>Systems biology of stem cell fate and cellular reprogramming</article-title>
        <source>Nat Rev Mol Cell Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>10</issue>
        <fpage>672</fpage>
        <lpage>681</lpage>
        <pub-id pub-id-type="pmid">19738627</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Saez-Rodriguez</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Alexopoulos</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Morris</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Lauffenburger</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Sorger</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Comparing signaling networks between normal and transformed hepatocytes using discrete logical models</article-title>
        <source>Cancer Res</source>
        <year>2011</year>
        <volume>71</volume>
        <issue>16</issue>
        <fpage>5400</fpage>
        <pub-id pub-id-type="doi">10.1158/0008-5472.CAN-10-4453</pub-id>
        <pub-id pub-id-type="pmid">21742771</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Siebert</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Bockmayr</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Temporal constraints in the logical analysis of regulatory networks</article-title>
        <source>Theor Comput Sci</source>
        <year>2008</year>
        <volume>391</volume>
        <issue>3</issue>
        <fpage>258</fpage>
        <lpage>275</lpage>
        <pub-id pub-id-type="doi">10.1016/j.tcs.2007.11.010</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="book">
        <name>
          <surname>Öktem</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Pearson</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Yli-Harja</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Nicorici</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Egiazarian</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Astola</surname>
          <given-names>J</given-names>
        </name>
        <etal/>
        <article-title>A computational model for simulating continuous time Boolean networks</article-title>
        <source>Proceedings of IEEE International Workshop on Genomic Signal Processing and Statistics (GENSIPS’02)</source>
        <year>October 2002</year>
        <publisher-name>NC, USA: Raleigh</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Vahedi</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Faryabi</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Chamberland</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Datta</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Dougherty</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Sampling-rate-dependent probabilistic Boolean networks</article-title>
        <source>J Theor Biol</source>
        <year>2009</year>
        <volume>261</volume>
        <issue>4</issue>
        <fpage>540</fpage>
        <lpage>547</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2009.08.026</pub-id>
        <pub-id pub-id-type="pmid">19716832</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sevim</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Gong</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Socolar</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Reliability of transcriptional cycles and the yeast cell-cycle oscillator</article-title>
        <source>PLoS Comput Biol</source>
        <year>2010</year>
        <volume>6</volume>
        <issue>7</issue>
        <fpage>e1000842</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1000842</pub-id>
        <pub-id pub-id-type="pmid">20628620</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Teraguchi</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kumagai</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Vandenbon</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Akira</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Standley</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Stochastic binary modeling of cells in continuous time as an alternative to biochemical reaction equations</article-title>
        <source>Phys Rev E</source>
        <year>2011</year>
        <volume>062903</volume>
        <issue>6</issue>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bauer</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Jackson</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Jiang</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Rohlf</surname>
          <given-names>T</given-names>
        </name>
        <article-title>Receptor cross-talk in angiogenesis: mapping environmental cues to cell phenotype using a stochastic, Boolean signaling network model</article-title>
        <source>J Theor Biol</source>
        <year>2010</year>
        <volume>264</volume>
        <issue>3</issue>
        <fpage>838</fpage>
        <lpage>846</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2010.03.025</pub-id>
        <pub-id pub-id-type="pmid">20307549</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Abou-Jaoudé</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Ouattara</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Kaufman</surname>
          <given-names>M</given-names>
        </name>
        <article-title>From structure to dynamics: frequency tuning in the p53-Mdm2 network: I. Logical approach</article-title>
        <source>J Theor Biol</source>
        <year>2009</year>
        <volume>258</volume>
        <issue>4</issue>
        <fpage>561</fpage>
        <lpage>577</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2009.02.005</pub-id>
        <pub-id pub-id-type="pmid">19233211</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="book">
        <name>
          <surname>Van Kampen</surname>
          <given-names>N</given-names>
        </name>
        <source>Stochastic Processes in Physics and Chemistry</source>
        <year>2004</year>
        <publisher-name>Amsterdam, Netherlands: Elsevier</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="book">
        <name>
          <surname>Shiryaev</surname>
          <given-names>A</given-names>
        </name>
        <source>Probability, volume 95 of Graduate texts in mathematics</source>
        <year>1996</year>
        <publisher-name>Springer-Verlag: New York, USA</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chaves</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Albert</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Sontag</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Robustness and fragility of Boolean models for genetic regulatory networks</article-title>
        <source>J Theor Biol</source>
        <year>2005</year>
        <volume>235</volume>
        <issue>3</issue>
        <fpage>431</fpage>
        <lpage>449</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2005.01.023</pub-id>
        <pub-id pub-id-type="pmid">15882705</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Petri net modelling of biological networks</article-title>
        <source>Briefings in Bioinformatics</source>
        <year>2007</year>
        <volume>8</volume>
        <issue>4</issue>
        <fpage>210</fpage>
        <lpage>219</lpage>
        <pub-id pub-id-type="doi">10.1093/bib/bbm029</pub-id>
        <pub-id pub-id-type="pmid">17626066</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Young</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Elcock</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Monte Carlo studies of vacancy migration in binary ordered alloys: I</article-title>
        <source>Proceedings of the Physical Society</source>
        <year>1966</year>
        <volume>89</volume>
        <fpage>735</fpage>
        <pub-id pub-id-type="doi">10.1088/0370-1328/89/3/329</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gillespie</surname>
          <given-names>D</given-names>
        </name>
        <article-title>A general method for numerically simulating the stochastic time evolution of coupled chemical reactions</article-title>
        <source>J Comput Phys</source>
        <year>1976</year>
        <volume>22</volume>
        <issue>4</issue>
        <fpage>403</fpage>
        <lpage>434</lpage>
        <pub-id pub-id-type="doi">10.1016/0021-9991(76)90041-3</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Klamt</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Saez-Rodriguez</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Gilles</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Structural and functional analysis of cellular networks with CellNetAnalyzer</article-title>
        <source>BMC Syst Biol</source>
        <year>2007</year>
        <volume>1</volume>
        <fpage>2</fpage>
        <pub-id pub-id-type="doi">10.1186/1752-0509-1-2</pub-id>
        <pub-id pub-id-type="pmid">17408509</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Müssel</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Hopfensitz</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kestler</surname>
          <given-names>H</given-names>
        </name>
        <article-title>BoolNet–an R package for generation, reconstruction and analysis of Boolean networks</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>10</issue>
        <fpage>1378</fpage>
        <lpage>1380</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq124</pub-id>
        <pub-id pub-id-type="pmid">20378558</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>De Jong</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Geiselmann</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Hernandez</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Page</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Genetic Network Analyzer: qualitative simulation of genetic regulatory networks</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>3</issue>
        <fpage>336</fpage>
        <lpage>344</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btf851</pub-id>
        <pub-id pub-id-type="pmid">12584118</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Di Cara</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Garg</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>De Micheli</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Xenarios</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Mendoza</surname>
          <given-names>L</given-names>
        </name>
        <article-title>Dynamic simulation of regulatory networks using SQUAD</article-title>
        <source>BMC Bioinf</source>
        <year>2007</year>
        <volume>8</volume>
        <fpage>462</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-8-462</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Novak</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Tyson</surname>
          <given-names>J</given-names>
        </name>
        <article-title>A model for restriction point control of the mammalian cell cycle</article-title>
        <source>J Theor Biol</source>
        <year>2004</year>
        <volume>230</volume>
        <issue>4</issue>
        <fpage>563</fpage>
        <lpage>579</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2004.04.039</pub-id>
        <pub-id pub-id-type="pmid">15363676</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sahin</surname>
          <given-names>Ö</given-names>
        </name>
        <name>
          <surname>Fröhlich</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Löbke</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Korf</surname>
          <given-names>U</given-names>
        </name>
        <name>
          <surname>Burmester</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Majety</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Mattern</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Schupp</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Thieffry</surname>
          <given-names>D</given-names>
        </name>
        <etal/>
        <article-title>Modeling ERBB receptor-regulated G1/S transition to find novel targets for de novo trastuzumab resistance</article-title>
        <source>BMC Syst Biol</source>
        <year>2009</year>
        <volume>3</volume>
        <fpage>1</fpage>
        <pub-id pub-id-type="doi">10.1186/1752-0509-3-1</pub-id>
        <pub-id pub-id-type="pmid">19118495</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Schlatter</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Schmich</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Vizcarra</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Scheurich</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Sauter</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Borner</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Ederer</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Merfort</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Sawodny</surname>
          <given-names>O</given-names>
        </name>
        <article-title>ON/OFF and beyond-a boolean model of apoptosis</article-title>
        <source>PLoS Comput Biol</source>
        <year>2009</year>
        <volume>5</volume>
        <issue>12</issue>
        <fpage>e1000595</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1000595</pub-id>
        <pub-id pub-id-type="pmid">20011108</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Syst Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Syst Biol</journal-id>
    <journal-title-group>
      <journal-title>BMC Systems Biology</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1752-0509</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3517402</article-id>
    <article-id pub-id-type="publisher-id">1752-0509-6-116</article-id>
    <article-id pub-id-type="pmid">22932419</article-id>
    <article-id pub-id-type="doi">10.1186/1752-0509-6-116</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Continuous time boolean modeling for biological signaling: application of Gillespie algorithm</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Stoll</surname>
          <given-names>Gautier</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>gautier.stoll@curie.fr</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Viara</surname>
          <given-names>Eric</given-names>
        </name>
        <xref ref-type="aff" rid="I4">4</xref>
        <email>viara@sysra.com</email>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Barillot</surname>
          <given-names>Emmanuel</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>emmanuel.barillot@curie.fr</email>
      </contrib>
      <contrib contrib-type="author" id="A4">
        <name>
          <surname>Calzone</surname>
          <given-names>Laurence</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>laurence.calzone@curie.fr</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Institut Curie, 26 rue d’Ulm, Paris, F-75248 France</aff>
    <aff id="I2"><label>2</label>INSERM, Paris, U900, F-75248 France</aff>
    <aff id="I3"><label>3</label>Mines ParisTech, Fontainebleau, F-77300 France</aff>
    <aff id="I4"><label>4</label>Sysra, Yerres, F-91330 France</aff>
    <pub-date pub-type="collection">
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>29</day>
      <month>8</month>
      <year>2012</year>
    </pub-date>
    <volume>6</volume>
    <fpage>116</fpage>
    <lpage>116</lpage>
    <history>
      <date date-type="received">
        <day>4</day>
        <month>4</month>
        <year>2012</year>
      </date>
      <date date-type="accepted">
        <day>15</day>
        <month>8</month>
        <year>2012</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright ©2012 Stoll et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2012</copyright-year>
      <copyright-holder>Stoll et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (
<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1752-0509/6/116"/>
    <abstract>
      <sec>
        <title/>
        <p>Mathematical modeling is used as a Systems Biology tool to answer biological questions, and more precisely, to validate a network that describes biological observations and predict the effect of perturbations. This article presents an algorithm for modeling biological networks in a discrete framework with continuous time.</p>
      </sec>
      <sec>
        <title>Background</title>
        <p>There exist two major types of mathematical modeling approaches: (1) quantitative modeling, representing various chemical species concentrations by real numbers, mainly based on differential equations and chemical kinetics formalism; (2) and qualitative modeling, representing chemical species concentrations or activities by a finite set of discrete values. Both approaches answer particular (and often different) biological questions. Qualitative modeling approach permits a simple and less detailed description of the biological systems, efficiently describes stable state identification but remains inconvenient in describing the transient kinetics leading to these states. In this context, time is represented by discrete steps. Quantitative modeling, on the other hand, can describe more accurately the dynamical behavior of biological processes as it follows the evolution of concentration or activities of chemical species as a function of time, but requires an important amount of information on the parameters difficult to find in the literature.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>Here, we propose a modeling framework based on a qualitative approach that is intrinsically continuous in time. The algorithm presented in this article fills the gap between qualitative and quantitative modeling. It is based on continuous time Markov process applied on a Boolean state space. In order to describe the temporal evolution of the biological process we wish to model, we explicitly specify the transition rates for each node. For that purpose, we built a language that can be seen as a generalization of Boolean equations. Mathematically, this approach can be translated in a set of ordinary differential equations on probability distributions. We developed a C++ software, MaBoSS, that is able to simulate such a system by applying Kinetic Monte-Carlo (or Gillespie algorithm) on the Boolean state space. This software, parallelized and optimized, computes the temporal evolution of probability distributions and estimates stationary distributions.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>Applications of the Boolean Kinetic Monte-Carlo are demonstrated for three qualitative models: a toy model, a published model of p53/Mdm2 interaction and a published model of the mammalian cell cycle. Our approach allows to describe kinetic phenomena which were difficult to handle in the original models. In particular, transient effects are represented by time dependent probability distributions, interpretable in terms of cell populations.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>Boolean modeling</kwd>
      <kwd>Continuous time</kwd>
      <kwd>Markov process</kwd>
      <kwd>Gillespie algorithm</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Mathematical models of signaling pathways are tools that answer biological questions. The most commonly used mathematical formalisms to answer these questions are ordinary differential equations (ODEs) and Boolean modeling.</p>
    <p>Ordinary differential equations (ODEs) have been widely utilized to model signaling pathways. It is the most natural formalism for translating detailed reaction networks into a mathematical model. Indeed, equations can be directly derived using mass action laws, Michaelis-Menten kinetics or Hill functions for each reaction according to the observed behaviors. This framework has limitations, though. The first one concerns the difficulty to assign values to the kinetic parameters of the model. Ideally, these parameters would be extracted from experimental data. However, they are often chosen by the modeler so as to fit qualitatively the expected phenotypes. The second limitation concerns the cell population heterogeneity. In this case, ODEs are no longer appropriate since the approach is deterministic and thus focuses on the average behavior. To include non-determinism, an ODE model needs to be transformed into a stochastic chemical model. In this formalism, a master equation is written on the probabilities of the number of molecules for each species. In the translation process, the same parameters used in ODEs (more particularly in ODEs written with mass action law) can be used in the master equation, but in this case, the number of initial conditions explodes along with the computation time.</p>
    <p>Boolean (or logical) formalism is another formalism used to model signaling pathways where genes/proteins are parameterized by 0s and 1s only. It is the most natural formalism to translate an influence network into a mathematical model. In such networks, each node corresponds to a species and each arrow to an interaction or an influence (positive or negative). In a Boolean model, a logical rule linking the inputs is assigned to each node. As a result, there are no real parameter values to adjust besides choosing the appropriate logical rules that best describe the system. In this paper, we will refer to a state in which each node of the influence network has a Boolean value as a network state, and the set of all possible transitions between the network states as a transition graph. There are two types of transition graphs, one deduced from the synchronous update strategy
[<xref ref-type="bibr" rid="B1">1</xref>], for which all the nodes that can be updated are updated in one transition, and another one deduced from the asynchronous update strategy
[<xref ref-type="bibr" rid="B2">2</xref>], for which only one node, of all the possible nodes, is updated in one transition. In the Boolean formalism, each transition can be interpreted as a “time” step, though this “time” does not characterize real biological time but rather an event. Stochasticity is an important aspect when studying cell populations. In Boolean framework, it can be applied: on nodes (by randomly flipping a node state
[<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B4">4</xref>]), on the logical rules (by allowing to change an AND gate into an OR gate
[<xref ref-type="bibr" rid="B5">5</xref>]), and on the update rules (by defining the probability and the priority of changing one particular Boolean value before others in an asynchronous strategy
[<xref ref-type="bibr" rid="B6">6</xref>] or by adding noise to the whole system in a synchronous strategy
[<xref ref-type="bibr" rid="B7">7</xref>]). One of the main drawbacks of the Boolean approach is the explosion of solutions. In an asynchronous update strategy, the size of the transition graph can reach 2<sup>#nodes</sup>.</p>
    <p>Both logical and continuous frameworks have advantages and disadvantages above-mentioned. We propose here to combine some of the advantages of both approaches in an algorithm that we call the “Boolean Kinetic Monte-Carlo” algorithm (BKMC). It consists of a natural generalization of the asynchronous Boolean dynamics
[<xref ref-type="bibr" rid="B2">2</xref>], with a direct probabilistic interpretation. In BKMC framework, the dynamics is parameterized by a biological time and the order of update is noisy, which is less strict than priority classes introduced in GINsim
[<xref ref-type="bibr" rid="B8">8</xref>]. A BKMC model is specified by logical rules as in regular Boolean models but with a more precise information: a numerical rate is added for each transition of each node.</p>
    <p>BKMC is not intended to replace existing tools but rather to complement them. It is best suited to model signaling pathways in the following cases: </p>
    <p>• The model is based on an influence network, because BKMC is a generalization of the asynchronous Boolean dynamics. See “Examples” section. Note that this is a common requirement for most of Boolean software.</p>
    <p>• The model describes processes for which information about the duration of a biological process is known, because in BKMC, time is parameterized by a real number. This is typically the case when studying developmental biology, where animal models provide time changes of gene/protein activities
[<xref ref-type="bibr" rid="B9">9</xref>].</p>
    <p>• The model describes heterogeneous cell population behavior, because BKMC has a probabilistic interpretation. For example, modeling heterogeneous cell population can help understand tissue formation based on cell differentiation
[<xref ref-type="bibr" rid="B10">10</xref>].</p>
    <p>• The model can contain many nodes (up to 64 in the present implementation), because BKMC is a simulation algorithm that converges fast. This can be useful for big models that have already been modeled with a discrete time Boolean method
[<xref ref-type="bibr" rid="B11">11</xref>], in order to obtain a finer description of transient effects (see webpage for examples of published models:
<ext-link ext-link-type="uri" xlink:href="https://maboss.curie.fr">https://maboss.curie.fr</ext-link>).</p>
    <p>Previous published works have also introduced a continuous time approach in the Boolean framework(
[<xref ref-type="bibr" rid="B12">12</xref>-<xref ref-type="bibr" rid="B18">18</xref>]). In this article, we will first review some of these works and present BKMC algorithm. We will then describe the C++ software, MaBoSS, developed to implement BKMC algorithm and finally illustrate its use with three examples, a toy model, a published model of p53-MDM2 interaction and a published model of the mammalian cell cycle.</p>
    <p>All abbreviations, definitions, algorithms and estimates used in this article can be found in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>. Throughout the article, all terms that are italicized are defined in the Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Definitions”.</p>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <sec>
      <title>BKMC for continuous time Boolean model</title>
      <sec>
        <title>Continuous time in Boolean modeling: past and present</title>
        <p>In Boolean approaches for modeling networks, the state of each node of the network is defined by a Boolean value (node state) and the network state by the set of node states. Any dynamics in the transition graph is represented by sequences of network states. A node state is based on the sign of the input arrows and the logic that links them. The dynamics can be deterministic in the case of synchronized update
[<xref ref-type="bibr" rid="B1">1</xref>], or non-deterministic in the case of asynchronized update
[<xref ref-type="bibr" rid="B2">2</xref>] or probabilistic Boolean networks
[<xref ref-type="bibr" rid="B7">7</xref>].</p>
        <p>The difficulty to interpret the dynamics in terms of biological time has led to several works that have generalized Boolean approaches. These approaches can be divided in two classes that we call explicit and implicit time for discrete steps.</p>
        <p>The explicit time for discrete steps consists of adding a real parameter to each node state. These parameters correspond to the time associated to each node state before it flips to another one (
[<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>]). Because data about these time lengths are difficult to extract from experimental studies, some works have included noise in the definition of these parameters
[<xref ref-type="bibr" rid="B18">18</xref>]. The drawback of this method is that the computation of the Boolean model becomes sensitive to both the type of noise and the initial conditions. As a result, these time parameters become new parameters that need to be tuned carefully and thus add complexity to the modeling.</p>
        <p>The implicit time for discrete steps consists of adding a probability to each transition of the transition graph in the case of non-deterministic transitions (asynchronous case). It is argued that these probabilities could be interpreted as specifying the duration of a biological process. As an illustration, let us assume a small network of two nodes, A and B. At time t, A and B are inactive: [AB] = [00]. In the transition graph, there exist two possible transitions at t+1: [00] → [01] and [00] → [10]. If the first transition has a significant higher probability than the second one, then we can conclude that B will have a higher tendency to activate before A. Therefore, it is equivalent to say that the activation of B is faster than the activation of A. Thus, in this case, the notion of time is implicitly modeled by setting probability transitions. In particular, priority rules, in the asynchronous strategy, consist of putting some of these probabilities to zero
[<xref ref-type="bibr" rid="B6">6</xref>]. In our example, if B is faster than A then the probability of the transition [00] → [10] is zero. As a result, the prioritized nodes always activate before the others. From a different perspective but keeping the same idea, Vahedi and colleagues
[<xref ref-type="bibr" rid="B14">14</xref>] have set up a method to deduce explicitly these probabilities from the duration of each discrete step. With the implementation of implicit time in a Boolean model, the dynamics remains difficult to interpret in terms of biological time.</p>
        <p>As an alternative to these approaches, we propose BKMC algorithm.</p>
      </sec>
      <sec>
        <title>Properties of BKMC algorithm</title>
        <p>BKMC algorithm was built such as to meet the following principles: </p>
        <p>• The state of each node is given by a Boolean number (0 or 1), referred to as node state;</p>
        <p>• The state of the network is given by the set of node states, referred to as network state;</p>
        <p>• The update of a node state is based on the signs linking the incoming arrows of this node and the logic;</p>
        <p>• Time is represented by a real number;</p>
        <p>• Evolution is stochastic.</p>
        <p>We choose to describe the time evolution of network states by a Markov process with continuous time, applied to the asynchronous transition graph. Therefore, the dynamics is defined by transition rates inserted in a master equation (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1).</p>
      </sec>
      <sec>
        <title>Markov process for Boolean model</title>
        <p>Consider a network of <italic>n</italic> nodes (or agents, that can represent any species, <italic>i.e.</italic> mRNA, proteins, complexes, <italic>etc.</italic>). In a Boolean framework, the network state of the system is described by a vector <bold>S</bold> of Boolean values, <italic>i.e.</italic><italic>S</italic><sub><italic>i</italic></sub>∈{0,1},<italic>i </italic>= 1,…,<italic>n</italic> where <italic>S</italic><sub><italic>i</italic></sub> is the state of the node <italic>i</italic>. The set of all possible network states, also referred to as the network state space, will be called Σ.</p>
        <p>A stochastic description of the state evolution is represented by a <italic>stochastic process</italic><italic>s</italic>:<italic>t </italic>↦<italic> s</italic>(<italic>t</italic>) defined on
<inline-formula><mml:math id="M1" name="1752-0509-6-116-i1" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo>⊂</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:math></inline-formula> applied on the network state space, where <italic>I</italic> is an interval: for each time
<inline-formula><mml:math id="M2" name="1752-0509-6-116-i2" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo>⊂</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:math></inline-formula>, <italic>s</italic>(<italic>t</italic>) represents a random variable applied on the network state space. Thus, the probability of these random variables is written as: </p>
        <p>
          <disp-formula id="bmcM1">
            <label>(1)</label>
            <mml:math id="M3" name="1752-0509-6-116-i3" overflow="scroll">
              <mml:mtable class="align" columnalign="right left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:mi>t</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="1em"/>
                    <mml:mo>∈</mml:mo>
                  </mml:mtd>
                  <mml:mtd class="align-2">
                    <mml:mo>[</mml:mo>
                    <mml:mn>0</mml:mn>
                    <mml:mo>,</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>]</mml:mo>
                    <mml:mspace width="0.3em"/>
                    <mml:mspace width="0.3em"/>
                    <mml:mtext>for any state</mml:mtext>
                    <mml:mspace width="0.3em"/>
                    <mml:mspace width="0.3em"/>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi>Σ</mml:mi>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mtext>with</mml:mtext>
                    <mml:munder>
                      <mml:mrow>
                        <mml:mo mathsize="big">∑</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mo>∈</mml:mo>
                        <mml:mi mathvariant="normal">Σ</mml:mi>
                      </mml:mrow>
                    </mml:munder>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:mi>t</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width=".45em"/>
                    <mml:mo>=</mml:mo>
                  </mml:mtd>
                  <mml:mtd class="align-2">
                    <mml:mn>1</mml:mn>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>Notice that for all <italic>t</italic>, <italic>s</italic>(<italic>t</italic>) are not independent, therefore
<inline-formula><mml:math id="M4" name="1752-0509-6-116-i4" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula>. From now on, we define
<inline-formula><mml:math id="M5" name="1752-0509-6-116-i5" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> as <italic>instantaneous probabilities</italic>. Since the instantaneous probabilities do not define the full stochastic process, all possible joint probabilities should also be defined.</p>
        <p>In order to simplify the stochastic process, Markov property is imposed. It can be expressed in the following way: “the conditional probabilities in the future, related to the present and the past, depend only on the present” (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1 for the mathematical definition). The formal definition of a <italic>Markov process</italic> is a stochastic process with the Markov property.</p>
        <p>Any Markov process can be defined by (see Van Kampen
[<xref ref-type="bibr" rid="B19">19</xref>], chapter IV): </p>
        <p>1. An initial condition: </p>
        <p>
          <disp-formula id="bmcM2">
            <label>(2)</label>
            <mml:math id="M6" name="1752-0509-6-116-i6" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mn>0</mml:mn>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mspace width="2.77695pt"/>
              <mml:mo>;</mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mi mathvariant="normal">Σ</mml:mi>
            </mml:math>
          </disp-formula>
        </p>
        <p>2. Conditional probabilities (of a single condition): </p>
        <p>
          <disp-formula id="bmcM3">
            <label>(3)</label>
            <mml:math id="M7" name="1752-0509-6-116-i7" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>t</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>|</mml:mo>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:mfenced>
              <mml:mspace width="2.77695pt"/>
              <mml:mo>;</mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>∈</mml:mo>
              <mml:mi mathvariant="normal">Σ</mml:mi>
              <mml:mspace width="2.77695pt"/>
              <mml:mo>;</mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>,</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mi>I</mml:mi>
              <mml:mo>;</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>&lt;</mml:mo>
              <mml:mi>t</mml:mi>
            </mml:math>
          </disp-formula>
        </p>
        <p>Concerning time, two cases can be considered: </p>
        <p>• If time is discrete: <italic>t </italic>∈<italic> I </italic>= {<italic>t</italic><sub>0</sub>,
<italic>t</italic><sub>1</sub>,⋯}, it can be shown that all possible conditional probabilities are function of transition probabilities
[<xref ref-type="bibr" rid="B20">20</xref>]:
<inline-formula><mml:math id="M8" name="1752-0509-6-116-i8" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula>. In that case, a Markov process is often named a Markov chain.</p>
        <p>• If time is continuous: <italic>t </italic>∈<italic> I </italic>= [<italic>a</italic>,
<italic>b</italic>], it can be shown that all possible conditional probabilities are function of <italic>transition rates</italic>[<xref ref-type="bibr" rid="B19">19</xref>]:
<inline-formula><mml:math id="M9" name="1752-0509-6-116-i9" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>∞</mml:mi><mml:mo>]</mml:mo></mml:math></inline-formula>.</p>
        <p>Notice that a discrete time Markov process can be derived from continuous time Markov process, and is called a <italic>Jump Process</italic> with the following transition probabilities: </p>
        <p>
          <disp-formula>
            <mml:math id="M10" name="1752-0509-6-116-i10" overflow="scroll">
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>≡</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:munder>
                    <mml:mrow>
                      <mml:mo>∑</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mo>∈</mml:mo>
                      <mml:mi mathvariant="normal">Σ</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
            </mml:math>
          </disp-formula>
        </p>
        <p>If the transition probabilities or transition rates are time independent, the Markov process is called a <italic>time independent Markov process</italic>. In BKMC, only this case will be considered. For a time independent Markov process, the <italic>transition graph</italic> can be defined as follows: a transition graph is a graph in Σ, with an edge between <bold>S</bold> and <bold>S</bold><sup><italic>′</italic></sup> if and only if
<inline-formula><mml:math id="M11" name="1752-0509-6-116-i11" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> (or
<inline-formula><mml:math id="M12" name="1752-0509-6-116-i12" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> if time is discrete).</p>
      </sec>
      <sec>
        <title>Asynchronous Boolean dynamics as a discrete time Markov process</title>
        <p>Asynchronous Boolean dynamics
[<xref ref-type="bibr" rid="B2">2</xref>] is widely used in Boolean modeling. It can be easily interpreted as a discrete time Markov process
[<xref ref-type="bibr" rid="B21">21</xref>,<xref ref-type="bibr" rid="B22">22</xref>] as shown below.</p>
        <p>In the case of asynchronous Boolean dynamics, the system is given by <italic>n</italic> nodes (or agents), with a set of directed arrows linking these nodes and defining a network. For each node <italic>i</italic>, a Boolean logic <italic>B</italic><sub><italic>i</italic></sub>(<bold>S</bold>) is specified and depends only on the nodes <italic>j</italic> for which there exists an arrow from node <italic>j</italic> to <italic>i</italic> (<italic>e.g.</italic><italic>B</italic><sub>1</sub> =<italic> S</italic><sub>3</sub> AND NOT<italic>S</italic><sub>4</sub>, where <italic>S</italic><sub>3</sub> and <italic>S</italic><sub>4</sub> are the Boolean values of nodes 3 and 4 respectively, and <italic>B</italic><sub>1</sub>is the Boolean logic of node 1). The notion of <italic>asynchronous transition</italic> (AT) can be defined as a pair of network states
<inline-formula><mml:math id="M13" name="1752-0509-6-116-i13" overflow="scroll"><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:math></inline-formula>, written
<inline-formula><mml:math id="M14" name="1752-0509-6-116-i14" overflow="scroll"><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math></inline-formula> such that </p>
        <p>
          <disp-formula id="bmcM4">
            <label>(4)</label>
            <mml:math id="M15" name="1752-0509-6-116-i15" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>=</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>B</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mspace width="0.3em"/>
                    <mml:mtext>for a given</mml:mtext>
                    <mml:mspace width="0.3em"/>
                    <mml:mi>j</mml:mi>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>=</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mspace width="0.3em"/>
                    <mml:mtext>for</mml:mtext>
                    <mml:mspace width="0.3em"/>
                    <mml:mi>i</mml:mi>
                    <mml:mo>≠</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>To define a Markov process, the transition probabilities
<inline-formula><mml:math id="M16" name="1752-0509-6-116-i16" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula> can be defined: given two network states <bold>S</bold> and <bold>S</bold><sup><italic>′</italic></sup>, let <italic>γ</italic>(<bold>S</bold>) be the number of asynchronous transitions from <bold>S</bold> to all possible states <bold>S</bold><sup><italic>′</italic></sup>. Then </p>
        <p>
          <disp-formula id="bmcM5">
            <label>(5)</label>
            <mml:math id="M17" name="1752-0509-6-116-i17" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="-6.0pt"/>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>|</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>/</mml:mo>
                    <mml:mi>γ</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>if</mml:mtext>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>→</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>is an AT</mml:mtext>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="-6.0pt"/>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>|</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mo>=</mml:mo>
                    <mml:mn>0</mml:mn>
                    <mml:mtext>if</mml:mtext>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>→</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>is not an AT</mml:mtext>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>In this formalism, the asynchronous Boolean dynamics completely defines a discrete time Markov process when the initial condition is specified. Notice that here the transition probabilities are time independent, <italic>i.e.</italic><inline-formula><mml:math id="M18" name="1752-0509-6-116-i18" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula>. Therefore, the approaches, mentioned in section “Continuous time in Boolean modeling: past and present”, that introduce time implicitly by adding probabilities to each transition of the transition graph, can be seen as a generalization of the definition of <italic>γ</italic>(<bold>S</bold>).</p>
      </sec>
      <sec>
        <title>Continuous time Markov process as a generalization of asynchronous Boolean dynamics</title>
        <p>To transform the discrete time Markov process described above in a continuous time Markov process, transition probabilities should be replaced by transition rates
<inline-formula><mml:math id="M19" name="1752-0509-6-116-i19" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>. In that case, conditional probabilities are computed by solving a master equation (equation 2 in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1). We present below the corresponding numerical algorithm, the <italic>Kinetic Monte-Carlo</italic> algorithm
[<xref ref-type="bibr" rid="B23">23</xref>].</p>
        <p>Because we want a generalization of the asynchronous Boolean dynamics, transition rates
<inline-formula><mml:math id="M20" name="1752-0509-6-116-i20" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula> are non-zero <underline>only if</underline><bold> S</bold> and <bold>S</bold><sup><italic>′</italic></sup> differ by only one node. In that case, each Boolean logic <italic>B</italic><sub><italic>i</italic></sub>(<bold>S</bold>)is replaced by two functions
<inline-formula><mml:math id="M21" name="1752-0509-6-116-i21" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mtext>up/down</mml:mtext></mml:mrow></mml:msubsup><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>∞</mml:mi><mml:mo>[</mml:mo></mml:math></inline-formula>. The transition rates are defined as follows: if <italic>i</italic> is the node that differs from <bold>S</bold> and <bold>S</bold><sup><italic>′</italic></sup>, then </p>
        <p>
          <disp-formula id="bmcM6">
            <label>(6)</label>
            <mml:math id="M22" name="1752-0509-6-116-i22" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>ρ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mo>→</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">up</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>if</mml:mtext>
                    <mml:mspace width=".3em"/>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:mn>0</mml:mn>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>ρ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mo>→</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mtext>down</mml:mtext>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>if</mml:mtext>
                    <mml:mspace width=".3em"/>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>R</italic><sub><italic>i</italic></sub><sup>up</sup> corresponds to the activation rate of node <italic>i</italic>, and <italic>R</italic><sub><italic>i</italic></sub><sup>down</sup> corresponds to the inactivation rate of node <italic>i</italic>. Therefore, the continuous Markov process is completely defined by all these <italic>R</italic><sup>up/down</sup> and an initial condition.</p>
      </sec>
      <sec>
        <title>Asymptotic behavior of continuous time Markov process</title>
        <p>In the case of continuous time Markov process, instantaneous probabilities always converge to a stationary distribution (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 2, section 1.2). A <italic>stationary distribution</italic> of a given Markov process corresponds to the set of instantaneous probabilities of a stationary Markov process which has the same transition probabilities (or transition rates) as the given discrete (or continuous) time Markov process. A <italic>stationary Markov process</italic> has the following property: for every joint probability
<inline-formula><mml:math id="M23" name="1752-0509-6-116-i23" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow></mml:mfenced></mml:math></inline-formula> and ∀<italic>τ</italic>: </p>
        <p>
          <disp-formula id="bmcM7">
            <label>(7)</label>
            <mml:math id="M24" name="1752-0509-6-116-i24" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1"/>
                  <mml:mtd class="align-2">
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mo>…</mml:mo>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1"/>
                  <mml:mtd class="align-2">
                    <mml:mspace width="2.77695pt"/>
                    <mml:mspace width="2.77695pt"/>
                    <mml:mo>=</mml:mo>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>+</mml:mo>
                        <mml:mi>τ</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>+</mml:mo>
                        <mml:mi>τ</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mo>…</mml:mo>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>Notice that instantaneous probabilities
<inline-formula><mml:math id="M25" name="1752-0509-6-116-i25" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> of a stationary stochastic process are time independent.</p>
        <p>The asymptotic behavior of a continuous time Markov process can be detailed by using the concept of <italic>indecomposable stationary distributions</italic>: indecomposable stationary distributions are stationary distributions that cannot be expressed as a linear combination of different stationary distributions. A linear combination of stationary distributions is also a stationary distribution, since instantaneous probabilities are solutions of a master equation which is linear (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 2, section 1.1). Therefore, a complete description of the asymptotic behavior is given by the linear combination of indecomposable stationary distributions to which the Markov process converges.</p>
      </sec>
      <sec>
        <title>Oscillations and cycles</title>
        <p>In order to describe a periodic behavior, the notion of cycle and oscillation for a continuous time Markov process is defined precisely.</p>
        <p>A <italic>cycle</italic> is a loop in the transition graph. This is a topological characterization in the transition graph that does not depend on the exact value of the transition rates. It can be shown that a cycle with no outgoing edges corresponds to an indecomposable stationary distribution (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 1, section 1.2).</p>
        <p>The question is then to link the notion of cycle to that of periodic behavior of instantaneous probabilities. The set of instantaneous probabilities cannot be perfectly periodic. They can display a damped oscillating behavior, or none at all (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.3). A <italic>damped oscillatory</italic> Markov process can be formally defined as a continuous time process that has at least one instantaneous probability with an infinite number of extrema.</p>
        <p>According to theorems described in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref> (“Basic information on Markov process”, theorems 6-8 and Corollary 3, section 1.3), a necessary condition for having damped oscillations is that the transition matrix has at least one non-real eigenvalue (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 4, section 1.1). In that case, there always exists an initial condition that produces damped oscillations. For the transition matrix to have a non-real eigenvalue, a Markov process needs to have a cycle. However, the reverse is not true: a Markov process with a cycle does not necessarily imply the existence of a non-real eigenvalue in the transition matrix. In the toy model of a single cycle, presented in the “Examples” section, non-real eigenvalues may or may not exist, according to different values of transition rates.</p>
      </sec>
      <sec>
        <title>BKMC: Kinetic Monte-Carlo (Gillespie algorithm) applied to continuous time asynchronous Boolean Dynamics</title>
        <p>It has been previously stated that a continuous time Markov process is completely defined by its initial condition and its transition rates. For computing any conditional probability (and any joint probability), a set of linear differential equations has to be solved (the master equation). Theoretically, the master equation can be solved exactly by computing the exponential of the transition matrix (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 5, section 1.1). However, because the size of this transition matrix is 2<sup><italic>n</italic></sup>×2<sup><italic>n</italic></sup>, the computation soon becomes impossible if <italic>n</italic> is large. To remedy this problem, it is possible to use a simulation algorithm that samples the probability space by computing time trajectories in the transition graph.</p>
        <p>The Kinetic Monte-Carlo
[<xref ref-type="bibr" rid="B23">23</xref>] (or Gillespie algorithm
[<xref ref-type="bibr" rid="B24">24</xref>]) is a simple algorithm for exploring the probability space of a Markov process defined by a set of transition rates. In fact, it can be understood as a formal definition of a continuous time Markov process. This algorithm produces a set of <italic>realizations</italic> or <italic>stochastic trajectories</italic> of the Markov process, given a set of uniform random numbers in [0,1]. By definition, a trajectory
<inline-formula><mml:math id="M26" name="1752-0509-6-116-i26" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> is a function from a time window [0,<italic>t</italic><sub>max</sub> to Σ. The set of stochastic trajectories represents the given Markov process in the sense that these trajectories can be used to compute probabilities. A finite set of these trajectories is produced, then, from this finite set, probabilities are estimated (as described in “Methods” section). The algorithm is based on an iterative step: from a state <bold>S</bold> at time <italic>t</italic><sub>0</sub>(given two uniform random numbers), it produces a transition time <italic>δt</italic> and a new state
<inline-formula><mml:math id="M27" name="1752-0509-6-116-i27" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>, with the following interpretation: the trajectory
<inline-formula><mml:math id="M28" name="1752-0509-6-116-i28" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> is such that
<inline-formula><mml:math id="M29" name="1752-0509-6-116-i29" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:math></inline-formula> for <italic>t</italic>∈<italic>t</italic><sub>0</sub><italic>t</italic><sub>0</sub> + <italic>δt</italic> and
<inline-formula><mml:math id="M30" name="1752-0509-6-116-i30" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>δt</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. Iteration of this step is done until a specified maximum time is reached. The initial state of each trajectory is based on the (probabilistic) initial condition that also needs to be specified.</p>
        <p>The exact iterative procedure is the following. Given <bold>S</bold> and two uniform random numbers <italic>u</italic>,<italic>u</italic><sup><italic>′</italic></sup>∈[0,1]: </p>
        <p>1. Compute the total rate of possible transitions for leaving state <bold>S</bold>:
<inline-formula><mml:math id="M31" name="1752-0509-6-116-i31" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mtext>tot</mml:mtext></mml:mrow></mml:msub><mml:mo>≡</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
        <p>2. Compute the time of the transition:
<inline-formula><mml:math id="M32" name="1752-0509-6-116-i32" overflow="scroll"><mml:mi>δt</mml:mi><mml:mo>≡</mml:mo><mml:mo>−</mml:mo><mml:mo>log</mml:mo><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mtext>tot</mml:mtext></mml:mrow></mml:msub></mml:math></inline-formula></p>
        <p>3. Order the possible new states
<inline-formula><mml:math id="M33" name="1752-0509-6-116-i33" overflow="scroll"><mml:msup><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mspace width="0.3em"/></mml:math></inline-formula> and their respective transition rates
<inline-formula><mml:math id="M34" name="1752-0509-6-116-i34" overflow="scroll"><mml:msup><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo mathvariant="bold">(</mml:mo><mml:mi mathvariant="bold">j</mml:mi><mml:mo mathvariant="bold">)</mml:mo></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
        <p>4. Compute the new state
<inline-formula><mml:math id="M35" name="1752-0509-6-116-i35" overflow="scroll"><mml:msup><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> such that
<inline-formula><mml:math id="M36" name="1752-0509-6-116-i36" overflow="scroll"><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mtext>tot</mml:mtext></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>≤</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> (by convention, <italic>ρ</italic><sup>(0)</sup>=0).</p>
        <p>This algorithm will be referred to as <italic>Boolean Kinetic Monte-Carlo</italic> or BKMC.</p>
      </sec>
    </sec>
    <sec>
      <title>Practical use of BKMC, through MaBoSS tool</title>
      <p>Biological data are translated into an influence network with logical rules associated to each node of the network. The value of one node depends on the value of the input nodes. For BKMC, another layer of information is provided when compared to the standard definition of Boolean models: transition rates are provided for all nodes, specifying the rates at which the node turns on and off. This refinement conserves the simplicity of Boolean description but allows to reproduce more accurately the observed biological dynamics. The parameters do not need to be exact as it is the case for nonlinear ordinary differential equation models, but they can be used to illustrate the relative speed of reactions. We developed a software tool, MaBoSS, that applies BKMC algorithm. MaBoSS stands for Markov Boolean Stochastic Simulator.</p>
      <sec>
        <title>How to build a mathematical model using MaBoSS</title>
        <p>Once MaBoSS is installed (see webpage for instructions,
<ext-link ext-link-type="uri" xlink:href="https://maboss.curie.fr">https://maboss.curie.fr</ext-link>), the protocol to follow to simulate a model can be described in four steps: </p>
        <p>1. Create the model using MaBoSS language in a file (myfile.bnd, for instance): (a) write the logic for each node, and (b) assign values to each transition rate.</p>
        <p>2. Create the configuration file (myfile.cfg, for instance) to define the simulation parameters.</p>
        <p>3. Run MaBoSS (the order of the arguments does not matter):</p>
        <p>
          <monospace>MaBoSS -c myfile.cfg -o myfile_out myfile.bnd</monospace>
        </p>
        <p>(we assume that MaBoSS is accessible through you PATH).MaBoSS creates three output files: </p>
        <p>• <monospace>myfile_out_proptraj.csv</monospace></p>
        <p>This file contains the network state probabilities on a time window, the entropy, the transition entropy and the Hamming distance distribution (see “Methods”)</p>
        <p>• <monospace>myfile_out_statdist.csv</monospace></p>
        <p>This file contains the stationary distribution characterization (see “Methods”)</p>
        <p>• <monospace>myfile_out_run.txt</monospace></p>
        <p>This file contains a summary of MaBoSS simulation run.</p>
        <p>4. Import output csv files in Excel or R and generate your graphs.</p>
      </sec>
      <sec>
        <title>Transition rates in MaBoSS</title>
        <p>MaBoSS defines transition rates
<inline-formula><mml:math id="M37" name="1752-0509-6-116-i37" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula> by the functions <italic>R</italic><sub><italic>i</italic></sub><sup>up/down</sup> (<bold>S</bold>) (see equations 6). The functions can be written using all Boolean operators (AND, OR, NOT, XOR), arithmetic operators (+,-,*,/), comparison operators and the conditional operator (?:). Examples of the use of the language are given below to illustrate three different cases: (1) different speeds for different inputs, (2) buffering effect and (3) the translation of discrete variables (with three values: 0, 1 and 2) into a Boolean model. </p>
        <p>1. Modeling different speeds for different inputs.Suppose that C is activated by A or B, but that B can activate C faster than A, and that C is inactivated when A and B are absent. In this case, we write: </p>
        <p>
          <monospace>node C {</monospace>
        </p>
        <p>
          <monospace> rate_up = B ? $kb : (A ? $ka : 0.0);</monospace>
        </p>
        <p>
          <monospace> rate_down = !(A &amp; B ) ? 1.0 : 0.0;</monospace>
        </p>
        <p> }</p>
        <p> When C is off (equal to 0), it is activated by B at a speed $kb. If B is absent, then C is activated by A at a speed $ka. If both are absent, C is not activated. Note that if both A and B are present, because of the way the logic is written in this particular case, C is activated at the highest speed, the speed $kb. When C is on (equal to 1), it is inactivated at a rate equal to 1 in the absence of both A and B.</p>
        <p> To implement the synergistic effect of A and B, <italic>i.e.</italic> when both A and B are on, C is activated at a rate $kab, then we can write:</p>
        <p>
          <monospace>node C {</monospace>
        </p>
        <p>
          <monospace>rate_up = (A &amp; !B ? $ka : 0.0)+(B &amp; !A ? $kb : 0.0) + (A &amp; B ? $kab : 0.0);</monospace>
        </p>
        <p>
          <monospace> rate_down = !(A &amp; B ) ? 1.0 : 0.0;</monospace>
        </p>
        <p> }</p>
        <p>2. Modeling buffering effect.Suppose that B is activated by A, but that B can remain active a long time after A has shut down. For that, it is enough to define different speeds of activation and inactivation:</p>
        <p>
          <monospace>node B {</monospace>
        </p>
        <p>
          <monospace>rate_up = A ? 2.0 : 0.0;</monospace>
        </p>
        <p>
          <monospace>rate_down = A ? 0.0 : 0.001;</monospace>
        </p>
        <p>}</p>
        <p> B is activated by A at a rate equal to 2. When A is turned off, B is inactivated more slowly at a rate equal to 0.001.</p>
        <p>3. Modeling different levels for a given node.Suppose that B is activated by A, but if the activity of A is maintained, B can reach a second level. For this, we define a second node B_h (for “B high”) with the following rules:</p>
        <p>
          <monospace>node B {</monospace>
        </p>
        <p>
          <monospace>rate_up = A ? 1.0 : 0.0; </monospace>
        </p>
        <p>
          <monospace>rate_down = (A | B_h) ? 0.0 : 1.0;</monospace>
        </p>
        <p>}</p>
        <p>
          <monospace>node B_h {</monospace>
        </p>
        <p>
          <monospace>rate_up = (A &amp; B) ? 1.0 : 0.0;</monospace>
        </p>
        <p>
          <monospace>rate_down = (A) ? 0.0 : 1.0;</monospace>
        </p>
        <p>}</p>
        <p> In this example, B is separated in two variables: B which corresponds to the first level of B and B_h which corresponds to the higher level of B. B is activated by A at a rate equal to 1. If A disappears before B has reached its second level B_h then B is turned off at a rate equal to 1. If A is maintained and B is active, then B_h is activated at a rate equal to 1. When A is turned off, B_h is inactivated at a rate equal to 1.</p>
      </sec>
      <sec>
        <title>Simulation parameters in MaBoSS</title>
        <p>To simulate a model in MaBoSS, a set of parameters needs to be adjusted (see “Parameter list” in the reference card available in the webpage). MaBoSS assigns default values, however, they need to be tuned for each model to achieve optimal performances: the best balance between the convergence of estimates and the computation time needs to be found. Therefore, several simulations should be run with different sets of parameters for best tuning. </p>
        <p>• Internal nodes: <italic>node.is_internal</italic>As explained in “Methods” (in “Initial conditions and outputs”), internal nodes correspond to species that are not measured explicitly. Practically, the higher the number of internal nodes, the better the convergence of the BKMC algorithm.</p>
        <p>• Time window for probabilities: <italic>timetick</italic>This parameter is used to compute estimates of network state probabilities (see “Network state probabilities on a time window” in “Methods”). A time window can be set as the minimum time needed for nodes to change their states. This parameter also controls the convergence of probability estimates. The larger the time window, the better the convergence of probability estimates.</p>
        <p>• Maximum time: <italic>max_time</italic>MaBoSS produces trajectories for a predefined amount of time, set by the parameter max_time. If the time of the biological process is known, then the maximum time parameter can be explicitly set. If the time of the biological process is not known, then there exists a more empirical way to set the maximum time. It is advised to choose a maximum time parameter that is slightly bigger than the inverse of the smallest transition rate.Note that the computing time in MaBoSS is proportional to this maximum time. Moreover, the choice of the maximum time impacts the stationary distribution estimates: a longer maximum time increases the quality of these estimates.</p>
        <p>• Number of trajectories: <italic>sample_count</italic>This parameter directly controls the quality of BKMC estimation algorithm. Practically, the convergence of the estimates increases as the number of trajectories is increased.</p>
        <p>• Number of trajectories (<italic>statdist_traj_count</italic>) and similarity threshold (<italic>statsdist_cluster_threshold</italic>) for stationary distribution estimatesThe <italic>statdist_traj_count</italic> parameter corresponds to a subset of trajectories used only for stationary distribution estimates. To avoid explosion of computing time, this parameter needs to be lower than the number of trajectories (rather than equal to).The <italic>statsdist_cluster_threshold</italic> parameter corresponds to the threshold for constructing the clusters of stationary distribution estimates. Ideally, it should be set to a high value (close to 1). However, if the threshold is too high then the clustering algorithm might not be efficient.</p>
      </sec>
      <sec>
        <title>Comparison with biological data</title>
        <p>Each node of the network should account for different levels of activity of the corresponding species (mRNA, protein, protein complex, etc.). It is possible to have more than two levels for one node, as shown in the example “Modeling different levels for a given node”.</p>
        <p>It is possible to extract the transition rates from experimental data, using the following property: the rate of a given transition is the inverse of the mean time for this transition to happen. It should be noticed than BKMC is an algorithm based on a linear equation (Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 2, section 1.1); therefore, small variations of transition rates will not affect the qualitative behavior of the model.</p>
        <p>BKMC algorithm provides estimates of the network state probabilities over time. These probabilities can be interpreted in terms of a cell population. The asymptotic behavior of a model, represented by a linear combination of indecomposable stationary distributions, can be interpreted as a combination of cell sub-populations. Indeed, a sub-population can be defined by network states with non-zero probability in the indecomposable stationary distribution. Therefore, a cell in a sub-population can only evolved in this sub-population (Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 1, section 1.2 and from the definition of strongly connected component with no outgoing edges).</p>
      </sec>
      <sec>
        <title>Comparison of MaBoSS with other existing tools for qualitative modeling</title>
        <p>MaBoSS contributes to the effort of tool development for qualitative modeling of biological networks. We propose to compare MaBoSS to some existing tools. However, it is difficult to compare the performance of these tools since each of them achieves different purposes and provides different outputs. As an alternative, we recapitulate, in Figure
<xref ref-type="fig" rid="F1">1</xref>, the characteristics and implications for each software. Some tools may be more appropriate than others according to the type of input, network size and expected output. Figure
<xref ref-type="fig" rid="F1">1</xref> is intended to help the users decide which software to use in a practical situation. We consider the following tools: GINsim
[<xref ref-type="bibr" rid="B8">8</xref>], CellNetAnalyzer
[<xref ref-type="bibr" rid="B25">25</xref>], BoolNet
[<xref ref-type="bibr" rid="B26">26</xref>], GNA
[<xref ref-type="bibr" rid="B27">27</xref>], and SQUAD
[<xref ref-type="bibr" rid="B28">28</xref>]. This list is not exhaustive but informs on where MaBoSS stands.</p>
        <fig id="F1" position="float">
          <label>Figure 1</label>
          <caption>
            <p><bold>Comparison of tools for discrete modeling, biological implication.</bold> Comparison table of the following tools: MaBoSS, GINsim, CellNetAnalyzer, BoolNet, GNA, SQUAD. Technical aspects are provided, along with the inputs/outputs relations between a model and data. The last row illustrates graphically the typical outputs that can be obtained from each tool.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-1"/>
        </fig>
        <p>As an illustration, the third example of the “Examples” section below, the mammalian cell cycle, was implemented in three of the tools presented in Figure
<xref ref-type="fig" rid="F1">1</xref>: MaBoSS, GINsim, BoolNet (see Additional file
<xref ref-type="supplementary-material" rid="S2">2</xref> “Model of the mammalian cell cycle with GINsim, BoolNet and MaBoSS.” for details of the results).</p>
      </sec>
    </sec>
    <sec>
      <title>Examples</title>
      <p>We have applied BKMC algorithm to three models of different sizes. The first one is a toy model illustrating the dynamics of a single cycle; the second one is a published Boolean model of p53-Mdm2 response to DNA damage and illustrates a multi-level case; and the third one is a published Boolean model of mammalian cell cycle regulation. Note that MaBoSS has been used for these three examples, but Markov process can be computed directly for the two first ones, without our BKMC algorithm because these models are small enough (by computing exponential of transition matrix, see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1), as proposed in
[<xref ref-type="bibr" rid="B16">16</xref>]. BKMC is best suited for larger networks, when the network state space is too large to be computed with standard existing tools (&gt;∼2<sup>10</sup>). The first two examples were chosen for their simplicity, and because they illustrate how global characterizations (entropy and transition entropy, see “Entropiesł::bel sect:entropies” in “Methods”) can be used. The third example shows the use of BKMC/MaBoSS for a more consequent and complex model for which the analysis is not obvious.</p>
      <p>For the purpose of this article, we built the transition graphs for the first two examples (with GINsim
[<xref ref-type="bibr" rid="B8">8</xref>]) in order to help the reasoning. However, it is important to note that BKMC algorithm does not construct the transition graph explicitly.</p>
      <p>All input files and results are given in the webpage of MaBoSS (
<ext-link ext-link-type="uri" xlink:href="https://maboss.curie.fr">https://maboss.curie.fr</ext-link>) with additional examples.</p>
      <sec>
        <title>Toy model of a single cycle</title>
        <p>We consider three species, A, B and C, where A is activated by C and inhibited by B, B is activated by A and C is activated by A or B (Figure
<xref ref-type="fig" rid="F2">2</xref>a).</p>
        <fig id="F2" position="float">
          <label>Figure 2</label>
          <caption>
            <p><bold>Toy model.</bold> Toy model of a single cycle. <bold>(a)</bold> Influence network. <bold>(b)</bold> Logical rules and transition rates of the model. <bold>(c)</bold> Simulation parameters.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-2"/>
        </fig>
        <p>The model is defined within the language of MaBoSS by a set of logical rules associated to each node (Figure
<xref ref-type="fig" rid="F2">2</xref>b) and simulation parameters set for optimal performances (Figure
<xref ref-type="fig" rid="F2">2</xref>c). The associated transition graph, generated by GINsim, is shown in Figure
<xref ref-type="fig" rid="F3">3</xref>.</p>
        <fig id="F3" position="float">
          <label>Figure 3</label>
          <caption>
            <p><bold>Transition graph of the toy model.</bold> Transition graph for the toy model (generated by GINsim). The node states should be read as [ABC] = [<sup>∗∗∗</sup>]. [ABC]=[100] corresponds to a state in which only A is active. The nodes in green belong to a cycle, the node in red is the fixed point and the other nodes are in blue.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-3"/>
        </fig>
        <p>The only stationary distribution is the fixed point [ABC]=[000]. We study two cases: when the rate of the transition from state [001] to state [000] (corresponding to the inactivation of C) is fast and when this rate is slow. We will refer to this transition rate as the <italic>escape rate</italic>. For both cases, we plot the time trajectories of the probabilities of the fixed point [ABC]=[000] and of the probabilities of A active [ABC]=[1<sup>∗∗</sup>] where <sup>∗</sup>can be either 1 or 0, along with the trajectories of the entropy and the transition entropy.</p>
        <p>In the first case, when the escape rate is fast, we set the parameter for the transition to a high value (rate_up = 10). In Figure
<xref ref-type="fig" rid="F4">4</xref>, we notice that the probability that [ABC] is equal to [000] converges to 1. We can conclude that [ABC]=[000] is a fixed point. In addition, the entropy and the transition entropy converge to 0. With BKMC, these properties confirm that [ABC]=[000] is a fixed point. The peak in the trajectory of the entropy (between times 0 and 0.6) corresponds to a set of states that are transiently activated before reaching the fixed point.</p>
        <fig id="F4" position="float">
          <label>Figure 4</label>
          <caption>
            <p><bold>MaBoSS outputs of the toy model with fast escape rate.</bold> BKMC algorithm is applied to the toy model, with a fast escape rate. Trajectory of the network state probabilities [ABC]=[000] and [ABC]=[1<sup>∗∗</sup>] (where <sup>∗</sup>can be either 0 or 1), the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted. Because the probability of [ABC]=[000] converges to 1, [ABC]=[000] is a fixed point. The asymptotic behavior of both the entropy and the transition entropy is also the signature of a fixed point.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-4"/>
        </fig>
        <p>In the second case, when the escape rate is slow, we set the parameter for the transition to a low value (rate_down = 10<sup>−5</sup>). As illustrated in Figure
<xref ref-type="fig" rid="F5">5</xref>, the transition entropy is and remains close to zero but the entropy does not converge to zero, which is the signature of a cyclic stationary distribution (see “Entropiesł::bel sect:entropies” in “Methods”). This corresponds to the cycle [111] → [011] → [001] → [101] in the transition graph (Figure
<xref ref-type="fig" rid="F3">3</xref>). However, as seen in the transition graph, one state in the cycle has an outgoing edge that leads to the fixed point (through the transition [001] → [000] in Figure
<xref ref-type="fig" rid="F3">3</xref>). If the trajectories are plotted on a larger time scale (Figure
<xref ref-type="fig" rid="F6">6</xref>), the entropy eventually converges to 0 and the trajectory of the fixed point converges to 1, which corresponds to the case of fast escape rate. Since the value of the transition entropy of Figure
<xref ref-type="fig" rid="F5">5</xref> is not exactly zero, but 10<sup>−4</sup>, it can be anticipated that the cyclic behavior is not stable. We can conclude on stable cyclic behaviors only when the transition entropy is exactly 0.</p>
        <fig id="F5" position="float">
          <label>Figure 5</label>
          <caption>
            <p><bold>MaBoSS outputs of the toy model with slow escape rate.</bold> BKMC algorithm is applied to the toy model, with a slow escape rate. Trajectory of the network state probabilities [ABC]=[000] and [ABC]=[1**], the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted. The asymptotic behavior of both the entropy and the transition entropy seems to be the signature of a cycle.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-5"/>
        </fig>
        <fig id="F6" position="float">
          <label>Figure 6</label>
          <caption>
            <p><bold>MaBoSS outputs of toy model with slow escape rate, large time scale.</bold> BKMC algorithm is applied to the toy model, with a slow escape rate, plotted on a larger time scale. Trajectory of probabilities ([ABC]=[000] and [ABC]=[1**]), the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted. On a large time scale, the asymptotic behavior of both the entropy and the transition entropy is similar to the case of the fast escape rate (Figure
<xref ref-type="fig" rid="F3">3</xref>).</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-6"/>
        </fig>
        <p>By considering the spectrum of the transition matrix (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1 and proof of theorem 4), it can be proven that the model with a slow escape rate is a damped oscillatory process whereas the model with a large escape rate is not. As mentioned previously, a cycle in the transition graph may or may not lead to an oscillatory behavior. Moreover, if the transition entropy seems to converge to a small value on a small time scale, and the entropy does not, this behavior illustrates the case of a transient cycle in the transition graph.</p>
      </sec>
      <sec>
        <title>p53-Mdm2 signaling</title>
        <p>We consider a model of p53 response to DNA damage
[<xref ref-type="bibr" rid="B18">18</xref>]. p53 interacts with Mdm2, which appears in two forms, cytoplasmic and nuclear. On one hand, p53 upregulates the level of cytoplasmic Mdm2 (Mdm2c), which is then transported into the nucleus, and inhibits the export of nuclear Mdm2 (Mdm2n). On the other hand, nuclear Mdm2 (Mdm2n) facilitates the degradation of p53 through ubiquitination. In the model, stress regulates the level of DNA damage (Dam), which in turn participates in the degradation process of Mdm2 in the nucleus. p53 inhibits DNA damage signal by promoting DNA repair. Here, stress is not shown explicitly (Figure
<xref ref-type="fig" rid="F7">7</xref>a).</p>
        <fig id="F7" position="float">
          <label>Figure 7</label>
          <caption>
            <p><bold>Model of p53 response to DNA damage.</bold> Model of p53 response to DNA damage. <bold>(a)</bold> Influence network. <bold>(b)</bold> Logical rules and transition rates of the model. <bold>(c)</bold> Simulation parameters.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-7"/>
        </fig>
        <p>The model is written in MaBoSS, with two levels of p53 (Figure
<xref ref-type="fig" rid="F7">7</xref>b), as it is done in Abou-Jaoudé <italic>et al.</italic>[<xref ref-type="bibr" rid="B18">18</xref>] with the appropriate simulation parameters (Figure
<xref ref-type="fig" rid="F7">7</xref>c). The associated transition graph, also generated by GINsim, is given in Figure
<xref ref-type="fig" rid="F8">8</xref>. It shows the existence of two cycles and of a fixed point [p53 Mdm2C Mdm2N Dam] = [0010] where nuclear Mdm2 is on and the rest is off.</p>
        <fig id="F8" position="float">
          <label>Figure 8</label>
          <caption>
            <p><bold>Transition graph of the model of p53 response to DNA damage.</bold> Transition graph of the p53 model (generated by GINsim). The node states should be read as [p53 Mdm2C Mdm2N Dam] = [<sup>∗∗∗∗</sup>] (where <sup>∗</sup>can be either 0 or 1). For instance, [p53 Mdm2C Mdm2N Dam]=[1000] corresponds to a state in which only p53 (at its level 1) is active. The nodes in green and the nodes in light blue belong to two cycles, the node in red is the fixed point and the other nodes are in dark blue.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-8"/>
        </fig>
        <p>In order to represent the activity of p53, the trajectories of the probabilities of all network states with p53 equal to 1 and with p53 equal to 2 are plotted (Figure
<xref ref-type="fig" rid="F9">9</xref>, upper panel), with the initial condition: [p53 Mdm2C Mdm2N Dam] = [0<sup>∗</sup>11] and for the situation when p53 is set to its highest value (2 equivalent to p53_h) and thus can promote Mdm2 cytoplasmic activity.</p>
        <fig id="F9" position="float">
          <label>Figure 9</label>
          <caption>
            <p><bold>MaBoSS outputs of the model of p53 response to DNA damage.</bold> Trajectories of the network state probabilities of [p53 Mdm2C Mdm2N Dam] = [1<sup>∗∗∗</sup>] and of [p53 Mdm2C Mdm2N Dam] = [2<sup>∗∗∗</sup>], the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-9"/>
        </fig>
        <p>The qualitative results obtained with MaBoSS are similar to those of Abou-Jaoudé and colleagues. However, at the level of cell population, some discrepancies appear: in Figure
<xref ref-type="fig" rid="F9">9</xref>, no damped oscillations can be seen as opposed to Figure
<xref ref-type="fig" rid="F8">8</xref> of their article. The reason is that, in their computations, the noise imposed on time is defined by a square distribution on a limited time frame, whereas in BKMC, Markovian hypotheses imply that the noise distribution is more spread out from 0 to infinity. The consequence is that synchronization is lost very fast. Damped oscillations could be observed with BKMC with a particular set of parameters: fast activation of p53 and slow degradation of p53 (results not shown).</p>
        <p>With MaBoSS, we clearly interpret the system as a population and not as a single cell. In addition, we can simulate different contexts, presented in the initial article as different models, within one single model that uses different simulation parameters to account for these contexts.</p>
        <p>Note that the existence of transient cycles, as shown in the toy model, can be deduced from the trajectory of the entropy that is significantly higher than the trajectory of the transition entropy (which is non-zero, therefore the transient cycles are not stable) (Figure
<xref ref-type="fig" rid="F9">9</xref>, lower panel).</p>
      </sec>
      <sec>
        <title>Mammalian cell cycle</title>
        <p>For the last example, we propose a model of the mammalian cell cycle initially published as on ODE model by Novák and Tyson
[<xref ref-type="bibr" rid="B29">29</xref>] and translated into a Boolean model by Fauré and colleagues
[<xref ref-type="bibr" rid="B6">6</xref>]. The latter model encompasses 10 nodes, which describe the mechanisms controlling the activity of the different CDK/cyclin complexes, the main actors of cell cycle regulation and the dynamics of entry into the cell cycle in presence of growth factors.</p>
        <p>We implement the logical rules of the published model in MaBoSS and define two parameter values for the transition rates: a slow one (set to 1) and a fast one (set to 10). The choice between slow and fast rates for each transition is based on the choice made in the published Boolean model: different priority classes were used in mixed discrete a/synchronous simulation and corresponded to the differences in speed of cellular processes such as transcription, degradation and protein modification. We could, of course, refine the analysis by setting different rates for each transition. The network, the logical rules and the simulation parameters can be found on the webpage.</p>
        <p>As mentioned before, MaBoSS can provide two types of outputs: the probabilities of different network states over time (along with the entropy and transition entropy) and the indecomposable stationary distributions.</p>
        <p>We consider two biological cases, in the presence of growth factors where the cell enters its division cycle and in the absence of growth factors where the cell is stuck in a G1-like state (state preceding replication of DNA). In the model, the activity of CyclinD (CycD), a G1-cyclin, illustrates the presence of growth factors. In our simulations, we set an initial condition corresponding to a G1 state with two CDK/cyclin inhibitors, p27 and cdh1, on, and with CyclinD on in order to account for the external growth signal. We plot the trajectories of the probabilities of all the cyclins A, B and E (Figure
<xref ref-type="fig" rid="F10">10</xref>, upper panel). The cyclins’ activities exhibit an oscillatory behavior. Each oscillation can be interpreted as a cell division cycle. However, these oscillations are damped. This can be explained by the fact that these probabilities should be interpreted at the cell population level and after few cycles, the cells become desynchronized. Moreover the trajectories of the entropy and the transition entropy exhibit the signature of cyclic attractors (Figure
<xref ref-type="fig" rid="F10">10</xref>, lower panel).</p>
        <fig id="F10" position="float">
          <label>Figure 10</label>
          <caption>
            <p><bold>MaBoSS outputs of the model of the mammalian cell cycle: trajectories of probabilities.</bold> BKMC algorithm is applied to the mammalian cell cycle model, with an initial condition corresponding to a G1 state in the presence of growth factors (CyclinD is on). Trajectories of the cyclins probabilities, the entropy (<italic>H</italic>), transition entropy (<italic>TH</italic>) are plotted. The asymptotic behavior corresponds to the first indecomposable stationary distribution identified in Figure
<xref ref-type="fig" rid="F10">10</xref>.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-10"/>
        </fig>
        <p>The indecomposable stationary distributions are identified by the clustering algorithm of MaBoSS and illustrated in Figure
<xref ref-type="fig" rid="F11">11</xref>. The two clusters in Figure
<xref ref-type="fig" rid="F11">11</xref>a show the two types of solutions for random initial conditions: one multi-cyclic solution when CyclinD is on, and which corresponds to the distribution of network states of the asymptotic solution of Figure
<xref ref-type="fig" rid="F11">11</xref>b, and one fixed point corresponding to a G1 arrest when CyclinD is off (Figure
<xref ref-type="fig" rid="F11">11</xref>c).</p>
        <fig id="F11" position="float">
          <label>Figure 11</label>
          <caption>
            <p><bold>MaBoSS outputs of the model of the mammalian cell cycle: stationary distributions.</bold> BKMC algorithm is applied to the mammalian cell cycle model, with random initial conditions. Results of the clustering algorithm that associates a cluster to each indecomposable stationary distribution. <bold>(a)</bold> Probability of reaching each identified cluster; these probabilities are estimated by the proportion of trajectories that belong to each cluster. <bold>(b)</bold> First estimated cluster that can be interpreted as a desynchronized population of cells that are dividing. <bold>(c)</bold> Second estimated cluster, corresponding to a fixed point, that can be interpreted as a G1 cell cycle arrest with no growth factors.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-11"/>
        </fig>
        <p>These two indecomposable stationary distributions correspond to the two attractors identified by discrete time modeling in Fauré <italic>et al.</italic> In the discrete time algorithm, the asymptotic behavior is described in terms of attractors (sub-parts of the transition graph); in our algorithm, the asymptotic behavior is described in terms of network state probability distributions.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>We have presented a new algorithm, Boolean Kinetic Monte-Carlo or BKMC, applicable to dynamical simulation of signaling networks based on continuous time in the Boolean framework. BKMC algorithm is a natural generalization of the asynchronous Boolean dynamics
[<xref ref-type="bibr" rid="B2">2</xref>], with time trajectories that can be interpreted in terms of biological time. The variables of the Boolean model represent biological species and the parameters represent rates of activation or inactivation of these species that, ideally, could be deduced from experimental data.</p>
    <p>We applied this algorithm to three different models: a toy model that illustrates a simple cyclic behavior, a published model of p53 response to DNA damage, and a published model of mammalian cell cycle dynamics.</p>
    <p>This algorithm is provided within a freely available software, MaBoSS, that can run BKMC algorithm on networks up to 64 nodes in the present version. The construction of a model uses a specific language that introduces logical rules and transition rates of node activation/inactivation in a flexible manner. The software provides global and semi-global outputs of the model dynamics that can be interpreted as signatures of the dynamical behaviors. These interpretations become particularly useful when the network state space is too large to be handled. The convergence of BKMC algorithm can be controlled by tuning some simulation parameters: maximum time of the simulation, number of trajectories, length of a time window on which the average of probabilities is performed, and the threshold for the definition of stationary distribution clusters.</p>
    <p>The next step is to apply BKMC algorithm with MaBoSS on other existing large signaling networks, <italic>e.g.</italic> EGFR pathway
[<xref ref-type="bibr" rid="B30">30</xref>], the apoptosis pathway
[<xref ref-type="bibr" rid="B31">31</xref>], etc. The translation of existing Boolean models in MaBoSS is straightforward but requires the addition of transition rates. In these future works, we expect to illustrate the advantage of BKMC on other simulation algorithms. Moreover, in future developments of MaBoSS, we plan to introduce methods for sensitivity analyses, refine approximation methods used in BKMC, and generalize Markov property.</p>
    <p>We also expect to implement MaBoSS in broadly used software environments for Boolean modeling, like GINsim
[<xref ref-type="bibr" rid="B8">8</xref>] or CellNetAnalyzer
[<xref ref-type="bibr" rid="B25">25</xref>].</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>BKMC generates stochastic trajectories. In this section, we describe how we use and interpret these trajectories.</p>
    <sec>
      <title/>
      <sec>
        <title>Network state probabilities on a time window</title>
        <p>To relate continuous time probabilities to real processes, an observable time window <italic>Δt</italic> is defined. A discrete time (
<inline-formula><mml:math id="M38" name="1752-0509-6-116-i38" overflow="scroll"><mml:mi>τ</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi></mml:math></inline-formula>) stochastic process <italic>s</italic>(<italic>τ</italic>) (that is not necessary Markovian) can be extracted from the continuous time Markov process: </p>
        <p>
          <disp-formula id="bmcM8">
            <label>(8)</label>
            <mml:math id="M39" name="1752-0509-6-116-i39" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>≡</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:mfrac>
              <mml:msubsup>
                <mml:mrow>
                  <mml:mo mathsize="big">∫</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>τ</mml:mi>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>)</mml:mo>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:msubsup>
              <mml:mtext mathvariant="italic">dt</mml:mtext>
              <mml:mspace width="2.77695pt"/>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>t</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>BKMC is used for estimating
<inline-formula><mml:math id="M40" name="1752-0509-6-116-i40" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> as follows: </p>
        <p>1. <bold>Estimate for one trajectory.</bold> For each trajectory <italic>j</italic>, compute the time for which the system is in state <bold>S</bold>, in the window [<italic>τΔt</italic>,(<italic>τ</italic> + 1)<italic>Δt</italic>]. Divide this time by <italic>Δt</italic>. Obtain an estimate of
<inline-formula><mml:math id="M41" name="1752-0509-6-116-i41" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> for trajectory <italic>j</italic>, <italic>i.e.</italic><inline-formula><mml:math id="M42" name="1752-0509-6-116-i42" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>.</p>
        <p>2. <bold>Estimate for a set of trajectories.</bold> Compute the average over <italic>j</italic> of all
<inline-formula><mml:math id="M43" name="1752-0509-6-116-i43" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> to obtain
<inline-formula><mml:math id="M44" name="1752-0509-6-116-i44" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>. Compute the error of this average (
<inline-formula><mml:math id="M45" name="1752-0509-6-116-i45" overflow="scroll"><mml:msqrt><mml:mrow><mml:mtext>Var</mml:mtext><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:mtext># trajectories</mml:mtext></mml:mrow></mml:msqrt></mml:math></inline-formula>).</p>
      </sec>
      <sec>
        <title>Entropies</title>
        <p>Once
<inline-formula><mml:math id="M46" name="1752-0509-6-116-i46" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> is computed, the entropy <italic>H</italic>(<italic>τ</italic>) can be estimated: </p>
        <p>
          <disp-formula id="bmcM9">
            <label>(9)</label>
            <mml:math id="M47" name="1752-0509-6-116-i47" overflow="scroll">
              <mml:mi>H</mml:mi>
              <mml:mo>(</mml:mo>
              <mml:mi>τ</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mo>−</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:msub>
                <mml:mrow>
                  <mml:mo>log</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msub>
              <mml:mfenced open="(" close=")">
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                  <mml:mfenced open="[" close="]">
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                      <mml:mo>(</mml:mo>
                      <mml:mi>τ</mml:mi>
                      <mml:mo>)</mml:mo>
                      <mml:mo>=</mml:mo>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                </mml:mrow>
              </mml:mfenced>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>The entropy measures the disorder of the system. Maximum entropy means that all states have the same probability; a zero entropy means that one of the states has a probability of one. The estimation of the entropy can be seen as a global characterization of a full probability distribution by a single real number. The choice of
<inline-formula><mml:math id="M48" name="1752-0509-6-116-i48" overflow="scroll"><mml:msub><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> allows the interpretation of <italic>H</italic>(<italic>τ</italic>) in an easier manner: 2<sup><italic>H</italic>(<italic>τ</italic>)</sup>is an estimate of the number of states that have a non-negligible probability in the time window [<italic>τΔt</italic>,(<italic>τ</italic> + 1)<italic>Δt</italic>]. A more computer-like interpretation of <italic>H</italic>(<italic>τ</italic>) is the number of bits that are necessary for describing states of non-negligible probability.</p>
        <p>The <italic>Transition Entropy</italic><italic>TH</italic> is a finer measure that characterizes the system at the level of a single trajectory. It can be computed in the following way: for each state <bold>S</bold>, there exists a set of possible transitions
<inline-formula><mml:math id="M49" name="1752-0509-6-116-i49" overflow="scroll"><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. For each of these transitions, a probability is associated: </p>
        <p>
          <disp-formula id="bmcM10">
            <label>(10)</label>
            <mml:math id="M50" name="1752-0509-6-116-i50" overflow="scroll">
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>≡</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:munder>
                    <mml:mrow>
                      <mml:mo>∑</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:munder>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mo>′</mml:mo>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mi>.</mml:mi>
            </mml:math>
          </disp-formula>
        </p>
        <p>By convention,
<inline-formula><mml:math id="M51" name="1752-0509-6-116-i51" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> if there is no transition from <bold>S </bold>to any other state.</p>
        <p>Therefore, the transition entropy <italic>TH</italic> can be associated to each state <bold>S</bold>: </p>
        <p>
          <disp-formula id="bmcM11">
            <label>(11)</label>
            <mml:math id="M52" name="1752-0509-6-116-i52" overflow="scroll">
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mo>−</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:munder>
              <mml:msub>
                <mml:mrow>
                  <mml:mo>log</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msub>
              <mml:mo>(</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>)</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
            </mml:math>
          </disp-formula>
        </p>
        <p>Similarly, <italic>TH</italic>(<bold>S</bold>) = 0 if there is no transition from <bold>S</bold> to any other state. The transition entropy on a time window <italic>TH</italic>(<italic>τ</italic>) is defined as: </p>
        <p>
          <disp-formula>
            <mml:math id="M53" name="1752-0509-6-116-i53" overflow="scroll">
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi>τ</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>)</mml:mo>
            </mml:math>
          </disp-formula>
        </p>
        <p>This transition entropy is estimated in the following way: </p>
        <p>1. <bold>Estimate for one trajectory.</bold> For each trajectory <italic>j</italic>, compute the set Φ of visited states <bold>S</bold> in the time window [<italic>τΔt</italic>,(<italic>τ</italic> + 1)<italic>Δt</italic>] and their respective duration <italic>μ</italic><sub><bold>S</bold></sub>. The estimated transition entropy is: </p>
        <p>
          <disp-formula id="bmcM12">
            <label>(12)</label>
            <mml:math id="M54" name="1752-0509-6-116-i54" overflow="scroll">
              <mml:msub>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mrow>
                      <mml:mtext mathvariant="italic">TH</mml:mtext>
                      <mml:mo>(</mml:mo>
                      <mml:mi>τ</mml:mi>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>Φ</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>μ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:mfrac>
            </mml:math>
          </disp-formula>
        </p>
        <p>2. <bold>Estimate for a set of trajectories.</bold> Compute the average over <italic>j</italic> of all
<inline-formula><mml:math id="M55" name="1752-0509-6-116-i55" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mtext mathvariant="italic">TH</mml:mtext><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> to obtain
<inline-formula><mml:math id="M56" name="1752-0509-6-116-i56" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mtext mathvariant="italic">TH</mml:mtext><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula>. Compute the error of this average (
<inline-formula><mml:math id="M57" name="1752-0509-6-116-i57" overflow="scroll"><mml:msqrt><mml:mrow><mml:mtext>Var</mml:mtext><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mrow><mml:mtext mathvariant="italic">TH</mml:mtext><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:mtext># trajectories</mml:mtext></mml:mrow></mml:msqrt></mml:math></inline-formula>).</p>
        <p>This transition entropy is a way to measure how deterministic the dynamics is. If the transition entropy is always zero, the system can only make a transition to a given state.</p>
        <p>If probability distributions on a time window tend to constant values (or tend to a stationary distribution), the entropy and the transition entropy can help characterize this stationary distribution such that: </p>
        <p>• A fixed point has zero entropy and zero transition entropy,</p>
        <p>• A cyclic stationary distribution has non-zero entropy and zero transition entropy.</p>
        <p>Entropy and transition entropy can be considered as “global characterizations” of the model: for a given time window, they always consist of two real numbers, whatever the size of the network is.</p>
      </sec>
      <sec>
        <title>Hamming distance distribution</title>
        <p>The <italic>Hamming Distance</italic> between two states <bold>S</bold>and <bold>S</bold><sup><italic>′</italic></sup> is the number of nodes that have different node states between <bold>S</bold>and <bold>S</bold><sup><italic>′</italic></sup>: </p>
        <p>
          <disp-formula id="bmcM13">
            <label>(13)</label>
            <mml:math id="M58" name="1752-0509-6-116-i58" overflow="scroll">
              <mml:mtext mathvariant="italic">HD</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>)</mml:mo>
              <mml:mo>≡</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mo>(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>δ</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:msubsup>
                    <mml:mrow>
                      <mml:mi>S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msubsup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>)</mml:mo>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>δ</italic> is the Kronecker delta (
<inline-formula><mml:math id="M59" name="1752-0509-6-116-i59" overflow="scroll"><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> if <italic>S</italic><sub><italic>i </italic></sub>=<italic> S</italic><sub><italic>i</italic></sub><sup><italic>′</italic></sup>,
<inline-formula><mml:math id="M60" name="1752-0509-6-116-i60" overflow="scroll"><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> if <italic>S</italic><sub><italic>i </italic></sub>≠<italic> S</italic><sub><italic>i</italic></sub><sup><italic>′</italic></sup>). Given a reference state <bold>S</bold><sub>ref</sub>, the Hamming distance distribution (over time) is given by: </p>
        <p>
          <disp-formula id="bmcM14">
            <label>(14)</label>
            <mml:math id="M61" name="1752-0509-6-116-i61" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mo>(</mml:mo>
              <mml:mtext mathvariant="italic">HD</mml:mtext>
              <mml:mo>,</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>t</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>δ</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mtext mathvariant="italic">HD</mml:mtext>
                  <mml:mo>,</mml:mo>
                  <mml:mtext mathvariant="italic">HD</mml:mtext>
                  <mml:mo>(</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mtext>ref</mml:mtext>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:msub>
            </mml:math>
          </disp-formula>
        </p>
        <p>The estimation of the Hamming distance distribution on a time window <bold>P</bold>(<italic>HD</italic>,<italic>τ</italic>) is similar to that of stochastic probabilities on a time window.</p>
        <p>The Hamming distance distribution is a useful characterization when the set of instantaneous probabilities is compared to a reference state (<bold>S</bold><sub>ref</sub>). In that case, the Hamming distance distribution describes how far this set is to this reference state. The Hamming distance distribution can be considered as a “semi-global” characterization of time evolution: for a given time window, the size of this characterization is the number of nodes (to be compared with probabilities on a time window whose size is 2<sup>#nodes</sup>).</p>
      </sec>
      <sec>
        <title>Input, internal, output and reference nodes</title>
        <p><italic>Input Nodes</italic> are defined as the nodes for which the initial condition is fixed. Therefore, each trajectory of BKMC starts with fixed values of input nodes and random values of other nodes.</p>
        <p><italic>Internal nodes</italic> are nodes that are not considered for computing probability distributions, entropies and transition entropies. <italic>Output nodes</italic> are nodes that are not internal. Technically, probabilities are summed up over network states that differ only by the state of internal nodes. These internal nodes are only used for generating time trajectories with BKMC algorithm. Usually, nodes are chosen to be internal when the corresponding species is not measured experimentally. Mathematically, it is equivalent to transform the original Markov process to a new stochastic process (that is not necessary Markovian) defined on a new network state space. This new state space is defined by the states of the output nodes. This raises the question of the transition entropy <italic>TH</italic>: formally, this notion has only a sense within Markovian processes, <italic>i.e.</italic> when there are no internal nodes. Here, we generalize the notion of transition entropy even in the case of internal nodes. Suppose that the system is in state <bold>S</bold>: </p>
        <p>• If the only possible transitions from state <bold>S </bold>to any other state consist of flipping an internal node, the transition entropy is zero.</p>
        <p>• If there is, at least, one transition from state <bold>S </bold>to another state that flips an output node, then only the output nodes will be considered for computing probabilities in equation 10. In particular,
<inline-formula><mml:math id="M62" name="1752-0509-6-116-i62" overflow="scroll"><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:math></inline-formula> is computed only on output node flipping events.</p>
        <p><italic>Reference nodes</italic> are nodes for which a reference node state is specified and for which the Hamming distance is computed. In this framework, a reference state is composed of reference nodes for which the node state is known and non-reference nodes for which the node state is unknown. Note that non-reference nodes may differ from internal nodes.</p>
      </sec>
      <sec>
        <title>Stationary distribution characterization</title>
        <p>It can be shown (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 2, section 1.2) that instantaneous probabilities of a continuous time Markov process converge to a stationary distribution. Fixed points and cycles are two special cases of stationary distributions. They can be identified by the asymptotic behavior of entropy and transition entropy (this works only if no nodes are internal): </p>
        <p>• If both the transition entropy and the entropy converge to zero, then the process converges to a fixed point.</p>
        <p>• if the transition entropy converges to zero and the entropy does not, then the process converges to a cycle.</p>
        <p>More generally, the complete description of the Markov process asymptotic behavior can be expressed as a linear combination of the indecomposable stationary distributions.</p>
        <p>A set of finite trajectories, produced by BKMC, can be used to estimate the set of indecomposable stationary distributions. Consider a trajectory
<inline-formula><mml:math id="M63" name="1752-0509-6-116-i63" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>]</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>⋯</mml:mo><mml:mspace width="0.3em"/><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:math></inline-formula>. Let
<inline-formula><mml:math id="M64" name="1752-0509-6-116-i64" overflow="scroll"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>≡</mml:mo><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>. The estimation of the associated indecomposable stationary probability distribution (<italic>s</italic><sub>0</sub>) is done by averaging over the whole trajectory: </p>
        <p>
          <disp-formula id="bmcM15">
            <label>(15)</label>
            <mml:math id="M65" name="1752-0509-6-116-i65" overflow="scroll">
              <mml:mover accent="true">
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mo>^</mml:mo>
              </mml:mover>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>T</mml:mi>
                </mml:mrow>
              </mml:mfrac>
              <mml:msubsup>
                <mml:mrow>
                  <mml:mo mathsize="big">∫</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>0</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>T</mml:mi>
                </mml:mrow>
              </mml:msubsup>
              <mml:mtext mathvariant="italic">dt</mml:mtext>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>I</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>(</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>)</mml:mo>
            </mml:math>
          </disp-formula>
        </p>
        <p>Therefore, a set of indecomposable stationary distribution estimates can be obtained by a set of trajectories. These indecomposable stationary distribution estimates should be clustered in groups, where each group consists of estimates for the same indecomposable stationary distribution. For that, we use the fact that two indecomposable stationary distributions are identical if they have the same support, <italic>i.e.</italic> the same set of network states with non-zero probabilities (shown in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, theorem 2, section 1.2). Therefore, it is possible to quantify how similar two indecomposable stationary distribution estimates are. A <italic>similarity coefficient</italic><inline-formula><mml:math id="M66" name="1752-0509-6-116-i66" overflow="scroll"><mml:mi>D</mml:mi><mml:mo>(</mml:mo><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msubsup><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:math></inline-formula>, given two stationary distribution estimates <italic>s</italic><sub>0</sub><sup>(<italic>i</italic>)</sup> and <italic>s</italic><sub>0</sub><sup>(<italic>i</italic>)</sup> , is defined: </p>
        <p>
          <disp-formula id="bmcM16">
            <label>(16)</label>
            <mml:math id="M67" name="1752-0509-6-116-i67" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mi>D</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>j</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>)</mml:mo>
                    <mml:mo>≡</mml:mo>
                    <mml:mfenced open="(" close=")">
                      <mml:mrow>
                        <mml:munder>
                          <mml:mrow>
                            <mml:mo mathsize="big">∑</mml:mo>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                            <mml:mo>∈</mml:mo>
                            <mml:mtext>support</mml:mtext>
                            <mml:mo>(</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>,</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:munder>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="3em"/>
                    <mml:mspace width="3em"/>
                    <mml:mspace width="1em"/>
                    <mml:mo>×</mml:mo>
                    <mml:mfenced open="(" close=")">
                      <mml:mrow>
                        <mml:munder>
                          <mml:mrow>
                            <mml:mo mathsize="big">∑</mml:mo>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi mathvariant="bold">S</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>′</mml:mi>
                              </mml:mrow>
                            </mml:msup>
                            <mml:mo>∈</mml:mo>
                            <mml:mtext>support</mml:mtext>
                            <mml:mo>(</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>,</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:munder>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi mathvariant="bold">S</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>′</mml:mi>
                              </mml:mrow>
                            </mml:msup>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>where </p>
        <p>
          <disp-formula id="bmcM17">
            <label>(17)</label>
            <mml:math id="M68" name="1752-0509-6-116-i68" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mtext>support</mml:mtext>
                    <mml:mo>(</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>j</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>)</mml:mo>
                    <mml:mo>≡</mml:mo>
                    <mml:mfenced open="{">
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mtext>such that</mml:mtext>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="3em"/>
                    <mml:mspace width="3em"/>
                    <mml:mspace width="3em"/>
                    <mml:mspace width="1em"/>
                    <mml:mfenced close="}">
                      <mml:mrow>
                        <mml:mo>×</mml:mo>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                        </mml:mfenced>
                        <mml:mo>&gt;</mml:mo>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>Clusters can be constructed when a similarity threshold <italic>α</italic> is provided. A cluster of stationary distributions is defined as follows: </p>
        <p>
          <disp-formula id="bmcM18">
            <label>(18)</label>
            <mml:math id="M69" name="1752-0509-6-116-i69" overflow="scroll">
              <mml:mi mathvariant="script">C</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mfenced open="{" close="}">
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>|</mml:mo>
                  <mml:mspace width="2.77695pt"/>
                  <mml:mo>∃</mml:mo>
                  <mml:msubsup>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msubsup>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mtext>s. t.</mml:mtext>
                  <mml:mi>D</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:msubsup>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msubsup>
                  <mml:mo>)</mml:mo>
                  <mml:mo>≥</mml:mo>
                  <mml:mi>α</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>For each cluster
<inline-formula><mml:math id="M70" name="1752-0509-6-116-i70" overflow="scroll"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula>, a distribution estimate
<inline-formula><mml:math id="M71" name="1752-0509-6-116-i71" overflow="scroll"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>, associated to an indecomposable stationary distribution, can be defined: </p>
        <p>
          <disp-formula id="bmcM19">
            <label>(19)</label>
            <mml:math id="M72" name="1752-0509-6-116-i72" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="script">C</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>|</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mo>|</mml:mo>
                </mml:mrow>
              </mml:mfrac>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>Errors on this estimate can be computed by: </p>
        <p>
          <disp-formula id="bmcM20">
            <label>(20)</label>
            <mml:math id="M73" name="1752-0509-6-116-i73" overflow="scroll">
              <mml:mtext>Err</mml:mtext>
              <mml:mfenced open="(" close=")">
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                  <mml:mfenced open="[" close="]">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="script">C</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>=</mml:mo>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:msqrt>
                <mml:mrow>
                  <mml:mtext>Var</mml:mtext>
                  <mml:mo>(</mml:mo>
                  <mml:mi mathvariant="bold">P</mml:mi>
                  <mml:mfenced open="[" close="]">
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                  <mml:mo>,</mml:mo>
                  <mml:mi>s</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>/</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mo>|</mml:mo>
                </mml:mrow>
              </mml:msqrt>
            </mml:math>
          </disp-formula>
        </p>
        <p>Notice that this clustering procedure has no sense if the process is not Markovian; therefore, no nodes are considered as internal.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Abbreviations</title>
    <p>BKMC: Boolean Kinetic Monte-Carlo; AT: Asynchronous transition; ODEs: Ordinary differential equations; MaBoSS: Markov Boolean Stochastic Simulator.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors’ contributions</title>
    <p>G. Stoll organized the project, set up the algorithms, participated in writing the software, set up the examples and wrote the article. E. Viara wrote the software and participated in setting up the algorithms. E. Barillot participated in discussions and corrected the manuscript. L. Calzone organized the project, set up the examples and wrote the article. All authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Supplementary material.</bold> Basic information on Markov process, abbreviations, definitions and algorithms.</p>
      </caption>
      <media xlink:href="1752-0509-6-116-S1.pdf" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="S2">
      <caption>
        <title>Additional file 2</title>
        <p><bold>Model of the mammalian cell cycle with GINsim, BoolNet and MaBoSS.</bold> The cell cycle presented in the “Examples” section has been modeled using three tools: GINsim, BoolNet, and MaBoSS. The results for each tool are presented: (1) GINsim provides steady state solutions and transition graphs for two different initial conditions: when CycD=0 and CycD=1. For the synchronous strategy, the transition graph can be visualized whereas for the asynchronous strategy, it is not easy to read or use; BoolNet constructs two graphical representations of the trajectories based on synchronous update strategy, for the case of CycD=0 (steady state) and CycD=1 (cycle); (3) MaBoSS estimates indecomposable stationary distributions for the case of CycD=0 (one fixed point, not shown) and CycD=1 (distribution of probabilities of different network states), and time-dependent activities of the cyclins showing damped oscillations. All results are coherent but are presented differently with a different focus for each tool.</p>
      </caption>
      <media xlink:href="1752-0509-6-116-S2.pdf" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>This project was supported by the Institut National du Cancer (SybEwing project), the Agence National de la Recherche (Calamar project). The research leading to these results has received funding from the European Community’s Seventh Framework Programme (FP7/2007-2013) under grant agreement nb HEALTH-F4-2007-200767 for APO-SYS and nb FP7-HEALTH-2010-259348 for ASSET. GS, EB and LC are members of the team “Computational Systems Biology of Cancer”, Equipe labellisée par la Ligue Nationale Contre le Cancer. We’d like to thank Camille Sabbah, Jacques Rougemont, Denis Thieffry, Elisabeth Remy, Luca Grieco and Andrei Zinovyev.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kauffman</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Homeostasis and differentiation in random genetic control networks</article-title>
        <source>Nature</source>
        <year>1969</year>
        <volume>224</volume>
        <fpage>177</fpage>
        <lpage>178</lpage>
        <pub-id pub-id-type="doi">10.1038/224177a0</pub-id>
        <pub-id pub-id-type="pmid">5343519</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Thomas</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Regulatory networks seen as asynchronous automata: a logical description</article-title>
        <source>J Theor Biol</source>
        <year>1991</year>
        <volume>153</volume>
        <fpage>1</fpage>
        <lpage>23</lpage>
        <pub-id pub-id-type="doi">10.1016/S0022-5193(05)80350-9</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Stoll</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Rougemont</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Naef</surname>
          <given-names>F</given-names>
        </name>
        <article-title>Few crucial links assure checkpoint efficiency in the yeast cell-cycle network</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>20</issue>
        <fpage>2539</fpage>
        <lpage>2546</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl432</pub-id>
        <pub-id pub-id-type="pmid">16895923</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Stoll</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Bischofberger</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Rougemont</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Naef</surname>
          <given-names>F</given-names>
        </name>
        <article-title>Stabilizing patterning in the Drosophila segment polarity network by selecting models in silico</article-title>
        <source>Biosystems</source>
        <year>2010</year>
        <volume>102</volume>
        <fpage>3</fpage>
        <lpage>10</lpage>
        <pub-id pub-id-type="doi">10.1016/j.biosystems.2010.07.014</pub-id>
        <pub-id pub-id-type="pmid">20655356</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Garg</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Mohanram</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Di Cara</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>De Micheli</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Xenarios</surname>
          <given-names>I</given-names>
        </name>
        <article-title>Modeling stochasticity and robustness in gene regulatory networks</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>12</issue>
        <fpage>i101—i109</fpage>
        <pub-id pub-id-type="pmid">19477975</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Fauré</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Thieffry</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Naldi</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Dynamical analysis of a generic Boolean model for the control of the mammalian cell cycle</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>14</issue>
        <fpage>e124—e131</fpage>
        <pub-id pub-id-type="pmid">16873462</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Shmulevich</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Dougherty</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Probabilistic Boolean networks: a rule-based uncertainty model for gene regulatory networks</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <issue>2</issue>
        <fpage>261</fpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/18.2.261</pub-id>
        <pub-id pub-id-type="pmid">11847074</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gonzalez</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Naldi</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Sanchez</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Thieffry</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <article-title>GINsim: a software suite for the qualitative modelling, simulation and analysis of regulatory networks</article-title>
        <source>Biosystems</source>
        <year>2006</year>
        <volume>84</volume>
        <issue>2</issue>
        <fpage>91</fpage>
        <lpage>100</lpage>
        <pub-id pub-id-type="doi">10.1016/j.biosystems.2005.10.003</pub-id>
        <pub-id pub-id-type="pmid">16434137</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wunderlich</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>DePace</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Modeling transcriptional networks in Drosophila development at multiple scales</article-title>
        <source>Curr Opin Genet Dev</source>
        <year>2011</year>
        <volume>21</volume>
        <issue>6</issue>
        <fpage>711</fpage>
        <lpage>718</lpage>
        <pub-id pub-id-type="doi">10.1016/j.gde.2011.07.005</pub-id>
        <pub-id pub-id-type="pmid">21889888</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>MacArthur</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Ma’ayan</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Lemischka</surname>
          <given-names>I</given-names>
        </name>
        <article-title>Systems biology of stem cell fate and cellular reprogramming</article-title>
        <source>Nat Rev Mol Cell Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>10</issue>
        <fpage>672</fpage>
        <lpage>681</lpage>
        <pub-id pub-id-type="pmid">19738627</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Saez-Rodriguez</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Alexopoulos</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Morris</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Lauffenburger</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Sorger</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Comparing signaling networks between normal and transformed hepatocytes using discrete logical models</article-title>
        <source>Cancer Res</source>
        <year>2011</year>
        <volume>71</volume>
        <issue>16</issue>
        <fpage>5400</fpage>
        <pub-id pub-id-type="doi">10.1158/0008-5472.CAN-10-4453</pub-id>
        <pub-id pub-id-type="pmid">21742771</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Siebert</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Bockmayr</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Temporal constraints in the logical analysis of regulatory networks</article-title>
        <source>Theor Comput Sci</source>
        <year>2008</year>
        <volume>391</volume>
        <issue>3</issue>
        <fpage>258</fpage>
        <lpage>275</lpage>
        <pub-id pub-id-type="doi">10.1016/j.tcs.2007.11.010</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="book">
        <name>
          <surname>Öktem</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Pearson</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Yli-Harja</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Nicorici</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Egiazarian</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Astola</surname>
          <given-names>J</given-names>
        </name>
        <etal/>
        <article-title>A computational model for simulating continuous time Boolean networks</article-title>
        <source>Proceedings of IEEE International Workshop on Genomic Signal Processing and Statistics (GENSIPS’02)</source>
        <year>October 2002</year>
        <publisher-name>NC, USA: Raleigh</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Vahedi</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Faryabi</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Chamberland</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Datta</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Dougherty</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Sampling-rate-dependent probabilistic Boolean networks</article-title>
        <source>J Theor Biol</source>
        <year>2009</year>
        <volume>261</volume>
        <issue>4</issue>
        <fpage>540</fpage>
        <lpage>547</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2009.08.026</pub-id>
        <pub-id pub-id-type="pmid">19716832</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sevim</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Gong</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Socolar</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Reliability of transcriptional cycles and the yeast cell-cycle oscillator</article-title>
        <source>PLoS Comput Biol</source>
        <year>2010</year>
        <volume>6</volume>
        <issue>7</issue>
        <fpage>e1000842</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1000842</pub-id>
        <pub-id pub-id-type="pmid">20628620</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Teraguchi</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kumagai</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Vandenbon</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Akira</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Standley</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Stochastic binary modeling of cells in continuous time as an alternative to biochemical reaction equations</article-title>
        <source>Phys Rev E</source>
        <year>2011</year>
        <volume>062903</volume>
        <issue>6</issue>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bauer</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Jackson</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Jiang</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Rohlf</surname>
          <given-names>T</given-names>
        </name>
        <article-title>Receptor cross-talk in angiogenesis: mapping environmental cues to cell phenotype using a stochastic, Boolean signaling network model</article-title>
        <source>J Theor Biol</source>
        <year>2010</year>
        <volume>264</volume>
        <issue>3</issue>
        <fpage>838</fpage>
        <lpage>846</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2010.03.025</pub-id>
        <pub-id pub-id-type="pmid">20307549</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Abou-Jaoudé</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Ouattara</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Kaufman</surname>
          <given-names>M</given-names>
        </name>
        <article-title>From structure to dynamics: frequency tuning in the p53-Mdm2 network: I. Logical approach</article-title>
        <source>J Theor Biol</source>
        <year>2009</year>
        <volume>258</volume>
        <issue>4</issue>
        <fpage>561</fpage>
        <lpage>577</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2009.02.005</pub-id>
        <pub-id pub-id-type="pmid">19233211</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="book">
        <name>
          <surname>Van Kampen</surname>
          <given-names>N</given-names>
        </name>
        <source>Stochastic Processes in Physics and Chemistry</source>
        <year>2004</year>
        <publisher-name>Amsterdam, Netherlands: Elsevier</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="book">
        <name>
          <surname>Shiryaev</surname>
          <given-names>A</given-names>
        </name>
        <source>Probability, volume 95 of Graduate texts in mathematics</source>
        <year>1996</year>
        <publisher-name>Springer-Verlag: New York, USA</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chaves</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Albert</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Sontag</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Robustness and fragility of Boolean models for genetic regulatory networks</article-title>
        <source>J Theor Biol</source>
        <year>2005</year>
        <volume>235</volume>
        <issue>3</issue>
        <fpage>431</fpage>
        <lpage>449</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2005.01.023</pub-id>
        <pub-id pub-id-type="pmid">15882705</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Petri net modelling of biological networks</article-title>
        <source>Briefings in Bioinformatics</source>
        <year>2007</year>
        <volume>8</volume>
        <issue>4</issue>
        <fpage>210</fpage>
        <lpage>219</lpage>
        <pub-id pub-id-type="doi">10.1093/bib/bbm029</pub-id>
        <pub-id pub-id-type="pmid">17626066</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Young</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Elcock</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Monte Carlo studies of vacancy migration in binary ordered alloys: I</article-title>
        <source>Proceedings of the Physical Society</source>
        <year>1966</year>
        <volume>89</volume>
        <fpage>735</fpage>
        <pub-id pub-id-type="doi">10.1088/0370-1328/89/3/329</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gillespie</surname>
          <given-names>D</given-names>
        </name>
        <article-title>A general method for numerically simulating the stochastic time evolution of coupled chemical reactions</article-title>
        <source>J Comput Phys</source>
        <year>1976</year>
        <volume>22</volume>
        <issue>4</issue>
        <fpage>403</fpage>
        <lpage>434</lpage>
        <pub-id pub-id-type="doi">10.1016/0021-9991(76)90041-3</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Klamt</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Saez-Rodriguez</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Gilles</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Structural and functional analysis of cellular networks with CellNetAnalyzer</article-title>
        <source>BMC Syst Biol</source>
        <year>2007</year>
        <volume>1</volume>
        <fpage>2</fpage>
        <pub-id pub-id-type="doi">10.1186/1752-0509-1-2</pub-id>
        <pub-id pub-id-type="pmid">17408509</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Müssel</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Hopfensitz</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kestler</surname>
          <given-names>H</given-names>
        </name>
        <article-title>BoolNet–an R package for generation, reconstruction and analysis of Boolean networks</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>10</issue>
        <fpage>1378</fpage>
        <lpage>1380</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq124</pub-id>
        <pub-id pub-id-type="pmid">20378558</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>De Jong</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Geiselmann</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Hernandez</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Page</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Genetic Network Analyzer: qualitative simulation of genetic regulatory networks</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>3</issue>
        <fpage>336</fpage>
        <lpage>344</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btf851</pub-id>
        <pub-id pub-id-type="pmid">12584118</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Di Cara</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Garg</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>De Micheli</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Xenarios</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Mendoza</surname>
          <given-names>L</given-names>
        </name>
        <article-title>Dynamic simulation of regulatory networks using SQUAD</article-title>
        <source>BMC Bioinf</source>
        <year>2007</year>
        <volume>8</volume>
        <fpage>462</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-8-462</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Novak</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Tyson</surname>
          <given-names>J</given-names>
        </name>
        <article-title>A model for restriction point control of the mammalian cell cycle</article-title>
        <source>J Theor Biol</source>
        <year>2004</year>
        <volume>230</volume>
        <issue>4</issue>
        <fpage>563</fpage>
        <lpage>579</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2004.04.039</pub-id>
        <pub-id pub-id-type="pmid">15363676</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sahin</surname>
          <given-names>Ö</given-names>
        </name>
        <name>
          <surname>Fröhlich</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Löbke</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Korf</surname>
          <given-names>U</given-names>
        </name>
        <name>
          <surname>Burmester</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Majety</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Mattern</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Schupp</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Thieffry</surname>
          <given-names>D</given-names>
        </name>
        <etal/>
        <article-title>Modeling ERBB receptor-regulated G1/S transition to find novel targets for de novo trastuzumab resistance</article-title>
        <source>BMC Syst Biol</source>
        <year>2009</year>
        <volume>3</volume>
        <fpage>1</fpage>
        <pub-id pub-id-type="doi">10.1186/1752-0509-3-1</pub-id>
        <pub-id pub-id-type="pmid">19118495</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Schlatter</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Schmich</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Vizcarra</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Scheurich</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Sauter</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Borner</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Ederer</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Merfort</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Sawodny</surname>
          <given-names>O</given-names>
        </name>
        <article-title>ON/OFF and beyond-a boolean model of apoptosis</article-title>
        <source>PLoS Comput Biol</source>
        <year>2009</year>
        <volume>5</volume>
        <issue>12</issue>
        <fpage>e1000595</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1000595</pub-id>
        <pub-id pub-id-type="pmid">20011108</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Syst Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Syst Biol</journal-id>
    <journal-title-group>
      <journal-title>BMC Systems Biology</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1752-0509</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3517402</article-id>
    <article-id pub-id-type="publisher-id">1752-0509-6-116</article-id>
    <article-id pub-id-type="pmid">22932419</article-id>
    <article-id pub-id-type="doi">10.1186/1752-0509-6-116</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Continuous time boolean modeling for biological signaling: application of Gillespie algorithm</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Stoll</surname>
          <given-names>Gautier</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>gautier.stoll@curie.fr</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Viara</surname>
          <given-names>Eric</given-names>
        </name>
        <xref ref-type="aff" rid="I4">4</xref>
        <email>viara@sysra.com</email>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Barillot</surname>
          <given-names>Emmanuel</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>emmanuel.barillot@curie.fr</email>
      </contrib>
      <contrib contrib-type="author" id="A4">
        <name>
          <surname>Calzone</surname>
          <given-names>Laurence</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>laurence.calzone@curie.fr</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Institut Curie, 26 rue d’Ulm, Paris, F-75248 France</aff>
    <aff id="I2"><label>2</label>INSERM, Paris, U900, F-75248 France</aff>
    <aff id="I3"><label>3</label>Mines ParisTech, Fontainebleau, F-77300 France</aff>
    <aff id="I4"><label>4</label>Sysra, Yerres, F-91330 France</aff>
    <pub-date pub-type="collection">
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>29</day>
      <month>8</month>
      <year>2012</year>
    </pub-date>
    <volume>6</volume>
    <fpage>116</fpage>
    <lpage>116</lpage>
    <history>
      <date date-type="received">
        <day>4</day>
        <month>4</month>
        <year>2012</year>
      </date>
      <date date-type="accepted">
        <day>15</day>
        <month>8</month>
        <year>2012</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright ©2012 Stoll et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2012</copyright-year>
      <copyright-holder>Stoll et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (
<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1752-0509/6/116"/>
    <abstract>
      <sec>
        <title/>
        <p>Mathematical modeling is used as a Systems Biology tool to answer biological questions, and more precisely, to validate a network that describes biological observations and predict the effect of perturbations. This article presents an algorithm for modeling biological networks in a discrete framework with continuous time.</p>
      </sec>
      <sec>
        <title>Background</title>
        <p>There exist two major types of mathematical modeling approaches: (1) quantitative modeling, representing various chemical species concentrations by real numbers, mainly based on differential equations and chemical kinetics formalism; (2) and qualitative modeling, representing chemical species concentrations or activities by a finite set of discrete values. Both approaches answer particular (and often different) biological questions. Qualitative modeling approach permits a simple and less detailed description of the biological systems, efficiently describes stable state identification but remains inconvenient in describing the transient kinetics leading to these states. In this context, time is represented by discrete steps. Quantitative modeling, on the other hand, can describe more accurately the dynamical behavior of biological processes as it follows the evolution of concentration or activities of chemical species as a function of time, but requires an important amount of information on the parameters difficult to find in the literature.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>Here, we propose a modeling framework based on a qualitative approach that is intrinsically continuous in time. The algorithm presented in this article fills the gap between qualitative and quantitative modeling. It is based on continuous time Markov process applied on a Boolean state space. In order to describe the temporal evolution of the biological process we wish to model, we explicitly specify the transition rates for each node. For that purpose, we built a language that can be seen as a generalization of Boolean equations. Mathematically, this approach can be translated in a set of ordinary differential equations on probability distributions. We developed a C++ software, MaBoSS, that is able to simulate such a system by applying Kinetic Monte-Carlo (or Gillespie algorithm) on the Boolean state space. This software, parallelized and optimized, computes the temporal evolution of probability distributions and estimates stationary distributions.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>Applications of the Boolean Kinetic Monte-Carlo are demonstrated for three qualitative models: a toy model, a published model of p53/Mdm2 interaction and a published model of the mammalian cell cycle. Our approach allows to describe kinetic phenomena which were difficult to handle in the original models. In particular, transient effects are represented by time dependent probability distributions, interpretable in terms of cell populations.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>Boolean modeling</kwd>
      <kwd>Continuous time</kwd>
      <kwd>Markov process</kwd>
      <kwd>Gillespie algorithm</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Mathematical models of signaling pathways are tools that answer biological questions. The most commonly used mathematical formalisms to answer these questions are ordinary differential equations (ODEs) and Boolean modeling.</p>
    <p>Ordinary differential equations (ODEs) have been widely utilized to model signaling pathways. It is the most natural formalism for translating detailed reaction networks into a mathematical model. Indeed, equations can be directly derived using mass action laws, Michaelis-Menten kinetics or Hill functions for each reaction according to the observed behaviors. This framework has limitations, though. The first one concerns the difficulty to assign values to the kinetic parameters of the model. Ideally, these parameters would be extracted from experimental data. However, they are often chosen by the modeler so as to fit qualitatively the expected phenotypes. The second limitation concerns the cell population heterogeneity. In this case, ODEs are no longer appropriate since the approach is deterministic and thus focuses on the average behavior. To include non-determinism, an ODE model needs to be transformed into a stochastic chemical model. In this formalism, a master equation is written on the probabilities of the number of molecules for each species. In the translation process, the same parameters used in ODEs (more particularly in ODEs written with mass action law) can be used in the master equation, but in this case, the number of initial conditions explodes along with the computation time.</p>
    <p>Boolean (or logical) formalism is another formalism used to model signaling pathways where genes/proteins are parameterized by 0s and 1s only. It is the most natural formalism to translate an influence network into a mathematical model. In such networks, each node corresponds to a species and each arrow to an interaction or an influence (positive or negative). In a Boolean model, a logical rule linking the inputs is assigned to each node. As a result, there are no real parameter values to adjust besides choosing the appropriate logical rules that best describe the system. In this paper, we will refer to a state in which each node of the influence network has a Boolean value as a network state, and the set of all possible transitions between the network states as a transition graph. There are two types of transition graphs, one deduced from the synchronous update strategy
[<xref ref-type="bibr" rid="B1">1</xref>], for which all the nodes that can be updated are updated in one transition, and another one deduced from the asynchronous update strategy
[<xref ref-type="bibr" rid="B2">2</xref>], for which only one node, of all the possible nodes, is updated in one transition. In the Boolean formalism, each transition can be interpreted as a “time” step, though this “time” does not characterize real biological time but rather an event. Stochasticity is an important aspect when studying cell populations. In Boolean framework, it can be applied: on nodes (by randomly flipping a node state
[<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B4">4</xref>]), on the logical rules (by allowing to change an AND gate into an OR gate
[<xref ref-type="bibr" rid="B5">5</xref>]), and on the update rules (by defining the probability and the priority of changing one particular Boolean value before others in an asynchronous strategy
[<xref ref-type="bibr" rid="B6">6</xref>] or by adding noise to the whole system in a synchronous strategy
[<xref ref-type="bibr" rid="B7">7</xref>]). One of the main drawbacks of the Boolean approach is the explosion of solutions. In an asynchronous update strategy, the size of the transition graph can reach 2<sup>#nodes</sup>.</p>
    <p>Both logical and continuous frameworks have advantages and disadvantages above-mentioned. We propose here to combine some of the advantages of both approaches in an algorithm that we call the “Boolean Kinetic Monte-Carlo” algorithm (BKMC). It consists of a natural generalization of the asynchronous Boolean dynamics
[<xref ref-type="bibr" rid="B2">2</xref>], with a direct probabilistic interpretation. In BKMC framework, the dynamics is parameterized by a biological time and the order of update is noisy, which is less strict than priority classes introduced in GINsim
[<xref ref-type="bibr" rid="B8">8</xref>]. A BKMC model is specified by logical rules as in regular Boolean models but with a more precise information: a numerical rate is added for each transition of each node.</p>
    <p>BKMC is not intended to replace existing tools but rather to complement them. It is best suited to model signaling pathways in the following cases: </p>
    <p>• The model is based on an influence network, because BKMC is a generalization of the asynchronous Boolean dynamics. See “Examples” section. Note that this is a common requirement for most of Boolean software.</p>
    <p>• The model describes processes for which information about the duration of a biological process is known, because in BKMC, time is parameterized by a real number. This is typically the case when studying developmental biology, where animal models provide time changes of gene/protein activities
[<xref ref-type="bibr" rid="B9">9</xref>].</p>
    <p>• The model describes heterogeneous cell population behavior, because BKMC has a probabilistic interpretation. For example, modeling heterogeneous cell population can help understand tissue formation based on cell differentiation
[<xref ref-type="bibr" rid="B10">10</xref>].</p>
    <p>• The model can contain many nodes (up to 64 in the present implementation), because BKMC is a simulation algorithm that converges fast. This can be useful for big models that have already been modeled with a discrete time Boolean method
[<xref ref-type="bibr" rid="B11">11</xref>], in order to obtain a finer description of transient effects (see webpage for examples of published models:
<ext-link ext-link-type="uri" xlink:href="https://maboss.curie.fr">https://maboss.curie.fr</ext-link>).</p>
    <p>Previous published works have also introduced a continuous time approach in the Boolean framework(
[<xref ref-type="bibr" rid="B12">12</xref>-<xref ref-type="bibr" rid="B18">18</xref>]). In this article, we will first review some of these works and present BKMC algorithm. We will then describe the C++ software, MaBoSS, developed to implement BKMC algorithm and finally illustrate its use with three examples, a toy model, a published model of p53-MDM2 interaction and a published model of the mammalian cell cycle.</p>
    <p>All abbreviations, definitions, algorithms and estimates used in this article can be found in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>. Throughout the article, all terms that are italicized are defined in the Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Definitions”.</p>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <sec>
      <title>BKMC for continuous time Boolean model</title>
      <sec>
        <title>Continuous time in Boolean modeling: past and present</title>
        <p>In Boolean approaches for modeling networks, the state of each node of the network is defined by a Boolean value (node state) and the network state by the set of node states. Any dynamics in the transition graph is represented by sequences of network states. A node state is based on the sign of the input arrows and the logic that links them. The dynamics can be deterministic in the case of synchronized update
[<xref ref-type="bibr" rid="B1">1</xref>], or non-deterministic in the case of asynchronized update
[<xref ref-type="bibr" rid="B2">2</xref>] or probabilistic Boolean networks
[<xref ref-type="bibr" rid="B7">7</xref>].</p>
        <p>The difficulty to interpret the dynamics in terms of biological time has led to several works that have generalized Boolean approaches. These approaches can be divided in two classes that we call explicit and implicit time for discrete steps.</p>
        <p>The explicit time for discrete steps consists of adding a real parameter to each node state. These parameters correspond to the time associated to each node state before it flips to another one (
[<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>]). Because data about these time lengths are difficult to extract from experimental studies, some works have included noise in the definition of these parameters
[<xref ref-type="bibr" rid="B18">18</xref>]. The drawback of this method is that the computation of the Boolean model becomes sensitive to both the type of noise and the initial conditions. As a result, these time parameters become new parameters that need to be tuned carefully and thus add complexity to the modeling.</p>
        <p>The implicit time for discrete steps consists of adding a probability to each transition of the transition graph in the case of non-deterministic transitions (asynchronous case). It is argued that these probabilities could be interpreted as specifying the duration of a biological process. As an illustration, let us assume a small network of two nodes, A and B. At time t, A and B are inactive: [AB] = [00]. In the transition graph, there exist two possible transitions at t+1: [00] → [01] and [00] → [10]. If the first transition has a significant higher probability than the second one, then we can conclude that B will have a higher tendency to activate before A. Therefore, it is equivalent to say that the activation of B is faster than the activation of A. Thus, in this case, the notion of time is implicitly modeled by setting probability transitions. In particular, priority rules, in the asynchronous strategy, consist of putting some of these probabilities to zero
[<xref ref-type="bibr" rid="B6">6</xref>]. In our example, if B is faster than A then the probability of the transition [00] → [10] is zero. As a result, the prioritized nodes always activate before the others. From a different perspective but keeping the same idea, Vahedi and colleagues
[<xref ref-type="bibr" rid="B14">14</xref>] have set up a method to deduce explicitly these probabilities from the duration of each discrete step. With the implementation of implicit time in a Boolean model, the dynamics remains difficult to interpret in terms of biological time.</p>
        <p>As an alternative to these approaches, we propose BKMC algorithm.</p>
      </sec>
      <sec>
        <title>Properties of BKMC algorithm</title>
        <p>BKMC algorithm was built such as to meet the following principles: </p>
        <p>• The state of each node is given by a Boolean number (0 or 1), referred to as node state;</p>
        <p>• The state of the network is given by the set of node states, referred to as network state;</p>
        <p>• The update of a node state is based on the signs linking the incoming arrows of this node and the logic;</p>
        <p>• Time is represented by a real number;</p>
        <p>• Evolution is stochastic.</p>
        <p>We choose to describe the time evolution of network states by a Markov process with continuous time, applied to the asynchronous transition graph. Therefore, the dynamics is defined by transition rates inserted in a master equation (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1).</p>
      </sec>
      <sec>
        <title>Markov process for Boolean model</title>
        <p>Consider a network of <italic>n</italic> nodes (or agents, that can represent any species, <italic>i.e.</italic> mRNA, proteins, complexes, <italic>etc.</italic>). In a Boolean framework, the network state of the system is described by a vector <bold>S</bold> of Boolean values, <italic>i.e.</italic><italic>S</italic><sub><italic>i</italic></sub>∈{0,1},<italic>i </italic>= 1,…,<italic>n</italic> where <italic>S</italic><sub><italic>i</italic></sub> is the state of the node <italic>i</italic>. The set of all possible network states, also referred to as the network state space, will be called Σ.</p>
        <p>A stochastic description of the state evolution is represented by a <italic>stochastic process</italic><italic>s</italic>:<italic>t </italic>↦<italic> s</italic>(<italic>t</italic>) defined on
<inline-formula><mml:math id="M1" name="1752-0509-6-116-i1" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo>⊂</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:math></inline-formula> applied on the network state space, where <italic>I</italic> is an interval: for each time
<inline-formula><mml:math id="M2" name="1752-0509-6-116-i2" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo>⊂</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:math></inline-formula>, <italic>s</italic>(<italic>t</italic>) represents a random variable applied on the network state space. Thus, the probability of these random variables is written as: </p>
        <p>
          <disp-formula id="bmcM1">
            <label>(1)</label>
            <mml:math id="M3" name="1752-0509-6-116-i3" overflow="scroll">
              <mml:mtable class="align" columnalign="right left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:mi>t</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="1em"/>
                    <mml:mo>∈</mml:mo>
                  </mml:mtd>
                  <mml:mtd class="align-2">
                    <mml:mo>[</mml:mo>
                    <mml:mn>0</mml:mn>
                    <mml:mo>,</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>]</mml:mo>
                    <mml:mspace width="0.3em"/>
                    <mml:mspace width="0.3em"/>
                    <mml:mtext>for any state</mml:mtext>
                    <mml:mspace width="0.3em"/>
                    <mml:mspace width="0.3em"/>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:mi>Σ</mml:mi>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mtext>with</mml:mtext>
                    <mml:munder>
                      <mml:mrow>
                        <mml:mo mathsize="big">∑</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mo>∈</mml:mo>
                        <mml:mi mathvariant="normal">Σ</mml:mi>
                      </mml:mrow>
                    </mml:munder>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:mi>t</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width=".45em"/>
                    <mml:mo>=</mml:mo>
                  </mml:mtd>
                  <mml:mtd class="align-2">
                    <mml:mn>1</mml:mn>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>Notice that for all <italic>t</italic>, <italic>s</italic>(<italic>t</italic>) are not independent, therefore
<inline-formula><mml:math id="M4" name="1752-0509-6-116-i4" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>≠</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula>. From now on, we define
<inline-formula><mml:math id="M5" name="1752-0509-6-116-i5" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> as <italic>instantaneous probabilities</italic>. Since the instantaneous probabilities do not define the full stochastic process, all possible joint probabilities should also be defined.</p>
        <p>In order to simplify the stochastic process, Markov property is imposed. It can be expressed in the following way: “the conditional probabilities in the future, related to the present and the past, depend only on the present” (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1 for the mathematical definition). The formal definition of a <italic>Markov process</italic> is a stochastic process with the Markov property.</p>
        <p>Any Markov process can be defined by (see Van Kampen
[<xref ref-type="bibr" rid="B19">19</xref>], chapter IV): </p>
        <p>1. An initial condition: </p>
        <p>
          <disp-formula id="bmcM2">
            <label>(2)</label>
            <mml:math id="M6" name="1752-0509-6-116-i6" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mn>0</mml:mn>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mspace width="2.77695pt"/>
              <mml:mo>;</mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mi mathvariant="normal">Σ</mml:mi>
            </mml:math>
          </disp-formula>
        </p>
        <p>2. Conditional probabilities (of a single condition): </p>
        <p>
          <disp-formula id="bmcM3">
            <label>(3)</label>
            <mml:math id="M7" name="1752-0509-6-116-i7" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>t</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>|</mml:mo>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:mfenced>
              <mml:mspace width="2.77695pt"/>
              <mml:mo>;</mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>∈</mml:mo>
              <mml:mi mathvariant="normal">Σ</mml:mi>
              <mml:mspace width="2.77695pt"/>
              <mml:mo>;</mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>,</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mi>I</mml:mi>
              <mml:mo>;</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>&lt;</mml:mo>
              <mml:mi>t</mml:mi>
            </mml:math>
          </disp-formula>
        </p>
        <p>Concerning time, two cases can be considered: </p>
        <p>• If time is discrete: <italic>t </italic>∈<italic> I </italic>= {<italic>t</italic><sub>0</sub>,
<italic>t</italic><sub>1</sub>,⋯}, it can be shown that all possible conditional probabilities are function of transition probabilities
[<xref ref-type="bibr" rid="B20">20</xref>]:
<inline-formula><mml:math id="M8" name="1752-0509-6-116-i8" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula>. In that case, a Markov process is often named a Markov chain.</p>
        <p>• If time is continuous: <italic>t </italic>∈<italic> I </italic>= [<italic>a</italic>,
<italic>b</italic>], it can be shown that all possible conditional probabilities are function of <italic>transition rates</italic>[<xref ref-type="bibr" rid="B19">19</xref>]:
<inline-formula><mml:math id="M9" name="1752-0509-6-116-i9" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>∞</mml:mi><mml:mo>]</mml:mo></mml:math></inline-formula>.</p>
        <p>Notice that a discrete time Markov process can be derived from continuous time Markov process, and is called a <italic>Jump Process</italic> with the following transition probabilities: </p>
        <p>
          <disp-formula>
            <mml:math id="M10" name="1752-0509-6-116-i10" overflow="scroll">
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>≡</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:munder>
                    <mml:mrow>
                      <mml:mo>∑</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mo>∈</mml:mo>
                      <mml:mi mathvariant="normal">Σ</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
            </mml:math>
          </disp-formula>
        </p>
        <p>If the transition probabilities or transition rates are time independent, the Markov process is called a <italic>time independent Markov process</italic>. In BKMC, only this case will be considered. For a time independent Markov process, the <italic>transition graph</italic> can be defined as follows: a transition graph is a graph in Σ, with an edge between <bold>S</bold> and <bold>S</bold><sup><italic>′</italic></sup> if and only if
<inline-formula><mml:math id="M11" name="1752-0509-6-116-i11" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> (or
<inline-formula><mml:math id="M12" name="1752-0509-6-116-i12" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> if time is discrete).</p>
      </sec>
      <sec>
        <title>Asynchronous Boolean dynamics as a discrete time Markov process</title>
        <p>Asynchronous Boolean dynamics
[<xref ref-type="bibr" rid="B2">2</xref>] is widely used in Boolean modeling. It can be easily interpreted as a discrete time Markov process
[<xref ref-type="bibr" rid="B21">21</xref>,<xref ref-type="bibr" rid="B22">22</xref>] as shown below.</p>
        <p>In the case of asynchronous Boolean dynamics, the system is given by <italic>n</italic> nodes (or agents), with a set of directed arrows linking these nodes and defining a network. For each node <italic>i</italic>, a Boolean logic <italic>B</italic><sub><italic>i</italic></sub>(<bold>S</bold>) is specified and depends only on the nodes <italic>j</italic> for which there exists an arrow from node <italic>j</italic> to <italic>i</italic> (<italic>e.g.</italic><italic>B</italic><sub>1</sub> =<italic> S</italic><sub>3</sub> AND NOT<italic>S</italic><sub>4</sub>, where <italic>S</italic><sub>3</sub> and <italic>S</italic><sub>4</sub> are the Boolean values of nodes 3 and 4 respectively, and <italic>B</italic><sub>1</sub>is the Boolean logic of node 1). The notion of <italic>asynchronous transition</italic> (AT) can be defined as a pair of network states
<inline-formula><mml:math id="M13" name="1752-0509-6-116-i13" overflow="scroll"><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:math></inline-formula>, written
<inline-formula><mml:math id="M14" name="1752-0509-6-116-i14" overflow="scroll"><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math></inline-formula> such that </p>
        <p>
          <disp-formula id="bmcM4">
            <label>(4)</label>
            <mml:math id="M15" name="1752-0509-6-116-i15" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>=</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>B</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mspace width="0.3em"/>
                    <mml:mtext>for a given</mml:mtext>
                    <mml:mspace width="0.3em"/>
                    <mml:mi>j</mml:mi>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>=</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mspace width="0.3em"/>
                    <mml:mtext>for</mml:mtext>
                    <mml:mspace width="0.3em"/>
                    <mml:mi>i</mml:mi>
                    <mml:mo>≠</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>To define a Markov process, the transition probabilities
<inline-formula><mml:math id="M16" name="1752-0509-6-116-i16" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula> can be defined: given two network states <bold>S</bold> and <bold>S</bold><sup><italic>′</italic></sup>, let <italic>γ</italic>(<bold>S</bold>) be the number of asynchronous transitions from <bold>S</bold> to all possible states <bold>S</bold><sup><italic>′</italic></sup>. Then </p>
        <p>
          <disp-formula id="bmcM5">
            <label>(5)</label>
            <mml:math id="M17" name="1752-0509-6-116-i17" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="-6.0pt"/>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>|</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>/</mml:mo>
                    <mml:mi>γ</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>if</mml:mtext>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>→</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>is an AT</mml:mtext>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="-6.0pt"/>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>|</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mo>=</mml:mo>
                    <mml:mn>0</mml:mn>
                    <mml:mtext>if</mml:mtext>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>→</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>′</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>is not an AT</mml:mtext>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>In this formalism, the asynchronous Boolean dynamics completely defines a discrete time Markov process when the initial condition is specified. Notice that here the transition probabilities are time independent, <italic>i.e.</italic><inline-formula><mml:math id="M18" name="1752-0509-6-116-i18" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math></inline-formula>. Therefore, the approaches, mentioned in section “Continuous time in Boolean modeling: past and present”, that introduce time implicitly by adding probabilities to each transition of the transition graph, can be seen as a generalization of the definition of <italic>γ</italic>(<bold>S</bold>).</p>
      </sec>
      <sec>
        <title>Continuous time Markov process as a generalization of asynchronous Boolean dynamics</title>
        <p>To transform the discrete time Markov process described above in a continuous time Markov process, transition probabilities should be replaced by transition rates
<inline-formula><mml:math id="M19" name="1752-0509-6-116-i19" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>. In that case, conditional probabilities are computed by solving a master equation (equation 2 in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1). We present below the corresponding numerical algorithm, the <italic>Kinetic Monte-Carlo</italic> algorithm
[<xref ref-type="bibr" rid="B23">23</xref>].</p>
        <p>Because we want a generalization of the asynchronous Boolean dynamics, transition rates
<inline-formula><mml:math id="M20" name="1752-0509-6-116-i20" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula> are non-zero <underline>only if</underline><bold> S</bold> and <bold>S</bold><sup><italic>′</italic></sup> differ by only one node. In that case, each Boolean logic <italic>B</italic><sub><italic>i</italic></sub>(<bold>S</bold>)is replaced by two functions
<inline-formula><mml:math id="M21" name="1752-0509-6-116-i21" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mtext>up/down</mml:mtext></mml:mrow></mml:msubsup><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>∞</mml:mi><mml:mo>[</mml:mo></mml:math></inline-formula>. The transition rates are defined as follows: if <italic>i</italic> is the node that differs from <bold>S</bold> and <bold>S</bold><sup><italic>′</italic></sup>, then </p>
        <p>
          <disp-formula id="bmcM6">
            <label>(6)</label>
            <mml:math id="M22" name="1752-0509-6-116-i22" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>ρ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mo>→</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">up</mml:mi>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>if</mml:mtext>
                    <mml:mspace width=".3em"/>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:mn>0</mml:mn>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>ρ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mo>→</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>′</mml:mi>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mtext>down</mml:mtext>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>(</mml:mo>
                    <mml:mi mathvariant="bold">S</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mtext>if</mml:mtext>
                    <mml:mspace width=".3em"/>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>S</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>R</italic><sub><italic>i</italic></sub><sup>up</sup> corresponds to the activation rate of node <italic>i</italic>, and <italic>R</italic><sub><italic>i</italic></sub><sup>down</sup> corresponds to the inactivation rate of node <italic>i</italic>. Therefore, the continuous Markov process is completely defined by all these <italic>R</italic><sup>up/down</sup> and an initial condition.</p>
      </sec>
      <sec>
        <title>Asymptotic behavior of continuous time Markov process</title>
        <p>In the case of continuous time Markov process, instantaneous probabilities always converge to a stationary distribution (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 2, section 1.2). A <italic>stationary distribution</italic> of a given Markov process corresponds to the set of instantaneous probabilities of a stationary Markov process which has the same transition probabilities (or transition rates) as the given discrete (or continuous) time Markov process. A <italic>stationary Markov process</italic> has the following property: for every joint probability
<inline-formula><mml:math id="M23" name="1752-0509-6-116-i23" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow></mml:mfenced></mml:math></inline-formula> and ∀<italic>τ</italic>: </p>
        <p>
          <disp-formula id="bmcM7">
            <label>(7)</label>
            <mml:math id="M24" name="1752-0509-6-116-i24" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1"/>
                  <mml:mtd class="align-2">
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mo>…</mml:mo>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1"/>
                  <mml:mtd class="align-2">
                    <mml:mspace width="2.77695pt"/>
                    <mml:mspace width="2.77695pt"/>
                    <mml:mo>=</mml:mo>
                    <mml:mi mathvariant="bold">P</mml:mi>
                    <mml:mfenced open="[" close="]">
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>+</mml:mo>
                        <mml:mi>τ</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mi>s</mml:mi>
                        <mml:mo>(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>+</mml:mo>
                        <mml:mi>τ</mml:mi>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>,</mml:mo>
                        <mml:mo>…</mml:mo>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>Notice that instantaneous probabilities
<inline-formula><mml:math id="M25" name="1752-0509-6-116-i25" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> of a stationary stochastic process are time independent.</p>
        <p>The asymptotic behavior of a continuous time Markov process can be detailed by using the concept of <italic>indecomposable stationary distributions</italic>: indecomposable stationary distributions are stationary distributions that cannot be expressed as a linear combination of different stationary distributions. A linear combination of stationary distributions is also a stationary distribution, since instantaneous probabilities are solutions of a master equation which is linear (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 2, section 1.1). Therefore, a complete description of the asymptotic behavior is given by the linear combination of indecomposable stationary distributions to which the Markov process converges.</p>
      </sec>
      <sec>
        <title>Oscillations and cycles</title>
        <p>In order to describe a periodic behavior, the notion of cycle and oscillation for a continuous time Markov process is defined precisely.</p>
        <p>A <italic>cycle</italic> is a loop in the transition graph. This is a topological characterization in the transition graph that does not depend on the exact value of the transition rates. It can be shown that a cycle with no outgoing edges corresponds to an indecomposable stationary distribution (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 1, section 1.2).</p>
        <p>The question is then to link the notion of cycle to that of periodic behavior of instantaneous probabilities. The set of instantaneous probabilities cannot be perfectly periodic. They can display a damped oscillating behavior, or none at all (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.3). A <italic>damped oscillatory</italic> Markov process can be formally defined as a continuous time process that has at least one instantaneous probability with an infinite number of extrema.</p>
        <p>According to theorems described in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref> (“Basic information on Markov process”, theorems 6-8 and Corollary 3, section 1.3), a necessary condition for having damped oscillations is that the transition matrix has at least one non-real eigenvalue (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 4, section 1.1). In that case, there always exists an initial condition that produces damped oscillations. For the transition matrix to have a non-real eigenvalue, a Markov process needs to have a cycle. However, the reverse is not true: a Markov process with a cycle does not necessarily imply the existence of a non-real eigenvalue in the transition matrix. In the toy model of a single cycle, presented in the “Examples” section, non-real eigenvalues may or may not exist, according to different values of transition rates.</p>
      </sec>
      <sec>
        <title>BKMC: Kinetic Monte-Carlo (Gillespie algorithm) applied to continuous time asynchronous Boolean Dynamics</title>
        <p>It has been previously stated that a continuous time Markov process is completely defined by its initial condition and its transition rates. For computing any conditional probability (and any joint probability), a set of linear differential equations has to be solved (the master equation). Theoretically, the master equation can be solved exactly by computing the exponential of the transition matrix (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 5, section 1.1). However, because the size of this transition matrix is 2<sup><italic>n</italic></sup>×2<sup><italic>n</italic></sup>, the computation soon becomes impossible if <italic>n</italic> is large. To remedy this problem, it is possible to use a simulation algorithm that samples the probability space by computing time trajectories in the transition graph.</p>
        <p>The Kinetic Monte-Carlo
[<xref ref-type="bibr" rid="B23">23</xref>] (or Gillespie algorithm
[<xref ref-type="bibr" rid="B24">24</xref>]) is a simple algorithm for exploring the probability space of a Markov process defined by a set of transition rates. In fact, it can be understood as a formal definition of a continuous time Markov process. This algorithm produces a set of <italic>realizations</italic> or <italic>stochastic trajectories</italic> of the Markov process, given a set of uniform random numbers in [0,1]. By definition, a trajectory
<inline-formula><mml:math id="M26" name="1752-0509-6-116-i26" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> is a function from a time window [0,<italic>t</italic><sub>max</sub> to Σ. The set of stochastic trajectories represents the given Markov process in the sense that these trajectories can be used to compute probabilities. A finite set of these trajectories is produced, then, from this finite set, probabilities are estimated (as described in “Methods” section). The algorithm is based on an iterative step: from a state <bold>S</bold> at time <italic>t</italic><sub>0</sub>(given two uniform random numbers), it produces a transition time <italic>δt</italic> and a new state
<inline-formula><mml:math id="M27" name="1752-0509-6-116-i27" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>, with the following interpretation: the trajectory
<inline-formula><mml:math id="M28" name="1752-0509-6-116-i28" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> is such that
<inline-formula><mml:math id="M29" name="1752-0509-6-116-i29" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:math></inline-formula> for <italic>t</italic>∈<italic>t</italic><sub>0</sub><italic>t</italic><sub>0</sub> + <italic>δt</italic> and
<inline-formula><mml:math id="M30" name="1752-0509-6-116-i30" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>δt</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. Iteration of this step is done until a specified maximum time is reached. The initial state of each trajectory is based on the (probabilistic) initial condition that also needs to be specified.</p>
        <p>The exact iterative procedure is the following. Given <bold>S</bold> and two uniform random numbers <italic>u</italic>,<italic>u</italic><sup><italic>′</italic></sup>∈[0,1]: </p>
        <p>1. Compute the total rate of possible transitions for leaving state <bold>S</bold>:
<inline-formula><mml:math id="M31" name="1752-0509-6-116-i31" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mtext>tot</mml:mtext></mml:mrow></mml:msub><mml:mo>≡</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
        <p>2. Compute the time of the transition:
<inline-formula><mml:math id="M32" name="1752-0509-6-116-i32" overflow="scroll"><mml:mi>δt</mml:mi><mml:mo>≡</mml:mo><mml:mo>−</mml:mo><mml:mo>log</mml:mo><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mtext>tot</mml:mtext></mml:mrow></mml:msub></mml:math></inline-formula></p>
        <p>3. Order the possible new states
<inline-formula><mml:math id="M33" name="1752-0509-6-116-i33" overflow="scroll"><mml:msup><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mspace width="0.3em"/></mml:math></inline-formula> and their respective transition rates
<inline-formula><mml:math id="M34" name="1752-0509-6-116-i34" overflow="scroll"><mml:msup><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo mathvariant="bold">(</mml:mo><mml:mi mathvariant="bold">j</mml:mi><mml:mo mathvariant="bold">)</mml:mo></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
        <p>4. Compute the new state
<inline-formula><mml:math id="M35" name="1752-0509-6-116-i35" overflow="scroll"><mml:msup><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> such that
<inline-formula><mml:math id="M36" name="1752-0509-6-116-i36" overflow="scroll"><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mtext>tot</mml:mtext></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>≤</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> (by convention, <italic>ρ</italic><sup>(0)</sup>=0).</p>
        <p>This algorithm will be referred to as <italic>Boolean Kinetic Monte-Carlo</italic> or BKMC.</p>
      </sec>
    </sec>
    <sec>
      <title>Practical use of BKMC, through MaBoSS tool</title>
      <p>Biological data are translated into an influence network with logical rules associated to each node of the network. The value of one node depends on the value of the input nodes. For BKMC, another layer of information is provided when compared to the standard definition of Boolean models: transition rates are provided for all nodes, specifying the rates at which the node turns on and off. This refinement conserves the simplicity of Boolean description but allows to reproduce more accurately the observed biological dynamics. The parameters do not need to be exact as it is the case for nonlinear ordinary differential equation models, but they can be used to illustrate the relative speed of reactions. We developed a software tool, MaBoSS, that applies BKMC algorithm. MaBoSS stands for Markov Boolean Stochastic Simulator.</p>
      <sec>
        <title>How to build a mathematical model using MaBoSS</title>
        <p>Once MaBoSS is installed (see webpage for instructions,
<ext-link ext-link-type="uri" xlink:href="https://maboss.curie.fr">https://maboss.curie.fr</ext-link>), the protocol to follow to simulate a model can be described in four steps: </p>
        <p>1. Create the model using MaBoSS language in a file (myfile.bnd, for instance): (a) write the logic for each node, and (b) assign values to each transition rate.</p>
        <p>2. Create the configuration file (myfile.cfg, for instance) to define the simulation parameters.</p>
        <p>3. Run MaBoSS (the order of the arguments does not matter):</p>
        <p>
          <monospace>MaBoSS -c myfile.cfg -o myfile_out myfile.bnd</monospace>
        </p>
        <p>(we assume that MaBoSS is accessible through you PATH).MaBoSS creates three output files: </p>
        <p>• <monospace>myfile_out_proptraj.csv</monospace></p>
        <p>This file contains the network state probabilities on a time window, the entropy, the transition entropy and the Hamming distance distribution (see “Methods”)</p>
        <p>• <monospace>myfile_out_statdist.csv</monospace></p>
        <p>This file contains the stationary distribution characterization (see “Methods”)</p>
        <p>• <monospace>myfile_out_run.txt</monospace></p>
        <p>This file contains a summary of MaBoSS simulation run.</p>
        <p>4. Import output csv files in Excel or R and generate your graphs.</p>
      </sec>
      <sec>
        <title>Transition rates in MaBoSS</title>
        <p>MaBoSS defines transition rates
<inline-formula><mml:math id="M37" name="1752-0509-6-116-i37" overflow="scroll"><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula> by the functions <italic>R</italic><sub><italic>i</italic></sub><sup>up/down</sup> (<bold>S</bold>) (see equations 6). The functions can be written using all Boolean operators (AND, OR, NOT, XOR), arithmetic operators (+,-,*,/), comparison operators and the conditional operator (?:). Examples of the use of the language are given below to illustrate three different cases: (1) different speeds for different inputs, (2) buffering effect and (3) the translation of discrete variables (with three values: 0, 1 and 2) into a Boolean model. </p>
        <p>1. Modeling different speeds for different inputs.Suppose that C is activated by A or B, but that B can activate C faster than A, and that C is inactivated when A and B are absent. In this case, we write: </p>
        <p>
          <monospace>node C {</monospace>
        </p>
        <p>
          <monospace> rate_up = B ? $kb : (A ? $ka : 0.0);</monospace>
        </p>
        <p>
          <monospace> rate_down = !(A &amp; B ) ? 1.0 : 0.0;</monospace>
        </p>
        <p> }</p>
        <p> When C is off (equal to 0), it is activated by B at a speed $kb. If B is absent, then C is activated by A at a speed $ka. If both are absent, C is not activated. Note that if both A and B are present, because of the way the logic is written in this particular case, C is activated at the highest speed, the speed $kb. When C is on (equal to 1), it is inactivated at a rate equal to 1 in the absence of both A and B.</p>
        <p> To implement the synergistic effect of A and B, <italic>i.e.</italic> when both A and B are on, C is activated at a rate $kab, then we can write:</p>
        <p>
          <monospace>node C {</monospace>
        </p>
        <p>
          <monospace>rate_up = (A &amp; !B ? $ka : 0.0)+(B &amp; !A ? $kb : 0.0) + (A &amp; B ? $kab : 0.0);</monospace>
        </p>
        <p>
          <monospace> rate_down = !(A &amp; B ) ? 1.0 : 0.0;</monospace>
        </p>
        <p> }</p>
        <p>2. Modeling buffering effect.Suppose that B is activated by A, but that B can remain active a long time after A has shut down. For that, it is enough to define different speeds of activation and inactivation:</p>
        <p>
          <monospace>node B {</monospace>
        </p>
        <p>
          <monospace>rate_up = A ? 2.0 : 0.0;</monospace>
        </p>
        <p>
          <monospace>rate_down = A ? 0.0 : 0.001;</monospace>
        </p>
        <p>}</p>
        <p> B is activated by A at a rate equal to 2. When A is turned off, B is inactivated more slowly at a rate equal to 0.001.</p>
        <p>3. Modeling different levels for a given node.Suppose that B is activated by A, but if the activity of A is maintained, B can reach a second level. For this, we define a second node B_h (for “B high”) with the following rules:</p>
        <p>
          <monospace>node B {</monospace>
        </p>
        <p>
          <monospace>rate_up = A ? 1.0 : 0.0; </monospace>
        </p>
        <p>
          <monospace>rate_down = (A | B_h) ? 0.0 : 1.0;</monospace>
        </p>
        <p>}</p>
        <p>
          <monospace>node B_h {</monospace>
        </p>
        <p>
          <monospace>rate_up = (A &amp; B) ? 1.0 : 0.0;</monospace>
        </p>
        <p>
          <monospace>rate_down = (A) ? 0.0 : 1.0;</monospace>
        </p>
        <p>}</p>
        <p> In this example, B is separated in two variables: B which corresponds to the first level of B and B_h which corresponds to the higher level of B. B is activated by A at a rate equal to 1. If A disappears before B has reached its second level B_h then B is turned off at a rate equal to 1. If A is maintained and B is active, then B_h is activated at a rate equal to 1. When A is turned off, B_h is inactivated at a rate equal to 1.</p>
      </sec>
      <sec>
        <title>Simulation parameters in MaBoSS</title>
        <p>To simulate a model in MaBoSS, a set of parameters needs to be adjusted (see “Parameter list” in the reference card available in the webpage). MaBoSS assigns default values, however, they need to be tuned for each model to achieve optimal performances: the best balance between the convergence of estimates and the computation time needs to be found. Therefore, several simulations should be run with different sets of parameters for best tuning. </p>
        <p>• Internal nodes: <italic>node.is_internal</italic>As explained in “Methods” (in “Initial conditions and outputs”), internal nodes correspond to species that are not measured explicitly. Practically, the higher the number of internal nodes, the better the convergence of the BKMC algorithm.</p>
        <p>• Time window for probabilities: <italic>timetick</italic>This parameter is used to compute estimates of network state probabilities (see “Network state probabilities on a time window” in “Methods”). A time window can be set as the minimum time needed for nodes to change their states. This parameter also controls the convergence of probability estimates. The larger the time window, the better the convergence of probability estimates.</p>
        <p>• Maximum time: <italic>max_time</italic>MaBoSS produces trajectories for a predefined amount of time, set by the parameter max_time. If the time of the biological process is known, then the maximum time parameter can be explicitly set. If the time of the biological process is not known, then there exists a more empirical way to set the maximum time. It is advised to choose a maximum time parameter that is slightly bigger than the inverse of the smallest transition rate.Note that the computing time in MaBoSS is proportional to this maximum time. Moreover, the choice of the maximum time impacts the stationary distribution estimates: a longer maximum time increases the quality of these estimates.</p>
        <p>• Number of trajectories: <italic>sample_count</italic>This parameter directly controls the quality of BKMC estimation algorithm. Practically, the convergence of the estimates increases as the number of trajectories is increased.</p>
        <p>• Number of trajectories (<italic>statdist_traj_count</italic>) and similarity threshold (<italic>statsdist_cluster_threshold</italic>) for stationary distribution estimatesThe <italic>statdist_traj_count</italic> parameter corresponds to a subset of trajectories used only for stationary distribution estimates. To avoid explosion of computing time, this parameter needs to be lower than the number of trajectories (rather than equal to).The <italic>statsdist_cluster_threshold</italic> parameter corresponds to the threshold for constructing the clusters of stationary distribution estimates. Ideally, it should be set to a high value (close to 1). However, if the threshold is too high then the clustering algorithm might not be efficient.</p>
      </sec>
      <sec>
        <title>Comparison with biological data</title>
        <p>Each node of the network should account for different levels of activity of the corresponding species (mRNA, protein, protein complex, etc.). It is possible to have more than two levels for one node, as shown in the example “Modeling different levels for a given node”.</p>
        <p>It is possible to extract the transition rates from experimental data, using the following property: the rate of a given transition is the inverse of the mean time for this transition to happen. It should be noticed than BKMC is an algorithm based on a linear equation (Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, equation 2, section 1.1); therefore, small variations of transition rates will not affect the qualitative behavior of the model.</p>
        <p>BKMC algorithm provides estimates of the network state probabilities over time. These probabilities can be interpreted in terms of a cell population. The asymptotic behavior of a model, represented by a linear combination of indecomposable stationary distributions, can be interpreted as a combination of cell sub-populations. Indeed, a sub-population can be defined by network states with non-zero probability in the indecomposable stationary distribution. Therefore, a cell in a sub-population can only evolved in this sub-population (Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 1, section 1.2 and from the definition of strongly connected component with no outgoing edges).</p>
      </sec>
      <sec>
        <title>Comparison of MaBoSS with other existing tools for qualitative modeling</title>
        <p>MaBoSS contributes to the effort of tool development for qualitative modeling of biological networks. We propose to compare MaBoSS to some existing tools. However, it is difficult to compare the performance of these tools since each of them achieves different purposes and provides different outputs. As an alternative, we recapitulate, in Figure
<xref ref-type="fig" rid="F1">1</xref>, the characteristics and implications for each software. Some tools may be more appropriate than others according to the type of input, network size and expected output. Figure
<xref ref-type="fig" rid="F1">1</xref> is intended to help the users decide which software to use in a practical situation. We consider the following tools: GINsim
[<xref ref-type="bibr" rid="B8">8</xref>], CellNetAnalyzer
[<xref ref-type="bibr" rid="B25">25</xref>], BoolNet
[<xref ref-type="bibr" rid="B26">26</xref>], GNA
[<xref ref-type="bibr" rid="B27">27</xref>], and SQUAD
[<xref ref-type="bibr" rid="B28">28</xref>]. This list is not exhaustive but informs on where MaBoSS stands.</p>
        <fig id="F1" position="float">
          <label>Figure 1</label>
          <caption>
            <p><bold>Comparison of tools for discrete modeling, biological implication.</bold> Comparison table of the following tools: MaBoSS, GINsim, CellNetAnalyzer, BoolNet, GNA, SQUAD. Technical aspects are provided, along with the inputs/outputs relations between a model and data. The last row illustrates graphically the typical outputs that can be obtained from each tool.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-1"/>
        </fig>
        <p>As an illustration, the third example of the “Examples” section below, the mammalian cell cycle, was implemented in three of the tools presented in Figure
<xref ref-type="fig" rid="F1">1</xref>: MaBoSS, GINsim, BoolNet (see Additional file
<xref ref-type="supplementary-material" rid="S2">2</xref> “Model of the mammalian cell cycle with GINsim, BoolNet and MaBoSS.” for details of the results).</p>
      </sec>
    </sec>
    <sec>
      <title>Examples</title>
      <p>We have applied BKMC algorithm to three models of different sizes. The first one is a toy model illustrating the dynamics of a single cycle; the second one is a published Boolean model of p53-Mdm2 response to DNA damage and illustrates a multi-level case; and the third one is a published Boolean model of mammalian cell cycle regulation. Note that MaBoSS has been used for these three examples, but Markov process can be computed directly for the two first ones, without our BKMC algorithm because these models are small enough (by computing exponential of transition matrix, see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1), as proposed in
[<xref ref-type="bibr" rid="B16">16</xref>]. BKMC is best suited for larger networks, when the network state space is too large to be computed with standard existing tools (&gt;∼2<sup>10</sup>). The first two examples were chosen for their simplicity, and because they illustrate how global characterizations (entropy and transition entropy, see “Entropiesł::bel sect:entropies” in “Methods”) can be used. The third example shows the use of BKMC/MaBoSS for a more consequent and complex model for which the analysis is not obvious.</p>
      <p>For the purpose of this article, we built the transition graphs for the first two examples (with GINsim
[<xref ref-type="bibr" rid="B8">8</xref>]) in order to help the reasoning. However, it is important to note that BKMC algorithm does not construct the transition graph explicitly.</p>
      <p>All input files and results are given in the webpage of MaBoSS (
<ext-link ext-link-type="uri" xlink:href="https://maboss.curie.fr">https://maboss.curie.fr</ext-link>) with additional examples.</p>
      <sec>
        <title>Toy model of a single cycle</title>
        <p>We consider three species, A, B and C, where A is activated by C and inhibited by B, B is activated by A and C is activated by A or B (Figure
<xref ref-type="fig" rid="F2">2</xref>a).</p>
        <fig id="F2" position="float">
          <label>Figure 2</label>
          <caption>
            <p><bold>Toy model.</bold> Toy model of a single cycle. <bold>(a)</bold> Influence network. <bold>(b)</bold> Logical rules and transition rates of the model. <bold>(c)</bold> Simulation parameters.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-2"/>
        </fig>
        <p>The model is defined within the language of MaBoSS by a set of logical rules associated to each node (Figure
<xref ref-type="fig" rid="F2">2</xref>b) and simulation parameters set for optimal performances (Figure
<xref ref-type="fig" rid="F2">2</xref>c). The associated transition graph, generated by GINsim, is shown in Figure
<xref ref-type="fig" rid="F3">3</xref>.</p>
        <fig id="F3" position="float">
          <label>Figure 3</label>
          <caption>
            <p><bold>Transition graph of the toy model.</bold> Transition graph for the toy model (generated by GINsim). The node states should be read as [ABC] = [<sup>∗∗∗</sup>]. [ABC]=[100] corresponds to a state in which only A is active. The nodes in green belong to a cycle, the node in red is the fixed point and the other nodes are in blue.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-3"/>
        </fig>
        <p>The only stationary distribution is the fixed point [ABC]=[000]. We study two cases: when the rate of the transition from state [001] to state [000] (corresponding to the inactivation of C) is fast and when this rate is slow. We will refer to this transition rate as the <italic>escape rate</italic>. For both cases, we plot the time trajectories of the probabilities of the fixed point [ABC]=[000] and of the probabilities of A active [ABC]=[1<sup>∗∗</sup>] where <sup>∗</sup>can be either 1 or 0, along with the trajectories of the entropy and the transition entropy.</p>
        <p>In the first case, when the escape rate is fast, we set the parameter for the transition to a high value (rate_up = 10). In Figure
<xref ref-type="fig" rid="F4">4</xref>, we notice that the probability that [ABC] is equal to [000] converges to 1. We can conclude that [ABC]=[000] is a fixed point. In addition, the entropy and the transition entropy converge to 0. With BKMC, these properties confirm that [ABC]=[000] is a fixed point. The peak in the trajectory of the entropy (between times 0 and 0.6) corresponds to a set of states that are transiently activated before reaching the fixed point.</p>
        <fig id="F4" position="float">
          <label>Figure 4</label>
          <caption>
            <p><bold>MaBoSS outputs of the toy model with fast escape rate.</bold> BKMC algorithm is applied to the toy model, with a fast escape rate. Trajectory of the network state probabilities [ABC]=[000] and [ABC]=[1<sup>∗∗</sup>] (where <sup>∗</sup>can be either 0 or 1), the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted. Because the probability of [ABC]=[000] converges to 1, [ABC]=[000] is a fixed point. The asymptotic behavior of both the entropy and the transition entropy is also the signature of a fixed point.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-4"/>
        </fig>
        <p>In the second case, when the escape rate is slow, we set the parameter for the transition to a low value (rate_down = 10<sup>−5</sup>). As illustrated in Figure
<xref ref-type="fig" rid="F5">5</xref>, the transition entropy is and remains close to zero but the entropy does not converge to zero, which is the signature of a cyclic stationary distribution (see “Entropiesł::bel sect:entropies” in “Methods”). This corresponds to the cycle [111] → [011] → [001] → [101] in the transition graph (Figure
<xref ref-type="fig" rid="F3">3</xref>). However, as seen in the transition graph, one state in the cycle has an outgoing edge that leads to the fixed point (through the transition [001] → [000] in Figure
<xref ref-type="fig" rid="F3">3</xref>). If the trajectories are plotted on a larger time scale (Figure
<xref ref-type="fig" rid="F6">6</xref>), the entropy eventually converges to 0 and the trajectory of the fixed point converges to 1, which corresponds to the case of fast escape rate. Since the value of the transition entropy of Figure
<xref ref-type="fig" rid="F5">5</xref> is not exactly zero, but 10<sup>−4</sup>, it can be anticipated that the cyclic behavior is not stable. We can conclude on stable cyclic behaviors only when the transition entropy is exactly 0.</p>
        <fig id="F5" position="float">
          <label>Figure 5</label>
          <caption>
            <p><bold>MaBoSS outputs of the toy model with slow escape rate.</bold> BKMC algorithm is applied to the toy model, with a slow escape rate. Trajectory of the network state probabilities [ABC]=[000] and [ABC]=[1**], the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted. The asymptotic behavior of both the entropy and the transition entropy seems to be the signature of a cycle.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-5"/>
        </fig>
        <fig id="F6" position="float">
          <label>Figure 6</label>
          <caption>
            <p><bold>MaBoSS outputs of toy model with slow escape rate, large time scale.</bold> BKMC algorithm is applied to the toy model, with a slow escape rate, plotted on a larger time scale. Trajectory of probabilities ([ABC]=[000] and [ABC]=[1**]), the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted. On a large time scale, the asymptotic behavior of both the entropy and the transition entropy is similar to the case of the fast escape rate (Figure
<xref ref-type="fig" rid="F3">3</xref>).</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-6"/>
        </fig>
        <p>By considering the spectrum of the transition matrix (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, section 1.1 and proof of theorem 4), it can be proven that the model with a slow escape rate is a damped oscillatory process whereas the model with a large escape rate is not. As mentioned previously, a cycle in the transition graph may or may not lead to an oscillatory behavior. Moreover, if the transition entropy seems to converge to a small value on a small time scale, and the entropy does not, this behavior illustrates the case of a transient cycle in the transition graph.</p>
      </sec>
      <sec>
        <title>p53-Mdm2 signaling</title>
        <p>We consider a model of p53 response to DNA damage
[<xref ref-type="bibr" rid="B18">18</xref>]. p53 interacts with Mdm2, which appears in two forms, cytoplasmic and nuclear. On one hand, p53 upregulates the level of cytoplasmic Mdm2 (Mdm2c), which is then transported into the nucleus, and inhibits the export of nuclear Mdm2 (Mdm2n). On the other hand, nuclear Mdm2 (Mdm2n) facilitates the degradation of p53 through ubiquitination. In the model, stress regulates the level of DNA damage (Dam), which in turn participates in the degradation process of Mdm2 in the nucleus. p53 inhibits DNA damage signal by promoting DNA repair. Here, stress is not shown explicitly (Figure
<xref ref-type="fig" rid="F7">7</xref>a).</p>
        <fig id="F7" position="float">
          <label>Figure 7</label>
          <caption>
            <p><bold>Model of p53 response to DNA damage.</bold> Model of p53 response to DNA damage. <bold>(a)</bold> Influence network. <bold>(b)</bold> Logical rules and transition rates of the model. <bold>(c)</bold> Simulation parameters.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-7"/>
        </fig>
        <p>The model is written in MaBoSS, with two levels of p53 (Figure
<xref ref-type="fig" rid="F7">7</xref>b), as it is done in Abou-Jaoudé <italic>et al.</italic>[<xref ref-type="bibr" rid="B18">18</xref>] with the appropriate simulation parameters (Figure
<xref ref-type="fig" rid="F7">7</xref>c). The associated transition graph, also generated by GINsim, is given in Figure
<xref ref-type="fig" rid="F8">8</xref>. It shows the existence of two cycles and of a fixed point [p53 Mdm2C Mdm2N Dam] = [0010] where nuclear Mdm2 is on and the rest is off.</p>
        <fig id="F8" position="float">
          <label>Figure 8</label>
          <caption>
            <p><bold>Transition graph of the model of p53 response to DNA damage.</bold> Transition graph of the p53 model (generated by GINsim). The node states should be read as [p53 Mdm2C Mdm2N Dam] = [<sup>∗∗∗∗</sup>] (where <sup>∗</sup>can be either 0 or 1). For instance, [p53 Mdm2C Mdm2N Dam]=[1000] corresponds to a state in which only p53 (at its level 1) is active. The nodes in green and the nodes in light blue belong to two cycles, the node in red is the fixed point and the other nodes are in dark blue.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-8"/>
        </fig>
        <p>In order to represent the activity of p53, the trajectories of the probabilities of all network states with p53 equal to 1 and with p53 equal to 2 are plotted (Figure
<xref ref-type="fig" rid="F9">9</xref>, upper panel), with the initial condition: [p53 Mdm2C Mdm2N Dam] = [0<sup>∗</sup>11] and for the situation when p53 is set to its highest value (2 equivalent to p53_h) and thus can promote Mdm2 cytoplasmic activity.</p>
        <fig id="F9" position="float">
          <label>Figure 9</label>
          <caption>
            <p><bold>MaBoSS outputs of the model of p53 response to DNA damage.</bold> Trajectories of the network state probabilities of [p53 Mdm2C Mdm2N Dam] = [1<sup>∗∗∗</sup>] and of [p53 Mdm2C Mdm2N Dam] = [2<sup>∗∗∗</sup>], the entropy (<italic>H</italic>) and the transition entropy (<italic>TH</italic>) are plotted.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-9"/>
        </fig>
        <p>The qualitative results obtained with MaBoSS are similar to those of Abou-Jaoudé and colleagues. However, at the level of cell population, some discrepancies appear: in Figure
<xref ref-type="fig" rid="F9">9</xref>, no damped oscillations can be seen as opposed to Figure
<xref ref-type="fig" rid="F8">8</xref> of their article. The reason is that, in their computations, the noise imposed on time is defined by a square distribution on a limited time frame, whereas in BKMC, Markovian hypotheses imply that the noise distribution is more spread out from 0 to infinity. The consequence is that synchronization is lost very fast. Damped oscillations could be observed with BKMC with a particular set of parameters: fast activation of p53 and slow degradation of p53 (results not shown).</p>
        <p>With MaBoSS, we clearly interpret the system as a population and not as a single cell. In addition, we can simulate different contexts, presented in the initial article as different models, within one single model that uses different simulation parameters to account for these contexts.</p>
        <p>Note that the existence of transient cycles, as shown in the toy model, can be deduced from the trajectory of the entropy that is significantly higher than the trajectory of the transition entropy (which is non-zero, therefore the transient cycles are not stable) (Figure
<xref ref-type="fig" rid="F9">9</xref>, lower panel).</p>
      </sec>
      <sec>
        <title>Mammalian cell cycle</title>
        <p>For the last example, we propose a model of the mammalian cell cycle initially published as on ODE model by Novák and Tyson
[<xref ref-type="bibr" rid="B29">29</xref>] and translated into a Boolean model by Fauré and colleagues
[<xref ref-type="bibr" rid="B6">6</xref>]. The latter model encompasses 10 nodes, which describe the mechanisms controlling the activity of the different CDK/cyclin complexes, the main actors of cell cycle regulation and the dynamics of entry into the cell cycle in presence of growth factors.</p>
        <p>We implement the logical rules of the published model in MaBoSS and define two parameter values for the transition rates: a slow one (set to 1) and a fast one (set to 10). The choice between slow and fast rates for each transition is based on the choice made in the published Boolean model: different priority classes were used in mixed discrete a/synchronous simulation and corresponded to the differences in speed of cellular processes such as transcription, degradation and protein modification. We could, of course, refine the analysis by setting different rates for each transition. The network, the logical rules and the simulation parameters can be found on the webpage.</p>
        <p>As mentioned before, MaBoSS can provide two types of outputs: the probabilities of different network states over time (along with the entropy and transition entropy) and the indecomposable stationary distributions.</p>
        <p>We consider two biological cases, in the presence of growth factors where the cell enters its division cycle and in the absence of growth factors where the cell is stuck in a G1-like state (state preceding replication of DNA). In the model, the activity of CyclinD (CycD), a G1-cyclin, illustrates the presence of growth factors. In our simulations, we set an initial condition corresponding to a G1 state with two CDK/cyclin inhibitors, p27 and cdh1, on, and with CyclinD on in order to account for the external growth signal. We plot the trajectories of the probabilities of all the cyclins A, B and E (Figure
<xref ref-type="fig" rid="F10">10</xref>, upper panel). The cyclins’ activities exhibit an oscillatory behavior. Each oscillation can be interpreted as a cell division cycle. However, these oscillations are damped. This can be explained by the fact that these probabilities should be interpreted at the cell population level and after few cycles, the cells become desynchronized. Moreover the trajectories of the entropy and the transition entropy exhibit the signature of cyclic attractors (Figure
<xref ref-type="fig" rid="F10">10</xref>, lower panel).</p>
        <fig id="F10" position="float">
          <label>Figure 10</label>
          <caption>
            <p><bold>MaBoSS outputs of the model of the mammalian cell cycle: trajectories of probabilities.</bold> BKMC algorithm is applied to the mammalian cell cycle model, with an initial condition corresponding to a G1 state in the presence of growth factors (CyclinD is on). Trajectories of the cyclins probabilities, the entropy (<italic>H</italic>), transition entropy (<italic>TH</italic>) are plotted. The asymptotic behavior corresponds to the first indecomposable stationary distribution identified in Figure
<xref ref-type="fig" rid="F10">10</xref>.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-10"/>
        </fig>
        <p>The indecomposable stationary distributions are identified by the clustering algorithm of MaBoSS and illustrated in Figure
<xref ref-type="fig" rid="F11">11</xref>. The two clusters in Figure
<xref ref-type="fig" rid="F11">11</xref>a show the two types of solutions for random initial conditions: one multi-cyclic solution when CyclinD is on, and which corresponds to the distribution of network states of the asymptotic solution of Figure
<xref ref-type="fig" rid="F11">11</xref>b, and one fixed point corresponding to a G1 arrest when CyclinD is off (Figure
<xref ref-type="fig" rid="F11">11</xref>c).</p>
        <fig id="F11" position="float">
          <label>Figure 11</label>
          <caption>
            <p><bold>MaBoSS outputs of the model of the mammalian cell cycle: stationary distributions.</bold> BKMC algorithm is applied to the mammalian cell cycle model, with random initial conditions. Results of the clustering algorithm that associates a cluster to each indecomposable stationary distribution. <bold>(a)</bold> Probability of reaching each identified cluster; these probabilities are estimated by the proportion of trajectories that belong to each cluster. <bold>(b)</bold> First estimated cluster that can be interpreted as a desynchronized population of cells that are dividing. <bold>(c)</bold> Second estimated cluster, corresponding to a fixed point, that can be interpreted as a G1 cell cycle arrest with no growth factors.</p>
          </caption>
          <graphic xlink:href="1752-0509-6-116-11"/>
        </fig>
        <p>These two indecomposable stationary distributions correspond to the two attractors identified by discrete time modeling in Fauré <italic>et al.</italic> In the discrete time algorithm, the asymptotic behavior is described in terms of attractors (sub-parts of the transition graph); in our algorithm, the asymptotic behavior is described in terms of network state probability distributions.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>We have presented a new algorithm, Boolean Kinetic Monte-Carlo or BKMC, applicable to dynamical simulation of signaling networks based on continuous time in the Boolean framework. BKMC algorithm is a natural generalization of the asynchronous Boolean dynamics
[<xref ref-type="bibr" rid="B2">2</xref>], with time trajectories that can be interpreted in terms of biological time. The variables of the Boolean model represent biological species and the parameters represent rates of activation or inactivation of these species that, ideally, could be deduced from experimental data.</p>
    <p>We applied this algorithm to three different models: a toy model that illustrates a simple cyclic behavior, a published model of p53 response to DNA damage, and a published model of mammalian cell cycle dynamics.</p>
    <p>This algorithm is provided within a freely available software, MaBoSS, that can run BKMC algorithm on networks up to 64 nodes in the present version. The construction of a model uses a specific language that introduces logical rules and transition rates of node activation/inactivation in a flexible manner. The software provides global and semi-global outputs of the model dynamics that can be interpreted as signatures of the dynamical behaviors. These interpretations become particularly useful when the network state space is too large to be handled. The convergence of BKMC algorithm can be controlled by tuning some simulation parameters: maximum time of the simulation, number of trajectories, length of a time window on which the average of probabilities is performed, and the threshold for the definition of stationary distribution clusters.</p>
    <p>The next step is to apply BKMC algorithm with MaBoSS on other existing large signaling networks, <italic>e.g.</italic> EGFR pathway
[<xref ref-type="bibr" rid="B30">30</xref>], the apoptosis pathway
[<xref ref-type="bibr" rid="B31">31</xref>], etc. The translation of existing Boolean models in MaBoSS is straightforward but requires the addition of transition rates. In these future works, we expect to illustrate the advantage of BKMC on other simulation algorithms. Moreover, in future developments of MaBoSS, we plan to introduce methods for sensitivity analyses, refine approximation methods used in BKMC, and generalize Markov property.</p>
    <p>We also expect to implement MaBoSS in broadly used software environments for Boolean modeling, like GINsim
[<xref ref-type="bibr" rid="B8">8</xref>] or CellNetAnalyzer
[<xref ref-type="bibr" rid="B25">25</xref>].</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>BKMC generates stochastic trajectories. In this section, we describe how we use and interpret these trajectories.</p>
    <sec>
      <title/>
      <sec>
        <title>Network state probabilities on a time window</title>
        <p>To relate continuous time probabilities to real processes, an observable time window <italic>Δt</italic> is defined. A discrete time (
<inline-formula><mml:math id="M38" name="1752-0509-6-116-i38" overflow="scroll"><mml:mi>τ</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi></mml:math></inline-formula>) stochastic process <italic>s</italic>(<italic>τ</italic>) (that is not necessary Markovian) can be extracted from the continuous time Markov process: </p>
        <p>
          <disp-formula id="bmcM8">
            <label>(8)</label>
            <mml:math id="M39" name="1752-0509-6-116-i39" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>≡</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:mfrac>
              <mml:msubsup>
                <mml:mrow>
                  <mml:mo mathsize="big">∫</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>τ</mml:mi>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>)</mml:mo>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:msubsup>
              <mml:mtext mathvariant="italic">dt</mml:mtext>
              <mml:mspace width="2.77695pt"/>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>t</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>BKMC is used for estimating
<inline-formula><mml:math id="M40" name="1752-0509-6-116-i40" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> as follows: </p>
        <p>1. <bold>Estimate for one trajectory.</bold> For each trajectory <italic>j</italic>, compute the time for which the system is in state <bold>S</bold>, in the window [<italic>τΔt</italic>,(<italic>τ</italic> + 1)<italic>Δt</italic>]. Divide this time by <italic>Δt</italic>. Obtain an estimate of
<inline-formula><mml:math id="M41" name="1752-0509-6-116-i41" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> for trajectory <italic>j</italic>, <italic>i.e.</italic><inline-formula><mml:math id="M42" name="1752-0509-6-116-i42" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>.</p>
        <p>2. <bold>Estimate for a set of trajectories.</bold> Compute the average over <italic>j</italic> of all
<inline-formula><mml:math id="M43" name="1752-0509-6-116-i43" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> to obtain
<inline-formula><mml:math id="M44" name="1752-0509-6-116-i44" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>. Compute the error of this average (
<inline-formula><mml:math id="M45" name="1752-0509-6-116-i45" overflow="scroll"><mml:msqrt><mml:mrow><mml:mtext>Var</mml:mtext><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:mtext># trajectories</mml:mtext></mml:mrow></mml:msqrt></mml:math></inline-formula>).</p>
      </sec>
      <sec>
        <title>Entropies</title>
        <p>Once
<inline-formula><mml:math id="M46" name="1752-0509-6-116-i46" overflow="scroll"><mml:mi mathvariant="bold">P</mml:mi><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> is computed, the entropy <italic>H</italic>(<italic>τ</italic>) can be estimated: </p>
        <p>
          <disp-formula id="bmcM9">
            <label>(9)</label>
            <mml:math id="M47" name="1752-0509-6-116-i47" overflow="scroll">
              <mml:mi>H</mml:mi>
              <mml:mo>(</mml:mo>
              <mml:mi>τ</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mo>−</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:msub>
                <mml:mrow>
                  <mml:mo>log</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msub>
              <mml:mfenced open="(" close=")">
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                  <mml:mfenced open="[" close="]">
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                      <mml:mo>(</mml:mo>
                      <mml:mi>τ</mml:mi>
                      <mml:mo>)</mml:mo>
                      <mml:mo>=</mml:mo>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                </mml:mrow>
              </mml:mfenced>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>The entropy measures the disorder of the system. Maximum entropy means that all states have the same probability; a zero entropy means that one of the states has a probability of one. The estimation of the entropy can be seen as a global characterization of a full probability distribution by a single real number. The choice of
<inline-formula><mml:math id="M48" name="1752-0509-6-116-i48" overflow="scroll"><mml:msub><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> allows the interpretation of <italic>H</italic>(<italic>τ</italic>) in an easier manner: 2<sup><italic>H</italic>(<italic>τ</italic>)</sup>is an estimate of the number of states that have a non-negligible probability in the time window [<italic>τΔt</italic>,(<italic>τ</italic> + 1)<italic>Δt</italic>]. A more computer-like interpretation of <italic>H</italic>(<italic>τ</italic>) is the number of bits that are necessary for describing states of non-negligible probability.</p>
        <p>The <italic>Transition Entropy</italic><italic>TH</italic> is a finer measure that characterizes the system at the level of a single trajectory. It can be computed in the following way: for each state <bold>S</bold>, there exists a set of possible transitions
<inline-formula><mml:math id="M49" name="1752-0509-6-116-i49" overflow="scroll"><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. For each of these transitions, a probability is associated: </p>
        <p>
          <disp-formula id="bmcM10">
            <label>(10)</label>
            <mml:math id="M50" name="1752-0509-6-116-i50" overflow="scroll">
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>≡</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:munder>
                    <mml:mrow>
                      <mml:mo>∑</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>′′</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:munder>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ρ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                      <mml:mo>→</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi mathvariant="bold">S</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mo>′</mml:mo>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mi>.</mml:mi>
            </mml:math>
          </disp-formula>
        </p>
        <p>By convention,
<inline-formula><mml:math id="M51" name="1752-0509-6-116-i51" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="bold">P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> if there is no transition from <bold>S </bold>to any other state.</p>
        <p>Therefore, the transition entropy <italic>TH</italic> can be associated to each state <bold>S</bold>: </p>
        <p>
          <disp-formula id="bmcM11">
            <label>(11)</label>
            <mml:math id="M52" name="1752-0509-6-116-i52" overflow="scroll">
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mo>−</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:munder>
              <mml:msub>
                <mml:mrow>
                  <mml:mo>log</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msub>
              <mml:mo>(</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>)</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>→</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">′</mml:mi>
                    </mml:mrow>
                  </mml:msup>
                </mml:mrow>
              </mml:msub>
            </mml:math>
          </disp-formula>
        </p>
        <p>Similarly, <italic>TH</italic>(<bold>S</bold>) = 0 if there is no transition from <bold>S</bold> to any other state. The transition entropy on a time window <italic>TH</italic>(<italic>τ</italic>) is defined as: </p>
        <p>
          <disp-formula>
            <mml:math id="M53" name="1752-0509-6-116-i53" overflow="scroll">
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi>τ</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>τ</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>)</mml:mo>
            </mml:math>
          </disp-formula>
        </p>
        <p>This transition entropy is estimated in the following way: </p>
        <p>1. <bold>Estimate for one trajectory.</bold> For each trajectory <italic>j</italic>, compute the set Φ of visited states <bold>S</bold> in the time window [<italic>τΔt</italic>,(<italic>τ</italic> + 1)<italic>Δt</italic>] and their respective duration <italic>μ</italic><sub><bold>S</bold></sub>. The estimated transition entropy is: </p>
        <p>
          <disp-formula id="bmcM12">
            <label>(12)</label>
            <mml:math id="M54" name="1752-0509-6-116-i54" overflow="scroll">
              <mml:msub>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mrow>
                      <mml:mtext mathvariant="italic">TH</mml:mtext>
                      <mml:mo>(</mml:mo>
                      <mml:mi>τ</mml:mi>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>Φ</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mtext mathvariant="italic">TH</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>μ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>Δ</mml:mi>
                  <mml:mi>t</mml:mi>
                </mml:mrow>
              </mml:mfrac>
            </mml:math>
          </disp-formula>
        </p>
        <p>2. <bold>Estimate for a set of trajectories.</bold> Compute the average over <italic>j</italic> of all
<inline-formula><mml:math id="M55" name="1752-0509-6-116-i55" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mtext mathvariant="italic">TH</mml:mtext><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> to obtain
<inline-formula><mml:math id="M56" name="1752-0509-6-116-i56" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mtext mathvariant="italic">TH</mml:mtext><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula>. Compute the error of this average (
<inline-formula><mml:math id="M57" name="1752-0509-6-116-i57" overflow="scroll"><mml:msqrt><mml:mrow><mml:mtext>Var</mml:mtext><mml:mo>(</mml:mo><mml:mover accent="true"><mml:mrow><mml:mtext mathvariant="italic">TH</mml:mtext><mml:mo>(</mml:mo><mml:mi>τ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:mtext># trajectories</mml:mtext></mml:mrow></mml:msqrt></mml:math></inline-formula>).</p>
        <p>This transition entropy is a way to measure how deterministic the dynamics is. If the transition entropy is always zero, the system can only make a transition to a given state.</p>
        <p>If probability distributions on a time window tend to constant values (or tend to a stationary distribution), the entropy and the transition entropy can help characterize this stationary distribution such that: </p>
        <p>• A fixed point has zero entropy and zero transition entropy,</p>
        <p>• A cyclic stationary distribution has non-zero entropy and zero transition entropy.</p>
        <p>Entropy and transition entropy can be considered as “global characterizations” of the model: for a given time window, they always consist of two real numbers, whatever the size of the network is.</p>
      </sec>
      <sec>
        <title>Hamming distance distribution</title>
        <p>The <italic>Hamming Distance</italic> between two states <bold>S</bold>and <bold>S</bold><sup><italic>′</italic></sup> is the number of nodes that have different node states between <bold>S</bold>and <bold>S</bold><sup><italic>′</italic></sup>: </p>
        <p>
          <disp-formula id="bmcM13">
            <label>(13)</label>
            <mml:math id="M58" name="1752-0509-6-116-i58" overflow="scroll">
              <mml:mtext mathvariant="italic">HD</mml:mtext>
              <mml:mo>(</mml:mo>
              <mml:mi mathvariant="bold">S</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>′</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:mo>)</mml:mo>
              <mml:mo>≡</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mo>(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>δ</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:msubsup>
                    <mml:mrow>
                      <mml:mi>S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msubsup>
                </mml:mrow>
              </mml:msub>
              <mml:mo>)</mml:mo>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>δ</italic> is the Kronecker delta (
<inline-formula><mml:math id="M59" name="1752-0509-6-116-i59" overflow="scroll"><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> if <italic>S</italic><sub><italic>i </italic></sub>=<italic> S</italic><sub><italic>i</italic></sub><sup><italic>′</italic></sup>,
<inline-formula><mml:math id="M60" name="1752-0509-6-116-i60" overflow="scroll"><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> if <italic>S</italic><sub><italic>i </italic></sub>≠<italic> S</italic><sub><italic>i</italic></sub><sup><italic>′</italic></sup>). Given a reference state <bold>S</bold><sub>ref</sub>, the Hamming distance distribution (over time) is given by: </p>
        <p>
          <disp-formula id="bmcM14">
            <label>(14)</label>
            <mml:math id="M61" name="1752-0509-6-116-i61" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mo>(</mml:mo>
              <mml:mtext mathvariant="italic">HD</mml:mtext>
              <mml:mo>,</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>t</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>δ</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mtext mathvariant="italic">HD</mml:mtext>
                  <mml:mo>,</mml:mo>
                  <mml:mtext mathvariant="italic">HD</mml:mtext>
                  <mml:mo>(</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mtext>ref</mml:mtext>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:msub>
            </mml:math>
          </disp-formula>
        </p>
        <p>The estimation of the Hamming distance distribution on a time window <bold>P</bold>(<italic>HD</italic>,<italic>τ</italic>) is similar to that of stochastic probabilities on a time window.</p>
        <p>The Hamming distance distribution is a useful characterization when the set of instantaneous probabilities is compared to a reference state (<bold>S</bold><sub>ref</sub>). In that case, the Hamming distance distribution describes how far this set is to this reference state. The Hamming distance distribution can be considered as a “semi-global” characterization of time evolution: for a given time window, the size of this characterization is the number of nodes (to be compared with probabilities on a time window whose size is 2<sup>#nodes</sup>).</p>
      </sec>
      <sec>
        <title>Input, internal, output and reference nodes</title>
        <p><italic>Input Nodes</italic> are defined as the nodes for which the initial condition is fixed. Therefore, each trajectory of BKMC starts with fixed values of input nodes and random values of other nodes.</p>
        <p><italic>Internal nodes</italic> are nodes that are not considered for computing probability distributions, entropies and transition entropies. <italic>Output nodes</italic> are nodes that are not internal. Technically, probabilities are summed up over network states that differ only by the state of internal nodes. These internal nodes are only used for generating time trajectories with BKMC algorithm. Usually, nodes are chosen to be internal when the corresponding species is not measured experimentally. Mathematically, it is equivalent to transform the original Markov process to a new stochastic process (that is not necessary Markovian) defined on a new network state space. This new state space is defined by the states of the output nodes. This raises the question of the transition entropy <italic>TH</italic>: formally, this notion has only a sense within Markovian processes, <italic>i.e.</italic> when there are no internal nodes. Here, we generalize the notion of transition entropy even in the case of internal nodes. Suppose that the system is in state <bold>S</bold>: </p>
        <p>• If the only possible transitions from state <bold>S </bold>to any other state consist of flipping an internal node, the transition entropy is zero.</p>
        <p>• If there is, at least, one transition from state <bold>S </bold>to another state that flips an output node, then only the output nodes will be considered for computing probabilities in equation 10. In particular,
<inline-formula><mml:math id="M62" name="1752-0509-6-116-i62" overflow="scroll"><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>ρ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:math></inline-formula> is computed only on output node flipping events.</p>
        <p><italic>Reference nodes</italic> are nodes for which a reference node state is specified and for which the Hamming distance is computed. In this framework, a reference state is composed of reference nodes for which the node state is known and non-reference nodes for which the node state is unknown. Note that non-reference nodes may differ from internal nodes.</p>
      </sec>
      <sec>
        <title>Stationary distribution characterization</title>
        <p>It can be shown (see Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, corollary 2, section 1.2) that instantaneous probabilities of a continuous time Markov process converge to a stationary distribution. Fixed points and cycles are two special cases of stationary distributions. They can be identified by the asymptotic behavior of entropy and transition entropy (this works only if no nodes are internal): </p>
        <p>• If both the transition entropy and the entropy converge to zero, then the process converges to a fixed point.</p>
        <p>• if the transition entropy converges to zero and the entropy does not, then the process converges to a cycle.</p>
        <p>More generally, the complete description of the Markov process asymptotic behavior can be expressed as a linear combination of the indecomposable stationary distributions.</p>
        <p>A set of finite trajectories, produced by BKMC, can be used to estimate the set of indecomposable stationary distributions. Consider a trajectory
<inline-formula><mml:math id="M63" name="1752-0509-6-116-i63" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>]</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>⋯</mml:mo><mml:mspace width="0.3em"/><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:math></inline-formula>. Let
<inline-formula><mml:math id="M64" name="1752-0509-6-116-i64" overflow="scroll"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>≡</mml:mo><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">S</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:math></inline-formula>. The estimation of the associated indecomposable stationary probability distribution (<italic>s</italic><sub>0</sub>) is done by averaging over the whole trajectory: </p>
        <p>
          <disp-formula id="bmcM15">
            <label>(15)</label>
            <mml:math id="M65" name="1752-0509-6-116-i65" overflow="scroll">
              <mml:mover accent="true">
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                </mml:mrow>
                <mml:mo>^</mml:mo>
              </mml:mover>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>T</mml:mi>
                </mml:mrow>
              </mml:mfrac>
              <mml:msubsup>
                <mml:mrow>
                  <mml:mo mathsize="big">∫</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>0</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>T</mml:mi>
                </mml:mrow>
              </mml:msubsup>
              <mml:mtext mathvariant="italic">dt</mml:mtext>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>I</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>(</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>)</mml:mo>
            </mml:math>
          </disp-formula>
        </p>
        <p>Therefore, a set of indecomposable stationary distribution estimates can be obtained by a set of trajectories. These indecomposable stationary distribution estimates should be clustered in groups, where each group consists of estimates for the same indecomposable stationary distribution. For that, we use the fact that two indecomposable stationary distributions are identical if they have the same support, <italic>i.e.</italic> the same set of network states with non-zero probabilities (shown in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>, “Basic information on Markov process”, theorem 2, section 1.2). Therefore, it is possible to quantify how similar two indecomposable stationary distribution estimates are. A <italic>similarity coefficient</italic><inline-formula><mml:math id="M66" name="1752-0509-6-116-i66" overflow="scroll"><mml:mi>D</mml:mi><mml:mo>(</mml:mo><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msubsup><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:math></inline-formula>, given two stationary distribution estimates <italic>s</italic><sub>0</sub><sup>(<italic>i</italic>)</sup> and <italic>s</italic><sub>0</sub><sup>(<italic>i</italic>)</sup> , is defined: </p>
        <p>
          <disp-formula id="bmcM16">
            <label>(16)</label>
            <mml:math id="M67" name="1752-0509-6-116-i67" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mi>D</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>j</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>)</mml:mo>
                    <mml:mo>≡</mml:mo>
                    <mml:mfenced open="(" close=")">
                      <mml:mrow>
                        <mml:munder>
                          <mml:mrow>
                            <mml:mo mathsize="big">∑</mml:mo>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi mathvariant="bold">S</mml:mi>
                            <mml:mo>∈</mml:mo>
                            <mml:mtext>support</mml:mtext>
                            <mml:mo>(</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>,</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:munder>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="3em"/>
                    <mml:mspace width="3em"/>
                    <mml:mspace width="1em"/>
                    <mml:mo>×</mml:mo>
                    <mml:mfenced open="(" close=")">
                      <mml:mrow>
                        <mml:munder>
                          <mml:mrow>
                            <mml:mo mathsize="big">∑</mml:mo>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi mathvariant="bold">S</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>′</mml:mi>
                              </mml:mrow>
                            </mml:msup>
                            <mml:mo>∈</mml:mo>
                            <mml:mtext>support</mml:mtext>
                            <mml:mo>(</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>,</mml:mo>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>)</mml:mo>
                          </mml:mrow>
                        </mml:munder>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi mathvariant="bold">S</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>′</mml:mi>
                              </mml:mrow>
                            </mml:msup>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>where </p>
        <p>
          <disp-formula id="bmcM17">
            <label>(17)</label>
            <mml:math id="M68" name="1752-0509-6-116-i68" overflow="scroll">
              <mml:mtable class="align" columnalign="left">
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mtext>support</mml:mtext>
                    <mml:mo>(</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>(</mml:mo>
                        <mml:mi>j</mml:mi>
                        <mml:mo>)</mml:mo>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>)</mml:mo>
                    <mml:mo>≡</mml:mo>
                    <mml:mfenced open="{">
                      <mml:mrow>
                        <mml:mi mathvariant="bold">S</mml:mi>
                        <mml:mtext>such that</mml:mtext>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                        </mml:mfenced>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd class="align-1">
                    <mml:mspace width="3em"/>
                    <mml:mspace width="3em"/>
                    <mml:mspace width="3em"/>
                    <mml:mspace width="1em"/>
                    <mml:mfenced close="}">
                      <mml:mrow>
                        <mml:mo>×</mml:mo>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:mi mathvariant="bold">P</mml:mi>
                          </mml:mrow>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mfenced open="[" close="]">
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>)</mml:mo>
                              </mml:mrow>
                            </mml:msubsup>
                            <mml:mo>=</mml:mo>
                            <mml:mi mathvariant="bold">S</mml:mi>
                          </mml:mrow>
                        </mml:mfenced>
                        <mml:mo>&gt;</mml:mo>
                        <mml:mn>0</mml:mn>
                      </mml:mrow>
                    </mml:mfenced>
                    <mml:mspace width="2em"/>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>Clusters can be constructed when a similarity threshold <italic>α</italic> is provided. A cluster of stationary distributions is defined as follows: </p>
        <p>
          <disp-formula id="bmcM18">
            <label>(18)</label>
            <mml:math id="M69" name="1752-0509-6-116-i69" overflow="scroll">
              <mml:mi mathvariant="script">C</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mfenced open="{" close="}">
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>|</mml:mo>
                  <mml:mspace width="2.77695pt"/>
                  <mml:mo>∃</mml:mo>
                  <mml:msubsup>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msubsup>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mtext>s. t.</mml:mtext>
                  <mml:mi>D</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:msubsup>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>0</mml:mn>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>′</mml:mi>
                    </mml:mrow>
                  </mml:msubsup>
                  <mml:mo>)</mml:mo>
                  <mml:mo>≥</mml:mo>
                  <mml:mi>α</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>For each cluster
<inline-formula><mml:math id="M70" name="1752-0509-6-116-i70" overflow="scroll"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula>, a distribution estimate
<inline-formula><mml:math id="M71" name="1752-0509-6-116-i71" overflow="scroll"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="script">C</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>, associated to an indecomposable stationary distribution, can be defined: </p>
        <p>
          <disp-formula id="bmcM19">
            <label>(19)</label>
            <mml:math id="M72" name="1752-0509-6-116-i72" overflow="scroll">
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi mathvariant="script">C</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>|</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mo>|</mml:mo>
                </mml:mrow>
              </mml:mfrac>
              <mml:munder>
                <mml:mrow>
                  <mml:mo>∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mi mathvariant="bold">P</mml:mi>
              <mml:mfenced open="[" close="]">
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mi mathvariant="bold">S</mml:mi>
                </mml:mrow>
              </mml:mfenced>
            </mml:math>
          </disp-formula>
        </p>
        <p>Errors on this estimate can be computed by: </p>
        <p>
          <disp-formula id="bmcM20">
            <label>(20)</label>
            <mml:math id="M73" name="1752-0509-6-116-i73" overflow="scroll">
              <mml:mtext>Err</mml:mtext>
              <mml:mfenced open="(" close=")">
                <mml:mrow>
                  <mml:mi mathvariant="bold">P</mml:mi>
                  <mml:mfenced open="[" close="]">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="script">C</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>=</mml:mo>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                </mml:mrow>
              </mml:mfenced>
              <mml:mo>=</mml:mo>
              <mml:msqrt>
                <mml:mrow>
                  <mml:mtext>Var</mml:mtext>
                  <mml:mo>(</mml:mo>
                  <mml:mi mathvariant="bold">P</mml:mi>
                  <mml:mfenced open="[" close="]">
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mi mathvariant="bold">S</mml:mi>
                    </mml:mrow>
                  </mml:mfenced>
                  <mml:mo>,</mml:mo>
                  <mml:mi>s</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>/</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:mi mathvariant="script">C</mml:mi>
                  <mml:mo>|</mml:mo>
                </mml:mrow>
              </mml:msqrt>
            </mml:math>
          </disp-formula>
        </p>
        <p>Notice that this clustering procedure has no sense if the process is not Markovian; therefore, no nodes are considered as internal.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Abbreviations</title>
    <p>BKMC: Boolean Kinetic Monte-Carlo; AT: Asynchronous transition; ODEs: Ordinary differential equations; MaBoSS: Markov Boolean Stochastic Simulator.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors’ contributions</title>
    <p>G. Stoll organized the project, set up the algorithms, participated in writing the software, set up the examples and wrote the article. E. Viara wrote the software and participated in setting up the algorithms. E. Barillot participated in discussions and corrected the manuscript. L. Calzone organized the project, set up the examples and wrote the article. All authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Supplementary material.</bold> Basic information on Markov process, abbreviations, definitions and algorithms.</p>
      </caption>
      <media xlink:href="1752-0509-6-116-S1.pdf" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="S2">
      <caption>
        <title>Additional file 2</title>
        <p><bold>Model of the mammalian cell cycle with GINsim, BoolNet and MaBoSS.</bold> The cell cycle presented in the “Examples” section has been modeled using three tools: GINsim, BoolNet, and MaBoSS. The results for each tool are presented: (1) GINsim provides steady state solutions and transition graphs for two different initial conditions: when CycD=0 and CycD=1. For the synchronous strategy, the transition graph can be visualized whereas for the asynchronous strategy, it is not easy to read or use; BoolNet constructs two graphical representations of the trajectories based on synchronous update strategy, for the case of CycD=0 (steady state) and CycD=1 (cycle); (3) MaBoSS estimates indecomposable stationary distributions for the case of CycD=0 (one fixed point, not shown) and CycD=1 (distribution of probabilities of different network states), and time-dependent activities of the cyclins showing damped oscillations. All results are coherent but are presented differently with a different focus for each tool.</p>
      </caption>
      <media xlink:href="1752-0509-6-116-S2.pdf" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>This project was supported by the Institut National du Cancer (SybEwing project), the Agence National de la Recherche (Calamar project). The research leading to these results has received funding from the European Community’s Seventh Framework Programme (FP7/2007-2013) under grant agreement nb HEALTH-F4-2007-200767 for APO-SYS and nb FP7-HEALTH-2010-259348 for ASSET. GS, EB and LC are members of the team “Computational Systems Biology of Cancer”, Equipe labellisée par la Ligue Nationale Contre le Cancer. We’d like to thank Camille Sabbah, Jacques Rougemont, Denis Thieffry, Elisabeth Remy, Luca Grieco and Andrei Zinovyev.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kauffman</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Homeostasis and differentiation in random genetic control networks</article-title>
        <source>Nature</source>
        <year>1969</year>
        <volume>224</volume>
        <fpage>177</fpage>
        <lpage>178</lpage>
        <pub-id pub-id-type="doi">10.1038/224177a0</pub-id>
        <pub-id pub-id-type="pmid">5343519</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Thomas</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Regulatory networks seen as asynchronous automata: a logical description</article-title>
        <source>J Theor Biol</source>
        <year>1991</year>
        <volume>153</volume>
        <fpage>1</fpage>
        <lpage>23</lpage>
        <pub-id pub-id-type="doi">10.1016/S0022-5193(05)80350-9</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Stoll</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Rougemont</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Naef</surname>
          <given-names>F</given-names>
        </name>
        <article-title>Few crucial links assure checkpoint efficiency in the yeast cell-cycle network</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>20</issue>
        <fpage>2539</fpage>
        <lpage>2546</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl432</pub-id>
        <pub-id pub-id-type="pmid">16895923</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Stoll</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Bischofberger</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Rougemont</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Naef</surname>
          <given-names>F</given-names>
        </name>
        <article-title>Stabilizing patterning in the Drosophila segment polarity network by selecting models in silico</article-title>
        <source>Biosystems</source>
        <year>2010</year>
        <volume>102</volume>
        <fpage>3</fpage>
        <lpage>10</lpage>
        <pub-id pub-id-type="doi">10.1016/j.biosystems.2010.07.014</pub-id>
        <pub-id pub-id-type="pmid">20655356</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Garg</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Mohanram</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Di Cara</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>De Micheli</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Xenarios</surname>
          <given-names>I</given-names>
        </name>
        <article-title>Modeling stochasticity and robustness in gene regulatory networks</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>12</issue>
        <fpage>i101—i109</fpage>
        <pub-id pub-id-type="pmid">19477975</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Fauré</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Thieffry</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Naldi</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Dynamical analysis of a generic Boolean model for the control of the mammalian cell cycle</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>14</issue>
        <fpage>e124—e131</fpage>
        <pub-id pub-id-type="pmid">16873462</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Shmulevich</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Dougherty</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Probabilistic Boolean networks: a rule-based uncertainty model for gene regulatory networks</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <issue>2</issue>
        <fpage>261</fpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/18.2.261</pub-id>
        <pub-id pub-id-type="pmid">11847074</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gonzalez</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Naldi</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Sanchez</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Thieffry</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <article-title>GINsim: a software suite for the qualitative modelling, simulation and analysis of regulatory networks</article-title>
        <source>Biosystems</source>
        <year>2006</year>
        <volume>84</volume>
        <issue>2</issue>
        <fpage>91</fpage>
        <lpage>100</lpage>
        <pub-id pub-id-type="doi">10.1016/j.biosystems.2005.10.003</pub-id>
        <pub-id pub-id-type="pmid">16434137</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wunderlich</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>DePace</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Modeling transcriptional networks in Drosophila development at multiple scales</article-title>
        <source>Curr Opin Genet Dev</source>
        <year>2011</year>
        <volume>21</volume>
        <issue>6</issue>
        <fpage>711</fpage>
        <lpage>718</lpage>
        <pub-id pub-id-type="doi">10.1016/j.gde.2011.07.005</pub-id>
        <pub-id pub-id-type="pmid">21889888</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>MacArthur</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Ma’ayan</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Lemischka</surname>
          <given-names>I</given-names>
        </name>
        <article-title>Systems biology of stem cell fate and cellular reprogramming</article-title>
        <source>Nat Rev Mol Cell Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>10</issue>
        <fpage>672</fpage>
        <lpage>681</lpage>
        <pub-id pub-id-type="pmid">19738627</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Saez-Rodriguez</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Alexopoulos</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Morris</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Lauffenburger</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Sorger</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Comparing signaling networks between normal and transformed hepatocytes using discrete logical models</article-title>
        <source>Cancer Res</source>
        <year>2011</year>
        <volume>71</volume>
        <issue>16</issue>
        <fpage>5400</fpage>
        <pub-id pub-id-type="doi">10.1158/0008-5472.CAN-10-4453</pub-id>
        <pub-id pub-id-type="pmid">21742771</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Siebert</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Bockmayr</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Temporal constraints in the logical analysis of regulatory networks</article-title>
        <source>Theor Comput Sci</source>
        <year>2008</year>
        <volume>391</volume>
        <issue>3</issue>
        <fpage>258</fpage>
        <lpage>275</lpage>
        <pub-id pub-id-type="doi">10.1016/j.tcs.2007.11.010</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="book">
        <name>
          <surname>Öktem</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Pearson</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Yli-Harja</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Nicorici</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Egiazarian</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Astola</surname>
          <given-names>J</given-names>
        </name>
        <etal/>
        <article-title>A computational model for simulating continuous time Boolean networks</article-title>
        <source>Proceedings of IEEE International Workshop on Genomic Signal Processing and Statistics (GENSIPS’02)</source>
        <year>October 2002</year>
        <publisher-name>NC, USA: Raleigh</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Vahedi</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Faryabi</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Chamberland</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Datta</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Dougherty</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Sampling-rate-dependent probabilistic Boolean networks</article-title>
        <source>J Theor Biol</source>
        <year>2009</year>
        <volume>261</volume>
        <issue>4</issue>
        <fpage>540</fpage>
        <lpage>547</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2009.08.026</pub-id>
        <pub-id pub-id-type="pmid">19716832</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sevim</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Gong</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Socolar</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Reliability of transcriptional cycles and the yeast cell-cycle oscillator</article-title>
        <source>PLoS Comput Biol</source>
        <year>2010</year>
        <volume>6</volume>
        <issue>7</issue>
        <fpage>e1000842</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1000842</pub-id>
        <pub-id pub-id-type="pmid">20628620</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Teraguchi</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kumagai</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Vandenbon</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Akira</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Standley</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Stochastic binary modeling of cells in continuous time as an alternative to biochemical reaction equations</article-title>
        <source>Phys Rev E</source>
        <year>2011</year>
        <volume>062903</volume>
        <issue>6</issue>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bauer</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Jackson</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Jiang</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Rohlf</surname>
          <given-names>T</given-names>
        </name>
        <article-title>Receptor cross-talk in angiogenesis: mapping environmental cues to cell phenotype using a stochastic, Boolean signaling network model</article-title>
        <source>J Theor Biol</source>
        <year>2010</year>
        <volume>264</volume>
        <issue>3</issue>
        <fpage>838</fpage>
        <lpage>846</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2010.03.025</pub-id>
        <pub-id pub-id-type="pmid">20307549</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Abou-Jaoudé</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Ouattara</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Kaufman</surname>
          <given-names>M</given-names>
        </name>
        <article-title>From structure to dynamics: frequency tuning in the p53-Mdm2 network: I. Logical approach</article-title>
        <source>J Theor Biol</source>
        <year>2009</year>
        <volume>258</volume>
        <issue>4</issue>
        <fpage>561</fpage>
        <lpage>577</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2009.02.005</pub-id>
        <pub-id pub-id-type="pmid">19233211</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="book">
        <name>
          <surname>Van Kampen</surname>
          <given-names>N</given-names>
        </name>
        <source>Stochastic Processes in Physics and Chemistry</source>
        <year>2004</year>
        <publisher-name>Amsterdam, Netherlands: Elsevier</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="book">
        <name>
          <surname>Shiryaev</surname>
          <given-names>A</given-names>
        </name>
        <source>Probability, volume 95 of Graduate texts in mathematics</source>
        <year>1996</year>
        <publisher-name>Springer-Verlag: New York, USA</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chaves</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Albert</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Sontag</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Robustness and fragility of Boolean models for genetic regulatory networks</article-title>
        <source>J Theor Biol</source>
        <year>2005</year>
        <volume>235</volume>
        <issue>3</issue>
        <fpage>431</fpage>
        <lpage>449</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2005.01.023</pub-id>
        <pub-id pub-id-type="pmid">15882705</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Petri net modelling of biological networks</article-title>
        <source>Briefings in Bioinformatics</source>
        <year>2007</year>
        <volume>8</volume>
        <issue>4</issue>
        <fpage>210</fpage>
        <lpage>219</lpage>
        <pub-id pub-id-type="doi">10.1093/bib/bbm029</pub-id>
        <pub-id pub-id-type="pmid">17626066</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Young</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Elcock</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Monte Carlo studies of vacancy migration in binary ordered alloys: I</article-title>
        <source>Proceedings of the Physical Society</source>
        <year>1966</year>
        <volume>89</volume>
        <fpage>735</fpage>
        <pub-id pub-id-type="doi">10.1088/0370-1328/89/3/329</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gillespie</surname>
          <given-names>D</given-names>
        </name>
        <article-title>A general method for numerically simulating the stochastic time evolution of coupled chemical reactions</article-title>
        <source>J Comput Phys</source>
        <year>1976</year>
        <volume>22</volume>
        <issue>4</issue>
        <fpage>403</fpage>
        <lpage>434</lpage>
        <pub-id pub-id-type="doi">10.1016/0021-9991(76)90041-3</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Klamt</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Saez-Rodriguez</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Gilles</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Structural and functional analysis of cellular networks with CellNetAnalyzer</article-title>
        <source>BMC Syst Biol</source>
        <year>2007</year>
        <volume>1</volume>
        <fpage>2</fpage>
        <pub-id pub-id-type="doi">10.1186/1752-0509-1-2</pub-id>
        <pub-id pub-id-type="pmid">17408509</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Müssel</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Hopfensitz</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kestler</surname>
          <given-names>H</given-names>
        </name>
        <article-title>BoolNet–an R package for generation, reconstruction and analysis of Boolean networks</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>10</issue>
        <fpage>1378</fpage>
        <lpage>1380</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq124</pub-id>
        <pub-id pub-id-type="pmid">20378558</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>De Jong</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Geiselmann</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Hernandez</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Page</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Genetic Network Analyzer: qualitative simulation of genetic regulatory networks</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>3</issue>
        <fpage>336</fpage>
        <lpage>344</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btf851</pub-id>
        <pub-id pub-id-type="pmid">12584118</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Di Cara</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Garg</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>De Micheli</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Xenarios</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Mendoza</surname>
          <given-names>L</given-names>
        </name>
        <article-title>Dynamic simulation of regulatory networks using SQUAD</article-title>
        <source>BMC Bioinf</source>
        <year>2007</year>
        <volume>8</volume>
        <fpage>462</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-8-462</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Novak</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Tyson</surname>
          <given-names>J</given-names>
        </name>
        <article-title>A model for restriction point control of the mammalian cell cycle</article-title>
        <source>J Theor Biol</source>
        <year>2004</year>
        <volume>230</volume>
        <issue>4</issue>
        <fpage>563</fpage>
        <lpage>579</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jtbi.2004.04.039</pub-id>
        <pub-id pub-id-type="pmid">15363676</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sahin</surname>
          <given-names>Ö</given-names>
        </name>
        <name>
          <surname>Fröhlich</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Löbke</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Korf</surname>
          <given-names>U</given-names>
        </name>
        <name>
          <surname>Burmester</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Majety</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Mattern</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Schupp</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Chaouiya</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Thieffry</surname>
          <given-names>D</given-names>
        </name>
        <etal/>
        <article-title>Modeling ERBB receptor-regulated G1/S transition to find novel targets for de novo trastuzumab resistance</article-title>
        <source>BMC Syst Biol</source>
        <year>2009</year>
        <volume>3</volume>
        <fpage>1</fpage>
        <pub-id pub-id-type="doi">10.1186/1752-0509-3-1</pub-id>
        <pub-id pub-id-type="pmid">19118495</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Schlatter</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Schmich</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Vizcarra</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Scheurich</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Sauter</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Borner</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Ederer</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Merfort</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Sawodny</surname>
          <given-names>O</given-names>
        </name>
        <article-title>ON/OFF and beyond-a boolean model of apoptosis</article-title>
        <source>PLoS Comput Biol</source>
        <year>2009</year>
        <volume>5</volume>
        <issue>12</issue>
        <fpage>e1000595</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1000595</pub-id>
        <pub-id pub-id-type="pmid">20011108</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
