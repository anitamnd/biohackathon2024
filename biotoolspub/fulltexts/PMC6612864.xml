<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6612864</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz350</article-id>
    <article-id pub-id-type="publisher-id">btz350</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2019 Conference Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Comparative and Functional Genomics</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Building large updatable colored de Bruijn graphs via merging</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-9283-0049</contrib-id>
        <name>
          <surname>Muggli</surname>
          <given-names>Martin D</given-names>
        </name>
        <xref ref-type="aff" rid="btz350-aff1">1</xref>
        <xref ref-type="corresp" rid="btz350-cor1"/>
        <!--<email>martin.muggli@colostate.edu</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Alipanahi</surname>
          <given-names>Bahar</given-names>
        </name>
        <xref ref-type="aff" rid="btz350-aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Boucher</surname>
          <given-names>Christina</given-names>
        </name>
        <xref ref-type="aff" rid="btz350-aff2">2</xref>
        <xref ref-type="corresp" rid="btz350-cor1"/>
        <!--<email>cboucher@cise.ufl.edu</email>-->
      </contrib>
    </contrib-group>
    <aff id="btz350-aff1"><label>1</label>Department of Computer Science, Colorado State University, Fort Collins, CO, USA</aff>
    <aff id="btz350-aff2"><label>2</label>Department of Computer and Information Science and Engineering, University of Florida, Gainesville, FL, USA</aff>
    <author-notes>
      <corresp id="btz350-cor1">To whom correspondence should be addressed. <email>martin.muggli@colostate.edu</email> or <email>cboucher@cise.ufl.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-05">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>35</volume>
    <issue>14</issue>
    <fpage>i51</fpage>
    <lpage>i60</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz350.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>There exist several large genomic and metagenomic data collection efforts, including GenomeTrakr and MetaSub, which are routinely updated with new data. To analyze such datasets, memory-efficient methods to construct and store the colored de Bruijn graph were developed. Yet, a problem that has not been considered is constructing the colored de Bruijn graph in a scalable manner that allows new data to be added without reconstruction. This problem is important for large public datasets as scalability is needed but also the ability to update the construction is also needed.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We create a method for constructing the colored de Bruijn graph for large datasets that is based on partitioning the data into smaller datasets, building the colored de Bruijn graph using a FM-index based representation, and succinctly merging these representations to build a single graph. The last step, merging succinctly, is the algorithmic challenge which we solve in this article. We refer to the resulting method as <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula>. This construction method also allows the graph to be updated with new data. We validate our approach and show it produces a three-fold reduction in working space when constructing a colored de Bruijn graph for 8000 strains. Lastly, we compare <inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> to other competing methods—including <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>, Rainbowfish, Mantis, Bloom Filter Trie, the method of Almodaresi <italic>et al.</italic> and Multi-BRWT—and illustrate that <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> is the only method that is capable of building the colored de Bruijn graph for 16 000 strains in a manner that allows it to be updated. Competing methods either did not scale to this large of a dataset or do not allow for additions without reconstruction.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>VariMerge is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/cosmo-team/cosmo/tree/VARI-merge">https://github.com/cosmo-team/cosmo/tree/VARI-merge</ext-link> under GPLv3 license.</p>
      </sec>
      <sec id="s4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">National Science Foundation (NSF) IIS</named-content>
        </funding-source>
        <award-id>1618814</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">National Institute of Allergy and Infectious Diseases Institute of the National Institutes of Health</named-content>
        </funding-source>
        <award-id>R01AI141810-01</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>The money and time needed to sequence a genome have decreased remarkably in the past decade. With this decrease has come an increase in the number and rate at which sequence data are collected for public sequencing projects. This led to the existence of GenomeTrakr, which is a large public effort to use genome sequencing for surveillance and detection of outbreaks of foodborne illnesses. This effort includes over 50 000 samples, spanning several species available through this initiative—a number that continues to rise as datasets are continually added (<xref rid="btz350-B26" ref-type="bibr">Stevens <italic>et al.</italic>, 2017</xref>). Another example is illustrated by the sequencing of the human genome. <xref rid="btz350-B28" ref-type="bibr">The 1000 Genomes Project Consortium (2015)</xref> was announced in 2008 and completed in 2015, and now the 100 000 Genomes Project is well underway (<xref rid="btz350-B29" ref-type="bibr">Turnbull <italic>et al.</italic>, 2018</xref>). Unfortunately, methods to analyze these and other large public datasets are limited due to their size.</p>
    <p><xref rid="btz350-B14" ref-type="bibr">Iqbal <italic>et al.</italic> (2012)</xref> presented one method for analysis of sequence data from large populations (such as the ones described above) which focuses on the construction of the <italic>colored de Bruijn graph</italic>. To define the colored de Bruijn graph, we first define the traditional de Bruijn graph and then show how it can be extended. Formally, a de Bruijn graph constructed for a set of strings (e.g. sequence reads) has a distinct vertex <italic>v</italic> for every unique <inline-formula id="IE5"><mml:math id="IM5"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer (substring of length <inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) present in the strings, and a directed edge (<italic>u</italic>, <italic>v</italic>) for every observed <italic>k</italic>-mer in the strings with <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer prefix <italic>u</italic> and <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer suffix <italic>v</italic>. In the colored de Bruijn graph, the edge structure is the same as the classic structure, but now to each node (<inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer) and edge (<italic>k</italic>-mer) is associated a list of colors corresponding to the samples in which the node or edge label exists. More specifically, given a set of <italic>n</italic> samples, there exists a set <inline-formula id="IE10"><mml:math id="IM10"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula> of <italic>n</italic> colors <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> where <italic>c<sub>i</sub></italic> corresponds to sample <italic>i</italic> and all <italic>k</italic>-mers and <inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers that are contained in sample <italic>i</italic> are colored with <italic>c<sub>i</sub></italic>. A <italic>bubble</italic> in this graph corresponds to an undirected cycle and is shown to be indicative of biological variation. <xref rid="btz350-B14" ref-type="bibr">Iqbal <italic>et al.</italic> (2012)</xref> show after constructing a colored de Bruijn graph, they can recover all genetic variants in the underlying population by traversing the graph, and finding paths with bubbles (‘bubble finding’).</p>
    <p>A bottleneck in applying Cortex (<xref rid="btz350-B14" ref-type="bibr">Iqbal <italic>et al.</italic>, 2012</xref>) to large datasets lies in the amount of memory and CPU time required to build and store the colored de Bruijn graph. Thus, <inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> (<xref rid="btz350-B17" ref-type="bibr">Muggli <italic>et al.</italic>, 2017</xref>), Rainbowfish (<xref rid="btz350-B1" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2017</xref>), Mantis (<xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2019</xref>), the method of <xref rid="btz350-B15" ref-type="bibr">Karasikov <italic>et al.</italic> (2019)</xref>, as well as others, sought to overcome this limitation by building and/or storing the colored de Bruijn graphs in a space- and time-efficient manner. <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> was one of the first methods to build the colored de Bruijn graph in a memory efficient manner. It extends the de Bruijn graph construction of <xref rid="btz350-B3" ref-type="bibr">Bowe <italic>et al.</italic> (2012)</xref>. Rainbowfish (<xref rid="btz350-B1" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2017</xref>) was later developed. It uses <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> to build the colored de Bruijn graph, which it further compresses by storing identical rows in the <inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> color matrix as a single row. Cortex, <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> and Rainbowfish have bubble-calling methods that allow genetic variation between the datasets to be detected.</p>
    <p>Mantis (<xref rid="btz350-B20" ref-type="bibr">Pandey <italic>et al.</italic>, 2018</xref>) improves on <inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> and Rainbowfish by constructing a different data structure which is not reliant on <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>. Most recently, the method of <xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic> (2019)</xref> was presented, which is referred to as an minimum spanning tree-based color-class representation. This method first uses Mantis to build the colored de Bruijn graph, which it then compresses by building minimum spanning trees of the underlying graph and storing only deltas between similar vectors. Both Mantis and the method of <xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic> (2019)</xref> do not have bubble-calling procedures. We note there exists more colored de Bruijn graph construction algorithms, and give a comprehensive review in the next section.</p>
    <p>Unfortunately, there does not exist a method to build the colored de Bruijn graph in a manner that is scalable to large datasets and allows for the addition of new data. This is important since one of the original purposes of the colored de Bruijn graph was to analyze population-level datasets—such as GenomeTrakr and 100 000 Genomes Project—which continually grow in size due to the addition of new data. Existing colored de Bruijn graph methods either cannot scale well enough to construct their data structure for large datasets or cannot update the data structure without complete reconstruction. For example, <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> (<xref rid="btz350-B17" ref-type="bibr">Muggli <italic>et al.</italic>, 2017</xref>), Rainbowfish (<xref rid="btz350-B1" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2017</xref>), Mantis (<xref rid="btz350-B20" ref-type="bibr">Pandey <italic>et al.</italic>, 2018</xref>) and the method of <xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic> (2019)</xref> are efficient with respect to memory and time but cannot be updated without reconstructing the entire colored de Bruijn graph. Bloom Filter Trie (<xref rid="btz350-B12" ref-type="bibr">Holley <italic>et al.</italic>, 2016</xref>) and the method of <xref rid="btz350-B15" ref-type="bibr">Karasikov <italic>et al.</italic> (2019)</xref> allow for the addition of new data but cannot scale to large datasets, as we show in this article. <xref rid="btz350-B9" ref-type="bibr">Crawford <italic>et al.</italic> (2018)</xref> build a de Bruijn graph that can be updated but restrict interest to the traditional (non-colored) de Bruijn graph.</p>
    <p>Here, we focus on scalable construction of the colored de Bruijn graph in a manner that allows new data to be added without reconstruction. One way to achieve this construction is to devise a divide-and-conquer approach which will divide the dataset into smaller sets, construct a succinct colored de Bruijn graph for each smaller set, and merge these succinct colored de Bruijn graphs into progressively larger graphs until a single one remains. The problem of merging succinct colored de Bruijn graphs efficiently is a challenging problem but necessary to solve since it avoids memory, disk and time overhead. This divide-and-conquer approach also allows the graph to be updated. Given an additional dataset, a compressed colored de Bruijn graph can be constructed for it, and then merged into the existing (larger) compressed colored de Bruijn graph.</p>
    <sec>
      <title>1.2 Our contributions</title>
      <p>We present <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> which constructs a colored de Bruijn graph for large datasets in a manner that allows new data to be added efficiently. As suggested earlier, <inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> builds through a process of dividing the data into smaller sets, building the colored de Bruijn graph in a RAM-efficient manner for each smaller set and merging the resulting colored de Bruijn graphs. Each of the colored de Bruijn graphs is stored using the FM-index in the same manner as <inline-formula id="IE23"><mml:math id="IM23"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> (<xref rid="btz350-B17" ref-type="bibr">Muggli <italic>et al.</italic>, 2017</xref>). Thus, the algorithmic challenge that we tackle is merging the graphs in a manner that keeps them in their compressed format throughout the merging process—rather than decompressing, merging and compressing, which would be impractical with respect to disk and memory usage.</p>
      <p>We verify the correctness of our approach and the accompanied bubble-calling algorithm by showing the colored de Bruijn graph built via merging is bit-for-bit identical to standard construction, and successfully identifies all bubbles in the merged graph. Next, we demonstrate that <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> improves construction scalability over <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>, reducing the running time by a third and the working space three-fold by comparing the peak disk and memory required to build the colored de Bruijn graph for 8000 Salmonella strains using <inline-formula id="IE26"><mml:math id="IM26"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE27"><mml:math id="IM27"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula>.</p>
      <p>Next, we use <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> to build a colored de Bruijn graph for 16 000 strains of Salmonella. This construction required 254 GB of RAM, 2.34 TB of external memory, and ∼140 h of CPU time. To contextualize these results, we compare the construction of <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> with those of state-of-the-art methods, including <inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> (<xref rid="btz350-B17" ref-type="bibr">Muggli <italic>et al.</italic>, 2017</xref>)/Rainbowfish (<xref rid="btz350-B1" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2017</xref>), Bloom Filter Trie (<xref rid="btz350-B12" ref-type="bibr">Holley <italic>et al.</italic>, 2016</xref>), Mantis (<xref rid="btz350-B20" ref-type="bibr">Pandey <italic>et al.</italic>, 2018</xref>)/the method of <xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic> (2019)</xref> and the method of <xref rid="btz350-B15" ref-type="bibr">Karasikov <italic>et al.</italic> (2019)</xref>, on datasets consisting of 4000, 8000 and 16 000 strains. Further, we demonstrate the ability of the graph to be updated efficiently through <inline-formula id="IE31"><mml:math id="IM31"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> by showing a Salmonella strain can be added to the graph in an order of magnitude faster than its initial construction. These results demonstrate that <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> is the only method that is capable of building the colored de Bruijn graph for 16 000 strains in a manner where new data can be added. Mantis was the only other method that was capable of building the colored de Bruijn graph for 16 000 strains, yet it is unable to update the graph without reconstruction. Although the authors suggest a dynamic update strategy in future work, no implementation is available. In addition, we note that <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> has several practical advantages over Mantis—it has a bubble-calling implementation which allows variants to be detected from the graph and is capable of constructing the graph for any value of <italic>k</italic> up to 64. All other methods were not scalable to 16 000 and thus, were unable to complete construction in 150 h and using at most 4 TB of disk space and 750 GB of memory.</p>
    </sec>
  </sec>
  <sec>
    <title>2 Related works</title>
    <sec>
      <title>2.1 Efficient de Bruijn graphs</title>
      <p>Space-efficient representations of de Bruijn graphs have been heavily researched in recent years. One of the first approaches was introduced with the creation of the ABySS assembler, which stores the graph as a distributed hash table (<xref rid="btz350-B22" ref-type="bibr">Simpson <italic>et al.</italic>, 2009</xref>). <xref rid="btz350-B8" ref-type="bibr">Conway and Bromage (2011)</xref> reduced these space requirements by using a sparse bit vector representation, which is due <xref rid="btz350-B19" ref-type="bibr">Okanohara and Sadakane (2007)</xref>, to represent the edges in the graph, and using rank and select operations (to be described shortly) to traverse the edges. Minia (<xref rid="btz350-B6" ref-type="bibr">Chikhi and Rizk, 2013</xref>) use a Bloom filter to store the edges, which requires the graph to be traversed by generating all possible outgoing edges at each node and testing their membership in the Bloom filter. <xref rid="btz350-B3" ref-type="bibr">Bowe <italic>et al.</italic> (2012)</xref> develop a succinct data structure based on the Burrows–Wheeler transform (BWT). This data structure is combined with ideas from IDBA-UD (<xref rid="btz350-B21" ref-type="bibr">Peng <italic>et al.</italic>, 2012</xref>) in order to create MEGAHIT (<xref rid="btz350-B16" ref-type="bibr">Li <italic>et al.</italic>, 2015</xref>). <xref rid="btz350-B7" ref-type="bibr">Chikhi <italic>et al.</italic> (2014)</xref> describe a space-efficient data structure that combines the use of the FM-index and minimizers.</p>
    </sec>
    <sec>
      <title>2.2 Efficient colored de Bruijn graphs</title>
      <p>As previously mentioned, <inline-formula id="IE34"><mml:math id="IM34"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> (<xref rid="btz350-B17" ref-type="bibr">Muggli <italic>et al.</italic>, 2017</xref>) and Rainbowfish (<xref rid="btz350-B1" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2017</xref>) are both space-efficient data structures for storing the colored de Bruijn graph which each use the structure of (<xref rid="btz350-B3" ref-type="bibr">Bowe <italic>et al.</italic>, 2012</xref>). <xref rid="btz350-B17" ref-type="bibr">Muggli <italic>et al.</italic> (2017)</xref> build the compressed color matrix by compressing each row using Elias-Fano encoding. Rainbowfish (<xref rid="btz350-B1" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2017</xref>) takes as input the color matrix of <inline-formula id="IE35"><mml:math id="IM35"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> and compress it by decomposing the matrix into ‘color sets’ based on an equivalence relation and compresses each color set individually. Thus, this method relies on the construction of <inline-formula id="IE36"><mml:math id="IM36"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> prior to building the sets of compatible colors. <xref rid="btz350-B12" ref-type="bibr">Holley <italic>et al.</italic> (2016)</xref> introduced the Bloom Filter Trie, which is another succinct data structure for the colored de Bruijn graph. It encodes frequently occurring sets of colors separate from the graph and stores a reference to the set if the reference takes fewer bits than the set itself. This data structure allows incremental updates of the underlying graph. More recently, Mantis (<xref rid="btz350-B20" ref-type="bibr">Pandey <italic>et al.</italic>, 2018</xref>) and its extension (<xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2019</xref>) improve upon <inline-formula id="IE37"><mml:math id="IM37"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> and Rainbowfish. They build a compressed colored de Bruijn graph by building sets of compatible colors (similar to Rainbowfish) but construct the compressed graph directly rather than constructing it from <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>. Lastly, the most recent method of <xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic> (2019)</xref> constructs the colored de Bruijn graph using Mantis, which it further compresses by careful reconstruction and compression of the color matrix.</p>
      <p>Lastly, there are a couple of methods that construct the color matrix in a manner that is both compressed and dynamic, which include the method of <xref rid="btz350-B18" ref-type="bibr">Mustafa <italic>et al.</italic> (2019)</xref> and Multi-BRWT (<xref rid="btz350-B15" ref-type="bibr">Karasikov <italic>et al.</italic>, 2019</xref>). These methods use a simple representation of a de Bruijn graph where each edge (the <italic>k</italic>-mer) is stored in a hash table. This graph representation allows it to be updated along with the color matrix—thus, the main contribution is not the data structure used to store the graph but that used to store the color matrix.</p>
    </sec>
    <sec>
      <title>2.3 Other related compressed data structures</title>
      <p>Some related compressed data structures are SeqOthello (<xref rid="btz350-B30" ref-type="bibr">Yu <italic>et al.</italic>, 2018</xref>), SBT (<xref rid="btz350-B24" ref-type="bibr">Solomon and Kingsford, 2016</xref>), Split-SBT (<xref rid="btz350-B25" ref-type="bibr">Solomon and Kingsford, 2018</xref>) and Allsome-SBT (<xref rid="btz350-B27" ref-type="bibr">Sun <italic>et al.</italic>, 2017</xref>). These methods index all <italic>k</italic>-mers or variants of <italic>k</italic>-mer indexes but do not provide graph information. For this reason, they are frequently applied to querying large collections of RNA-seq data but not genome assembly. Another indexing method is BIGSI (<xref rid="btz350-B4" ref-type="bibr">Bradley <italic>et al.</italic>, 2017</xref>), which provides graph features and can be viewed as a probabilistic colored de Bruijn graph.</p>
      <p>Two other approaches are worthy of note because they merge the BWT of a set of strings. BWT-Merge (<xref rid="btz350-B23" ref-type="bibr">Sirén, 2016</xref>) is related to our work since the data structure we construct and store is similar to BWT. BWT-Merge merges two strings stored using BWT by using a reverse trie of one BWT to generate queries that are then located in the other BWT using FM-index backward search. The reverse trie allows the common suffixes across multiple merge elements to share the results of a single backward search step. Thus, BWT-Merge finds the final rank of each full suffix completely, one suffix at a time. Finally, MSBWT (<xref rid="btz350-B13" ref-type="bibr">Holt and McMillan, 2014</xref>) is a method which merges the BWTs of multiple strings in a method similar to our own except applied to strings instead of graphs. Lastly, <xref rid="btz350-B10" ref-type="bibr">Egidi <italic>et al.</italic> (2019)</xref> recently improved upon the algorithm in this article. Their algorithm has the same asymptotic cost as the method presented here but is more space-efficient.</p>
      <p>In Section 5, we compared the performance of <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> against <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> (<xref rid="btz350-B17" ref-type="bibr">Muggli <italic>et al.</italic>, 2017</xref>)/Rainbowfish (<xref rid="btz350-B1" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2017</xref>), Bloom Filter Trie (<xref rid="btz350-B12" ref-type="bibr">Holley <italic>et al.</italic>, 2016</xref>), Multi-BRWT (<xref rid="btz350-B15" ref-type="bibr">Karasikov <italic>et al.</italic>, 2019</xref>) and Mantis (<xref rid="btz350-B20" ref-type="bibr">Pandey <italic>et al.</italic>, 2018</xref>)/the method of <xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic> (2019)</xref>. Among all mentioned methods in this section, we chose these tools based on the following criteria: the method should be both graph-based and non-probabilistic (exact) for a fair comparison.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Preliminaries</title>
    <p>As previously mentioned, <inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> (<xref rid="btz350-B17" ref-type="bibr">Muggli <italic>et al.</italic>, 2017</xref>) represents the colored de Bruijn graph using BWT and <inline-formula id="IE42"><mml:math id="IM42"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> efficiently merges de Bruijn graphs that are represented in this manner. Here, we first define some basic notation and definitions concerning BWT, then show how the colored de Bruijn graph can be stored using BWT.</p>
    <sec>
      <title>3.1 Basic definitions and terminology</title>
      <p>Here, we begin with some basic definitions related to our representation. Throughout we consider a string <inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>…</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> symbols drawn from the alphabet <inline-formula id="IE45"><mml:math id="IM45"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0..</mml:mn><mml:mo>σ</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. For <inline-formula id="IE46"><mml:math id="IM46"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> we write <inline-formula id="IE47"><mml:math id="IM47"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mn>..</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to denote the <italic>suffix</italic> of <inline-formula id="IE48"><mml:math id="IM48"><mml:mi>X</mml:mi></mml:math></inline-formula> length <inline-formula id="IE49"><mml:math id="IM49"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, that is <inline-formula id="IE50"><mml:math id="IM50"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mn>..</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>…</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Similarly, we write <inline-formula id="IE51"><mml:math id="IM51"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to denote the <italic>prefix</italic> of <inline-formula id="IE52"><mml:math id="IM52"><mml:mi>X</mml:mi></mml:math></inline-formula> length <italic>i</italic>. <inline-formula id="IE53"><mml:math id="IM53"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mn>..</mml:mn><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the <italic>substring</italic><inline-formula id="IE54"><mml:math id="IM54"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>…</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE55"><mml:math id="IM55"><mml:mi>X</mml:mi></mml:math></inline-formula> that starts at position <italic>i</italic> and ends at <italic>j</italic>.</p>
      <p>The suffix array <inline-formula id="IE56"><mml:math id="IM56"><mml:mrow><mml:mi>S</mml:mi><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of input text <inline-formula id="IE57"><mml:math id="IM57"><mml:mi>X</mml:mi></mml:math></inline-formula> is an array <inline-formula id="IE58"><mml:math id="IM58"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of length <italic>n</italic> that contains a permutation of the integers <inline-formula id="IE59"><mml:math id="IM59"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE60"><mml:math id="IM60"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mn>..</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≺</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mn>..</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≺</mml:mo><mml:mo>⋯</mml:mo><mml:mo>≺</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mn>..</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE61"><mml:math id="IM61"><mml:mo>≺</mml:mo></mml:math></inline-formula> denotes lexicographic precedence. Next, for a string <inline-formula id="IE62"><mml:math id="IM62"><mml:mi>Y</mml:mi></mml:math></inline-formula>, we refer to the <inline-formula id="IE63"><mml:math id="IM63"><mml:mi>Y</mml:mi></mml:math></inline-formula>-interval in the suffix array <inline-formula id="IE64"><mml:math id="IM64"><mml:mrow><mml:mi>S</mml:mi><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>X</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as the interval <inline-formula id="IE65"><mml:math id="IM65"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>s</mml:mi><mml:mn>..</mml:mn><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> that contains all suffixes having <inline-formula id="IE66"><mml:math id="IM66"><mml:mi>Y</mml:mi></mml:math></inline-formula> as a prefix. For a character <italic>c</italic> and a string <inline-formula id="IE67"><mml:math id="IM67"><mml:mi>Y</mml:mi></mml:math></inline-formula>, the computation of <inline-formula id="IE68"><mml:math id="IM68"><mml:mrow><mml:mi mathvariant="italic">cY</mml:mi></mml:mrow></mml:math></inline-formula>-interval from <inline-formula id="IE69"><mml:math id="IM69"><mml:mi>Y</mml:mi></mml:math></inline-formula>-interval is called the <italic>left extension</italic>.</p>
      <sec>
        <title>3.1.1 BWT and FM-index</title>
        <p>For a string <inline-formula id="IE70"><mml:math id="IM70"><mml:mi>Y</mml:mi></mml:math></inline-formula>, we denote <inline-formula id="IE71"><mml:math id="IM71"><mml:mi>A</mml:mi></mml:math></inline-formula> as the list of <inline-formula id="IE72"><mml:math id="IM72"><mml:mi>Y</mml:mi></mml:math></inline-formula>’s characters sorted lexicographically by the suffixes starting at those characters. Further, we denote <inline-formula id="IE73"><mml:math id="IM73"><mml:mi>B</mml:mi></mml:math></inline-formula> be the list of <inline-formula id="IE74"><mml:math id="IM74"><mml:mi>Y</mml:mi></mml:math></inline-formula>’s characters sorted lexicographically by the suffixes starting immediately after those characters. Thus, if <inline-formula id="IE75"><mml:math id="IM75"><mml:mrow><mml:mi>Y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> then <inline-formula id="IE76"><mml:math id="IM76"><mml:mrow><mml:mi>Y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE77"><mml:math id="IM77"><mml:mrow><mml:mi>Y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> have the same relative order in both lists. This implies that if <inline-formula id="IE78"><mml:math id="IM78"><mml:mrow><mml:mi>Y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is in position <italic>p</italic> in <inline-formula id="IE79"><mml:math id="IM79"><mml:mi>B</mml:mi></mml:math></inline-formula> then in <inline-formula id="IE80"><mml:math id="IM80"><mml:mi>A</mml:mi></mml:math></inline-formula> it is in position
<disp-formula id="E1"><mml:math id="M1"><mml:mrow><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo> </mml:mo><mml:mo>:</mml:mo><mml:mo> </mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≺</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo> </mml:mo><mml:mo>:</mml:mo><mml:mo> </mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>h</mml:mi><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>We note that the last character in <inline-formula id="IE81"><mml:math id="IM81"><mml:mi>Y</mml:mi></mml:math></inline-formula> always appears first in <inline-formula id="IE82"><mml:math id="IM82"><mml:mi>B</mml:mi></mml:math></inline-formula>. It follows that we can recover <inline-formula id="IE83"><mml:math id="IM83"><mml:mi>Y</mml:mi></mml:math></inline-formula> from <inline-formula id="IE84"><mml:math id="IM84"><mml:mi>B</mml:mi></mml:math></inline-formula>, which is the principle of BWT (<xref rid="btz350-B5" ref-type="bibr">Burrows and Wheeler, 1994</xref>).</p>
        <p><xref rid="btz350-B11" ref-type="bibr">Ferragina and Manzini (2005)</xref> showed BWT can be used for indexing as follows. Here, we denote <inline-formula id="IE85"><mml:math id="IM85"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the BWT array computed for <inline-formula id="IE86"><mml:math id="IM86"><mml:mi>Y</mml:mi></mml:math></inline-formula>. Hence, if we know the range <inline-formula id="IE87"><mml:math id="IM87"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mn>..</mml:mn><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> occupied by characters immediately preceding occurrences of a pattern <italic>P</italic> in <inline-formula id="IE88"><mml:math id="IM88"><mml:mi>Y</mml:mi></mml:math></inline-formula>, then we can compute the range <inline-formula id="IE89"><mml:math id="IM89"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mn>..</mml:mn><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> occupied by characters immediately preceding occurrences of <inline-formula id="IE90"><mml:math id="IM90"><mml:mrow><mml:mi mathvariant="italic">cP</mml:mi></mml:mrow></mml:math></inline-formula> in <inline-formula id="IE91"><mml:math id="IM91"><mml:mi>Y</mml:mi></mml:math></inline-formula>, for any character <italic>c</italic>, since
<disp-formula id="E2"><mml:math id="M2"><mml:mtable><mml:mtr><mml:mtd><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo> </mml:mo><mml:mo>:</mml:mo><mml:mo> </mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≺</mml:mo><mml:mi>c</mml:mi><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo> </mml:mo><mml:mo>:</mml:mo><mml:mo> </mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>}</mml:mo><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo> </mml:mo><mml:mo>:</mml:mo><mml:mo> </mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≺</mml:mo><mml:mi>c</mml:mi><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo> </mml:mo><mml:mo>:</mml:mo><mml:mo> </mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
        <p>As can be seen above: <inline-formula id="IE92"><mml:math id="IM92"><mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> is the number of occurrences of <inline-formula id="IE93"><mml:math id="IM93"><mml:mrow><mml:mi mathvariant="italic">cP</mml:mi></mml:mrow></mml:math></inline-formula>. To recap, the FM-index for <inline-formula id="IE94"><mml:math id="IM94"><mml:mi>Y</mml:mi></mml:math></inline-formula> requires: (i) an array that stores <inline-formula id="IE95"><mml:math id="IM95"><mml:mrow><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo> </mml:mo><mml:mo>:</mml:mo><mml:mo> </mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≺</mml:mo><mml:mi>c</mml:mi><mml:mo>}</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> for each character <italic>c</italic> and (ii) a (rank) data structure for <inline-formula id="IE96"><mml:math id="IM96"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that returns how many times a given character occurs up to a specific position. The latter data structure is used in backward search in order to compute the left extension of a given string.</p>
      </sec>
    </sec>
    <sec>
      <title>3.2 Storage of de Bruijn graphs using the BWT</title>
      <p>We now give a brief explanation of the data structure behind <inline-formula id="IE97"><mml:math id="IM97"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>. An example of this representation is shown in <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S2</xref> in Section 7. We refer the reader to <xref rid="btz350-B17" ref-type="bibr">Muggli <italic>et al.</italic> (2017)</xref> for a full explanation.</p>
      <p>Given a de Bruijn graph <inline-formula id="IE98"><mml:math id="IM98"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we assume each edge <inline-formula id="IE99"><mml:math id="IM99"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> has a <italic>k</italic>-mer corresponding to it. We define the co-lexicographic (colex) ordering of <italic>V</italic> as the lexicographic order of their reversed <inline-formula id="IE100"><mml:math id="IM100"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers. We let <inline-formula id="IE101"><mml:math id="IM101"><mml:mi>F</mml:mi></mml:math></inline-formula> be the edges in <italic>E</italic> in colex order by their ending nodes, where ties are broken by their starting nodes, and let <inline-formula id="IE102"><mml:math id="IM102"><mml:mi>L</mml:mi></mml:math></inline-formula> be the edges in <italic>E</italic> sorted colex by their starting nodes, with ties broken by their ending nodes. We define <inline-formula id="IE103"><mml:math id="IM103"><mml:mrow><mml:mi mathvariant="italic">label</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as a function that takes in an edge <inline-formula id="IE104"><mml:math id="IM104"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> and returns the final symbol of the <italic>k</italic>-mer corresponding to it.</p>
      <p>If we are given two edges <italic>e</italic> and <inline-formula id="IE105"><mml:math id="IM105"><mml:mrow><mml:mi>e</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> that have the same label then they have the same relative order in both <inline-formula id="IE106"><mml:math id="IM106"><mml:mi>F</mml:mi></mml:math></inline-formula> and <inline-formula id="IE107"><mml:math id="IM107"><mml:mi>L</mml:mi></mml:math></inline-formula>; otherwise, their relative order in <inline-formula id="IE108"><mml:math id="IM108"><mml:mi>F</mml:mi></mml:math></inline-formula> is the same as their labels’ lexicographic order. This means that if <italic>e</italic> is in position <italic>p</italic> in <inline-formula id="IE109"><mml:math id="IM109"><mml:mi>L</mml:mi></mml:math></inline-formula>, then in <inline-formula id="IE110"><mml:math id="IM110"><mml:mi>F</mml:mi></mml:math></inline-formula> it is in position
<disp-formula id="E3"><mml:math id="M3"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>d</mml:mi><mml:mo>:</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mi>d</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="italic">label</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≺</mml:mo><mml:mi mathvariant="italic">label</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>h</mml:mi><mml:mo>:</mml:mo><mml:mi mathvariant="italic">label</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="italic">label</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>h</mml:mi><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1.</mml:mn><mml:mo> </mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>We let <inline-formula id="IE111"><mml:math id="IM111"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the sequence of edge labels given the ordering of the edges in <inline-formula id="IE112"><mml:math id="IM112"><mml:mi>L</mml:mi></mml:math></inline-formula>. Thus, we let <inline-formula id="IE113"><mml:math id="IM113"><mml:mrow><mml:mi mathvariant="italic">label</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be equal to <inline-formula id="IE114"><mml:math id="IM114"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for all <italic>h</italic>. We let <inline-formula id="IE115"><mml:math id="IM115"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the bit vector with a 1 marking the position in <inline-formula id="IE116"><mml:math id="IM116"><mml:mi>F</mml:mi></mml:math></inline-formula> of the last incoming edge of each node, and let <inline-formula id="IE117"><mml:math id="IM117"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>L</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the bit vector with a 1 marking the position in <inline-formula id="IE118"><mml:math id="IM118"><mml:mi>L</mml:mi></mml:math></inline-formula> of the last outgoing edge of each node. Therefore, given a character <italic>c</italic> and the index of a node <italic>v</italic> (we note that there is no explicit stored set of nodes. Hence, we refer to the “node index” as the position among all nodes if sorted in colex order), we can use <inline-formula id="IE119"><mml:math id="IM119"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>L</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to find the interval in <inline-formula id="IE120"><mml:math id="IM120"><mml:mi>L</mml:mi></mml:math></inline-formula> containing <italic>v’</italic>s outgoing edges and search in <inline-formula id="IE121"><mml:math id="IM121"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to find the position of edge <italic>e</italic> labeled <italic>c</italic>. Similarly, we can find all incoming edges of a node <italic>v</italic> using their position in <inline-formula id="IE122"><mml:math id="IM122"><mml:mi>F</mml:mi></mml:math></inline-formula> and <inline-formula id="IE123"><mml:math id="IM123"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <p>We annotate each bit of <inline-formula id="IE124"><mml:math id="IM124"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to the corresponding symbols in <inline-formula id="IE125"><mml:math id="IM125"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We let <inline-formula id="IE126"><mml:math id="IM126"><mml:mrow><mml:mi mathvariant="italic">flags</mml:mi></mml:mrow></mml:math></inline-formula> be a bit array of such annotation bits. In practice, we store <inline-formula id="IE127"><mml:math id="IM127"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>L</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE128"><mml:math id="IM128"><mml:mrow><mml:mi mathvariant="italic">flags</mml:mi></mml:mrow></mml:math></inline-formula> (rather than <inline-formula id="IE129"><mml:math id="IM129"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) to store the de Bruijn graph but limit our discussion to the construction that uses <inline-formula id="IE130"><mml:math id="IM130"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for ease of explanation. We refer the reader to <xref rid="btz350-B3" ref-type="bibr">Bowe <italic>et al.</italic> (2012)</xref> for a full explanation of <inline-formula id="IE131"><mml:math id="IM131"><mml:mrow><mml:mi mathvariant="italic">flags</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p>We note that an important aspect of this succinct representation of the graph is that the <inline-formula id="IE132"><mml:math id="IM132"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mers (nodes) and <italic>k</italic>-mers (edges) of the de Bruijn graph <italic>G</italic> are not explicitly stored in the above representation—rather they than can be <italic>computed</italic> from this representation. We can efficiently traverse the graph in a forward or reverse manner and recover incoming and outgoing edges of a given node <italic>v</italic>. Therefore, given a node <italic>v</italic> identified by its index, we can recover the <inline-formula id="IE133"><mml:math id="IM133"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer corresponding to <italic>v</italic> by traversing the graph in a backward direction <inline-formula id="IE134"><mml:math id="IM134"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> times starting from <italic>v</italic>. See <xref ref-type="supplementary-material" rid="sup1">Supplementary</xref> Section 8 for more details. This also illustrates the necessity of adding extra nodes and edges to the graph, which we refer to as <italic>dummy</italic> nodes and edges. In order to ensure there is a directed path of length at least <inline-formula id="IE135"><mml:math id="IM135"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to each original node, we augment the graph with additional nodes (and edges) so that each new node has a <inline-formula id="IE136"><mml:math id="IM136"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-mer that is prefixed by one or more copies of a special symbol <inline-formula id="IE137"><mml:math id="IM137"><mml:mo>$</mml:mo></mml:math></inline-formula> not in the alphabet and lexicographically strictly less than all others. When new nodes are added, we are assured that the node corresponding to <inline-formula id="IE138"><mml:math id="IM138"><mml:mrow><mml:msup><mml:mrow><mml:mo>$</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is always first in colex order and has no incoming edges. Lastly, we augment the graph in a similar manner by adding extra outgoing edges, whose <inline-formula id="IE139"><mml:math id="IM139"><mml:mi>k</mml:mi></mml:math></inline-formula>-mer ends in <inline-formula id="IE140"><mml:math id="IM140"><mml:mo>$</mml:mo></mml:math></inline-formula>, doing so for each original node with no outgoing edge.</p>
      <sec>
        <title>3.2.1 Storage of colors</title>
        <p>Given a multiset <inline-formula id="IE141"><mml:math id="IM141"><mml:mrow><mml:mi mathvariant="script">G</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of individual de Bruijn graphs, we set <italic>G</italic> to be the union of those individual graphs and build the previously-described representation for <italic>G</italic>. We also build and store a 2D binary array <inline-formula id="IE142"><mml:math id="IM142"><mml:mi>C</mml:mi></mml:math></inline-formula> in which <inline-formula id="IE143"><mml:math id="IM143"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> indicates whether the <italic>i</italic>th edge in <italic>G</italic> is present in the <italic>j</italic>th individual de Bruijn graph.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>4 Methods</title>
    <p>In this section, we begin by describing a naive merge algorithm, which will motivate the necessity of the succinct algorithm. In the description of both algorithms, we describe how to merge two-colored de Bruijn graphs but note that it generalizes to an arbitrary number of graphs. Hence, we assume that we have two de Bruijn graphs <inline-formula id="IE144"><mml:math id="IM144"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE145"><mml:math id="IM145"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as input, which are stored as <inline-formula id="IE146"><mml:math id="IM146"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE147"><mml:math id="IM147"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> as well as <inline-formula id="IE148"><mml:math id="IM148"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE149"><mml:math id="IM149"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, respectively. And we output the merged graph <inline-formula id="IE150"><mml:math id="IM150"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as <inline-formula id="IE151"><mml:math id="IM151"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">LM</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">FM</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE152"><mml:math id="IM152"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. An illustration of <italic>G</italic><sub>1</sub>, <italic>G</italic><sub>2</sub>, <italic>G<sub>M</sub></italic> and the corresponding data structures is given in <xref ref-type="fig" rid="btz350-F1">Figure 1</xref>.
</p>
    <fig id="btz350-F1" orientation="portrait" position="float">
      <label>Fig. 1.</label>
      <caption>
        <p>(<bold>a</bold>) A colored de Bruijn graph consisting of two individual graphs, whose edges are shown in red and blue. The nodes are shown in purple because they can occur in either graph. (<bold>b</bold>) A second colored de Bruijn graph, whose edges are green and yellow. Again, the nodes are shown in lime because they can occur in either graph. (<bold>c</bold>) A colored de Bruijn graph merged from the two-colored de Bruijn graphs. (<bold>d</bold>) The nodes for all three graphs arranged in columns (red and blue, merged, green and yellow). Each column is sorted into co-lexicographic order, with each node’s number of incoming edges shown on its left and the labels of its outgoing edges shown on its right. Vertical alignment illustrates how the merged components (center) are copied from either the left, the right or both</p>
      </caption>
      <graphic xlink:href="btz350f1"/>
    </fig>
    <sec>
      <title>4.1 A naive merge algorithm</title>
      <p>We recall from Section 3 that the edges (<italic>k</italic>-mers) of <italic>G</italic><sub>1</sub> and <italic>G</italic><sub>2</sub> can be computed from the succinct representation. We denote these <italic>k</italic>-mers for <italic>G</italic><sub>1</sub>, <italic>G</italic><sub>2</sub> as <inline-formula id="IE153"><mml:math id="IM153"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE154"><mml:math id="IM154"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, respectively. For example, if we want to reconstruct the <italic>k</italic>-mer <monospace>AGAGAGTTA</monospace> contained in <italic>G</italic><sub>1</sub> which is stored as <monospace>A</monospace> in <inline-formula id="IE155"><mml:math id="IM155"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we need to backward navigate in <italic>G</italic><sub>1</sub> from the edge labeled <monospace>A</monospace> through <italic>k</italic> – 1 predecessor edges (<monospace>T, T, G</monospace>,…), and concatenate the abbreviated characters encountered during this backward navigation in reverse order. Thus, a naive merging algorithm would reconstruct <inline-formula id="IE156"><mml:math id="IM156"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE157"><mml:math id="IM157"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> then merge them, which can be trivially given they are in sorted (colex) order. This algorithm requires explicitly building <inline-formula id="IE158"><mml:math id="IM158"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, and the merged list. Thus, it has a significant memory footprint. See <xref ref-type="supplementary-material" rid="sup1">Supplementary</xref> Algorithm S3 in Section 9 for the details of this naive merge algorithm.</p>
    </sec>
    <sec>
      <title>4.2 The succinct merge algorithm</title>
      <p>Before we give a detailed explanation of our succinct merge algorithm, we consider the problem of merging two sorted lists of strings with the constraint that we can only examine a single character from each string at a time. We can solve this problem with a divide and conquer approach. First, we group all the strings in each list by their first character. This partially solves the problem, as we know all the strings in the first group from each list must occur in the output before all the strings in the second group in each list and so on. Thus, the problem is now reduced to merging the strings in the first group, followed by merging the strings in the second group and so on. Each of these merges can be addressed by again grouping the elements (i.e. subgroups of the initial groups) by examining the second character of each string. We can apply this step recursively until all characters of each string have been examined. We now draw the reader’s attention to the fact that our succinct colored de Bruijn graph representation is a space-efficient representation of the list of sorted <italic>k</italic>-mers.</p>
      <sec>
        <title>4.2.1 Overview of the algorithm</title>
        <p>We now return to the problem of merging succinct colored de Bruijn graphs. The algorithm consists of two steps: (i) a planning step which plans the merge and (ii) an executing step which executes the merge. Thus, the planning step outputs a <italic>merge plan</italic>, which consists of lists of non-overlapping intervals for <inline-formula id="IE159"><mml:math id="IM159"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE160"><mml:math id="IM160"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. These lists detail how to construct the data structure for the merged graph from the succinct data structures for <italic>G</italic><sub>1</sub> and <italic>G</italic><sub>2</sub>.</p>
        <p>We refer to <inline-formula id="IE161"><mml:math id="IM161"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE162"><mml:math id="IM162"><mml:mi>C</mml:mi></mml:math></inline-formula> as the <italic>primary components</italic> of the data structure and <inline-formula id="IE163"><mml:math id="IM163"><mml:mrow><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <italic>B<sub>L</sub></italic> as <italic>secondary components</italic>. We describe how to merge the primary components, and leave the details of how to merge the secondary components to <xref ref-type="supplementary-material" rid="sup1">Supplementary</xref> Section 12.</p>
      </sec>
      <sec>
        <title>4.2.2 The planning step</title>
        <p>Formally, we denote the merge plan as <inline-formula id="IE164"><mml:math id="IM164"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mn>1</mml:mn></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where each <inline-formula id="IE165"><mml:math id="IM165"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mn>1</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> is an index in <inline-formula id="IE166"><mml:math id="IM166"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE167"><mml:math id="IM167"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where each <inline-formula id="IE168"><mml:math id="IM168"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> is an index in <inline-formula id="IE169"><mml:math id="IM169"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. An overview of the planning step is given in Algorithm 1. We first initialize <italic>P</italic><sub>1</sub> and <italic>P</italic><sub>2</sub> to be single intervals covering <inline-formula id="IE170"><mml:math id="IM170"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE171"><mml:math id="IM171"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, respectively (e.g. <inline-formula id="IE172"><mml:math id="IM172"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE173"><mml:math id="IM173"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>). Next, we revise <italic>P</italic><sub>1</sub> and <italic>P</italic><sub>2</sub> in an iterative manner <italic>k</italic> times (where <italic>k</italic> corresponds to the <italic>k</italic>-mer value). At each iteration of the algorithm, a single character of the strings in <inline-formula id="IE174"><mml:math id="IM174"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE175"><mml:math id="IM175"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is processed, and the merge plan is revised. Thus, in order to fully describe the planning stage, we define (i) how the characters of <inline-formula id="IE176"><mml:math id="IM176"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE177"><mml:math id="IM177"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> are computed, and (ii) how <italic>P</italic><sub>1</sub> and <italic>P</italic><sub>2</sub> are revised based on these characters. An illustration of the merge plans is given in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S3</xref> in Section 10.</p>
        <p>
          <boxed-text id="btz350-BOX1" position="float" orientation="portrait">
            <sec>
              <title>Algorithm 1 . The planning step to merge <italic>G</italic><sub>1</sub> and <italic>G</italic><sub>2</sub>.</title>
              <p>
                <inline-formula id="IE178">
                  <mml:math id="IM178">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>P</mml:mi>
                        </mml:mrow>
                        <mml:mn>1</mml:mn>
                      </mml:msub>
                      <mml:mo>←</mml:mo>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mn>1</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mi mathvariant="italic">EBWT</mml:mi>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>G</mml:mi>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                        <mml:mn>1</mml:mn>
                      </mml:msub>
                      <mml:mo>|</mml:mo>
                      <mml:mo stretchy="false">]</mml:mo>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </p>
              <p>
                <inline-formula id="IE179">
                  <mml:math id="IM179">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>P</mml:mi>
                        </mml:mrow>
                        <mml:mn>2</mml:mn>
                      </mml:msub>
                      <mml:mo>←</mml:mo>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mn>1</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mi mathvariant="italic">EBWT</mml:mi>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>G</mml:mi>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                        <mml:mn>2</mml:mn>
                      </mml:msub>
                      <mml:mo>|</mml:mo>
                      <mml:mo stretchy="false">]</mml:mo>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </p>
              <p>
                <inline-formula id="IE180">
                  <mml:math id="IM180">
                    <mml:mrow>
                      <mml:mi mathvariant="italic">Co</mml:mi>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>l</mml:mi>
                        </mml:mrow>
                        <mml:mn>1</mml:mn>
                      </mml:msub>
                      <mml:mo>←</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mo stretchy="false">]</mml:mo>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </p>
              <p>
                <inline-formula id="IE181">
                  <mml:math id="IM181">
                    <mml:mrow>
                      <mml:mi mathvariant="italic">Co</mml:mi>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>l</mml:mi>
                        </mml:mrow>
                        <mml:mn>2</mml:mn>
                      </mml:msub>
                      <mml:mo>←</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mo stretchy="false">]</mml:mo>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </p>
              <p>% Iterate through ‘edge label matrix’ columns in sort precedence order</p>
              <p>
                <bold>for all</bold>
                <inline-formula id="IE182">
                  <mml:math id="IM182">
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mo>{</mml:mo>
                      <mml:mn>1..</mml:mn>
                      <mml:mi>k</mml:mi>
                      <mml:mo>}</mml:mo>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
                <bold>do</bold>
              </p>
              <p>  <inline-formula id="IE183"><mml:math id="IM183"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>←</mml:mo><mml:mi mathvariant="italic">GetCol</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Co</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
              <p>  <inline-formula id="IE184"><mml:math id="IM184"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>←</mml:mo><mml:mi mathvariant="italic">GetCol</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Co</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
              <p>  % RefinePlan is given in Algorithm 2.</p>
              <p>  <inline-formula id="IE185"><mml:math id="IM185"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>←</mml:mo><mml:mi mathvariant="italic">RefinePlan</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Co</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Co</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
              <p>  <inline-formula id="IE186"><mml:math id="IM186"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>←</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
              <p>
                <bold>end for</bold>
              </p>
            </sec>
          </boxed-text>
        </p>
        <p><italic>Computing the next character of L<sub>1</sub> and L<sub>2</sub></italic>. Let <italic>i</italic> denote the current iteration of our revision of <italic>P</italic><sub>1</sub> and <italic>P</italic><sub>2</sub>, where <inline-formula id="IE187"><mml:math id="IM187"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. We compute the next character of <inline-formula id="IE188"><mml:math id="IM188"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE189"><mml:math id="IM189"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> using two temporary character vectors <inline-formula id="IE190"><mml:math id="IM190"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE191"><mml:math id="IM191"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, which are of length <inline-formula id="IE192"><mml:math id="IM192"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE193"><mml:math id="IM193"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. We note that the ‘next’ character is the preceding character in the <italic>k</italic>-mer since <inline-formula id="IE194"><mml:math id="IM194"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE195"><mml:math id="IM195"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> only store the last character of <inline-formula id="IE196"><mml:math id="IM196"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE197"><mml:math id="IM197"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Thus, we process the characters of <inline-formula id="IE198"><mml:math id="IM198"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE199"><mml:math id="IM199"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> from right to left. Conceptually, we define these vectors as follows: <inline-formula id="IE200"><mml:math id="IM200"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> if <italic>i </italic>&lt;<italic> k</italic> and otherwise <inline-formula id="IE201"><mml:math id="IM201"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE202"><mml:math id="IM202"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> if <italic>j </italic>&lt;<italic> k</italic>; and otherwise <inline-formula id="IE203"><mml:math id="IM203"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Yet, since we do not explicitly build or store <inline-formula id="IE204"><mml:math id="IM204"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE205"><mml:math id="IM205"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, we must compute <inline-formula id="IE206"><mml:math id="IM206"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE207"><mml:math id="IM207"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
        <p>We define the computation of <inline-formula id="IE208"><mml:math id="IM208"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> by describing the following three cases. When <inline-formula id="IE209"><mml:math id="IM209"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, we compute <inline-formula id="IE210"><mml:math id="IM210"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> by traversing <italic>G</italic><sub>1</sub> in a forward direction from the first incoming edge of every node and copying the character found at the <inline-formula id="IE211"><mml:math id="IM211"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>q</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th position of that incoming edge (again, stored in <inline-formula id="IE212"><mml:math id="IM212"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>) into <italic>q</italic>-th position of all outgoing edges of that node. When <italic>i </italic>=<italic> </italic>1, the <inline-formula id="IE213"><mml:math id="IM213"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>q</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th position corresponds to <inline-formula id="IE214"><mml:math id="IM214"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, so <inline-formula id="IE215"><mml:math id="IM215"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is used in place of <inline-formula id="IE216"><mml:math id="IM216"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> but is otherwise identical to the previous case. Lastly, when <italic>i </italic>=<italic> k</italic>, we let <inline-formula id="IE217"><mml:math id="IM217"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> equal <inline-formula id="IE218"><mml:math id="IM218"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We compute <inline-formula id="IE219"><mml:math id="IM219"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> in an analogous manner. An illustration of how to compute the next column of <inline-formula id="IE220"><mml:math id="IM220"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE221"><mml:math id="IM221"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is given in the Supplementary Section 11. Moreover, the pseudocode for <italic>GetCol</italic> is shown in Supplementary Algorithm S11.</p>
        <p><italic>Revising P<sub>1</sub> and P<sub>2</sub></italic>. We revise <italic>P</italic><sub>1</sub> and <italic>P</italic><sub>2</sub> based on <inline-formula id="IE222"><mml:math id="IM222"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE223"><mml:math id="IM223"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> at iteration <italic>i</italic> by considering each pair of intervals in <italic>P</italic><sub>1</sub> and <italic>P</italic><sub>2</sub>, i.e., <inline-formula id="IE224"><mml:math id="IM224"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE225"><mml:math id="IM225"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE226"><mml:math id="IM226"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, and partitioning each interval into at most five sub-intervals. We store the list of sub-intervals of <italic>P</italic><sub>1</sub> and <italic>P</italic><sub>2</sub> as <italic>SubP</italic><sub>1</sub> and <italic>SubP</italic><sub>2</sub>. Intuitively, we create <italic>SubP</italic><sub>1</sub> in order to divide <inline-formula id="IE227"><mml:math id="IM227"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> based on continuous ranges in <inline-formula id="IE228"><mml:math id="IM228"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> that have the same character, e.g. each continuous range of <monospace>A</monospace>’s, <monospace>C</monospace>’s, <monospace>G</monospace>’s, <monospace>T</monospace>’s or <monospace>$</monospace>’s. Similarly, <italic>SubP</italic><sub>2</sub> is used to divide <inline-formula id="IE229"><mml:math id="IM229"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. We divide <italic>P</italic><sub>1</sub> by first computing the subvector of <inline-formula id="IE230"><mml:math id="IM230"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> that is covered by <inline-formula id="IE231"><mml:math id="IM231"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, which we denote as <inline-formula id="IE232"><mml:math id="IM232"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and computing the subvector of <inline-formula id="IE233"><mml:math id="IM233"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> that is covered by <inline-formula id="IE234"><mml:math id="IM234"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, which we denote as <inline-formula id="IE235"><mml:math id="IM235"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Next, given character <italic>c</italic>, we populate <inline-formula id="IE236"><mml:math id="IM236"><mml:mrow><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE237"><mml:math id="IM237"><mml:mrow><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> based on <inline-formula id="IE238"><mml:math id="IM238"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula id="IE239"><mml:math id="IM239"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as follows: (i) we check whether <italic>c</italic> exists in either <inline-formula id="IE240"><mml:math id="IM240"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE241"><mml:math id="IM241"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; (ii) if so, we add an interval to <inline-formula id="IE242"><mml:math id="IM242"><mml:mrow><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> covering the contiguous range of <italic>c</italic> in <inline-formula id="IE243"><mml:math id="IM243"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (or add an empty interval if <inline-formula id="IE244"><mml:math id="IM244"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> lacks any instances of <italic>c</italic>), and add an interval to <inline-formula id="IE245"><mml:math id="IM245"><mml:mrow><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> covering the contiguous range of <italic>c</italic> in <inline-formula id="IE246"><mml:math id="IM246"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (or, likewise, add an empty interval if <inline-formula id="IE247"><mml:math id="IM247"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> lacks any instances of <italic>c</italic>) (we are guaranteed by the definition of our data structure that any instances of <italic>c</italic> in <inline-formula id="IE248"><mml:math id="IM248"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> will be in a contiguous range, and likewise, any instances of <italic>c</italic> in <inline-formula id="IE249"><mml:math id="IM249"><mml:mrow><mml:mi mathvariant="italic">Co</mml:mi><mml:msubsup><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> will also be in a contiguous range). Finally, we concatenate all the lists in <italic>SubP</italic><sub>1</sub> and <italic>SubP</italic><sub>2</sub> to form the revised plan <inline-formula id="IE250"><mml:math id="IM250"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE251"><mml:math id="IM251"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. This revised plan <inline-formula id="IE252"><mml:math id="IM252"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE253"><mml:math id="IM253"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> becomes the input <italic>P</italic><sub>1</sub> and <italic>P</italic><sub>2</sub> for the next refinement step. <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S3</xref> shows three-merged plans, including two refined ones (green and blue). The pseudocode for this step is given in Algorithm 2.</p>
        <p>We crafted the method above to maintain the property described in the following observation.</p>
        <p>Observation 1 <italic>Let P<sub>1</sub> be a (partial) merge plan, and</italic><inline-formula id="IE254"><mml:math id="IM254"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>its refinement by our merge algorithm, where</italic><inline-formula id="IE255"><mml:math id="IM255"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic>are the elements in</italic><inline-formula id="IE256"><mml:math id="IM256"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula><italic>that are covered by interval</italic><inline-formula id="IE257"><mml:math id="IM257"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula id="IE258"><mml:math id="IM258"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>o</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic>are the elements of</italic><inline-formula id="IE259"><mml:math id="IM259"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula><italic>covered by interval</italic><inline-formula id="IE260"><mml:math id="IM260"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula><italic>. The following conditions hold: (1)</italic><inline-formula id="IE261"><mml:math id="IM261"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula id="IE262"><mml:math id="IM262"><mml:mrow><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula><italic>; (2) given any pair of elements where</italic><inline-formula id="IE263"><mml:math id="IM263"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>a</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula id="IE264"><mml:math id="IM264"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>φ</mml:mo></mml:mrow></mml:math></inline-formula><italic>there exists intervals</italic><inline-formula id="IE265"><mml:math id="IM265"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula id="IE266"><mml:math id="IM266"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>in</italic><inline-formula id="IE267"><mml:math id="IM267"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>such that</italic><inline-formula id="IE268"><mml:math id="IM268"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>∩</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mo>φ</mml:mo></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula id="IE269"><mml:math id="IM269"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>a</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>; and lastly, (3) given an interval p<sub>i</sub> in P<sub>1</sub> and the subsets of the alphabet used</italic><inline-formula id="IE270"><mml:math id="IM270"><mml:mrow><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula id="IE271"><mml:math id="IM271"><mml:mrow><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>o</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic>, then p<sub>i</sub> will be partitioned into</italic><inline-formula id="IE272"><mml:math id="IM272"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>∪</mml:mo><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula><italic>subintervals in</italic><inline-formula id="IE273"><mml:math id="IM273"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
        <p>We defined this observation for <italic>P</italic><sub>1</sub> but note that an analogous observation exists for <italic>P</italic><sub>2</sub>.
</p>
        <p>
          <boxed-text id="btz350-BOX2" position="float" orientation="portrait">
            <caption>
              <p><bold>Algorithm 2</bold>. Revising <italic>P</italic><sub>1</sub> and <italic>P</italic><sub>2</sub></p>
            </caption>
            <p><bold>procedure</bold> Partition(<italic>W</italic><sub>1</sub>, <italic>W</italic><sub>2</sub>)</p>
            <p>  <inline-formula id="IE274"><mml:math id="IM274"><mml:mrow><mml:mo>Σ</mml:mo><mml:mo>′</mml:mo><mml:mo>←</mml:mo><mml:mi mathvariant="italic">AlphabetUsed</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  <inline-formula id="IE275"><mml:math id="IM275"><mml:mrow><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>←</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  <inline-formula id="IE276"><mml:math id="IM276"><mml:mrow><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>←</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  <bold>for all</bold><inline-formula id="IE277"><mml:math id="IM277"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><bold>do</bold></p>
            <p>    <inline-formula id="IE278"><mml:math id="IM278"><mml:mrow><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi mathvariant="italic">Append</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">IntervalOccupied</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>    <inline-formula id="IE279"><mml:math id="IM279"><mml:mrow><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi mathvariant="italic">Append</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">IntervalOccupied</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  <bold>end for</bold></p>
            <p>  <bold>return</bold> (<italic>SubP</italic><sub>1</sub>, <italic>SubP</italic><sub>2</sub>)</p>
            <p>
              <bold>end procedure</bold>
            </p>
            <p> </p>
            <p> </p>
            <p><bold>procedure</bold> RefinePlan(<italic>P</italic><sub>1</sub>, <italic>P</italic><sub>2</sub>, <italic>Col</italic><sub>1</sub>, <italic>Col</italic><sub>2</sub>, <italic>i</italic>)</p>
            <p>  <inline-formula id="IE280"><mml:math id="IM280"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>←</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  <inline-formula id="IE281"><mml:math id="IM281"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>←</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  % For each interval in <italic>P</italic><sub>1</sub> (and <italic>P</italic><sub>2</sub>)</p>
            <p>  <bold>for all</bold><inline-formula id="IE282"><mml:math id="IM282"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1..</mml:mn><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><bold>do</bold></p>
            <p>   %…extract a window from each column covered by the interval…</p>
            <p>    <inline-formula id="IE283"><mml:math id="IM283"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>←</mml:mo><mml:mi mathvariant="italic">CoveredSymbols</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Co</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>    <inline-formula id="IE284"><mml:math id="IM284"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>←</mml:mo><mml:mi mathvariant="italic">CoveredSymbols</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Co</mml:mi><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>    %…and partitioning that window on its character runs, forming sub-intervals.</p>
            <p>    <inline-formula id="IE285"><mml:math id="IM285"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>←</mml:mo><mml:mi mathvariant="italic">Partition</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>    <inline-formula id="IE286"><mml:math id="IM286"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>.</mml:mo><mml:mi mathvariant="italic">Concatenate</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>    <inline-formula id="IE287"><mml:math id="IM287"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>.</mml:mo><mml:mi mathvariant="italic">Concatenate</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Sub</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  <bold>end for</bold></p>
            <p>  <bold>if</bold><inline-formula id="IE288"><mml:math id="IM288"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>    <inline-formula id="IE289"><mml:math id="IM289"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  <bold>end if</bold></p>
            <p>  <bold>return</bold><inline-formula id="IE290"><mml:math id="IM290"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>2</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>
              <bold>end procedure</bold>
            </p>
          </boxed-text>
        </p>
      </sec>
      <sec>
        <title>4.2.3 The execution step</title>
        <p>We execute the merge plan by combining the elements of <inline-formula id="IE291"><mml:math id="IM291"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that are covered by an interval in <italic>P</italic><sub>1</sub> with the elements of <inline-formula id="IE292"><mml:math id="IM292"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that are covered by the same interval in <italic>P</italic><sub>2</sub> into a single element in <inline-formula id="IE293"><mml:math id="IM293"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We note that when all characters of each <italic>k</italic>-mer in <inline-formula id="IE294"><mml:math id="IM294"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE295"><mml:math id="IM295"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> have been computed and accounted for, each interval in <italic>P</italic><sub>1</sub> (and <italic>P</italic><sub>2</sub>) will cover either 0 or 1 element of <inline-formula id="IE296"><mml:math id="IM296"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> (and <inline-formula id="IE297"><mml:math id="IM297"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>) and the number of intervals in <italic>P</italic><sub>1</sub> (equivalently <italic>P</italic><sub>2</sub>) will be equal to <inline-formula id="IE298"><mml:math id="IM298"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, we consider and merge each pair of intervals of <italic>P</italic><sub>1</sub> and <italic>P</italic><sub>2</sub> in an iterative manner. We let <inline-formula id="IE299"><mml:math id="IM299"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the <italic>i</italic>-th pair of intervals. We concatenate the next character of <inline-formula id="IE300"><mml:math id="IM300"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> onto the end of <inline-formula id="IE301"><mml:math id="IM301"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE302"><mml:math id="IM302"><mml:mrow><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. If <inline-formula id="IE303"><mml:math id="IM303"><mml:mrow><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> then we dismiss the next character of <inline-formula id="IE304"><mml:math id="IM304"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> since it corresponds to the edge that was just added. Lastly, if <inline-formula id="IE305"><mml:math id="IM305"><mml:mrow><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE306"><mml:math id="IM306"><mml:mrow><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, we copy the next character from <inline-formula id="IE307"><mml:math id="IM307"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> onto the end of <inline-formula id="IE308"><mml:math id="IM308"><mml:mrow><mml:mi mathvariant="italic">Edge</mml:mi><mml:mo>-</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>We merge the color matrices in an identical manner by copying elements of <inline-formula id="IE309"><mml:math id="IM309"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE310"><mml:math id="IM310"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE311"><mml:math id="IM311"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Again, we iterate through the plan by considering each pair of intervals. If <inline-formula id="IE312"><mml:math id="IM312"><mml:mrow><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE313"><mml:math id="IM313"><mml:mrow><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> then we concatenate the corresponding rows of <inline-formula id="IE314"><mml:math id="IM314"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE315"><mml:math id="IM315"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> to form a new row that is added to <inline-formula id="IE316"><mml:math id="IM316"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. If only one of <inline-formula id="IE317"><mml:math id="IM317"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE318"><mml:math id="IM318"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> is non-zero then the corresponding row of <inline-formula id="IE319"><mml:math id="IM319"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE320"><mml:math id="IM320"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is copied to <inline-formula id="IE321"><mml:math id="IM321"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with the other elements of the new row set to 0. Lastly, we note that we discussed the planning and execution steps of merging the primary components. As previously mentioned, details about merging the secondary components are given in the Supplementary Section 12.</p>
        <p>The following theorem demonstrates the efficiency of our approach. The proof of the following theorem is found in the Supplementary Section 13.</p>
        <p>Theorem 1. Given two colored de Bruijn graphs <inline-formula id="IE322"><mml:math id="IM322"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE323"><mml:math id="IM323"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> constructed for k, where <inline-formula id="IE324"><mml:math id="IM324"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>≥</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. It follows that our merge algorithm constructs the merged colored de Bruijn graph G<sub>M</sub> in <inline-formula id="IE325"><mml:math id="IM325"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>·</mml:mo><mml:mi>max</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time, where <italic>t</italic> is the number of colors in G<sub>M</sub>.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>5 Results</title>
    <p>In this section, we show the correctness of our method, the reduction in the resources used to build a colored de Bruijn graph by merging, and the comparison between state-of-the-art methods for building colored de Bruijn graphs. We ran all performance experiments on a machine with two Xeon E5-2640 v4 chips, each having 10 2.4 GHz cores. The system contains 755 GB of RAM and two ZFS RAID pools of nine disk each for storage. We report wall clock time and maximum resident set size from Linux.</p>
    <sec>
      <title>5.1 Validation on <italic>Escherichia coli</italic></title>
      <p>In order to validate the correctness of our approach, we generated two succinct colored de Bruijn graphs with two sets of three <italic>Escherichia coli</italic> (<italic>E.coli</italic>) incomplete assemblies each, merged them to a single six-color graph, and verified its equivalence to a six-color graph built from scratch using <inline-formula id="IE326"><mml:math id="IM326"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>. We obtained the six sub-strains of <italic>E.coli</italic> K-12 from NCBI. Each of the genomes contained approximately 4.6 million base pairs and had a median GC content of 49.9%. This experiment tests that the merged colored de Bruijn graph built by <inline-formula id="IE327"><mml:math id="IM327"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> is equivalent to that produced by building the graph without merging (i.e. with <inline-formula id="IE328"><mml:math id="IM328"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> alone) even in the presence of any redundant dummy edges. We tested equivalence by running a bubble-calling algorithm on both six-color graphs and found the identical set of bubbles between them. Further, we found <inline-formula id="IE329"><mml:math id="IM329"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> produced files on disk that were bit-for-bit identical to those generated by <inline-formula id="IE330"><mml:math id="IM330"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> when consuming complete assemblies, demonstrating the merge algorithm perfectly merges the succinct source graphs. We leave additional details of this validation to the Supplementary (see <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S4</xref>).</p>
    </sec>
    <sec>
      <title>5.2 Demonstration of large-scale construction and incremental updates</title>
      <p>We downloaded the sequence data from for 16 000 Salmonella strains (NCBI BioProject PRJNA18384), assembled them individually with IDBA, then divided them into four sets of 4000 strains, which we label 4A, 4B, 4C and 4D. From these datasets we construct a colored de Bruijn graph for 8000 strains, to demonstrate the efficiency of the merge process, and 16 000 strains, to demonstrate scalability. The exact accessions for each dataset are available in our repository.</p>
      <p>In order to measure the effectiveness of <inline-formula id="IE331"><mml:math id="IM331"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> for the proposed divide-and-conquer method of building large graphs, we constructed the colored de Bruijn graph using <inline-formula id="IE332"><mml:math id="IM332"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> for a set of 4000 salmonella assemblies (4A). This took 8 h 46 min, 1 TB of external memory and 136 GB of RAM to build the graph for 4000 strains. We then built a graph for a second set of 4000 assemblies (4B) using 10 h 40 min, 1.5 TB of external memory and 137 GB of RAM. We merged these two 4000 sample graphs (i.e. 8AB) using our proposed algorithm in 2 h 1 min, no external memory and 10 GB of RAM. ‘0’ is shown in the external memory column of <xref rid="btz350-T1" ref-type="table">Table 1</xref> for merge since no external memory is ever used for merging. Thus the <inline-formula id="IE333"><mml:math id="IM333"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> method required a combined 137 GB of RAM, 26 h 30 min of runtime to produce the graph for 8000 strains. We denote this graph with 8000 strains as 8AB. In contrast, running <inline-formula id="IE334"><mml:math id="IM334"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> on the same 8000 strains required 37 h 27 min, 4.6 TB of external memory and 271 GB of RAM. Thus <inline-formula id="IE335"><mml:math id="IM335"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> reduced runtime by 11 h, reducing RAM requirements to 134 GB and reducing external memory requirements by 3.1 TB.</p>
      <table-wrap id="btz350-T1" orientation="portrait" position="float">
        <label>Table 1.</label>
        <caption>
          <p>Breakdown of the memory, disk and time usage of <inline-formula id="IE336"><mml:math id="IM336"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> to build the colored de Bruijn graph for 8000 strains</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">Input stats<hr/></th>
              <th colspan="3" rowspan="1">de Bruijn graph<hr/></th>
              <th colspan="3" rowspan="1">Color matrix<hr/></th>
              <th colspan="4" rowspan="1">Combined requirements<hr/></th>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Program and dataset</th>
              <th rowspan="1" colspan="1"><italic> k</italic>-mers</th>
              <th rowspan="1" colspan="1">Colors</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Size (GB)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Size (GB)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">External memory (TB)</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Size (GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1"><inline-formula id="IE337"><mml:math id="IM337"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>(4A)</td>
              <td rowspan="1" colspan="1">1.1 B</td>
              <td rowspan="1" colspan="1">4000</td>
              <td rowspan="1" colspan="1">136</td>
              <td rowspan="1" colspan="1">8 h 46 min</td>
              <td rowspan="1" colspan="1">0.31</td>
              <td rowspan="1" colspan="1">52</td>
              <td rowspan="1" colspan="1">1 h 39 min</td>
              <td rowspan="1" colspan="1">51.2</td>
              <td rowspan="1" colspan="1">136</td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">10 h 25 min</td>
              <td rowspan="1" colspan="1">51</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"><inline-formula id="IE338"><mml:math id="IM338"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>(4B)</td>
              <td rowspan="1" colspan="1">1.5 B</td>
              <td rowspan="1" colspan="1">4000</td>
              <td rowspan="1" colspan="1">137</td>
              <td rowspan="1" colspan="1">10 h 40 min</td>
              <td rowspan="1" colspan="1">0.52</td>
              <td rowspan="1" colspan="1">54</td>
              <td rowspan="1" colspan="1">2 h 22 min</td>
              <td rowspan="1" colspan="1">52.5</td>
              <td rowspan="1" colspan="1">137</td>
              <td rowspan="1" colspan="1">1.5</td>
              <td rowspan="1" colspan="1">13 h 2 min</td>
              <td rowspan="1" colspan="1">53</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"><inline-formula id="IE339"><mml:math id="IM339"><mml:mrow><mml:mtext>Merge</mml:mtext></mml:mrow></mml:math></inline-formula>(4A, 4B)</td>
              <td rowspan="1" colspan="1">2.4 B</td>
              <td rowspan="1" colspan="1">8000</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">2 h 1 min</td>
              <td rowspan="1" colspan="1">0.63</td>
              <td rowspan="1" colspan="1">117</td>
              <td rowspan="1" colspan="1">1 h 2 min</td>
              <td rowspan="1" colspan="1">106</td>
              <td rowspan="1" colspan="1">117</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">3 h 3 min</td>
              <td rowspan="1" colspan="1">106</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE340">
                  <mml:math id="IM340">
                    <mml:mrow>
                      <mml:mtext>VariMerge</mml:mtext>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">2.4</td>
              <td rowspan="1" colspan="1">8000</td>
              <td rowspan="1" colspan="1">137</td>
              <td rowspan="1" colspan="1">21 h 27 min</td>
              <td rowspan="1" colspan="1">0.63</td>
              <td rowspan="1" colspan="1">117</td>
              <td rowspan="1" colspan="1">5 h 3 min</td>
              <td rowspan="1" colspan="1">117</td>
              <td rowspan="1" colspan="1">137</td>
              <td rowspan="1" colspan="1">1.5</td>
              <td rowspan="1" colspan="1">26 h 30 min</td>
              <td rowspan="1" colspan="1">106</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic>Note</italic>: The <inline-formula id="IE341"><mml:math id="IM341"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> method consists of running <inline-formula id="IE342"><mml:math id="IM342"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> on subsets of the population (4A and 4B) and then merging the results with our proposed merge algorithm (denoted <inline-formula id="IE343"><mml:math id="IM343"><mml:mrow><mml:mtext>Merge</mml:mtext></mml:mrow></mml:math></inline-formula> here). We list the resources used for both individual runs of <inline-formula id="IE344"><mml:math id="IM344"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>, the <inline-formula id="IE345"><mml:math id="IM345"><mml:mrow><mml:mtext>Merge</mml:mtext></mml:mrow></mml:math></inline-formula> required and the combined resources. The combined resources consist of the total time and maximum space used across all three components of <inline-formula id="IE346"><mml:math id="IM346"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> used in this dataset. No external memory is needed for merging itself so ‘0’ is in the external memory column for <inline-formula id="IE347"><mml:math id="IM347"><mml:mrow><mml:mtext>Merge</mml:mtext></mml:mrow></mml:math></inline-formula>.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>We further used this facility to merge two more 4000 color graphs (i.e. 4C + 4D) (<xref rid="btz350-T2" ref-type="table">Table 2</xref>). We denote the resulting graph as 8CD. We then merged this 8000 sample graph with the aforementioned 8000 color graph to produce a succinct colored de Bruijn graph of 16 000 samples (i.e. 8AB + 8CD).</p>
      <table-wrap id="btz350-T2" orientation="portrait" position="float">
        <label>Table 2.</label>
        <caption>
          <p>Breakdown of the peak memory, peak disk and time required by <inline-formula id="IE348"><mml:math id="IM348"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> to build the colored de Bruijn graph for 16 000 strains of Salmonella</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">Input stats<hr/></th>
              <th colspan="3" rowspan="1">de Bruijn graph<hr/></th>
              <th colspan="3" rowspan="1">Color matrix<hr/></th>
              <th colspan="4" rowspan="1">Combined requirements<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Program and dataset</th>
              <th rowspan="1" colspan="1"><italic>k</italic>-mers (B)</th>
              <th rowspan="1" colspan="1">Colors</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Size (GB)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Size (GB)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">External memory (TB)</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Size (GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1"><inline-formula id="IE349"><mml:math id="IM349"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>(4C)</td>
              <td rowspan="1" colspan="1">1.7 B</td>
              <td rowspan="1" colspan="1">4000</td>
              <td rowspan="1" colspan="1">135</td>
              <td rowspan="1" colspan="1">10 h 53 min</td>
              <td rowspan="1" colspan="1">0.46</td>
              <td rowspan="1" colspan="1">53</td>
              <td rowspan="1" colspan="1">2 h 34 min</td>
              <td rowspan="1" colspan="1">51.8</td>
              <td rowspan="1" colspan="1">135</td>
              <td rowspan="1" colspan="1">1.6</td>
              <td rowspan="1" colspan="1">13 h 27 min</td>
              <td rowspan="1" colspan="1">52</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"><inline-formula id="IE350"><mml:math id="IM350"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>(4D)</td>
              <td rowspan="1" colspan="1">2.4 B</td>
              <td rowspan="1" colspan="1">4000</td>
              <td rowspan="1" colspan="1">137</td>
              <td rowspan="1" colspan="1">14 h 35 min</td>
              <td rowspan="1" colspan="1">0.67</td>
              <td rowspan="1" colspan="1">59</td>
              <td rowspan="1" colspan="1">3 h 37 min</td>
              <td rowspan="1" colspan="1">57.9</td>
              <td rowspan="1" colspan="1">137</td>
              <td rowspan="1" colspan="1">2.34</td>
              <td rowspan="1" colspan="1">18 h 12 min</td>
              <td rowspan="1" colspan="1">59</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"><inline-formula id="IE351"><mml:math id="IM351"><mml:mrow><mml:mtext>Merge</mml:mtext></mml:mrow></mml:math></inline-formula>(4C, 4D)</td>
              <td rowspan="1" colspan="1">3.8 B</td>
              <td rowspan="1" colspan="1">8000</td>
              <td rowspan="1" colspan="1">17</td>
              <td rowspan="1" colspan="1">2 h 59 min</td>
              <td rowspan="1" colspan="1">1.00</td>
              <td rowspan="1" colspan="1">118</td>
              <td rowspan="1" colspan="1">57 min</td>
              <td rowspan="1" colspan="1">107</td>
              <td rowspan="1" colspan="1">118</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">3 h 56 min</td>
              <td rowspan="1" colspan="1">108</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"><inline-formula id="IE352"><mml:math id="IM352"><mml:mrow><mml:mtext>Merge</mml:mtext></mml:mrow></mml:math></inline-formula>(8AB, 8CD)</td>
              <td rowspan="1" colspan="1">5.8 B</td>
              <td rowspan="1" colspan="1">16 000</td>
              <td rowspan="1" colspan="1">25</td>
              <td rowspan="1" colspan="1">4 h 53 min</td>
              <td rowspan="1" colspan="1">1.60</td>
              <td rowspan="1" colspan="1">254</td>
              <td rowspan="1" colspan="1">2 h 10 min</td>
              <td rowspan="1" colspan="1">232</td>
              <td rowspan="1" colspan="1">254</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">7 h 3 min</td>
              <td rowspan="1" colspan="1">233</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE353">
                  <mml:math id="IM353">
                    <mml:mrow>
                      <mml:mtext>VariMerge</mml:mtext>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">5.8 B</td>
              <td rowspan="1" colspan="1">16 000</td>
              <td rowspan="1" colspan="1">137</td>
              <td rowspan="1" colspan="1">54 h 47 min</td>
              <td rowspan="1" colspan="1">1.60</td>
              <td rowspan="1" colspan="1">254</td>
              <td rowspan="1" colspan="1">14 h 21 min</td>
              <td rowspan="1" colspan="1">232</td>
              <td rowspan="1" colspan="1">254</td>
              <td rowspan="1" colspan="1">2.34</td>
              <td rowspan="1" colspan="1">69 h 8 min</td>
              <td rowspan="1" colspan="1">233</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic>Note:</italic> We note <inline-formula id="IE354"><mml:math id="IM354"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> includes the resources required of the two 4000 runs of <inline-formula id="IE355"><mml:math id="IM355"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> (i.e. <inline-formula id="IE356"><mml:math id="IM356"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>(4A) and <inline-formula id="IE357"><mml:math id="IM357"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>(4B)) and the merge run (i.e. <inline-formula id="IE358"><mml:math id="IM358"><mml:mrow><mml:mtext>Merge</mml:mtext></mml:mrow></mml:math></inline-formula>(4A, 4B)) from <xref rid="btz350-T1" ref-type="table">Table 1</xref>. No extra external memory is needed for merging so ‘0’ is in the external memory column for <inline-formula id="IE359"><mml:math id="IM359"><mml:mrow><mml:mtext>Merge</mml:mtext></mml:mrow></mml:math></inline-formula>.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>In order to measure the effectiveness of <inline-formula id="IE360"><mml:math id="IM360"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> for incremental additions to a graph that holds a growing population of genomes, we started with the colored de Bruijn graph of 16 000 salmonella assemblies. We then constructed a second graph for a singleton set of just one additional assembly. Next, we ran our proposed merge algorithm on these two graphs. <inline-formula id="IE361"><mml:math id="IM361"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> took 69 h 8 min, 2.34 TB of external memory and 254 GB of RAM to build the graph for 16 000 strains. To build a single colored de Bruijn graph for an additional strain, <inline-formula id="IE362"><mml:math id="IM362"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> took 7 s, 460 MB of external memory and 2.3 GB of RAM. Our proposed merge algorithm took 7 h 9 min, no external memory and 254 GB of RAM to merge the 16 000 color graph with the one color graph. This is an order of magnitude faster than the almost 70 h it would take to build the same 16 001 color graph from scratch.</p>
      <p>This experiment also reveals that increasing the number of divisions (below a reasonable threshold) will lower the time, memory and external memory—with the tradeoff being the practical challenge of dividing and merging the data. Nonetheless, this is one of the benefits of <inline-formula id="IE363"><mml:math id="IM363"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula>, as smaller and smaller memory and external memory could be used by making further divisions of the data.</p>
    </sec>
    <sec>
      <title>5.3 Comparison to existing methods</title>
      <p>We compare our method to the existing space- and memory-efficient colored de Bruijn graphs. To accomplish this, we ran Bloom Filter Trie (<xref rid="btz350-B12" ref-type="bibr">Holley <italic>et al.</italic>, 2016</xref>), <inline-formula id="IE364"><mml:math id="IM364"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> (<xref rid="btz350-B17" ref-type="bibr">Muggli <italic>et al.</italic>, 2017</xref>)/Rainbowfish (<xref rid="btz350-B1" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2017</xref>), Mantis (<xref rid="btz350-B20" ref-type="bibr">Pandey <italic>et al.</italic>, 2018</xref>)/the method of <xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic> (2019)</xref> and Multi-BRWT (<xref rid="btz350-B15" ref-type="bibr">Karasikov <italic>et al.</italic>, 2019</xref>). The peak RAM use and running time required by the methods to construct a colored de Bruijn graph for 4000, 8000 and 16 000 strains is shown in <xref rid="btz350-T3" ref-type="table">Table 3</xref>. In addition, <xref rid="btz350-T3" ref-type="table">Table 3</xref> illustrates the output size of all the methods. We note that all methods were run with default parameters and <italic>k </italic>=<italic> </italic>32, except from Bloom Filter Trie which can only work with <italic>k</italic> values which are multiples of 9, hence we ran it with <italic>k </italic>=<italic> </italic>27. We ran Mantis with their ‘log-slot’ parameter set to 33 and 36 for the experiments using 4000 and 8000 strains, and 16 000 strains, respectively. All methods are exact, colored de Bruijn graph construction methods. Since Rainbowfish first runs <inline-formula id="IE365"><mml:math id="IM365"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> and then compresses, the peak RAM, peak disk usage, and time will be at least that of <inline-formula id="IE366"><mml:math id="IM366"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> for construction; this is why they are shown together in <xref rid="btz350-T3" ref-type="table">Table 3</xref>. Similarly, we report peak RAM, peak disk usage and time of Mantis together with that of the method of <xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic> (2019)</xref> because the latter method first runs Mantis and then compresses the output of Mantis. These points are also discussed in the related work. Again, because we are interested in construction (not exclusively compression) we are interested in peak RAM and external memory usage.</p>
      <table-wrap id="btz350-T3" orientation="portrait" position="float">
        <label>Table 3.</label>
        <caption>
          <p>Comparison between space-efficient colored de Bruijn graph construction methods for 4000, 8000 and 16 000 Salmonella strains using <inline-formula id="IE367"><mml:math id="IM367"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> versus competing methods</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Dataset</th>
              <th rowspan="1" colspan="1">No. of <italic>k</italic>-mers (Billion)</th>
              <th align="left" rowspan="1" colspan="1">Program</th>
              <th rowspan="1" colspan="1">Output size (GB)</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">4000</td>
              <td rowspan="1" colspan="1">1.1</td>
              <td rowspan="1" colspan="1"><inline-formula id="IE368"><mml:math id="IM368"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>/Rainbowfish</td>
              <td rowspan="1" colspan="1">51</td>
              <td rowspan="1" colspan="1">10 h 25 min</td>
              <td rowspan="1" colspan="1">136</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Bloom Filter Trie</td>
              <td rowspan="1" colspan="1">99</td>
              <td rowspan="1" colspan="1">51 h 42 min</td>
              <td rowspan="1" colspan="1">120</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Multi-BRWT</td>
              <td rowspan="1" colspan="1">1.3 TB</td>
              <td rowspan="1" colspan="1">42 h 23 min</td>
              <td rowspan="1" colspan="1">156</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Mantis/Method of Almodaresi <italic>et al.</italic></td>
              <td rowspan="1" colspan="1">36</td>
              <td rowspan="1" colspan="1">5 h 58 min</td>
              <td rowspan="1" colspan="1">313</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE369">
                  <mml:math id="IM369">
                    <mml:mrow>
                      <mml:mtext>VariMerge</mml:mtext>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">51</td>
              <td rowspan="1" colspan="1">10 h 25 min</td>
              <td rowspan="1" colspan="1">136</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">8000</td>
              <td rowspan="1" colspan="1">2.4</td>
              <td rowspan="1" colspan="1"><inline-formula id="IE370"><mml:math id="IM370"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>/Rainbowfish</td>
              <td rowspan="1" colspan="1">114</td>
              <td rowspan="1" colspan="1">37 h 27 min</td>
              <td rowspan="1" colspan="1">271</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Bloom Filter Trie</td>
              <td rowspan="1" colspan="1">N/A</td>
              <td rowspan="1" colspan="1">N/A</td>
              <td rowspan="1" colspan="1">N/A</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Multi-BRWT</td>
              <td rowspan="1" colspan="1">N/A</td>
              <td rowspan="1" colspan="1">N/A</td>
              <td rowspan="1" colspan="1">N/A</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Mantis/Method of Almodaresi <italic>et al.</italic></td>
              <td rowspan="1" colspan="1">38</td>
              <td rowspan="1" colspan="1">13 h 37 min</td>
              <td rowspan="1" colspan="1">370</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE371">
                  <mml:math id="IM371">
                    <mml:mrow>
                      <mml:mtext>VariMerge</mml:mtext>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">106</td>
              <td rowspan="1" colspan="1">26 h 30 min</td>
              <td rowspan="1" colspan="1">137</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">16 000</td>
              <td rowspan="1" colspan="1">5.8</td>
              <td rowspan="1" colspan="1"><inline-formula id="IE372"><mml:math id="IM372"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula>/Rainbowfish</td>
              <td rowspan="1" colspan="1">N/A</td>
              <td rowspan="1" colspan="1">N/A</td>
              <td rowspan="1" colspan="1">N/A</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Bloom Filter Trie</td>
              <td rowspan="1" colspan="1">N/A</td>
              <td rowspan="1" colspan="1">N/A</td>
              <td rowspan="1" colspan="1">N/A</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Multi-BRWT</td>
              <td rowspan="1" colspan="1">N/A</td>
              <td rowspan="1" colspan="1">N/A</td>
              <td rowspan="1" colspan="1">N/A</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Mantis/method of Almodaresi <italic>et al.</italic></td>
              <td rowspan="1" colspan="1">256</td>
              <td rowspan="1" colspan="1">36 h 12 min</td>
              <td rowspan="1" colspan="1">316</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE373">
                  <mml:math id="IM373">
                    <mml:mrow>
                      <mml:mtext>VariMerge</mml:mtext>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">233</td>
              <td rowspan="1" colspan="1">69 h 8 min</td>
              <td rowspan="1" colspan="1">254</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn3">
            <p><italic>Note:</italic> We report N/A for any method that exceeded 140 CPU hours, 4 TB of disk space and 750 GB of memory. We anticipate add-on methods to compress better but will still consume the resources shown for their base method because they reuse base the method’s output. We measured RAM as max resident set size. Mantis authors noted their use of memory mapped I/O means this reveals opportunistic consumption and not necessarily requirement for their program. To the best of our knowledge, no extra external memory is needed for Bloom Filter Trie, Multi-BRWT, Mantis and the method of Almodaresi <italic>et al.</italic>, so it is omitted from the table.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>We report N/A in <xref rid="btz350-T3" ref-type="table">Table 3</xref> for any method that exceeded 140 h, and/or our RAM and external memory quota. We had 4 TB of disk space for each method (20 TB in total) and 750 GB of RAM. All methods performed reasonably well on 4000 strains. Bloom Filter Trie required the most time, and Multi-BRWT required the most space. This was unsurprising as Multi-BRWT focuses on compression of the color matrix and not the graph (see Related Work). Mantis (and its successor (<xref rid="btz350-B2" ref-type="bibr">Almodaresi <italic>et al.</italic>, 2019</xref>)) required the largest peak memory (313 GB). With 8000 strains Bloom Filter Trie and Multi-BRWT required more than 140 h, Vari and Rainbowfish were able to run within the given constraints but had the longest running time (over 37 h). Mantis was more efficient with respect to final output (38 GB versus 106 GB) and <inline-formula id="IE374"><mml:math id="IM374"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> was more efficient with respect to RAM consumed (137 GB versus 370 GB). Lastly, only Mantis and <inline-formula id="IE375"><mml:math id="IM375"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> were capable of building the colored de Bruijn graph with 16 000 strains. For 16 000 strains our method had improved output size and RAM usage and Mantis had improved running time. Yet, as shown in the previous section, <inline-formula id="IE376"><mml:math id="IM376"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> allows the graph to be updated with new data via merging. Mantis (as well as <inline-formula id="IE377"><mml:math id="IM377"><mml:mrow><mml:mtext>Vari</mml:mtext></mml:mrow></mml:math></inline-formula> and Rainbowfish) provide no option to update the graph without reconstruction.</p>
      <p>Lastly, <inline-formula id="IE378"><mml:math id="IM378"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> has several practical advantages over competing methods. It allows large values of <italic>k</italic>, i.e. <inline-formula id="IE379"><mml:math id="IM379"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula>, and allows for efficient queries of the form: given a color <italic>c</italic>, return all <italic>k</italic>-mers that have that color. Competing methods cannot perform such queries without the input files or cannot scale to large datasets. We discuss this more in the conclusions.</p>
    </sec>
  </sec>
  <sec>
    <title>6 Conclusion</title>
    <p>In this article, we develop a method to build the colored de Bruijn graph by merging smaller graphs in a resource-efficient manner. This allows the colored de Bruijn graph to be constructed for large datasets and provides an efficient means to update it. As previously mentioned, resource use can be optimized by partitioning the data into smaller, carefully selected datasets. We leave how to optimize the construction via data partitioning size as future work.</p>
    <p>Lastly, we mention that the underlying graph data structure of <inline-formula id="IE380"><mml:math id="IM380"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> has some advantages over competing methods. First, <inline-formula id="IE381"><mml:math id="IM381"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> allows arbitrary <italic>k</italic> up to 64 while other tools are more restricted; BFT requires <italic>k</italic> to be multiples of 9 and Mantis only supports values of <italic>k</italic> up to 32. Second, the node labels can be recovered from the index alone, allowing the following queries to be performed: given a particular color <italic>c</italic>, what <italic>k</italic>-mers have color <italic>c</italic>. These queries can be accomplished by <inline-formula id="IE382"><mml:math id="IM382"><mml:mrow><mml:mtext>VariMerge</mml:mtext></mml:mrow></mml:math></inline-formula> scanning a particular column of the color matrix and can be used for comparing samples, i.e. which <italic>k</italic>-mers are shared and which differ between sample <italic>x</italic> and sample <italic>y</italic>. While the Mantis authors have suggested an approach to supporting this query, it is unimplemented and requires the input files, increasing the size of the data structure.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the National Science Foundation (NSF) IIS [Grant No. 1618814 to C.B.] and National Institute of Allergy and Infectious Diseases Institute of the National Institutes of Health [Grant No. R01AI141810-01 to C.B.].</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>btz350_Supplementary_Data</label>
      <media xlink:href="btz350_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz350-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Almodaresi</surname><given-names>F.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Rainbowfish: a succinct colored de Bruijn graph representation</article-title>. In: <source>17th International Workshop on Algorithms in Bioinformatics (WABI 2017)</source>. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, pp. <fpage>251</fpage>–<lpage>265</lpage>. </mixed-citation>
    </ref>
    <ref id="btz350-B2">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Almodaresi</surname><given-names>F.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) An efficient, scalable and exact representation of high-dimensional color information enabled via de Bruijn graph search. <italic>BioRxiv</italic>, doi: 10.1101/464222.</mixed-citation>
    </ref>
    <ref id="btz350-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bowe</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Succinct de Bruijn graphs</article-title>. In: <source>International Workshop on Algorithms in Bioinformatics</source>. Springer, pp. <fpage>225</fpage>–<lpage>235</lpage>.</mixed-citation>
    </ref>
    <ref id="btz350-B4">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Bradley</surname><given-names>P.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) Real-time search of all bacterial and viral genomic data. <italic>BioRxiv.</italic> doi: 10.1101/234955.</mixed-citation>
    </ref>
    <ref id="btz350-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Burrows</surname><given-names>M.</given-names></name>, <name name-style="western"><surname>Wheeler</surname><given-names>D.</given-names></name></person-group> (<year>1994</year>) <chapter-title>A block sorting lossless data compression algorithm</chapter-title>
<source>Technical Report 124</source>. 
<publisher-name>Digital Equipment Corporation</publisher-name>, 
<publisher-loc>Palo Alto, CA</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btz350-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chikhi</surname><given-names>R.</given-names></name>, <name name-style="western"><surname>Rizk</surname><given-names>G.</given-names></name></person-group> (<year>2013</year>) 
<article-title>Space-efficient and exact de Bruijn graph representation based on a Bloom filter</article-title>. <source>Algorithms Mol. Biol</source>., <volume>8</volume>, <fpage>22</fpage>.<pub-id pub-id-type="pmid">24040893</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chikhi</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>On the representation of de Bruijn graphs</article-title>. In: <source>International Conference on Research in Computational Molecular Biology</source>. Springer, pp. <fpage>35</fpage>–<lpage>55</lpage>.</mixed-citation>
    </ref>
    <ref id="btz350-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Conway</surname><given-names>T.</given-names></name>, <name name-style="western"><surname>Bromage</surname><given-names>A.</given-names></name></person-group> (<year>2011</year>) 
<article-title>Succinct data structures for assembling large genomes</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>479</fpage>–<lpage>486</lpage>.<pub-id pub-id-type="pmid">21245053</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Crawford</surname><given-names>V.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Practical dynamic de Bruijn graphs</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>4189</fpage>–<lpage>4195</lpage>.<pub-id pub-id-type="pmid">29939217</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B10">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Egidi</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) Space-efficient merging of succinct de bruijn graphs. arXiv: 1902.02889.</mixed-citation>
    </ref>
    <ref id="btz350-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ferragina</surname><given-names>P.</given-names></name>, <name name-style="western"><surname>Manzini</surname><given-names>G.</given-names></name></person-group> (<year>2005</year>) 
<article-title>Indexing compressed text</article-title>. <source>JACM</source>, <volume>52</volume>, <fpage>552</fpage>–<lpage>581</lpage>.</mixed-citation>
    </ref>
    <ref id="btz350-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Holley</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Bloom filter trie–a data structure for pan-genome storage</article-title>. <source>Algorithm Mol. Biol</source>., <volume>11</volume>, <fpage>217</fpage>–<lpage>230</lpage>. </mixed-citation>
    </ref>
    <ref id="btz350-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Holt</surname><given-names>J.</given-names></name>, <name name-style="western"><surname>McMillan</surname><given-names>L.</given-names></name></person-group> (<year>2014</year>) 
<article-title>Merging of multi-string BWTs with applications</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3524</fpage>–<lpage>3531</lpage>.<pub-id pub-id-type="pmid">25172922</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Iqbal</surname><given-names>Z.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>De novo assembly and genotyping of variants using colored de Bruijn graphs</article-title>. <source>Nat. Genet</source>., <volume>44</volume>, <fpage>226</fpage>–<lpage>232</lpage>.<pub-id pub-id-type="pmid">22231483</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B15">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Karasikov</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) Sparse binary relation representations for genome graph annotation. <italic>BioRxiv</italic>, doi: 10.1101/468512.</mixed-citation>
    </ref>
    <ref id="btz350-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>D.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>MEGAHIT: an ultra-fast single-node solution for large and complex metagenomics assembly via succinct de Bruijn graph</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>1674</fpage>–<lpage>1676</lpage>.<pub-id pub-id-type="pmid">25609793</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Muggli</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Succinct colored de Bruijn graphs</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>3181</fpage>–<lpage>3187</lpage>.<pub-id pub-id-type="pmid">28200001</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mustafa</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Dynamic compression schemes for graph coloring</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>407</fpage>–<lpage>414</lpage>.<pub-id pub-id-type="pmid">30020403</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Okanohara</surname><given-names>D.</given-names></name>, <name name-style="western"><surname>Sadakane</surname><given-names>K.</given-names></name></person-group> (<year>2007</year>) 
<article-title>Practical entropy-compressed rank/select dictionary</article-title>. In: <source>Proceedings of the Meeting on Algorithm Engineering &amp; Expermiments</source>. Society for Industrial and Applied Mathematics, pp. <fpage>60</fpage>–<lpage>70</lpage>.</mixed-citation>
    </ref>
    <ref id="btz350-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Pandey</surname><given-names>P.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Mantis: a fast, small, and exact large-scale sequence-search index</article-title>. <source>Cell</source>, <volume>7</volume>, <fpage>201</fpage>–<lpage>207</lpage>.</mixed-citation>
    </ref>
    <ref id="btz350-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Peng</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>IDBA-UD: a <italic>de novo</italic> assembler for single-cell and metagenomic sequencing data with highly uneven depth</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>1420</fpage>–<lpage>1428</lpage>.<pub-id pub-id-type="pmid">22495754</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Simpson</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>ABySS: a parallel assembler for short read sequence data</article-title>. <source>Genome Res</source>., <volume>19</volume>, <fpage>1117</fpage>–<lpage>1123</lpage>.<pub-id pub-id-type="pmid">19251739</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sirén</surname><given-names>J.</given-names></name></person-group> (<year>2016</year>) 
<article-title>Burrows-Wheeler transform for terabases</article-title>. In: <source>2016 Data Compression Conference (DCC)</source>. IEEE, pp. <fpage>211</fpage>–<lpage>220</lpage>.</mixed-citation>
    </ref>
    <ref id="btz350-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Solomon</surname><given-names>B.</given-names></name>, <name name-style="western"><surname>Kingsford</surname><given-names>C.</given-names></name></person-group> (<year>2016</year>) 
<article-title>Fast search of thousands of short-read sequencing experiments</article-title>. <source>Nat. Biotechnol</source>., <volume>34</volume>, <fpage>300</fpage>–<lpage>302</lpage>.<pub-id pub-id-type="pmid">26854477</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Solomon</surname><given-names>B.</given-names></name>, <name name-style="western"><surname>Kingsford</surname><given-names>C.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Improved search of large transcriptomic sequencing databases using split sequence bloom trees</article-title>. <source>J. Comput. Biol</source>., <volume>25</volume>, <fpage>755</fpage>–<lpage>765</lpage>.<pub-id pub-id-type="pmid">29641248</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Stevens</surname><given-names>E.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>The public health impact of a publically available, environmental database of microbial genomes</article-title>. <source>Front. Microbiol</source>., <volume>8</volume>, <fpage>808</fpage>.<pub-id pub-id-type="pmid">28536563</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sun</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>AllSome sequence bloom trees</article-title>. In: <source>21st Annual International Conference on Research in Computational Molecular Biology</source>, Vol. 10229. Springer-Verlag, , pp. <fpage>272</fpage>–<lpage>286</lpage>.</mixed-citation>
    </ref>
    <ref id="btz350-B28">
      <mixed-citation publication-type="journal">The 1000 Genomes Project Consortium. (<year>2015</year>) 
<article-title>A global reference for human genetic variation</article-title>. <source>Nature</source>, <volume>526</volume>, <fpage>68</fpage>–<lpage>74</lpage>.<pub-id pub-id-type="pmid">26432245</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Turnbull</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>The 100,000 genomes project: bringing whole genome sequencing to the NHS</article-title>. <source>BMJ</source>, <volume>361</volume>, <fpage>k1687</fpage>.<pub-id pub-id-type="pmid">29691228</pub-id></mixed-citation>
    </ref>
    <ref id="btz350-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Yu</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>SeqOthello: querying RNA-seq experiments at scale</article-title>. <source>Genome Biol</source>., <volume>19</volume>, <fpage>167.</fpage><pub-id pub-id-type="pmid">30340508</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
