<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6894214</article-id>
    <article-id pub-id-type="pmid">31653197</article-id>
    <article-id pub-id-type="publisher-id">3115</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-019-3115-8</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>GenGraph: a python module for the simple generation and manipulation of genome graphs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-7583-0963</contrib-id>
        <name>
          <surname>Ambler</surname>
          <given-names>Jon Mitchell</given-names>
        </name>
        <address>
          <email>Jon.Ambler@uct.ac.za</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mulaudzi</surname>
          <given-names>Shandukani</given-names>
        </name>
        <address>
          <email>shandu.mulaudzi@gmail.com</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mulder</surname>
          <given-names>Nicola</given-names>
        </name>
        <address>
          <email>nicola.mulder@uct.ac.za</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1937 1151</institution-id><institution-id institution-id-type="GRID">grid.7836.a</institution-id><institution>Wellcome Centre for Infectious Diseases Research in Africa and Institute for Infectious Diseases and Molecular Medicine, University of Cape Town, </institution></institution-wrap>Anzio Road, Cape Town, 7700 South Africa </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>25</day>
      <month>10</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>25</day>
      <month>10</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>519</elocation-id>
    <history>
      <date date-type="received">
        <day>21</day>
        <month>1</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>20</day>
        <month>9</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">As sequencing technology improves, the concept of a single reference genome is becoming increasingly restricting. In the case of <italic>Mycobacterium tuberculosis</italic>, one must often choose between using a genome that is closely related to the isolate, or one that is annotated in detail. One promising solution to this problem is through the graph based representation of collections of genomes as a single genome graph. Though there are currently a handful of tools that can create genome graphs and have demonstrated the advantages of this new paradigm, there still exists a need for flexible tools that can be used by researchers to overcome challenges in genomics studies.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">We present GenGraph, a Python toolkit and accompanying modules that use existing multiple sequence alignment tools to create genome graphs. Python is one of the most popular coding languages for the biological sciences, and by providing these tools, GenGraph makes it easier to experiment and develop new tools that utilise genome graphs. The conceptual model used is highly intuitive, and as much as possible the graph structure represents the biological relationship between the genomes. This design means that users will quickly be able to start creating genome graphs and using them in their own projects. We outline the methods used in the generation of the graphs, and give some examples of how the created graphs may be used. GenGraph utilises existing file formats and methods in the generation of these graphs, allowing graphs to be visualised and imported with widely used applications, including Cytoscape, R, and Java Script.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">GenGraph provides a set of tools for generating graph based representations of sets of sequences with a simple conceptual model, written in the widely used coding language Python, and publicly available on Github.</p>
      </sec>
      <sec>
        <title>Electronic supplementary material</title>
        <p>The online version of this article (10.1186/s12859-019-3115-8) contains supplementary material, which is available to authorized users.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Genome</kwd>
      <kwd>Graph</kwd>
      <kwd>Toolkit</kwd>
      <kwd>Python</kwd>
      <kwd>Module</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Modern genomics relies heavily on the use of a reference genome for common processes like variant calling, gene expression analysis, and even genome assembly. This reference sequence is often a consensus from a set of sequences that collectively represent anything from an individual isolate such as <italic>Mycobacterium tuberculosis</italic> H37Rv, to an entire species, in the case of the human genome assembly GRCh38, and the use of this single reference introduces a number of biases. The reference may be missing genes from some strains resulting in them being ignored in a differential expression analysis, or contain chromosomal rearrangements resulting in the effect of an upstream variant being misinterpreted. In terms of genome storage, the current standard is as linear sequence stored in a fasta file. Although they have served their purpose up until now, in the age of pangenomes and microbiome studies these representations have become limiting in terms of the file space they occupy, the functionality they provide, and their ability to represent population scale variation. These challenges have led to a move towards genome graphs. Where a pangenome is a collection of sequences that represent all variation between individuals in a defined clade, a genome graph is a graph representation of a pangenome where the sequences can be represented as a De Bruiijn graph, directed acyclic graph, bidirected graph, or a biedged graph. This representation of genomes offers a myriad of advantages over the use of a single reference genome.</p>
    <p>Graphs are not a new concept in genomics, and are used for tasks including the assembly of genomes and the alignment of reads. Now, tools like vg (variant graph) [<xref ref-type="bibr" rid="CR1">1</xref>], PanTools [<xref ref-type="bibr" rid="CR2">2</xref>] and the Seven Bridges genome graph toolkit (<ext-link ext-link-type="uri" xlink:href="https://www.sbgenomics.com/graph/">https://www.sbgenomics.com/graph/</ext-link>) allow for the creation and utilisation of genome graphs in genomics work flows, and GfaPy allows for the creating, parsing, and editing of GFA graphs using Python [<xref ref-type="bibr" rid="CR3">3</xref>]. These tools are developing rapidly, and include features that take advantage of the graph structure, allowing for read alignment and variant calling using the graph genome as a reference. While these tools are highly capable, there still exists a need for the development of more toolkits for genome graphs as advocated by Paten <italic>et. al.,</italic> in a recent review that discusses these tools and the improvements they have brought to variant calling [<xref ref-type="bibr" rid="CR4">4</xref>].</p>
    <p>GenGraph is a genome graph creation and manipulation toolkit created in Python that focuses on providing tools for working with bacterial genome graphs within an initiative conceptual model. It is able to create a genome graph using multiple whole genomes and existing multiple sequence alignment (MSA) tools, allowing any current or future algorithm to be employed. In this article we outline the structure of the genome graph created by GenGraph, and the methods for its creation, and give examples of how the provided functions may be used to extract biologically interesting features from the graph. Further examples of applications are available on the project Github page.</p>
  </sec>
  <sec id="Sec2">
    <title>Implementation</title>
    <p>GenGraph is written in Python, a widely used language in the biological sciences that is easy to learn, powerful, and has numerous useful libraries including Biopython, Numpy and NetworkX. GenGraph was implemented as both a Python tool and a module with modified NetworkX graph objects whose attributes may be accessed in the manner described in the NetworkX documentation.</p>
    <sec id="Sec3">
      <title>Structure of the graph</title>
      <p>A GenGraph graph is a directed sequence graph, where the individual genomes are encoded as walks within the graph along a labeled path. Each node represents a sub-sequence that is homologous between the component sequences. This implies the sequences have a shared evolutionary origin, and are not just identical sequences, and biological representation of the genomes is prioritised over a compressed data structure (Fig. <xref rid="Fig1" ref-type="fig">1</xref>). This is an important design choice in that it allows for a more intuitive use of the graph, and a simpler conceptual model. As the graph contains no self loops, creating functions that require traversal is kept simpler.
<fig id="Fig1"><label>Fig. 1</label><caption><p>Representation of repeats in the genome graph. <bold>a</bold>, Two sequences where sequence 2 contains 3 additional “ATG” repeats high-lighted in blue. <bold>b</bold>, GenGraph represents only differences, with node 1 representing both sequences, node 2 representing the additional repeats found only in sequence 1, and node 3 the sequence that is once again shared. <bold>c</bold>, This is opposed to an approach where the “ATG” repeat is represented as a single node with a self loop. This approach may be neater and result in better compression, but raises many practical problems including not allowing the node to be labeled with the sequence start and stop positions</p></caption><graphic xlink:href="12859_2019_3115_Fig1_HTML" id="MO1"/></fig>
</p>
      <p>The coordinate system relies on storing the relative start and stop positions for each component sequences in each node. This means that given only a single node, one can determine that the first ’A’ nucleotide in the node has position 132 in isolate A, 21,310 in isolate B, and so on. This allows for existing annotations to be used, and for the sequence of a gene for a particular isolate to be retrieved from the graph given a traditional GTF file, a common task for which a function has been created. The coordinate system also allows for inversions to be represented in a single node (Fig. <xref rid="Fig2" ref-type="fig">2</xref>). This results in a more intuitive representation of the relationship between the sequences as genes that fall within the inverted sequence are still found in the same node in both isolates, and the concept of a chromosomal breakpoint is represented by the edges either side of the node. Descriptions of the node and edge attributes can be found in Tables <xref rid="Tab1" ref-type="table">1</xref> and <xref rid="Tab2" ref-type="table">2</xref>.
<fig id="Fig2"><label>Fig. 2</label><caption><p>Representation of inversions in the genome graph. During the first step of genome graph creation, co-linear blocks are identified. In some cases, these may be homologous sequences that have been inverted. GenGraph represents these sequences in a single node (that may be broken down into more nodes in the second step) and represents the inverted state of the sequence by negative nucleotide position values in the node. <bold>a</bold>, Two sequences are shown where an inversion has taken place. This is normally a larger stretch of sequence perhaps a few kb in length. <bold>b</bold>, The positions of the sequences are different, as is generally the case with homologous sequences. The positions of the nucleotides flanking the breakpoints are shown. <bold>c</bold>, The inversion in the second sequence is represented by reversed negative nucleotide position values. <bold>d</bold>, This way, both sequences are represented in the same node, and to recreate sequence 2, the sequence in the node is simply reverse-complimented</p></caption><graphic xlink:href="12859_2019_3115_Fig2_HTML" id="MO2"/></fig><table-wrap id="Tab1"><label>Table 1</label><caption><p>Information on the node attributes used in a gengraph genome graph</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Node attribute</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="justify">name</td><td align="left">String</td><td align="justify">A unique name identifying the node. When a node is split, the resulting nodes inherit the original node’s value appended with a new number. So if node Aln_66 is split into 4 nodes, they are named Aln_66_1, Aln_66 _2, Aln_66_3, Aln_66_4.</td></tr><tr><td align="justify">sequence</td><td align="left">String</td><td align="justify">The nucleotide sequence that is represented by this node.</td></tr><tr><td align="justify">ids</td><td align="left">String</td><td align="justify">This is a comma separated list of the isolates that are represented by this node.</td></tr><tr><td align="justify">(isolate)_leftend, (isolate)_rightend</td><td align="left">Integer</td><td align="justify">For each isolate, the positions of the first and last nucleotides represented by the node is recorded. So for isolate H37Rv, H37Rv_leftend = 13,203.</td></tr></tbody></table></table-wrap><table-wrap id="Tab2"><label>Table 2</label><caption><p>Information on the edge attributes used in a gengraph genome graph</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Edge attribute</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">String</td><td align="justify">Edges are named by a combination of the two nodes that they link. Eg: Aln_48_50 (-) Aln_48_49 would be the name of the node that links nodes Aln_48_50 and Aln_48_49</td></tr><tr><td align="left">ids</td><td align="left">String</td><td align="justify">This is a comma separated list of the isolates that are represented by this edge.</td></tr></tbody></table></table-wrap>
</p>
    </sec>
    <sec id="Sec4">
      <title>Creation of the genome graph</title>
      <p>The graph is created as a modified Python NetworkX graph object, the details of which may be found here (<ext-link ext-link-type="uri" xlink:href="https://networkx.github.io">https://networkx.github.io</ext-link>). GenGraph currently creates a genome graph in two steps (Fig. <xref rid="Fig3" ref-type="fig">3</xref>). First, large structural differences between the genomes including large deletions and chromosomal inversions are identified by finding large blocks of co-linear sequence between the genomes using a tool like progressiveMauve [<xref ref-type="bibr" rid="CR5">5</xref>]. These represent regions of structural conservation, and are temporarily stored in a single node within the initial graph, even if they are imperfect alignments. GenGraph then realigns the sequences in these initial nodes using the selected MSA tool, and finds the best local alignment for the sequences. The relative start and stop positions for the region of aligned sequence contained within the node is stored for each of the isolates that are included in that node as attributes of the NetworkX node object. This is then converted into a sub-graph by collapsing shared regions into single nodes, and creating edges so that a path exists for each of the original sequences through the sub-graph. This sub-graph then replaces the initial temporary node from the initial structural graph.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Overview of the GenGraph algorithm. <bold>a</bold>, Co-linear blocks of sequence are identified to determine the structural relationship of the sequences. <bold>b-c</bold>, Each block is then realigned using a MSA tool. <bold>c-d</bold>, Identical sequences are reduced into nodes and edges created</p></caption><graphic xlink:href="12859_2019_3115_Fig3_HTML" id="MO3"/></fig>
</p>
      <p>The process of identifying the co-linear blocks and subsequent realignment is done using functions that wrap existing alignment tools. Currently Muscle [<xref ref-type="bibr" rid="CR6">6</xref>], Mafft [<xref ref-type="bibr" rid="CR7">7</xref>] and Clustal Omega [<xref ref-type="bibr" rid="CR8">8</xref>] are supported for the local MSA. The final NetworkX graph objects created by GenGraph may be exported as GraphML, XML, or as a serialised object, though various other formats may be added in future. GenGraph creates a report file containing information such as the number of nodes and edges in the graph, the average in and out degree of the nodes, the total sequence length of all the nodes in the graph and the density of the graph (Additional file <xref rid="MOESM1" ref-type="media">1</xref>). This information can be used to monitor how graphs change as more genomes are added as well as the relationship between the number of features and the graph size.</p>
    </sec>
    <sec id="Sec5">
      <title>Available graph functions</title>
      <p>GenGraph is available as both a command line tool, and a Python module. Both allow for the creation of a genome graph, and the use of an existing genome graph for downstream analysis.</p>
      <p>These functions include simple processes like extracting a single genome in fasta format for a specific isolate, or extracting a sub-sequence, as well as more complicated functions that take advantage of the coordinate system to translate the position of a gene in one genome to its position in another.</p>
      <p>To demonstrate the use of GenGraph, we downloaded the complete genome assemblies of various <italic>Mycobacterium tuberculosis</italic> isolates from the NCBI database (<ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/genome/">https://www.ncbi.nlm.nih.gov/genome/</ext-link>) and used them to construct a genome graph using progressiveMauve for the structure graph, and Clustal Omega for the realignment of the blocks. We then use the available functions and simple Python code to identify conserved regions of the genomes, compare the sequence of a gene between isolates, and visualise a variant in a gene.</p>
    </sec>
  </sec>
  <sec id="Sec6">
    <title>Results and Discussion</title>
    <sec id="Sec7">
      <title>Structure of the graph</title>
      <p>GenGraph creates the genome graph based on whole genome sequence alignments that are conducted in two parts. First, the identification of large co-linear blocks, then the realignment of those blocks. This allowed for the creation of a genome graph containing multiple bacterial genomes, including MTB isolates like W-148 that contain large chromosomal rearrangements [<xref ref-type="bibr" rid="CR9">9</xref>]. The genome graphs are thus able to capture all variants from large scale structural differences between isolates such as chromosomal rearrangements, down to smaller scale differences including SNPs and copy number variations. The structure aims to represent a biologically accurate representation of the evolutionary relationships between the sequences of the different isolates. In doing so, it maintains a simple conceptual model, which makes interpreting the graph simple, and in turn helps developers to create new tools easier.</p>
    </sec>
    <sec id="Sec8">
      <title>Global and local alignment: Performance</title>
      <p>A primary feature of GenGraph is the use of existing MSA tools for the creation of the graph by wrapping the tools in functions. Because GenGraph uses these alignment tools to create the graph structure, users may use parameters or aligners that are best suited for the organism. With MSA being the current speed bottleneck in the creation of genome graphs, the scalability of GenGraph is dependent on the ability of these alignment tools. This allows the toolkit to evolve and improve with time, as well as utilise alignment tools that are best suited to the dataset at hand, and adapt to new innovations including GPU acceleration or field-programmable gate array chips.</p>
      <p>Graph generation runtime increases in a linear fashion, influenced by the number of sequences being aligned, their length, and similarity. By breaking down the genomes into partially pre-aligned blocks, GenGraph is able to align multiple long genomes in segments and with the current version of mafft able to align up to 30,000 sequences in a block.</p>
      <p>GenGraph was able to create a genome graph containing 5 MTB genomes on a 2012 i7 Macbook Pro with 8 GB ram using Mafft in 53 min and 10 genomes in 2 h and 44 min (Additional file <xref rid="MOESM2" ref-type="media">2</xref>). For smaller genomes, 300 HIV-1 genomes were aligned and converted to a genome graph in 35 min. Currently GenGraph does not take advantage of multiprocessing, an enhancement that will be made in an upcoming update. From testing we see the scalability of GenGraph is dependent on the power of the latest alignment tools, the number of sequences being aligned, their length, and their similarity, though in general we observe a linear increase in genome graph generation time as the number of sequences increase (Table <xref rid="Tab3" ref-type="table">3</xref>). Graph generation represents the most computationally intense and time consuming process, while downstream analysis benefits from the use of the data in an aligned form.
<table-wrap id="Tab3"><label>Table 3</label><caption><p>An increase in file size was observed per genome added to the graph that demonstrated the compression of data that occurs by collapsing regions of shared aligned sequences into single representative nodes</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Number of genomes</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">10</th></tr></thead><tbody><tr><td align="justify">File size</td><td align="left">4,5Mb</td><td align="left">5,9Mb</td><td align="left">7,6Mb</td><td align="left">8,5Mb</td><td align="left">11Mb</td><td align="left">13Mb</td><td align="left">38Mb</td></tr><tr><td align="justify">Number of nodes</td><td align="left">0</td><td align="left">3,690</td><td align="left">8,106</td><td align="left">9,320</td><td align="left">13,264</td><td align="left">15,355</td><td align="left">43,290</td></tr><tr><td align="justify">Number of edges</td><td align="left">0</td><td align="left">4,886</td><td align="left">10,868</td><td align="left">12,485</td><td align="left">17,823</td><td align="left">22,296</td><td align="left">73,652</td></tr></tbody></table><table-wrap-foot><p>The compression is related to the similarity of the sequences, as sequences that only differ by few bases will only require a few additional nodes. (Additional file <xref rid="MOESM3" ref-type="media">3</xref>)</p></table-wrap-foot></table-wrap>
</p>
    </sec>
    <sec id="Sec9">
      <title>Available graph functions &amp; toolkit</title>
      <p>The structure used by GenGraph and the provided functions makes writing code simple for anyone that is familiar to Python. While the toolkit provides options to create genome graphs and extract sequences using command line, the GenGraph module provides access to functions and methods that can be used to create new tools or conduct analyses.</p>
      <sec id="Sec10">
        <title>Use case 1: Identifying conserved regions</title>
        <p>The following code can be used to identify the largest uninterrupted sequence common to all the isolates in the provided genome graph. These conserved regions may contain core genes required for survival and are often drug target candidates.</p>
        <p>
          <graphic position="anchor" xlink:href="12859_2019_3115_Figa_HTML" id="MO4"/>
        </p>
        <p>The inverse can be done, finding all nodes with length less than 3 bp and belonging to only one isolate. This will represent isolate specific SNPs that could be useful to explain unique characteristics, for example in the case of a genome graph composed of 10 harmless and one pathogenic strain. This process would be far more difficult using multiple vcf files and reference genomes, particularly if mutations are found in genes that are not found in the reference genome.</p>
      </sec>
      <sec id="Sec11">
        <title>Use case 2: Comparing genes between isolates</title>
        <p>A common task is the comparison of genes from different isolates, and describing how they differ. First we extract the carB gene in the MTB isolate H37Rv.</p>
        <p>
          <graphic position="anchor" xlink:href="12859_2019_3115_Figb_HTML" id="MO5"/>
        </p>
        <p>This subgraph contains the sequence of the carB gene. If the graph has only one node, and all of the isolates are found in the node ’ids’ list, then all of the isolates have the same gene with no mutations. A user could then iterate though all genes in an annotation file, and identify those conserved across all strains to identify a core genome. If there is more than one node, or not all isolates are represented in that node, further investigation can be done by adding another attribute to each node representing the sequence length, and then exporting the subgraph for visualisation in Cytoscape [<xref ref-type="bibr" rid="CR10">10</xref>].</p>
        <p>
          <graphic position="anchor" xlink:href="12859_2019_3115_Figc_HTML" id="MO6"/>
        </p>
        <p>With a few simple lines of Python, we are able to compare genes across different isolates, visualising interesting differences (Fig. <xref rid="Fig4" ref-type="fig">4</xref>). With more complex code, functions that calculate sequence similarity between isolates can be created, and allow for the identification of homologues to be done. This has been used in the creation of a homology matrix, which is useful for interpreting results from isolates with poor or missing annotations. The homology matrix created by GenGraph allows mapping of gene IDs between isolates to identify orthologues in a gene-order aware manner. As orthologues are identified by their relative position within in the graph, and not by their sequence similarities, the correct orthologues of genes with multiple paralogues such as the PE/PPE genes in <italic>M. tuberculosis</italic> are identified. Additional tools for cladogram construction and pan-transcriptome extraction have been created that take advantage of the genome graph structure in a similar manner and are outlined on the GenGraph GitHub page under the Wiki.
<fig id="Fig4"><label>Fig. 4</label><caption><p>Plot of exported subgraph. <bold>a</bold>, Cytoscape allows for the styling of imported networks, and by mapping the node width to the sequence length it is simple to visualise which nodes represent insertions. Nodes can be coloured by which isolates they contain, in this case Beijing isolates were represented by red nodes, H37Rv by blue nodes, and purple nodes represent nodes shared by all isolates. <bold>b</bold>, For more detail on nodes of interest, a table listing the node and edge attributes is also available</p></caption><graphic xlink:href="12859_2019_3115_Fig4_HTML" id="MO7"/></fig>
</p>
      </sec>
    </sec>
    <sec id="Sec12">
      <title>Comparisons</title>
      <p>GenGraph was made to be modular and built around the described genome graph structure. Although GenGraph currently uses a two stage graph genome creation pipeline the focus is not on assembly, support for cactus and de Bruijn graphs to be collapsed into the GenGraph structure will be provided in future releases, as well as importing of graphs created by vg. While cactus and de Bruijn graphs are useful for assembly and alignment, their structures are not intuitive to the majority of downstream users. The functionality provided by GenGraph provides support for the downstream use of genome graphs, and designed to make it easy for even novice programmers to start using genome graphs in their workflows, encouraging adoption and making the transition from fasta based reference thinking simpler. The structure of graphs used in GenGraph is most similar to the structure used in vg (<ext-link ext-link-type="uri" xlink:href="https://github.com/vgteam/vg/wiki/Visualization">https://github.com/vgteam/vg/wiki/Visualization</ext-link>) but differs in that vg is written in C++, and we believe a genome graph tool for Python would be more accessible for the research community.</p>
    </sec>
  </sec>
  <sec id="Sec13" sec-type="conclusion">
    <title>Conclusions</title>
    <p>GenGraph brings genome graphs into the world of Python, with a toolkit that allows users to create genome graphs using MSA tools. It is able to scale from small viral genomes to bacterial genomes on desktop computers, with further testing for large genomes already underway. GenGraph uses external alignment tools for the creation of the alignments used in generating the genome graph, making it able to utilise any existing or future alignment tools to boost its performance. Because only existing graph file formats are used, the graphs can be imported and visualised by common tools, including Cytoscape and R.</p>
    <p>To facilitate adoption, GenGraph includes a number of useful tools and functions in order to facilitate adoption into work flows, allowing users to quickly create code that carries out common tasks and analysis using genome graphs. Combined with an intuitive conceptual model and built for Python, one of the most widely used programming languages in the biological sciences, GenGraph provides a starting point for the development of a new generation of genome graph based tools.</p>
  </sec>
  <sec id="Sec14">
    <title>Availability and requirements</title>
    <p><bold>Project name</bold>: GenGraph<bold>Project home page</bold>: <ext-link ext-link-type="uri" xlink:href="https://github.com/jambler24/GenGraph">https://github.com/jambler24/GenGraph</ext-link><bold>Operating system(s)</bold>: Platform independent<bold>Programming language</bold>: Python 3<bold>Other requirements</bold>: NetworkX, Mauve, and Muscle. A docker image is also available in the github repository containing all these requirements.<bold>License</bold>: GNU LGPL<bold>Any restrictions to use by non-academics</bold>: No</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Additional material</title>
    <sec id="Sec15">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="12859_2019_3115_MOESM1_ESM.txt">
            <label>Additional file 1</label>
            <caption>
              <p>Example report file for the genome graph created by GenGraph. The report file is in.txt format and contains details of the generated genome graph.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
      <p>
        <supplementary-material content-type="local-data" id="MOESM2">
          <media xlink:href="12859_2019_3115_MOESM2_ESM.zip">
            <label>Additional file 2</label>
            <caption>
              <p>Genome graph containing five MTB genomes. The graph was created from the assemblies of six MTB isolates (Beijing, C, CDC1551, F11, H37Ra, H37Rv) from GenBank, and saved in GraphML format. This file is viewable in Cytoscape and may be imported using Python’s NetworkX package.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
      <p>
        <supplementary-material content-type="local-data" id="MOESM3">
          <media xlink:href="12859_2019_3115_MOESM3_ESM.png">
            <label>Additional file 3</label>
            <caption>
              <p>Graph showing the effect of sequence similarity on file size. To test the effect of different sequence similarities on the output file size, single base substitution mutations were simulated at different rates across 1 kb sequences. At 1 SNP per 1kb, there is only a slight increase in size as more sequences are added. This represents an upper estimate, as sequences were mutated independently, where as in related sequences some mutations would be shared and not require new nodes to be created. In the case of whole genomes, three closely related <italic>Mycobacterium tuberculosis</italic> KZN strains of 4.5 MB can be converted to a single 4.6 MB GraphML file.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>Not Applicable.</p>
    <sec id="d29e765">
      <title>Abreviations</title>
      <p>GFF: General feature format; GTF: Gene transfer format; MSA: Multiple sequence alignment; MTB: <italic>Mycobacterium tuberculosis</italic>; SNP: Single nucleotide polymorphism; SRA: Sequence read archive; VCF: Variant call format</p>
    </sec>
    <sec id="d29e773">
      <title>Publisher’s Note</title>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </sec>
    <sec id="d29e778">
      <title>Authors’ contributions</title>
      <p>JMA, bioinformatician, writing, developing the code for GenGraph; NM, corresponding author, technical supervision and assistance, proof reading, Bioinformatics component; SM, development of GenGraph functions. All authors have read and approved the manuscript.</p>
    </sec>
    <sec id="d29e783">
      <title>Funding</title>
      <p>This work was funded by the National Research Foundation of South Africa, grant number 86934. This was in the form of a bursary for Jon Mitchell Ambler while completing his PhD. The funders had no role in the creation of this software, decision to publish or preparation of the manuscript.</p>
    </sec>
    <sec id="d29e788" sec-type="data-availability">
      <title>Availability of data and materials</title>
      <p>The software is available along with a docker recipe on GitHub <ext-link ext-link-type="uri" xlink:href="https://github.com/jambler24/GenGraph">https://github.com/jambler24/GenGraph</ext-link>. Genome sequences used during the current study are available from the NCBI <ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov">https://www.ncbi.nlm.nih.gov</ext-link>.</p>
    </sec>
    <sec id="d29e803">
      <title>Ethics approval and consent to participate</title>
      <p>Not applicable.</p>
    </sec>
    <sec id="d29e808">
      <title>Consent for publication</title>
      <p>Not applicable.</p>
    </sec>
    <sec id="d29e813" sec-type="COI-statement">
      <title>Competing interests</title>
      <p>The authors declare that they have no competing interests.</p>
    </sec>
  </ack>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <mixed-citation publication-type="other">VG Team. Variant Graph. <ext-link ext-link-type="uri" xlink:href="https://github.com/vgteam/vg/">https://github.com/vgteam/vg/</ext-link>. Accessed 10 Dec 2018.</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <mixed-citation publication-type="other">Sheikhizadeh S, Schranz ME, Akdel M, de Ridder D, Smit S. PanTools: representation, storage and exploration of pan-genomic data. Bioinformatics. 2016; 32(17):487–93. 10.1093/bioinformatics/btw455.</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <mixed-citation publication-type="other">Gonnella G, Kurtz S. GfaPy: A flexible and extensible software library for handling sequence graphs in Python. Bioinformatics. 2017; 33(19):3094–5. 10.1093/bioinformatics/btx398.</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <mixed-citation publication-type="other">Paten B, Novak AM, Eizenga JM, Garrison E. Genome graphs and the evolution of genome inference. Genome Res. 2017; 27(5):665–76. 10.1101/gr.214155.116.</mixed-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <mixed-citation publication-type="other">Darling AE, Mau B, Perna NT. Progressivemauve: Multiple genome alignment with gene gain, loss and rearrangement. PLoS ONE. 2010; 5(6). 10.1371/journal.pone.0011147.</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <mixed-citation publication-type="other">Edgar RC. MUSCLE: Multiple sequence alignment with high accuracy and high throughput. Nucleic Acids Res. 2004; 32(5):1792–7. 10.1093/nar/gkh340.</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <mixed-citation publication-type="other">Katoh K, Kuma KI, Toh H, Miyata T. MAFFT version 5: Improvement in accuracy of multiple sequence alignment. Nucleic Acids Res. 2005; 33(2):511–8. 10.1093/nar/gki198.</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <mixed-citation publication-type="other">Sievers F, Wilm A, Dineen D, Gibson TJ, Karplus K, Li W, Lopez R, McWilliam H, Remmert M, Söding J, Thompson JD, Higgins DG. Fast, scalable generation of high-quality protein multiple sequence alignments using Clustal Omega. Mol Syst Biol. 2011; 7(1):539. 10.1038/msb.2011.75.</mixed-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <mixed-citation publication-type="other">Shitikov EA, Bespyatykh JA, Ischenko DS, Alexeev DG, Karpova IY, Kostryukova ES, Isaeva YD, Nosova EY, Mokrousov IV, Vyazovaya Aa, Narvskaya OV, Vishnevsky BI, Otten TF, Zhuravlev VI, Zhuravlev VY, Yablonsky PK, Ilina EN, Govorun VM. Unusual large-scale chromosomal rearrangements in Mycobacterium tuberculosis Beijing B0/W148 cluster isolates. PLoS ONE. 2014; 9(1):84971. 10.1371/journal.pone.0084971.</mixed-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <mixed-citation publication-type="other">Shannon P, Markiel A, Ozier O, Baliga NS, Wang JT, Ramage D, Amin N, Schwikowski B, Ideker T. Cytoscape: A Software Environment for Integrated Models of Biomolecular Interaction Networks. Genome Res. 2003; 13(11):2498–504. 10.1101/gr.1239303.</mixed-citation>
    </ref>
  </ref-list>
</back>
