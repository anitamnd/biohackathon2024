<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6929406</article-id>
    <article-id pub-id-type="publisher-id">3272</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-019-3272-9</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>DTA-SiST: de novo transcriptome assembly by using simplified suffix trees</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Zhao</surname>
          <given-names>Jin</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Feng</surname>
          <given-names>Haodi</given-names>
        </name>
        <address>
          <email>fenghaodi@sdu.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zhu</surname>
          <given-names>Daming</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zhang</surname>
          <given-names>Chi</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Xu</surname>
          <given-names>Ying</given-names>
        </name>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1761 1174</institution-id><institution-id institution-id-type="GRID">grid.27255.37</institution-id><institution>School of Computer Science and Technology, Shandong University, </institution></institution-wrap>Binhai Road, Qingdao, Shandong People’s Republic of China </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2287 3919</institution-id><institution-id institution-id-type="GRID">grid.257413.6</institution-id><institution>Department of Medical and Molecular Genetics and Center for Computational Biology and Bioinformatics, Indiana University, </institution></institution-wrap>Indianapolis, IN USA </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1936 738X</institution-id><institution-id institution-id-type="GRID">grid.213876.9</institution-id><institution>Department of Biochemistry and Molecular Biology, University of Georgia, </institution></institution-wrap>Athens, GA USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>24</day>
      <month>12</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>24</day>
      <month>12</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <issue>Suppl 25</issue>
    <issue-sponsor>Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. The articles have undergone the journal's standard peer review process for supplements. The Supplement Editor declares that they have no competing interests.</issue-sponsor>
    <elocation-id>698</elocation-id>
    <permissions>
      <copyright-statement>© The Author(s) 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">Alternative splicing allows the pre-mRNAs of a gene to be spliced into various mRNAs, which greatly increases the diversity of proteins. High-throughput sequencing of mRNAs has revolutionized our ability for transcripts reconstruction. However, the massive size of short reads makes de novo transcripts assembly an algorithmic challenge.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">We develop a novel radical framework, called DTA-SiST, for de novo transcriptome assembly based on suffix trees. DTA-SiST first extends contigs by reads that have the longest overlaps with the contigs’ terminuses. These reads can be found in linear time of the lengths of the reads through a well-designed suffix tree structure. Then, DTA-SiST constructs splicing graphs based on contigs for each gene locus. Finally, DTA-SiST proposes two strategies to extract transcript-representing paths: a depth-first enumeration strategy and a hybrid strategy based on length and coverage. We implemented the above two strategies and compared them with the state-of-the-art de novo assemblers on both simulated and real datasets. Experimental results showed that the depth-first enumeration strategy performs always better with recall and also better with precision for smaller datasets while the hybrid strategy leads with precision for big datasets.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">DTA-SiST performs more competitive than the other compared de novo assemblers especially with precision measure, due to the read-based contig extension strategy and the elegant transcripts extraction rules.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Alternative splicing</kwd>
      <kwd>RNA-seq</kwd>
      <kwd>De novo assembly</kwd>
    </kwd-group>
    <conference xlink:href="http://ic-ic.tongji.edu.cn/2018/index.htm">
      <conf-name>2018 International Conference on Intelligent Computing (ICIC 2018) and Intelligent Computing and Biomedical Informatics (ICBI) 2018 conference</conf-name>
      <conf-loc>Wuhan and Shanghai, China</conf-loc>
      <conf-date>15-18 August 2018, 3-4 November 2018</conf-date>
    </conference>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Alternative splicing plays an important role in regulating gene expression and producing diversity of proteins. Through alternative splicing, the pre-mRNAs of a gene can be spliced into various mRNAs, which results in the large difference between the number of genes and that of proteins [<xref ref-type="bibr" rid="CR1">1</xref>, <xref ref-type="bibr" rid="CR2">2</xref>]. A transcript is defined as a mature mRNA that encodes protein. We call the set of all the transcripts the transcriptome. The transcriptome can be seen as a precursor of the proteome, i.e., the entire set of proteins expressed by a genome. Transcriptome reconstruction is an important mean for studying cell phenotype and function [<xref ref-type="bibr" rid="CR3">3</xref>]. However, this task is quite nontrivial. For the time being, we only know a small part of the landscape of alternative splicing of some species.</p>
    <p>The high-throughput sequencing has revolutionized our ability to study many challenging issues such as motif finding, DNA/RNA-protein interaction, ribosome profiling, small RNA expression profiling, transcripts assembly, and disease diagnosis [<xref ref-type="bibr" rid="CR4">4</xref>–<xref ref-type="bibr" rid="CR9">9</xref>]. The RNA sequencing (RNA-seq) offers a great opportunity to identify the expressed transcripts.</p>
    <p>There are generally two alternative computational strategies for transcriptome assembly problems: genome-guided approaches such as Scallop [<xref ref-type="bibr" rid="CR10">10</xref>], Cufflinks [<xref ref-type="bibr" rid="CR11">11</xref>], StringTie [<xref ref-type="bibr" rid="CR12">12</xref>], CIDANE [<xref ref-type="bibr" rid="CR13">13</xref>], Scripture [<xref ref-type="bibr" rid="CR14">14</xref>], IsoLasso [<xref ref-type="bibr" rid="CR15">15</xref>], and TransComb [<xref ref-type="bibr" rid="CR16">16</xref>], and de novo transcripts assembly approaches such as Trinity [<xref ref-type="bibr" rid="CR17">17</xref>], Oases [<xref ref-type="bibr" rid="CR18">18</xref>], SOAPdenovo-Trans [<xref ref-type="bibr" rid="CR19">19</xref>], IDBA-Tran [<xref ref-type="bibr" rid="CR20">20</xref>], BinPacker [<xref ref-type="bibr" rid="CR21">21</xref>], Bridger [<xref ref-type="bibr" rid="CR22">22</xref>], ABySS [<xref ref-type="bibr" rid="CR23">23</xref>], and IsoTree [<xref ref-type="bibr" rid="CR24">24</xref>]. Genome-guided assemblers are generally more accurate than de novo assemblers when the high-quality reference genome is available. However, the high-quality reference genome is not always available. In this situation, de novo transcriptome assembly is required. In this paper, we mainly consider de novo transcriptome assembly methods.</p>
    <p>Existing strategies for transcriptome assembly usually adopt the following scheme: first constructing graphs based on the RNA-seq reads, and then extracting paths from the graphs to represent plausible transcripts. Various algorithms are employed to recover transcript-representing paths. For example, Cufflinks [<xref ref-type="bibr" rid="CR11">11</xref>] and Bridger [<xref ref-type="bibr" rid="CR22">22</xref>] employ the minimum path cover algorithm to extract the minimum number of paths that cover all the vertices. StringTie [<xref ref-type="bibr" rid="CR12">12</xref>] applies the network flow algorithm on the splicing graphs to recover all the possible transcripts. Trinity [<xref ref-type="bibr" rid="CR17">17</xref>] extracts the sufficiently covered paths from the compact graphs based on a brute-force enumeration strategy. BinPacker [<xref ref-type="bibr" rid="CR21">21</xref>] models the paths in the splicing graphs as a set of trajectories of items by solving a series of bin-packing problems. Note that Cufflinks and StringTie belong to genome-guided approaches. They usually start by aligning reads to a reference genome, and then construct graphs according to alignment results. Trinity, Bridger, and BinPacker are de novo transcriptome assembly approaches, and they build graphs solely based on the overlaps of <italic>k</italic>-mers (<italic>k</italic>-character substrings of read sequences). To investigate the influence of path extracting strategies on the assemblers’ performances, DTA-SiST developed two strategies: a depth-first enumeration strategy and a hybrid strategy based on length and coverage. The first strategy aims to distinguish as many as possible transcripts while the second tries to target candidates more accurately. DTA-SiST implemented these two strategies and compared them with the state-of-the-art assemblers.</p>
    <p>Historically, the de novo assembly approaches mostly rely on the pioneering works on de Bruijn graphs [<xref ref-type="bibr" rid="CR25">25</xref>], including Trinity [<xref ref-type="bibr" rid="CR17">17</xref>], SOAPdenovo-Trans [<xref ref-type="bibr" rid="CR19">19</xref>], Oases [<xref ref-type="bibr" rid="CR18">18</xref>], IDBA-Tran [<xref ref-type="bibr" rid="CR20">20</xref>], and Trans-AByss [<xref ref-type="bibr" rid="CR23">23</xref>]. Recently, Bridger [<xref ref-type="bibr" rid="CR22">22</xref>], BinPacker [<xref ref-type="bibr" rid="CR21">21</xref>], and IsoTree [<xref ref-type="bibr" rid="CR24">24</xref>] applied splicing graphs [<xref ref-type="bibr" rid="CR26">26</xref>] to represent alternative splicing. Both de Bruijn graphs and splicing graphs are usually constructed by extending contigs with <italic>k</italic>-mers. Each node in a de Bruijn graph represents a <italic>k</italic>-mer while a node in a splicing graph usualls to an exon. Hence, the number of nodes in a splicing graph is far less than that of the nodes in a de Bruijn graph, which makes the models based on splicing graphs more tractable.</p>
    <p>The <italic>k</italic>-mer-based extension strategies extend a contig through a <italic>k</italic>-mer whose first (or last) <italic>k</italic>−1-character substring is exactly the same as the last (or first) <italic>k</italic>−1-character substring of the contig. For convenience, we say that the <italic>k</italic>-mer has a <italic>k</italic>−1-character <italic>overlap with the contig’s ternimus</italic>. For example, suppose the contig sequence is ACATCG, and the <italic>k</italic>-mer set contains the <italic>k</italic>-mers of TACA, ACAT, CATC, ATCG, and TCGG. Since the last 3-character substring of TACA is exactly the same as the first 3-character substring of the contig, i.e., the <italic>k</italic>-mer of TACA has a 3-character overlap with the contig’s terminus, the contig can be extended by TACA to TACATCG. Similarly, the first 3-character substring of TCGG is exactly the same as the last 3-character substring of the contig. Through TCGG, the contig of TACATCG can be extended to TACATCGG. By applying a hash table to hold the <italic>k</italic>-mers with their original reads’ IDs as their corresponding values, the <italic>k</italic>-mer-based strategies can find the candidate <italic>k</italic>-mers quickly. However, since a <italic>k</italic>-mer may originate from quite a few different reads which may easily lead to a wrong extension, these strategies deny making full use of the information of the whole nucleotides arrangement in each read. Although the <italic>k</italic>-mer-based contig extension strategy has been widely used in de novo assemblers, both the accuracy and sensitivity are still far from meeting the requirement.</p>
    <p>Some multiple-<italic>k</italic> strategies have been developed such as Oases-M [<xref ref-type="bibr" rid="CR18">18</xref>], IDBA-Tran [<xref ref-type="bibr" rid="CR20">20</xref>], and Bridger-M [<xref ref-type="bibr" rid="CR22">22</xref>], but the problem is not solved basically since these works just intuitively tried several <italic>k</italic> values one after another without fully considering the variances of the lengths of the actual overlaps between reads. In our last work IsoTree [<xref ref-type="bibr" rid="CR24">24</xref>, <xref ref-type="bibr" rid="CR27">27</xref>], we proposed a method to find the candidate reads that have the longest overlap to the contig’s terminus. But the method needs to try all the candidate reads that may have overlaps of lengths between <italic>L</italic>−1 and <italic>x</italic> with the contig’s terminus, which is time consuming and a little tedious. Here, <italic>L</italic> is the length of reads, and <italic>x</italic> is the length of the longest overlap between the contig’s terminus and the available reads. In this work, we introduce a more straightforward contig extension strategy that extends a contig by the read that has the longest overlap with the contig’s terminus. Through the suffix trees of reads, we can find the candidate reads that have the longest overlap with a contig’s terminus in <italic>O</italic>(<italic>L</italic>) time by just scanning the first (for left extension) or the last (for right extension) <italic>L</italic>−1 characters of the contig once.</p>
    <p>In the rest of this work, the methods of constructing suffix trees and splicing graphs as well as the algorithms of extracting transcript-representing paths from splicing graphs are first introduced. Then, the experimental results and discussions are presented. The final conclusions are given in the end.</p>
  </sec>
  <sec id="Sec2">
    <title>Methods</title>
    <sec id="Sec3">
      <title>Suffix tree construction</title>
      <p>Traditional <italic>k</italic>-mer-based extension strategies build overlapping <italic>k</italic>-mers from reads and extend contigs by <italic>k</italic>-mers, which can only guarantee <italic>k</italic>−1-character overlaps between contigs and <italic>k</italic>-mers. The whole nucleotides arrangements of reads are usually ignored in <italic>k</italic>-mer-based extension strategies. Obviously, extending contigs by reads is more credible than extending contigs by <italic>k</italic>-mers, especially for long reads. However, it is much more complicated to find a read that holds the longest overlap to the current contig’s terminus than to find a <italic>k</italic>-mer that overlaps the current contig’s terminus by exactly <italic>k</italic>−1 characters. The latter can be conveniently realized by using hash tables. Some multiple-<italic>k</italic> strategies have been developed to overcome the shortage of single-<italic>k</italic> strategies by trying several <italic>k</italic> values. But these intuitive designs were far from the real sense that reads may overlap with each other by different numbers of characters. In order to make full use of nucleotide arrangements of reads, DTA-SiST presents a read-based contig extension strategy. The main point is that DTA-SiST applies a suffix tree structure to quickly find the candidate reads.</p>
      <p>To facilitate the contig extension from 5’ to 3’, DTA-SiST builds a suffix tree, called right extension suffix tree (REST). Although the beginning of the maximum overlap between the current contig’s 3’ terminus and the candidate reads is unknown, the ending of the maximum overlap is known. The maximum overlap is actually a prefix of the candidate reads. Consequently, DTA-SiST reverses all the read sequences and constructs a suffix tree for the <italic>l</italic>∼<italic>L</italic>−1 character suffixes of all the reverse reads, where <italic>l</italic> denotes the predefined minimum overlap length and <italic>L</italic> represents the read length. In the right extension suffix tree, the path from the root node to each node represents a substring of some reverse reads. If the <italic>x</italic>-length (<italic>l</italic>≤<italic>x</italic>≤<italic>L</italic>−1) path from the root node to the node <italic>v</italic> represents a suffix of the reverse read of <italic>r</italic>, DTA-SiST stores the read id <italic>r</italic> in the node <italic>v</italic> (as shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref>).
<fig id="Fig1"><label>Fig. 1</label><caption><p>Right extension suffix tree. An example for adding the suffixes of a reverse read to the right extension suffix tree</p></caption><graphic xlink:href="12859_2019_3272_Fig1_HTML" id="MO1"/></fig></p>
      <p>Similarly, DTA-SiST constructs a left extension suffix tree (LEST) to facilitate the contig extension from 3’ to 5’. In this case, the maximum overlap is actually a suffix of candidate reads and the start point of the overlap is known. Hence, the left extension suffix tree consists exactly of the <italic>l</italic>∼<italic>L</italic>−1 character suffixes of all the reads. An example for adding a read to the left extension suffix tree is shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>.
<fig id="Fig2"><label>Fig. 2</label><caption><p>Left extension suffix tree. An example for adding the suffixes of a read to the left extension suffix tree</p></caption><graphic xlink:href="12859_2019_3272_Fig2_HTML" id="MO2"/></fig></p>
      <p>Through the suffix trees constructed with the above method, DTA-SiST gets the candidate reads that hold the longest overlap with current contig’s terminus in <italic>O</italic>(<italic>L</italic>) time by scanning prefix of the contig (for left extension, right extension is processed similarly) along the edges in the left extension tree as far as possible and then moving back to find the reads’ IDs stored in the nearest node. Suppose there are totally <italic>N</italic> reads. In theory, the suffix trees will take up <italic>O</italic>(<italic>M</italic>+<italic>N</italic>(<italic>L</italic>−<italic>l</italic>)) space, where <italic>M</italic> is the size of all the suffixes. Notice that <italic>M</italic> can be up to <italic>O</italic>(<italic>N</italic>(<italic>L</italic>+<italic>l</italic>)(<italic>L</italic>−<italic>l</italic>)) supposing that all the suffixes are different. The space of the suffix trees can be divided into two parts, one is to store the reads’ IDs, and the other is to store the tree structure. In order to reduce the space consumed in storing reads’ IDs, we compress the reads with the same sequence into one read and assign them the same ID. After numerous experiments, we found that many vertices and reads’ IDs stored in the suffix trees are useless. The reason is that not all the suffixes (or prefixes) of reads can match contigs’ 5’ (or 3’) terminuses, and thus they will never be used in the left (or right) extension. If the suffix (or prefix) of a read can be used in the left (or right) extension, this suffix (or prefix) must be a prefix (or suffix) of another read. Based on this observation, we construct the simplified suffix trees with the following steps. The idea is that we first extract all the <italic>L</italic>−1-character prefixes of all the reads. Then we check and store the suffixes with lengths of <italic>l,l</italic>+1,...,<italic>L</italic>−1 that overlap with these prefixes and thus get the left extension suffix tree LEST. Finally, we check and store the prefixes with lengths of <italic>l,l</italic>+1,...,<italic>L</italic>−1 that overlap with the suffixes in the LEST and thus get the right extension suffix tree REST. As defined before, the prefixes stored in the REST are actually their reversals.</p>
      <p><bold>step 1:</bold> Initialize the left extension suffix tree LEST structure by the <italic>L</italic>−1-character prefixes of all the reads. If a suffix is usable in the left extension, it must overlap with a <italic>L</italic>−1-character prefix of reads. Hence, the tree constructed with the <italic>L</italic>−1-character prefixes covers all the usable suffixes.</p>
      <p>Figure <xref rid="Fig3" ref-type="fig">3</xref> gives an example to construct the simplified suffix trees. As shown in this figure, there are total of four reads, i.e., Read1 as sequence CATTC, Read2 as sequence ATTCT, Read3 as sequence AGCTC, and Read4 as sequence TCCAT. The length of these reads is 5<italic>b</italic><italic>p</italic> (<italic>L</italic>=5), and the minimum overlap length is 2<italic>b</italic><italic>p</italic> (<italic>l</italic>=2). The 4-character prefixes of these reads are used to construct the tree structure.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Simplified suffix tree. An example for constructing the simplified suffix trees. In this example, there are total of four reads. The read length is 5<italic>b</italic><italic>p</italic>, and the minimum overlap length is 2<italic>b</italic><italic>p</italic></p></caption><graphic xlink:href="12859_2019_3272_Fig3_HTML" id="MO3"/></fig></p>
      <p><bold>step 2:</bold> Add reads’ IDs to the left extension suffix tree. If one suffix (whose length is between <italic>l</italic> and <italic>L</italic>−1) of read <italic>r</italic> follows a path from the root node to node <italic>v</italic> in the LEST, DTA-SiST stores the read id <italic>r</italic> in the node <italic>v</italic>.</p>
      <p>In the above example (Fig. <xref rid="Fig3" ref-type="fig">3</xref>), the suffixes with lengths 4,3,2 of Read1 are ATTC, TTC, and TC, respectively. DTA-SiST first scans the 4-character suffix (ATTC) in the left extension suffix tree. DTA-SiST finds that there is a path from the root node in the tree that exactly corresponds to ATTC, and DTA-SiST adds the ID of Read1 into the left extension suffix tree. Then, DTA-SiST scans the 3-character suffix (TTC) and the 2-character suffix (TC) in the left extension suffix tree successively. Since there is no path from the root node in the left extension suffix tree marked as TTC while there is one marked as TC, DTA-SiST adds the ID of Read1 only in the node corresponding to path TC. Similarly, DTA-SiST adds the IDs of the other reads into the left extension suffix tree.</p>
      <p><bold>step 3:</bold> Trim the left extension suffix tree. DTA-SiST iteratively deletes the leaf nodes without reads’ IDs.</p>
      <p>As shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref>, the leaf nodes without reads’ IDs are iteratively removed. Through the trimming operations, the number of nodes in the left extension suffix tree is reduced from 16 to 10.</p>
      <p><bold>step 4:</bold> Construct the right extension suffix tree REST based on the left extension suffix tree. DTA-SiST scans each <italic>x</italic>-character (<italic>l</italic>≤<italic>x</italic>≤<italic>L</italic>−1) prefix of all the reads to check whether it matches a path from the root to a node with some stored read IDs in the left extension suffix tree. If yes, DTA-SiST will reverse the prefix, add the reversal sequence into the right extension suffix tree, and store the corresponding read’s ID in the corresponding node.</p>
      <p>In the above example (Fig. <xref rid="Fig3" ref-type="fig">3</xref>), the 2,3,4-character prefixes of Read1 are CA, CAT, and CATT, respectively. DTA-SiST first scans the 2-character prefix (CA) in the left extension suffix tree. Although there is a path from the root node marked CA, but the ending node of the path contains no IDs which means that CA is only part of a usable suffix. In this case, DTA-SiST will not add the ID of Read1 but continue to scan the 3-character prefix (CAT). Since CAT matches a path from the root node in the left extension suffix tree and the ending node of the path contains reads’ IDs, DTA-SiST reverses CAT to TAC and adds TAC as well as the ID of Read1 to the right extension suffix tree. Then, DTA-SiST scans the 4-character prefix (CATT) in the left extension suffix tree similarly. The prefixes of the other reads are processed in the same way.</p>
      <p><bold>step 5:</bold> Compress the left extension suffix tree and the right extension suffix tree. In order to save the space and improve the speed, each <italic>l</italic>-character path from the root node is compressed into one node and stored as a 64-bit unsigned integer each.</p>
      <p>As shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref>, through the compressing operation, the number of nodes in the left extension suffix tree is reduced from 10 to 7.</p>
      <p>With these improvements on the suffix trees, the memory cost by DTA-SiST is comparable to that cost by the hash table data structure as shown in Table <xref rid="Tab1" ref-type="table">1</xref>. Note that in theory, the hash table for single <italic>k</italic>-mer representation takes up a memory of <italic>O</italic>(<italic>N</italic>(<italic>L</italic>−<italic>k</italic>+1)), and the simplified suffix tree takes up a memory of <italic>O</italic>(<italic>N</italic><sup>′</sup>(<italic>L</italic>−<italic>l</italic>)), where <italic>N</italic><sup>′</sup>(<italic>N</italic><sup>′</sup>≤<italic>N</italic>) is the number of reads with usable suffixes or prefixes. As mentioned above, the memory of the trees is spent in storing the tree structures and reads’ IDs. Since the initial left extension suffix tree structure is constructed from the <italic>L</italic>−1-character prefixes of all the reads and that the <italic>l</italic>-character paths from the root node are compressed into one node each, there are at most <italic>O</italic>(<italic>N</italic><sup>′</sup>(<italic>L</italic>−<italic>l</italic>)) nodes in the tree. The memory that is used to store the reads’ IDs can be up to <italic>O</italic>(<italic>N</italic><sup>′</sup>(<italic>L</italic>−<italic>l</italic>)) supposing that all the suffixes of these <italic>N</italic><sup>′</sup> reads are usable. The same results can be drawn for the right extension suffix tree. Note that the hash table for multiple <italic>k</italic>-mer representation takes up a memory of <italic>O</italic>(<italic>M</italic><sup>′</sup>+<italic>N</italic>(<italic>L</italic>−<italic>l</italic>)<sup>2</sup>), where <italic>M</italic><sup>′</sup> is the size of all the <italic>l</italic>+1,<italic>l</italic>+2,...,<italic>L</italic>-mers if we use hash table of all these substrings to find the <italic>k</italic>-mers that have the <italic>longest</italic> overlaps with the contigs’ terminuses. Notice that <italic>M</italic><sup>′</sup> is quite larger than <italic>M</italic>, the size of all the <italic>l,l</italic>+1,...,<italic>L</italic>−1-suffixes. We compared the memories occupied by the suffix trees, the hash table of <italic>k</italic>-mers with single length of <italic>l</italic>+1, and hash table of <italic>k</italic>-mers with multiple lengths of <italic>l</italic>+1,<italic>l</italic>+2,...,<italic>L</italic>.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Comparison of memory occupied by different strategies</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Reads</th><th align="left">50bp</th><th align="left">75bp</th><th align="left">100bp</th><th align="left">50bp</th><th align="left">50bp</th></tr><tr><th align="left"/><th align="left">0.1million</th><th align="left">0.1million</th><th align="left">0.1million</th><th align="left">0.5million</th><th align="left">1million</th></tr></thead><tbody><tr><td align="left">Suffix tree</td><td align="left">68.3M</td><td align="left">143.5M</td><td align="justify">220.5M</td><td align="left">85.1M</td><td align="justify">94.3M</td></tr><tr><td align="left">Single-<italic>k</italic></td><td align="left">20.8M</td><td align="left">34.7M</td><td align="justify">49.2M</td><td align="left">78.5M</td><td align="justify">149.3M</td></tr><tr><td align="left">Multiple-<italic>k</italic></td><td align="left">286.0M</td><td align="left">572.9M</td><td align="justify">899.5M</td><td align="left">445.9M</td><td align="justify">640.6M</td></tr></tbody></table></table-wrap></p>
      <p>Table <xref rid="Tab1" ref-type="table">1</xref> shows that the simplified suffix tree strategy occupies comparable memory as that used by the single-<italic>k</italic> strategy while the multiple-<italic>k</italic> strategy costs much more. Notice that multiple-<italic>k</italic> strategy is impractical in finding the best candidate that has the longest overlap with the contig’s terminus due to its memory usage for real data (notice that multiple-<italic>k</italic> strategies such as Oases-M [<xref ref-type="bibr" rid="CR18">18</xref>], IDBA-Tran [<xref ref-type="bibr" rid="CR20">20</xref>], and Bridger-M [<xref ref-type="bibr" rid="CR22">22</xref>] basically just repeated the single-<italic>k</italic> strategy for several different <italic>k</italic> values, which are excluded from discussion here). As shown in Table <xref rid="Tab1" ref-type="table">1</xref>, the memory occupied by these three strategies is significantly correlated with the read length and the data size. These three strategies cost the most memory on the sample that contains 0.1 million reads with length of 100bp, which indicates that the read length greatly affects the memory usage. Table <xref rid="Tab1" ref-type="table">1</xref> also shows an interesting phenomenon that the simplified suffix tree strategy occupies less memory than the single-<italic>k</italic> strategy and the multiple-<italic>k</italic> strategy on the sample that contains 1 million reads with length of 50bp. We attribute the surprising performance of the simplified suffix tree strategy on this sample to the operation of compressing the reads with the same sequence into one read. With the increase of data size, the number of reads with the same sequence increases. The read compression step significantly reduced the data size of this sample.</p>
    </sec>
    <sec id="Sec4">
      <title>Splicing graph construction</title>
      <p>The splicing graph used by DTA-SiST is similar to that defined in Bridger [<xref ref-type="bibr" rid="CR22">22</xref>], BinPacker [<xref ref-type="bibr" rid="CR21">21</xref>], and IsoTree [<xref ref-type="bibr" rid="CR24">24</xref>]. A splicing graph is a directed acyclic graph, in which the vertex represents a part of an exon or an exon. An edge exists between two vertices only if these two vertices come from a same transcript. Simple paths in such graphs usually represent plausible transcripts or parts of them.</p>
      <p>Briefly, DTA-SiST constructs splicing graphs as follows: DTA-SiST first sets the reads whose coverage exceeds the average as seeds, and then selects an unused seed as the main contig and extends the contig with help of the suffix trees. DTA-SiST explores the suffix trees along the edges marked with the characters scanned from the endpoints of the contig successively to get the candidate read that holds the longest overlap with the current contig’s terminus. When there are multiple candidate reads, DTA-SiST selects the candidate read whose coverage is closest to that of the contig. DTA-SiST repeats the above candidates selection and extension steps until there are no candidate reads that hold at least <italic>l</italic>-character overlaps with the contig’s terminus. When the contig cannot be extended in either direction, DTA-SiST makes the branch extensions to construct splicing variants. DTA-SiST applies a similar strategy described in our previous work [<xref ref-type="bibr" rid="CR24">24</xref>] to construct splicing variants and trim the splicing graph.</p>
      <p>Figure <xref rid="Fig4" ref-type="fig">4</xref> gives an example for extending contigs by reads under the help of right extension suffix tree and left extension suffix tree. For the left extension (from 3’ to 5’): DTA-SiST searches the left extension suffix tree with characters from 5’ to 3’ successively, i.e., 8 (simplified code for GA), G, T, T, C, G, ⋯. There is a path of 8(GA)GTTC in the left extension suffix tree but no path of 8(GA)GTTCG. Hence, 8(GA)GTTC is the maximum overlap of reads with the contig’s 5’ terminus. DTA-SiST takes out the read id (<italic>a</italic>) stored in the last node in the path of 8(GA)GTTC and extends the contig by the read <italic>a</italic>. Similarly, DTA-SiST can find the candidate reads that hold the maximum overlap with the contig’s 3’ terminus through the right extension suffix tree. The contig is then extended in right direction.
<fig id="Fig4"><label>Fig. 4</label><caption><p>Contig extension. An example for extending contigs by reads under the help of right extension suffix tree and left extension suffix tree</p></caption><graphic xlink:href="12859_2019_3272_Fig4_HTML" id="MO4"/></fig></p>
      <p>The main difference between DTA-SiST and IsoTree for contig extension is the method of finding the candidate reads that hold the longest overlaps with the contig’s terminus. IsoTree extracts the candidates by trying the overlap lengths from <italic>L</italic>−1 to <italic>l</italic>. To get the reads that hold <italic>x</italic>-character overlaps with contig’s terminus, IsoTree first sets the first and the last <italic>k</italic>-mers of the <italic>x</italic>-character terminus as tags. Then, IsoTree searches the hash table to find the reads that contain these two tags in <italic>O</italic>(<italic>a</italic><sub><italic>x</italic></sub>+<italic>b</italic><sub><italic>x</italic></sub>) time, where <italic>a</italic><sub><italic>x</italic></sub> and <italic>b</italic><sub><italic>x</italic></sub> are the numbers of reads that contain the two tags, respectively. If an obtained read exactly has a <italic>x</italic>-character overlap with the contig’ terminus, it is identified as a candidate read. Once a candidate read is obtained, no smaller overlap length will be further tried. Thus, if the maximum overlap length is <italic>x</italic>, IsoTree will cost <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$O(N\sum \limits _{i = L-1}^{x}{(a_{i}+b_{i})i})$\end{document}</tex-math><mml:math id="M2"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>N</mml:mi><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:munderover><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_3272_Article_IEq1.gif"/></alternatives></inline-formula> time to find the candidate reads. Notice that DTA-SiST can find the candidate that has the longest overlap with the contig’s terminus in <italic>O</italic>(<italic>L</italic>) time for each extension and thus <italic>O</italic>(<italic>NL</italic>) in total. The suffix tree strategy is more time-saving considering that the time for building the suffix trees is <italic>O</italic>(<italic>N</italic>(<italic>L</italic>+<italic>l</italic>−1)(<italic>L</italic>−<italic>l</italic>)), which is usually far smaller than <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$O(N\sum \limits _{i = L-1}^{x}{(a_{i}+b_{i})i})$\end{document}</tex-math><mml:math id="M4"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>N</mml:mi><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:munderover><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_3272_Article_IEq2.gif"/></alternatives></inline-formula>. Besides, although DTA-SiST needs more memory to hold the suffix trees, its memory consumption is endurable as described in “<xref rid="Sec6" ref-type="sec">Results</xref>” section.</p>
    </sec>
    <sec id="Sec5">
      <title>Transcripts assembly</title>
      <p>In the transcript-representing path detection step, most of researchers formulated it as an optimization problem with objective of either extracting the minimum number of paths to cover the whole graph or ensuring the minimum gaps between the coverage of the edges entering and leaving the nodes. Wondering whether the real world follows these optimization principles, we developed two new strategies for transcript-representing path extraction.</p>
      <p>In order to detect as many transcripts as possible, DTA-SiST develops a depth-first enumeration strategy to recover all the possible transcripts that can be represented by the splicing graph. Besides, DTA-SiST develops a strict criterion to exclude the fake transcripts (these rules are generally adopted in most transcript-assembly methods): (i) the transcript sequence should be longer than 200bp (by default); (ii) the coverage of each transcript must be larger than 2 (by default); (iii) at least 20 reads (by default) can be mapped to the transcript; (iv) the whole transcript sequence must be covered by paired-end reads when paired-end reads are available.</p>
      <p>Additionally, considering that thicker paths (paths with higher coverage) are more likely to be transcripts, DTA-SiST proposes a hybrid strategy to extract the longest path among the thickest paths. The hybrid strategy iteratively extracts paths with the compromise of length and thickness by a dynamic programming method until all the edges are covered by these paths or a predefined condition is met. The hybrid strategy based on length and coverage is also a good juxtapose to evaluate the depth-first enumeration strategy.</p>
      <p>In the following discussion, let <italic>G</italic>(<italic>V,E</italic>) denote the splicing graph. DTA-SiST adds a source vertex <italic>s</italic> and a sink vertex <italic>t</italic> into the graph, and connects <italic>s</italic> (or <italic>t</italic>) with the vertices without incoming edges (or outgoing edges). DTA-SiST applies the function <italic>w</italic>(<italic>node</italic>) (or <italic>w</italic>(<italic>edge</italic>)) to weigh the vertex sequences (or the edge sequences) by the number of reads per base. Specifically, DTA-SiST assigns the weight of edge (<italic>s,v</italic>) as the weight of node <italic>v</italic>, assigns the weight of edge (<italic>u,t</italic>) as the weight of node <italic>u</italic>, assigns the weight of node <italic>s</italic> as the sum of the weights of edges leaving node <italic>s</italic>, and assigns the weight of node <italic>t</italic> as the sum of the weights of edges entering node <italic>t</italic>.</p>
      <p><bold>Depth-first enumeration strategy.</bold> DTA-SiST enumerates the paths from the source vertex <italic>s</italic> to the sink vertex <italic>t</italic> by a depth-first search strategy (Algorithm 1). The algorithm starts from the source vertex <italic>s</italic>, and iteratively traverses an unexplored edge leading from a vertex already reached. Once it encounters the sink vertex <italic>t</italic>, the algorithm will output the path. The algorithm uses a stack to store the nodes on the current depth-first search path, so that the path can be extracted by scanning the stack. The algorithm has a time bound of <italic>O</italic>((<italic>V</italic>+<italic>E</italic>)<italic>p</italic>), where <italic>p</italic> is the number of paths starting from <italic>s</italic>.
<graphic position="anchor" xlink:href="12859_2019_3272_Figa_HTML" id="MO7"/></p>
      <p><bold>The hybrid strategy based on length and coverage.</bold> DTA-SiST iteratively calls Algorithm 2 to find the longest path from the paths that are extracted with the maximum coverage strategy until the path meets a pre-given empirical condition. Once a path is derived, it will be deleted from the splicing graph, i.e., the coverage of all the edges and vertices along the path will be reduced by the minimum coverage of the edges and vertices along the path. The time consumed by this strategy is <italic>O</italic>((<italic>V</italic>+<italic>E</italic>)<italic>E</italic>).
<graphic position="anchor" xlink:href="12859_2019_3272_Figb_HTML" id="MO8"/></p>
      <p>As shown in Algorithm 2, it introduces <italic>π</italic>[<italic>v</italic>] to denote the predecessor of vertex <italic>v</italic>. By using backtracking, a path with the compromise of length and thickness can be extracted in one iteration according to <italic>π</italic>[<italic>v</italic>]. For each node <italic>v</italic> in topological order, <italic>capacity</italic>(<italic>v</italic>) denotes the maximum coverage among all the paths that start from vertex <italic>s</italic> and end at vertex <italic>v</italic>, where the coverage of a path is defined as the minimum weight among all the vertices and edges in the path. Algorithm 2 computes the <italic>capacity</italic>(<italic>v</italic>) for each vertex <italic>v</italic> in topological order in a dynamic way until it has computed <italic>capacity</italic>(<italic>t</italic>). Besides, the variable <italic>l</italic>[<italic>v</italic>] denotes the length of the path from vertex <italic>s</italic> to vertex <italic>v</italic>.</p>
    </sec>
  </sec>
  <sec id="Sec6" sec-type="results">
    <title>Results</title>
    <p>We realized DTA-SiST in two versions: DTA-SiST-E and DTA-SiST-H corresponding to the depth-first enumeration strategy and the hybrid strategy based on length and coverage, respectively. We compared them with six state-of-the-art de novo assemblers including IsoTree (version 1.0), Trinity (version 2.3.2), BinPacker (version 1.0), SOAPdenovo-Trans (version 1.03), IDBA-Tran (version 1.1.1), and Oases (version 0.2.8) on both simulated and real datasets. We carried out the experiments on a server with 256GB of RAM and E5-2620V3*2 CPU processor.</p>
    <sec id="Sec7">
      <title>Datasets</title>
      <p>In order to explore the sensitivity of assemblers on the length of reads, we used FluxSimulator [<xref ref-type="bibr" rid="CR28">28</xref>] to simulate 11 samples with read lengths of 50<italic>bp</italic>,60<italic>b</italic><italic>p</italic>,70<italic>b</italic><italic>p</italic>,80<italic>b</italic><italic>p</italic>,90<italic>b</italic><italic>p</italic>,100<italic>b</italic><italic>p</italic>,110<italic>b</italic><italic>p</italic>,120<italic>b</italic><italic>p</italic>,130<italic>b</italic><italic>p</italic>,140<italic>b</italic><italic>p</italic>, and 150<italic>b</italic><italic>p</italic>, respectively. The only difference between these simulated samples is the length of reads. Each sample contains 0.1 million paired-end reads that are generated from 100 isoform transcripts originated from 41 different genes in chromosome 1 (CRCh38.83, NCBI).</p>
      <p>We retrieved a dog dataset and a human dataset from NCBI SRA database, with Accession Code SRX295047 and SRR3692633, respectively. In the dog dataset, there are totally 30968059 paired-end reads with length of 50<italic>b</italic><italic>p</italic>. The human dataset contains total of 43675886 paired-end reads with length of 75<italic>b</italic><italic>p</italic>. The reads both in the dog dataset and the human dataset are single strand-specific. Besides, we obtained total of 62516 and 46993 annotated transcripts from UCSC for dogs and humans, respectively.</p>
    </sec>
    <sec id="Sec8">
      <title>Evaluation criteria</title>
      <p>In this paper, we aligned transcripts predicted by assemblers to annotated transcripts by blast+ [<xref ref-type="bibr" rid="CR29">29</xref>]. We define the full-length reconstructed transcript as an assembled transcript that holds at least 95% sequence identity to an annotated transcript. The full-length identified transcript represents an annotated transcript with at least 95% sequence covered by an assembled transcript.</p>
      <p>On the simulated datasets, we applied recall and precision to measure the performances of the de novo assemblers. The recall is defined as the ratio between the number of full-length identified transcripts and the number of annotated transcripts, while the precision is defined as the ratio between the number of full-length reconstructed transcripts and the number of assembled transcripts.</p>
      <p>As the annotated transcripts of the real datasets are usually not the ground truth expressed transcripts, the recall and precision defined above are not suitable to the real datasets [<xref ref-type="bibr" rid="CR10">10</xref>, <xref ref-type="bibr" rid="CR24">24</xref>]. For the real datasets, we use the number of full-length identified transcripts to represent the recall, and we measure the precision by comparing the number of full-length reconstructed transcripts and the number of assembled transcripts (i.e., candidate transcripts) [<xref ref-type="bibr" rid="CR21">21</xref>, <xref ref-type="bibr" rid="CR22">22</xref>].</p>
    </sec>
    <sec id="Sec9">
      <title>Simulated data</title>
      <p>On the simulated datasets, besides the recall and precision, we also evaluated the sensitivity on read length of our method and the other leading approaches. We implemented all assemblers on the simulated datasets whose read lengths fall in the scope of 50<italic>b</italic><italic>p</italic>∼150<italic>b</italic><italic>p</italic> (Fig. <xref rid="Fig5" ref-type="fig">5</xref>). We ran all the compared assemblers with the <italic>k</italic>-mer length of 25<italic>b</italic><italic>p</italic> and other parameters as default.
<fig id="Fig5"><label>Fig. 5</label><caption><p>Impact of the length of read on the performances of assemblers</p></caption><graphic xlink:href="12859_2019_3272_Fig5_HTML" id="MO5"/></fig></p>
      <p>Figure <xref rid="Fig5" ref-type="fig">5</xref> shows that DTA-SiST-E performed more competitive than the other compared de novo assemblers especially with precision measure. The average precision obtained by DTA-SiST-E on these 11 simulated samples was 0.68, which had 36.0, 25.9, 11.5, 74.4, 106.1, 78.9, and 4.6% increase over that achieved by Trinity (0.50), BinPacker (0.54), IsoTree (0.61), SOAPdenovo-Trans (0.39), Oases (0.33), IDBA-Tran (0.38), and DTA-SiST-H (0.65), respectively. DTA-SiST-E’s outstanding performance with precision benefits from the transcript filtering criterion. For the recall measure, DTA-SiST-E performed better than the other de novo assemblers except that IsoTree led a little with read lengths of 120<italic>b</italic><italic>p</italic>,130<italic>b</italic><italic>p</italic>, and 150<italic>b</italic><italic>p</italic>. We attribute the outstanding performances of DTA-SiST and IsoTree to their read-based contig extension strategies. They extend contigs by reads while most other de novo assemblers extend contigs by <italic>k</italic>-mers.</p>
      <p>From Fig. <xref rid="Fig5" ref-type="fig">5</xref>, we observed that the performances of the depth-first enumeration strategy DTA-SiST-E are better than those of the hybrid strategy DTA-SiST-H with both recall and precision measures, which is interesting since there is usually a tradeoff between these two measures.</p>
    </sec>
    <sec id="Sec10">
      <title>Real data</title>
      <p>On the real datasets, we evaluated the de novo assemblers by counting the number of full-length identified transcripts and the number of full-length reconstructed transcripts. In terms of resource requirements, we assessed the de novo assemblers with regard to the running times and memory usages.</p>
      <p>The numbers of full-length identified transcripts, full-length reconstructed transcripts, and candidate transcripts collected by the de novo assemblers are shown in Table <xref rid="Tab2" ref-type="table">2</xref>.
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Number of full-length transcripts recovered by the de novo assemblers</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Assembler</th><th align="left" colspan="3">Dog dataset</th><th align="left" colspan="3">Human dataset</th></tr><tr><th align="left"/><th align="left">Identified</th><th align="left">Reconstructed</th><th align="left">Candidates</th><th align="left">Identified</th><th align="left">Reconstructed</th><th align="left">Candidates</th></tr></thead><tbody><tr><td align="left">Trinity</td><td align="left">1017</td><td align="left">1663</td><td align="left">96018</td><td align="left">1913</td><td align="left">3039</td><td align="left">437730</td></tr><tr><td align="left">BinPacker</td><td align="left">1149</td><td align="left">2601</td><td align="left">73419</td><td align="left">1491</td><td align="left">3449</td><td align="left">192674</td></tr><tr><td align="left">IDBA-Tran</td><td align="left">598</td><td align="left">1011</td><td align="left">69757</td><td align="left">1376</td><td align="left">2196</td><td align="left">182651</td></tr><tr><td align="left">SOAPdenovo-Trans</td><td align="left">1005</td><td align="left">1006</td><td align="left">85028</td><td align="left">/</td><td align="left">/</td><td align="left">/</td></tr><tr><td align="left">Oases</td><td align="left">530</td><td align="left">957</td><td align="left">113361</td><td align="left">1762</td><td align="left">3126</td><td align="left">439865</td></tr><tr><td align="left">IsoTree</td><td align="left">1354</td><td align="left">2974</td><td align="left">81597</td><td align="left">2015</td><td align="left">3821</td><td align="left">218269</td></tr><tr><td align="left">DTA-SiST-E</td><td align="left">1504</td><td align="left">3916</td><td align="left">103461</td><td align="left">2175</td><td align="left">4930</td><td align="left">278255</td></tr><tr><td align="left">DTA-SiST-H</td><td align="left">1370</td><td align="left">2514</td><td align="left">71356</td><td align="left">1950</td><td align="left">3959</td><td align="left">199642</td></tr></tbody></table></table-wrap></p>
      <p>From Table <xref rid="Tab2" ref-type="table">2</xref>, we observed that DTA-SiST always performed more competitive than the other de novo assemblers on recovering the full-length identified transcripts (estimate of recall). On the dog dataset, DTA-SiST-E recovered total of 1504 full-length identified transcripts and improved IsoTree (1354), Trinity (1017), BinPacker (1149), SOAPdenovo-Trans (1005), IDBA-Tran (598), and Oases (530) with 11.1, 47.9, 30.9, 49.7, 151.5, and 183.8%, respectively. Except DTA-SiST-E, DTA-SiST-H and IsoTree outperformed all the other de novo assemblers in terms of recovering full-length identified transcripts. The outstanding performances of DTA-SiST and IsoTree with recall measurement benefit from their read-based extension strategies. They extend the contig by reads while the other de novo assemblers extend the contig by <italic>k</italic>-mers. The <italic>k</italic>-mer-based extension strategies can only guarantee <italic>k</italic>−1-length overlaps while the read-based extension strategies ensure at least <italic>l</italic>-length overlaps. Both the theoretical conclusion and the experimental results show that the read-based extension strategies perform better than the <italic>k</italic>-mer-based extension strategies.</p>
      <p>On the dog dataset, DTA-SiST-E, DTA-SiST-H, IsoTree, Trinity, BinPacker, SOAPdenovo-Trans, IDBA-Tran, and Oases obtained total of 3916, 2514, 2974, 1663, 2601, 1006, 1011, and 957 full-length reconstructed transcripts out of 103461, 71356, 81597, 96018, 73419, 85028, 69757, and 113361 candidates, respectively, which suggests that DTA-SiST-E also outperformed its competitors with precision.</p>
      <p>On the human dataset, DTA-SiST maintained its superior performance on recovering the full-length identified transcripts. DTA-SiST-E obtained the most number of full-length identified transcripts (2175), followed by IsoTree (2015), DTA-SiST-H (1950), Trinity (1913), Oases (1762), BinPacker (1491), and IDBA-Tran (1376). However, DTA-SiST-E guessed more candidates than IsoTree and DTA-SiST-H. We attribute the large number of candidates collected by DTA-SiST-E to its enumeration strategy. Although DTA-SiST-H, IsoTree, and Trinity recovered almost the same number of full-length identified transcripts (1950, 2015, and 1913, respectively), DTA-SiST-H guessed the least number of candidate transcripts (199642 vs 218269 and 437730, respectively). Besides, Trinity collected more full-length identified transcripts than BinPacker on the human dataset while BinPacker detected a larger number of full-length identified transcripts than Trinity on the dog dataset.</p>
      <p>Additionally, DTA-SiST-E, DTA-SiST-H, IsoTree, Trinity, BinPacker, IDBA-Tran, and Oases collected total of 4930, 3959, 3821, 3039, 3449, 2196, and 3126 full-length reconstructed transcripts out of 278255, 199642, 218269, 437730, 192674, 182651, and 439865 candidates on the human dataset. From these numbers we can figure out that DTA-SiST-E not only holds a superior performance with recall measurement, its precision is also higher than the other assemblers except DTA-SiST-H. We conclude that DTA-SiST-H is applicable to the high precision demand while DTA-SiST-E is suitable to the general demand.</p>
      <p>Throughout the experiments on both simulated and real datasets, we found that most assemblers’ performances decreased as the magnitude of the data increased. The magnitudes of the simulated samples are far less than those of the real datasets, and all the assemblers performed better on the simulated datasets than on the real datasets. In addition, the human dataset is larger than the dog dataset, and almost all the assemblers performed better on the dog dataset than on the human dataset. The outstanding performance of DTA-SiST-H with precision becomes obvious when the data size increased. When the data size is big and the users focus more on precision, DTA-SiST-H is the best choice. Otherwise, DTA-SiST-E is applicable to most cases.</p>
      <p>We examined the assemblers’ computational demands of running time and peak memory. From Fig. <xref rid="Fig6" ref-type="fig">6</xref>, we can see that DTA-SiST (notice that since each splicing graph has only very limited number of <italic>s</italic>−<italic>t</italic> paths, the difference between the time cost by DTA-SiST-E and DTA-SiST-H can be ignored) cost much less time (about half on the dog dataset and 0.11 on the human dataset) than IsoTree while DTA-SiST performed more competitive than IsoTree in most cases. Although DTA-SiST (the difference between the memory cost by DTA-SiST-E and that by DTA-SiST-H can be ignored) consumed more memory than IsoTree, its memory consumption is endurable on both dog dataset (peak memory: 80G) and human dataset (peak memory: 160G which is even smaller than that 164.7G of the <italic>k</italic>-mer-based strategy Oases).
<fig id="Fig6"><label>Fig. 6</label><caption><p>The running time and peak memory for each de novo assembler on the real dataset</p></caption><graphic xlink:href="12859_2019_3272_Fig6_HTML" id="MO6"/></fig></p>
    </sec>
  </sec>
  <sec id="Sec11" sec-type="discussion">
    <title>Discussion</title>
    <p>Experimental results showed that DTA-SiST performs more competitive than the other compared de novo assemblers especially with precision measure. We owe this improvement to the read-based contig extension strategy and the transcript extraction methods. However, there are still quite a few issues need to be studied further. First, despite the outstanding performance of read-based contig extension strategy on precision and speed, it needs more memory to keep the suffix trees. More elegant implementations of the suffix trees or new data structures for assisting realizing read-based extension strategy are expected. Second, due to sequencing error and the giant gap in isoform expression level of the same gene, the number of erroneous reads originating from high-expressed transcripts may be larger than that of the correct reads originating from low-expressed transcripts [<xref ref-type="bibr" rid="CR30">30</xref>]. These erroneous reads may introduce artificial branches in splicing graphs and thus introduce chimeric transcripts while low-expressed transcripts may have little support from reads and thus are missed from the splicing graphs. High quality sequencing data and more exquisite algorithms are needed. Third, some transcripts that originate from different genes may share a long subsequence, which results in a large mixed graph (a mixture of splicing graphs that represent different genes). Once the common subsequence is longer than a read, it is hard to split the mixed graph into splicing graphs for different gene loci. In this case, a mixture graph will be seen as a splicing graph, and it will lead to a higher possibility to obtain pseudo transcripts and a lower opportunity to extract all truth expressed transcripts. To overcome this problem we need longer high quality reads and fine tuned transcript extraction rules. In short, there are still a lot of works need to do on de novo transcriptome assembly.</p>
  </sec>
  <sec id="Sec12" sec-type="conclusion">
    <title>Conclusion</title>
    <p>De novo transcriptome assembly is a challenging problem that arises with the development of RNA-seq. In this article, we proposed a new approach for contig extension. We applied suffix trees of reads to quickly find the candidate reads that have the longest overlaps with contigs’ terminuses, and extended the contigs by these reads directly. We also developed two strategies to extract the transcript-representing paths in the splicing graphs: a depth-first enumeration strategy and a hybrid strategy based on length and coverage. We ran and compared these two strategies with other leading de novo transcriptome assemblers on both simulated and real datasets. The experimental results provide a whole picture of the superior performance of DTA-SiST with the cost of acceptable more memory. Future work includes developing smaller-sized data structure while keeping the searching speed and transcript extracting algorithms with higher recall and precision.</p>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>LEST</term>
        <def>
          <p>Left extension suffix tree</p>
        </def>
      </def-item>
      <def-item>
        <term>NCBI</term>
        <def>
          <p>National Center for Biotechnology Information</p>
        </def>
      </def-item>
      <def-item>
        <term>REST</term>
        <def>
          <p>Right extension suffix tree</p>
        </def>
      </def-item>
      <def-item>
        <term>RNA-seq</term>
        <def>
          <p>RNA sequencing</p>
        </def>
      </def-item>
      <def-item>
        <term>SRA</term>
        <def>
          <p>Sequence read archive</p>
        </def>
      </def-item>
      <def-item>
        <term>UCSC</term>
        <def>
          <p>University of California SANTA CRUZ</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors would like to thank the editors and reviewers for their constructive comments and suggestions on this manuscript.</p>
    <sec id="d29e2076">
      <title>About this supplement</title>
      <p>This article has been published as part of <italic>BMC Bioinformatics Volume 20 Supplement 25, 2019: Proceedings of the 2018 International Conference on Intelligent Computing (ICIC 2018) and Intelligent Computing and Biomedical Informatics (ICBI) 2018 conference: bioinformatics</italic>. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-20-supplement-25">https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-20-supplement-25</ext-link>.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>HF, DZ, and YX contributed to the design of the study. JZ implemented DTA-SiST and performed experiments. JZ, HF, and CZ wrote the manuscript. All authors read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>Publication costs are funded by National Natural Science Foundation of China under No. 61672325, No. 61472222, and No. 61732009.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>DTA-SiST with choice for either strategy is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/Jane110111107/DTA-SiST">https://github.com/Jane110111107/DTA-SiST</ext-link>. The real datasets were downloaded from <ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov">https://www.ncbi.nlm.nih.gov</ext-link>. The annotation transcripts were downloaded from <ext-link ext-link-type="uri" xlink:href="https://genome.ucsc.edu">https://genome.ucsc.edu</ext-link>.</p>
  </notes>
  <notes>
    <title>Ethics approval and consent to participate</title>
    <p>Not applicable.</p>
  </notes>
  <notes>
    <title>Consent for publication</title>
    <p>Not applicable.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Faustino</surname>
            <given-names>NA</given-names>
          </name>
          <name>
            <surname>Cooper</surname>
            <given-names>TA</given-names>
          </name>
        </person-group>
        <article-title>Pre-mrna splicing and human disease</article-title>
        <source>Genes Dev</source>
        <year>2003</year>
        <volume>17</volume>
        <issue>4</issue>
        <fpage>419</fpage>
        <lpage>37</lpage>
        <pub-id pub-id-type="doi">10.1101/gad.1048803</pub-id>
        <pub-id pub-id-type="pmid">12600935</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Manley</surname>
            <given-names>JL</given-names>
          </name>
        </person-group>
        <article-title>Mechanisms of alternative splicing regulation: insights from molecular and genomics approaches</article-title>
        <source>Nat Rev Mol Cell Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>11</issue>
        <fpage>741</fpage>
        <lpage>54</lpage>
        <pub-id pub-id-type="doi">10.1038/nrm2777</pub-id>
        <pub-id pub-id-type="pmid">19773805</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <mixed-citation publication-type="other">Lewin B. Essential Genes: Pearson Prentice Hall; 2006, p. 46.</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>D-S</given-names>
          </name>
        </person-group>
        <article-title>Discmla: an efficient discriminative motif learning algorithm over high-throughput datasets</article-title>
        <source>IEEE/ACM Trans Comput Biol Bioinforma</source>
        <year>2018</year>
        <volume>15</volume>
        <issue>6</issue>
        <fpage>1810</fpage>
        <lpage>20</lpage>
        <pub-id pub-id-type="doi">10.1109/TCBB.2016.2561930</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tome</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Ozer</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Pagano</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Gheba</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Schroth</surname>
            <given-names>GP</given-names>
          </name>
          <name>
            <surname>Lis</surname>
            <given-names>JT</given-names>
          </name>
        </person-group>
        <article-title>Comprehensive analysis of rna-protein interactions by high-throughput sequencing–rna affinity profiling</article-title>
        <source>Nat Methods</source>
        <year>2014</year>
        <volume>11</volume>
        <issue>6</issue>
        <fpage>683</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.2970</pub-id>
        <pub-id pub-id-type="pmid">24809628</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chew</surname>
            <given-names>G-L</given-names>
          </name>
          <name>
            <surname>Pauli</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Rinn</surname>
            <given-names>JL</given-names>
          </name>
          <name>
            <surname>Regev</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Schier</surname>
            <given-names>AF</given-names>
          </name>
          <name>
            <surname>Valen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Ribosome profiling reveals resemblance between long non-coding rnas and 5’ leaders of coding rnas</article-title>
        <source>Development</source>
        <year>2013</year>
        <volume>140</volume>
        <issue>13</issue>
        <fpage>2828</fpage>
        <lpage>34</lpage>
        <pub-id pub-id-type="doi">10.1242/dev.098343</pub-id>
        <pub-id pub-id-type="pmid">23698349</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhuang</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Fuchs</surname>
            <given-names>RT</given-names>
          </name>
          <name>
            <surname>Robb</surname>
            <given-names>GB</given-names>
          </name>
        </person-group>
        <article-title>Small rna expression profiling by high-throughput sequencing: implications of enzymatic manipulation</article-title>
        <source>J Nucleic Acids</source>
        <year>2012</year>
        <volume>2012</volume>
        <fpage>360358</fpage>
        <pub-id pub-id-type="doi">10.1155/2012/360358</pub-id>
        <pub-id pub-id-type="pmid">22778911</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tjaden</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>De novo assembly of bacterial transcriptomes from rna-seq data</article-title>
        <source>Genome Biol</source>
        <year>2015</year>
        <volume>16</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-014-0572-2</pub-id>
        <pub-id pub-id-type="pmid">25583448</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Deng</surname>
            <given-names>S-P</given-names>
          </name>
          <name>
            <surname>Cao</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>D-S</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>Y-P</given-names>
          </name>
        </person-group>
        <article-title>Identifying stages of kidney renal cell carcinoma by combining gene expression and dna methylation data</article-title>
        <source>IEEE/ACM Trans Comput Biol Bioinforma</source>
        <year>2017</year>
        <volume>14</volume>
        <issue>5</issue>
        <fpage>1147</fpage>
        <lpage>53</lpage>
        <pub-id pub-id-type="doi">10.1109/TCBB.2016.2607717</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shao</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kingsford</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Accurate assembly of transcripts through phase-preserving graph decomposition</article-title>
        <source>Nat Biotechnol</source>
        <year>2017</year>
        <volume>35</volume>
        <fpage>1167</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.4020</pub-id>
        <pub-id pub-id-type="pmid">29131147</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Williams</surname>
            <given-names>BA</given-names>
          </name>
          <name>
            <surname>Pertea</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Mortazavi</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Kwan</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>van Baren</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
          <name>
            <surname>Wold</surname>
            <given-names>BJ</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Transcript assembly and abundance estimation from rna-seq reveals thousands of new transcripts and switching among isoforms</article-title>
        <source>Nat Biotechnol</source>
        <year>2010</year>
        <volume>28</volume>
        <fpage>511</fpage>
        <lpage>5</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.1621</pub-id>
        <pub-id pub-id-type="pmid">20436464</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pertea</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Pertea</surname>
            <given-names>GM</given-names>
          </name>
          <name>
            <surname>Antonescu</surname>
            <given-names>CM</given-names>
          </name>
          <name>
            <surname>Chang</surname>
            <given-names>T-C</given-names>
          </name>
          <name>
            <surname>Mendell</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Stringtie enables improved reconstruction of a transcriptome from rna-seq reads</article-title>
        <source>Nat Biotechnol</source>
        <year>2015</year>
        <volume>33</volume>
        <issue>3</issue>
        <fpage>290</fpage>
        <lpage>5</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.3122</pub-id>
        <pub-id pub-id-type="pmid">25690850</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Canzar</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Andreotti</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Weese</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Klau</surname>
            <given-names>GW</given-names>
          </name>
        </person-group>
        <article-title>Cidane: comprehensive isoform discovery and abundance estimation</article-title>
        <source>Genome Biol</source>
        <year>2016</year>
        <volume>17</volume>
        <issue>1</issue>
        <fpage>16</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-015-0865-0</pub-id>
        <pub-id pub-id-type="pmid">26831908</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Guttman</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Garber</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Levin</surname>
            <given-names>JZ</given-names>
          </name>
          <name>
            <surname>Donaghey</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Robinson</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Adiconis</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Fan</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Koziol</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Gnirke</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Nusbaum</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ab initio reconstruction of cell type-specific transcriptomes in mouse reveals the conserved multi-exonic structure of lincrnas</article-title>
        <source>Nature Biotechnol</source>
        <year>2010</year>
        <volume>28</volume>
        <fpage>503</fpage>
        <lpage>10</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.1633</pub-id>
        <pub-id pub-id-type="pmid">20436462</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Feng</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Isolasso: a lasso regression approach to rna-seq based transcriptome assembly</article-title>
        <source>J Comput Biol</source>
        <year>2011</year>
        <volume>18</volume>
        <issue>11</issue>
        <fpage>1693</fpage>
        <lpage>707</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2011.0171</pub-id>
        <pub-id pub-id-type="pmid">21951053</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Transcomb: genome-guided transcriptome assembly via combing junctions in splicing graphs</article-title>
        <source>Genome Biol</source>
        <year>2016</year>
        <volume>17</volume>
        <issue>1</issue>
        <fpage>213</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-016-1074-1</pub-id>
        <pub-id pub-id-type="pmid">27760567</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Grabherr</surname>
            <given-names>MG</given-names>
          </name>
          <name>
            <surname>Haas</surname>
            <given-names>BJ</given-names>
          </name>
          <name>
            <surname>Yassour</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Levin</surname>
            <given-names>JZ</given-names>
          </name>
          <name>
            <surname>Thompson</surname>
            <given-names>DA</given-names>
          </name>
          <name>
            <surname>Amit</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Adiconis</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Fan</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Raychowdhury</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Zeng</surname>
            <given-names>Q</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Full-length transcriptome assembly from rna-seq data without a reference genome</article-title>
        <source>Nat Biotechnol</source>
        <year>2011</year>
        <volume>29</volume>
        <issue>7</issue>
        <fpage>644</fpage>
        <lpage>52</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.1883</pub-id>
        <pub-id pub-id-type="pmid">21572440</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schulz</surname>
            <given-names>MH</given-names>
          </name>
          <name>
            <surname>Zerbino</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>Vingron</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Oases: robust de novo rna-seq assembly across the dynamic range of expression levels</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>8</issue>
        <fpage>1086</fpage>
        <lpage>92</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts094</pub-id>
        <pub-id pub-id-type="pmid">22368243</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Xie</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Luo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Patterson</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>He</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Gu</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Soapdenovo-trans: de novo transcriptome assembly with short rna-seq reads</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <issue>12</issue>
        <fpage>1660</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu077</pub-id>
        <pub-id pub-id-type="pmid">24532719</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Peng</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Leung</surname>
            <given-names>HC</given-names>
          </name>
          <name>
            <surname>Yiu</surname>
            <given-names>S-M</given-names>
          </name>
          <name>
            <surname>Lv</surname>
            <given-names>M-J</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>X-G</given-names>
          </name>
          <name>
            <surname>Chin</surname>
            <given-names>FY</given-names>
          </name>
        </person-group>
        <article-title>Idba-tran: a more robust de novo de bruijn graph assembler for transcriptomes with uneven expression levels</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <issue>13</issue>
        <fpage>326</fpage>
        <lpage>34</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btt219</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Chang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>McMullen</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>Binpacker: packing-based de novo transcriptome assembly from rna-seq data</article-title>
        <source>PLoS Comput Biol</source>
        <year>2016</year>
        <volume>12</volume>
        <issue>2</issue>
        <fpage>1004772</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1004772</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Ashby</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Cramer</surname>
            <given-names>CL</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>Bridger: a new framework for de novo transcriptome assembly using rna-seq data</article-title>
        <source>Genome Biol</source>
        <year>2015</year>
        <volume>16</volume>
        <issue>1</issue>
        <fpage>30</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-015-0596-2</pub-id>
        <pub-id pub-id-type="pmid">25723335</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Robertson</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Schein</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Chiu</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Corbett</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Field</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Jackman</surname>
            <given-names>SD</given-names>
          </name>
          <name>
            <surname>Mungall</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Okada</surname>
            <given-names>HM</given-names>
          </name>
          <name>
            <surname>Qian</surname>
            <given-names>JQ</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>De novo assembly and analysis of rna-seq data</article-title>
        <source>Nat Methods</source>
        <year>2010</year>
        <volume>7</volume>
        <issue>11</issue>
        <fpage>909</fpage>
        <lpage>12</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1517</pub-id>
        <pub-id pub-id-type="pmid">20935650</pub-id>
      </element-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <mixed-citation publication-type="other">Zhao J, Feng H, Zhu D, Zhang C, Xu Y. Isotree: A new framework for de novo transcriptome assembly from rna-seq reads. IEEE/ACM Trans Comput Biol Bioinforma. 2018. 10.1109/TCBB.2018.2808350.</mixed-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>An eulerian path approach to dna fragment assembly</article-title>
        <source>Proc Natl Acad Sci</source>
        <year>2001</year>
        <volume>98</volume>
        <issue>17</issue>
        <fpage>9748</fpage>
        <lpage>53</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.171285098</pub-id>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Heber</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Alekseyev</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Sze</surname>
            <given-names>S-H</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
        </person-group>
        <article-title>Splicing graphs and est assembly problem</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <issue>suppl 1</issue>
        <fpage>181</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/18.suppl_1.S181</pub-id>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhao</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Feng</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Xu</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>Isotree: De novo transcriptome assembly from rna-seq reads. In: International Symposium on Bioinformatics Research and Applications</article-title>
        <source>ISBRA 2017, LNBI</source>
        <year>2017</year>
        <volume>10330</volume>
        <fpage>71</fpage>
        <lpage>83</lpage>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Griebel</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Zacher</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Ribeca</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Raineri</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Lacroix</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Guigó</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Sammeth</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Modelling and simulating generic rna-seq experiments with the flux simulator</article-title>
        <source>Nucleic Acids Res</source>
        <year>2012</year>
        <volume>40</volume>
        <issue>20</issue>
        <fpage>10073</fpage>
        <lpage>83</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gks666</pub-id>
        <pub-id pub-id-type="pmid">22962361</pub-id>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Camacho</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Coulouris</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Avagyan</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Ma</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Papadopoulos</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Bealer</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Madden</surname>
            <given-names>TL</given-names>
          </name>
        </person-group>
        <article-title>Blast+: architecture and applications</article-title>
        <source>BMC Bioinformatics</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>421</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-10-421</pub-id>
        <pub-id pub-id-type="pmid">20003500</pub-id>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Mu</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Translig: a de novo transcriptome assembler that uses line graph iteration</article-title>
        <source>Genome Biol</source>
        <year>2019</year>
        <volume>20</volume>
        <issue>1</issue>
        <fpage>81</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-019-1690-7</pub-id>
        <pub-id pub-id-type="pmid">31014374</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
