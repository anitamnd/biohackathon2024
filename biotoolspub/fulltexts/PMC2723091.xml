<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version v40?>
<?ConverterInfo.XSLTName bmc2nlm.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title>BMC Bioinformatics</journal-title>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2723091</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-10-216</article-id>
    <article-id pub-id-type="pmid">19604391</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-10-216</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Linked region detection using high-density SNP genotype data via the minimum recombinant model of pedigree haplotype inference</article-title>
    </title-group>
    <contrib-group>
      <contrib id="A1" contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Lusheng</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>lwang@cs.cityu.edu.hk</email>
      </contrib>
      <contrib id="A2" contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Zhanyong</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>zhyong@cs.cityu.edu.hk</email>
      </contrib>
      <contrib id="A3" corresp="yes" contrib-type="author">
        <name>
          <surname>Yang</surname>
          <given-names>Wanling</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>yangwl@hkucc.hku.hk</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Computer Science, City University of Hong Kong, Hong Kong, PR China</aff>
    <aff id="I2"><label>2</label>Department of Paediatrics &amp; Adolescent Medicine, LKS Faculty of Medicine, The University of Hong Kong, 21 Sassoon Road, Hong Kong, PR China</aff>
    <pub-date pub-type="collection">
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>15</day>
      <month>7</month>
      <year>2009</year>
    </pub-date>
    <volume>10</volume>
    <fpage>216</fpage>
    <lpage>216</lpage>
    <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/10/216"/>
    <history>
      <date date-type="received">
        <day>16</day>
        <month>12</month>
        <year>2008</year>
      </date>
      <date date-type="accepted">
        <day>15</day>
        <month>7</month>
        <year>2009</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2009 Wang et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2009</copyright-year>
      <copyright-holder>Wang et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        <!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Wang
               Lusheng
               
               lwang@cs.cityu.edu.hk
            </dc:author><dc:title>
            Linked region detection using high-density SNP genotype data via the minimum recombinant model of pedigree haplotype inference
         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 10(1): 216-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2009)10:1&#x0003c;216&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>-->
      </license>
    </permissions>
    <abstract>
      <sec>
        <title>Background</title>
        <p>With the rapid development of high-throughput genotyping technologies, efficient methods for identifying linked regions using high-density SNP genotype data have become more and more important. Recently, a deterministic method that works very well on SNP genotyping data has been developed (Lin et al. Bioinformatics 2008, 24(1): 86–93). However, that program can only work on a limited number of family structures. In particular, the results (if any) will be poor when the genotype data for the whole chromosome of one of the parents in a nuclear family is missing.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We have developed a software package (LIden) for identifying linked regions using high-density SNP genotype data. We focus on handling the case where the genotype data for the whole chromosome of one of the parents in a nuclear family is missing. We use the minimum recombinant model for haplotype inference in pedigrees. Several local optimization algorithms are used to infer the haplotype of each individual and determine the linked regions based on the inferred haplotype data. We have developed a more flexible method to combine nuclear families to further refine (reduce the length of) the linked regions.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>Our new package (LIden) is efficient software for linked region detection using high-density SNP genotype data. LIden can handle some important cases where the existing programs do not work well. In particular, the new package can handle many cases where the genotype data of one of the two parents is missing for the entire chromosome. The running time of the program is <italic>O</italic>(<italic>mn</italic>), where <italic>m </italic>is the number of members in the family and <italic>n </italic>is the number of SNP sites in the chromosome. LIden is specifically suitable for handling big sized families. This research also demonstrates another practical use of the minimum recombinant model for haplotype inference in pedigrees.</p>
        <p>The software package can be downloaded at <ext-link ext-link-type="uri" xlink:href="http://www.cs.cityu.edu.hk/~lwang/software/Link"/>.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>With the completion of the human genome sequencing project and the development of HapMap project [<xref ref-type="bibr" rid="B1">1</xref>], our understanding of human genomic sequences has been extended dramatically. Due to the development of SNP genotyping technology, genotyping of hundreds of thousands of single nucleotide polymorphism (SNP) markers in a high-throughput format has become a routine job in many labs.</p>
    <p>Compared to classical genotyping methods mainly using microsatellite markers, SNP genotyping is faster and easier. It provides complete coverage of the genome and much more information on covered regions. Linkage analysis is a method to identify genomic regions that cosegregate with an inherited disease in a family and to facilitate the eventual identification of the mutation in that region causing the disease. Leykin et al. in [<xref ref-type="bibr" rid="B2">2</xref>] and Sellick et al. in [<xref ref-type="bibr" rid="B3">3</xref>] demonstrated that high-density SNP genotype data, such as that from microarrays, can be used for large-scale and cost-effective linkage analysis. The main reason is that there will be a sufficient number of informative markers between any two recombination points and thus the allele sharing status among the family members can be precisely determined. Therefore, efficient programs are highly demanded for allele sharing determination that work on a large number of markers and big sized families.</p>
    <p>Classical linkage analysis methods are designed for sparse microsatellite markers. They are mainly based on two algorithms, the Elston-Steward algorithm that is limited by the number of total markers used [<xref ref-type="bibr" rid="B4">4</xref>] and the Lander-Green algorithm that is limited by the total number of individuals in a family [<xref ref-type="bibr" rid="B5">5</xref>]. As a result, they either cannot handle genotype data based on large number of SNPs at all or they cannot handle families of a large size, especially together with large numbers of genotyped SNPs, due to memory constraint.</p>
    <p>Recently, a deterministic method that works very well on SNP genotyping data [<xref ref-type="bibr" rid="B6">6</xref>] has been developed. This was one of a series of efforts to develop software that is particularly suitable for SNP genotyping data and runs in time linear to both the number of SNP sites and the number of family members. However, the program in [<xref ref-type="bibr" rid="B6">6</xref>] can only work on a limited number of family structures. Here we use the minimum recombinant model for haplotype inference in pedigrees and develop a set of algorithms to minimize the total number of recombinants and produce a software package that works on a much wider range of family structures. Extensive simulations on Affymetrix Human Mapping 50 K/250 K GeneChips showed that the new package can correctly identify the linked regions on a wide range of family structures. In particular, the new package outperforms the old program in many important cases where the genotype data of one of the parents is missing on the entire chromosome. This research also demonstrates another practical use of the minimum recombinant model for haplotype inference in pedigrees.</p>
  </sec>
  <sec>
    <title>Implementation</title>
    <p>We use the minimum recombinant model to infer the haplotype configuration for all the family members. In 2002, Qian and Beckman [<xref ref-type="bibr" rid="B7">7</xref>] proposed a model to reconstruct haplotype configurations from genotype data in a pedigree under the Mendelian law of inheritance. In this model, the resulting haplotype configurations should have the minimum number of recombinants (i.e. recombination events).</p>
    <sec>
      <title>Minimum Recombinant Haplotype Configuration</title>
      <p>Given a pedigree and the genotype information for each member, the object is to find a haplotype configuration such that the total number of recombinants in the whole pedigree is minimized.</p>
      <p>The problem is called Minimum Recombinant Haplotype Configuration (MRHC). The MRHC problem was proved to be NP-hard by Li and Jiang [<xref ref-type="bibr" rid="B8">8</xref>]. Lots of algorithms have been proposed. Some algorithms run in time exponential in terms of the number of SNP sites and some algorithms run in time exponential in terms of the number of family members [<xref ref-type="bibr" rid="B9">9</xref>]. An integer linear programming approach was proposed to handle incomplete genotype data [<xref ref-type="bibr" rid="B10">10</xref>].</p>
      <p>Linkage analysis aims to identify regions whose allele is shared by all or most diseased members in a family but by none or few normal family members. In dominant inheritance situations, sharing of one mutation allele can cause a disease phenotype. In recessive cases, sharing of two disease alleles in that region is necessary for there to be a diseased status. We will first design algorithms to infer the allele sharing status with minimum recombinants and then use an algorithm to find the linked regions(regions shared by all or most of the diseased individuals but not shared by any normal individuals) by possibly changing the inferred allele sharing status.</p>
    </sec>
  </sec>
  <sec>
    <title>Algorithm</title>
    <p>Our package contains a set of (heuristic) algorithms to handle various kinds of situations and sometimes for one case, we use two (local optimization) algorithms to iteratively refine the output. Before we discuss the algorithms, we give the basic data structures used in the package.</p>
    <sec>
      <title>The basic data structures</title>
      <p>For each individual in the family, we use five arrays: <bold>genotype</bold>, <bold>paternal-h</bold>, <bold>maternal-h</bold>, <bold>which-p </bold>and <bold>which-m </bold>to store the information. The possible values for each element in the arrays are given in Table <xref ref-type="table" rid="T1">1</xref>. The genotype value of individual <italic>I </italic>at site <italic>i </italic>is in <bold>I. genotype [i]</bold>, which is {<italic>A, A</italic>}, {<italic>A, B</italic>} or {<italic>B, B</italic>}. The haplotype value of individual <italic>I </italic>from the father at site <italic>i </italic>is in <bold>I.paternal-h [i]</bold>, which is either <italic>A </italic>or <italic>B</italic>. Similarly, the haplotype value of individual <italic>I </italic>at site <italic>i </italic>from the mother is in <bold>I. maternal-h [i]</bold>, which is either <italic>A </italic>or <italic>B</italic>. For each individual, there are two (paternal and maternal) copies of haplotypes. We use 0 and 1 to distinguish them. <bold>I.which-p [i] </bold>can be 0 or 1.</p>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p>The possible values of each element in the five arrays.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="left">Array Name</td>
              <td align="left">Possible Values of each element</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">genotype</td>
              <td align="left">{<italic>AA</italic>}, {<italic>AB</italic>}, {<italic>BB</italic>}</td>
            </tr>
            <tr>
              <td colspan="2">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">paternal-h</td>
              <td align="left"><italic>A</italic>, <italic>B</italic></td>
            </tr>
            <tr>
              <td colspan="2">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">maternal-h</td>
              <td align="left"><italic>A</italic>, <italic>B</italic></td>
            </tr>
            <tr>
              <td colspan="2">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">which-p</td>
              <td align="left">0, 1</td>
            </tr>
            <tr>
              <td colspan="2">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">which-m</td>
              <td align="left">0, 1</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p><bold>I.which-p [i] = 0 </bold>indicates that the haplotype <bold>I.paternal-h [i] </bold>of individual <italic>I </italic>is from his/her father's 0-th haplotype and <bold>I.which-p [i] = 1 </bold>indicates that the haplotype <bold>I.paternal-h [i] </bold>of individual <italic>I </italic>is from his/her father's 1-th haplotype. Similarly, <bold>I.which-m [i] = 0 </bold>indicates that the haplotype <bold>I. maternal-h [i] </bold>of individual <italic>I </italic>is from his/her mother's 0-th haplotype and <bold>I.which-m [i] = 1 </bold>indicates that the haplotype <bold>I. maternal-h [i] </bold>of individual <italic>I </italic>is from his/her mother's 1-th haplotype. The main purpose here is to keep a record of which grandparent the allele came from.</p>
    </sec>
    <sec>
      <title>The algorithms for nuclear families with data available for both parents</title>
      <p>Let us consider a nuclear family with two parents and <italic>n </italic>children <italic>C</italic><sub>1</sub>, <italic>C</italic><sub>2</sub>,..., <italic>C</italic><sub><italic>n</italic></sub>. The pedigree is shown in Figure <xref ref-type="fig" rid="F1">1</xref>. A box represents a male individual and a circle represents a female individual. The filled circles/boxes indicate diseased individuals and the open circles/boxes indicate normal individuals. This setting applies to all the figures in this paper. To handle nuclear families with both parents, we use two algorithms, the <italic>basic algorithm </italic>and the <italic>horizontal local optimization algorithm</italic>.</p>
      <fig position="float" id="F1">
        <label>Figure 1</label>
        <caption>
          <p><bold>A family with <italic>n </italic>children</bold>. A nuclear family with two parents and n children <italic>C</italic><sub>1</sub>, <italic>C</italic><sub>2</sub>,..., <italic>C</italic><sub><italic>n</italic></sub>. A box represents a male individual and a circle represents a female individual. The filled circles/boxes indicate diseased individuals and the open circles/boxes indicate normal individuals. This setting applies to all the figures in this paper.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-216-1"/>
      </fig>
    </sec>
    <sec>
      <title>The basic algorithm</title>
      <p>In our basic algorithm, we consider a site at a time. Suppose that <italic>paternal </italic>[<italic>i</italic>], <italic>maternal </italic>[<italic>i</italic>], <italic>which</italic>-<italic>p </italic>[<italic>i</italic>] and <italic>which</italic>-<italic>m </italic>[<italic>i</italic>] of each individual at site <italic>i </italic>have been fixed. For site <italic>i </italic>+ 1, there are (at most) 4 different haplotype configurations of the two parents fitting the given genotype data. For each of the 4 haplotype configurations of the two parents, we can fix <italic>C</italic><sub><italic>j</italic></sub><italic>.paternal-h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.maternal-h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.which-p </italic>[<italic>i </italic>+ 1] and <italic>C</italic><sub><italic>j</italic></sub><italic>.which-m </italic>[<italic>i </italic>+ 1] for every child <italic>C</italic><sub><italic>j </italic></sub>(<italic>j </italic>= 1, 2,..., <italic>n</italic>) such that the number of break points of child <italic>C</italic><sub><italic>j </italic></sub>between site <italic>i </italic>and <italic>i </italic>+ 1 is minimized. Note that, for each child <italic>C</italic><sub><italic>j</italic></sub>, the number of breakpoints between site <italic>i </italic>and site <italic>i </italic>+ 1 could be 0, 1 or 2. When two choices are equally good for child <italic>C</italic><sub><italic>k</italic></sub>, we arbitrarily select one. We then choose one of the 4 haplotype configurations of the parents at site <italic>i </italic>+ 1 such that the total number of break points for <italic>all </italic>the <italic>n </italic>children between site <italic>i </italic>and site <italic>i </italic>+ 1 is minimized. It is worth pointing out that the basic algorithm here considers <italic>all </italic>the children site by site while the old algorithm in [<xref ref-type="bibr" rid="B6">6</xref>] considers all the sites for every child and then handles the children of the nuclear family one by one. Clearly, the quality of the solution at site <italic>i </italic>+ 1 heavily depends on the quality of the solution at site <italic>i</italic>. Thus, we will first use a method to select a starting site that generates a good solution and then we use the algorithm to compute the solution to the left and right ends of the chromosome, respectively.</p>
      <sec>
        <title>Finding a good starting site</title>
        <p>Here we try to find a site, where the haplotypes for all individuals are uniquely determined according to the given genotype data. This can be done if both genotypes of the parents are "AB", and every child's genotype is "AA" or "BB". If there is no such site, we look for the "second best" site, where some of the individuals' haplotypes can be partially fixed. The second best site is a site where the genotype of one parent is "AB", and the genotype of each child is "AA" or "BB". In this case, we can uniquely determine the haplotypes for all children, but partially determine the inheritance information, i.e., one parent has genotype "AA" ("BB") and the inherited "A" ("B") of a child from this parent could be any one of "AA" ("BB"). For this case, we arbitrarily give a solution which fits the genotype data. The third best site is a site where both genotypes of father and mother are "AB", and the genotypes of some (but not all) children are "AA" or "BB". In this case, we can fix the haplotypes of those children with "AA" or "BB" correctly. But for a child with genotype "AB", we have a risk of making mistakes. Again, in this case, we arbitrarily give a solution which fits the genotype data. The worst case is that both genotypes of father and mother are "AA" or "BB". In this case, we cannot fix the inheritance source for any child. In practice, we can always find a site which is one of the first three types.</p>
        <p>Note that there is no guarantee that we can always find a starting site with uniquely determined haplotypes. When the solution on the starting site is wrong, our algorithm may produce a short segment with many breakpoints. Whenever such a segment is found, our algorithm will re-calculate the solution of the segment using the reverse order and thus another starting point.</p>
      </sec>
      <sec>
        <title>The horizontal local optimization algorithm</title>
        <p>After we obtain a haplotype solution from the basic algorithm, we can look at three individuals, two parents and one of their children <italic>C</italic><sub><italic>j</italic></sub>, at a time. Assuming that the haplotypes of the two parents are fixed, the number of break points in <italic>C</italic><sub><italic>j </italic></sub>might be further reduced if we change the haplotypes of <italic>C</italic><sub><italic>j</italic></sub>. This is due to the existence of multiple solutions at a site and the fact that the haplotype solution at site <italic>i </italic>heavily depends on that of its previous site. Thus, we use an algorithm that can give a haplotype of <italic>C</italic><sub><italic>j </italic></sub>with minimum number of break points when the haplotypes of the two parents are fixed (by the basic algorithm). In this way, the total number of break points can be reduced. Let <italic>D</italic><sup><italic>pq</italic></sup>(<italic>i</italic>) be the minimum number of breakpoints of <italic>C</italic><sub><italic>j </italic></sub>for the first <italic>i </italic>sites such that at site <italic>i </italic>the paternal haplotype is from the <italic>p</italic>-th haplotype of the father and the maternal haplotype is from the <italic>q</italic>-th haplotype of the mother, where <italic>p </italic>= 0, 1 and <italic>q </italic>= 0, 1. Then <italic>D</italic><sup><italic>pq</italic></sup>(<italic>i </italic>+ 1) can be computed based on <italic>D</italic><sup>00 </sup>(<italic>i</italic>), <italic>D</italic><sup>01 </sup>(<italic>i</italic>), <italic>D</italic><sup>10 </sup>(<italic>i</italic>) and <italic>D</italic><sup>11 </sup>(<italic>i</italic>). For example, the value of <italic>D</italic><sup>00 </sup>(<italic>i </italic>+ 1) can be one of <italic>D</italic><sup>00 </sup>(<italic>i</italic>), <italic>D</italic><sup>01 </sup>(<italic>i</italic>) + 1, <italic>D</italic><sup>10 </sup>(<italic>i</italic>) + 1 or <italic>D</italic><sup>11 </sup>(<italic>i</italic>) + 2. We can check each of the cases and see if the genotype of <italic>C</italic><sub><italic>j </italic></sub>at site <italic>i </italic>+ 1 can fit each of the four configurations under the Mendelian law of inheritance. Among all the possible configurations, we choose the one corresponding to the minimum value. The running time of the algorithm is <italic>O</italic>(<italic>n</italic>), where <italic>n </italic>is the number of sites in the chromosome.</p>
        <p>We apply the horizontal local optimization algorithm to each of the <italic>n </italic>children in the nuclear family one by one in an arbitrarily fixed order. (The order among the children does not affect the results.)</p>
      </sec>
      <sec>
        <title>The whole algorithm for a nuclear family</title>
        <p>Consider a nuclear family containing two generations. For a segment from position <italic>i </italic>to position <italic>i </italic>+ <italic>k</italic>, we can use the basic algorithm in two ways, i.e., from left to right or from right to left. We may get different solutions since the starting points are different. After we obtain a solution using the basic algorithm, we can use the horizontal local optimization algorithm to further improve the solution. The whole algorithm is as follows:</p>
        <p>1. Find a good starting point as described.</p>
        <p>2. Use the basic algorithm to get a solution for all individuals in the nuclear family.</p>
        <p>3. Identify a short segment with a large number of breakpoints and apply the basic algorithm to this segment to re-calculate using the inverse order (thus a different starting point). If we can reduce the total number of break points then we use the new solution for this segment.</p>
        <p>4. Use the horizontal local optimization algorithm for each child to refine the solution.</p>
      </sec>
    </sec>
    <sec>
      <title>The algorithms for nuclear families with data available for single parents</title>
      <p>Now, we consider the case, where the genotype data of one of the parents in the nuclear family is unknown over the entire chromosome. To handle this case, the basic idea is similar to that for nuclear families with data available for both parents. For the basic algorithm, we guess the haplotype of the unknown parent whenever needed. Since each individual has two copies of haplotypes on each chromosome, there are four different haplotype configurations at each site. The two haplotypes for an individual can be AA, AB, BA, and BB. Thus, we can modify the basic algorithm to handle this case, where the genotype data for one parent is missing. In the basic algorithm, instead of considering at most 4 configurations of the two parents, we consider at most 8 configurations, where the unknown parent has 4 configurations, and the known parent has at most 2 configurations. Similarly, for each of the 8 configurations of the two parents, we can fix <italic>C</italic><sub><italic>j</italic></sub><italic>.paternal</italic>-<italic>h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.maternal</italic>-<italic>h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.which</italic>-<italic>p </italic>[<italic>i </italic>+ 1] and <italic>C</italic><sub><italic>j</italic></sub>.<italic>which</italic>-<italic>m </italic>[<italic>i </italic>+ 1] for every child <italic>C</italic><sub><italic>j </italic></sub>(<italic>j </italic>= 1, 2,..., <italic>n</italic>) such that the number of breakpoints of child <italic>C</italic><sub><italic>j </italic></sub>between site <italic>i </italic>and <italic>i </italic>+ 1 is minimized. The rest of the algorithm remains the same.</p>
    </sec>
    <sec>
      <title>The algorithm for a family with three or more generations</title>
      <p>To handle a family with three generations, we will view the set of all individuals in the first and second generations as a nuclear family which is referred to as the <italic>main </italic>nuclear family. For any child <italic>C</italic><sub><italic>j </italic></sub>in the main nuclear family, if <italic>C</italic><sub><italic>j </italic></sub>has his/her own children (third generation individuals), then we will view <italic>C</italic><sub><italic>j </italic></sub>as a <italic>super </italic>child representing the <italic>second generation nuclear family </italic>including <italic>C</italic><sub><italic>j</italic></sub>, <italic>C</italic><sub><italic>j</italic></sub>'s spouse and all their children. The basic algorithm for a family with three generations is similar to the basic algorithm for a nuclear family. Here we focus on the main nuclear family and give some special treatment for super children.</p>
    </sec>
    <sec>
      <title>The basic algorithm for a family with three generations</title>
      <p>Again, we consider a site at a time. Suppose that <italic>paternal</italic>-<italic>h </italic>[<italic>i</italic>], <italic>maternal</italic>-<italic>h </italic>[<italic>i</italic>], <italic>which</italic>-<italic>p </italic>[<italic>i</italic>] and <italic>which</italic>-<italic>m </italic>[<italic>i</italic>] of each individual in the main nuclear family for site <italic>i </italic>are fixed. Let us consider site <italic>i </italic>+ 1. If the genotype data is known for both parents, there are (at most) 4 different haplotype configurations of the two parents (first generation individuals) fitting the given genotype data. If the genotype data of a parent is missing, there are at most 8 different haplotype configurations of the two parents. Let <italic>C</italic><sub>1</sub>, <italic>C</italic><sub>2</sub>,..., <italic>C</italic><sub><italic>n </italic></sub>be the <italic>n </italic>children in the second generation and some of them might be super children. For each possible haplotype configurations of the two parents (first generation individuals), we try to fix <italic>C</italic><sub><italic>j</italic></sub><italic>.paternal</italic>-<italic>h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.maternal</italic>-<italic>h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.which</italic>-<italic>p </italic>[<italic>i </italic>+ 1] and <italic>C</italic><sub><italic>j</italic></sub><italic>.which</italic>-<italic>m </italic>[<italic>i </italic>+ 1] for every child <italic>C</italic><sub><italic>j </italic></sub>(<italic>j </italic>= 1, 2,..., <italic>n</italic>) as follows:</p>
      <p>A1: if <italic>C</italic><sub><italic>j </italic></sub>is not a super child, we fix <italic>C</italic><sub><italic>j</italic></sub><italic>.paternal</italic>-<italic>h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.maternal</italic>-<italic>h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.which</italic>-<italic>p </italic>[<italic>i </italic>+ 1] and <italic>C</italic><sub><italic>j</italic></sub><italic>.which</italic>-<italic>m </italic>[<italic>i </italic>+ 1] such that the number of breakpoints of child <italic>C</italic><sub><italic>j </italic></sub>between site <italic>i </italic>and <italic>i </italic>+ 1 is minimized. Note that for each child <italic>C</italic><sub><italic>j</italic></sub>, the number of breakpoints between site <italic>i </italic>and site <italic>i </italic>+ 1 could be 0, 1 or 2.</p>
      <p>A2: if <italic>C</italic><sub><italic>j </italic></sub>is a super child, we fix <italic>C</italic><sub><italic>j</italic></sub><italic>.paternal</italic>-<italic>h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.maternal</italic>-<italic>h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.which</italic>-<italic>p </italic>[<italic>i </italic>+ 1] and <italic>C</italic><sub><italic>j</italic></sub>.<italic>which</italic>-<italic>m </italic>[<italic>i </italic>+ 1] such that the number of breakpoints <inline-formula><inline-graphic xlink:href="1471-2105-10-216-i1.gif"/></inline-formula> in the second generation nuclear family <italic>C</italic><sub><italic>j </italic></sub>represented by <italic>C</italic><sub><italic>j </italic></sub>between site <italic>i </italic>and <italic>i </italic>+ 1 is minimized. Here if the genotype data for both <italic>C</italic><sub><italic>j </italic></sub>and <italic>C</italic><sub><italic>j</italic></sub>'s spouse is given, there are at most two choices for each of <italic>C</italic><sub><italic>j </italic></sub>and <italic>C</italic><sub><italic>j</italic></sub>'s spouse. We can call the basic algorithm to get <inline-formula><inline-graphic xlink:href="1471-2105-10-216-i1.gif"/></inline-formula>. Note that <inline-formula><inline-graphic xlink:href="1471-2105-10-216-i1.gif"/></inline-formula> could be greater than 2.</p>
      <p>Again, when several choices are equally good for child <italic>C</italic><sub><italic>k</italic></sub>, we arbitrarily select a choice.</p>
      <p>Among all the possible haplotype configurations of the parents (first generation individuals) at site <italic>i </italic>+ 1, we select one such that the total number of breakpoints for <italic>all </italic>the individuals in the three-generation family between site <italic>i </italic>and site <italic>i </italic>+ 1 is minimized. This process can be used recursively to handle more than three generations. In fact, for our package, there is no limit on the number of generations in the family. Clearly, if the genotype data of both parents in all nuclear families is known, the running time of the basic algorithm is <italic>O</italic>(<italic>mn</italic>), where <italic>m </italic>is the total number of individuals in the whole family and <italic>n </italic>is the number of SNP sites in the chromosome.</p>
    </sec>
    <sec>
      <title>Dealing with missing individuals in the second generation</title>
      <p>In this subsection, we deal with the cases where the genotype data for one of the parents in a second generation nuclear family is missing. The algorithm is similar to the basic algorithm for a family with three generations. Let <italic>C</italic><sub><italic>j </italic></sub>be a super child. Two cases arise.</p>
      <sec>
        <title>The genotype data for <italic>C</italic><sub><italic>j</italic></sub>'s spouse is missing</title>
        <p>For this case, when we try to fix <italic>C</italic><sub><italic>j</italic></sub><italic>.paternal</italic>-<italic>h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub>.<italic>maternal</italic>-<italic>h </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.which</italic>-<italic>p </italic>[<italic>i </italic>+ 1] and <italic>C</italic><sub><italic>j</italic></sub><italic>.which</italic>-<italic>m </italic>[<italic>i </italic>+ 1] such that the number of breakpoints in the second generation nuclear family represented by <italic>C</italic><sub><italic>j </italic></sub>between site <italic>i </italic>and <italic>i </italic>+ 1 is minimized as in A2, we have to guess the haplotyes of <italic>C</italic><sub><italic>j</italic></sub>'s spouse by trying all possible haplotypes <italic>AA</italic>, <italic>AB</italic>, <italic>BA </italic>and <italic>BB</italic>. When the genotype data for <italic>C</italic><sub><italic>j</italic></sub>'s spouse is given, there are two choices. This will slightly slow down the program. Moreover, if there are more than one second generation nuclear families missing the super child's spouse's genotype data, the speed will not be affected too much, since children in the second generation are processed one by one.</p>
      </sec>
      <sec>
        <title>The genotype data for <italic>C</italic><sub><italic>j </italic></sub>is missing</title>
        <p>For this case, when we try to fix <italic>C</italic><sub><italic>j</italic></sub><italic>.paternal </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.maternal </italic>[<italic>i </italic>+ 1], <italic>C</italic><sub><italic>j</italic></sub><italic>.which</italic>-<italic>p </italic>[<italic>i </italic>+ 1] and <italic>C</italic><sub><italic>j</italic></sub><italic>.which</italic>-<italic>m </italic>[<italic>i </italic>+ 1] such that the number of breakpoints in the second generation nuclear family represented by <italic>C</italic><sub><italic>j </italic></sub>between site <italic>i </italic>and <italic>i </italic>+ 1 is minimized as in A2, we have to guess the haplotyes of <italic>C</italic><sub><italic>j </italic></sub>by trying all possible haplotypes <italic>AA</italic>, <italic>AB</italic>, <italic>BA </italic>and <italic>BB </italic>without genotype data. Again, the running time is still <italic>O</italic>(<italic>m </italic>× <italic>n</italic>) since children in the second generation are processed one by one.</p>
      </sec>
      <sec>
        <title>Remarks</title>
        <p>For the algorithm in [<xref ref-type="bibr" rid="B6">6</xref>], a top-down approach is used to deal with three-generation families. The algorithm processes nuclear families (with two generations) one by one from the top to the bottom. The old approach cannot give good solutions when the size of the main nuclear family is small. The reason is that the quality of solutions heavily depends on the sizes of nuclear families and if the size of the main nuclear family is small, the obtained haplotypes for the (super) children in the second generation could be wrong and this wrong information will be passed to the processing of the third generation. A better strategy is to work on big nuclear families first. However, even this strategy is not as good as our approach here since we do not fix the solution of super children in the second generation. We have observed that the inferred haplotypes for big sized second generation families such as two parents and 5 children could be wrong though the breakpoint positions are very accurate. If the wrong haplotyes are used to handle other nuclear families, the whole linked region could be missed.</p>
        <p>The current version of our program works for any number of generations. It can handle the case, where the genotype data for one of a couple is missing.</p>
      </sec>
    </sec>
    <sec>
      <title>Genotype data error correction</title>
      <p>For large-scale SNP genotyping, a certain number of experimental errors is unavoidable. We observe that when genotype data errors occur, the inferred haplotypes contain many breakpoints that are close to each other. In order to get the correct allele sharing status, our algorithm will simply delete both breakpoints that are within <italic>x </italic>SNP sites. We suggest setting the value of <italic>x </italic>based on the error rate. When the error rate is smaller than 0.1%, <italic>x </italic>= 5. When the error rate is between 0.1% and 0.3%, <italic>x </italic>= 8. When the error rate is between 0.3% and 0.5%, <italic>x </italic>is set to be 10. When the error rate cannot be estimated, we simply use <italic>x </italic>= 8.</p>
    </sec>
    <sec>
      <title>Identifying mutation regions</title>
      <p>After obtaining the inferred haplotype data for all the individuals in the family, we can find possible mutation regions by looking at the SNP sites one by one. The possible mutation regions should be regions shared by all or most of the diseased family members (considering phenocopy) but none or few of the normal family members (considering penetrance). Those regions are reported as suspected mutation regions. Due to the existence of multiple solutions and haplotype inference error, it is possible that the reported regions do not completely overlap the true mutation region. In our algorithm, we use a subroutine to extend the suspected mutation regions site by site in both directions, where we can revise the haplotype allele such that the allele is shared by diseased family members, but not shared by the normal family members. Unlike the program in [<xref ref-type="bibr" rid="B6">6</xref>], here we have to extend in both directions.</p>
      <p>The current version of the package reports all the possible regions. The users are asked to input the maximum number of normal individuals to be allowed to share the mutation allele (allowing for penetrance) and the maximum number of diseased individuals in the family to be allowed not to share the potential mutation region (allowing for phenocopy).</p>
    </sec>
  </sec>
  <sec>
    <title>Results and Discussion</title>
    <p>In this section, we will test our software package using simulated data. We have considered a wide range of pedigree structures.</p>
    <sec>
      <title>Generating haplotype data using the Chi-square model</title>
      <p>In order to test the program, we generated haplotype datasets based on the Chi-square model to see if our program can infer the haplotype data correctly from the corresponding genotype data. The founder haplotypes were obtained from real datasets (Affymetrix Human Mapping 50 K/250 K GeneChips [<xref ref-type="bibr" rid="B11">11</xref>]), and children haplotypes were generated through random inheritance of paternal/maternal alleles using the Chi-square model for recombination with m equals 4 [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>] and according to male/female averaged genetic map for chromosome 1 downloaded from HapMap [<xref ref-type="bibr" rid="B14">14</xref>]. The simulation process is identical to that of [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B15">15</xref>]. When disease status was considered, a mutation was randomly assigned to be close to a SNP site (called <italic>mutation site</italic>), and the diseased individuals were forced to inherit the mutation strand and the normal individuals were forced not to inherit the mutation strand. This process is done generation by generation.</p>
    </sec>
    <sec>
      <title>Nuclear families with data available for both parents</title>
      <p>Let us consider a nuclear family as shown in Figure <xref ref-type="fig" rid="F1">1</xref>. When the genotype data for both parents is given, the results are shown in Table <xref ref-type="table" rid="T2">2</xref>. Here we test the cases, where there are 2, 3,..., 6 children in the nuclear family. The results are listed in column 2, 3,..., 6, respectively. We have selected individuals to form 95 couples as in [<xref ref-type="bibr" rid="B6">6</xref>]. We have done experiments on 285 datasets (three times for each couple) and calculated the average. For all the simulations, the number of data sets is a multiple of 95. Each cell in the table contains two values. The first one is by our program and the one in brackets is by the program in [<xref ref-type="bibr" rid="B6">6</xref>]. A breakpoint is correctly inferred if the inferred breakpoint is within 20 SNPs away from the real location. From Table <xref ref-type="table" rid="T2">2</xref>, we can see that all the elements in the row "overlap/real" are 1 indicating that our package can always identify the whole mutation region. The elements in the row "overlap/found" are about 0.97 or 0.96 indicating that the sizes of the reported regions are slightly larger than (almost identical to) that of the real mutation regions. The values of recall and precision are also very good when there are more than two children. The values in brackets are by the program in [<xref ref-type="bibr" rid="B6">6</xref>]. We can see that both programs perform very well in those cases.</p>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p>The experimental results for nuclear families when the genotype data for both parents is available.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="left">2 children</td>
              <td align="left">3 children</td>
              <td align="left">4 children</td>
              <td align="left">5 children</td>
              <td align="left">6 children</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">No. of Breakpoints</td>
              <td align="left">11.11 (10.59)</td>
              <td align="left">15.63 (15.50)</td>
              <td align="left">21.32 (21.28)</td>
              <td align="left">26.61 (26.60)</td>
              <td align="left">31.66 (31.60)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">precision</td>
              <td align="left">0.47 (0.50)</td>
              <td align="left">0.93 (0.98)</td>
              <td align="left">0.95 (0.97)</td>
              <td align="left">0.98 (0.99)</td>
              <td align="left">0.98 (0.99)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">recall</td>
              <td align="left">0.47 (0.48)</td>
              <td align="left">0.91 (0.96)</td>
              <td align="left">0.94 (0.97)</td>
              <td align="left">0.96 (0.98)</td>
              <td align="left">0.96 (0.98)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of real linked region (cM)</td>
              <td align="left">76.66</td>
              <td align="left">59.51</td>
              <td align="left">40.82</td>
              <td align="left">35.97</td>
              <td align="left">29.90</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of found linked region (cM)</td>
              <td align="left">78.70 (79.51)</td>
              <td align="left">60.79 (60.77)</td>
              <td align="left">42.15 (42.13)</td>
              <td align="left">37.00 (37.01)</td>
              <td align="left">30.97 (30.99)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/real</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/found</td>
              <td align="left">0.97 (0.96)</td>
              <td align="left">0.97 (0.97)</td>
              <td align="left">0.96 (0.96)</td>
              <td align="left">0.96 (0.96)</td>
              <td align="left">0.95 (0.95)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">linked region recovery</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>The row "No. of Breakpoints" indicates the number of breakpoints in the whole family. The row "precision" is the ratio of the number of correctly inferred breakpoints to the total number of inferred breakpoints. The row "recall" is the ratio of the number of correctly inferred breakpoints to the number of real breakpoints. The row "length of real linked region (cM)" is the length of the linked region generated in the simulation. The row "length of found linked region (cM)" is the length of the linked region calculated by our program. The row "overlap/real" is the length of the region shared by both the real linked region and the inferred linked region divided by the length of the real linked region. The row "overlap/found" is the length of the region shared by both the real linked region and the inferred linked region divided by the length of the inferred linked region. The row "linked region recovery" is the number of times that the inferred linked region contains the mutation site divided by the total number of experiments. In each cell, the first value is by our program and the one in brackets is by the program in [<xref ref-type="bibr" rid="B6">6</xref>].</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>Nuclear families with data available for single parents</title>
      <p>Let us consider nuclear families with a single parent. In this case, the genotype data for the other parent is missing. About half of the children are diseased. There are two cases: (1) the available parent is diseased and (2) the available parent is normal. The results are shown in Table <xref ref-type="table" rid="T3">3</xref> and Table <xref ref-type="table" rid="T4">4</xref>, respectively. Each cell in the tables contains two values. The first one is by our program and the one in brackets is by the program in [<xref ref-type="bibr" rid="B6">6</xref>]. We consider the cases where there are 2, 3,..., 6 children. For both cases, we can see that for our program, the precision and the recall are slightly worse than that in Table <xref ref-type="table" rid="T2">2</xref>. The length of the inferred region is slightly longer. Most importantly, all the elements in the row "linked region recovery" are 1 for our program. This indicates that our program can always find the linked region that contains the mutation site. We can also see that our new program performs much better than the program in [<xref ref-type="bibr" rid="B6">6</xref>] in those cases. Comparing case 1 and case 2, we can see that case 2 is harder to handle. In case 2, the result for 2 children is very poor and this case is not solvable by our program.</p>
      <table-wrap position="float" id="T3">
        <label>Table 3</label>
        <caption>
          <p>The experimental results for nuclear families when the genotype data of only one parent is available and this parent is diseased. </p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="left">2 children</td>
              <td align="left">3 children</td>
              <td align="left">4 children</td>
              <td align="left">5 children</td>
              <td align="left">6 children</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">No. of Breakpoints</td>
              <td align="left">3.68 (3.75)</td>
              <td align="left">7.47 (14.59)</td>
              <td align="left">10.32 (25.47)</td>
              <td align="left">12.90 (34.83)</td>
              <td align="left">15.48 (50.38)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">precision</td>
              <td align="left">0.33 (0.39)</td>
              <td align="left">0.78 (0.26)</td>
              <td align="left">0.89 (0.23)</td>
              <td align="left">0.94 (0.24)</td>
              <td align="left">0.96 (0.21)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">recall</td>
              <td align="left">0.23 (0.27)</td>
              <td align="left">0.72 (0.48)</td>
              <td align="left">0.86 (0.55)</td>
              <td align="left">0.91 (0.63)</td>
              <td align="left">0.92 (0.66)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of real linked region (cM)</td>
              <td align="left">83.14</td>
              <td align="left">57.98</td>
              <td align="left">45.62</td>
              <td align="left">35.15</td>
              <td align="left">31.01</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of found linked region (cM)</td>
              <td align="left">111.1 (91.45)</td>
              <td align="left">65.08 (66.32)</td>
              <td align="left">48.85 (49.38)</td>
              <td align="left">37.40 (38.02)</td>
              <td align="left">32.57 (32.80)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/real</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/found</td>
              <td align="left">0.86 (0.94)</td>
              <td align="left">0.93 (0.94)</td>
              <td align="left">0.94 (0.93)</td>
              <td align="left">0.93 (0.92)</td>
              <td align="left">0.93 (0.92)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">linked region recovery</td>
              <td align="left">1.00<break/>(255/285)</td>
              <td align="left">1.00<break/>(229/285)</td>
              <td align="left">1.00<break/>(267/285)</td>
              <td align="left">1.00<break/>(276/285)</td>
              <td align="left">1.00<break/>(281/285)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>The meaning of each line is the same as in Table 2.</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap position="float" id="T4">
        <label>Table 4</label>
        <caption>
          <p>The experimental results for nuclear families when the genotype data of only one parent is available and this parent is normal. </p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="left">3 children</td>
              <td align="left">4 children</td>
              <td align="left">5 children</td>
              <td align="left">6 children</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">No. of Breakpoints</td>
              <td align="left">7.39 (13.47)</td>
              <td align="left">10.29 (24.47)</td>
              <td align="left">12.94 (35.69)</td>
              <td align="left">15.23 (55.84)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">precision</td>
              <td align="left">0.75 (0.31)</td>
              <td align="left">0.89 (0.25)</td>
              <td align="left">0.94 (0.24)</td>
              <td align="left">0.96 (0.19)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">recall</td>
              <td align="left">0.68 (0.53)</td>
              <td align="left">0.86 (0.59)</td>
              <td align="left">0.90 (0.65)</td>
              <td align="left">0.92 (0.66)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of real linked region (cM)</td>
              <td align="left">55.56</td>
              <td align="left">43.61</td>
              <td align="left">36.61</td>
              <td align="left">28.45</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of found linked region (cM)</td>
              <td align="left">67.66 (59.25)</td>
              <td align="left">43.90 (44.14)</td>
              <td align="left">36.87 (35.83)</td>
              <td align="left">29.23 (28.12)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/real</td>
              <td align="left">0.99 (0.99)</td>
              <td align="left">0.99 (0.98)</td>
              <td align="left">0.99 (0.98)</td>
              <td align="left">0.99 (0.97)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/found</td>
              <td align="left">0.85 (0.94)</td>
              <td align="left">0.99 (0.98)</td>
              <td align="left">0.99 (0.99)</td>
              <td align="left">0.98 (0.98)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">linked region recovery</td>
              <td align="left">1.00<break/>(275/285)</td>
              <td align="left">1.00<break/>(274/285)</td>
              <td align="left">1.00<break/>(274/285)</td>
              <td align="left">1.00<break/>(266/285)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>The meaning of each line is the same as in Table 2.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>Complicated pedigrees</title>
      <p>We did experiments on some complicated pedigrees. First we study some pedigrees, where the genotype data for the super children in the second generation (shared by two nuclear families) is missing. See P1–P4 in Figure <xref ref-type="fig" rid="F2">2</xref>. A slash on an individual indicates that the genotype data for this individual is missing. This setting applies to all the figures in the paper.</p>
      <fig position="float" id="F2">
        <label>Figure 2</label>
        <caption>
          <p><bold>Pedigrees P1 to P4</bold>. Pedigrees P1 to P4. A slash on an individual indicates that the genotype data for this individual is missing.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-216-2"/>
      </fig>
      <p>We have done 285 experiments on each of P1–P4. From Table <xref ref-type="table" rid="T5">5</xref>, we can see that the inferred region of our program can almost always cover the entire real linked region. The length of the inferred linked region is a bit (about 15%) longer than that of the real linked region. From the row "linked region recovery", we can see that our program can always precisely find the linked region that contains the mutation site. Note that the program in [<xref ref-type="bibr" rid="B6">6</xref>] cannot handle P1–P4 at all. This is a significant improvement in our new program. Let us consider pedigrees P5–P8 in Figure <xref ref-type="fig" rid="F3">3</xref>, where individuals with missing genotype data are not super children (not shared by two nuclear families). We have done 285 experiments for each of the pedigrees. The results are listed in Table <xref ref-type="table" rid="T6">6</xref>. From the row "linked region recovery", we can see that, if the nuclear family of the first generation has a single parent, and the nuclear family of the second generation has at least three (with both parents) or four (with single parent) children, we can always find the linked region that contains the mutation site. The program in [<xref ref-type="bibr" rid="B6">6</xref>] missed the mutation site at a rate of about 13.07%. Now we consider pedigrees P9–P16 in Figures <xref ref-type="fig" rid="F4">4</xref>, <xref ref-type="fig" rid="F5">5</xref> and <xref ref-type="fig" rid="F6">6</xref>. The experimental results are shown in Table <xref ref-type="table" rid="T7">7</xref> and Table <xref ref-type="table" rid="T8">8</xref>, respectively. We can see that for common pedigrees of different structures, our program can always find the linked region containing the mutation site and our program reports the linked region more precisely than the program in [<xref ref-type="bibr" rid="B6">6</xref>]. Note that the program in [<xref ref-type="bibr" rid="B6">6</xref>] sometimes missed the mutation sites. From all the listed experimental results, we can see that our program has much higher precision and recall than the program in [<xref ref-type="bibr" rid="B6">6</xref>], which indicates that our new program can infer the haplotypes more precisely.</p>
      <table-wrap position="float" id="T5">
        <label>Table 5</label>
        <caption>
          <p>The experimental results for pedigrees P1 to P4. </p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="left">P1</td>
              <td align="left">P2</td>
              <td align="left">P3</td>
              <td align="left">P4</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">No. of Breakpoints</td>
              <td align="left">20.49</td>
              <td align="left">20.20</td>
              <td align="left">14.20</td>
              <td align="left">20.38</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">precision</td>
              <td align="left">0.58</td>
              <td align="left">0.77</td>
              <td align="left">0.49</td>
              <td align="left">0.57</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">recall</td>
              <td align="left">0.63</td>
              <td align="left">0.72</td>
              <td align="left">0.43</td>
              <td align="left">0.53</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of real linked region (cM)</td>
              <td align="left">34.69</td>
              <td align="left">36.42</td>
              <td align="left">43.89</td>
              <td align="left">41.28</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of found linked region (cM)</td>
              <td align="left">45.84</td>
              <td align="left">47.28</td>
              <td align="left">62.88</td>
              <td align="left">43.25</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/real</td>
              <td align="left">0.99</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">1</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/found</td>
              <td align="left">0.83</td>
              <td align="left">0.80</td>
              <td align="left">0.75</td>
              <td align="left">0.95</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">linked region recovery</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">1</td>
              <td align="left">1</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>The meaning of each line is the same as in Table 2.</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap position="float" id="T6">
        <label>Table 6</label>
        <caption>
          <p>The experimental results for pedigrees P5 to P8.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="left">P5</td>
              <td align="left">P6</td>
              <td align="left">P7</td>
              <td align="left">P8</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">No. of Breakpoints</td>
              <td align="left">20.81 (31.60)</td>
              <td align="left">26.37 (47.27)</td>
              <td align="left">38.83 (108.4)</td>
              <td align="left">44.65 (145.4)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">precision</td>
              <td align="left">0.86 (0.45)</td>
              <td align="left">0.96 (0.41)</td>
              <td align="left">0.97 (0.26)</td>
              <td align="left">0.90 (0.23)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">recall</td>
              <td align="left">0.82 (0.66)</td>
              <td align="left">0.94 (0.71)</td>
              <td align="left">0.93 (0.71)</td>
              <td align="left">0.92 (0.76)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of real linked region (cM)</td>
              <td align="left">38.58</td>
              <td align="left">19.77</td>
              <td align="left">21.92</td>
              <td align="left">12.37</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of found linked region (cM)</td>
              <td align="left">41.00 (43.28)</td>
              <td align="left">22.98 (23.51)</td>
              <td align="left">23.37 (24.57)</td>
              <td align="left">16.04 (16.20)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/real</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/found</td>
              <td align="left">0.93 (0.93)</td>
              <td align="left">0.86 (0.84)</td>
              <td align="left">0.91 (0.91)</td>
              <td align="left">0.79 (0.78)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">linked region recovery</td>
              <td align="left">1.00<break/>(232/285)</td>
              <td align="left">1.00<break/>(266/285)</td>
              <td align="left">1.00<break/>(228/285)</td>
              <td align="left">1.00<break/>(265/285)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p> The meaning of each line is the same as in Table 2.</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap position="float" id="T7">
        <label>Table 7</label>
        <caption>
          <p>The experimental results for pedigrees P9 to P12.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="left">P9</td>
              <td align="left">P10</td>
              <td align="left">P11</td>
              <td align="left">P12</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">No. of Breakpoints</td>
              <td align="left">23.43 (41.07)</td>
              <td align="left">18.46 (26.38)</td>
              <td align="left">37.44 (92.49)</td>
              <td align="left">20.68 (31.52)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">precision</td>
              <td align="left">0.95 (0.40)</td>
              <td align="left">0.92 (0.49)</td>
              <td align="left">0.91 (0.29)</td>
              <td align="left">0.94 (0.47)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">recall</td>
              <td align="left">0.91 (0.67)</td>
              <td align="left">0.89 (0.68)</td>
              <td align="left">0.89 (0.70)</td>
              <td align="left">0.91 (0.71)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of real linked region (cM)</td>
              <td align="left">29.80</td>
              <td align="left">26.06</td>
              <td align="left">22.26</td>
              <td align="left">22.05</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of found linked region (cM)</td>
              <td align="left">32.01 (36.72)</td>
              <td align="left">28.26 (31.93)</td>
              <td align="left">24.07 (24.53)</td>
              <td align="left">29.78 (30.57)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/real</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/found</td>
              <td align="left">0.90 (0.81)</td>
              <td align="left">0.91 (0.83)</td>
              <td align="left">0.90 (0.89)</td>
              <td align="left">0.80 (0.78)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">linked region recovery</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (90/95)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p> The meaning of each line is the same as in Table 2.</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap position="float" id="T8">
        <label>Table 8</label>
        <caption>
          <p>The experimental results for pedigrees P13 to P16. </p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="left">P13</td>
              <td align="left">P14</td>
              <td align="left">P15</td>
              <td align="left">P16</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">No. of Breakpoints</td>
              <td align="left">23.56 (46.66)</td>
              <td align="left">44.20 (124.0)</td>
              <td align="left">31.37 (48.25)</td>
              <td align="left">34.60 (69.26)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">precision</td>
              <td align="left">0.97 (0.37)</td>
              <td align="left">0.98 (0.27)</td>
              <td align="left">0.96 (0.47)</td>
              <td align="left">0.88 (0.38)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">recall</td>
              <td align="left">0.94 (0.71)</td>
              <td align="left">0.95 (0.75)</td>
              <td align="left">0.93 (0.71)</td>
              <td align="left">0.87 (0.75)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of real linked region (cM)</td>
              <td align="left">21.36</td>
              <td align="left">18.22</td>
              <td align="left">21.41</td>
              <td align="left">18.40</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">length of found linked region (cM)</td>
              <td align="left">25.61 (25.91)</td>
              <td align="left">19.68 (20.42)</td>
              <td align="left">25.12 (27.60)</td>
              <td align="left">21.81 (22.39)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/real</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">0.99 (1.00)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">overlap/found</td>
              <td align="left">0.86 (0.84)</td>
              <td align="left">0.90 (0.89)</td>
              <td align="left">0.88 (0.81)</td>
              <td align="left">0.86 (0.85)</td>
            </tr>
            <tr>
              <td colspan="5">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">linked region recovery</td>
              <td align="left">1.00 (84/95)</td>
              <td align="left">1.00 (75/95)</td>
              <td align="left">1.00 (1.00)</td>
              <td align="left">1.00 (1.00)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>The meaning of each line is the same as in Table 2.</p>
        </table-wrap-foot>
      </table-wrap>
      <fig position="float" id="F3">
        <label>Figure 3</label>
        <caption>
          <p><bold>Pedigrees P5 to P8</bold>.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-216-3"/>
      </fig>
      <fig position="float" id="F4">
        <label>Figure 4</label>
        <caption>
          <p><bold>Pedigrees P9 to P12</bold>.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-216-4"/>
      </fig>
      <fig position="float" id="F5">
        <label>Figure 5</label>
        <caption>
          <p><bold>Pedigrees P13 to P14</bold>.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-216-5"/>
      </fig>
      <fig position="float" id="F6">
        <label>Figure 6</label>
        <caption>
          <p><bold>Pedigrees P15 to P16</bold>.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-216-6"/>
      </fig>
    </sec>
    <sec>
      <title>A Case Study</title>
      <p>We studied a pedigree to see if the program can correctly identify the linked region when some of the family members are purposely excluded. The pedigree is shown in Figure <xref ref-type="fig" rid="F7">7</xref>. The simulated allele sharing status and the linked region are shown in Figure <xref ref-type="fig" rid="F8">8</xref>. Each individual has two haplotypes, paternal haplotype and maternal haplotype. Note that individual D is the founder of the disease in the family. The two haplotypes of individual D are shown as 1-th haplotype and 0-th haplotype at the top and at the bottom, respectively. Any other individual may inherit alleles from both 0-th haplotype and 1-th haplotype of individual D. Thus, any other individual in the family appears twice (upper part and lower part) in the figure. The upper part shows the segments inherited from the 1-th haplotype of D and the lower part shows the segments inherited from the 0-th haplotype of D. The segments from diseased individuals are red and the segments from normal individuals are blue. At any position in the chromosome, each second generation individual gets an allele from D that is either from the 0-th haplotype or 1-th haplotype. For the third generation individual, say, C1, the allele at a position may or may not be from D. The simulated (true) linked region is from 189.61 cM to 211.55 cM (physical position from 169183745 bps to 197201161 bps) indicated by the horizontal black double-direction arrow in the middle. The inferred configuration is shown in Figure <xref ref-type="fig" rid="F9">9</xref>. We can see that the inferred configuration is roughly the same as the simulated configuration except that it is upside down. The inferred linked region is from 189.61 cM(169174855 bps) to 211.63 cM(197295627 bps). The inferred linked region remains the same if we exclude individual E or F. The inferred linked region also remains unchanged if we simultaneously remove E, M and N. When we simultaneously remove E, K, N, D1, D2 and D3, the inferred linked region is from 189.61 cM to 225.48 cM, which is only slightly enlarged. When we simultaneously remove E, F, M, C1, C2, C3 and C4, the inferred linked region is again enlarged and the region is from 172.07 cM to 211.63 cM. When F, K, N, D1, D2 and D3 are simultaneously removed from the pedigree, the inferred linked region is from 189.61 cM and 221.90 cM.</p>
      <fig position="float" id="F7">
        <label>Figure 7</label>
        <caption>
          <p><bold>A pedigree for case study</bold>.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-216-7"/>
      </fig>
      <fig position="float" id="F8">
        <label>Figure 8</label>
        <caption>
          <p><bold>The simulated grand-paternal haplotype allele sharing status among all members, excluding grandmother</bold>. Each individual has two haplotypes, paternal haplotype and maternal haplotype. Note that individual D is the founder of the disease in the family. The two haplotypes of individual D are shown as 1-th haplotype and 0-th haplotype at the top and at the bottom, respectively. Any other individual may inherit alleles from both 0-th haplotype and 1-th haplotype of individual D. Thus, any other individual in the family appears twice (upper part and lower part) in the figure. The upper part shows the segments inherited from the 1-th haplotype of D and the lower part shows the segments inherited from the 0-th haplotype of D. The segments from diseased individuals are red and the segments from normal individuals are blue. The simulated (true) linked region is indicated by the horizontal black double-direction arrow in the middle.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-216-8"/>
      </fig>
      <fig position="float" id="F9">
        <label>Figure 9</label>
        <caption>
          <p><bold>The inferred grand-paternal haplotype allele sharing status among all members, excluding grandmother</bold>.</p>
        </caption>
        <graphic xlink:href="1471-2105-10-216-9"/>
      </fig>
    </sec>
    <sec>
      <title>Genotype data error correction</title>
      <p>To test the effect of genotype data errors on our program, we did experiments on the pedigree in Figure <xref ref-type="fig" rid="F7">7</xref>. We generated genotype errors by randomly changing the genotype value (which is one of AA, BB and AB) into a different value (which is one of the other two values) at a position with probability 0.1% and 0.5%, respectively. We simulated 475 data sets. The length of real linked region ranges from 0.76 cM to 65.17 cM. The experimental results are shown in Table <xref ref-type="table" rid="T9">9</xref>. For each cell, there are two values. The first one is by our program and the one in brackets is by the program in [<xref ref-type="bibr" rid="B6">6</xref>]. We can see that our program performs better and can always recover the real linked regions.</p>
      <table-wrap position="float" id="T9">
        <label>Table 9</label>
        <caption>
          <p>The experimental results for genotype data error correction using Affymetrix 50 K GeneChips data.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="left">precision</td>
              <td align="left">recall</td>
              <td align="left">linked region recovery</td>
              <td align="left">overlap/real</td>
              <td align="left">overlap/found</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">No error</td>
              <td align="left">97.74%</td>
              <td align="left">95.05%</td>
              <td align="left">100%</td>
              <td align="left">99.98%</td>
              <td align="left">92.46%</td>
            </tr>
            <tr>
              <td/>
              <td align="left">(69.62%)</td>
              <td align="left">(86.56%)</td>
              <td align="left">(100%)</td>
              <td align="left">(100%)</td>
              <td align="left">(91.78%)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">0.1% error</td>
              <td align="left">84.40%</td>
              <td align="left">94.94%</td>
              <td align="left">100%</td>
              <td align="left">99.93%</td>
              <td align="left">92.00%</td>
            </tr>
            <tr>
              <td/>
              <td align="left">(67.19%)</td>
              <td align="left">(86.19%)</td>
              <td align="left">(100%)</td>
              <td align="left">(100%)</td>
              <td align="left">(91.13%)</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">0.5% error</td>
              <td align="left">79.00%</td>
              <td align="left">93.76%</td>
              <td align="left">100%</td>
              <td align="left">99.84%</td>
              <td align="left">92.57%</td>
            </tr>
            <tr>
              <td/>
              <td align="left">(61.81%)</td>
              <td align="left">(86.10%)</td>
              <td align="left">(100%)</td>
              <td align="left">(100%)</td>
              <td align="left">(91.94%)</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>Comparison with Merlin</title>
      <p>We compared our program with Merlin [<xref ref-type="bibr" rid="B16">16</xref>]. We did the experiments on a PC with a CPU of 3.0 GHz and 1.00 GB memory. The results are shown in Table <xref ref-type="table" rid="T10">10</xref> and Table <xref ref-type="table" rid="T11">11</xref> for Affymetrix 50 K GeneChips and Affymetrix 250 K GeneChips, respectively. We have also considered different kinds of pedigrees.</p>
      <table-wrap position="float" id="T10">
        <label>Table 10</label>
        <caption>
          <p>Comparison with Merlin using Affymetrix 50 K GeneChips. </p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="left">Run time (s)</td>
              <td align="left">overlap/real</td>
              <td align="left">overlap/found</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0+3</td>
              <td align="left">16.717 (0.898)</td>
              <td align="left">0.941 (0.805)</td>
              <td align="left">0.605 (0.862)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">0+4</td>
              <td align="left">23.325 (1.126)</td>
              <td align="left">0.928 (0.824)</td>
              <td align="left">0.594 (0.930)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">0+5</td>
              <td align="left">30.634 (1.746)</td>
              <td align="left">0.941 (0.901)</td>
              <td align="left">0.587 (0.936)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">0+6</td>
              <td align="left">39.028 (3.901)</td>
              <td align="left">0.987 (0.929)</td>
              <td align="left">0.576 (0.969)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">2+3(4 bits)</td>
              <td align="left">3.276 (1.340)</td>
              <td align="left">1.000 (0.928)</td>
              <td align="left">0.960 (1)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">2+4(6 bits)</td>
              <td align="left">4.596 (1.735)</td>
              <td align="left">0.9997 (0.937)</td>
              <td align="left">0.967 (0.990)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P5(7 bits)</td>
              <td align="left">7.714 (2.325)</td>
              <td align="left">0.999 (0.933)</td>
              <td align="left">0.919 (0.979)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P9(9 bits)</td>
              <td align="left">7.365 (3.255)</td>
              <td align="left">0.999 (0.879)</td>
              <td align="left">0.926 (0.958)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P10(11 bits)</td>
              <td align="left">19.15 (8.829)</td>
              <td align="left">0.999 (0.797)</td>
              <td align="left">0.912 (0.968)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P11(12 bits)</td>
              <td align="left">11.37 (14.01)</td>
              <td align="left">1.000 (0.938)</td>
              <td align="left">0.924 (0.979)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P12(13 bits)</td>
              <td align="left">25.62 (31.57)</td>
              <td align="left">1.000 (0.922)</td>
              <td align="left">0.842 (0.958)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P7(14 bits)</td>
              <td align="left">13.58 (58.14)</td>
              <td align="left">1.000 (0.949)</td>
              <td align="left">0.933 (0.990)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P15(14 bits)</td>
              <td align="left">46.96 (43.15)</td>
              <td align="left">1.000 (0.906)</td>
              <td align="left">0.894 (0.979)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P13(15 bits)</td>
              <td align="left">23.72 (1282.05)</td>
              <td align="left">1.000 (0.970)</td>
              <td align="left">0.875 (1)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P16(15 bits)</td>
              <td align="left">37.93 (384.78)</td>
              <td align="left">0.988 (0.950)</td>
              <td align="left">0.877 (0.990)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P14(16 bits)</td>
              <td align="left">15.042 (NA)</td>
              <td align="left">1.000 (NA)</td>
              <td align="left">0.927 (NA)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P6(17 bits)</td>
              <td align="left">40.754 (NA)</td>
              <td align="left">1.000 (NA)</td>
              <td align="left">0.869 (NA)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Each cell contains two values. The first one is by our program and the one in brackets is by Merlin. Pedigree 0+i for i = 3, 4, 5 and 6 stands for a nuclear family with i children and the genotype data for parents is not available. Pedigree 2+i for i = 3 and 4 stands for a nuclear family with i children and the genotype data for both parents is available. "NA" means that the program failed to execute on this pedigree.</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap position="float" id="T11">
        <label>Table 11</label>
        <caption>
          <p>Comparison with Merlin using Affymetrix 250 K GeneChips. </p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="left">Run time (s)</td>
              <td align="left">overlap/real</td>
              <td align="left">overlap/found</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0+3</td>
              <td align="left">67.680 (2.979)</td>
              <td align="left">0.954 (0.975)</td>
              <td align="left">0.590 (0.866)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">0+4</td>
              <td align="left">97.082 (4.067)</td>
              <td align="left">0.965 (0.988)</td>
              <td align="left">0.548 (0.955)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">0+5</td>
              <td align="left">124.43 (6.558)</td>
              <td align="left">0.983 (0.994)</td>
              <td align="left">0.607 (0.960)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">0+6</td>
              <td align="left">131.71 (12.50)</td>
              <td align="left">0.994 (0.992)</td>
              <td align="left">0.675 (0.986)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">2+3(4 bits)</td>
              <td align="left">9.454 (7.122)</td>
              <td align="left">1 (0.936)</td>
              <td align="left">0.995 (1)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">2+4(6 bits)</td>
              <td align="left">11.625 (8.133)</td>
              <td align="left">1 (0.989)</td>
              <td align="left">0.988 (1)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P5(7 bits)</td>
              <td align="left">16.662 (8.262)</td>
              <td align="left">1 (0.892)</td>
              <td align="left">0.983 (0.938)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P9(9 bits)</td>
              <td align="left">24.18 (16.65)</td>
              <td align="left">1.000 (0.934)</td>
              <td align="left">0.973 (1)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P10(11 bits)</td>
              <td align="left">38.54 (31.39)</td>
              <td align="left">1.000 (0.797)</td>
              <td align="left">0.970 (0.938)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P11(12 bits)</td>
              <td align="left">29.94 (415.18)</td>
              <td align="left">1.000 (0.991)</td>
              <td align="left">0.972 (1)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P12(13 bits)</td>
              <td align="left">49.28 (1237.7)</td>
              <td align="left">1.000 (0.968)</td>
              <td align="left">0.871 (1)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P7(14 bits)</td>
              <td align="left">31.611 (NA)</td>
              <td align="left">1(NA)</td>
              <td align="left">0.960(NA)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P15(14 bits)</td>
              <td align="left">103.269 (NA)</td>
              <td align="left">1(NA)</td>
              <td align="left">0.927(NA)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P13(15 bits)</td>
              <td align="left">54.114 (NA)</td>
              <td align="left">1.000(NA)</td>
              <td align="left">0.881(NA)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P16(15 bits)</td>
              <td align="left">141.266 (NA)</td>
              <td align="left">0.991(NA)</td>
              <td align="left">0.922(NA)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P14(16 bits)</td>
              <td align="left">52.911 (NA)</td>
              <td align="left">1(NA)</td>
              <td align="left">0.979(NA)</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">P6(17 bits)</td>
              <td align="left">63.984 (NA)</td>
              <td align="left">1.000(NA)</td>
              <td align="left">0.862(NA)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Each cell contains two values. The first one is by our program and the one in brackets is by Merlin. Pedigree 0+i for i = 3, 4, 5 and 6 stands for a nuclear family with i children and the genotype data for both parents is not available. Pedigree 2+i for i = 3 and 4 stands for a nuclear family with i children and the genotype data for both parents is available. "NA" means that the program failed to execute on this pedigree.</p>
        </table-wrap-foot>
      </table-wrap>
      <sec>
        <title>Running time</title>
        <p>For small sized families, both programs can generate results in a few seconds. When the sizes of the families and the number of the markers increase, the running time of our program increases linearly. For large families, Merlin requires really long running time. Most importantly, Merlin needs large memory space for big sized families and cannot successfully complete the computation for some pedigrees (see P14 and P6 in Table <xref ref-type="table" rid="T10">10</xref> and Table <xref ref-type="table" rid="T11">11</xref>).</p>
      </sec>
      <sec>
        <title>Output Quality</title>
        <p>We again use "overlap/real" and "overlap/found" to indicate the quality of the computational results. Our program always clearly gives a computed candidate region for each input. Merlin calculates a LOD score for each marker. We evaluated the segment with the highest LOD score as the output linked region for Merlin. From Table <xref ref-type="table" rid="T10">10</xref> and Table <xref ref-type="table" rid="T11">11</xref>, we can see that the results of our program are less than optimal when parental data is not available at all. When the family size becomes bigger, our program outperforms Merlin. Our program can quickly produce accurate linked regions when the family size is big while Merlin failed to execute on big sized families.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Conclusion</title>
    <p>We have developed a software package that infers the haplotype allele sharing status for the members of a pedigree based on the minimum recombinants model. The running time of the program is linear in terms of the input size <italic>O</italic>(<italic>mn</italic>), where <italic>m </italic>is the total number of individuals in the whole family and <italic>n </italic>is the number of SNP sites in the chromosome. The new package can handle a wide range of pedigree structures. It works very well for cases where the genotype data of one parent is missing for the entire chromosome.</p>
  </sec>
  <sec>
    <title>Availability and requirements</title>
    <p><bold>Project Name</bold>: CityU 121608</p>
    <p><bold>Project Homepage</bold>: <ext-link ext-link-type="uri" xlink:href="http://www.cs.cityu.edu.hk/~lwang/software/Link"/></p>
    <p><bold>Operating system(s)</bold>: Platform independent</p>
    <p><bold>Programming language</bold>: Java</p>
    <p><bold>Other requirements</bold>: Java 1.6.0 or higher</p>
    <p><bold>Licence</bold>: None</p>
    <p><bold>Any restrictions to use by non-academics</bold>: None</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>LW carried out the algorithm design, provided some of initial pseudo codes, checked part of computer codes, participated in the design of experiments, and drafted the manuscript. ZW produced the computer program, carried out the experiments, drafted experiment results, and participated in algorithm design. WY initiated the study, participated in the design of experiments, polished the manuscript, and was in charge of communication with the editor. All the authors read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <ack>
    <sec>
      <title>Acknowledgements</title>
      <p>We thank the referees for their helpful suggestions. Lusheng Wang is fully supported by a grant from the Research Grants Council of the Hong Kong Special Administrative Region, China [Project No. CityU 121608].</p>
    </sec>
  </ack>
  <ref-list>
    <ref id="B1">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <collab>The International HapMap Consortium</collab>
        </person-group>
        <article-title>A second generation human haplotype map of over 3.1 million SNPs</article-title>
        <source>Nature</source>
        <year>2007</year>
        <volume>449</volume>
        <fpage>851</fpage>
        <lpage>861</lpage>
        <pub-id pub-id-type="pmid">17943122</pub-id>
        <pub-id pub-id-type="doi">10.1038/nature06258</pub-id>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Leykin</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Hao</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Cheng</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Meyer</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Pollak</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Smith</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Rosenow</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Comparative linkage analysis and visualization of high-density oligonucleotide SNP array data</article-title>
        <source>BMC Genet</source>
        <year>2005</year>
        <volume>6</volume>
        <fpage>7</fpage>
        <pub-id pub-id-type="pmid">15713228</pub-id>
        <pub-id pub-id-type="doi">10.1186/1471-2156-6-7</pub-id>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sellick</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Longman</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Tolmie</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Newbury-Ecob</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Geenhalgh</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Hughes</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Whiteford</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Garrett</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Houlston</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Genomewide linkage searches for mendelian disease loci can be efficiently conducted using high-density SNP genotyping arrays</article-title>
        <source>Nucleic Acids Res</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>e164</fpage>
        <pub-id pub-id-type="pmid">15561999</pub-id>
        <pub-id pub-id-type="doi">10.1093/nar/gnh163</pub-id>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Elston</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Stewart</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>A general model for the genetic analysis of pedigree data</article-title>
        <source>Hum Hered</source>
        <year>1971</year>
        <volume>21</volume>
        <fpage>523</fpage>
        <lpage>542</lpage>
        <pub-id pub-id-type="pmid">5149961</pub-id>
        <pub-id pub-id-type="doi">10.1159/000152448</pub-id>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lander</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Green</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Construction of multilocus genetic linkage maps in humans</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>1987</year>
        <volume>84</volume>
        <fpage>2363</fpage>
        <lpage>2367</lpage>
        <pub-id pub-id-type="pmid">3470801</pub-id>
        <pub-id pub-id-type="doi">10.1073/pnas.84.8.2363</pub-id>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lin</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Lau</surname>
            <given-names>YL</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Identification of linked regions using high-density SNP genotype data in linkage analysis</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>86</fpage>
        <lpage>93</lpage>
        <pub-id pub-id-type="pmid">18024969</pub-id>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btm552</pub-id>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Qian</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Beckmann</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Minimum recombinant haplotyping in pedigrees</article-title>
        <source>Am J Hum Genet</source>
        <year>2002</year>
        <volume>70</volume>
        <fpage>1434</fpage>
        <lpage>1445</lpage>
        <pub-id pub-id-type="pmid">11992251</pub-id>
        <pub-id pub-id-type="doi">10.1086/340610</pub-id>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Efficient inference of haplotypes from genotypes on a pedigree</article-title>
        <source>J Bioinform Comput Bio</source>
        <year>2003</year>
        <volume>1</volume>
        <fpage>41</fpage>
        <lpage>69</lpage>
        <pub-id pub-id-type="pmid">15290781</pub-id>
        <pub-id pub-id-type="doi">10.1142/S0219720003000204</pub-id>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Doi</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Minimum recombinant haplotype configuration on tree pedigrees</article-title>
        <source>Proc of the 3rd Annual Workshop on Algorithms in Bioinformatics (WABI'03)</source>
        <year>2003</year>
        <fpage>339</fpage>
        <lpage>353</lpage>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Computing the minimum recombinant haplotype configuration from incomplete genotype data on a pedigree by integer linear programming</article-title>
        <source>Journal of Computational Biology</source>
        <year>2005</year>
        <volume>12</volume>
        <fpage>719</fpage>
        <lpage>739</lpage>
        <pub-id pub-id-type="pmid">16108713</pub-id>
        <pub-id pub-id-type="doi">10.1089/cmb.2005.12.719</pub-id>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="other">
        <article-title>Affymetrix Human Mapping GeneChips</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www.affymetrix.com/products_services/arrays/specific/100k.affx"/>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Broman</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Weber</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Characterization of human crossover interference</article-title>
        <source>Am J Hum Genet</source>
        <year>2000</year>
        <volume>66</volume>
        <fpage>1911</fpage>
        <lpage>1926</lpage>
        <pub-id pub-id-type="pmid">10801387</pub-id>
        <pub-id pub-id-type="doi">10.1086/302923</pub-id>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhao</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Speed</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>McPeek</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Statistical analysis of crossover interference using the chi-square model</article-title>
        <source>Genetics</source>
        <year>1995</year>
        <volume>139</volume>
        <fpage>1045</fpage>
        <lpage>1056</lpage>
        <pub-id pub-id-type="pmid">7713407</pub-id>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="other">
        <article-title>International HapMap Project</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www.hapmap.org"/>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yang</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Sham</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Lau</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>Predicting the number and sizes of IBD regions among family members and evaluating the family size requirement for linkage studies</article-title>
        <source>European Journal of Human Genetics</source>
        <year>2008</year>
        <volume>16</volume>
        <fpage>1535</fpage>
        <lpage>1543</lpage>
        <pub-id pub-id-type="pmid">18575462</pub-id>
        <pub-id pub-id-type="doi">10.1038/ejhg.2008.116</pub-id>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abecasis</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Cherny</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Cookson</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Cardon</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Merlin – rapid analysis of dense genetic maps using sparse gene flow trees</article-title>
        <source>Nature Genetics</source>
        <year>2002</year>
        <volume>30</volume>
        <fpage>97</fpage>
        <lpage>101</lpage>
        <pub-id pub-id-type="pmid">11731797</pub-id>
        <pub-id pub-id-type="doi">10.1038/ng786</pub-id>
      </citation>
    </ref>
  </ref-list>
</back>
