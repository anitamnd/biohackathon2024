<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5860201</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btx558</article-id>
    <article-id pub-id-type="publisher-id">btx558</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>DART: a fast and accurate RNA-seq mapper with a partitioning strategy</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Lin</surname>
          <given-names>Hsin-Nan</given-names>
        </name>
        <xref ref-type="aff" rid="btx558-aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hsu</surname>
          <given-names>Wen-Lian</given-names>
        </name>
        <xref ref-type="corresp" rid="btx558-cor1"/>
        <!--<email>hsu@iis.sinica.edu.tw</email>-->
        <xref ref-type="aff" rid="btx558-aff1"/>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Berger</surname>
          <given-names>Bonnie</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <aff id="btx558-aff1">Institute of Information Science, Academia Sinica, Taipei, Taiwan</aff>
    <author-notes>
      <corresp id="btx558-cor1">To whom correspondence should be addressed. Email: <email>hsu@iis.sinica.edu.tw</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>1</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2017-09-05">
      <day>05</day>
      <month>9</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>9</month>
      <year>2017</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>34</volume>
    <issue>2</issue>
    <fpage>190</fpage>
    <lpage>197</lpage>
    <history>
      <date date-type="received">
        <day>02</day>
        <month>5</month>
        <year>2017</year>
      </date>
      <date date-type="rev-recd">
        <day>29</day>
        <month>8</month>
        <year>2017</year>
      </date>
      <date date-type="accepted">
        <day>3</day>
        <month>9</month>
        <year>2017</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Â© The Author 2017. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2017</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by-nc/4.0/" license-type="cc-by-nc">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btx558.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>In recent years, the massively parallel cDNA sequencing (RNA-Seq) technologies have become a powerful tool to provide high resolution measurement of expression and high sensitivity in detecting low abundance transcripts. However, RNA-seq data requires a huge amount of computational efforts. The very fundamental and critical step is to align each sequence fragment against the reference genome. Various <italic>de novo</italic> spliced RNA aligners have been developed in recent years. Though these aligners can handle spliced alignment and detect splice junctions, some challenges still remain to be solved. With the advances in sequencing technologies and the ongoing collection of sequencing data in the ENCODE project, more efficient alignment algorithms are highly demanded. Most read mappers follow the conventional seed-and-extend strategy to deal with inexact matches for sequence alignment. However, the extension is much more time consuming than the seeding step.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We proposed a novel RNA-seq de novo mapping algorithm, call DART, which adopts a partitioning strategy to avoid the extension step. The experiment results on synthetic datasets and real NGS datasets showed that DART is a highly efficient aligner that yields the highest or comparable sensitivity and accuracy compared to most state-of-the-art aligners, and more importantly, it spends the least amount of time among the selected aligners.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>
          <ext-link ext-link-type="uri" xlink:href="https://github.com/hsinnan75/DART">https://github.com/hsinnan75/DART</ext-link>
        </p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Ministry of Science and Technology</named-content>
          <named-content content-type="funder-identifier">10.13039/100007225</named-content>
        </funding-source>
        <award-id>105-2319-B-400-002</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Transcriptome analysis is the genome-wide study of gene structures and activities. It involves the identification of novel transcripts and the quantification of gene expression. DNA microarray technique is a very popular approach to study gene expression levels. However, the probe-target hybridization limits the accuracy of expression measurements, and it also limits to study only those genes for which probes are designed (<xref rid="btx558-B32" ref-type="bibr">Zhao <italic>et al.</italic>, 2014</xref>). With the emergence of the next generation sequencing (NGS) platforms in recent years, the massively parallel cDNA sequencing (RNA-Seq) technologies have become another powerful tool to provide high resolution measurement of expression and high sensitivity in detecting low abundance transcripts. RNA-Seq does not require prior gene annotation and therefore is able to study unknown transcripts. Recent studies have showed that RNA-Seq demonstrates superior benefits over microarray in transcriptome profiling, though DNA microarrays are irreplaceable and they are still widely used when conducting transcriptional profiling experiments (<xref rid="btx558-B6" ref-type="bibr">Fu <italic>et al.</italic>, 2009</xref>; <xref rid="btx558-B27" ref-type="bibr">Sirbu <italic>et al.</italic>, 2012</xref>; <xref rid="btx558-B32" ref-type="bibr">Zhao <italic>et al.</italic>, 2014</xref>). One of the major reasons is that RNA-Seq data analysis is much more complicated. It requires a huge amount of computational efforts. A typical human RNA-Sequencing experiment can generate up to billions of short sequence fragments. The very fundamental and critical step in the RNA-Seq analysis is to align each sequence fragment (or read) against a reference genome, followed by quantification of genes and identification of differentially expressed genes (<xref rid="btx558-B7" ref-type="bibr">Garber <italic>et al.</italic>, 2011</xref>).</p>
    <p>The alignment of a short read for DNA-resequencing or RNA-Seq against a reference genome is to identify the coordinate where the read originates. However, the task of RNA-Seq alignment is more challenging than that of conventional DNA-sequencing alignment. Although both types of alignments contain mismatches, insertions and deletions due to genomic variations and sequencing errors, the mature mRNA transcripts in eukaryotes are modified and they do not include intragenic regions (or introns) in the gene sequences. Thus a spliced RNA spans one or more introns and concatenate adjacent or distant exons, which may result in the alignment not contiguous and separated by large gaps. Though some RNA-Seq mappers, such as Erange (<xref rid="btx558-B25" ref-type="bibr">Mortazavi <italic>et al.</italic>, 2008</xref>), OSA (<xref rid="btx558-B11" ref-type="bibr">Hu <italic>et al.</italic>, 2012</xref>), SpliceSeq (<xref rid="btx558-B26" ref-type="bibr">Ryan <italic>et al.</italic>, 2012</xref>), etc.) align reads against a transcriptome to avoid introns in the reference, the gene annotation is incomplete for most of the studied organisms. Alignments based on the transcriptome would be biased toward known transcripts. Therefore, <italic>de novo</italic> spliced RNA aligners are more preferable to analyze RNA-Seq reads for detecting novel splice junctions.</p>
    <p>Various <italic>de novo</italic> spliced RNA aligners have been developed in recent years, which include QPALMA (<xref rid="btx558-B3" ref-type="bibr">De Bona <italic>et al.</italic>, 2008</xref>), TopHat (<xref rid="btx558-B28" ref-type="bibr">Trapnell <italic>et al.</italic>, 2009</xref>), GSNAP (<xref rid="btx558-B31" ref-type="bibr">Wu and Nacu, 2010</xref>) (and GSTRUCT is its successive version), PALMapper (<xref rid="btx558-B12" ref-type="bibr">Jean <italic>et al.</italic>, 2010</xref>), MapSplice (<xref rid="btx558-B29" ref-type="bibr">Wang <italic>et al.</italic>, 2010</xref>), RUM(<xref rid="btx558-B8" ref-type="bibr">Grant <italic>et al.</italic>, 2011</xref>), GEM (<xref rid="btx558-B24" ref-type="bibr">Marco-Sola <italic>et al.</italic>, 2012</xref>), STAR(<xref rid="btx558-B4" ref-type="bibr">Dobin <italic>et al.</italic>, 2013</xref>), TopHat2 (<xref rid="btx558-B14" ref-type="bibr">Kim <italic>et al.</italic>, 2013</xref>), HISAT (<xref rid="btx558-B13" ref-type="bibr">Kim <italic>et al.</italic>, 2015</xref>) and Subread (<xref rid="btx558-B21" ref-type="bibr">Liao <italic>et al.</italic>, 2013</xref>). In summary, most of the short read aligners basically adopt the seed-and-extend strategy (<xref rid="btx558-B19" ref-type="bibr">Li and Homer, 2010</xref>), which is sequential in nature and takes much longer time on the extension step for dealing with mismatches. In the seeding step, aligners use either a hash table or a suffix array (SA)/Burrows Wheeler Transform (BWT) index (<xref rid="btx558-B30" ref-type="bibr">Wheeler, 1994</xref>) to perform seed exploration. A hash table based aligner uses all the subsequences of k-mers to obtain occurrence locations. In contrast, a SA/BWT based aligner finds the maximal exact matches (MEM) between the read sequence and the reference genome. An MEM is the maximal exact match between two sequences, which cannot be extended further without allowing mismatches. MEMs have been widely used as seeds for whole genome alignment and NGS read alignment (<xref rid="btx558-B1" ref-type="bibr">Choi <italic>et al.</italic>, 2005</xref>; <xref rid="btx558-B17" ref-type="bibr">Li and Durbin, 2009</xref>; <xref rid="btx558-B23" ref-type="bibr">Liu and Schmidt, 2012</xref>). In the extension step, a dynamic programming algorithm or combined with a heuristic algorithm are often used to deal with mismatches or indels in the read alignments.</p>
    <p>An exonic read is a read that can be aligned completely within the corresponding exon and its alignment against the reference genome is relatively straightforward. In contrast, the more challenging task in RNA-Seq alignment is to deal with the reads that span one or more introns. They are referred to as spanned reads in this article. Many above-mentioned RNA-Seq aligners adopt similar strategy to handle spanned reads. A spanned read is split into appropriate fragments and each fragment can be aligned contiguously to a reference genome, and all the desirable sub-alignments within appropriate intron sizes are merged to form the complete alignment. However, these aligners differ in how they handle splice junction alignment.</p>
    <p>QPALMA used Support Vector Machines (SVMs) to learn splice junctions from a transcriptome dataset. It then infers spliced alignments from seed regions based on the trained scoring functions. TopHat finds junctions in two phases. It uses Bowtie/Bowtie2 to map all reads to the reference and then assembles the mapped reads to generate contiguous consensus sequences (called islands). It then constructs all candidate splice junctions from neighboring islands that could form canonical (GT-AG) introns. GSNAP identifies splice junctions with probabilistic models which are derived from the frequencies of nucleotides neighboring splice sites. MapSplice partitions a read sequence into some consecutive segment and identifies exonic alignment for each segment. If a segment contains spliced alignment, the splice junction can be easily discovered using the double-anchored search method between the neighboring segments with exonic alignment. STAR finds the Maximal Mappable Prefix (MMP, similar to MEM) for exonic alignment. It repeatedly finds the MMPs for the unmapped portion of the read, therefore, the splice junctions can be discovered naturally. HISAT is the first aligner that employs a hierarchical indexing strategy (global and local FM indexing) for spliced alignment. It applies different strategies to handle different exonic and spliced alignment types. Subread detects splice junctions with a two-scan procedure. It identifies junction sites between the best two mapping locations for each read (first scan), and then validates junctions by examining all mapping possibilities (second scan).</p>
    <p>Most of the above-mentioned aligners require considerable computing time to increase alignment sensitivity and accuracy. With the advances in sequencing technologies and the ongoing collection of sequencing data in the ENCODE project, more efficient algorithms are highly demanded to handle the huge amount of short reads as well as the associated sequence variations (<xref rid="btx558-B5" ref-type="bibr">Engstrom <italic>et al.</italic>, 2013</xref>). Furthermore, some aligners might fail to detect splice junctions if sequencing errors happen at their neighboring locations. In this study, we proposed a novel RNA-Seq mapping algorithm, call DART (Division based Alignment for RNA-Seq Transcripts) to handle spliced alignment without any annotation guidance. It is derived from our DNA read mapper, Kart (<xref rid="btx558-B22" ref-type="bibr">Lin and Hsu, 2017</xref>). DART adopts a partitioning strategy to handle RNA-Seq transcript alignments. Unlike most of read aligners that try to extend a seed in both directions with a dynamic programming step, DART divides a read sequence into one or more segments to replace the seed extension step. The experiment results on synthetic datasets and real datasets show that DART is a highly efficient aligner that yields the highest sensitivity and accuracy and spends the least amount of time among the selected aligners.</p>
    <p>We describe the details of the alignment algorithm of DART in the Methods section. Then we analyze and compare its performance with some selected state-of-the-art aligners in the Results section. DART can be freely downloaded from <ext-link ext-link-type="uri" xlink:href="https://github.com/hsinnan75/DART">https://github.com/hsinnan75/DART</ext-link>.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Overview of algorithms</title>
      <p>A unique feature of DART is that we adopt a <italic>partitioning</italic> strategy to handle the matches and mismatches separately between read sequences and the reference genome. DART divides a read alignment into two groups: simple region pairs (abbreviated as <italic>simple pairs</italic>) and normal region pairs (<italic>normal pairs</italic>), where all simple pairs have perfect alignment (exact match) and normal pairs require un-gapped or gapped alignment (due to mismatches or indels). Both simple pairs and normal pairs are referred to as <italic>fragment pairs</italic>. Once the fragment pairs are identified, they can be processed and aligned separately and the final mapping result is simply the concatenation of the alignment of each fragment pair.</p>
      <p>The mapping algorithm of DART consists of two main steps: seed exploration and candidate alignment processing. <xref ref-type="fig" rid="btx558-F1">Figure 1</xref> illustrates the idea of the algorithm. Given a read sequence <italic>R</italic>, DART identifies all simple pairs with a BWT search algorithm in the seed exploration step. In the candidate alignment step, adjacent simple pairs are clustered according to their coordinates. For example, the four simple pairs SP<sub>A</sub>, SP<sub>B</sub>, SP<sub>C</sub> and SP<sub>D</sub> in <xref ref-type="fig" rid="btx558-F1">Figure 1</xref> are clustered together because they are aligned in the neighboring regions. Then DART fills the gaps between simple pairs if they are in the same exonic region. The gap between SP<sub>A</sub> and SP<sub>B</sub> appears because a deletion happens in the read sequence and that between SP<sub>C</sub> and SP<sub>D</sub> appears because a sequencing error occurs in the read sequence. Thus, DART will generate the corresponding normal pairs for the two intra-exonic gaps. Adjacent simple pairs and the supplementary normal pairs form a complete alignment for the given read sequence. It is noteworthy that the gap between SP<sub>B</sub> and SP<sub>C</sub> is due to the splice junction and it is referred to as an intragenic gap. There is no need to add a normal pair for such gaps. DART discovers splice junctions according to the intragenic gaps between adjacent fragment pairs. The detailed implementation of the two main steps are described below.
</p>
      <fig id="btx558-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>The mapping idea of DART. The mapping can be divided into simple and normal pairs to deal with exact matches and mismatches separately</p>
        </caption>
        <graphic xlink:href="btx558f1"/>
      </fig>
    </sec>
    <sec>
      <title>2.2 Seed exploration</title>
      <p>Consider a read sequence <italic>R</italic>, the reference genome <italic>G</italic>, and the BWT array constructed from <italic>G</italic> and its reverse sequence <italic>Gâ</italic>. For simplicity and without losing generality, we assume <italic>G</italic> is the concatenation of <italic>G</italic> and <italic>Gâ</italic> in the following description. Let <italic>R</italic>[<italic>i</italic><sub>1</sub>] be the <italic>i</italic><sub>1</sub>th nucleotide of <italic>R</italic>, and <italic>R</italic>[<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>] be the subsequence between <italic>R</italic>[<italic>i</italic><sub>1</sub>] and <italic>R</italic>[<italic>i</italic><sub>2</sub>]. Similarly, let <italic>G</italic>[<italic>j</italic><sub>1</sub>] be the <italic>j</italic><sub>1</sub>th nucleotide of <italic>G</italic>, and <italic>G</italic>[<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>] be the subsequence between <italic>G</italic>[<italic>j</italic><sub>1</sub>] and <italic>G</italic>[<italic>j</italic><sub>2</sub>]. A <italic>locally maximal exact matches</italic> (LMEMs) on the BWT array of length <italic>l</italic> is defined as a common substring between <italic>R</italic>[<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>] and <italic>G</italic>[<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>] (i.e. <italic>R</italic>[<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>]â=â<italic>G</italic>[<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>]) and it cannot be extended in either direction of <italic>R</italic>[<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>] and <italic>G</italic>[<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>] without allowing for a mismatch. This LMEM is denoted by a 4-tuple (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, <italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>) where <italic>i</italic><sub>2</sub> â <italic>i</italic><sub>1</sub>â=â<italic>j</italic><sub>2</sub>â<italic>j</italic><sub>1</sub> =â<italic>l</italic>â1.We use ÎPosâ=â(<italic>j</italic><sub>1</sub><italic>- i</italic><sub>1</sub>) to represent the position difference of an LMEM.</p>
      <p>Dart finds all LMEMs by traversing a BWT array. The traversal algorithm is identical to that described in (<xref rid="btx558-B17" ref-type="bibr">Li and Durbin, 2009</xref>). Readers who are interested in the search algorithm are referred to the article. The traversal starts from <italic>R</italic>[<italic>i</italic><sub>1</sub>] and stops at <italic>R</italic>[<italic>i</italic><sub>2</sub>] if the exact matching meets a mismatch at <italic>R</italic>[<italic>i</italic><sub>2</sub>+1], i.e. R[<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>] is a substring of the reference sequence, whereas R[<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>+1] is not. The next LMEM exploration will start from <italic>R</italic>[<italic>i</italic><sub>2</sub>+1] until it reaches the end of the read sequence. DART only keeps those LMEMs whose sizes are no less than a predefined threshold <italic>k</italic> and whose occurrences are less than 50. The value <italic>k</italic> is determined based on the size of the reference genome. Each qualified LMEM is then converted into one or more simple pairs according to the occurrences. If <italic>R</italic>[<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>] has multiple copies in <italic>G</italic>, then each copy is denoted by a 4-tuple respectively. For example, <italic>R</italic>[1, 20] is the longest substring that matches two substrings of <italic>G</italic>, say <italic>G</italic>[501, 520] and <italic>G</italic>[1001, 1020], thus the LMEM will be converted into two simple pairs, which are (1, 20, 501, 520) and (1, 20, 1001, 1020), respectively. The simple pairs SP<sub>A</sub>, SP<sub>B</sub>, SP<sub>C</sub> and SP<sub>D</sub> in <xref ref-type="fig" rid="btx558-F1">Figure 1</xref> are examples of LMEMs found by the array traversal. In the toy example, the array traversal breaks due to an indel error, a splice junction and a mismatch, respectively, and finally it reaches the end of the read sequence.</p>
    </sec>
    <sec>
      <title>2.3 Candidate alignment processing</title>
      <p>All the simple pairs identified by the seed exploration step are sorted by their genomic locations. Adjacent simple pairs are clustered together if their genomic locations are within a user-defined distance threshold. This threshold can be defined as the maximal intron size. Simple pairs that are within the maximal intron size are considered in the same transcript and therefore should be put in the same cluster. The clustering procedure starts from the first simple pair on the list and checks if the next simple pair is within the distance threshold with the previous one. If they are truly neighboring, we put them in the same cluster and check the next simple pair with the newly added one. Otherwise, the current cluster is no longer expanded and a new cluster is created for the simple pair. The clustering procedure continues until all the simple pairs are clustered. Each cluster is then evaluated by the total length of its simple pairs. To avoid delay in processing clusters that are unlikely to be true alignment, DART only keeps clusters which produce the longest length (denoted as <italic>L</italic>) or above <italic>L</italic>-20. However, if the input data consists of paired-end reads, DART will first compare the clusters of two paired-end reads and keep all the clusters that meet the paired-end conditions.</p>
      <p>A read alignment will be built from a simple pair cluster. Two simple pairs in the same cluster could overlap due to tandem repeats or sequence variations. In such cases, the overlapped portion in the genome and read portion will be chopped off from the shorter simple pair to ensure that all simple pairs are non-overlapping. Sometimes simple pairs could intersect to each other. In such cases, we remove the simple pairs that cause this dislocation. If the simple pairs in a cluster exhibit gaps either in the read sequence or genome sequence, DART will identify the corresponding normal pairs to fill all the gaps. Note that the intragenic gaps are ignored since their presence is due to splice junctions. The gaps of the read sequence could be either aligned with the same exonic region of the respective simple pairs, or split into two segments to form a spliced alignment if the adjacent simple pairs are mapped to different exons.</p>
      <p><xref ref-type="fig" rid="btx558-F2">Figure 2</xref> gives examples to illustrate the two cases. In <xref ref-type="fig" rid="btx558-F2">Figure 2A</xref>, there are some uncovered nucleotides between SP<sub>A</sub> and SP<sub>B</sub>, three in the read portion and two in the genome portion. Since the ÎPos of SP<sub>A</sub> and SP<sub>B</sub> are 310 (=â311 - 1) and 309 (=â333 - 24), respectively, it suggests that SP<sub>A</sub> and SP<sub>B</sub> are in the same exon. In such cases, DART simply inserts a normal pair (21, 23, 331, 332) in between SP<sub>A</sub> and SP<sub>B</sub> to fill the gaps. It can be also observed that gaps could span one or more introns. As shown in <xref ref-type="fig" rid="btx558-F2">Figure 2B</xref>, there are five uncovered nucleotides in the read sequence and simple pairs SP<sub>C</sub> and SP<sub>D</sub> are in different exons since their ÎPos difference (100 vs. 487) is above the predefined minimal intron size (the default value is 5). In such cases, the gaps could be split into two parts if they cover two exonic regions. Let two adjacent simple pairs be (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, <italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>) and (<italic>i</italic><sub>3</sub>, <italic>i</italic><sub>4</sub>, <italic>j</italic><sub>3</sub>, <italic>j</italic><sub>4</sub>), respectively, and suppose <italic>i</italic><sub>3</sub> â <italic>i</italic><sub>2</sub>â=â<italic>k</italic>&gt;â1. Thus, <italic>R</italic>[<italic>i</italic><sub>2</sub>â+â1, <italic>i</italic><sub>3</sub> â 1] represents the uncovered nucleotides of length <italic>k</italic> in the read portion, and <italic>G</italic>[<italic>j</italic><sub>2</sub>â+â1, <italic>j</italic><sub>3</sub> â 1] represents the uncovered nucleotides in the genome portion. DART aligns the fragments <italic>R</italic>[<italic>i</italic><sub>2</sub>â+â1, <italic>i</italic><sub>3â</sub>1] and <italic>G</italic>[<italic>j</italic><sub>2</sub>â+â1, <italic>j</italic><sub>2</sub>â+â<italic>k</italic>] with the Needleman-Wunsch algorithm, and it also aligns the fragments <italic>R</italic>[<italic>i</italic><sub>2</sub>â+â1, <italic>i</italic><sub>3</sub> â 1] and <italic>G</italic>[<italic>j</italic><sub>3</sub> â <italic>k</italic>, <italic>j</italic><sub>3</sub> â 1]. Then DART find the cut point <italic>p</italic> to maximize the identical pairs of the two alignments, so that the alignment of <italic>R</italic>[<italic>i</italic><sub>2</sub>â+â1, <italic>i</italic><sub>2</sub>â+â<italic>p</italic>] and <italic>G</italic>[<italic>j</italic><sub>2</sub>â+â1, <italic>j</italic><sub>2</sub>â+â<italic>p</italic>], and that of <italic>R</italic>[<italic>i</italic><sub>2</sub>â+â<italic>p</italic>â+â1, <italic>i</italic><sub>3</sub> â 1] and <italic>G</italic>[<italic>j</italic><sub>3</sub> â <italic>kâ</italic>+<italic>âp</italic>, <italic>j</italic><sub>3</sub> â 1] produce the highest alignment score. In the example of <xref ref-type="fig" rid="btx558-F2">Figure 2B</xref>, the best choice of <italic>p</italic> is 2, so that the two fragment pairs (19, 20, 119, 120) and (21, 23, 508, 510) produce the highest alignment score. Thus the two fragment pairs are inserted as normal pairs between SP<sub>C</sub> and SP<sub>D</sub> to cover the entire read sequence. Though the Needleman-Wunsch algorithm is used to identify the cut point, the gap sizes are normally very small and it does not take much time on the alignments.
</p>
      <fig id="btx558-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>(<bold>A</bold>) Gaps between simple pairs in an exonic read. (<bold>B</bold>) Gaps between simple pairs in a spanned read</p>
        </caption>
        <graphic xlink:href="btx558f2"/>
      </fig>
      <p>It is also noteworthy that a fragment pair might cover intronic region accidentally. A canonical splice junction starts with the dinucleotide GT (donor site) and ends with the dinucleotide AG (acceptor site). If another dinucleotide GT is closely adjacent the acceptor site, it would be mapped to the donor site by accident. <xref ref-type="fig" rid="btx558-F3">Figure 3</xref> gives an example of such cases. It can be seen that the dinucleotide GT at <italic>R</italic>[19, 20] is mistakenly mapped to <italic>G</italic>[757, 758] which is the donor site of the corresponding splice junction. <italic>R</italic>[19, 20] should be mapped to <italic>G</italic>[811, 812] which is closely adjacent with the acceptor site. Though the alignment score stays the same whether <italic>R</italic>[19, 20] is mapped either to <italic>G</italic>[757, 758] or to <italic>G</italic>[811, 812], the incorrect mapping can result in wrong splice junction detection.
</p>
      <fig id="btx558-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Identification of the splice junction between two simple pairs A and B. The simple pair A should be shrunk by two nucleotides to match the splice site âGT/AGâ in the splice junction</p>
        </caption>
        <graphic xlink:href="btx558f3"/>
      </fig>
      <p>To avoid mapping to intronic regions, DART refines the splice junction sites by checking two adjacent fragment pairs if they are mapped to different exons (like SP<sub>A</sub> and SP<sub>B</sub> in <xref ref-type="fig" rid="btx558-F3">Fig. 3</xref>). Given two adjacent fragment pairs, denoted as (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, <italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>) and (<italic>i</italic><sub>3</sub>, <italic>i</italic><sub>4</sub>, <italic>j</italic><sub>3</sub>, <italic>j</italic><sub>4</sub>), respectively, DART checks if <italic>G</italic>[<italic>j<sub>2</sub>+</italic>1â<italic>+</italic>â<italic>shift, j<sub>2</sub>+</italic>2â<italic>+</italic>â<italic>shift</italic>] is a donor site and <italic>G</italic>[<italic>j<sub>3</sub>â</italic>2â<italic>+</italic>â<italic>shift, j<sub>3</sub> â</italic>1â<italic>+</italic>â<italic>shift</italic>] is an acceptor site where <italic>shift</italic> goes with 0,âÂ±1,âÂ±2, â¦ andâÂ±9 sequentially until the splice site pair are checked. If the splice junction is found with <italic>shift</italic>ââ 0, the sizes of the corresponding fragment pairs are modified accordingly. DART checks the most four common splice sites: âGT/AGâ, âCT/ACâ, âGC/AGâ and âCT/GCâ. For example, the simple pairs SP<sub>A</sub> and SP<sub>B</sub> in <xref ref-type="fig" rid="btx558-F3">Figure 3</xref> will be modified as (1, 18, 739, 756) and (19, 42, 811, 834), respectively with <italic>shift</italic>â=ââ2.</p>
      <p>Finally, DART generates all sub-alignments based on the fragment pairs in the cluster. The sub-alignment for a simple pair is a perfect alignment without any mismatches, whereas the sub-alignment for a normal pair can be un-gapped alignment (with only mismatches) or gapped alignment (with indels). If the read portion and genome portion of a normal pair have equal size, then it is very likely the normal pair only contains substitution errors and the un-gapped alignment makes the best alignment; however, if a normal pair contains indel errors, the un-gapped alignment will result in low sequence identity. So, by checking the percentage of mismatches with a linear scan, we can determine whether a normal pair requires gapped alignment or not. DART performs the Needleman-Wunsch algorithm to generate gapped alignments. All the sub-alignments are concatenated together to form the final alignment. If there are more clusters to be considered for the same read, DART repeats the candidate alignment processing step to generate alternative alignments.</p>
    </sec>
    <sec>
      <title>2.4 Mapping quality score</title>
      <p>MAQ (<xref rid="btx558-B20" ref-type="bibr">Li <italic>et al.</italic>, 2008</xref>) introduced the idea of mapping quality to estimate the reliability of a read alignment. It can be converted into the probability of a query sequence being aligned incorrectly. The mapping quality is estimated based on the uniqueness of optimal alignment. An alignment generated by Dart is assigned with a MAPQ based on the following rules:</p>
      <p>50â=âunique mapping;</p>
      <p>3â=âmaps to 2 locations;</p>
      <p>2â=âmaps to 3 locations;</p>
      <p>1â=âmaps to 4â9 locations;</p>
      <p>0â=âmaps to 10 or more locations.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Implementation and experiment design</title>
      <p>DART was developed under Linux environment and implemented with standard C/Câ++. It supports multi-thread to take advantage of multi-core computers. DART reads a BWT-based index file and takes a read library (single-end or paired-end reads) in FASTA/FASTQ format as input. DART reports read alignments in the SAM (Sequence Alignment/Map) format(<xref rid="btx558-B18" ref-type="bibr">Li <italic>et al.</italic>, 2009</xref>).It is difficult to estimate the correctness of read alignments using real datasets since the true coordinate of each read sequence is unknown. Therefore, we created simulated read libraries to estimate the performance of read aligners. Here, we simulated read libraries of the human genome (Hg38, size: 3âG bp) using the Flux simulator (<xref rid="btx558-B9" ref-type="bibr">Griebel <italic>et al.</italic>, 2012</xref>), a popular software to simulate RNA-Seq experiments <italic>in silico</italic>. Flux simulates the RNA sequencing protocols and produces the read distributions observed in practice fairly well. Simulated RNA-seq reads were generated from the known transcripts (GENCODE release 25) (<xref rid="btx558-B10" ref-type="bibr">Harrow <italic>et al.</italic>, 2012</xref>) on the entire human genome using the 76âbp error model by Flux simulator. To test the capabilities of RNA-seq aligners, we generated four Illumina-like paired-end read datasets with different read lengths: 76, 101, 151 and 251âbp. They are labeled as <italic>SimRead_76</italic>, <italic>SimRead_101</italic>, <italic>SimRead_151</italic> and <italic>SimRead_251</italic>, respectively. Each dataset contains around 40 million paired-end reads.</p>
      <p>Most of RNA-Seq aligners are evaluated by the alignment sensitivity, mapping accuracy, true-/false-positive rates of splice junction detection, and mapping speed (<xref rid="btx558-B2" ref-type="bibr">Conesa <italic>et al.</italic>, 2016</xref>; <xref rid="btx558-B4" ref-type="bibr">Dobin <italic>et al.</italic>, 2013</xref>; <xref rid="btx558-B5" ref-type="bibr">Engstrom <italic>et al.</italic>, 2013</xref>; <xref rid="btx558-B19" ref-type="bibr">Li and Homer, 2010</xref>). We follow the same benchmarking metrics to evaluate performance of DART and compare it with other RNA-Seq aligners. Since Flux simulator only provides the transcript level coordinate, we estimate the average sequence identity (called SeqIdy) of read alignments to reveal the accuracy of base-to-base alignment. A read alignment is considered a true one if its mapping coordinate is within the original transcript. A predicted splice junction is considered as a true one if it meets the boundary of a true splice junction with a maximal difference of 5âbp (due to the consideration of genome alteration); otherwise it is considered as a false splice junction. Suppose an RNA-Seq aligner handles a library of <italic>N</italic> reads and reports at least one alignment for <italic>Nâ</italic> reads and it predicts <italic>M</italic> distinct splice junctions. The resulting alignments are then compared with the original transcript level coordinate of the simulated reads, and the predicted splice junctions are verified with the gene annotation (GENCODE release 25). The alignment accuracy is estimated only on the read alignment with MAPQâ&gt;â0. Suppose there are <italic>n</italic> reads with MAPQâ&gt;â0 and <italic>nâ</italic> reads are mapped to the correct transcript and <italic>m</italic> splice junctions agree with the gene annotations. Thus the benchmarking metrics are defined as follows:<disp-quote content-type="extract"><p><italic>sensitivityâ=âNââ/âN</italic>;</p><p><italic>accuracyâ=ânââ/ân</italic>;</p><p><italic>recall=ânâ</italic>â/âN;</p><p><italic>SeqIdyâ</italic>=<italic>â</italic>identical base pairsâ/âalignment length;</p><p><italic>splice junction accuracyâ</italic>=<italic>âmâ/âM.</italic></p></disp-quote></p>
      <p>Note that TopHat2 and Subread do not output the splice junctions directly, we used <italic>bed_to_juncs</italic> (a program in the TopHat2 package) to generate the predicted splice junctions from the output file of <italic>junctions.bed</italic>.</p>
      <p>We also downloaded four recently released read libraries to measure the performance in practice on the SRA database (<xref rid="btx558-B15" ref-type="bibr">Leinonen <italic>et al.</italic>, 2011</xref>). They are <italic>SRR3351428</italic>, <italic>ERR1518881</italic>, <italic>SRR3439468</italic> and <italic>SRR3439488</italic>. These data comprise 278, 706, 960 paired-end reads. The read length ranges from 100 to 151âbp. Since the true genomic origins of the real datasets are unknown, we estimate the performance of aligners with the following objective criteria: <italic>sensitivity</italic>, <italic>SeqIdy</italic>, <italic>reported splice junctions, true splice junctions, splice junction accuracy</italic> and <italic>runtime</italic>. To avoid estimation bias due to multiple hits (i.e. ambiguous mapping), we only evaluated the first alignment for each read.</p>
      <p>All reads in the test data were processed on a Linux 64-bit system with 4 Intel Xeon E7-4830â2.13âGHz CPUs and 2TB physical memory. DART was compared with the following existing RNA-seq read aligners: STAR, TopHat2, Subread, MapSplice2 and HISAT2. The comparison was conducted with the default parameters of each aligner since the above-mentioned aligners were developed and optimized for human genomes and recent RNA-seq data. It is a reasonable and commonly accepted practice (<xref rid="btx558-B4" ref-type="bibr">Dobin <italic>et al.</italic>, 2013</xref>). Each aligner was asked to only report the best alignment or a random best if there were multiple hits. All aligners were run in the <italic>de novo</italic> mode (i.e. without using transcript annotations) with 16 threads to speed up the whole procedure. The mapping process is forced to terminate if the whole dataset cannot be finished within 24âh. We mark NA in the measurement for such cases. The arguments as well as version number of each aligner are summarized in the <xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> (<xref ref-type="supplementary-material" rid="sup1">Supplementary Table S1</xref>).</p>
    </sec>
    <sec>
      <title>3.2 Evaluation on simulated datasets</title>
      <p><xref rid="btx558-T1" ref-type="table">Table 1</xref> summarizes the performance evaluation of selected RNA-Seq aligner on the simulated datasets. It is observed that DART produced the highest or comparable sensitivity, accuracy, recall and SeqIdy. Its performance exhibited consistency among datasets with various read lengths. It is also noteworthy that DART spent 576âs on the whole simulated datasets. STAR also produced the high accuracy and SeqIdy, but its sensitivity and recall decreased when read length became 251âbp long. The sensitivity and recall of STAR on the SimRead_251 were 0.939 and 0.921, respectively, which were much lower than those of DART (0.997 and 0.971). STAR also spent much more time on theSimRead_251. STAR spent 850âs on the whole simulated datasets. HISAT2 ran faster than Tophat2, Subread and MapSplice2; however, its sensitivity and recall were much lower than those of DART and STAR. It left many reads unaligned. Subread produced better alignments than Tophat2 and HISAT2. Its sensitivity and recall were higher than the two aligners. However, its alignment speed was not fast enough. MapSplice2 produced comparable alignments. Its sensitivity, recall and SeqIdy were comparable to those of DART and STAR, but it spent much more time to yield good quality alignments. Tophat2 was the slowest aligner among the selected methods. It spent 63â107âs on the whole simulated datasets. Moreover, Tophat2 produced the worst sensitivity and recall. It is also observed that all the selected aligners except DART and MapSplice2 produced relatively low sensitivity when the read length became longer.
<table-wrap id="btx558-T1" orientation="portrait" position="float"><label>Table 1.</label><caption><p>Performance comparison of DART and other selected aligners on the simulated datasets</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="left" span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/></colgroup><thead><tr><th rowspan="1" colspan="1">Synthetic datasets</th><th rowspan="1" colspan="1">Aligner</th><th rowspan="1" colspan="1">Sensitivity</th><th rowspan="1" colspan="1">Accuracy</th><th rowspan="1" colspan="1">Recall</th><th rowspan="1" colspan="1">SeqIdy</th><th rowspan="1" colspan="1">Reported SJ</th><th rowspan="1" colspan="1">True SJ</th><th rowspan="1" colspan="1">SJ accuracy</th><th rowspan="1" colspan="1">Runtime</th></tr></thead><tbody><tr><td rowspan="6" colspan="1">SimRead_76</td><td rowspan="1" colspan="1">DART</td><td rowspan="1" colspan="1">0.991</td><td rowspan="1" colspan="1">0.989</td><td rowspan="1" colspan="1">0.957</td><td rowspan="1" colspan="1">0.999</td><td rowspan="1" colspan="1">99761</td><td rowspan="1" colspan="1">96700</td><td rowspan="1" colspan="1">0.969</td><td rowspan="1" colspan="1">71</td></tr><tr><td rowspan="1" colspan="1">STAR</td><td rowspan="1" colspan="1">0.978</td><td rowspan="1" colspan="1">0.981</td><td rowspan="1" colspan="1">0.958</td><td rowspan="1" colspan="1">0.996</td><td rowspan="1" colspan="1">108202</td><td rowspan="1" colspan="1">101163</td><td rowspan="1" colspan="1">0.935</td><td rowspan="1" colspan="1">129</td></tr><tr><td rowspan="1" colspan="1">TopHat2</td><td rowspan="1" colspan="1">0.852</td><td rowspan="1" colspan="1">0.961</td><td rowspan="1" colspan="1">0.853</td><td rowspan="1" colspan="1">0.998</td><td rowspan="1" colspan="1">102230</td><td rowspan="1" colspan="1">93850</td><td rowspan="1" colspan="1">0.918</td><td rowspan="1" colspan="1">6172</td></tr><tr><td rowspan="1" colspan="1">Subread</td><td rowspan="1" colspan="1">0.965</td><td rowspan="1" colspan="1">0.988</td><td rowspan="1" colspan="1">0.929</td><td rowspan="1" colspan="1">0.998</td><td rowspan="1" colspan="1">99033</td><td rowspan="1" colspan="1">95469</td><td rowspan="1" colspan="1">0.964</td><td rowspan="1" colspan="1">2610</td></tr><tr><td rowspan="1" colspan="1">MapSplice2</td><td rowspan="1" colspan="1">0.962</td><td rowspan="1" colspan="1">0.976</td><td rowspan="1" colspan="1">0.940</td><td rowspan="1" colspan="1">0.997</td><td rowspan="1" colspan="1">101230</td><td rowspan="1" colspan="1">97895</td><td rowspan="1" colspan="1">0.967</td><td rowspan="1" colspan="1">3602</td></tr><tr><td rowspan="1" colspan="1">HISAT2</td><td rowspan="1" colspan="1">0.911</td><td rowspan="1" colspan="1">0.977</td><td rowspan="1" colspan="1">0.889</td><td rowspan="1" colspan="1">0.999</td><td rowspan="1" colspan="1">100589</td><td rowspan="1" colspan="1">96922</td><td rowspan="1" colspan="1">0.964</td><td rowspan="1" colspan="1">353</td></tr><tr><td rowspan="6" colspan="1">SimRead_101</td><td rowspan="1" colspan="1">DART</td><td rowspan="1" colspan="1">0.992</td><td rowspan="1" colspan="1">0.988</td><td rowspan="1" colspan="1">0.965</td><td rowspan="1" colspan="1">0.997</td><td rowspan="1" colspan="1">105584</td><td rowspan="1" colspan="1">102162</td><td rowspan="1" colspan="1">0.968</td><td rowspan="1" colspan="1">95</td></tr><tr><td rowspan="1" colspan="1">STAR</td><td rowspan="1" colspan="1">0.977</td><td rowspan="1" colspan="1">0.982</td><td rowspan="1" colspan="1">0.958</td><td rowspan="1" colspan="1">0.996</td><td rowspan="1" colspan="1">112674</td><td rowspan="1" colspan="1">105459</td><td rowspan="1" colspan="1">0.936</td><td rowspan="1" colspan="1">154</td></tr><tr><td rowspan="1" colspan="1">TopHat2</td><td rowspan="1" colspan="1">0.809</td><td rowspan="1" colspan="1">0.967</td><td rowspan="1" colspan="1">0.809</td><td rowspan="1" colspan="1">0.999</td><td rowspan="1" colspan="1">109153</td><td rowspan="1" colspan="1">99501</td><td rowspan="1" colspan="1">0.912</td><td rowspan="1" colspan="1">10357</td></tr><tr><td rowspan="1" colspan="1">Subread</td><td rowspan="1" colspan="1">0.955</td><td rowspan="1" colspan="1">0.987</td><td rowspan="1" colspan="1">0.925</td><td rowspan="1" colspan="1">0.998</td><td rowspan="1" colspan="1">105269</td><td rowspan="1" colspan="1">101136</td><td rowspan="1" colspan="1">0.961</td><td rowspan="1" colspan="1">2346</td></tr><tr><td rowspan="1" colspan="1">MapSplice2</td><td rowspan="1" colspan="1">0.979</td><td rowspan="1" colspan="1">0.980</td><td rowspan="1" colspan="1">0.960</td><td rowspan="1" colspan="1">0.998</td><td rowspan="1" colspan="1">110219</td><td rowspan="1" colspan="1">104434</td><td rowspan="1" colspan="1">0.948</td><td rowspan="1" colspan="1">4736</td></tr><tr><td rowspan="1" colspan="1">HISAT2</td><td rowspan="1" colspan="1">0.898</td><td rowspan="1" colspan="1">0.979</td><td rowspan="1" colspan="1">0.879</td><td rowspan="1" colspan="1">0.998</td><td rowspan="1" colspan="1">104309</td><td rowspan="1" colspan="1">100633</td><td rowspan="1" colspan="1">0.965</td><td rowspan="1" colspan="1">384</td></tr><tr><td rowspan="6" colspan="1">SimRead_151</td><td rowspan="1" colspan="1">DART</td><td rowspan="1" colspan="1">0.996</td><td rowspan="1" colspan="1">0.989</td><td rowspan="1" colspan="1">0.971</td><td rowspan="1" colspan="1">0.994</td><td rowspan="1" colspan="1">112614</td><td rowspan="1" colspan="1">108771</td><td rowspan="1" colspan="1">0.966</td><td rowspan="1" colspan="1">146</td></tr><tr><td rowspan="1" colspan="1">STAR</td><td rowspan="1" colspan="1">0.969</td><td rowspan="1" colspan="1">0.984</td><td rowspan="1" colspan="1">0.953</td><td rowspan="1" colspan="1">0.995</td><td rowspan="1" colspan="1">117793</td><td rowspan="1" colspan="1">110832</td><td rowspan="1" colspan="1">0.941</td><td rowspan="1" colspan="1">208</td></tr><tr><td rowspan="1" colspan="1">TopHat2</td><td rowspan="1" colspan="1">0.720</td><td rowspan="1" colspan="1">0.974</td><td rowspan="1" colspan="1">0.718</td><td rowspan="1" colspan="1">0.999</td><td rowspan="1" colspan="1">114134</td><td rowspan="1" colspan="1">104970</td><td rowspan="1" colspan="1">0.920</td><td rowspan="1" colspan="1">20055</td></tr><tr><td rowspan="1" colspan="1">Subread</td><td rowspan="1" colspan="1">0.928</td><td rowspan="1" colspan="1">0.987</td><td rowspan="1" colspan="1">0.901</td><td rowspan="1" colspan="1">0.998</td><td rowspan="1" colspan="1">111156</td><td rowspan="1" colspan="1">106542</td><td rowspan="1" colspan="1">0.958</td><td rowspan="1" colspan="1">2394</td></tr><tr><td rowspan="1" colspan="1">MapSplice2</td><td rowspan="1" colspan="1">0.994</td><td rowspan="1" colspan="1">0.979</td><td rowspan="1" colspan="1">0.973</td><td rowspan="1" colspan="1">0.997</td><td rowspan="1" colspan="1">110676</td><td rowspan="1" colspan="1">106594</td><td rowspan="1" colspan="1">0.963</td><td rowspan="1" colspan="1">6032</td></tr><tr><td rowspan="1" colspan="1">HISAT2</td><td rowspan="1" colspan="1">0.871</td><td rowspan="1" colspan="1">0.981</td><td rowspan="1" colspan="1">0.854</td><td rowspan="1" colspan="1">0.997</td><td rowspan="1" colspan="1">107932</td><td rowspan="1" colspan="1">104315</td><td rowspan="1" colspan="1">0.966</td><td rowspan="1" colspan="1">464</td></tr><tr><td rowspan="6" colspan="1">SimRead_251</td><td rowspan="1" colspan="1">DART</td><td rowspan="1" colspan="1">0.997</td><td rowspan="1" colspan="1">0.988</td><td rowspan="1" colspan="1">0.971</td><td rowspan="1" colspan="1">0.989</td><td rowspan="1" colspan="1">115680</td><td rowspan="1" colspan="1">111487</td><td rowspan="1" colspan="1">0.964</td><td rowspan="1" colspan="1">264</td></tr><tr><td rowspan="1" colspan="1">STAR</td><td rowspan="1" colspan="1">0.939</td><td rowspan="1" colspan="1">0.982</td><td rowspan="1" colspan="1">0.921</td><td rowspan="1" colspan="1">0.995</td><td rowspan="1" colspan="1">118922</td><td rowspan="1" colspan="1">112132</td><td rowspan="1" colspan="1">0.943</td><td rowspan="1" colspan="1">359</td></tr><tr><td rowspan="1" colspan="1">TopHat2</td><td rowspan="1" colspan="1">0.606</td><td rowspan="1" colspan="1">0.973</td><td rowspan="1" colspan="1">0.601</td><td rowspan="1" colspan="1">0.999</td><td rowspan="1" colspan="1">117547</td><td rowspan="1" colspan="1">107358</td><td rowspan="1" colspan="1">0.913</td><td rowspan="1" colspan="1">26523</td></tr><tr><td rowspan="1" colspan="1">Subread</td><td rowspan="1" colspan="1">0.893</td><td rowspan="1" colspan="1">0.983</td><td rowspan="1" colspan="1">0.863</td><td rowspan="1" colspan="1">0.997</td><td rowspan="1" colspan="1">114634</td><td rowspan="1" colspan="1">109503</td><td rowspan="1" colspan="1">0.955</td><td rowspan="1" colspan="1">4170</td></tr><tr><td rowspan="1" colspan="1">MapSplice2</td><td rowspan="1" colspan="1">0.998</td><td rowspan="1" colspan="1">0.967</td><td rowspan="1" colspan="1">0.964</td><td rowspan="1" colspan="1">0.997</td><td rowspan="1" colspan="1">111967</td><td rowspan="1" colspan="1">107395</td><td rowspan="1" colspan="1">0.959</td><td rowspan="1" colspan="1">7920</td></tr><tr><td rowspan="1" colspan="1">HISAT2</td><td rowspan="1" colspan="1">0.829</td><td rowspan="1" colspan="1">0.978</td><td rowspan="1" colspan="1">0.811</td><td rowspan="1" colspan="1">0.995</td><td rowspan="1" colspan="1">108670</td><td rowspan="1" colspan="1">105086</td><td rowspan="1" colspan="1">0.967</td><td rowspan="1" colspan="1">635</td></tr></tbody></table><table-wrap-foot><fn id="tblfn1"><p><italic>Note</italic>: Each dataset contains around 40 million reads with different lengths. The simulation was based on known transcripts from the entire human genome.</p></fn></table-wrap-foot></table-wrap></p>
      <p>For the identification of splice junctions, <xref rid="btx558-T1" ref-type="table">Table 1</xref> also shows that DART, Subread, MapSplice2 and HISAT2 produced similar accuracy on the splice junction detection. Their splice junction accuracies were around 0.95â0.96.The number of true splice junctions of each aligner increased when the read length became longer. It suggests that longer reads provide better splice junction detection for RNA-Seq data analysis. For example, the numbers of true splice junctions identified by DART on the four simulated datasets were 96â700, 102â162, 108â771 and 111â487, respectively. Among all the selected aligners, TopHat2 produced less accurate and fewer numbers of splice junctions. With the simulated RNA-Seq datasets, we demonstrated that DART is a highly accurate and fast aligner. It is not only the fastest RNA-Seq aligner, but it also produces the most accurate or comparable alignments among the state-of-the-art aligners. DART is also less sensitive to the read length. It yields consistent alignment sensitivities on reads with different read lengths.</p>
    </sec>
    <sec>
      <title>3.3 Evaluation on real datasets</title>
      <p><xref rid="btx558-T2" ref-type="table">Table 2</xref> summarizes the performance of the selected aligners on the real datasets. In this benchmark, it can be observed that DART produced the highest or comparable sensitivity and SeqIdy on all the datasets and it was also the fastest. DART and MapSplice2 yielded similar sensitivity; however, DART produced higher SeqIdy than MapSplice2, and MapSplice2 spent much more time to generate similar alignments. STAR was also the second fastest aligner on real datasets, however, its sensitivity and SeqIdy were not as good as those of DART and MapSplice2. We also noticed that MapSplice2 spent much more time on the dataset of SRR3351428. It seemed like MapSplice2 had difficulty in dealing with some particular reads in that dataset. HISAT2 yielded lower sensitivity though it run faster than MapSplice2. Subread was faster than MapSplice2 on the datasets of SRR3351428 and ERR1518881, but it produced less sensitivity. Moreover, it could not finish the mapping process on the remaining two real datasets within 24âh. TopHat2 did not perform very well on the real datasets. Its sensitivity was the lowest among the tested methods and it also failed to finish the alignments on the last two real datasets within the time limit.
<table-wrap id="btx558-T2" orientation="portrait" position="float"><label>Table 2.</label><caption><p>Performance comparison of DART and other selected aligners on the real datasets</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="left" span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/></colgroup><thead><tr><th rowspan="1" colspan="1">Real datasets</th><th rowspan="1" colspan="1">Aligner</th><th rowspan="1" colspan="1">Sensitivity</th><th rowspan="1" colspan="1">SeqIdy</th><th rowspan="1" colspan="1">Reported SJ</th><th rowspan="1" colspan="1">True SJ</th><th rowspan="1" colspan="1">SJ accuracy</th><th rowspan="1" colspan="1">Runtime</th></tr></thead><tbody><tr><td rowspan="6" colspan="1">SRR3351428 (100bp)</td><td rowspan="1" colspan="1">DART</td><td rowspan="1" colspan="1">0.975</td><td rowspan="1" colspan="1">0.999</td><td rowspan="1" colspan="1">236920</td><td rowspan="1" colspan="1">150260</td><td rowspan="1" colspan="1">0.634</td><td rowspan="1" colspan="1">244</td></tr><tr><td rowspan="1" colspan="1">STAR</td><td rowspan="1" colspan="1">0.922</td><td rowspan="1" colspan="1">0.996</td><td rowspan="1" colspan="1">270788</td><td rowspan="1" colspan="1">152192</td><td rowspan="1" colspan="1">0.562</td><td rowspan="1" colspan="1">270</td></tr><tr><td rowspan="1" colspan="1">TopHat2</td><td rowspan="1" colspan="1">0.844</td><td rowspan="1" colspan="1">0.998</td><td rowspan="1" colspan="1">217011</td><td rowspan="1" colspan="1">146077</td><td rowspan="1" colspan="1">0.673</td><td rowspan="1" colspan="1">22464</td></tr><tr><td rowspan="1" colspan="1">Subread</td><td rowspan="1" colspan="1">0.858</td><td rowspan="1" colspan="1">0.998</td><td rowspan="1" colspan="1">221700</td><td rowspan="1" colspan="1">146518</td><td rowspan="1" colspan="1">0.661</td><td rowspan="1" colspan="1">3312</td></tr><tr><td rowspan="1" colspan="1">MapSplice2</td><td rowspan="1" colspan="1">0.966</td><td rowspan="1" colspan="1">0.996</td><td rowspan="1" colspan="1">240918</td><td rowspan="1" colspan="1">149255</td><td rowspan="1" colspan="1">0.620</td><td rowspan="1" colspan="1">67446</td></tr><tr><td rowspan="1" colspan="1">HISAT2</td><td rowspan="1" colspan="1">0.883</td><td rowspan="1" colspan="1">0.998</td><td rowspan="1" colspan="1">149592</td><td rowspan="1" colspan="1">129379</td><td rowspan="1" colspan="1">0.865</td><td rowspan="1" colspan="1">404</td></tr><tr><td rowspan="6" colspan="1">ERR1518881 (101bp)</td><td rowspan="1" colspan="1">DART</td><td rowspan="1" colspan="1">0.874</td><td rowspan="1" colspan="1">0.997</td><td rowspan="1" colspan="1">243515</td><td rowspan="1" colspan="1">154851</td><td rowspan="1" colspan="1">0.636</td><td rowspan="1" colspan="1">369</td></tr><tr><td rowspan="1" colspan="1">STAR</td><td rowspan="1" colspan="1">0.841</td><td rowspan="1" colspan="1">0.987</td><td rowspan="1" colspan="1">259194</td><td rowspan="1" colspan="1">157026</td><td rowspan="1" colspan="1">0.606</td><td rowspan="1" colspan="1">371</td></tr><tr><td rowspan="1" colspan="1">TopHat2</td><td rowspan="1" colspan="1">0.640</td><td rowspan="1" colspan="1">0.995</td><td rowspan="1" colspan="1">220662</td><td rowspan="1" colspan="1">150126</td><td rowspan="1" colspan="1">0.680</td><td rowspan="1" colspan="1">21185</td></tr><tr><td rowspan="1" colspan="1">Subread</td><td rowspan="1" colspan="1">0.759</td><td rowspan="1" colspan="1">0.992</td><td rowspan="1" colspan="1">229369</td><td rowspan="1" colspan="1">151325</td><td rowspan="1" colspan="1">0.660</td><td rowspan="1" colspan="1">4008</td></tr><tr><td rowspan="1" colspan="1">MapSplice2</td><td rowspan="1" colspan="1">0.893</td><td rowspan="1" colspan="1">0.988</td><td rowspan="1" colspan="1">221275</td><td rowspan="1" colspan="1">150496</td><td rowspan="1" colspan="1">0.680</td><td rowspan="1" colspan="1">15021</td></tr><tr><td rowspan="1" colspan="1">HISAT2</td><td rowspan="1" colspan="1">0.756</td><td rowspan="1" colspan="1">0.993</td><td rowspan="1" colspan="1">162639</td><td rowspan="1" colspan="1">135460</td><td rowspan="1" colspan="1">0.833</td><td rowspan="1" colspan="1">480</td></tr><tr><td rowspan="6" colspan="1">SRR3439468 (151bp)</td><td rowspan="1" colspan="1">DART</td><td rowspan="1" colspan="1">0.930</td><td rowspan="1" colspan="1">0.996</td><td rowspan="1" colspan="1">197235</td><td rowspan="1" colspan="1">129148</td><td rowspan="1" colspan="1">0.655</td><td rowspan="1" colspan="1">481</td></tr><tr><td rowspan="1" colspan="1">STAR</td><td rowspan="1" colspan="1">0.841</td><td rowspan="1" colspan="1">0.992</td><td rowspan="1" colspan="1">206157</td><td rowspan="1" colspan="1">129008</td><td rowspan="1" colspan="1">0.626</td><td rowspan="1" colspan="1">594</td></tr><tr><td rowspan="1" colspan="1">TopHat2</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">Subread</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">MapSplice2</td><td rowspan="1" colspan="1">0.930</td><td rowspan="1" colspan="1">0.990</td><td rowspan="1" colspan="1">158581</td><td rowspan="1" colspan="1">113879</td><td rowspan="1" colspan="1">0.718</td><td rowspan="1" colspan="1">49320</td></tr><tr><td rowspan="1" colspan="1">HISAT2</td><td rowspan="1" colspan="1">0.482</td><td rowspan="1" colspan="1">0.994</td><td rowspan="1" colspan="1">131892</td><td rowspan="1" colspan="1">105180</td><td rowspan="1" colspan="1">0.797</td><td rowspan="1" colspan="1">1306</td></tr><tr><td rowspan="6" colspan="1">SRR3439488 (151bp)</td><td rowspan="1" colspan="1">DART</td><td rowspan="1" colspan="1">0.899</td><td rowspan="1" colspan="1">0.995</td><td rowspan="1" colspan="1">142410</td><td rowspan="1" colspan="1">112562</td><td rowspan="1" colspan="1">0.790</td><td rowspan="1" colspan="1">427</td></tr><tr><td rowspan="1" colspan="1">STAR</td><td rowspan="1" colspan="1">0.775</td><td rowspan="1" colspan="1">0.990</td><td rowspan="1" colspan="1">148672</td><td rowspan="1" colspan="1">113102</td><td rowspan="1" colspan="1">0.761</td><td rowspan="1" colspan="1">813</td></tr><tr><td rowspan="1" colspan="1">TopHat2</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">Subread</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td><td align="center" rowspan="1" colspan="1">NA</td></tr><tr><td rowspan="1" colspan="1">MapSplice2</td><td rowspan="1" colspan="1">0.851</td><td rowspan="1" colspan="1">0.989</td><td rowspan="1" colspan="1">151771</td><td rowspan="1" colspan="1">107025</td><td rowspan="1" colspan="1">0.705</td><td rowspan="1" colspan="1">36240</td></tr><tr><td rowspan="1" colspan="1">HISAT2</td><td rowspan="1" colspan="1">0.657</td><td rowspan="1" colspan="1">0.994</td><td rowspan="1" colspan="1">120311</td><td rowspan="1" colspan="1">100198</td><td rowspan="1" colspan="1">0.833</td><td rowspan="1" colspan="1">703</td></tr></tbody></table></table-wrap></p>
      <p>For the splice junction detection on real datasets (shown in <xref rid="btx558-T2" ref-type="table">Table 2</xref>), DART, Tophat2, Subread and MapSplice2 produced similar results. It suggests that the splice junction detections of those methods were very consistent on the real datasets. Though HISAT2 achieved higher accuracy on the splice junction detection, it produced less number of true splice junctions. STAR produced lower splice junction accuracy on the real datasets, though the numbers of observed splice junctions were similar to other methods.</p>
      <p>We also compared the memory usage of each aligner. Though some aligners allow users to set the maximal memory usage, we did not give any limitations and let each aligner take as much memory as it needs. In <xref rid="btx558-T3" ref-type="table">Table 3</xref>, we found that TopHat2, HISAT2 and MapSplice2 required less physical memory, followed by Subread and DART which required 10 and 12âGB, respectively. STAR required around 30âGB of physical memory. Note that the memory requirement was measured on the simulated and real datasets running with 16 threads.
<table-wrap id="btx558-T3" orientation="portrait" position="float"><label>Table 3.</label><caption><p>Comparison of the peak RAM usage</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="char" char="." span="1"/></colgroup><thead><tr><th rowspan="1" colspan="1">Aligner</th><th rowspan="1" colspan="1">Memory usage (GB)</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">DART</td><td rowspan="1" colspan="1">12.0</td></tr><tr><td rowspan="1" colspan="1">STAR</td><td rowspan="1" colspan="1">30.0</td></tr><tr><td rowspan="1" colspan="1">TopHat2</td><td rowspan="1" colspan="1">4.5</td></tr><tr><td rowspan="1" colspan="1">Subread</td><td rowspan="1" colspan="1">10.0</td></tr><tr><td rowspan="1" colspan="1">MapSplice2</td><td rowspan="1" colspan="1">6.3</td></tr><tr><td rowspan="1" colspan="1">HISAT2</td><td rowspan="1" colspan="1">5.6</td></tr></tbody></table></table-wrap></p>
      <p>All the selected aligners were evaluated with 16 threads, we further analyzed the efficiency of DART with different number of threads. <xref rid="btx558-T4" ref-type="table">Table 4</xref> shows the runtime of DART on the dataset of SimRead_76. It can be observed that DART is highly efficient to utilize multi-threads. The runtime is nearly half as the number of threads doubles. However, the efficiency still degenerates as the number of threads increase due to the disk overhead. Since all the threads need to access the same files for input and output, they must wait to gain the exclusive file accesses. Thus, not all the threads are fully utilized all the time during the mapping process.
<table-wrap id="btx558-T4" orientation="portrait" position="float"><label>Table 4.</label><caption><p>The scaling of runtime of DART on the dataset SimRead_76</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/></colgroup><thead><tr><th rowspan="1" colspan="1">Dataset</th><th rowspan="1" colspan="1">Threads</th><th rowspan="1" colspan="1">runtime</th></tr></thead><tbody><tr><td rowspan="5" colspan="1">SimRead_76</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">937</td></tr><tr><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">464</td></tr><tr><td rowspan="1" colspan="1">4</td><td rowspan="1" colspan="1">240</td></tr><tr><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1">126</td></tr><tr><td rowspan="1" colspan="1">16</td><td rowspan="1" colspan="1">71</td></tr></tbody></table></table-wrap></p>
    </sec>
  </sec>
  <sec>
    <title>4 Conclusions</title>
    <p>In this article, we present DART, a new <italic>de novo</italic> RNA-seq aligner for sensitive, rapid and accurate mapping to reference sequences. DART is a BWT-based aligner and it adopts a partitioning strategy to divide a read into simple and normal pairs. Each simple pair is a perfect alignment and each normal pair is a gapped/un-gapped alignment.</p>
    <p>By benchmarking on the simulated and real datasets, we demonstrate that the proposed partitioning mapping strategy can replace the extension step in the conventional seed-and-extend strategy and reduce the time of alignment. We show that DART was able to align 160 million simulated paired-end reads with various lengths in 576âs, while the second fastest aligner, i.e. STAR took 850âs. For the real datasets, DART aligned around 278 million paired-end reads in 1521âs, whereas STAR took 2048âs on the same datasets. Though DART is faster, it can still generate accurate alignments and yield high sensitivity regardless of read length. It also produces high sequence identity of alignments. In addition, it detects comparable or larger number of splice junctions than other aligners. The accuracy of predicted splice junctions on the simulated datasets is between 0.96 and 0.97, and that on the real datasets is between 0.63 and 0.79. Both of which are comparable to or better than the selected aligners.</p>
    <p>The sensitivity of read mapping is one of the important factors for further analysis, such as gene expression level measurement or structural variants detection. Specifically, orphan reads and one-end anchored (OEA) are often used to identify sequence variants. Orphan reads refer to those paired-end reads where neither read sequences can be aligned with high sequence identity to the reference genome, and OEA refer to those paired-end reads in which one of the paired reads is aligned to the reference genome. Thus, mapping sensitivity and the number of paired alignments are crucial for further read analysis. We have shown that DART is capable of producing high sensitivity mapping and generating more paired alignments with the least amount of time. With the advances in sequencing technologies and the ongoing collection of sequencing data in the ENCODE project, we believe DART is a better aligner to handle the huge amount of short reads as well as the associated sequence variants detection.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>Supplementary Data</label>
      <media xlink:href="btx558_supplementary.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>We appreciate the advice and discussion from Dr. Ei-Wen Yang. The BWT indexing and BWT array search procedure of DART were modified from BWA. We would also like to thank Thasso Griebel <italic>et al.</italic> for developing the RNA-seq simulator.</p>
    <sec>
      <title>Funding</title>
      <p>Bioinformatics Core Facility for Translational Medicine and Biotechnology Development/Ministry of Science and Technology (Taiwan) 105-2319-B-400-002.</p>
      <p><italic>Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="btx558-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Choi</surname><given-names>J.H.</given-names></name></person-group><etal>et al</etal> (<year>2005</year>) 
<article-title>GAME: A simple and efficient whole genome alignment method using maximal exact match filtering</article-title>. <source>Comput. Biol. Chem</source>., <volume>29</volume>, <fpage>244</fpage>â<lpage>253</lpage>.<pub-id pub-id-type="pmid">15979044</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Conesa</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>A survey of best practices for RNA-seq data analysis</article-title>. <source>Genome Biol</source>., <volume>17</volume>, <fpage>13</fpage>.<pub-id pub-id-type="pmid">26813401</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>De Bona</surname><given-names>F.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) 
<article-title>Optimal spliced alignments of short sequence reads</article-title>. <source>Bioinformatics</source>, <volume>24</volume>, <fpage>I174</fpage>â<lpage>I180</lpage>.<pub-id pub-id-type="pmid">18689821</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dobin</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>STAR: ultrafast universal RNA-seq aligner</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>15</fpage>â<lpage>21</lpage>.<pub-id pub-id-type="pmid">23104886</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Engstrom</surname><given-names>P.G.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Systematic evaluation of spliced alignment programs for RNA-seq data</article-title>. <source>Nat. Methods</source>, <volume>10</volume>, <fpage>1185+</fpage>.<pub-id pub-id-type="pmid">24185836</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Fu</surname><given-names>X.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>Estimating accuracy of RNA-Seq and microarrays with proteomics</article-title>. <source>BMC Genomics</source>, <volume>10</volume>, <fpage>161</fpage>.<pub-id pub-id-type="pmid">19371429</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Garber</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2011</year>) 
<article-title>Computational methods for transcriptome annotation and quantification using RNA-seq</article-title>. <source>Nat. Methods</source>, <volume>8</volume>, <fpage>469</fpage>â<lpage>477</lpage>.<pub-id pub-id-type="pmid">21623353</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Grant</surname><given-names>G.R.</given-names></name></person-group><etal>et al</etal> (<year>2011</year>) 
<article-title>Comparative analysis of RNA-Seq alignment algorithms and the RNA-Seq unified mapper (RUM)</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>2518</fpage>â<lpage>2528</lpage>.<pub-id pub-id-type="pmid">21775302</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Griebel</surname><given-names>T.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Modelling and simulating generic RNA-Seq experiments with the flux simulator</article-title>. <source>Nucleic Acids Res</source>., <volume>40</volume>, <fpage>10073</fpage>â<lpage>10083</lpage>.<pub-id pub-id-type="pmid">22962361</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Harrow</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>GENCODE: The reference human genome annotation for The ENCODE Project</article-title>. <source>Genome Res</source>., <volume>22</volume>, <fpage>1760</fpage>â<lpage>1774</lpage>.<pub-id pub-id-type="pmid">22955987</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Hu</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>OSA: a fast and accurate alignment tool for RNA-Seq</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>1933</fpage>â<lpage>1934</lpage>.<pub-id pub-id-type="pmid">22592379</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jean</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) RNA-Seq read alignments with PALMapper. <italic>Curr. Protoc. Bioinformatics</italic>, <volume>32</volume>, <fpage>11.6:11.6.1</fpage>â<lpage>11.6.37</lpage>.</mixed-citation>
    </ref>
    <ref id="btx558-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kim</surname><given-names>D.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>HISAT: a fast spliced aligner with low memory requirements</article-title>. <source>Nat. Methods</source>, <volume>12</volume>, <fpage>357</fpage>â<lpage>U121</lpage>.<pub-id pub-id-type="pmid">25751142</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kim</surname><given-names>D.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>TopHat2: accurate alignment of transcriptomes in the presence of insertions, deletions and gene fusions</article-title>. <source>Genome Biol</source>., <volume>14</volume>, <fpage>R36</fpage>.<pub-id pub-id-type="pmid">23618408</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Leinonen</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2011</year>) 
<article-title>The sequence read archive</article-title>. <source>Nucleic Acids Res</source>., <volume>39</volume>, <fpage>D19</fpage>â<lpage>D21</lpage>.<pub-id pub-id-type="pmid">21062823</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name>, <name name-style="western"><surname>Durbin</surname><given-names>R.</given-names></name></person-group> (<year>2009</year>) 
<article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>1754</fpage>â<lpage>1760</lpage>.<pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>The Sequence Alignment/Map format and SAMtools</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>2078</fpage>â<lpage>2079</lpage>.<pub-id pub-id-type="pmid">19505943</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name>, <name name-style="western"><surname>Homer</surname><given-names>N.</given-names></name></person-group> (<year>2010</year>) 
<article-title>A survey of sequence alignment algorithms for next-generation sequencing</article-title>. <source>Brief. Bioinf</source>., <volume>11</volume>, <fpage>473</fpage>â<lpage>483</lpage>.</mixed-citation>
    </ref>
    <ref id="btx558-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) 
<article-title>Mapping short DNA sequencing reads and calling variants using mapping quality scores</article-title>. <source>Genome Res</source>., <volume>18</volume>, <fpage>1851</fpage>â<lpage>1858</lpage>.<pub-id pub-id-type="pmid">18714091</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Liao</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>The Subread aligner: fast, accurate and scalable read mapping by seed-and-vote</article-title>. <source>Nucleic Acids Res</source>., <volume>41</volume>, <fpage>e108.</fpage><pub-id pub-id-type="pmid">23558742</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lin</surname><given-names>H.N.</given-names></name>, <name name-style="western"><surname>Hsu</surname><given-names>W.L.</given-names></name></person-group> (<year>2017</year>) 
<article-title>Kart: a divide-and-conquer algorithm for NGS read alignment</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>2281</fpage>â<lpage>2287</lpage>.<pub-id pub-id-type="pmid">28379292</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Liu</surname><given-names>Y.C.</given-names></name>, <name name-style="western"><surname>Schmidt</surname><given-names>B.</given-names></name></person-group> (<year>2012</year>) 
<article-title>Long read alignment based on maximal exact match seeds</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>I318</fpage>â<lpage>I324</lpage>.<pub-id pub-id-type="pmid">22962447</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Marco-Sola</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>The GEM mapper: fast, accurate and versatile alignment by filtration</article-title>. <source>Nat. Methods</source>, <volume>9</volume>, <fpage>1185</fpage>â<lpage>U1176</lpage>.<pub-id pub-id-type="pmid">23103880</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mortazavi</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) 
<article-title>Mapping and quantifying mammalian transcriptomes by RNA-Seq</article-title>. <source>Nat. Methods</source>, <volume>5</volume>, <fpage>621</fpage>â<lpage>628</lpage>.<pub-id pub-id-type="pmid">18516045</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ryan</surname><given-names>M.C.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>SpliceSeq: a resource for analysis and visualization of RNA-Seq data on alternative splicing and its functional impacts</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>2385</fpage>â<lpage>2387</lpage>.<pub-id pub-id-type="pmid">22820202</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sirbu</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>RNA-seq vs dual- and single-channel microarray data: sensitivity analysis for differential expression and clustering</article-title>. <source>Plos One</source>, <volume>7</volume>, <fpage>e50986</fpage>.<pub-id pub-id-type="pmid">23251411</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Trapnell</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>TopHat: discovering splice junctions with RNA-Seq</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>1105</fpage>â<lpage>1111</lpage>.<pub-id pub-id-type="pmid">19289445</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wang</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>MapSplice: Accurate mapping of RNA-seq reads for splice junction discovery</article-title>. <source>Nucleic Acids Res</source>., <volume>38</volume>, <fpage>e178</fpage>.<pub-id pub-id-type="pmid">20802226</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wheeler</surname><given-names>M.B.</given-names></name></person-group> (<year>1994</year>) 
<article-title>A block-sorting lossless data compression algorithm</article-title>. <source>SRC Res. Rep</source>.</mixed-citation>
    </ref>
    <ref id="btx558-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wu</surname><given-names>T.D.</given-names></name>, <name name-style="western"><surname>Nacu</surname><given-names>S.</given-names></name></person-group> (<year>2010</year>) 
<article-title>Fast and SNP-tolerant detection of complex variants and splicing in short reads</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>873</fpage>â<lpage>881</lpage>.<pub-id pub-id-type="pmid">20147302</pub-id></mixed-citation>
    </ref>
    <ref id="btx558-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zhao</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Comparison of RNA-Seq and microarray in transcriptome profiling of activated T cells</article-title>. <source>Plos One</source>, <volume>9</volume>, <fpage>e78644</fpage>.<pub-id pub-id-type="pmid">24454679</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
