<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">eNeuro</journal-id>
    <journal-id journal-id-type="iso-abbrev">eNeuro</journal-id>
    <journal-id journal-id-type="hwp">eneuro</journal-id>
    <journal-id journal-id-type="publisher-id">eNeuro</journal-id>
    <journal-title-group>
      <journal-title>eNeuro</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2373-2822</issn>
    <publisher>
      <publisher-name>Society for Neuroscience</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8641918</article-id>
    <article-id pub-id-type="pmid">34556557</article-id>
    <article-id pub-id-type="doi">10.1523/ENEURO.0202-21.2021</article-id>
    <article-id pub-id-type="publisher-id">eN-OTM-0202-21</article-id>
    <article-categories>
      <subj-group subj-group-type="hwp-journal-coll">
        <subject>0200</subject>
        <subject>7</subject>
      </subj-group>
      <subj-group subj-group-type="heading">
        <subject>Open Source Tools and Methods</subject>
        <subj-group>
          <subject>Novel Tools and Methods</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>GhostiPy: An Efficient Signal Processing and Spectral Analysis Toolbox for Large Data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Chu</surname>
          <given-names>Joshua P.</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-2054-0234</contrib-id>
        <name>
          <surname>Kemere</surname>
          <given-names>Caleb T.</given-names>
        </name>
      </contrib>
      <aff id="aff1">Department of Electrical and Computer Engineering, <institution>Rice University</institution>, Houston, Texas 77251-1892</aff>
    </contrib-group>
    <author-notes>
      <fn fn-type="other">
        <p>The authors declare no competing financial interests.</p>
      </fn>
      <fn fn-type="con">
        <p>Author contributions: J.P.C. and C.T.K. designed research; J.P.C. performed research; J.P.C. and C.T.K. analyzed data; J.P.C. and C.T.K. wrote the paper.</p>
      </fn>
      <fn fn-type="supported-by">
        <p>The development of GhostiPy was supported by the National Science Foundation (Grant NSF CBET1351692) and the National Institute of Neurological Diseases and Strokes (Grant R01-NS-115233).</p>
      </fn>
      <corresp id="cor1">Correspondence should be addressed to Caleb T. Kemere at <email>caleb.kemere@rice.edu</email>.</corresp>
    </author-notes>
    <pub-date pub-type="epreprint">
      <day>23</day>
      <month>9</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>2</day>
      <month>12</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="collection">
      <season>Nov-Dec</season>
      <year>2021</year>
    </pub-date>
    <volume>8</volume>
    <issue>6</issue>
    <elocation-id>ENEURO.0202-21.2021</elocation-id>
    <history>
      <date date-type="received">
        <day>5</day>
        <month>5</month>
        <year>2021</year>
      </date>
      <date date-type="rev-recd">
        <day>3</day>
        <month>8</month>
        <year>2021</year>
      </date>
      <date date-type="accepted">
        <day>31</day>
        <month>8</month>
        <year>2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2021 Chu and Kemere</copyright-statement>
      <copyright-year>2021</copyright-year>
      <copyright-holder>Chu and Kemere</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open-access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</ext-link>, which permits unrestricted use, distribution and reproduction in any medium provided that the original work is properly attributed.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="ENEURO.0202-21.2021.pdf"/>
    <self-uri xlink:role="icon" xlink:href="ENEURO.0202-21.2021g1.jpg"/>
    <abstract>
      <title>Abstract</title>
      <p>Recent technological advances have enabled neural recordings consisting of hundreds to thousands of channels. As the pace of these developments continues to grow rapidly, it is imperative to have fast, flexible tools supporting the analysis of neural data gathered by such large-scale modalities. Here we introduce GhostiPy (<bold>g</bold>eneral <bold>h</bold>ub <bold>o</bold>f <bold>s</bold>pectral <bold>t</bold>echniques <bold>i</bold>n <bold>Py</bold>thon), a Python open source software toolbox implementing various signal processing and spectral analyses including optimal digital filters and time–frequency transforms. GhostiPy prioritizes performance and efficiency by using parallelized, blocked algorithms. As a result, it is able to outperform commercial software in both time and space complexity for high-channel count data and can handle out-of-core computation in a user-friendly manner. Overall, our software suite reduces frequently encountered bottlenecks in the experimental pipeline, and we believe this toolset will enhance both the portability and scalability of neural data analysis.</p>
    </abstract>
    <kwd-group>
      <kwd>local field potential</kwd>
      <kwd>oscillations</kwd>
      <kwd>signal processing</kwd>
      <kwd>spectral analysis</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>NINDS</funding-source>
        <award-id>R01NS115233</award-id>
      </award-group>
      <award-group>
        <funding-source>NSF</funding-source>
        <award-id>CBET1351692</award-id>
      </award-group>
    </funding-group>
    <counts>
      <fig-count count="10"/>
      <table-count count="2"/>
      <equation-count count="15"/>
      <ref-count count="28"/>
      <page-count count="10"/>
      <word-count count="00"/>
    </counts>
    <custom-meta-group>
      <custom-meta>
        <meta-name>cover-date</meta-name>
        <meta-value>November/December 2021</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="s1">
    <title>Significance Statement</title>
    <p>Because of technological innovation, the size of neural recordings has increased dramatically, but downstream analysis code is often not optimized to handle such large scales of data efficiently. Here we have developed GhostiPy, an open source Python package prioritizing performance and efficiency for large data in the context of typical spectral analysis and signal processing algorithms. Users can control hardware resource consumption (e.g., system memory) by setting the level of parallelization and enabling out-of-core processing. Thus, algorithms can be run on a variety of hardware, from laptops to dedicated computer servers. Overall, GhostiPy improves experimental throughput by increasing the portability of analyses.</p>
  </sec>
  <sec sec-type="intro" id="s2">
    <title>Introduction</title>
    <p>Advancements in neural recording technologies have enabled the collection of large data in both space (high density/channel count) and time (continuous recordings). During subsequent analysis, the scale of the data induces certain challenges that may manifest as the following scenarios: (1) analysis code takes a long time to complete (high time complexity); and (2) code is unable to complete because of insufficient memory on the hardware (high spatial complexity). Moreover, the scientist may have difficulty finding existing tools that address both 1 and 2 and implement the desired analyses.</p>
    <p>Although a potential remedy is to simply upgrade the hardware, it is not an acceptable solution for scientists desiring portability, an important component that improves reproducibility and replicability. In more portable systems, hardware resources may be limited (e.g., using a laptop at the airport). We thus took an alternate approach by efficiently implementing analyses that would trivially scale for different hardware configurations. Our solution is GhostiPy (general hub of spectral techniques in Python), a free and open source Python toolbox that attempts to optimize both time and space complexity in the context of spectral analyses. Methods include linear filtering, signal envelope extraction, and spectrogram estimation, according to best practices. GhostiPy is designed for general purpose usage; while well suited for high-density continuous neural data, it works with any arbitrary array-like data object.</p>
    <p>In this article, we first describe the software design principles of GhostiPy to increase efficiency. We then elaborate on featured methods along with code samples illustrating the user friendliness of the software. Finally, we benchmark our software against a comparable implementation, and we discuss strategies for working under an out-of-core (when data cannot fit into system memory) processing context.</p>
  </sec>
  <sec sec-type="materials|methods" id="s3">
    <title>Materials and Methods</title>
    <p>An overview of implemented methods can be found in <xref rid="T1" ref-type="table">Table 1</xref>. Excluding out-of-core support, it is possible to use multiple different packages (OverLordGold Dragon, <ext-link xlink:href="https://github.com/OverLordGoldDragon/ssqueezepy/" ext-link-type="uri">https://github.com/OverLordGoldDragon/ssqueezepy/</ext-link>; <xref rid="B1" ref-type="bibr">Bokil et al., 2010</xref>; <xref rid="B18" ref-type="bibr">Oostenveld et al., 2011</xref>; <xref rid="B11" ref-type="bibr">Gramfort et al., 2013</xref>; <xref rid="B27" ref-type="bibr">Yegenoglu et al., 2015</xref>; <xref rid="B13" ref-type="bibr">Lee et al., 2019</xref>; <xref rid="B21" ref-type="bibr">Tadel et al., 2019</xref>; <xref rid="B26" ref-type="bibr">Virtanen et al., 2020</xref>) to achieve the same functionality. However, the mix-and-match approach can reduce user friendliness since application programming interfaces (APIs) differ across packages and dependency management is more difficult. We believe our unified package provides an attractive solution to this challenge. <xref rid="T2" ref-type="table">Table 2</xref> documents the methods currently available in GhostiPy.</p>
    <table-wrap position="float" id="T1">
      <label>Table 1</label>
      <caption>
        <p>Features implemented by GhostiPy compared with existing software</p>
      </caption>
      <table frame="hsides" rules="none">
        <col align="left" valign="top" span="1"/>
        <col align="left" valign="top" span="1"/>
        <col align="left" valign="top" span="1"/>
        <col align="left" valign="top" span="1"/>
        <col align="left" valign="top" span="1"/>
        <col align="left" valign="top" span="1"/>
        <col align="left" valign="top" span="1"/>
        <col align="left" valign="top" span="1"/>
        <thead>
          <tr>
            <th align="left" rowspan="1" colspan="1"/>
            <th align="left" rowspan="1" colspan="1">Python</th>
            <th align="left" rowspan="1" colspan="1">Overlap save convolution</th>
            <th align="left" rowspan="1" colspan="1">Multitaper method</th>
            <th align="left" rowspan="1" colspan="1">Hilbert transform</th>
            <th align="left" rowspan="1" colspan="1">CWT</th>
            <th align="left" rowspan="1" colspan="1">Synchrosqueezed transform</th>
            <th align="left" rowspan="1" colspan="1">Out-of-core</th>
          </tr>
        </thead>
        <tbody valign="top">
          <tr>
            <td align="left" rowspan="1" colspan="1">Ghostipy</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">SciPy</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">Chronux</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">Elephant</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">BrainStorm</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">PyWt</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">Field Trip</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">MNE</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">ssqueezepy</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">MATLAB</td>
            <td align="left" rowspan="1" colspan="1">–</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">+</td>
            <td align="left" rowspan="1" colspan="1">–</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <table-wrap position="float" id="T2">
      <label>Table 2</label>
      <caption>
        <p>Available methods in GhostiPy</p>
      </caption>
      <table frame="hsides" rules="none">
        <col align="left" valign="top" span="1"/>
        <col align="left" valign="top" span="1"/>
        <thead>
          <tr>
            <th align="left" rowspan="1" colspan="1">Method</th>
            <th align="left" rowspan="1" colspan="1">Description</th>
          </tr>
        </thead>
        <tbody valign="top">
          <tr>
            <td align="left" rowspan="1" colspan="1">analytic_signal()</td>
            <td align="left" rowspan="1" colspan="1">Compute the analytic signal for<break/>a real-valued signal</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">cwt()</td>
            <td align="left" rowspan="1" colspan="1">Compute the continuous wavelet<break/>transform</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">estimate_taps()</td>
            <td align="left" rowspan="1" colspan="1">Estimate number of taps needed<break/>for an FIR filter</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">filter_data_fir()</td>
            <td align="left" rowspan="1" colspan="1">Filter data using an FIR filter</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">firdesign()</td>
            <td align="left" rowspan="1" colspan="1">Design an FIR filter</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">get_tapers()</td>
            <td align="left" rowspan="1" colspan="1">Compute DPSS tapers</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">group_delay()</td>
            <td align="left" rowspan="1" colspan="1">Get group delay of an FIR filter</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">mtm_spectrogram()</td>
            <td align="left" rowspan="1" colspan="1">Use the multitaper method to<break/>generate a spectrogram</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">mtm_spectrum()</td>
            <td align="left" rowspan="1" colspan="1">Use the multitaper method to<break/>estimate a spectrum</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">plot_fourier_<break/>spectrogram()</td>
            <td align="left" rowspan="1" colspan="1">Plot a spectrogram generated<break/>from a Fourier-based method</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">plot_frequency_<break/>response()</td>
            <td align="left" rowspan="1" colspan="1">Plot frequency response of a<break/>transfer function</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">plot_wavelet_<break/>spectrogram()</td>
            <td align="left" rowspan="1" colspan="1">Plot a spectrogram generated<break/>from a wavelet-based method</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">signal_envelope()</td>
            <td align="left" rowspan="1" colspan="1">Estimate the envelope of a real-<break/>valued signal</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">signal_phase()</td>
            <td align="left" rowspan="1" colspan="1">Estimate the instantaneous<break/>phase of a real-valued signal</td>
          </tr>
          <tr>
            <td align="left" rowspan="1" colspan="1">wsst()</td>
            <td align="left" rowspan="1" colspan="1">Compute the wavelet synchrosqueezed<break/>transform</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <sec id="s3A">
      <title>Software design considerations</title>
      <p>As previously noted, successful completion of analyses may be hampered by long computation times or lack of system memory. Specifically, algorithmic time and space complexity is a major determinant for the efficiency and performance of a software method. In general, it is difficult to optimize both simultaneously. For example, time complexity may be reduced by increasing hardware parallelization, at the expense of higher space complexity (memory requirements). While we sought to lower both kinds of complexity compared with existing solutions, we gave space complexity a higher priority. Stated concretely, slow computation time is primarily a nuisance, but failure to complete an analysis because of insufficient memory is catastrophic.</p>
      <p>Our design decision to prioritize space complexity was particularly critical because it directly influenced which backend library we chose for the fast Fourier transform (FFT), an operation used in the majority of the GhostiPy methods. While investigating the different options, we saw that numpy currently uses the pocketfft backend (<ext-link xlink:href="https://gitlab.mpcdf.mpg.de/mtr/pocketfft" ext-link-type="uri">https://gitlab.mpcdf.mpg.de/mtr/pocketfft</ext-link>; <xref rid="B25" ref-type="bibr">Van Der Walt et al., 2011</xref>). When accelerated with the Intel MKL library, it can be slightly faster than FFTW (<ext-link xlink:href="https://software.intel.com/content/www/us/en/develop/tools/math-kernel-library/benchmarks.html" ext-link-type="uri">https://software.intel.com/content/www/us/en/develop/tools/math-kernel-library/benchmarks.html</ext-link>). However, we have found FFTW (<xref rid="B8" ref-type="bibr">Frigo and Johnson, 1998</xref>, <xref rid="B9" ref-type="bibr">2005</xref>) to be superior for memory management and better suited for FFTs of arbitrary length, including prime and odd numbers. An additional benefit of FFTW was its multithreaded capabilities (<xref rid="F1" ref-type="fig">Fig. 1</xref>). We therefore selected FFTW as our FFT backend.</p>
      <fig position="float" id="F1" fig-type="figure">
        <label>Figure 1.</label>
        <caption>
          <p>GhostiPy uses fftw rather than numpy for its FFT backend. <bold><italic toggle="yes">a</italic></bold>, <bold><italic toggle="yes">b</italic></bold>, Note that when fftw is multithreaded, the computation time can be reduced (<bold><italic toggle="yes">a</italic></bold>) without an increase in memory use (<bold><italic toggle="yes">b</italic></bold>).</p>
        </caption>
        <graphic xlink:href="ENEURO.0202-21.2021_f001" position="float"/>
      </fig>
      <p>To lower space complexity, we used blocked algorithms, including overlap save convolution, which is not offered in any of the standard Python numerical computing libraries such as numpy or scipy (<xref rid="B25" ref-type="bibr">Van Der Walt et al., 2011</xref>; <xref rid="B26" ref-type="bibr">Virtanen et al., 2020</xref>). This approach enabled us to process very large data that could not fit in memory (also known as out-of-core processing). Throughout our code, we also used other strategies such as in-place operations.</p>
      <p>To lower the time complexity, we used efficient lengths of FFTs wherever possible, and we leveraged modern computing hardware by parallelizing our algorithms. For example, a wavelet transform can be trivially parallelized since the transform for each scale is not dependent on other scales.</p>
    </sec>
    <sec id="s3B">
      <title>Finite impulse response filter design</title>
      <p>GhostiPy provides classical signal processing capabilities such as filtering data, using the efficient overlap save convolution. Filtering data is a ubiquitous operation, but before this stage, the filter must itself be designed. While this step may appear somewhat trivial, it can make a significant difference, including the very existence of theta–gamma phase amplitude coupling (<xref rid="B3" ref-type="bibr">Canolty et al., 2006</xref>; <xref rid="B6" ref-type="bibr">Dvorak and Fenton, 2014</xref>).</p>
      <p>Existing packages such as scipy and MNE offer a variety of finite impulse response (FIR) filter design methods (<xref rid="B11" ref-type="bibr">Gramfort et al., 2013</xref>; <xref rid="B26" ref-type="bibr">Virtanen et al., 2020</xref>). However, some methods suffer from the following issues. (1) Using the least-squares method, a solution may result in a filter with a magnitude response effectively of zero throughout. This situation is more common when designing filters with passband relatively low compared with the sampling rate. (2) Using the Remez exchange method, the algorithm may simply fail to converge. (3) Using the window method, the transition bands cannot be controlled exactly, and optimality cannot be defined, as is the case for the least-squares (L2 optimal) and Remez exchange (L1 optimal) methods.</p>
      <p>Therefore, the GhostiPy filter design uses the method defined in the study by <xref rid="B2" ref-type="bibr">Burrus et al. (1992)</xref> for the following reasons: (1) it is simple to design, and the computational complexity is similar to that of a window method and can be implemented on embedded hardware if desired; (2) optimality can be defined, as it is optimal in the L2 sense; (3) transition bands can be defined exactly, and the steepness of the passband rolloff can be controlled by the spline power parameter; and (4) the filter impulse response can be defined analytically. Consequently, its computation does not suffer from the failure modes of the least-squares or Remez exchange methods, as those must solve systems of linear equations. In other words, the design process is reliable and stable.</p>
      <p>This method designs a low-pass filter according to the following:
<disp-formula id="FD1"><label>(1)</label><mml:math id="m1" display="block" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>sin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ω</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>π</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mtext>sin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow></mml:mrow><mml:mi>p</mml:mi></mml:msup></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD2"><label>(2)</label><mml:math id="m2" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mi>ω</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>ω</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo> + </mml:mo><mml:msub><mml:mi>ω</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:mfrac><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>Δ</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>ω</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>ω</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <italic toggle="yes">ω</italic><sub>1</sub> and <italic toggle="yes">ω</italic><sub>2</sub> are radian frequencies defining the transition-band boundaries.</p>
      <p>GhostiPy uses the low-pass filter defined in <xref rid="FD1" ref-type="disp-formula">Equation 1</xref> as a prototype to design more complicated filters. As a result, users can request filters with arbitrary magnitude response. An example is shown in <xref rid="F2" ref-type="fig">Figure 2</xref>.</p>
      <fig position="float" id="F2" fig-type="figure">
        <label>Figure 2.</label>
        <caption>
          <p>FIR filter design. <bold><italic toggle="yes">a</italic></bold>, A theta-band filter designed for full bandwidth data. The specification of the transition bands allows for easy determination of critical frequencies. The −6 dB points are exactly the midpoints of the transition bands. <bold><italic toggle="yes">b</italic></bold>, Filters with arbitrary pass and stop bands may also be designed.</p>
        </caption>
        <graphic xlink:href="ENEURO.0202-21.2021_f002" position="float"/>
      </fig>
    </sec>
    <sec id="s3C">
      <title>Multitaper method</title>
      <p>Users often wish to perform a spectral decomposition on a signal of interest. This can be accomplished by using the multitaper method (<xref rid="B24" ref-type="bibr">Thomson, 1982</xref>; <xref rid="B19" ref-type="bibr">Percival and Walden, 1993</xref>). The technique is well suited to reduce the variance of a spectrum estimate, which is particularly useful when working with noisy neural data. The spectrum estimate is obtained as an average of multiple statistically independent spectrum estimators for a discrete signal, <italic toggle="yes">x</italic>[<italic toggle="yes">n</italic>], with sampling frequency <italic toggle="yes">f<sub>s</sub></italic>, as follows:
<disp-formula id="FD3"><label>(3)</label><mml:math id="m3" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>W</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>L</mml:mi></mml:mfrac><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>L</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD4"><label>(4)</label><mml:math id="m4" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover></mml:mstyle><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>W</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Given the length of data <italic toggle="yes">N</italic> and a smoothing half-bandwidth <italic toggle="yes">W</italic>, the tapers <italic toggle="yes">v<sub>l</sub></italic><sub>,</sub><italic toggle="yes"><sub>W</sub></italic>[<italic toggle="yes">n</italic>] are computed by solving for vectors that satisfy the energy and orthogonality properties, as follows:
<disp-formula id="FD5"><label>(5)</label><mml:math id="m5" display="block" overflow="scroll"><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>W</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>W</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD6"><label>(6)</label><mml:math id="m6" display="block" overflow="scroll"><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>W</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>W</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>≠</mml:mo><mml:mi>m</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>For the tapers, GhostiPy uses the discrete prolate spheroidal sequences (DPSSs), which satisfy <xref rid="FD5" ref-type="disp-formula">Equations 5</xref> and <xref rid="FD6" ref-type="disp-formula">6</xref> and maximize the power in the band [– <italic toggle="yes">W</italic>,<italic toggle="yes">W</italic>] (<xref rid="B24" ref-type="bibr">Thomson, 1982</xref>). An example for computing the multitapered spectrum is shown in <xref rid="F3" ref-type="fig">Figure 3</xref>.</p>
      <fig position="float" id="F3" fig-type="figure">
        <label>Figure 3.</label>
        <caption>
          <p>Multitapered spectra. Data are from a sharp wave ripple event, where energy occurs mainly between 100 and 250 Hz. <bold><italic toggle="yes">a–d</italic></bold>, Bandwidths are 10 Hz (<bold><italic toggle="yes">a</italic></bold>), 15 Hz (<bold><italic toggle="yes">b</italic></bold>), 20 Hz (<bold><italic toggle="yes">c</italic></bold>), and 25 Hz (<bold><italic toggle="yes">d</italic></bold>). Note in the code that the data-sampling rate is 1250 Hz, the FFT is parallelized across eight threads, and ripple_data are a 1D numpy array.</p>
        </caption>
        <graphic xlink:href="ENEURO.0202-21.2021_f003" position="float"/>
      </fig>
    </sec>
    <sec id="s3D">
      <title>Continuous wavelet transform</title>
      <p>Neuroscientists often use a continuous wavelet transform (CWT) to study transient oscillatory activity. The CWT itself is defined in the time domain by the following:
<disp-formula id="FD7"><label>(7)</label><mml:math id="m7" display="block" overflow="scroll"><mml:mrow><mml:mi>W</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mi>∞</mml:mi></mml:mrow><mml:mi>∞</mml:mi></mml:msubsup><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>a</mml:mi></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:mstyle><mml:msup><mml:mi>ψ</mml:mi><mml:mi mathvariant="normal"> * </mml:mi></mml:msup><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mi>a</mml:mi></mml:mfrac></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mi> x </mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <italic toggle="yes">ψ</italic>(…) is the mother wavelet function. The transform represents a two-dimensional decomposition in the scale (<italic toggle="yes">a</italic>) and time (<italic toggle="yes">b</italic>) planes. In the frequency domain, the CWT is given by the inverse Fourier transform of the following:
<disp-formula id="FD8"><label>(8)</label><mml:math id="m8" display="block" overflow="scroll"><mml:mrow><mml:mi>W</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mi>Ψ</mml:mi><mml:mi mathvariant="normal"> * </mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>for a given scale (<italic toggle="yes">a</italic>), where <italic toggle="yes">X</italic> and Ψ are the Fourier transforms of <italic toggle="yes">x</italic> and <italic toggle="yes">ψ</italic>, respectively.</p>
      <p>Many mother wavelet functions have been investigated in the literature, but we have focused on the analytic wavelets, as they are found to be superior, particularly for estimating the phase (<xref rid="B17" ref-type="bibr">Olhede and Walden, 2002</xref>; <xref rid="B14" ref-type="bibr">Lilly and Gascard, 2006</xref>; <xref rid="B15" ref-type="bibr">Lilly and Olhede, 2009</xref>, <xref rid="B16" ref-type="bibr">2012</xref>. We have implemented the analytic Morse, Morlet, and Bump wavelets, whose respective frequency domain definitions are as follows:
<disp-formula id="FD9"><label>(9)</label><mml:math id="m9" display="block" overflow="scroll"><mml:mrow><mml:mi>Ψ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mi>ω</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>ω</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD10"><label>(10)</label><mml:math id="m10" display="block" overflow="scroll"><mml:mrow><mml:mi>Ψ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>e</mml:mi><mml:mi>γ</mml:mi></mml:mrow><mml:mi>β</mml:mi></mml:mfrac></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mfrac><mml:mi>β</mml:mi><mml:mi>γ</mml:mi></mml:mfrac></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>β</mml:mi></mml:msup><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>γ</mml:mi></mml:msup></mml:mrow></mml:msup><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD11"><label>(11)</label><mml:math id="m11" display="block" overflow="scroll"><mml:mrow><mml:mi>Ψ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>μ</mml:mi><mml:mo>−</mml:mo><mml:mi>σ</mml:mi></mml:mrow><mml:mi>a</mml:mi></mml:mfrac></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:msup><mml:msub><mml:mi mathvariant="normal">1</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>−</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>+</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE1"><mml:math id="i1" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi mathvariant="normal">1</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>−</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>+</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the indicator function for the interval (<italic toggle="yes">μ</italic> – <italic toggle="yes">σ</italic>) /<italic toggle="yes">a</italic> ≤ <italic toggle="yes">ω</italic> ≤ (<italic toggle="yes">μ</italic> + <italic toggle="yes">σ</italic>) /<italic toggle="yes">a</italic> and <italic toggle="yes">H</italic>(<italic toggle="yes">ω</italic>) is the Heaviside step function. In our implementation, we use <xref rid="FD8" ref-type="disp-formula">Equation 8</xref> to compute the CWT.</p>
      <p>Note that in practice the timeseries <italic toggle="yes">x</italic>(<italic toggle="yes">t</italic>) is sampled, and the CWT is likewise sampled. Then <xref rid="FD8" ref-type="disp-formula">Equation 8</xref> becomes a pointwise complex multiplication of discrete Fourier transforms, where the discretized angular frequencies <italic toggle="yes">ω<sub>k</sub></italic> are determined by the following:
<disp-formula id="FD12"><label>(12)</label><mml:math id="m12" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mi>ω</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <italic toggle="yes">N</italic> is the number of data samples and Δ<italic toggle="yes">t</italic> is the sampling interval.</p>
      <p>A naive implementation of the wavelet transform (<xref rid="FD8" ref-type="disp-formula">Eq. 8</xref>) calculates untruncated wavelets the same length as the input data. This is often inefficient because it is equivalent to convolving the data with a time-domain wavelet, mainly consisting of leading and trailing zeros. In our approach, we exploit the fact that wavelets are finite in time and frequency, and we use an overlap-save algorithm to compute the CWT purely in the frequency domain. Note that the latter point is particularly critical: because of the Gibbs phenomenon, using any time-domain representation of the wavelet may violate numerical analyticity for wavelet center frequencies near the Nyquist frequency. It is therefore necessary to use only the frequency domain representation of the wavelet. While we offer both traditional/naive and blockwise convolution implementations, the latter will give superior performance for longer-duration data. We believe that this is a valuable option for researchers and that this is the first tool that uses blockwise convolution to implement the CWT.</p>
      <p>For electrophysiological data, a typical wavelet analysis will require computing <xref rid="FD8" ref-type="disp-formula">Equation 8</xref> for 50–500 scales. This is an obvious candidate for parallelization since the wavelet transform for each scale can be computed independently of the others. We use a backend powered by Dask to carry out the parallelization (<xref rid="B20" ref-type="bibr">Rocklin, 2015</xref>). Users can set the number of parallel computations to execute and thereby leverage the multicore capabilities offered by modern computing hardware.</p>
    </sec>
    <sec id="s3E">
      <title>Synchrosqueezing transform</title>
      <p>One disadvantage of the wavelet transform is that its frequency resolution decreases as the temporal resolution increases. Strictly speaking, the CWT results in information contained in the (time, scale) plane, but a single frequency is typically assigned to each scale. Regardless, spectral smearing can be observed at higher frequencies/lower scales. However <xref rid="B4" ref-type="bibr">Daubechies (1996)</xref> and <xref rid="B23" ref-type="bibr">Thakur et al. (2013)</xref> showed the synchrosqueezing transform (SST) could mitigate this issue by transferring a CWT (time, scale) plane information to the (time, frequency) plane.</p>
      <p>The synchrosqueezing transform proceeds as follows. For every scale <italic toggle="yes">a</italic>: compute the CWT <italic toggle="yes">W</italic>(<italic toggle="yes">a</italic>) using <xref rid="FD8" ref-type="disp-formula">Equation 8</xref>, compute the following partial derivative:
<disp-formula id="FD13"><label>(13)</label><mml:math id="m13" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mo>∂</mml:mo><mml:mi>b</mml:mi></mml:msub><mml:mi>W</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mi>ω</mml:mi><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>Ψ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mi>ω</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>and compute the following phase transform: 
<disp-formula id="FD14"><label>(14)</label><mml:math id="m14" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mi>ω</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>π</mml:mi></mml:mrow></mml:mfrac><mml:mi>ℑ</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mo>∂</mml:mo><mml:mi>b</mml:mi></mml:msub><mml:mi>W</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>W</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>The phase transform contains the real frequencies each point in the CWT matrix should be assigned to. In practice, the real frequency space is discretized, so the CWT points are assigned to frequency bins. Note that multiple CWT points at a given time coordinate, <italic toggle="yes">b</italic>, may map to the same frequency bin. In this situation, a given frequency bin is a simple additive accumulation of CWT points.</p>
      <p>Note the similarity of the SST to the spectral reassignment algorithms in the studies by <xref rid="B10" ref-type="bibr">Gardner and Magnasco (2006)</xref> and <xref rid="B7" ref-type="bibr">Fitz and Fulop (2009)</xref>. However, an important distinction is that the SST only operates along the scale dimension. In addition to preserving the temporal resolution of the CWT, this makes SST data easy to work with since uniform sampling can be maintained.</p>
      <p>Overall, the spectrogram methods implemented by GhostiPy give an experimenter a more complete picture of the time-varying spectral content of neural data. <xref rid="F4" ref-type="fig">Figure 4</xref> illustrates this using the scipy standard spectrogram method along with the GhostiPy methods.</p>
      <fig position="float" id="F4" fig-type="figure">
        <label>Figure 4.</label>
        <caption>
          <p>Time–frequency decompositions. <bold><italic toggle="yes">a–c</italic></bold>, Users can leverage the scipy spectrogram (<bold><italic toggle="yes">a</italic></bold>) along with the methods of GhostiPy (<bold><italic toggle="yes">b–d</italic>)</bold> for a richer understanding of their data. The synchrosqueezed transform in <bold><italic toggle="yes">d</italic></bold> gives the overall sharpest time and frequency resolution. Note in the code that data are a 1D numpy array, fs is the sampling rate, nperseg is the spectrogram window size in samples, noverlap is the number of samples overlapping in adjacent windows, and w is the bandwidth for the multitapered spectrogram.</p>
        </caption>
        <graphic xlink:href="ENEURO.0202-21.2021_f004" position="float"/>
      </fig>
    </sec>
    <sec sec-type="data-availability" id="s3F">
      <title>Data availability</title>
      <p>The code/software described in the article is freely available online at <ext-link xlink:href="https://github.com/kemerelab/ghostipy/" ext-link-type="uri">https://github.com/kemerelab/ghostipy/</ext-link>. Jupyter Notebook, which can be found at <ext-link xlink:href="https://github.com/kemerelab/ghostipy/tree/master/examples/2021paper" ext-link-type="uri">https://github.com/kemerelab/ghostipy/tree/master/examples/2021paper</ext-link>, was used to produce the figures. The code and notebooks are also available as <xref rid="ext1" ref-type="supplementary-material">Extended Data 1</xref> and <xref rid="ext2" ref-type="supplementary-material">Extended Data 2</xref>. All results were obtained on an Intel Core i7-4790 desktop computer running the Ubuntu 16.04 operating system.</p>
      <supplementary-material position="float" id="ext1" content-type="local-data">
        <object-id pub-id-type="doi">10.1523/ENEURO.0202-21.2021.ed1</object-id>
        <label>Extended Data 1</label>
        <caption>
          <p>Ghostipy-0.2.0. Download <inline-supplementary-material id="ed1" xlink:href="enu-eN-OTM-0202-21-s01.zip" content-type="local-data">Extended Data 1, ZIP file</inline-supplementary-material>.</p>
        </caption>
      </supplementary-material>
      <supplementary-material position="float" id="ext2" content-type="local-data">
        <object-id pub-id-type="doi">10.1523/ENEURO.0202-21.2021.ed2</object-id>
        <label>Extended Data 2</label>
        <caption>
          <p>Example data analysis notebooks. Download <inline-supplementary-material id="ed2" xlink:href="enu-eN-OTM-0202-21-s02.zip" content-type="local-data">Extended Data 2, ZIP file</inline-supplementary-material>.</p>
        </caption>
      </supplementary-material>
    </sec>
  </sec>
  <sec sec-type="results" id="s4">
    <title>Results</title>
    <sec id="s4A">
      <title>Example analyses</title>
      <p>An example spectrogram of local field potentials recorded in area CA1 of the rat hippocampus is depicted in <xref rid="F5" ref-type="fig">Figure 5</xref>. Clearly apparent are the theta oscillation, theta-nested gamma oscillations, and a sharp wave ripple, which occurs after the animal has stopped moving.</p>
      <fig position="float" id="F5" fig-type="figure">
        <label>Figure 5.</label>
        <caption>
          <p>CWT spectrogram of LFP. Spectrogram of local field potential recordings from area CA1 of the hippocampus of a rat during a 5 min exploration (middle), with movement speed (top) and the raw electrophysiological signal (bottom). A number of features of the hippocampal rhythms can be noted in this example, including the pervasive theta oscillation (∼8 Hz), theta-nested gamma oscillations (∼60 Hz) during movement, and, toward the end, a sharp wave ripple (∼200 Hz). Morse wavelets (<italic toggle="yes">γ</italic> = 3, <italic toggle="yes">β</italic> = 10) were used, and frequencies were limited to [1, 250] Hz.</p>
        </caption>
        <graphic xlink:href="ENEURO.0202-21.2021_f005" position="float"/>
      </fig>
      <p>In addition, GhostiPy can be used as an intermediate for a multistep analysis. <xref rid="F6" ref-type="fig">Figure 6</xref> replicates the speed spectrogram analysis in the study by <xref rid="B12" ref-type="bibr">Kemere et al. (2013)</xref> for an animal exploring a novel and a familiar environment (<xref rid="B35" ref-type="bibr">Mattias et al., 2015</xref>). <xref rid="F7" ref-type="fig">Figure 7</xref> implements the clustering of theta cycles (<xref rid="B28" ref-type="bibr">Zhang et al., 2019</xref>) with Morse wavelets. We have also included notebooks to replicate these example analyses.</p>
      <fig position="float" id="F6" fig-type="figure">
        <label>Figure 6.</label>
        <caption>
          <p>Speed spectrogram. The multitaper spectrogram (bandwidth, 5 Hz) was computed with GhostiPy for nonoverlapping 0.5 s time bins and then <italic toggle="yes">z</italic> scored for each frequency. Each time bin in the spectrogram was assigned to 1 of 21 logarithmically spaced speed bins spanning 0.125–64 cm/s. <bold><italic toggle="yes">a</italic></bold>, <bold><italic toggle="yes">b</italic></bold>, The mean PSD for each speed bin is shown for an animal exploring a novel environment (<bold><italic toggle="yes">a</italic></bold>) and a familiar environment (<bold><italic toggle="yes">b</italic></bold>).</p>
        </caption>
        <graphic xlink:href="ENEURO.0202-21.2021_f006" position="float"/>
      </fig>
      <fig position="float" id="F7" fig-type="figure">
        <label>Figure 7.</label>
        <caption>
          <p>Theta cycle clustering. The Morse wavelet (γ = 3, β = 20) CWT was computed with GhostiPy using 81 frequencies and was subsequently divided into multiple windows, where one window corresponded to one theta cycle. Each CWT sample in a window was assigned to 1 of 20 phase bins according to the instantaneous theta phase at that particular sample. The result was frequency–phase power profiles, which were then clustered into four clusters. Shown is the mean frequency–phase power profile for each cluster. As in <xref rid="B28" ref-type="bibr">Zhang et al., 2019</xref>, these use the hc-11 dataset from CRCNS.org (<xref rid="B30" ref-type="bibr">Grossmark and Buzaki, 2016</xref>, <xref rid="B31" ref-type="bibr">Grossmark et al., 2016</xref>).</p>
        </caption>
        <graphic xlink:href="ENEURO.0202-21.2021_f007" position="float"/>
      </fig>
    </sec>
    <sec id="s4B">
      <title>Performance and complexity</title>
      <p>The calculation of the CWT is computationally intensive and consequently a good method to benchmark performance. Of the software packages listed in <xref rid="T1" ref-type="table">Table 1</xref>, only MATLAB offered an equivalent solution. It was thus chosen as the reference to compare our implementation against. <xref rid="F8" ref-type="fig">Figure 8</xref> shows that our implementation results in faster computation times and better memory usage.</p>
      <fig position="float" id="F8" fig-type="figure">
        <label>Figure 8.</label>
        <caption>
          <p>CWT implementation performance. <bold><italic toggle="yes">a</italic></bold>, <bold><italic toggle="yes">b</italic></bold>, Our implementation of the Morse continuous wavelet transform outperforms MATLAB in both time (<bold><italic toggle="yes">a</italic></bold>) and space complexity (<bold><italic toggle="yes">b</italic></bold>). Note that MATLAB was unable to complete execution for the full range of the test parameter (data length) because of out-of-memory exceptions. The test machine was an Intel Core i7-4790 (eight hyperthreads) equipped with 32 gigabytes of RAM. In both cases, the CWT was parallelized over available CPU threads.</p>
        </caption>
        <graphic xlink:href="ENEURO.0202-21.2021_f008" position="float"/>
      </fig>
      <p>It is not entirely clear what accounts for the higher jaggedness in the MATLAB curves from <xref rid="F8" ref-type="fig">Figure 8</xref>. A possible explanation is that the FFT computation is less efficient for an odd-length transform, but the magnitude of the spikes in the curve is surprising given that the FFT backend of MATLAB also uses FFTW. Regardless, we have demonstrated that our implementation is able to achieve lower time and space complexity. When using the functionality offered by GhostiPy, the following three primary scenarios arise with regard to the sizes of data involved in the processing: (1) both the input and output data fit into core memory; (2) the input fits into core memory, but the output does not; and (3) neither the input nor the output fit.</p>
      <p>In all of the previous examples, we have restricted ourselves to case 1. However, with the ever-increasing sizes of data, the other cases will inevitably be encountered. Case 2 may arise when attempting to generate spectrograms. As the input is a single channel, memory constraints are rarely an issue. For example, even a 10 h local field potential (LFP) recording sampled at 1 kHz and saved as 64 bit floating point values will require &lt;300 mebibytes (MiB) of memory. However, the size of a wavelet spectrogram computed from these data will be directly proportional to the number of scales/frequencies. For a typical range of 1–350 Hz at 10 voices per octave, this amounts to a space requirement of 85 times that of the input data. Given that this can well exceed the core memory size of a machine, the GhostiPy CWT routine can also accept a preallocated output array that is stored on disk (<xref rid="F9" ref-type="fig">Fig. 9</xref>).</p>
      <fig position="float" id="F9" fig-type="figure">
        <label>Figure 9.</label>
        <caption>
          <p>CWT out-of-core. Example code when the output array is too large for main memory. The CWT method is first executed as a dry run to compute the necessary array sizes. Here data are a 1D numpy array, and cwt_data are an HDF5 array created to store the results to disk.</p>
        </caption>
        <graphic xlink:href="ENEURO.0202-21.2021_f009" position="float"/>
      </fig>
      <p>Case 3 may arise when a user wishes to filter many channels of full bandwidth data. One case used is a 1 h recording for a 256-channel probe sampled at 30 kHz and stored as a 2 byte signed integer type; already this requires 51 gibibytes. Our strategy is similar to case 2, where an output array is allocated and stored on disk. As for the input, it is read in chunks, and the size of these can be chosen to lower memory usage, although potentially at a cost to computation time. The code in <xref rid="F10" ref-type="fig">Figure 10</xref> illustrates an example.</p>
      <fig position="float" id="F10" fig-type="figure">
        <label>Figure 10.</label>
        <caption>
          <p>Filtering out-of-core. Filtering data from a large array stored on disk and likewise storing the output on disk. Similar to the CWT out-of-core features, the method is called once as a dry run to compute array sizes, which the user can then pass in to store the result. The filtering method also allows to correct for the delay of the filter and to downsample without storing any intermediate results. Although the example uses the h5py library, any object that behaves like an array can be used. Here ds is the downsampling factor, K is the filter group delay, N is the number of samples, infile[’chdata’] is a (n_channels, n_samples) array, and outdata is an HDF5 array.</p>
        </caption>
        <graphic xlink:href="ENEURO.0202-21.2021_f010" position="float"/>
      </fig>
      <p>Several points can be made about the scheme in <xref rid="F10" ref-type="fig">Figure 10</xref>. Our method allows for downsampling during the convolution, which can reduce the number of stages in a computational scheme. Given full bandwidth data, a traditional strategy to filter to the theta band would look like the following: (1) apply an antialiasing filter; (2) downsample to obtain LFP; (3) store the LFP to disk; (4) apply a theta-band filter; (5) downsample this output; and (5) save the result.</p>
      <p>Using the GhostiPy method, it is not necessary to generate the intermediate LFP. To our knowledge, we do not know of other software that allows out-of-core filtering and downsampling in a single function call. The result is a simultaneous reduction in time and space complexity, by storing only the downsampled result and by filtering only once. Filtering to the theta band is now simplified to the following steps: (1) apply a theta filter to the full bandwidth data; (2) downsample the result; and (3) save the result to disk.</p>
    </sec>
  </sec>
  <sec sec-type="discussion" id="s5">
    <title>Discussion</title>
    <p>We have described the key features of GhostiPy and given examples of its ease of use to perform computations efficiently. Users can thus conduct exploratory spectral analyses quickly across a range of parameters while reducing their concerns for running out of memory, especially since out-of-core computation is supported for many of the methods. Thus, we believe GhostiPy is well suited to handle the ever-increasing size of experimental data.</p>
    <p>In the future, we plan to improve GhostiPy with various enhancements. For example, currently the methods are designed to offer the user a lot of low-level control over areas such as multithreading, and to work with raw array types. However, users may desire a higher-level API. For this reason, we believe it would be a worthwhile endeavor to incorporate our work into frameworks such as NWB (<xref rid="B22" ref-type="bibr">Teeters et al., 2015</xref>); this would also facilitate more widespread adoption. There are also other analyses we could implement, including the adaptive multitaper method (<xref rid="B19" ref-type="bibr">Percival and Walden, 1993</xref>) and other time–frequency reassignment techniques similar to the synchrosqueezing transform (<xref rid="B5" ref-type="bibr">Daubechies et al., 2016</xref>).</p>
    <p>Our primary contribution is improving the ease and speed at which data analysis can be conducted by developing user-friendly software implementing efficient algorithms well suited for large data sizes. This point is specifically demonstrated by our ability to outperform existing solutions in space and time complexity, and to run computations even in out-of-core memory conditions, which enables machines with 1–10 s of of GBs of memory to process data on the scale of 10–100 s of GBs and higher. In these ways, we have increased the accessibility of neural data analysis by enabling it to be run on hardware such as a laptop computer, a scenario that often was not previously possible.</p>
    <p>Finally, the software we developed has a much larger potential impact than the scope described in this article. Although many of the examples given in this article were specific to extracellular rodent hippocampal data, the functionality we implemented is intentionally generic and applicable to many fields. As an example, our code can easily be adapted for use in real-time processing, whether running on embedded hardware or on a laptop computer in a clinical EEG setting. Given the functionality already developed and the full scope of our work, we are optimistic that GhostiPy can help accelerate modern scientific progress.</p>
  </sec>
</body>
<back>
  <ack>
    <p>Acknowledgements: We thank Shayok Dutta (Rice University), Andres Grosmark and Gyorgi Buzsaki (NYU, New York, NY), Loren Frank and Mattias Karlsson (UCSF), and the CRCNS.org data archive for sharing data used in example analyses.</p>
  </ack>
  <ref-list content-type="nameDate">
    <title>References</title>
    <ref id="B1">
      <mixed-citation publication-type="journal"><string-name><surname>Bokil</surname><given-names>H</given-names></string-name>, <string-name><surname>Andrews</surname><given-names>P</given-names></string-name>, <string-name><surname>Kulkarni</surname><given-names>JE</given-names></string-name>, <string-name><surname>Mehta</surname><given-names>S</given-names></string-name>, <string-name><surname>Mitra</surname><given-names>PP</given-names></string-name> (<year>2010</year>) <article-title>Chronux: a platform for analyzing neural signals</article-title>. <source>J Neurosci Methods</source>
<volume>192</volume>:<fpage>146</fpage>–<lpage>151</lpage>. <pub-id pub-id-type="doi">10.1016/j.jneumeth.2010.06.020</pub-id>
<?supplied-pmid 20637804?><pub-id pub-id-type="pmid">20637804</pub-id></mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal"><string-name><surname>Burrus</surname><given-names>CS</given-names></string-name>, <string-name><surname>Soewito</surname><given-names>AW</given-names></string-name>, <string-name><surname>Gopinath</surname><given-names>RA</given-names></string-name> (<year>1992</year>) <article-title>Least squared error FIR filter design with transition bands</article-title>. <source>IEEE Trans Signal Process</source>
<volume>40</volume>:<fpage>1327</fpage>–<lpage>1340</lpage>. <pub-id pub-id-type="doi">10.1109/78.139239</pub-id></mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal"><string-name><surname>Canolty</surname><given-names>RT</given-names></string-name>, <string-name><surname>Edwards</surname><given-names>E</given-names></string-name>, <string-name><surname>Dalal</surname><given-names>SS</given-names></string-name>, <string-name><surname>Soltani</surname><given-names>M</given-names></string-name>, <string-name><surname>Nagarajan</surname><given-names>SS</given-names></string-name>, <string-name><surname>Kirsch</surname><given-names>HE</given-names></string-name>, <string-name><surname>Berger</surname><given-names>MS</given-names></string-name>, <string-name><surname>Barbaro</surname><given-names>NM</given-names></string-name>, <string-name><surname>Knight</surname><given-names>RT</given-names></string-name> (<year>2006</year>) <article-title>High gamma power is phase-locked to theta oscillations in human neocortex</article-title>. <source>Science</source>
<volume>313</volume>:<fpage>1626</fpage>–<lpage>1628</lpage>. <pub-id pub-id-type="doi">10.1126/science.1128115</pub-id>
<?supplied-pmid 16973878?><pub-id pub-id-type="pmid">16973878</pub-id></mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="book"><string-name><surname>Daubechies</surname><given-names>I</given-names></string-name> (<year>1996</year>) <part-title>A nonlinear squeezing of the continuous wavelet transform based on auditory nerve models</part-title>. In: <source>Wavelets in medicine and biology</source> (<person-group person-group-type="editor"><string-name><surname>Aldroubi</surname><given-names>A</given-names></string-name>, <string-name><surname>Unser</surname><given-names>MA</given-names></string-name></person-group>, <role>eds</role>), pp <fpage>527</fpage>–<lpage>546</lpage>. <publisher-loc>Boca Raton, FL</publisher-loc>: <publisher-name>CRC</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal"><string-name><surname>Daubechies</surname><given-names>I</given-names></string-name>, <string-name><surname>Wang</surname><given-names>Y</given-names></string-name>, <string-name><surname>Wu</surname><given-names>H-t</given-names></string-name> (<year>2016</year>) <article-title>ConceFT: concentration of frequency and time via a multitapered synchrosqueezed transform</article-title>. <source>Phil Trans R Soc A</source>
<volume>374</volume>:<fpage>20150193</fpage>. <pub-id pub-id-type="doi">10.1098/rsta.2015.0193</pub-id><pub-id pub-id-type="pmid">26953175</pub-id></mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal"><string-name><surname>Dvorak</surname><given-names>D</given-names></string-name>, <string-name><surname>Fenton</surname><given-names>AA</given-names></string-name> (<year>2014</year>) <article-title>Toward a proper estimation of phase–amplitude coupling in neural oscillations</article-title>. <source>J Neurosci Methods</source>
<volume>225</volume>:<fpage>42</fpage>–<lpage>56</lpage>. <pub-id pub-id-type="doi">10.1016/j.jneumeth.2014.01.002</pub-id>
<?supplied-pmid 24447842?><pub-id pub-id-type="pmid">24447842</pub-id></mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal"><string-name><surname>Fitz</surname><given-names>KR</given-names></string-name>, <string-name><surname>Fulop</surname><given-names>SA</given-names></string-name> (<year>2009</year>) <article-title>A unified theory of time-frequency reassignment</article-title>. <source>arXiv</source>:0903.3080.</mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="book"><string-name><surname>Frigo</surname><given-names>M</given-names></string-name>, <string-name><surname>Johnson</surname><given-names>SG</given-names></string-name> (<year>1998</year>) <part-title>FFTW: an adaptive software architecture for the FFT</part-title>. In: <source>Proceedings of the 1998 IEEE International conference on acoustics, speech and signal processing: ICASSP'98: May 12-15, 1998, Washington state convention and Trade Center, Seattle, WA (USA)</source>, <volume>Vol 3</volume>, pp <fpage>1381</fpage>–<lpage>1384</lpage>. <publisher-loc>Piscataway, NJ</publisher-loc>: <publisher-name>IEEE</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal"><string-name><surname>Frigo</surname><given-names>M</given-names></string-name>, <string-name><surname>Johnson</surname><given-names>SG</given-names></string-name> (<year>2005</year>) <article-title>The design and implementation of FFTW3</article-title>. <source>Proc IEEE</source>
<volume>93</volume>:<fpage>216</fpage>–<lpage>231</lpage>.</mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal"><string-name><surname>Gardner</surname><given-names>TJ</given-names></string-name>, <string-name><surname>Magnasco</surname><given-names>MO</given-names></string-name> (<year>2006</year>) <article-title>Sparse time-frequency representations</article-title>. <source>Proc Natl Acad Sci U S A</source>
<volume>103</volume>:<fpage>6094</fpage>–<lpage>6099</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.0601707103</pub-id>
<?supplied-pmid 16601097?><pub-id pub-id-type="pmid">16601097</pub-id></mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal"><string-name><surname>Gramfort</surname><given-names>A</given-names></string-name>, <string-name><surname>Luessi</surname><given-names>M</given-names></string-name>, <string-name><surname>Larson</surname><given-names>E</given-names></string-name>, <string-name><surname>Engemann</surname><given-names>DA</given-names></string-name>, <string-name><surname>Strohmeier</surname><given-names>D</given-names></string-name>, <string-name><surname>Brodbeck</surname><given-names>C</given-names></string-name>, <string-name><surname>Goj</surname><given-names>R</given-names></string-name>, <string-name><surname>Jas</surname><given-names>M</given-names></string-name>, <string-name><surname>Brooks</surname><given-names>T</given-names></string-name>, <string-name><surname>Parkkonen</surname><given-names>L</given-names></string-name>, <string-name><surname>Hämäläinen</surname><given-names>M</given-names></string-name> (<year>2013</year>) <article-title>MEG and EEG data analysis with MNE-Python</article-title>. <source>Front Neurosci</source>
<volume>7</volume>:<fpage>267</fpage>. <?supplied-pmid 24431986?><pub-id pub-id-type="pmid">24431986</pub-id></mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal"><string-name><surname>Grosmark</surname><given-names>AD</given-names></string-name>, <string-name><surname>Buzsáki</surname><given-names>G</given-names></string-name> (<year>2016</year>) <article-title>Diversity in neural firing dynamics supports both rigid and learned hippocampal sequences</article-title>. <source>Science</source>
<volume>351</volume>:<fpage>1440</fpage>–<lpage>1443</lpage>.<pub-id pub-id-type="pmid">27013730</pub-id></mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal"><string-name><surname>Grosmark</surname><given-names>AD</given-names></string-name>, <string-name><surname>Long</surname><given-names>J</given-names></string-name>, <string-name><surname>Buzsáki</surname><given-names>G</given-names></string-name> (<year>2016</year>) <article-title>Recordings from hippocampal area CA1, PRE, during and POST novel spatial learning</article-title>. CRCNS.org. <pub-id pub-id-type="doi">10.6080/K0862DC5</pub-id>.</mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal"><string-name><surname>Kemere</surname><given-names>C</given-names></string-name>, <string-name><surname>Carr</surname><given-names>MF</given-names></string-name>, <string-name><surname>Karlsson</surname><given-names>MP</given-names></string-name>, <string-name><surname>Frank</surname><given-names>LM</given-names></string-name> (<year>2013</year>) <article-title>Rapid and continuous modulation of hippocampal network state during exploration of new places</article-title>. <source>PLoS One</source>
<volume>8</volume>:<fpage>e73114</fpage>. <pub-id pub-id-type="doi">10.1371/journal.pone.0073114</pub-id>
<?supplied-pmid 24023818?><pub-id pub-id-type="pmid">24023818</pub-id></mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal"><string-name><surname>Lee</surname><given-names>G</given-names></string-name>, <string-name><surname>Gommers</surname><given-names>R</given-names></string-name>, <string-name><surname>Waselewski</surname><given-names>F</given-names></string-name>, <string-name><surname>Wohlfahrt</surname><given-names>K</given-names></string-name>, <string-name><surname>O’Leary</surname><given-names>A</given-names></string-name> (<year>2019</year>) <article-title>PyWavelets: a Python package for wavelet analysis</article-title>. <source>J Open Source Softw</source>
<volume>4</volume>:<fpage>1237</fpage>. <pub-id pub-id-type="doi">10.21105/joss.01237</pub-id></mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal"><string-name><surname>Lilly</surname><given-names>JM</given-names></string-name>, <string-name><surname>Gascard</surname><given-names>J-C</given-names></string-name> (<year>2006</year>) <article-title>Wavelet ridge diagnosis of time-varying elliptical signals with application to an oceanic eddy</article-title>. <source>Nonlin Processes Geophys</source>
<volume>13</volume>:<fpage>467</fpage>–<lpage>483</lpage>. <pub-id pub-id-type="doi">10.5194/npg-13-467-2006</pub-id></mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal"><string-name><surname>Lilly</surname><given-names>JM</given-names></string-name>, <string-name><surname>Olhede</surname><given-names>SC</given-names></string-name> (<year>2009</year>) <article-title>Higher-order properties of analytic wavelets</article-title>. <source>IEEE Trans Signal Process</source>
<volume>57</volume>:<fpage>146</fpage>–<lpage>160</lpage>. <pub-id pub-id-type="doi">10.1109/TSP.2008.2007607</pub-id></mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal"><string-name><surname>Lilly</surname><given-names>JM</given-names></string-name>, <string-name><surname>Olhede</surname><given-names>SC</given-names></string-name> (<year>2012</year>) <article-title>Generalized Morse wavelets as a superfamily of analytic wavelets</article-title>. <source>IEEE Trans Signal Process</source>
<volume>60</volume>:<fpage>6036</fpage>–<lpage>6041</lpage>. <pub-id pub-id-type="doi">10.1109/TSP.2012.2210890</pub-id></mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal"><string-name><surname>Mattias</surname><given-names>K</given-names></string-name>, <string-name><surname>Margaret</surname><given-names>C</given-names></string-name>, <string-name><surname>Frank</surname><given-names>LM</given-names></string-name> (<year>2015</year>) <article-title>Simultaneous extracellular recordings from hippocampal areas CA1 and CA3 (or MEC and CA1) from rats performing an alternation task in two W-shapped tracks that are geometrically identically but visually distinct</article-title>. <source>CRCNS.org</source>. Available at <pub-id pub-id-type="doi">10.6080/K0NK3BZJ</pub-id>.</mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal"><string-name><surname>Olhede</surname><given-names>SC</given-names></string-name>, <string-name><surname>Walden</surname><given-names>AT</given-names></string-name> (<year>2002</year>) <article-title>Generalized morse wavelets</article-title>. <source>IEEE Trans Signal Process</source>
<volume>50</volume>:<fpage>2661</fpage>–<lpage>2670</lpage>. <pub-id pub-id-type="doi">10.1109/TSP.2002.804066</pub-id></mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal"><string-name><surname>Oostenveld</surname><given-names>R</given-names></string-name>, <string-name><surname>Fries</surname><given-names>P</given-names></string-name>, <string-name><surname>Maris</surname><given-names>E</given-names></string-name>, <string-name><surname>Schoffelen</surname><given-names>J-M</given-names></string-name> (<year>2011</year>) <article-title>FieldTrip: open source software for advanced analysis of MEG, EEG, and invasive electrophysiological data</article-title>. <source>Comput Intell Neurosci</source>
<volume>2011</volume>:<fpage>156869</fpage>. <?supplied-pmid 21253357?><pub-id pub-id-type="pmid">21253357</pub-id></mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="book"><string-name><surname>Percival</surname><given-names>DB</given-names></string-name>, <string-name><surname>Walden</surname><given-names>AT</given-names></string-name> (<year>1993</year>) <source>Spectral analysis for physical applications</source>. <publisher-loc>Cambridge, UK</publisher-loc>: <publisher-name>Cambridge UP</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="book"><string-name><surname>Rocklin</surname><given-names>M</given-names></string-name> (<year>2015</year>) <part-title>Dask: parallel computation with blocked algorithms and task scheduling</part-title>. In: <source>Proceedings of the 14th Python in science conference (SCIPY 2015)</source>, <volume>Vol 126</volume> (<person-group person-group-type="editor"><string-name><surname>Huff</surname><given-names>K</given-names></string-name>, <string-name><surname>Bergstra</surname><given-names>J</given-names></string-name></person-group>, <role>eds</role>). <publisher-loc>Austin, TX</publisher-loc>: <publisher-name>SciPy Developers</publisher-name>. [10.25080/Majora-7b98e3ed-013]</mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal"><string-name><surname>Tadel</surname><given-names>F</given-names></string-name>, <string-name><surname>Bock</surname><given-names>E</given-names></string-name>, <string-name><surname>Niso</surname><given-names>G</given-names></string-name>, <string-name><surname>Mosher</surname><given-names>JC</given-names></string-name>, <string-name><surname>Cousineau</surname><given-names>M</given-names></string-name>, <string-name><surname>Pantazis</surname><given-names>D</given-names></string-name>, <string-name><surname>Leahy</surname><given-names>RM</given-names></string-name>, <string-name><surname>Baillet</surname><given-names>S</given-names></string-name> (<year>2019</year>) <article-title>MEG/EEG group analysis with brainstorm</article-title>. <source>Front Neurosci</source>
<volume>13</volume>:<fpage>76</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2019.00076</pub-id>
<?supplied-pmid 30804744?><pub-id pub-id-type="pmid">30804744</pub-id></mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal"><string-name><surname>Teeters</surname><given-names>JL</given-names></string-name>, <string-name><surname>Godfrey</surname><given-names>K</given-names></string-name>, <string-name><surname>Young</surname><given-names>R</given-names></string-name>, <string-name><surname>Dang</surname><given-names>C</given-names></string-name>, <string-name><surname>Friedsam</surname><given-names>C</given-names></string-name>, <string-name><surname>Wark</surname><given-names>B</given-names></string-name>, <string-name><surname>Asari</surname><given-names>H</given-names></string-name>, <string-name><surname>Peron</surname><given-names>S</given-names></string-name>, <string-name><surname>Li</surname><given-names>N</given-names></string-name>, <string-name><surname>Peyrache</surname><given-names>A</given-names></string-name>, <string-name><surname>Denisov</surname><given-names>G</given-names></string-name>, <string-name><surname>Siegle</surname><given-names>JH</given-names></string-name>, <string-name><surname>Olsen</surname><given-names>SR</given-names></string-name>, <string-name><surname>Martin</surname><given-names>C</given-names></string-name>, <string-name><surname>Chun</surname><given-names>M</given-names></string-name>, <string-name><surname>Tripathy</surname><given-names>S</given-names></string-name>, <string-name><surname>Blanche</surname><given-names>TJ</given-names></string-name>, <string-name><surname>Harris</surname><given-names>K</given-names></string-name>, <string-name><surname>Buzsáki</surname><given-names>G</given-names></string-name>, <string-name><surname>Koch</surname><given-names>C</given-names></string-name>, <etal>et al.</etal> (<year>2015</year>) <article-title>Neurodata without borders: creating a common data format for neurophysiology</article-title>. <source>Neuron</source>
<volume>88</volume>:<fpage>629</fpage>–<lpage>634</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuron.2015.10.025</pub-id>
<?supplied-pmid 26590340?><pub-id pub-id-type="pmid">26590340</pub-id></mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal"><string-name><surname>Thakur</surname><given-names>G</given-names></string-name>, <string-name><surname>Brevdo</surname><given-names>E</given-names></string-name>, <string-name><surname>Fučkar</surname><given-names>NS</given-names></string-name>, <string-name><surname>Wu</surname><given-names>H-T</given-names></string-name> (<year>2013</year>) <article-title>The synchrosqueezing algorithm for time-varying spectral analysis: robustness properties and new paleoclimate applications</article-title>. <source>Signal Processing</source>
<volume>93</volume>:<fpage>1079</fpage>–<lpage>1094</lpage>. <pub-id pub-id-type="doi">10.1016/j.sigpro.2012.11.029</pub-id></mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal"><string-name><surname>Thomson</surname><given-names>DJ</given-names></string-name> (<year>1982</year>) <article-title>Spectrum estimation and harmonic analysis</article-title>. <source>Proc IEEE</source>
<volume>70</volume>:<fpage>1055</fpage>–<lpage>1096</lpage>. <pub-id pub-id-type="doi">10.1109/PROC.1982.12433</pub-id></mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal"><string-name><surname>Van Der Walt</surname><given-names>S</given-names></string-name>, <string-name><surname>Colbert</surname><given-names>SC</given-names></string-name>, <string-name><surname>Varoquaux</surname><given-names>G</given-names></string-name> (<year>2011</year>) <article-title>The NumPy array: a structure for efficient numerical computation</article-title>. <source>Comput Sci Eng</source>
<volume>13</volume>:<fpage>22</fpage>–<lpage>30</lpage>. <pub-id pub-id-type="doi">10.1109/MCSE.2011.37</pub-id></mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal"><string-name><surname>Virtanen</surname><given-names>P</given-names></string-name>, <string-name><surname>Gommers</surname><given-names>R</given-names></string-name>, <string-name><surname>Oliphant</surname><given-names>TE</given-names></string-name>, <string-name><surname>Haberland</surname><given-names>M</given-names></string-name>, <string-name><surname>Reddy</surname><given-names>T</given-names></string-name>, <string-name><surname>Cournapeau</surname><given-names>D</given-names></string-name>, <string-name><surname>Burovski</surname><given-names>E</given-names></string-name>, <string-name><surname>Peterson</surname><given-names>P</given-names></string-name>, <string-name><surname>Weckesser</surname><given-names>W</given-names></string-name>, <string-name><surname>Bright</surname><given-names>J</given-names></string-name>, <string-name><surname>van der Walt</surname><given-names>SJ</given-names></string-name>, <string-name><surname>Brett</surname><given-names>M</given-names></string-name>, <string-name><surname>Wilson</surname><given-names>J</given-names></string-name>, <string-name><surname>Millman</surname><given-names>KJ</given-names></string-name>, <string-name><surname>Mayorov</surname><given-names>N</given-names></string-name>, <string-name><surname>Nelson</surname><given-names>ARJ</given-names></string-name>, <string-name><surname>Jones</surname><given-names>E</given-names></string-name>, <string-name><surname>Kern</surname><given-names>R</given-names></string-name>, <string-name><surname>Larson</surname><given-names>E</given-names></string-name>, <string-name><surname>Carey</surname><given-names>CJ</given-names></string-name>, <etal>et al.</etal> (<year>2020</year>) <article-title>SciPy 1.0: fundamental algorithms for scientific computing in Python</article-title>. <source>Nat Methods</source>
<volume>17</volume>:<fpage>261</fpage>–<lpage>272</lpage>. <pub-id pub-id-type="doi">10.1038/s41592-019-0686-2</pub-id>
<?supplied-pmid 32015543?><pub-id pub-id-type="pmid">32015543</pub-id></mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="book"><string-name><surname>Yegenoglu</surname><given-names>A</given-names></string-name>, <string-name><surname>Holstein</surname><given-names>D</given-names></string-name>, <string-name><surname>Phan</surname><given-names>LD</given-names></string-name>, <string-name><surname>Denker</surname><given-names>M</given-names></string-name>, <string-name><surname>Davison</surname><given-names>A</given-names></string-name>, <string-name><surname>Grun</surname><given-names>S</given-names></string-name> (<year>2015</year>) <source>Elephant–open-source tool for the analysis of electrophysiological data sets</source>. <publisher-name>Tech Rep Computational and Systems Neuroscience</publisher-name>. Available at <ext-link xlink:href="https://juser.fz-juelich.de/record/255984" ext-link-type="uri">https://juser.fz-juelich.de/record/255984</ext-link>. </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal"><string-name><surname>Zhang</surname><given-names>L</given-names></string-name>, <string-name><surname>Lee</surname><given-names>J</given-names></string-name>, <string-name><surname>Rozell</surname><given-names>C</given-names></string-name>, <string-name><surname>Singer</surname><given-names>AC</given-names></string-name> (<year>2019</year>) <article-title>Sub-second dynamics of theta-gamma coupling in hippocampal CA1</article-title>. <source>eLife</source>
<volume>8</volume>:<fpage>e44320</fpage>. <pub-id pub-id-type="doi">10.7554/eLife.44320</pub-id><pub-id pub-id-type="pmid">31355744</pub-id></mixed-citation>
    </ref>
  </ref-list>
  <sec sec-type="synthesis-author-response" id="s6">
    <title>Synthesis</title>
    <boxed-text position="float">
      <p>Reviewing Editor: Michaël Zugaro, CNRS, Collège de France, Inserm</p>
      <p>Decisions are customarily a result of the Reviewing Editor and the peer reviewers coming together and discussing their recommendations until a consensus is reached. When revisions are invited, a fact-based synthesis statement explaining their decision and outlining what is needed to prepare a revision will be listed below. The following reviewer(s) agreed to reveal their identity: Adrien Peyrache, Francesco Battaglia.</p>
    </boxed-text>
    <p>The manuscript presents GhostiPy, a new free software Python package for the analysis of neural data. This provides a simple, unified interface to easily access numerous algorithms commonly used in spectral analysis. It can run on multiple platforms and hardware, and can compute e.g. spectrograms without prior downsampling. Some algorithms have been optimized compared to standard (numpy) implementations. Overall, this is a welcome addition to the field. Although the Reviewers have not raised any major concerns, they have indicated several ways in which the manuscript could be significantly improved. In particular, the sections should be reordered to reflect the order in which analyses are actually performed (e.g. filtering, then spectograms), and more practical details should be provided (e.g. description of input parameters).</p>
    <p>Both Reviewers have pointed out that the mathematical presentation of the algorithms (equations, explanation) was unnecessary given that these are standard methods. More relevant to the specific toolbox presented here would be to offer more details about gains in resource usage (computation time, memory load) and richer examples featuring more use cases. In particular, it would be interesting to know more about scalability: for example, one of the reasons FFTW was favored is that it can be multi-threaded, but no example was provided to illustrate how this library performs on a multi-core machine, or whether it is possible (or there are plans) to scale up use of Ghostipy on distributed (cluster) systems.</p>
    <p>Another useful recommendation is to include a list of the API methods/functions of the toolbox, so that it may be seen at a glance what is already possible with the package.</p>
    <p>Minor notes follow.</p>
    <p>Equations 2 and 3 define an orthonormal basis, however in multi-taper analysis (including in Ghostipy) DPSS (or Slepian) sequences are used, which maximizes power in a restricted frequency band. That condition should be added to the description.</p>
    <p>L10: Please clarify that portability is important for reproducibility and replicability.</p>
    <p>Table 1: It misleading to list “Morse wavelet” as the default wavelet function. For example, Fieldtrip supports Morlet waveforms.</p>
    <p>Eq. 1-4: This study describes a software package, not a mathematical method. There is therefore no need for these equations (at least in the main text). This is true also for the other equations in the main text.</p>
    <p>In contrast, the following pseudocode showing how to obtain spectrum contains parameters that are not explained (e.g. “n_fft_threads”), and inputs should be clarified (e.g. “asa”)</p>
    <p>Eq. 5-10 are redundant (one can assume readers know the details of CWT) unless their presentation relates to the implementation of CWT in the software. These should be removed, or it should be explained if the implementation of CWT was improved in this toolbox.</p>
    <p>The goal of Figure 2 is also unclear. Here, spectrograms from different toolboxes are “compared” (i.e. just displayed) which is not the focus of the paper. The comparison should be between the implementation of SST in this software and others, for example MATLAB. How does this software provide an advantage to users to start using it for computing SST?</p>
    <p>Figure 2 gain: x-axis should be time, y-axis Frequency and color bar “normalized PSD", unless the study presents spectrograms in a non-traditional manner. Panels a-d are not described in the legend.</p>
    <p>L132-133: Quoting other articles is unusual in a methodological paper, and judgements such as “Theta-gamma coupling was thus a serendipitous discovery.” (L139) are not expected in this kind of study.</p>
    <p>Figure 4: The study should report the CWT parameters, the length of the example data, the execution time, comparison to other software packages.</p>
    <p>L194: It is unclear why the study focuses only CWT for benchmark. Furthermore, it is not clear if parallelization or the GPU computing capabilities of the CWT in MATLAB was used.</p>
  </sec>
  <sec sec-type="synthesis-author-response" id="s7">
    <title>Author Response</title>
    <p>Dear Reviewers,</p>
    <p>Thank you for your time! We have made numerous changes in response to your suggestions that we think improve the manuscript and will assist it in helping the readers. Please find below, a point-by-point description of the changes that we’ve made.</p>
    <p>In particular, the sections should be reordered to reflect the order in which analyses are actually performed (e.g. filtering, then spectograms), and more practical details should be provided (e.g. description of input parameters).</p>
    <p>We’ve reordered the sections to be filtering, multitaper spectrum estimation, and finally spectrograms. We have attempted to provide more information about the input parameters in the text as needed.</p>
    <p>Both Reviewers have pointed out that the mathematical presentation of the algorithms (equations, explanation) was unnecessary given that these are standard methods. More relevant to the specific toolbox presented here would be to offer more details about gains in resource usage (computation time, memory load) and richer examples featuring more use cases.</p>
    <p>We have added a new figure (Figure 1 in the revised manuscript) detailing performance of FFTW vs numpy’s fft. Figures 6 and 7 demonstrate the use of ghostipy in multi-level analyses previously seen in the literature. Note that the code for these examples are given in the repository - we are happy to include this code in the paper, but we would need guidance on the appropriate way to do this.</p>
    <p>In particular, it would be interesting to know more about scalability: for example, one of the reasons FFTW was favored is that it can be multi-threaded, but no example was provided to illustrate how this library performs on a multi-core machine, or whether it is possible (or there are plans) to scale up use of Ghostipy on distributed (cluster) systems.</p>
    <p>For scalability, the primary focus of ghostipy was to facilitate portability (i.e. so that analyses could still be run on laptops and other smaller scale hardware). However we recognize that researchers may have access to HPC resources, so we have opened up a GitHub issue to implement ghostipy’s algorithms on distributed systems in the future (https://github.com/kemerelab/ghostipy/issues/2). If we find that this is becomes a widely-needed feature, we will work on adding it.</p>
    <p>Another useful recommendation is to include a list of the API methods/functions of the toolbox, so that it may be seen at a glance what is already possible with the package.</p>
    <p>We have added Table 2 which lists available methods and the corresponding descriptions.</p>
    <p>Minor notes:</p>
    <p>Equations 2 and 3 define an orthonormal basis, however in multi-taper analysis (including in Ghostipy) DPSS (or Slepian) sequences are used, which maximizes power in a restricted frequency band. That condition should be added to the description.</p>
    <p>We have added to the manuscript: “For the tapers, ghostipy uses the discrete prolate spheroidal sequences (DPSS), which satisfy Eqns. 3 and 4 and maximize the power in the band [-W, W].”</p>
    <p>L10: Please clarify that portability is important for reproducibility and replicability.</p>
    <p>This sentence has been revised to say “Although a potential remedy is to simply upgrade the hardware, it is not an acceptable solution for scientists desiring portability, an important component that improves reproducibility and replicability.”</p>
    <p>Table 1: It misleading to list “Morse wavelet” as the default wavelet function. For example, Fieldtrip supports Morlet waveforms.</p>
    <p>Table 1 has been revised as “CWT” rather than “Morse CWT.” Entries are likewise updated.</p>
    <p>Eq. 1-4: This study describes a software package, not a mathematical method. There is therefore no need for these equations (at least in the main text). This is true also for the other equations in the main text.</p>
    <p>We believe the equations provide value to users who want to understand what ghostipy implements (e.g. the kind of filters it designs, how it computes the multitapered spectrum (since different packages do this differently)).</p>
    <p>In contrast, the following pseudocode showing how to obtain spectrum contains parameters that are not explained (e.g. “n_fft_threads”), and inputs should be clarified (e.g. “asa”)</p>
    <p>An additional sentence to the Fig. 4 caption was added: “Note in the code that the data sampling rate is 1250 Hz, the FFT is parallelized across 8 threads, and ripple_data is a 1d numpy array.”</p>
    <p>Eq. 5-10 are redundant (one can assume readers know the details of CWT) unless their presentation relates to the implementation of CWT in the software. These should be removed, or it should be explained if the implementation of CWT was improved in this toolbox.</p>
    <p>Text has been added to this section to clarify that we improved the implementation of the CWT by writing a blockwise convolution algorithm in addition to the naive implementation. Using the blockwise algorithm can improve performance and efficiency.</p>
    <p>The goal of Figure 2 is also unclear. Here, spectrograms from different toolboxes are “compared” (i.e. just displayed) which is not the focus of the paper. The comparison should be between the implementation of SST in this software and others, for example MATLAB. How does this software provide an advantage to users to start using it for computing SST?</p>
    <p>Our objective for Figure 2 (now Figure 4 in the manuscript) was to demonstrate that ghostipy computes various time-frequency decompositions that are not provided by standard Python packages (see Table 1). By combining existing functionality with ghostipy’s, users can have a more complete understanding of their data.</p>
    <p>Figure 2 gain: x-axis should be time, y-axis Frequency and color bar “normalized PSD", unless the study presents spectrograms in a non-traditional manner. Panels a-d are not described in the legend.</p>
    <p>Figure 2 has been revised accordingly (now Figure 4 in the manuscript)</p>
    <p>L132-133: Quoting other articles is unusual in a methodological paper, and judgements such as “Theta-gamma coupling was thus a serendipitous discovery.” (L139) are not expected in this kind of study.</p>
    <p>These lines have been removed. The sentence motivating filter design now reads “While this step may appear somewhat trivial, it can make a significant difference, including the very existence of theta-gamma phase amplitude coupling (PAC)"</p>
    <p>Figure 4: The study should report the CWT parameters, the length of the example data, the execution time, comparison to other software packages.</p>
    <p>The caption has been revised to describe the length of example data, Morse wavelet parameters, and restriction of analyzed frequencies. Since the figure was meant to provide an example of a use case, comparison to other software packages is not described.</p>
    <p>L194: It is unclear why the study focuses only CWT for benchmark. Furthermore, it is not clear if parallelization or the GPU computing capabilities of the CWT in MATLAB was used.</p>
    <p>We have specifically focused on the CWT to demonstrate the simultaneous reduction in space and time complexity compared to MATLAB. The caption for Figure 5 now includes the statement “In both cases, the CWT was parallelized over available CPU threads.”</p>
    <p>We appreciate your reconsideration of the manuscript.</p>
    <p>Sincerely,</p>
    <p>The authors</p>
  </sec>
</back>
