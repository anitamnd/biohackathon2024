<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5483318</article-id>
    <article-id pub-id-type="publisher-id">1725</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-017-1725-6</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>CMSA: a heterogeneous CPU/GPU computing system for multiple similar RNA/DNA sequence alignment</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Chen</surname>
          <given-names>Xi</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Chen</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tang</surname>
          <given-names>Shanjiang</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Yu</surname>
          <given-names>Ce</given-names>
        </name>
        <address>
          <email>yuce@tju.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zou</surname>
          <given-names>Quan</given-names>
        </name>
        <address>
          <email>zouquan@tju.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1761 2484</institution-id><institution-id institution-id-type="GRID">grid.33763.32</institution-id><institution>School of Computer Science and Technology, </institution><institution>Tianjin University, </institution></institution-wrap>Yaguan Road, Tianjin, China </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>24</day>
      <month>6</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>24</day>
      <month>6</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2017</year>
    </pub-date>
    <volume>18</volume>
    <elocation-id>315</elocation-id>
    <history>
      <date date-type="received">
        <day>16</day>
        <month>3</month>
        <year>2017</year>
      </date>
      <date date-type="accepted">
        <day>12</day>
        <month>6</month>
        <year>2017</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2017</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License(<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver(<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p>The multiple sequence alignment (MSA) is a classic and powerful technique for sequence analysis in bioinformatics. With the rapid growth of biological datasets, MSA parallelization becomes necessary to keep its running time in an acceptable level. Although there are a lot of work on MSA problems, their approaches are either insufficient or contain some implicit assumptions that limit the generality of usage. First, the information of users’ sequences, including the sizes of datasets and the lengths of sequences, can be of arbitrary values and are generally unknown before submitted, which are unfortunately ignored by previous work. Second, the center star strategy is suited for aligning similar sequences. But its first stage, center sequence selection, is highly time-consuming and requires further optimization. Moreover, given the heterogeneous CPU/GPU platform, prior studies consider the MSA parallelization on GPU devices only, making the CPUs idle during the computation. Co-run computation, however, can maximize the utilization of the computing resources by enabling the workload computation on both CPU and GPU simultaneously.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>This paper presents CMSA, a robust and efficient MSA system for large-scale datasets on the heterogeneous CPU/GPU platform. It performs and optimizes multiple sequence alignment automatically for users’ submitted sequences without any assumptions. CMSA adopts the co-run computation model so that both CPU and GPU devices are fully utilized. Moreover, CMSA proposes an improved center star strategy that reduces the time complexity of its center sequence selection process from <italic>O</italic>(<italic>mn</italic>
<sup>2</sup>) to <italic>O</italic>(<italic>mn</italic>). The experimental results show that CMSA achieves an up to 11× speedup and outperforms the state-of-the-art software.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>CMSA focuses on the multiple similar RNA/DNA sequence alignment and proposes a novel bitmap based algorithm to improve the center star strategy. We can conclude that harvesting the high performance of modern GPU is a promising approach to accelerate multiple sequence alignment. Besides, adopting the co-run computation model can maximize the entire system utilization significantly. The source code is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/wangvsa/CMSA">https://github.com/wangvsa/CMSA</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Heterogeneous</kwd>
      <kwd>GPU</kwd>
      <kwd>Multiple sequence alignment (MSA)</kwd>
      <kwd>Center star alignment</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100001809</institution-id>
            <institution>National Natural Science Foundation of China</institution>
          </institution-wrap>
        </funding-source>
        <award-id>11573019</award-id>
      </award-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100001809</institution-id>
            <institution>National Natural Science Foundation of China</institution>
          </institution-wrap>
        </funding-source>
        <award-id>61602336</award-id>
      </award-group>
      <award-group>
        <funding-source>
          <institution>Joint Research fund in Astronomy</institution>
        </funding-source>
        <award-id>U1531111</award-id>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2017</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Multiple sequence alignment (MSA) refers to the problem of aligning three or more sequences with or without inserting gaps between the symbols [<xref ref-type="bibr" rid="CR1">1</xref>]. It is a fundamental tool for similar sequences analysis in computational biology and molecular function prediction. In computational molecular biology, similar DNA sequences are aligned to find out the single nucleotide polymorphism and the copy-number variant, which is the key content in genetics [<xref ref-type="bibr" rid="CR2">2</xref>]. In molecular function prediction, large-scale similar DNA sequence alignment is required when addressing the evolutionary analysis of bacterial and viral genomes [<xref ref-type="bibr" rid="CR3">3</xref>]. Therefore, MSA software need to be efficient and scalable to handle large-scale datasets, which may contain hundreds of thousands of similar sequences.</p>
    <p>MSA is a problem with an exponential time complexity, it has been proven to be NP-complete [<xref ref-type="bibr" rid="CR4">4</xref>]. Many heuristic algorithms are developed and implemented by previous studies, including Kalign [<xref ref-type="bibr" rid="CR5">5</xref>], MAFFT [<xref ref-type="bibr" rid="CR6">6</xref>] and Clustal [<xref ref-type="bibr" rid="CR7">7</xref>]. However, our experiments show that none of these heuristic-based softwares can address the alignment of large-scale RNA/DNA datasets with more than 100,000 sequences. Besides, all of these softwares are optimized either for short sequences or long sequences and none of them are designed for any arbitrary lengths of sequences.</p>
    <p>On the other hand, heuristic methods model the MSA problem as multiple pairwise alignment problems, and there are two kinds of classic algorithms, i.e., tree-based algorithm and center star algorithm. In the tree-based algorithm, an evolutionary tree may be assumed, with the input sequences assigned to the leaves. Additional reconstructed sequences, corresponding to the internal nodes of the tree, are added to the multiple alignment. A star-alignment will denote the special case in which the tree has only one internal node. This is a reasonable model for the evolutionary history of some input sequences where all the observed sequences are assumed to have arisen by separate lineages from a single ancestral sequence [<xref ref-type="bibr" rid="CR8">8</xref>]. For this scenario, the center star algorithm reduce the times of pairwise alignment, and both methods could achieve a similar accuracy. So in this paper, we focus on paralleling and optimizing the center star algorithm. A K-band strategy [<xref ref-type="bibr" rid="CR2">2</xref>, <xref ref-type="bibr" rid="CR9">9</xref>] is proposed to reduce the time and space cost of dynamic programming process and then developed a MSA software named HAlign, which is based on the center star algorithm and K-band strategy. But its time complexity of finding the center sequence is still too high to make it practical for large-scale datasets. Therefore, we believe that it is necessary to further optimize the center star algorithm for large-scale MSA problems.</p>
    <p>Recently, Graphic Processing Unit (GPU) with the Compute Unified Device Architecture (CUDA) programming model is widely used as additional accelerators for time-consuming computations. And heterogeneous CPU and GPU platform is a desirable way to overlap the computation of the CPU and GPU to fully exploit the compute capability and shorten the runtime [<xref ref-type="bibr" rid="CR10">10</xref>]. However, in the multiple similar sequence alignment area, few parallel implementations exist that can address large-scale datasets and produce good speedups.</p>
    <p>In this paper, we present CMSA, a robust and efficient MSA system for large-scale datasets on the heterogeneous CPU/GPU platform. CMSA is based on the center star strategy and mainly focuses on the alignment of similar RNA/DNA sequences. It can perform and optimize multiple sequence alignment automatically for users’ submitted sequences of any arbitrary length and volume. Second, it adopts the co-run computation model that leverages both CPU and GPU for sequence alignment. So it could maximize the entire system utilization. A pre-computation mechanism is developed in CMSA to estimate the computing capacity of CPU and GPU in advance. CMSA then distributes the workloads for CPU and GPU based on this estimation to achieve a better load balance. Furthermore, we propose a novel bitmap based algorithm to find the center sequence, which is the most crucial procedure in the center star strategy. The new algorithm reduces the time complexity from <italic>O</italic>(<italic>mn</italic>
<sup>2</sup>) to <italic>O</italic>(<italic>mn</italic>) without sacrificing the accuracy. The experiments demonstrate the efficiency and scalability of CMSA. Specifically, it shows that CMSA has a linear scalability as the number of sequences increases and achieves a speedup up to 11×. We also compare CMSA with the state-of-the-art MSA tools including MAFFT, Kalign, and HAlign. The results show that CMSA is much faster than these tools and is able to process large-scale datasets in an acceptable time, whereas previous tools cannot.</p>
    <sec id="Sec2">
      <title>Multiple similar sequence alignment</title>
      <p>Similar sequences probably have the same ancestor, share the same structure, and have a similar biological function. The biological information associated with similar sequences can provide the necessary foundation for determining the structure and function of the newly discovered ones. For example, in computational molecular biology, the alignment of similar DNA sequences can be used to find single nucleotide polymorphism.</p>
      <p>There are several MSA methods that utilize the feature of the similarity between sequences. Progressive MSA methods align the most similar sequences firstly, add then add the less related sequences to the alignment in succession. The basic idea is that long common substrings can be rapidly extracted from the pairwise sequences when the input sequences are highly similar. Thus, we only need to align the remaining short regions. However, few MSA tools are implemented for massive similar sequences alignment. Therefore, we need some methods to solve the MSA problem on similar large-scale datasets.</p>
    </sec>
    <sec id="Sec3">
      <title>Center star strategy</title>
      <p>The main approach underlying the center star strategy is to transform the MSA problem into pairwise alignment problems.</p>
      <p>For a dataset of <italic>n</italic> sequences with the average length of <italic>m</italic>, the <italic>i</italic>
<italic>th</italic> sequence is define as <italic>s</italic>
<sub><italic>i</italic></sub>, where 1≤<italic>i</italic>≤<italic>n</italic>. <italic>S</italic>
<sub><italic>ij</italic></sub> is the similarity score of sequences <italic>s</italic>
<sub><italic>i</italic></sub> and <italic>s</italic>
<sub><italic>j</italic></sub>. <italic>S</italic>
<sub><italic>i</italic></sub> is the total similarity score of sequence <italic>s</italic>
<sub><italic>i</italic></sub>. Then the <italic>S</italic>
<sub><italic>i</italic></sub> is can be computed with the following equation: 
<disp-formula id="Equa"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$S_{i} = \sum_{j=1}^{n} S_{{ij}}, j \neq i $$ \end{document}</tex-math><mml:math id="M2"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math><graphic xlink:href="12859_2017_1725_Article_Equa.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p>Center star strategy contains three steps: 
<list list-type="bullet"><list-item><p><bold>Step 1. Center sequence selection</bold>. Compute the total similarity score <italic>S</italic><sub><italic>i</italic></sub> for each sequence and choose the one with a maximum value as the center sequence.</p></list-item><list-item><p><bold>Step 2. Pairwise alignment.</bold> The center sequence then is pairwise aligned with each of the other sequences.</p></list-item><list-item><p><bold>Step 3. Subtotaling the inserted spaces.</bold> All of the inserted spaces are summed to obtain the final MSA result.</p></list-item></list>
</p>
      <p>Now we analyze the time complexity of the center star strategy. The result is shown in Table <xref rid="Tab1" ref-type="table">1</xref>. Suppose we use a dynamic programming method such as Needleman-Wunsch [<xref ref-type="bibr" rid="CR11">11</xref>] to align sequences, which demands <italic>O</italic>(<italic>m</italic>
<sup>2</sup>) for both time and space. And in the first step, a naive way to find the center sequence is to align each pair of sequences, which costs a total time of <italic>O</italic>(<italic>m</italic>
<sup>2</sup>
<italic>n</italic>
<sup>2</sup>). Then in the second step, aligning the center sequence with other <italic>n</italic>−1 sequences demands a total time of (<italic>mn</italic>
<sup>2</sup>). The position information of all inserted gaps can be stored in <italic>O</italic>(<italic>mn</italic>) spaces. In the last step, those gaps are summed to generate the final result.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>The time complexity of the center star strategy</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Step</th><th align="left">Naive center star</th><th align="left">HAlign</th><th align="left">CMSA</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><italic>O</italic>(<italic>m</italic><sup>2</sup><italic>n</italic><sup>2</sup>)</td><td align="left"><italic>O</italic>(<italic>mn</italic><sup>2</sup>)</td><td align="left"><italic>O</italic>(<italic>mn</italic>)</td></tr><tr><td align="left">2</td><td align="left"><italic>O</italic>(<italic>m</italic><sup>2</sup><italic>n</italic>)</td><td align="left"><italic>O</italic>(<italic>m</italic><sup>2</sup><italic>n</italic>)</td><td align="left"><italic>O</italic>(<italic>m</italic><sup>2</sup><italic>n</italic>)</td></tr><tr><td align="left">3</td><td align="left"><italic>O</italic>(<italic>mn</italic>)</td><td align="left"><italic>O</italic>(<italic>mn</italic>)</td><td align="left"><italic>O</italic>(<italic>mn</italic>)</td></tr></tbody></table></table-wrap>
</p>
      <p>The second column in Table <xref rid="Tab1" ref-type="table">1</xref> shows these three steps’ time complexity of a naive center star strategy. A conclusion can be drawn from the table that most of the time would be used to find the center sequence. To reduce this cost, HAlign [<xref ref-type="bibr" rid="CR9">9</xref>] uses <italic>trie trees</italic> to accelerate the process. The time complexity for building a trie tree for one sequence is <italic>O</italic>(<italic>m</italic>). Searching <italic>n</italic> sequences in a trie tree incurs a time cost of <italic>O</italic>(<italic>mn</italic>). These two steps are performed <italic>n</italic> times to find the center sequence, which requires a total time of <italic>O</italic>(<italic>mn</italic>
<sup>2</sup>). But for large-scale datasets where <italic>n</italic>≫<italic>m</italic>, it’s still not efficient enough. Therefore, in this paper, we propose a novel bitmap-based algorithm that could reduce the time complexity of the first stage to <italic>O</italic>(<italic>mn</italic>) and also achieves a better accuracy compared to HAlign. Our approach will be discussed in detail in “<xref rid="Sec8" ref-type="sec">An improved center star algorithm</xref>” section.</p>
    </sec>
    <sec id="Sec4">
      <title>Heterogeneous CPU/GPU architecture</title>
      <p>There are several different parallel programming approaches on multi-core systems: 
<list list-type="simple"><list-item><label>(i)</label><p>Low-level multi-tasking or multi-threading such as POSIX Thread (pThread) library [<xref ref-type="bibr" rid="CR12">12</xref>].</p></list-item><list-item><label>(ii)</label><p>High-level libraries, such as Intel Threading Building Blocks [<xref ref-type="bibr" rid="CR13">13</xref>], which provides certain abstractions and features attempting to simplify concurrent software development.</p></list-item><list-item><label>(iii)</label><p>Programming languages or language extensions developed specifically for concurrency, such as OpenMP [<xref ref-type="bibr" rid="CR14">14</xref>].</p></list-item></list>
</p>
      <p>Moreover, GPU now is widely used to accelerate time-consuming tasks. GPU contains a scalable array of multi-threaded processing units known as streaming multi-processors (SM). Although GPU is originally designed to render graphics, general-purpose GPU (GPGPU) breaks this limit, and CUDA [<xref ref-type="bibr" rid="CR15">15</xref>] is proposed as a general-purpose programming model for writing highly parallel programs. This model has proven quite successful at programming a broad range of scientific applications [<xref ref-type="bibr" rid="CR16">16</xref>].</p>
      <p>A heterogeneous CPU/GPU platform is proposed to achieve the best performance. Figure <xref rid="Fig1" ref-type="fig">1</xref> depicts this architecture. CPU and GPU are connected by PCIE and both of them have their own memory space. There are two main methods for heterogeneous CPU/GPU programming. 
<list list-type="simple"><list-item><label>(i)</label><p>Consider CPU as a master and GPU as a worker. CPU handles the work assignment, data distribution, etc. GPU is responsible for the whole computation.
<fig id="Fig1"><label>Fig. 1</label><caption><p>The heterogeneous CPU/GPU architecture. To achieving the best performance, the co-run model of CPU and GPU is adopted</p></caption><graphic xlink:href="12859_2017_1725_Fig1_HTML" id="MO1"/></fig>
</p></list-item><list-item><label>(ii)</label><p>CPU still plays the role of a master and at the same time, it shares a portion of GPU’s computations.</p></list-item></list>
</p>
      <p>The former method has a clear work division between CPU and GPU but wastes the computing resource of CPU regrettably. The latter method has a better performance, but it also brings in some tricky issues such as the load balance and extra communications between CPU and GPU.</p>
    </sec>
  </sec>
  <sec id="Sec5">
    <title>Challenges and approaches</title>
    <p>There are several key issues that we need to address for MSA in practice. In the following, we highlight these challenges and then give our corresponding solutions. The detailed implementation will be described in “<xref rid="Sec6" ref-type="sec">Implementation</xref>” section.</p>
    <p><bold>The MSA problem on similar RNA/DNA sequence.</bold> Most MSA methods and tools ignore the similarity of RNA/DNA sequences, which is an important characteristic in RNA/DNA sequence alignment. Center star strategy is more suited for similar sequence alignment, but its center sequence selection process is very slow especially for large-scale datasets.</p>
    <p><italic>An improved center star algorithm.</italic> We have analyzed that the first stage, center sequence selection, is the most time-consuming part of a straightforward implementation of the center star strategy. Therefore, we designed a bitmap liked algorithm to find the center sequence. The time complexity is reduced from <italic>O</italic>(<italic>mn</italic>
<sup>2</sup>) to <italic>O</italic>(<italic>mn</italic>), as discussed in “<xref rid="Sec3" ref-type="sec">Center star strategy</xref>” section.</p>
    <p><bold>Low utilization problem on the heterogeneous CPU/GPU platform.</bold> To further improve the performance of CMSA, parallelization is a sensible way. However, most GPU based MSA systems perform all computations on GPU only. The CPU source is idle. And these GPU based systems cannot run on different platforms which only contain CPU device. Therefore, it’s necessary to exploit the computing power of CPU and GPU at the same time.</p>
    <p><italic>Co-run computation model.</italic> To fully utilize all available computing capacities in the heterogeneous CPU/GPU platform, it is crucial to enable CPU and GPU work concurrently for workload computations (i.e., co-run computation), which means that CPU also performs a portion of computation instead of waiting for GPU to do all the work. The software designed for heterogeneous CPU/GPU platform can adapt to different computation environment. And when the GPU is not available, the CPU can handle the overall computation. Thus, CMSA can run on different platforms with or without GPUs. We designed a pre-computation mechanism to decide how to distribute workloads between CPU and GPU.</p>
    <p><bold>Different lengths of sequences.</bold> Previous MSA software mainly focus on either short or long sequences, but no work consider both of them.</p>
    <p><italic>Automatical configuration.</italic> CMSA could automatically configure the parameters like thread number and block number according to the lengths of sequences. When the space requirement exceeds GPU’s global memory limit, the related computation will be executed on CPU only.</p>
  </sec>
  <sec id="Sec6">
    <title>Implementation</title>
    <p>In this section, the execution overflow of CMSA is first explained. Then our improved center star algorithm is discussed. At last, the implementation details of CMSA on the heterogeneous CPU/GPU platform is described.</p>
    <sec id="Sec7">
      <title>Execution overflow</title>
      <p>CMSA is a heterogeneous CPU/GPU system, using CUDA and OpenMP for parallelization. To reduce the total execution time, CPU also carries out part of the alignment task instead of waiting for GPU to deal with the whole work. The execution overview of CMSA is shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. It contains following steps: 
<list list-type="bullet"><list-item><p><bold>Step 1. Read input sequences.</bold> CMSA reads all sequences into the host (CPU) memory. After the pre-computation process, a copy of sequences that would be handled by GPU will be sent to the device (GPU) memory.
<fig id="Fig2"><label>Fig. 2</label><caption><p>The overall flow of CMSA. Multiple sequence alignment is handled on the heterogeneous CPU/GPU platform</p></caption><graphic xlink:href="12859_2017_1725_Fig2_HTML" id="MO2"/></fig>
</p></list-item><list-item><p><bold>Step 2. Select center sequence.</bold> We design a bitmap based algorithm to find the center sequence. This process has a time complexity of <italic>O</italic>(<italic>mn</italic>) and could be finished within few seconds even with massive sequences, so it is performed on CPU only without any parallelization. The algorithm will be discussed in “<xref rid="Sec8" ref-type="sec">An improved center star algorithm</xref>” section.</p></list-item><list-item><p><bold>Step 3. Workload allocation.</bold> CMSA performs a pre-computation process to decide how to distribute workload for CPU and GPU. In this process, a small number of sequences are aligned in advance to evaluate the computing capacity of CPU and GPU. The detailed information of workload allocation will be described in “<xref rid="Sec9" ref-type="sec">Workload distribution</xref>” section.</p></list-item><list-item><p><bold>Step 4. Pairwise sequence alignment.</bold> CPU and GPU independently execute pairwise alignment of assigned sequences. For better performances, tasks on CPU are executed in parallel by using OpenMP library. On the GPU end, the parameters like the number of threads in a block and the number of blocks in a grid can be automatically configured based on the different lengths of sequences. “<xref rid="Sec10" ref-type="sec">Parallel optimization of pairwise alignment</xref>” section will describe the implementation of both ends.</p></list-item><list-item><p><bold>Step 5. Output.</bold> When both CPU and GPU finish their job, CMSA gathers the result from GPU and CPU, then merges the inserted gaps to generate the final result.</p></list-item></list>
</p>
    </sec>
    <sec id="Sec8">
      <title>An improved center star algorithm</title>
      <p>As we discussed in “<xref rid="Sec3" ref-type="sec">Center star strategy</xref>” section, a straightforward implementation of center star strategy is time-consuming mainly because its first stage. In spite of an improved method has been proposed by HAlign, which could substantially reduce the time of finding the center sequence, it still has a <italic>O</italic>(<italic>mn</italic>
<sup>2</sup>) time complexity. For large-scale datasets where <italic>n</italic>≫<italic>m</italic>, it would become the bottleneck. Thus in this paper, we propose a bitmap based algorithm to further optimize the center sequence selection process.</p>
      <p>First, every sequence is partitioned into a series of disjoint segments. Each segment consists of 8 characters. We use 2 bits (binary number) to represent a character. So a segment needs 16 bits space, which then can be stored in one integer. An example is given in Table <xref rid="Tab2" ref-type="table">2</xref>. Suppose characters ‘A’, ‘T’, ‘C’, ‘G’ are represented by binary numbers 00, 01, 10, and 11, respectively. The binary number of segment “ATCGCGAT” is 0001111011100001, which then is transformed into a decimal number 7905.
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Example of a segment. Convert the RNA/DNA segments to the decimal numbers</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Segment</th><th align="left">ATCGCGAT</th></tr></thead><tbody><tr><td align="left">Binary number</td><td align="left">0001111011100001</td></tr><tr><td align="left">Decimal number</td><td align="left">7905</td></tr></tbody></table></table-wrap>
</p>
      <p>Second, an array of integers denoted as <italic>Occ</italic>[] is built for recording the time of occurrence of all segments. The decimal numbers of their represented segments are used as indexes. Therefore, the size of this array is 2<sup>16</sup> (<italic>Occ</italic>[65535]) since the maximum decimal number of a segment is 2<sup>16</sup>. All elements of <italic>Occ</italic> is initialized with zero. Next, we look through all segments in each sequence and count the occurrences of them. For example, if a sequence has a segment “ATCGCGAT”, whose decimal number is 7905, then the value of <italic>Occ</italic>[7905] is increased by one. Notice that same segments in one sequence only count once.</p>
      <p>Finally, we find the center sequence with <italic>Occ</italic>. We calculate a similarity score (<italic>SS</italic>) for each sequence by accumulate the occurrences of all its segments. Suppose a sequence contains <italic>p</italic> segments and the decimal numbers of these segments are <italic>d</italic>
<sub>1</sub>,<italic>d</italic>
<sub>2</sub>,…,<italic>d</italic>
<sub><italic>p</italic></sub>, then its similarity score is: <italic>SS</italic>=<italic>Occ</italic>[<italic>d</italic>
<sub>1</sub>]+<italic>Occ</italic>[<italic>d</italic>
<sub>2</sub>]+⋯+<italic>Occ</italic>[<italic>d</italic>
<sub><italic>p</italic></sub>]. After calculating all similarity scores, the sequence with a maximum <italic>SS</italic> is chosen to be the center sequence.</p>
      <p>If there are <italic>n</italic> sequences with the average length of <italic>m</italic>, building the <italic>Occ</italic> array for one sequence needs a time of <italic>O</italic>(<italic>m</italic>). So the process incurs a time cost of <italic>O</italic>(<italic>mn</italic>) for <italic>n</italic> sequences. Besides, calculating a similarity score for one sequence needs to access <italic>Occ</italic>
<italic>m</italic> times, so all <italic>SSs</italic> can be calculated in the time of <italic>O</italic>(<italic>mn</italic>). Therefore, the total time complexity of center sequence selection is <italic>O</italic>(<italic>mn</italic>), which is less than HAlign’s <italic>O</italic>(<italic>mn</italic>
<sup>2</sup>). In our experiments, the process of finding the center sequence can complete in a few seconds for a dataset with 500 thousands of sequences.</p>
      <p>As discussed in “<xref rid="Sec3" ref-type="sec">Center star strategy</xref>” section, we apply the dynamic programming method in the second phase of the center star strategy, which requires a time of <italic>O</italic>(<italic>m</italic>
<sup>2</sup>
<italic>n</italic>). In other words, the second step of CMSA, i.e. pairwise alignments, is now the most time-consuming phase. Therefore, we only focus on parallelizing the second step.</p>
    </sec>
    <sec id="Sec9">
      <title>Workload distribution</title>
      <p>One of the key issues of a heterogeneous system is load balance. Since CPU and GPU differ greatly in computing capability, a heterogeneous system needs a way to estimate this differential to achieve the load balance. Suppose the execution time of CPU and GPU are <italic>T</italic>
<sub>1</sub> and <italic>T</italic>
<sub>2</sub>, then the total time of the pairwise alignment is the maxmum value of <italic>T</italic>
<sub>1</sub> and <italic>T</italic>
<sub>2</sub>. So the best performance is achieved when the computations of CPU and GPU are completely overlapped, which means <italic>T</italic>
<sub>1</sub>=<italic>T</italic>
<sub>2</sub>.</p>
      <p>In CMSA, a pre-computation process is performed to decide how to distribute the workload for CPU and GPU. In this process, both CPU and GPU computes the same number of sequences (a small portion of input sequences). CMSA compares the execution time of CPU and GPU (denoted as <italic>t</italic>
<sub>1</sub> and <italic>t</italic>
<sub>2</sub>) to calculate a ratio of computing capability <italic>R</italic>, <inline-formula id="IEq1"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$R = \frac {t_{1}}{t_{2}}$\end{document}</tex-math><mml:math id="M4"><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2017_1725_Article_IEq1.gif"/></alternatives></inline-formula>. According to this ratio, CMSA then assigns <inline-formula id="IEq2"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {n}{R+1}$\end{document}</tex-math><mml:math id="M6"><mml:mfrac><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2017_1725_Article_IEq2.gif"/></alternatives></inline-formula> sequences to CPU and the rest <inline-formula id="IEq3"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {Rn}{R+1}$\end{document}</tex-math><mml:math id="M8"><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">Rn</mml:mtext></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2017_1725_Article_IEq3.gif"/></alternatives></inline-formula> sequences to GPU, where <italic>n</italic> is the number of input sequences.</p>
    </sec>
    <sec id="Sec10">
      <title>Parallel optimization of pairwise alignment</title>
      <p>In the CPU end, OpenMP is used to accelerate the pairwise alignment in a coarse-grained manner. The computation of the DP matrix and the backtracking of score matrices are mapped onto different threads. In other words, each thread is responsible for aligning the center sequence with a different sequence. Threads are working independently, and each thread handles its own memory space including allocating and releasing the resources. The number of threads is usually set to the number of cores in the CPU.</p>
      <p>Typical general-purpose graphics processors consist of multiple identical instances of computation units called Stream Multiprocessors (SM). SM is the unit of computation to which a group of threads, called thread blocks. A CUDA program consists of several <italic>kernels</italic>. When a kernel is launched, a two-level thread structure is generated. The top level is called <italic>grid</italic>, which consists of one or more <italic>blocks</italic>, denoted as <italic>B</italic>. Each block consists of the same number of threads, denoted as <italic>T</italic>. The whole block will be assigned to one SM.</p>
      <p>Like the implementation on CPU, each thread in a kernel aligns one sequence with the center sequence, which means each kernel computes <italic>B</italic>×<italic>T</italic> sequences. As we discussed early, GPU handles <inline-formula id="IEq4"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {Rn}{R+1}$\end{document}</tex-math><mml:math id="M10"><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">Rn</mml:mtext></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2017_1725_Article_IEq4.gif"/></alternatives></inline-formula> sequences totally. So on the GPU end, <inline-formula id="IEq5"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {Rn}{(R+1)(BT)}$\end{document}</tex-math><mml:math id="M12"><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">Rn</mml:mtext></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">BT</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2017_1725_Article_IEq5.gif"/></alternatives></inline-formula> kernels are executed. Since each kernel computes the same number of sequences and the DP matrices computed by each kernel are not used in the next kernel, we could recycle these memory resources. Before the first kernel is invoked, CMSA allocates the memory required for storing the DP matrices in one kernel. And when the last kernel finishes, the memory will be released. The DP matrix is stored in a one-dimensional way in the global memory of GPU. For example, there is a 12GB global memory. In theory, each kernel can simultaneously compute 53688 sequences of the length of 200 if each element in the DP matrix contains three short <italic>short</italic> type digital in this paper.</p>
    </sec>
  </sec>
  <sec id="Sec11">
    <title>Results and discussion</title>
    <p>We evaluate CMSA using 16s rRNA sequences on a heterogeneous CPU/GPU workstation. In this section, we first introduce the experimental environments and then evaluate the efficiency and scalability of CMSA along with our bitmap based algorithm. Finally, we compare CMSA with some of state-of-the-art MSA tools.</p>
    <sec id="Sec12">
      <title>Experimental setup</title>
      <sec id="Sec13">
        <title>Experimental platform</title>
        <p>The experiments are carried out on a heterogeneous CPU/GPU platform, which has 32 GB RAM, an Intel Xeon E5-2620 2.4 GHz processor and an NVIDIA Tesla K40 graphic card. Centos 6.5 is installed and CUDA Toolkit 6.5 is used to compile the program. The CPU consists of 12 cores. The detailed specifications of Tesla K40 is shown in Table <xref rid="Tab3" ref-type="table">3</xref>.
<table-wrap id="Tab3"><label>Table 3</label><caption><p>GPU hardware specifications</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" colspan="2">Tesla K40</th></tr></thead><tbody><tr><td align="left">CUDA Driver Version / Runtime Version</td><td align="left">8.0 / 8.0</td></tr><tr><td align="left">CUDA compute capability</td><td align="left">3.5</td></tr><tr><td align="left">CUDA cores</td><td align="left">2880</td></tr><tr><td align="left">GPU clock rate (MHz)</td><td align="left">745</td></tr><tr><td align="left">Total amount of global memory (GB)</td><td align="left">12</td></tr><tr><td align="left">Memory bandwidth (GB/s)</td><td align="left">288</td></tr><tr><td align="left">Shared memory size per block (bytes)</td><td align="left">49152</td></tr><tr><td align="left">Registers available per block</td><td align="left">65536</td></tr></tbody></table></table-wrap>
</p>
      </sec>
      <sec id="Sec14">
        <title>Datasets</title>
        <p>The BALiBASE is small and is suited only for protein alignment. As there is no benchmark datasets contain large-scale DNA/RNA sequences, we employ human mitochondrial genomes(mt genomes) and 16s rRNA. 16s rRNA sequences are often used to infer phylogenetic relationships and to distinguish species in microbial environmental genome analyses (Hao et al., 2011). All sequences are obtained from NCBI’s GenBank database (<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/pubmed">http://www.ncbi.nlm.nih.gov/pubmed</ext-link>). The mt genomes is a highly similar dataset. To address DNA/RNA sequences with low similarity, we also tested our program on 16s rRNA. We classified these 16s rRNA sequences into three datasets according to their average lengths, named as D1, D2 and D3, respectively, as shown in Table <xref rid="Tab4" ref-type="table">4</xref>.
<table-wrap id="Tab4"><label>Table 4</label><caption><p>Experimental datasets</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Dataset</th><th align="left">Average length</th><th align="left">Num</th><th align="left">File size</th></tr></thead><tbody><tr><td align="left">MT</td><td align="left">16569</td><td align="left">672</td><td align="left">11 MB</td></tr><tr><td align="left">D1</td><td align="left">252</td><td align="left">500000</td><td align="left">183.8 MB</td></tr><tr><td align="left">D2</td><td align="left">490</td><td align="left">500000</td><td align="left">290.6 MB</td></tr><tr><td align="left">D3</td><td align="left">748</td><td align="left">500000</td><td align="left">414.3 MB</td></tr><tr><td align="left">16s rRNA</td><td align="left">1388</td><td align="left">1011621</td><td align="left">1.4 GB</td></tr></tbody></table></table-wrap>
</p>
      </sec>
      <sec id="Sec15">
        <title>Metrics</title>
        <p>The sum-of-pairs (SP) score is often chosen to measure the alignment accuracy. The SP score is the sum of every pairwise alignment score from the MSA. But for large-scale datasets, it may be very large and exceeds the computer’s limitation. Thus we employ the average SP value, which is simply divided the SP value by the number of sequences, n. The average SP can also describe alignment performance. In the experimental tests, a program, “ <italic>bali</italic>_<italic>score</italic>”, downloaded from the Balibase benchmark (<ext-link ext-link-type="uri" xlink:href="http://www.lbgi.fr/balibase/">http://www.lbgi.fr/balibase/</ext-link>) was used to compare the alignment results.</p>
      </sec>
      <sec id="Sec16">
        <title>Baselines</title>
        <p>To show the efficiency and accuracy of CMSA, we compare CMSA with state-of-the-art MSA tools including Kalign, MAFFT and HAlign. Most of state-of-the-art MSA software cannot handle large-scale datasets. In order with data handling size, these tools are T-Coffee (small), CLUSTAL (medium), MAFFT (medium-large) and Kalign(large), as suggesting by EMBL-EBI. Therefore, the MAFFT, Kalign v2 is adopted. Besides, HAlign is the state-of-the-art software using center star strategy. Therefore, we use HAlign, MAFFT and Kalign v2 as benchmarks, and default parameters of Kalign v2, MAFFT and HAlign are used. For fairer comparison, all experiments are conducted on one node.</p>
      </sec>
    </sec>
    <sec id="Sec17">
      <title>Bitmap based algorithm for selecting the center sequence</title>
      <p>As we discussed in “<xref rid="Sec3" ref-type="sec">Center star strategy</xref>” section, both HAlign and CMSA are based on center star strategy. HAlign uses a tire-tree based algorithm to find the center sequence whereas CMSA uses a bitmap based algorithm. To evaluate our new proposed algorithm, we first compare the running time of the first stage of HAlign and CMSA. Then we perform the subsequent steps using the center sequence selected by HAlign and compare its results with ours. In addition to our own datasets, we also test HAlign and CMSA on the human mitochondrial genomes dataset(marked as MT), which is used in HAlign’s experiments. The human mitochondrial genome dataset is a highly similar dataset. It has a total of 672 human mitochondrial genomes shown in Table <xref rid="Tab4" ref-type="table">4</xref>.</p>
      <p>Table <xref rid="Tab5" ref-type="table">5</xref> shows the running time and SP score of HAlign and CMSA(CPU) based on different center sequence selection algorithms. For fairness, the HAlign was tested on only one node. The center sequence showed in the table is the zero-based index of sequences. As we can see, CMSA is much faster than HAlign in all experiments since our bitmap based algorithm has a lower time complexity (<italic>O</italic>(<italic>mn</italic>)). Also, HAlign runs out of memory when computing dataset D3 with 5000 sequences. When processing the dataset D2 with 1000 sequences and the dataset D3 with 1000 sequences, HAlign and CMSA find the same center sequence. Except these two tests, HAlign and CMSA reach a different result. And when inspecting the average SP score, CMSA performs better than HAlign. Besides, the better average SP score occurs with the datasets of high similarity. Thus we can conclude that our new algorithm used to find the center sequence is efficient and accurate with high and low similarity.
<table-wrap id="Tab5"><label>Table 5</label><caption><p>The running time and SP score of single core HAlign and CMSA(CPU) based on different center sequence selection algorithms</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Dataset</th><th align="left">Num</th><th align="left" colspan="2">Center sequence</th><th align="left" colspan="8">Running time(s)</th><th align="left" colspan="2">Average SP score</th></tr></thead><tbody><tr><td align="left"/><td align="left"/><td align="center">HAlign</td><td align="center">CMSA</td><td align="center" colspan="4">HAlign</td><td align="center" colspan="4">CMSA</td><td align="center">HAlign</td><td align="center">CMSA</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left"/><td align="left">Step1</td><td align="left">Step2</td><td align="left">Step3</td><td align="left">Overall</td><td align="left">Step1</td><td align="left">Step2</td><td align="left">Step3</td><td align="left">Overall</td><td align="left"/><td align="left"/></tr><tr><td align="center">MT</td><td align="center">672</td><td align="center">16</td><td align="center">479</td><td align="center">88.19</td><td align="center">33.40</td><td align="center">21.11</td><td align="center">142.70</td><td align="center">0.80</td><td align="center">43.40</td><td align="center">0.50</td><td align="center">44.70</td><td align="center">0.977</td><td align="center">0.987</td></tr><tr><td align="center"/><td align="center">1000</td><td align="center">912</td><td align="center">575</td><td align="center">2.22</td><td align="center">0.42</td><td align="center">0.24</td><td align="center">2.88</td><td align="center">0.05</td><td align="center">0.40</td><td align="center">0.03</td><td align="center">0.48</td><td align="center">0.549</td><td align="center">0.570</td></tr><tr><td align="center">D1</td><td align="center">3000</td><td align="center">912</td><td align="center">575</td><td align="center">23.17</td><td align="center">2.75</td><td align="center">0.77</td><td align="center">26.69</td><td align="center">0.13</td><td align="center">1.20</td><td align="center">0.10</td><td align="center">1.43</td><td align="center">0.550</td><td align="center">0.588</td></tr><tr><td align="center"/><td align="center">5000</td><td align="center">3477</td><td align="center">2266</td><td align="center">67.95</td><td align="center">2.10</td><td align="center">1.28</td><td align="center">71.33</td><td align="center">0.16</td><td align="center">2.15</td><td align="center">0.23</td><td align="center">2.54</td><td align="center">0.492</td><td align="center">0.523</td></tr><tr><td align="center"/><td align="center">1000</td><td align="center">158</td><td align="center">158</td><td align="center">6.93</td><td align="center">0.52</td><td align="center">0.99</td><td align="center">8.44</td><td align="center">0.07</td><td align="center">1.40</td><td align="center">0.10</td><td align="center">1.57</td><td align="center">0.508</td><td align="center">0.548</td></tr><tr><td align="center">D2</td><td align="center">3000</td><td align="center">181</td><td align="center">1447</td><td align="center">70.64</td><td align="center">5.07</td><td align="center">1.20</td><td align="center">76.91</td><td align="center">0.18</td><td align="center">4.90</td><td align="center">0.25</td><td align="center">5.33</td><td align="center">0.484</td><td align="center">0.500</td></tr><tr><td align="center"/><td align="center">5000</td><td align="center">3533</td><td align="center">4677</td><td align="center">200.38</td><td align="center">10.31</td><td align="center">7.60</td><td align="center">218.29</td><td align="center">0.25</td><td align="center">0.96</td><td align="center">0.42</td><td align="center">1.63</td><td align="center">0.455</td><td align="center">0.510</td></tr><tr><td align="center"/><td align="center">1000</td><td align="center">697</td><td align="center">697</td><td align="center">13.50</td><td align="center">2.19</td><td align="center">1.85</td><td align="center">17.54s</td><td align="center">0.12</td><td align="center">4.22</td><td align="center">0.17</td><td align="center">4.15</td><td align="center">0.513</td><td align="center">0.540</td></tr><tr><td align="center">D3</td><td align="center">3000</td><td align="center">2170</td><td align="center">3217</td><td align="center">125.06</td><td align="center">2.19</td><td align="center">1.85</td><td align="center">129.10</td><td align="center">0.24</td><td align="center">13.44</td><td align="center">0.34</td><td align="center">14.02</td><td align="center">0.527</td><td align="center">0.528</td></tr><tr><td align="center"/><td align="center">5000</td><td align="center">2420</td><td align="center">2992</td><td align="center">351.49</td><td align="center">8.40</td><td align="center">9.75</td><td align="center">369.64</td><td align="center">0.37</td><td align="center">22.13</td><td align="center">0.60</td><td align="center">23.10</td><td align="center">0.518</td><td align="center">0.523</td></tr></tbody></table></table-wrap>
</p>
    </sec>
    <sec id="Sec18">
      <title>Efficiency and scalability</title>
      <p>As an indication of how CMSA scales with the size of dataset, Fig. <xref rid="Fig3" ref-type="fig">3</xref>
<xref rid="Fig3" ref-type="fig">a</xref> shows the running time of CMSA on all three datasets described in Table <xref rid="Tab4" ref-type="table">4</xref>. It’s clear that the longer the average length is, the more time it would cost. Moreover, in all three datasets, the running time goes up linearly as the number of sequences increases, which demonstrates a great scalability of CMSA. Figure <xref rid="Fig3" ref-type="fig">3</xref>
<xref rid="Fig3" ref-type="fig">b</xref> shows the speedup of the same experiments. The best speedup is not achieved at first since with a low number of sequences, the runtime of the pre-compute and initialization makes up a considerable proportion. With the increase of the number of sequences, the real computation would dominate most of the running time, which in turn reports a better speedup.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Experiments on datasets with different number of sequences. D1, D2, D3 represent three kinds of datasets described in Table <xref rid="Tab4" ref-type="table">4</xref>. <bold>a</bold> Running time and <bold>b</bold> Speedup</p></caption><graphic xlink:href="12859_2017_1725_Fig3_HTML" id="MO3"/></fig>
</p>
      <p>We have test the CMSA (CPU/GPU) with different numbers of sequences(average length:252). Table <xref rid="Tab6" ref-type="table">6</xref> shows the workload ratio (R) described in “<xref rid="Sec9" ref-type="sec">Workload distribution</xref>” section. From the table, the values of workload ratio are similar, and the average workload ratio of GPU and CPU is 1.420. We can confirm that CMSA has the good method of workload distribution for CPU and GPU.
<table-wrap id="Tab6"><label>Table 6</label><caption><p>Workload radio for GPU and CPU</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Dataset</th><th align="left">Number</th><th align="left">Workload radio</th></tr></thead><tbody><tr><td align="left">D1</td><td align="left">100000</td><td align="left">1.382</td></tr><tr><td align="left"/><td align="left">200000</td><td align="left">1.432</td></tr><tr><td align="left"/><td align="left">300000</td><td align="left">1.435</td></tr><tr><td align="left"/><td align="left">400000</td><td align="left">1.426</td></tr><tr><td align="left"/><td align="left">500000</td><td align="left">1.423</td></tr></tbody></table></table-wrap>
</p>
    </sec>
    <sec id="Sec19">
      <title>Comparison with State-of-the-art tools</title>
      <p>To show the efficiency and accuracy of CMSA, we compare CMSA with state-of-the-art MSA tools. In this setion, CMSA(CPU) and CMSA(CPU/GPU) are both tested.</p>
      <p>Table <xref rid="Tab7" ref-type="table">7</xref> shows the time consumed for three datasets with different number of sequences computed. In our experiments, Kalign cannot handle datasets that consist of more than 100,000 sequences. MAFFT runs without a problem, but it takes too much time, e.g. 18 h for D1 with 100,000 sequences and more than 24 h for D2 and D3 with 100,000 sequences. So we don’t record the exact running time of CMSA for D2 and D3 with more than 100,000 sequences. In comparison, both HAlign and CMSA can handle all datasets in an acceptable time. Moreover, in all experiments, CMSA is the fastest one and also the one having the best scalability as the number of sequences increases. When computing D3, CMSA is 13× faster than HAlign when the dataset size is 10,000 and 24× faster when the size increases to 500,000.
<table-wrap id="Tab7"><label>Table 7</label><caption><p>Running time of different MSA tools with different number of sequences and average length</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Dataset</th><th align="left">Number</th><th align="left">Kalign</th><th align="left">MAFFT</th><th align="left">HAlign(one node)</th><th align="left">CMSA(CPU)</th><th align="left">CMSA(CPU/GPU)</th></tr></thead><tbody><tr><td align="left">D1</td><td align="left">10000</td><td align="left">20m39s</td><td align="left">2m26s</td><td align="left">39.99s</td><td align="left">6.66s</td><td align="left">7.71s</td></tr><tr><td align="left"/><td align="left">100000</td><td align="left">-</td><td align="left">18h30m</td><td align="left">5m59s</td><td align="left">41.61s</td><td align="left">44.32s</td></tr><tr><td align="left"/><td align="left">500000</td><td align="left">-</td><td align="left">-</td><td align="left">33m17s</td><td align="left">3m15s</td><td align="left">3m20s</td></tr><tr><td align="left">D2</td><td align="left">10000</td><td align="left">52m28s</td><td align="left">4m40s</td><td align="left">1m36s</td><td align="left">16.21s</td><td align="left">17.19s</td></tr><tr><td align="left"/><td align="left">100000</td><td align="left">-</td><td align="left">-</td><td align="left">22m11s</td><td align="left">2m14s</td><td align="left">2m36s</td></tr><tr><td align="left"/><td align="left">500000</td><td align="left">-</td><td align="left">-</td><td align="left">2h15m</td><td align="left">11m6s</td><td align="left">12m1s</td></tr><tr><td align="left">D3</td><td align="left">10000</td><td align="left">79m23s</td><td align="left">8m59s</td><td align="left">10m9s</td><td align="left">45.01s</td><td align="left">44.11s</td></tr><tr><td align="left"/><td align="left">100000</td><td align="left">-</td><td align="left">-</td><td align="left">15m27s</td><td align="left">6m16s</td><td align="left">6m21s</td></tr><tr><td align="left"/><td align="left">500000</td><td align="left">-</td><td align="left">-</td><td align="left">11h2m</td><td align="left">30m28s</td><td align="left">27m58s</td></tr></tbody></table></table-wrap>
</p>
      <p>Table <xref rid="Tab8" ref-type="table">8</xref> shows the comparison result of average SP scores for 16 s rRNA datasets. From Table <xref rid="Tab8" ref-type="table">8</xref>, we can observe that MAFFT produced better alignment results than other state-of-the-art MSA softwares when addressing the large-scale datasets. The average SP of CMSA was lower than that of MAFFT and higher than that of HAlign. Therefore, we confirm the robustness of CMSA, whether with large-scale or small datasets.
<table-wrap id="Tab8"><label>Table 8</label><caption><p>Average SP scores of different MSA tools with different number of sequences and average length</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Dataset</th><th align="left">Number</th><th align="left">Kalign</th><th align="left">MAFFT</th><th align="left">HAlign(one node)</th><th align="left">CMSA(CPU)</th><th align="left">CMSA(CPU/GPU)</th></tr></thead><tbody><tr><td align="left">D1</td><td align="left">10000</td><td align="left">0.570</td><td align="left">0.560</td><td align="left">0.340</td><td align="left">0.467</td><td align="left">0.428</td></tr><tr><td align="left"/><td align="left">100000</td><td align="left">-</td><td align="left">0.561</td><td align="left">0.340</td><td align="left">0.478</td><td align="left">0.431</td></tr><tr><td align="left"/><td align="left">500000</td><td align="left">-</td><td align="left">-</td><td align="left">0.372</td><td align="left">0.473</td><td align="left">0.423</td></tr><tr><td align="left">D2</td><td align="left">10000</td><td align="left">0.458</td><td align="left">0.472</td><td align="left">0.329</td><td align="left">0.467</td><td align="left">0.447</td></tr><tr><td align="left"/><td align="left">100000</td><td align="left">-</td><td align="left">-</td><td align="left">0.380</td><td align="left">0.474</td><td align="left">0.454</td></tr><tr><td align="left"/><td align="left">500000</td><td align="left">-</td><td align="left">-</td><td align="left">0.327</td><td align="left">0.480</td><td align="left">0.449</td></tr><tr><td align="left">D3</td><td align="left">10000</td><td align="left">0.480</td><td align="left">0.479</td><td align="left">0.401</td><td align="left">0.474</td><td align="left">0.414</td></tr><tr><td align="left"/><td align="left">100000</td><td align="left">-</td><td align="left">-</td><td align="left">0.376</td><td align="left">0.477</td><td align="left">0.437</td></tr><tr><td align="left"/><td align="left">500000</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">0.472</td><td align="left">0.441</td></tr></tbody></table></table-wrap>
</p>
    </sec>
  </sec>
  <sec id="Sec20">
    <title>Related work</title>
    <p>There are a number of work on MSA problems and many parallel techniques as well as optimization methods have been proposed to accelerate MSA algorithms. In this section, we review them from two aspects.</p>
    <p><bold>MSA software and algorithms.</bold> MSA software can be classified into two categories based on their underlying algorithms: heuristic based or combinatorial optimization based. Many popular MSA tools like T-Coffee [<xref ref-type="bibr" rid="CR17">17</xref>], CLUSTAL [<xref ref-type="bibr" rid="CR7">7</xref>], Kalign [<xref ref-type="bibr" rid="CR5">5</xref>] and MAFFT [<xref ref-type="bibr" rid="CR6">6</xref>] are based on heuristic methods. T-Coffee can make accurate alignments of very divergent proteins but only for small sets of sequences, given its high computational cost. CLUSTAL is suitable for medium-large alignments. On a single machine, it is possible to take over an hour to compute 10,000 sequences with a more accurate method of CLUSTAL. Kalign is as accurate as other methods on small alignments, but is significantly more accurate when aligning large and distantly related sets of sequences. MAFFT uses fast fourier transforms, which can handle medium-large file sizes and align many thousands of sequences. ClustalW [<xref ref-type="bibr" rid="CR18">18</xref>] has more than 52,400 citations now and is considered the most popular MSA tool. A commercial parallel version of ClustalW is designed for expensive SGI shared memory multiprocessor machines [<xref ref-type="bibr" rid="CR19">19</xref>]. ClustalW-MPI [<xref ref-type="bibr" rid="CR20">20</xref>] targets distributed memory workstation clusters using MPI but parallelize only Stages 1 and 3 of ClustalW. It achieves speedup of 4.3 using 16 processors on the 500-sequences test data. MSA-CUDA [<xref ref-type="bibr" rid="CR21">21</xref>] parallelizes all three stages of the ClustalW processing pipeline using CUDA and achieves average speedup of 18.74 for average-length protein sequences compared to the sequential ClustalW. CUDA MAFFT [<xref ref-type="bibr" rid="CR22">22</xref>] also uses CUDA to accelerate MAFFT that can achieve speedup up to 19.58 on a NVIDIA Tesla C2050 GPU compared to the sequential and multi-thread MAFFT.</p>
    <p><bold>Center star algorithm.</bold> The center star algorithm is a combinatorial optimization method and it is much more suited for aligning similar sequences. Then, K-band [<xref ref-type="bibr" rid="CR2">2</xref>] is proposed to reduce the space and time cost of the pairwise alignment stage of the center star strategy. Based on the fact that for similar sequences, the backtracking often runs along the diagonal, so the lower left quarter and the upper right quarter in dynamic programming table are not taken into consideration. Therefore the K-band method only computes the band of which the width is k nearby the diagonal of the dynamic programming table. HAlign [<xref ref-type="bibr" rid="CR9">9</xref>]then further optimized the center star algorithm with a trie-tree data structure, as we discussed in “<xref rid="Sec3" ref-type="sec">Center star strategy</xref>” section. But this method still requires a time cost of <italic>O</italic>(<italic>mn</italic>
<sup>2</sup>) to find the center sequence, which is not efficient enough to handle large-scale datasets. Because of this, their Hadoop version skips the center sequence selection process and just designate the first sequence as the center sequence. Moreover, to our best knowledge, there are no work exist on accelerating the center star algorithm with CUDA enabled GPUs.</p>
  </sec>
  <sec id="Sec21" sec-type="conclusion">
    <title>Conclusion</title>
    <p>In this paper, we designed CMSA, a robust and efficient MSA system for large-scale datasets on the heterogeneous CPU/GPU system. CMSA is based on an improved center star strategy, for which we proposed a novel bitmap based algorithm to find the center sequence. The new algorithm reduces the time complexity from <italic>O</italic>(<italic>mn</italic>
<sup>2</sup>) to <italic>O</italic>(<italic>mn</italic>). Moreover, CMSA is capable of aligning a large number of sequences with different lengths, which extends the generality of previous studies in MSA. In addition, to fully utilize the computing devices, CMSA takes co-run computation model so that the workloads are assigned and computed on both CPU and GPU devices simultaneously. Specifically, we proposed a pre-computation mechanism in CMSA to distribute workloads to CPU and GPU based on their computing capacity. Moreover, the more accurate mechanism will be future work to be performed for CMSA.</p>
    <p>The experiment results demonstrated the efficiency and scalability of CMSA for large-scale datasets. CMSA achieved a speedup of 11 at best and can handle a large dataset with 500,000 sequences in half an hour. We also evaluated our center sequence selection algorithm. It is much faster and accurate that trie-tree based algorithm proposed in HAlign. Besides, we compared CMSA with some state-of-the-art MSA tools including Kalign, HAlign and MAFFT. In all our experiments, CMSA outperformed those software both in average SP scores and in the execution times.</p>
  </sec>
  <sec id="Sec22">
    <title>Availability and requirements</title>
    <p>
      <list list-type="bullet">
        <list-item>
          <p><bold>Project name</bold>: CMSA</p>
        </list-item>
        <list-item>
          <p><bold>Project home page</bold>: https://github.com/wangvsa/CMSA</p>
        </list-item>
        <list-item>
          <p><bold>Operating system(s)</bold>: Linux 64-bit</p>
        </list-item>
        <list-item>
          <p><bold>Programming language</bold>: C++, CUDA, OpenMP</p>
        </list-item>
        <list-item>
          <p><bold>Other requirements</bold>: CUDA-capable GPU</p>
        </list-item>
        <list-item>
          <p><bold>license</bold>: GUN GPL</p>
        </list-item>
        <list-item>
          <p><bold>Any restrictions to use by non-academics</bold>: None</p>
        </list-item>
        <list-item>
          <p>The datasets used in this paper is available from: http://datamining.xmu.edu.cn/software/halign/and http://www.ncbi.nlm.nih.gov/pubmed.</p>
        </list-item>
        <list-item>
          <p>The program,“<italic>bali</italic>_<italic>score</italic>", is available from the Balibase bench-mark (http://www.lbgi.fr/balibase/).</p>
        </list-item>
      </list>
    </p>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>CPU</term>
        <def>
          <p>Central processing unit</p>
        </def>
      </def-item>
      <def-item>
        <term>CUDA</term>
        <def>
          <p>Compute unified device architecture</p>
        </def>
      </def-item>
      <def-item>
        <term>GPU</term>
        <def>
          <p>Graphics processing unit</p>
        </def>
      </def-item>
      <def-item>
        <term>MPI</term>
        <def>
          <p>Message passing interface</p>
        </def>
      </def-item>
      <def-item>
        <term>MSA</term>
        <def>
          <p>Multiple sequence alignment</p>
        </def>
      </def-item>
      <def-item>
        <term>NCBI</term>
        <def>
          <p>National center for biotechnology information</p>
        </def>
      </def-item>
      <def-item>
        <term>OpenMP</term>
        <def>
          <p>Open multiprocessing</p>
        </def>
      </def-item>
      <def-item>
        <term>PCIe</term>
        <def>
          <p>Peripheral component interconnect express</p>
        </def>
      </def-item>
      <def-item>
        <term>pthread</term>
        <def>
          <p>POSIX thread</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <ack>
    <title>Acknowledgements</title>
    <p>We gratefully acknowledge the support of NVIDIA Corporation with the donation of the Tesla K40 GPU used for this research. Besides, Shanjiang Tang is one of the corresponding authors.</p>
    <sec id="d29e2935">
      <title>Funding</title>
      <p>This work is supported by the National Natural Science Foundation of China (61602336, 61370010, U1531111).</p>
    </sec>
    <sec id="d29e2940">
      <title>Authors’ contributions</title>
      <p>XC conceptualized the study, carried out the design and implementation of the algorithm, analyzed the results and drafted the manuscript; CW implemented the parallel part of CMSA, designed the experiments and revised for important intellectual content. SJT, CY provided expertise on the GPU, participated in analysis of the results and contributed to revise the manuscript. QZ provided expertise on the MSA and contributed to revise the manuscript. All authors read and approved the final manuscript.</p>
    </sec>
    <sec id="d29e2945">
      <title>Competing interests</title>
      <p>The authors declare that they have no competing interests.</p>
    </sec>
    <sec id="d29e2950">
      <title>Consent for publication</title>
      <p>Not applicable.</p>
    </sec>
    <sec id="d29e2955">
      <title>Ethics approval and consent to participate</title>
      <p>Not applicable.</p>
    </sec>
    <sec id="d29e2960">
      <title>Publisher’s Note</title>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </sec>
  </ack>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <mixed-citation publication-type="other">Karadimitriou K, Kraft DH. Genetic algorithms and the multiple sequence alignment problem in biology. In: Proceedings of the Second Annual Molecular Biology and Biotechnology Conference. Baton Rouge: 1996. p. 1–7.</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zou</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Shan</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>A novel center star multiple sequence alignment algorithm based on affine gap penalty and k-band</article-title>
        <source>Phys Procedia</source>
        <year>2012</year>
        <volume>33</volume>
        <fpage>322</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1016/j.phpro.2012.05.069</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Guo</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Xing</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Che</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Lnetwork: an efficient and effective method for constructing phylogenetic networks</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <fpage>378</fpage>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>On the complexity of multiple sequence alignment</article-title>
        <source>J Comput Biol</source>
        <year>1994</year>
        <volume>1</volume>
        <issue>4</issue>
        <fpage>337</fpage>
        <lpage>48</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.1994.1.337</pub-id>
        <?supplied-pmid 8790475?>
        <pub-id pub-id-type="pmid">8790475</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lassmann</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Sonnhammer</surname>
            <given-names>EL</given-names>
          </name>
        </person-group>
        <article-title>Kalign–an accurate and fast multiple sequence alignment algorithm</article-title>
        <source>BMC Bioinforma</source>
        <year>2005</year>
        <volume>6</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-6-298</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Katoh</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Misawa</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Kuma</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Miyata</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Mafft: a novel method for rapid multiple sequence alignment based on fast fourier transform</article-title>
        <source>Nucleic Acids Res</source>
        <year>2002</year>
        <volume>30</volume>
        <issue>14</issue>
        <fpage>3059</fpage>
        <lpage>66</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkf436</pub-id>
        <?supplied-pmid 12136088?>
        <pub-id pub-id-type="pmid">12136088</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Higgins</surname>
            <given-names>DG</given-names>
          </name>
          <name>
            <surname>Sharp</surname>
            <given-names>PM</given-names>
          </name>
        </person-group>
        <article-title>Clustal: a package for performing multiple sequence alignment on a microcomputer</article-title>
        <source>Gene</source>
        <year>1988</year>
        <volume>73</volume>
        <issue>1</issue>
        <fpage>237</fpage>
        <lpage>44</lpage>
        <pub-id pub-id-type="doi">10.1016/0378-1119(88)90330-7</pub-id>
        <?supplied-pmid 3243435?>
        <pub-id pub-id-type="pmid">3243435</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Trees, stars, and multiple biological sequence alignment</article-title>
        <source>SIAM J Appl Math</source>
        <year>1989</year>
        <volume>49</volume>
        <issue>1</issue>
        <fpage>197</fpage>
        <lpage>209</lpage>
        <pub-id pub-id-type="doi">10.1137/0149012</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zou</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Hu</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Guo</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Halign: Fast multiple similar dna/rna sequence alignment based on the centre star strategy</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <issue>15</issue>
        <fpage>2475</fpage>
        <lpage>81</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv177</pub-id>
        <?supplied-pmid 25812743?>
        <pub-id pub-id-type="pmid">25812743</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <source>Bioinformatics: High Performance Parallel Computer Architectures</source>
        <year>2010</year>
        <publisher-loc>Florida</publisher-loc>
        <publisher-name>CRC Press</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Needleman</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Wunsch</surname>
            <given-names>CD</given-names>
          </name>
        </person-group>
        <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>
        <source>J Mol Biol</source>
        <year>1970</year>
        <volume>48</volume>
        <issue>3</issue>
        <fpage>443</fpage>
        <lpage>53</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-2836(70)90057-4</pub-id>
        <?supplied-pmid 5420325?>
        <pub-id pub-id-type="pmid">5420325</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Garcia</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Fernandez</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Posix thread libraries</article-title>
        <source>Linux J</source>
        <year>2000</year>
        <volume>2000</volume>
        <issue>70es</issue>
        <fpage>36</fpage>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Reinders</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <source>Intel Threading Building Blocks: Outfitting C++ for Multi-core Processor Parallelism</source>
        <year>2007</year>
        <publisher-loc>sebastopol</publisher-loc>
        <publisher-name>O’Reilly Media, Inc.</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dagum</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Menon</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Openmp: an industry standard api for shared-memory programming</article-title>
        <source>IEEE Comput Sci Eng</source>
        <year>1998</year>
        <volume>5</volume>
        <issue>1</issue>
        <fpage>46</fpage>
        <lpage>55</lpage>
        <pub-id pub-id-type="doi">10.1109/99.660313</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Luebke</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Cuda: Scalable parallel programming for high-performance scientific computing</article-title>
        <source>Biomedical Imaging: From Nano to Macro, 2008. ISBI 2008. 5th IEEE International Symposium On</source>
        <year>2008</year>
        <publisher-loc>Paris</publisher-loc>
        <publisher-name>IEEE</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weber</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Gothandaraman</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Hinde</surname>
            <given-names>RJ</given-names>
          </name>
          <name>
            <surname>Peterson</surname>
            <given-names>GD</given-names>
          </name>
        </person-group>
        <article-title>Comparing hardware accelerators in scientific applications: A case study</article-title>
        <source>IEEE Trans Parallel Distrib Syst</source>
        <year>2011</year>
        <volume>22</volume>
        <issue>1</issue>
        <fpage>58</fpage>
        <lpage>68</lpage>
        <pub-id pub-id-type="doi">10.1109/TPDS.2010.125</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Notredame</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Higgins</surname>
            <given-names>DG</given-names>
          </name>
          <name>
            <surname>Heringa</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>T-coffee: A novel method for fast and accurate multiple sequence alignment</article-title>
        <source>J Mol Biol</source>
        <year>2000</year>
        <volume>302</volume>
        <issue>1</issue>
        <fpage>205</fpage>
        <lpage>17</lpage>
        <pub-id pub-id-type="doi">10.1006/jmbi.2000.4042</pub-id>
        <?supplied-pmid 10964570?>
        <pub-id pub-id-type="pmid">10964570</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thompson</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>Higgins</surname>
            <given-names>DG</given-names>
          </name>
          <name>
            <surname>Gibson</surname>
            <given-names>TJ</given-names>
          </name>
        </person-group>
        <article-title>Clustal w: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice</article-title>
        <source>Nucleic Acids Res</source>
        <year>1994</year>
        <volume>22</volume>
        <issue>22</issue>
        <fpage>4673</fpage>
        <lpage>80</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/22.22.4673</pub-id>
        <?supplied-pmid 7984417?>
        <pub-id pub-id-type="pmid">7984417</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Cheetham</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Dehne</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Pitre</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Rau-Chaplin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Taillon</surname>
            <given-names>PJ</given-names>
          </name>
        </person-group>
        <article-title>Parallel clustal w for pc clusters</article-title>
        <source>Computational Science and ITS Applications - Iccsa 2003, International Conference, Montreal, Canada, May 18-21, 2003, Proceedings</source>
        <year>2003</year>
        <publisher-loc>Berlin</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>KB</given-names>
          </name>
        </person-group>
        <article-title>Clustalw-mpi: Clustalw analysis using distributed and parallel computing</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>12</issue>
        <fpage>1585</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btg192</pub-id>
        <?supplied-pmid 12912844?>
        <pub-id pub-id-type="pmid">12912844</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Maskell</surname>
            <given-names>DL</given-names>
          </name>
        </person-group>
        <article-title>Msa-cuda: multiple sequence alignment on graphics processing units with cuda</article-title>
        <source>2009 20th IEEE International Conference on Application-specific Systems, Architectures and Processors</source>
        <year>2009</year>
        <publisher-loc>Boston</publisher-loc>
        <publisher-name>IEEE</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Zhu</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Cuda-mafft: Accelerating mafft on cuda-enabled graphics hardware</article-title>
        <source>Bioinformatics and Biomedicine (BIBM), 2013 IEEE International Conference On</source>
        <year>2013</year>
        <publisher-loc>England</publisher-loc>
        <publisher-name>IEEE</publisher-name>
      </element-citation>
    </ref>
  </ref-list>
</back>
