<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-archivearticle1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3934876</article-id>
    <article-id pub-id-type="pmid">24586435</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-13-33044</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0088901</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v2">
        <subject>Biology</subject>
        <subj-group>
          <subject>Computational Biology</subject>
          <subj-group>
            <subject>Genomics</subject>
            <subj-group>
              <subject>Genome Analysis Tools</subject>
              <subject>Genome Sequencing</subject>
            </subj-group>
          </subj-group>
          <subj-group>
            <subject>Sequence Analysis</subject>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Proteomics</subject>
          <subj-group>
            <subject>Sequence Analysis</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v2">
        <subject>Computer Science</subject>
        <subj-group>
          <subject>Algorithms</subject>
        </subj-group>
        <subj-group>
          <subject>Computer Applications</subject>
          <subj-group>
            <subject>Computer-Aided Design</subject>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Computer Architecture</subject>
          <subj-group>
            <subject>Computer Hardware</subject>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Computer Modeling</subject>
        </subj-group>
        <subj-group>
          <subject>Computing Methods</subject>
          <subj-group>
            <subject>Computer Graphics</subject>
            <subject>Mathematical Computing</subject>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Programming Languages</subject>
        </subj-group>
        <subj-group>
          <subject>Software Engineering</subject>
          <subj-group>
            <subject>Computer Benchmarking</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v2">
        <subject>Engineering</subject>
        <subj-group>
          <subject>Human Factors Engineering</subject>
          <subj-group>
            <subject>Man Computer Interface</subject>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Software Engineering</subject>
          <subj-group>
            <subject>Computer Benchmarking</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v2">
        <subject>Mathematics</subject>
        <subj-group>
          <subject>Probability Theory</subject>
          <subj-group>
            <subject>Markov Model</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>QuickProbs—A Fast Multiple Sequence Alignment Algorithm Designed for Graphics Processors</article-title>
      <alt-title alt-title-type="running-head">QuickProbs</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Gudyś</surname>
          <given-names>Adam</given-names>
        </name>
        <xref ref-type="aff" rid="aff1"/>
        <xref ref-type="corresp" rid="cor1">
          <sup>*</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Deorowicz</surname>
          <given-names>Sebastian</given-names>
        </name>
        <xref ref-type="aff" rid="aff1"/>
      </contrib>
    </contrib-group>
    <aff id="aff1">
      <addr-line>Institute of Informatics, Faculty of Automatic Control, Electronics and Computer Science, Silesian University of Technology, Gliwice, Poland</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Guo</surname>
          <given-names>Jun-Tao</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>The University of North Carolina at Charlotte, United States of America</addr-line>
    </aff>
    <author-notes>
      <corresp id="cor1">* E-mail: <email>adam.gudys@polsl.pl</email></corresp>
      <fn fn-type="COI-statement">
        <p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p>
      </fn>
      <fn fn-type="con">
        <p>Conceived and designed the experiments: AG SD. Performed the experiments: AG. Analyzed the data: AG SD. Contributed reagents/materials/analysis tools: AG. Wrote the paper: AG SD. Designed the algorithm: AG SD. Implemented the algorithm: AG. Performed statistical analysis of the results: AG.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>25</day>
      <month>2</month>
      <year>2014</year>
    </pub-date>
    <volume>9</volume>
    <issue>2</issue>
    <elocation-id>e88901</elocation-id>
    <history>
      <date date-type="received">
        <day>12</day>
        <month>8</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>15</day>
        <month>1</month>
        <year>2014</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2014 Gudyś, Deorowicz</copyright-statement>
      <copyright-year>2014</copyright-year>
      <copyright-holder>Gudyś, Deorowicz</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are properly credited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>Multiple sequence alignment is a crucial task in a number of biological analyses like secondary structure prediction, domain searching, phylogeny, etc. MSAProbs is currently the most accurate alignment algorithm, but its effectiveness is obtained at the expense of computational time. In the paper we present QuickProbs, the variant of MSAProbs customised for graphics processors. We selected the two most time consuming stages of MSAProbs to be redesigned for GPU execution: the posterior matrices calculation and the consistency transformation. Experiments on three popular benchmarks (BAliBASE, PREFAB, OXBench-X) on quad-core PC equipped with high-end graphics card show QuickProbs to be 5.7 to 9.7 times faster than original CPU-parallel MSAProbs. Additional tests performed on several protein families from Pfam database give overall speed-up of 6.7. Compared to other algorithms like MAFFT, MUSCLE, or ClustalW, QuickProbs proved to be much more accurate at similar speed. Additionally we introduce a tuned variant of QuickProbs which is significantly more accurate on sets of distantly related sequences than MSAProbs without exceeding its computation time. The GPU part of QuickProbs was implemented in OpenCL, thus the package is suitable for graphics processors produced by all major vendors.</p>
    </abstract>
    <funding-group>
      <funding-statement>The work was supported by National Science Centre grant upon decision DEC-2012/05/N/ST6/03158 and European Social Fund project UDA-POKL.04.01.01-00-106/09. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
    </funding-group>
    <counts>
      <page-count count="18"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="s1">
    <title>Introduction</title>
    <p>Multiple sequence alignment (MSA) is an essential task in molecular biology. It is performed for both, nucleotide and protein sequences. Its field of applications covers phylogenetic analyses, gene finding, identification of functional domains, prediction of secondary structures, and many others. Rapidly increasing size of sequence databases allowed by the development of high throughput sequencing technologies provides biologists with the opportunity to analyse in silico enormous sets of data. Hence, the constant pressure for developing more accurate and faster MSA algorithms. As multiple sequence alignment problem is NP-hard <xref rid="pone.0088901-Wang1" ref-type="bibr">[1]</xref>, <xref rid="pone.0088901-Just1" ref-type="bibr">[2]</xref>, exact methods are infeasible for practical applications due to excessive computation time. Therefore, many heuristics have been developed including progressive <xref rid="pone.0088901-Feng1" ref-type="bibr">[3]</xref>, iterative <xref rid="pone.0088901-Barton1" ref-type="bibr">[4]</xref>, or hidden Markov model-based <xref rid="pone.0088901-Krogh1" ref-type="bibr">[5]</xref> strategies. One of the most popular multiple sequence alignment software is ClustalW <xref rid="pone.0088901-Thompson1" ref-type="bibr">[6]</xref>. It is a classic representative of progressive algorithms, and works according to the scheme:</p>
    <list list-type="order">
      <list-item>
        <p>Estimate evolutionary distances between all pairs of sequences.</p>
      </list-item>
      <list-item>
        <p>Build a guide tree on the basis of the distances.</p>
      </list-item>
      <list-item>
        <p>Align sequences in the order described by the tree.</p>
      </list-item>
    </list>
    <p>Calculation of an evolutionary distance is done either by performing pairwise sequence alignment between sequences (default mode) or by employing <inline-formula><inline-graphic xlink:href="pone.0088901.e001.jpg"/></inline-formula>-tuple matching (fast mode).</p>
    <p>Many researches aimed at refining ClustalW accuracy by extending the idea of progressive alignment. An important breakthrough was the introduction of T-Coffee algorithm <xref rid="pone.0088901-Notredame1" ref-type="bibr">[7]</xref> which incorporated a consistency-based objective function. The principle was employing knowledge of some symbols being aligned from all pairwise alignments and was confirmed to improve significantly quality of a final result. Other techniques acquired by MSA algorithms include identification of homologous regions using fast Fourier transform (MAFFT <xref rid="pone.0088901-Katoh1" ref-type="bibr">[8]</xref>) or iterative refinement of a final alignment (MUSCLE <xref rid="pone.0088901-Edgar1" ref-type="bibr">[9]</xref>). There is a group of methods that improved calculation of a pairwise alignment by using suboptimal alignments. These are Probcons <xref rid="pone.0088901-Do1" ref-type="bibr">[10]</xref> and Probalign <xref rid="pone.0088901-Roshan1" ref-type="bibr">[11]</xref> which compute posterior probability matrices for all pairs of sequences using pair hidden Markov models (pair-HMMs) and partition functions, respectively. Both of them are also equipped in a consistency scheme which makes them very accurate. Recently published MSAProbs algorithm combines pair-HMM and posterior function approaches with a consistency transformation and an iterative refinement leading to the highest quality amongst all presented packages <xref rid="pone.0088901-Liu1" ref-type="bibr">[12]</xref>. However, experiments show that even most accurate methods fail to find a proper alignment when analysed sequences are distantly related, particularly in so called ‘twilight zone’, when sequence similarity drops below 30%. Some algorithms addressed this issue by introducing to the alignment procedure additional knowledge. E.g., 3D-Coffee extends T-Coffee by using mixture of pairwise sequence and structure alignments <xref rid="pone.0088901-OSullivan1" ref-type="bibr">[13]</xref>. MSACompro introduces to MSAProbs pipeline secondary structures, residue-residue contact maps, and solvent accessibility which elevates accuracy <xref rid="pone.0088901-Deng1" ref-type="bibr">[14]</xref>.</p>
    <p>Our research, however, focuses on methods exploiting only sequences themselves. An important issue related to accurate MSA algorithms like T-Coffee, ProbCons, or MSAProbs is that superior results are produced at the cost of significant increase in complexity: all the above-mentioned methods are inferior to ClustalW in fast mode in terms of time and memory requirements. This is a serious disadvantage when processing large sequence sets, which is often the case, as it has been proven that introducing homologous sequences to MSA improves quality of a final result <xref rid="pone.0088901-Katoh2" ref-type="bibr">[15]</xref>. Moreover, there are applications which require huge number of multiple alignments to be computed. E.g., PhylomeDB database <xref rid="pone.0088901-HuertaCepas1" ref-type="bibr">[16]</xref> gathers currently almost 1.9 million of MSAs. As alignment times varied from several seconds to several minutes, computation of all alignments required tens of months of CPU time <xref rid="pone.0088901-CapellaGutierrez1" ref-type="bibr">[17]</xref>. Taking into account increasing availability of genomic and proteomic data, this number is expected to grow dramatically in close future. Hence, it is desirable to have algorithms able to align large sequence sets or perform large number of alignments in a reasonable time.</p>
    <p>For aforementioned reason, some algorithms aimed at improving alignment quality without sacrificing time and memory efficiency of ClustalW. These are for example Kalign <xref rid="pone.0088901-Katoh1" ref-type="bibr">[8]</xref> and Kalign2 <xref rid="pone.0088901-Lassmann2" ref-type="bibr">[19]</xref> which instead of <inline-formula><inline-graphic xlink:href="pone.0088901.e002.jpg"/></inline-formula>-tuple matches employ respectively, Wu-Manber <xref rid="pone.0088901-Wu1" ref-type="bibr">[20]</xref> and Muth-Manber <xref rid="pone.0088901-Muth1" ref-type="bibr">[21]</xref> approximate string matching algorithms. Kalign2 turns out to be faster and more memory efficient than ClustalW in fast mode and also significantly more accurate (not as accurate as consistency-based methods, though). Kalign-LCS <xref rid="pone.0088901-Deorowicz1" ref-type="bibr">[22]</xref> further improved alignment accuracy and execution time by exploiting a bit-parallel longest common subsequence measure for distance calculation. The new version of MAFFT introduces PartTree algorithm <xref rid="pone.0088901-Katoh3" ref-type="bibr">[23]</xref> which allows a guide tree to be constructed without calculating all pairwise distances. A similar strategy was acquired by the recently published algorithm Clustal<inline-formula><inline-graphic xlink:href="pone.0088901.e003.jpg"/></inline-formula>
<xref rid="pone.0088901-Sievers1" ref-type="bibr">[24]</xref> that joins HMMs with mBed <xref rid="pone.0088901-Blackshields1" ref-type="bibr">[25]</xref>, a method of dimensionality reduction called sequence embedding. As a result, the number of pairwise alignments in both these packages is decreased from <inline-formula><inline-graphic xlink:href="pone.0088901.e004.jpg"/></inline-formula> to <inline-formula><inline-graphic xlink:href="pone.0088901.e005.jpg"/></inline-formula> with respect to the number of sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e006.jpg"/></inline-formula>. This makes MAFFT and Clustal<inline-formula><inline-graphic xlink:href="pone.0088901.e007.jpg"/></inline-formula> the only methods which are able to align tens of thousands of sequences in a reasonable time.</p>
    <p>Nevertheless, experiments clearly show that if alignment quality is of paramount importance, consistency-based methods are out of competition. In order to overcome their greatest disadvantage, i.e., large execution times, many algorithms utilise multi-core architecture of modern CPUs. One of the best examples is MSAProbs which assessed on quad-core CPU turned out to be faster than its less accurate serial competitors like ProbCons or Probalign. Yet, parallelisation on central processors has its limitations. Nowadays, a typical desktop PC is equipped with four- or six-core CPU and to further decrease execution times, expensive multi-processor architectures have to be used. One of the ways of addressing this issue is using a potential of graphics processors in general purpose computing. Since computational power of current GPUs is more than order of magnitude greater than power of central processors, developing GPU-suited versions of algorithms has become popular in many computational demanding tasks also in bioinformatics. One must keep in mind, that differences in architectures of graphics processors and CPUs are fundamental. GPUs have thousands of cores, several types of memory and utilise massively parallel execution model. This makes designing algorithms customised for GPUs a challenging task that cannot be accomplished by adapting serial or parallel methods destined for CPU execution.</p>
    <p>Heretofore, GPU customisation of multiple sequence alignment algorithms concerned mainly ClustalW <xref rid="pone.0088901-Liu2" ref-type="bibr">[26]</xref>, <xref rid="pone.0088901-Liu3" ref-type="bibr">[27]</xref> and different variants of MSA problem like constrained MSA investigated by authors of this paper <xref rid="pone.0088901-Gudy1" ref-type="bibr">[28]</xref> or regular expression MSA <xref rid="pone.0088901-Lin1" ref-type="bibr">[29]</xref>. The only attempt to parallelise on graphics processor an accurate, consistency-based multiple sequence alignment method was G-MSA <xref rid="pone.0088901-Blazewicz1" ref-type="bibr">[30]</xref>, a variant of T-Coffee algorithm. The authors, however, focused on decreasing execution times and introduced some modifications that lowered quality of an output alignment. As a result, G-MSA turned out to be very fast (even 193 times faster than its predecessor), but inferior in terms of accuracy not only to original T-Coffee, but also to some non-consistency algorithms like MUSCLE. The aim of our research is different. We selected MSAProbs, the most accurate from existing MSA methods as our starting point and developed QuickProbs. It is a variant of MSAProbs algorithm suited for graphics processors preserving outstanding accuracy of its predecessor.</p>
    <p>The algorithm executes on GPU the most time consuming parts of MSAProbs pipeline, i.e., the posterior probability matrices calculation and the consistency transformation. These stages are parallelised in MSAProbs on CPU with a use of OpenMP <xref rid="pone.0088901-OpenMP1" ref-type="bibr">[31]</xref>. The parallelisation is, however, based on inter-task execution model which is unsuitable for graphics processors because of their massively parallel architecture. Therefore, GPU-specific algorithms for these stages had to be designed.</p>
    <p>The posterior calculation stage executes dynamic programming methods like <italic>forward-backward</italic> algorithm for pair-HMMs or partition function calculation. The dynamic programming (DP) was a subject of GPU customisation multiple times, also in bioinformatics. It concerned pairwise sequence alignment <xref rid="pone.0088901-Manavski1" ref-type="bibr">[32]</xref>–<xref rid="pone.0088901-Liu5" ref-type="bibr">[37]</xref>, short read alignment <xref rid="pone.0088901-Liu6" ref-type="bibr">[38]</xref>, RNA folding <xref rid="pone.0088901-Chang1" ref-type="bibr">[39]</xref>, phylogeny <xref rid="pone.0088901-Suchard1" ref-type="bibr">[40]</xref>, etc. Each application has some specific features that require suited algorithms, though. In MSAProbs these features include presence of several dependant DP layers, different storage patterns for different layers, a complex form of recursive expression making GPU code register-bound.</p>
    <p>The consistency transformation stage incorporates a set of sparse matrix multiplications. There are algorithms and libraries for this task <xref rid="pone.0088901-Demouth1" ref-type="bibr">[41]</xref>–<xref rid="pone.0088901-NVidia2" ref-type="bibr">[43]</xref>. The multiplication procedure exploited by MSAProbs has however some specific features. Firstly, many multiplications of small matrices is performed, while previously published solutions are optimised for large matrices. Secondly, the consistency transformation does not allow new elements to be introduced to output matrices. Due to these reasons existing methods cannot be used directly for our aims.</p>
    <p>QuickProbs uses new, graphics processor specific, intra-task parallel algorithms for both, posterior matrix calculation and consistency transformation. Additionally, we parallelised on CPU the alignment construction and refinement stage, which in MSAProbs is performed serially. As a result, our package is several times faster than MSAProbs. This allows user to process larger datasets in a reasonable time without sacrificing alignment quality. Additionally we present a tuned variant of method called QuickProbs-acc. It significantly outperforms MSAProbs in terms of accuracy on sets of distantly related sequences without exceeding its running times.</p>
  </sec>
  <sec sec-type="materials|methods" id="s2">
    <title>Materials and Methods</title>
    <sec id="s2a">
      <title>Problem formulation</title>
      <p>Let <inline-formula><inline-graphic xlink:href="pone.0088901.e008.jpg"/></inline-formula> be the set of input sequences. Multiple sequence alignment problem consists in arranging sequences from <inline-formula><inline-graphic xlink:href="pone.0088901.e009.jpg"/></inline-formula> by putting gaps between symbols in the way that homologous residues are aligned together in columns. Homologous residues are those which share three dimensional structural position and diverge from common ancestral residue <xref rid="pone.0088901-Durbin1" ref-type="bibr">[44]</xref>. The problem of MSA is that for majority of cases it is impossible to identify a single correct alignment. This is because both structures and sequences evolve and some residues cannot be superposed in any way. This must be taken into account when assessing multiple sequence alignment algorithms. Therefore, a subset of key residues and core structural blocks that can be unambiguously aligned is identified and used for evaluation. The most commonly used assessment measures calculated on these regions are sum-of-pairs (SP) and total-column (TC) scores <xref rid="pone.0088901-Thompson2" ref-type="bibr">[45]</xref>. They denote percentage of properly aligned residue pairs and columns, respectively, and a reference alignment is required to compute them. In the case of real sequences it is usually constructed manually. If testing sets are generated synthetically with a use of evolution modelling software like ROSE <xref rid="pone.0088901-Stoye1" ref-type="bibr">[46]</xref>, the reference alignment is built during artificial evolutionary process by the software itself.</p>
    </sec>
    <sec id="s2b">
      <title>General purpose computing on GPU</title>
      <p>Computational power of current graphics processors is several times greater than power of CPUs. Rapid development of programming interfaces like CUDA <xref rid="pone.0088901-NVidia3" ref-type="bibr">[47]</xref> or OpenCL <xref rid="pone.0088901-Khronos1" ref-type="bibr">[48]</xref> allows this power to be employed in general purpose computing. Due to this fact, designing algorithms customised for graphics processors has recently become an important method of speeding up analyses of large datasets as an alternative to using expensive multi-processor architectures based on CPUs. In QuickProbs, GPU computing is performed with a use of OpenCL library since, unlike CUDA, it is suitable for graphics processors produced by both major vendors, NVidia and AMD. Hence, in the following description we hold to the OpenCL nomenclature providing CUDA terms in parentheses.</p>
      <p>The reason why designing algorithms suited for GPU execution is a challenging task is a great difference between architectures of central and graphics processors. Unlike CPUs that contain few cores, modern GPUs are composed of thousands of <italic>processing elements</italic> (<italic>cores</italic>) gathered in several <italic>compute units</italic> (<italic>multiprocessors</italic>). Processing elements within compute units operate according to a single instruction-multiple data or single program-multiple data paradigm. From logical point of view a GPU program (known as a <italic>kernel</italic> in both OpenCL and CUDA) consists of many <italic>work-items</italic> (<italic>threads</italic>) gathered in <italic>workgroups</italic> (<italic>blocks</italic>). An important fact is that synchronisation between work-items can be done only within a workgroup. Thus, matching the number and the size of workgroups for a particular task is a crucial issue when developing GPU-suited algorithms. After execution of a kernel, a hardware <italic>scheduler</italic> maps work-items in the way that a workgroup is executed on a single compute unit, while one unit can handle multiple workgroups. OpenCL does not specify how workgroups are run by hardware but in order to efficiently utilise computational power of GPU, knowledge of workgroup execution at the device level is necessary. The smallest amount of work that is physically performed on AMD GPUs consists of 64 work-items and is called a <italic>wavefront</italic>; on NVidia devices it has 32 items and is known as a <italic>warp</italic>. Therefore, it is important to make the group size multiplicity of these portions. There is no guarantee in which order wavefronts (warps) are executed—this is decided by the scheduler dynamically. An important consideration is that all work-items within that portion must share exactly the same execution path. A divergence in a wavefront (warp) caused, e.g., by the presence of conditional statements is realised by executing instructions from all paths with some work-items being masked when necessary. Hence, data dependant branching inside wavefronts (warps) increases kernel execution time and should be avoided. Another important issue when developing algorithms on GPU is providing sufficient <italic>occupancy</italic> of a device. In order to hide delays of arithmetic instructions and, most importantly, memory accesses it is recommended to invoke a few times more work-items than the number of processing elements. On modern devices this results in as much as 10<sup>4</sup> work-items per kernel.</p>
      <p>An important difference between CPU and GPU concerns memory architecture. GPU is equipped with few gigabytes of <italic>global memory</italic> which is an equivalent of main memory at CPU. Maximal throughput of global memory is several times greater than main memory bandwidth. However, it can be achieved only in the case of coalesced accesses when consecutive work-items utilise data from contiguous 128-byte area. In such situation whole portion of data can be read in one transaction. Since latency of global memory is large, non-coalesced accesses often result in lower bandwidth than at CPU. This issue has been partially solved in recent graphics processors by caching. Nevertheless, compared to CPUs which have several megabytes of cache per core, amount of cache on GPU is much smaller—hundreds of bytes per processing element. Another limitation concerning global addressing space is lack of virtual memory on GPU: programmer is responsible for fitting all necessary data in a limited storage area. Each compute unit contains additional amount (tens of kilobytes) of fast, directly addressable <italic>local memory</italic> (<italic>shared memory</italic>) which can be used for buffering frequently accessed data. Graphics processors contain much more registers than CPUs (tens of thousands per compute unit). The size of local memory and the number of registers allocated by work-items are important for execution time as they affect the maximum size of workgroup as well as GPU occupancy.</p>
      <p>Concluding, graphics processor execution model differs significantly from CPU. Presence of thousands of cores at GPU device requires fine-grained algorithm parallelisation. Programmer needs to take care of coalesced accesses to global memory to maximise throughput. Careful use of local memory and registers is necessary to keep GPU occupancy at desired level. Finally, calculations should be organised in the way, that eliminates branching within the same wavefront (warp). As a result, algorithms destined for graphics processors often use different data structures and computation schemes than methods suited for central processors, even those exploiting multi-core architectures. Due to this fact algorithms for GPUs must be designed and implemented from the scratch rather than be adopted from CPU.</p>
    </sec>
    <sec id="s2c">
      <title>MSAProbs algorithm principals</title>
      <p>MSAProbs is currently the most accurate multiple sequence alignment software. It is a progressive strategy based on the following stages:</p>
      <p>I. Calculation of posterior probability matrices and distances for all pairs of sequences.</p>
      <p>II. Construction of a guide tree upon distances and calculation of sequence weights.</p>
      <p>III. Performing weighted consistency transformation on all posterior matrices.</p>
      <p>IV. Building final alignment using the guide tree and posterior matrices followed by the iterative refinement.</p>
      <p>The algorithm scheme can be found on <xref ref-type="fig" rid="pone-0088901-g001">Figure 1</xref>. Stages I and IV were divided in the diagram into two sub-stages in order to present data dependencies. At the beginning, the algorithm computes posterior probability matrices (stage I.a) which contain detailed information of residue alignments for all sequence pairs and are used for distances calculation (stage I.b). Many progressive algorithms estimate distance between two sequences on the basis of a maximum probability alignment computed with Viterbi algorithm <xref rid="pone.0088901-Viterbi1" ref-type="bibr">[49]</xref>. The main disadvantage of this approach is that it takes into account only one possible alignment of the sequences, thus it is error-prone. In contrast, MSAProbs computes for each pair of sequences a posterior probability matrix which is further used for calculation of a maximum expected accuracy alignment <xref rid="pone.0088901-Durbin1" ref-type="bibr">[44]</xref>. As it takes advantage of suboptimal alignments, it improves quality of results. As in all progressive methods, distances are required for guide tree construction (stage II). This is done with a variant of UPGMA algorithm <xref rid="pone.0088901-Sneath1" ref-type="bibr">[50]</xref>. Before MSAProbs constructs a final alignment it performs so called consistency transformation (stage III). Single posterior matrix computed in stage I contains information only from pairwise alignments of two sequences, which may cause errors in the result if some residues are aligned improperly. The consistency transformation relaxes posterior matrices over other sequences. Thanks to this, matrices contain information of residue alignment from pairwise alignments of all sequences. This reduces the probability of misaligning some symbols during construction of the final result. Number of consistency iterations is one of the algorithm parameters. Afterwards, sequences are aligned greedily in the order described by the tree (stage IV.a). At each tree node, a profile-profile alignment is performed with a use of relaxed posterior matrices calculated previously. When the alignment is constructed, the refinement stage begins (stage IV.b). It randomly splits the alignment horizontally and realigns resulting profiles. Thanks to this, the algorithm is able to remove some errors introduced in previous stages. The number of refinement iterations is also a parameter. Summing up, MSAProbs has three features crucial for its accuracy:</p>
      <fig id="pone-0088901-g001" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.g001</object-id>
        <label>Figure 1</label>
        <caption>
          <title>MSAProbs algorithm computation scheme.</title>
          <p>Stages denoted with (*) are run in parallel with a use of OpenMP.</p>
        </caption>
        <graphic xlink:href="pone.0088901.g001"/>
      </fig>
      <list list-type="bullet">
        <list-item>
          <p>exploiting maximum accuracy criterion during pairwise alignments,</p>
        </list-item>
        <list-item>
          <p>relaxing posterior matrices over other sequences,</p>
        </list-item>
        <list-item>
          <p>performing the iterative refinement.</p>
        </list-item>
      </list>
      <p>First two methods decrease probability of misaligning given pair of residues by utilising information from suboptimal pairwise alignments and alignments of other sequences. If misalignment occurs, third feature gives the opportunity to correct it.</p>
      <p>Predominance of MSAProbs over previously published methods is obtained at the cost of computation time. The most time consuming stages are those performed for all pairs of sequences, that is the posterior matrix calculation (I) and the consistency transformation (III). The worst-case time complexities of these stages are <inline-formula><inline-graphic xlink:href="pone.0088901.e010.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e011.jpg"/></inline-formula>, respectively, for sequences of length <inline-formula><inline-graphic xlink:href="pone.0088901.e012.jpg"/></inline-formula>. In order to decrease computation time, those operations were chosen in MSAProbs to be parallelised using OpenMP. Following subsections describe all MSAProbs stages with a special stress put on stages I, III, and IV which were redesigned in QuickProbs.</p>
      <p><bold>Posterior matrix calculation.</bold> This stage of MSAProbs consists of calculating set of posterior probability matrices for all pairs of sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e013.jpg"/></inline-formula>, where ‘&lt;’ indicates an ordering relation of sequences within <inline-formula><inline-graphic xlink:href="pone.0088901.e014.jpg"/></inline-formula>. Let <inline-formula><inline-graphic xlink:href="pone.0088901.e015.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e016.jpg"/></inline-formula> denote <inline-formula><inline-graphic xlink:href="pone.0088901.e017.jpg"/></inline-formula>'th and <inline-formula><inline-graphic xlink:href="pone.0088901.e018.jpg"/></inline-formula>'th symbols of <inline-formula><inline-graphic xlink:href="pone.0088901.e019.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e020.jpg"/></inline-formula> sequences, respectively. Elements of posterior probability matrix <inline-formula><inline-graphic xlink:href="pone.0088901.e021.jpg"/></inline-formula> express <inline-formula><inline-graphic xlink:href="pone.0088901.e022.jpg"/></inline-formula>, that is a probability of symbols <inline-formula><inline-graphic xlink:href="pone.0088901.e023.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e024.jpg"/></inline-formula> being aligned in the true alignment of <inline-formula><inline-graphic xlink:href="pone.0088901.e025.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e026.jpg"/></inline-formula>. In MSAProbs, <inline-formula><inline-graphic xlink:href="pone.0088901.e027.jpg"/></inline-formula> elements are root mean squares (RMS) of posterior probabilities calculated using pair hidden Markov models (<inline-formula><inline-graphic xlink:href="pone.0088901.e028.jpg"/></inline-formula>) and partition function (<inline-formula><inline-graphic xlink:href="pone.0088901.e029.jpg"/></inline-formula>): <disp-formula id="pone.0088901.e030"><graphic xlink:href="pone.0088901.e030.jpg" position="anchor" orientation="portrait"/><label>(1)</label></disp-formula>
</p>
      <p>After posterior matrix computation, the Needleman-Wunsch algorithm <xref rid="pone.0088901-Needleman1" ref-type="bibr">[51]</xref> with no gap penalties is applied on <inline-formula><inline-graphic xlink:href="pone.0088901.e031.jpg"/></inline-formula> in order to determine distance <inline-formula><inline-graphic xlink:href="pone.0088901.e032.jpg"/></inline-formula> between sequences. As majority of <inline-formula><inline-graphic xlink:href="pone.0088901.e033.jpg"/></inline-formula> elements are close to 0, in order to save space and accelerate the consistency transformation, posterior matrices are translated to a sparse form by filtering out all elements less than <inline-formula><inline-graphic xlink:href="pone.0088901.e034.jpg"/></inline-formula>. For convenience, sparse representation of <inline-formula><inline-graphic xlink:href="pone.0088901.e035.jpg"/></inline-formula> matrix will be referred to as <inline-formula><inline-graphic xlink:href="pone.0088901.e036.jpg"/></inline-formula>. Let us denote the calculation of particular <inline-formula><inline-graphic xlink:href="pone.0088901.e037.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e038.jpg"/></inline-formula> as a posterior task, resulting in <inline-formula><inline-graphic xlink:href="pone.0088901.e039.jpg"/></inline-formula> tasks to be processed. Parallelism of posterior stage in MSAProbs is provided by distributing tasks among several OpenMP threads. As each thread calculates one or more tasks, this parallelisation model can be referred to as <italic>inter-task</italic>.</p>
      <p><bold>Tree construction and sequence weighting.</bold> The guide tree construction in MSAProbs is performed with a use of UPGMA algorithm. After that sequences are weighted in the order described by the tree using ClustalW weighting scheme. The weight of sequence <inline-formula><inline-graphic xlink:href="pone.0088901.e040.jpg"/></inline-formula> will be denoted as <inline-formula><inline-graphic xlink:href="pone.0088901.e041.jpg"/></inline-formula>.</p>
      <p><bold>Consistency transformation.</bold> The consistency transformation stage in MSAProbs relies in relaxing all posterior matrices calculated in stage I over sequences from <inline-formula><inline-graphic xlink:href="pone.0088901.e042.jpg"/></inline-formula>. The transformation is repeated <inline-formula><inline-graphic xlink:href="pone.0088901.e043.jpg"/></inline-formula> times (2 by default). The procedure of updating <inline-formula><inline-graphic xlink:href="pone.0088901.e044.jpg"/></inline-formula> matrix will be referred to as a relaxation task and requires a set of <inline-formula><inline-graphic xlink:href="pone.0088901.e045.jpg"/></inline-formula> sparse-sparse matrix multiplications. It is done according to the formula: <disp-formula id="pone.0088901.e046"><graphic xlink:href="pone.0088901.e046.jpg" position="anchor" orientation="portrait"/><label>(2)</label></disp-formula>
</p>
      <p>An important note is that MSAProbs does not allow any new elements to be introduced to <inline-formula><inline-graphic xlink:href="pone.0088901.e047.jpg"/></inline-formula> matrix. More precisely, it may happen, that in a row of <inline-formula><inline-graphic xlink:href="pone.0088901.e048.jpg"/></inline-formula> an element appears such that there is no element with the same column number in a corresponding row of <inline-formula><inline-graphic xlink:href="pone.0088901.e049.jpg"/></inline-formula>. Such elements are filtered out from <inline-formula><inline-graphic xlink:href="pone.0088901.e050.jpg"/></inline-formula> after multiplication. Moreover, the elements with values below <inline-formula><inline-graphic xlink:href="pone.0088901.e051.jpg"/></inline-formula> are dropped. As a result <inline-formula><inline-graphic xlink:href="pone.0088901.e052.jpg"/></inline-formula> always has less or equal number of elements than <inline-formula><inline-graphic xlink:href="pone.0088901.e053.jpg"/></inline-formula>. MSAProbs performs consistency for <inline-formula><inline-graphic xlink:href="pone.0088901.e054.jpg"/></inline-formula> matrices such that <inline-formula><inline-graphic xlink:href="pone.0088901.e055.jpg"/></inline-formula>, i.e., the input and output of the relaxation procedure is only an upper triangle of a matrix table. As a consequence, the algorithm chooses one of the three versions of multiplication procedure depending on the ordering of <inline-formula><inline-graphic xlink:href="pone.0088901.e056.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e057.jpg"/></inline-formula>, and <inline-formula><inline-graphic xlink:href="pone.0088901.e058.jpg"/></inline-formula> sequences, i.e., <inline-formula><inline-graphic xlink:href="pone.0088901.e059.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e060.jpg"/></inline-formula>, and <inline-formula><inline-graphic xlink:href="pone.0088901.e061.jpg"/></inline-formula>. Matrices that are being relaxed are temporarily stored in the dense form <inline-formula><inline-graphic xlink:href="pone.0088901.e062.jpg"/></inline-formula> and translated back to the sparse representation <inline-formula><inline-graphic xlink:href="pone.0088901.e063.jpg"/></inline-formula> at the end of the task. After all of the tasks finish, <inline-formula><inline-graphic xlink:href="pone.0088901.e064.jpg"/></inline-formula> matrices are replaced by <inline-formula><inline-graphic xlink:href="pone.0088901.e065.jpg"/></inline-formula>. Parallelism in the consistency transformation is provided, similarly to stage I, by inter-task execution: an OpenMP thread is responsible for relaxation of one or more <inline-formula><inline-graphic xlink:href="pone.0088901.e066.jpg"/></inline-formula> matrices. The posterior matrices after performing <inline-formula><inline-graphic xlink:href="pone.0088901.e067.jpg"/></inline-formula> consistency transformations will be referred to as <inline-formula><inline-graphic xlink:href="pone.0088901.e068.jpg"/></inline-formula> (on <xref ref-type="fig" rid="pone-0088901-g001">Figure 1</xref> we neglect the fact that matrices are stored in the sparse form, thus <inline-formula><inline-graphic xlink:href="pone.0088901.e069.jpg"/></inline-formula> symbol is used).</p>
      <p><bold>Final alignment construction and refinement.</bold> The last stage of all progressive methods is the computation of final alignment according to the guide tree constructed during stage II. At each tree node a weighted profile-profile alignment (referred to as a progressive step) is performed. When aligning two profiles <inline-formula><inline-graphic xlink:href="pone.0088901.e070.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e071.jpg"/></inline-formula> posterior probability matrix <inline-formula><inline-graphic xlink:href="pone.0088901.e072.jpg"/></inline-formula> is calculated using <inline-formula><inline-graphic xlink:href="pone.0088901.e073.jpg"/></inline-formula> matrices for all pairs of sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e074.jpg"/></inline-formula> such that <inline-formula><inline-graphic xlink:href="pone.0088901.e075.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e076.jpg"/></inline-formula>. Then, the profile-profile alignment is constructed with a use of posterior probabilities <inline-formula><inline-graphic xlink:href="pone.0088901.e077.jpg"/></inline-formula> of aligning <inline-formula><inline-graphic xlink:href="pone.0088901.e078.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e079.jpg"/></inline-formula> profile residues. This is done according to the following dynamic programming recursion: <disp-formula id="pone.0088901.e080"><graphic xlink:href="pone.0088901.e080.jpg" position="anchor" orientation="portrait"/><label>(3)</label></disp-formula>
</p>
      <p>Calculation of the final alignment is followed by the refinement, one of the classic techniques of progressive methods. In MSAProbs it is called a post-processing stage. It was designed as a solution for one of the greatest problems of progressive strategies—wrong choice of sequences or profiles to be aligned in early steps of the final result construction. Such misalignments cannot be corrected in the following progressive steps and affect overall accuracy of the method. The refinement tries to solve this problem by splitting final alignment horizontally into two random profiles. Then, the columns containing only gaps are removed and the profiles are realigned in the same way as in the final alignment stage. The aforementioned procedure is repeated <inline-formula><inline-graphic xlink:href="pone.0088901.e081.jpg"/></inline-formula> times (10 by default). The more refinement iterations, the greatest the chance of removing errors introduced during progressive construction.</p>
      <p>In MSAProbs the final alignment and refinement procedures are executed serially.</p>
    </sec>
    <sec id="s2d">
      <title>QuickProbs algorithm</title>
      <p>The main goal of our study was to speed up the most time-consuming stages of MSAProbs (posterior matrices calculation and consistency transformation) by redesigning them for GPU execution using OpenCL. Additionally, we decided to parallelise on CPU the last stage of MSAProbs algorithm which previously was implemented in a serial manner. This is because the construction and refinement of final alignment, if executed serially, would be the most time consuming part of QuickProbs. In the following subsections we present how stages I, III, and IV were modified in QuickProbs. The separate subsection is devoted to QuickProbs-acc, a specialised variant of our package which aims at improving MSAProbs quality.</p>
      <p><bold>Posterior matrix calculation.</bold> The posterior matrix calculation in QuickProbs is, similarly to MSAProbs, based on tasks. However, massively parallel architecture of graphics processors requires smaller portions of work to be done by a work-item. Therefore, it was assumed that each task is processed by a single workgroup. That computation scheme can be denoted as <italic>intra-task</italic> parallelisation (one task—many work-items). As work-items within workgroup can synchronise and exchange data through local memory, they are able to properly handle data dependencies present in a task. Another important difference is that modifications made in QuickProbs algorithm at the consistency stage result in the necessity of calculating <inline-formula><inline-graphic xlink:href="pone.0088901.e082.jpg"/></inline-formula> for all <inline-formula><inline-graphic xlink:href="pone.0088901.e083.jpg"/></inline-formula>, not only <inline-formula><inline-graphic xlink:href="pone.0088901.e084.jpg"/></inline-formula>. As <inline-formula><inline-graphic xlink:href="pone.0088901.e085.jpg"/></inline-formula>, it is sufficient to calculate in the dense form only one of these two matrices (either <inline-formula><inline-graphic xlink:href="pone.0088901.e086.jpg"/></inline-formula> or <inline-formula><inline-graphic xlink:href="pone.0088901.e087.jpg"/></inline-formula>) and then transform it to both <inline-formula><inline-graphic xlink:href="pone.0088901.e088.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e089.jpg"/></inline-formula>. Therefore, QuickProbs posterior task takes as an input two sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e090.jpg"/></inline-formula> and consists of three steps:</p>
      <list list-type="order">
        <list-item>
          <p>calculate dense posterior matrix <inline-formula><inline-graphic xlink:href="pone.0088901.e091.jpg"/></inline-formula> (or <inline-formula><inline-graphic xlink:href="pone.0088901.e092.jpg"/></inline-formula>, depending on sequence lengths) and pairwise distance <inline-formula><inline-graphic xlink:href="pone.0088901.e093.jpg"/></inline-formula>,</p>
        </list-item>
        <list-item>
          <p>build sparse matrix <inline-formula><inline-graphic xlink:href="pone.0088901.e094.jpg"/></inline-formula> on the basis of <inline-formula><inline-graphic xlink:href="pone.0088901.e095.jpg"/></inline-formula> (<inline-formula><inline-graphic xlink:href="pone.0088901.e096.jpg"/></inline-formula>),</p>
        </list-item>
        <list-item>
          <p>build sparse transposed matrix <inline-formula><inline-graphic xlink:href="pone.0088901.e097.jpg"/></inline-formula> on the basis of <inline-formula><inline-graphic xlink:href="pone.0088901.e098.jpg"/></inline-formula> (<inline-formula><inline-graphic xlink:href="pone.0088901.e099.jpg"/></inline-formula>).</p>
        </list-item>
      </list>
      <p>Let <inline-formula><inline-graphic xlink:href="pone.0088901.e100.jpg"/></inline-formula> indicate the length of sequence <inline-formula><inline-graphic xlink:href="pone.0088901.e101.jpg"/></inline-formula> increased by 1. Size of <inline-formula><inline-graphic xlink:href="pone.0088901.e102.jpg"/></inline-formula> posterior matrix is <inline-formula><inline-graphic xlink:href="pone.0088901.e103.jpg"/></inline-formula> (sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e104.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e105.jpg"/></inline-formula> correspond to vertical and horizontal dimensions, respectively). QuickProbs parallelisation scheme assumes that each work-item in a workgroup calculates a single column of posterior matrix. Thus, the width <inline-formula><inline-graphic xlink:href="pone.0088901.e106.jpg"/></inline-formula> of <inline-formula><inline-graphic xlink:href="pone.0088901.e107.jpg"/></inline-formula> matrix that can be processed on GPU is limited by the maximum number of work-items in a workgroup <inline-formula><inline-graphic xlink:href="pone.0088901.e108.jpg"/></inline-formula> for a particular device. In current graphics processors like Radeon 7970 or GeForce 680 this limit is 1024 which is sufficient for majority of multiple sequence alignment problems. If <inline-formula><inline-graphic xlink:href="pone.0088901.e109.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e110.jpg"/></inline-formula>, the algorithm calculates <inline-formula><inline-graphic xlink:href="pone.0088901.e111.jpg"/></inline-formula> matrix instead of <inline-formula><inline-graphic xlink:href="pone.0088901.e112.jpg"/></inline-formula>. However, if <inline-formula><inline-graphic xlink:href="pone.0088901.e113.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e114.jpg"/></inline-formula>, the task cannot be calculated at GPU and is scheduled for CPU execution.</p>
      <p>At the beginning of posterior calculation stage, descriptions of all posterior tasks are prepared. As each task consists in computing two sparse matrices <inline-formula><inline-graphic xlink:href="pone.0088901.e115.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e116.jpg"/></inline-formula>, there are <inline-formula><inline-graphic xlink:href="pone.0088901.e117.jpg"/></inline-formula> tasks in total. The orientation of a dense posterior matrix to be calculated by a task depends on lengths of sequences. Namely, the shorter sequence corresponds to the horizontal dimension (task width) and the longer to the vertical dimension (task height). Tasks of width exceeding <inline-formula><inline-graphic xlink:href="pone.0088901.e118.jpg"/></inline-formula> are scheduled for CPU execution. The rest is processed at GPU in batches. An important feature is that workgroups from different batches are scheduled independently. Therefore, workgroup resources, i.e., the number of work-items and the amount of local memory to be reserved are determined by the task with the largest horizontal dimension. Thus, the smaller divergence of task widths in a batch, the less GPU resources are wasted. Generally, the number of tasks in a batch is limited by the size of global memory available for a particular device <inline-formula><inline-graphic xlink:href="pone.0088901.e119.jpg"/></inline-formula> (detailed description of task memory requirements is given later). Nevertheless, in order to produce smaller and less divergent batches, we lowered global memory limit to <inline-formula><inline-graphic xlink:href="pone.0088901.e120.jpg"/></inline-formula> which produced best results in our preliminary experiments. Tasks are sorted in a descending order according to the width. Then, consecutive tasks are added to the current batch as long as its global memory requirement does not exceed <inline-formula><inline-graphic xlink:href="pone.0088901.e121.jpg"/></inline-formula>. If that happens, a new batch is created and procedure repeats until no task remains. Finally, to reduce width divergence in batches and improve GPU utilisation, QuickProbs transposes all tasks in a batch with heights smaller than the number of work-items in the workgroup (it does not affect required number of work-items but decreases columns length).</p>
      <p>Step (1) of the posterior task consists in computation of matrix <inline-formula><inline-graphic xlink:href="pone.0088901.e122.jpg"/></inline-formula> as a root mean square of <inline-formula><inline-graphic xlink:href="pone.0088901.e123.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e124.jpg"/></inline-formula> matrices. Pair-HMM calculates posterior probability matrix <inline-formula><inline-graphic xlink:href="pone.0088901.e125.jpg"/></inline-formula> using <italic>forward-backward</italic> algorithm <xref rid="pone.0088901-Durbin1" ref-type="bibr">[44]</xref>. The procedure consists of two dynamic programming passes. They calculate matrices of forward and backward probabilities which are afterwards combined to form <inline-formula><inline-graphic xlink:href="pone.0088901.e126.jpg"/></inline-formula>. <inline-formula><inline-graphic xlink:href="pone.0088901.e127.jpg"/></inline-formula> is calculated using values of partition functions of forward and reverse <inline-formula><inline-graphic xlink:href="pone.0088901.e128.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e129.jpg"/></inline-formula> alignments as in <xref rid="pone.0088901-Roshan1" ref-type="bibr">[11]</xref>. The procedure, analogously to pair-HMM, requires two dynamic programming passes. At the end of step (1) <inline-formula><inline-graphic xlink:href="pone.0088901.e130.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e131.jpg"/></inline-formula> are joined to form <inline-formula><inline-graphic xlink:href="pone.0088901.e132.jpg"/></inline-formula> and an additional DP pass calculates pairwise distance <inline-formula><inline-graphic xlink:href="pone.0088901.e133.jpg"/></inline-formula> from <inline-formula><inline-graphic xlink:href="pone.0088901.e134.jpg"/></inline-formula>. In general, dependencies in the DP matrices in the above-mentioned procedures are <disp-formula id="pone.0088901.e135"><graphic xlink:href="pone.0088901.e135.jpg" position="anchor" orientation="portrait"/><label>(4)</label></disp-formula>
</p>
      <p>and <disp-formula id="pone.0088901.e136"><graphic xlink:href="pone.0088901.e136.jpg" position="anchor" orientation="portrait"/><label>(5)</label></disp-formula>
</p>
      <p>for forward and reverse passes, respectively, with different <inline-formula><inline-graphic xlink:href="pone.0088901.e137.jpg"/></inline-formula> functions. The more detailed information about forms of a dynamic programming recursions used in <inline-formula><inline-graphic xlink:href="pone.0088901.e138.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e139.jpg"/></inline-formula> calculations is presented in <xref ref-type="table" rid="pone-0088901-t001">Table 1</xref>. According to QuickProbs parallelisation scheme, each work-item within a workgroup calculates a single column of posterior matrix. Therefore, dynamic programming procedure must be executed according to an anti-diagonal pattern as presented in <xref ref-type="fig" rid="pone-0088901-g002">Figure 2</xref>. The whole matrix is processed in <inline-formula><inline-graphic xlink:href="pone.0088901.e140.jpg"/></inline-formula> iterations in the way that <inline-formula><inline-graphic xlink:href="pone.0088901.e141.jpg"/></inline-formula>'th thread idles for <inline-formula><inline-graphic xlink:href="pone.0088901.e142.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e143.jpg"/></inline-formula> first iterations in forward and reverse passes, respectively. The idea of the dynamic programming computation scheme exploited by QuickProbs is presented in <xref ref-type="table" rid="pone-0088901-t002">Table 2</xref>.</p>
      <fig id="pone-0088901-g002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.g002</object-id>
        <label>Figure 2</label>
        <caption>
          <title>Scheme of traversing dynamic programming matrices in forward (a) and reverse (b) passes.</title>
          <p>Cells contain numbers of iterations in which they are processed.</p>
        </caption>
        <graphic xlink:href="pone.0088901.g002"/>
      </fig>
      <table-wrap id="pone-0088901-t001" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t001</object-id>
        <label>Table 1</label>
        <caption>
          <title>Algorithm 1.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t001-1" xlink:href="pone.0088901.t001"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">
                  <bold>Input:</bold>
                </td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0088901.e144.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e145.jpg"/></inline-formula>—sequences for which posterior matrix is to be calculated, <inline-formula><inline-graphic xlink:href="pone.0088901.e146.jpg"/></inline-formula>—work-item identifier (column number).</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">
                  <bold>Output:</bold>
                </td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0088901.e147.jpg"/></inline-formula>—distance between <inline-formula><inline-graphic xlink:href="pone.0088901.e148.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e149.jpg"/></inline-formula> sequences, <inline-formula><inline-graphic xlink:href="pone.0088901.e150.jpg"/></inline-formula>—output posterior matrix in the dense form.</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">1:</td>
                <td align="left" rowspan="1" colspan="1">Initialise auxiliary matrices <inline-formula><inline-graphic xlink:href="pone.0088901.e151.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e152.jpg"/></inline-formula> of size <inline-formula><inline-graphic xlink:href="pone.0088901.e153.jpg"/></inline-formula>.</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">2:</td>
                <td align="left" rowspan="1" colspan="1">Posterior function forward pass: <inline-formula><inline-graphic xlink:href="pone.0088901.e154.jpg"/></inline-formula>
</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">3:</td>
                <td align="left" rowspan="1" colspan="1">Posterior function reverse pass: <inline-formula><inline-graphic xlink:href="pone.0088901.e155.jpg"/></inline-formula>
</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">4:</td>
                <td align="left" rowspan="1" colspan="1">Combine forward and reverse matrices: <inline-formula><inline-graphic xlink:href="pone.0088901.e156.jpg"/></inline-formula>
</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">5:</td>
                <td align="left" rowspan="1" colspan="1">Pair-HMM forward pass: <inline-formula><inline-graphic xlink:href="pone.0088901.e157.jpg"/></inline-formula>
</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">6:</td>
                <td align="left" rowspan="1" colspan="1">Pair-HMM backward pass: <inline-formula><inline-graphic xlink:href="pone.0088901.e158.jpg"/></inline-formula>
</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">7:</td>
                <td align="left" rowspan="1" colspan="1">Combine forward and backward matrices: <inline-formula><inline-graphic xlink:href="pone.0088901.e159.jpg"/></inline-formula>
</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">8:</td>
                <td align="left" rowspan="1" colspan="1">Calculate final posterior matrix: <inline-formula><inline-graphic xlink:href="pone.0088901.e160.jpg"/></inline-formula>
</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">9:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e161.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">10:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e162.jpg"/>
                  </inline-formula>
                </td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt101">
            <label/>
            <p>Pseudo-code of the posterior matrix calculation procedure. Statements show only general form of data dependencies. Procedure requires execution of 6 anti-diagonal passes (lines 2, <inline-formula><inline-graphic xlink:href="pone.0088901.e163.jpg"/></inline-formula>, 5, 6, 7, and <inline-formula><inline-graphic xlink:href="pone.0088901.e164.jpg"/></inline-formula>). <inline-formula><inline-graphic xlink:href="pone.0088901.e165.jpg"/></inline-formula> is computed first due to greater memory requirements.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="pone-0088901-t002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t002</object-id>
        <label>Table 2</label>
        <caption>
          <title>Algorithm 2.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t002-2" xlink:href="pone.0088901.t002"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">
                  <bold>Input:</bold>
                </td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0088901.e166.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e167.jpg"/></inline-formula>—input sequences, <inline-formula><inline-graphic xlink:href="pone.0088901.e168.jpg"/></inline-formula>—work-item identifier (column number).</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">
                  <bold>Output:</bold>
                </td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0088901.e169.jpg"/></inline-formula>—matrix to be calculated.</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">1:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>function</bold>
                  <sc>forward</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">2:</td>
                <td align="left" rowspan="1" colspan="1">Initialise <inline-formula><inline-graphic xlink:href="pone.0088901.e170.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e171.jpg"/></inline-formula>
</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">3:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>for</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e172.jpg"/>
                  </inline-formula>
                  <bold>do</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">4:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e173.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">5:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>if</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e174.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">6:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e175.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">7:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end if</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">8:</td>
                <td align="left" rowspan="1" colspan="1">
                  <sc>synchronise</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">9:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">10:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>return</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e176.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">11:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end function</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">12:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>function</bold>
                  <sc>reverse</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">13:</td>
                <td align="left" rowspan="1" colspan="1">Initialise <inline-formula><inline-graphic xlink:href="pone.0088901.e177.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e178.jpg"/></inline-formula>
</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">14:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>for </bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e179.jpg"/>
                  </inline-formula>
                  <bold>do</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">15:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e180.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">16:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>if</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e181.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">17:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e182.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">18:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end if</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">19:</td>
                <td align="left" rowspan="1" colspan="1">
                  <sc>synchronise</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">20:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">21:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>return</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e183.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">22:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end function</bold>
                </td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt102">
            <label/>
            <p>Pseudo-code of the generalised dynamic programming forward and reversed passes. <inline-formula><inline-graphic xlink:href="pone.0088901.e184.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e185.jpg"/></inline-formula> indicate <inline-formula><inline-graphic xlink:href="pone.0088901.e186.jpg"/></inline-formula>'th row and <inline-formula><inline-graphic xlink:href="pone.0088901.e187.jpg"/></inline-formula>'th column of <inline-formula><inline-graphic xlink:href="pone.0088901.e188.jpg"/></inline-formula> matrix.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>Note, that all intermediate matrices needed for <inline-formula><inline-graphic xlink:href="pone.0088901.e189.jpg"/></inline-formula> calculation must be stored in device global memory. Due to fact that dynamic programming requires accessing whole matrices with very limited data reuse, it will not take advantage of caching. Therefore, providing best possible global memory access pattern is a key issue for algorithm execution time. Taking into account anti-diagonal calculation scheme, simple row-major matrix representation results in a non-coalesced access which drastically decreases algorithm performance (each matrix cell is accessed in a separate transaction). Hence, a jagged memory layout of matrices elements was proposed (see <xref ref-type="fig" rid="pone-0088901-g003">Figure 3</xref>) in which consecutive work-items access consecutive memory cells resulting in perfect coalescing. Let <inline-formula><inline-graphic xlink:href="pone.0088901.e190.jpg"/></inline-formula> indicate the size of the jag. The number of elements necessary for storing matrix for sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e191.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e192.jpg"/></inline-formula> in the jagged form is <disp-formula id="pone.0088901.e193"><graphic xlink:href="pone.0088901.e193.jpg" position="anchor" orientation="portrait"/><label>(6)</label></disp-formula>
</p>
      <fig id="pone-0088901-g003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.g003</object-id>
        <label>Figure 3</label>
        <caption>
          <title>Jagged pattern of storing dense matrices in graphics device global memory.</title>
          <p>The size of jag is denoted as <inline-formula><inline-graphic xlink:href="pone.0088901.e194.jpg"/></inline-formula>.</p>
        </caption>
        <graphic xlink:href="pone.0088901.g003"/>
      </fig>
      <p>For convenience an <italic>element</italic> is used as a basic memory unit in the paper. Sometimes it is referred to as a <italic>dense element</italic> to distinguish it from <italic>sparse elements</italic> defined later. Pair-HMM used in MSAProbs contains 5 states. MSAProbs stores whole DP matrices for all states resulting in <inline-formula><inline-graphic xlink:href="pone.0088901.e195.jpg"/></inline-formula> elements for both, forward and backward procedures. However, as we are only interested in full matrix at 0'th state, it is sufficient to store only two consecutive rows of layers 1–4 (they are required for the dynamic programming recursion). This reduces memory requirements for <inline-formula><inline-graphic xlink:href="pone.0088901.e196.jpg"/></inline-formula> calculation to <inline-formula><inline-graphic xlink:href="pone.0088901.e197.jpg"/></inline-formula>, which is an important improvement, as it allows rows from layers 1–4 to be stored in fast local memory. Combination of forward and backward matrices can be done in place. The similar situation occurs in the case of partition function calculation. The difference here is that intermediate results are stored in a double floating-point precision. Therefore, in order to save space, reverse and combination passes are merged. The total memory footprint of calculating <inline-formula><inline-graphic xlink:href="pone.0088901.e198.jpg"/></inline-formula> is <inline-formula><inline-graphic xlink:href="pone.0088901.e199.jpg"/></inline-formula> elements. The calculation of a root mean square of <inline-formula><inline-graphic xlink:href="pone.0088901.e200.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e201.jpg"/></inline-formula> is done in place so it introduces no additional memory overhead. Eventually, the computation of <inline-formula><inline-graphic xlink:href="pone.0088901.e202.jpg"/></inline-formula> requires <inline-formula><inline-graphic xlink:href="pone.0088901.e203.jpg"/></inline-formula> elements in total. Note that <inline-formula><inline-graphic xlink:href="pone.0088901.e204.jpg"/></inline-formula> has to be computed first and stored so <inline-formula><inline-graphic xlink:href="pone.0088901.e205.jpg"/></inline-formula> can be calculated in the remaining space.</p>
      <p>Steps (2) and (3) of the posterior task transform dense <inline-formula><inline-graphic xlink:href="pone.0088901.e206.jpg"/></inline-formula> matrix to sparse representations <inline-formula><inline-graphic xlink:href="pone.0088901.e207.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e208.jpg"/></inline-formula>, respectively. The main component of <inline-formula><inline-graphic xlink:href="pone.0088901.e209.jpg"/></inline-formula> is an array of so-called <italic>sparse elements</italic> denoted as <inline-formula><inline-graphic xlink:href="pone.0088901.e210.jpg"/></inline-formula>. Each sparse element is a pair containing a column number and a floating-point value of posterior probability, referred to as <inline-formula><inline-graphic xlink:href="pone.0088901.e211.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e212.jpg"/></inline-formula>, respectively. Additionally, there are two vectors storing sizes of rows and starting indices of rows in the sparse elements array. They are denoted as <inline-formula><inline-graphic xlink:href="pone.0088901.e213.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e214.jpg"/></inline-formula>. The <inline-formula><inline-graphic xlink:href="pone.0088901.e215.jpg"/></inline-formula>'th sparse element in <inline-formula><inline-graphic xlink:href="pone.0088901.e216.jpg"/></inline-formula>'th row of <inline-formula><inline-graphic xlink:href="pone.0088901.e217.jpg"/></inline-formula> matrix is denoted as <inline-formula><inline-graphic xlink:href="pone.0088901.e218.jpg"/></inline-formula> and can be accessed by using the formula <inline-formula><inline-graphic xlink:href="pone.0088901.e219.jpg"/></inline-formula>. Such representation has its impact on a sparse generation procedure. Namely, in order to store <inline-formula><inline-graphic xlink:href="pone.0088901.e220.jpg"/></inline-formula> element in array <inline-formula><inline-graphic xlink:href="pone.0088901.e221.jpg"/></inline-formula> the number of non-zeros are in all previous rows and part of <inline-formula><inline-graphic xlink:href="pone.0088901.e222.jpg"/></inline-formula>'th row before <inline-formula><inline-graphic xlink:href="pone.0088901.e223.jpg"/></inline-formula>'th element have to be known. The similar situation is during <inline-formula><inline-graphic xlink:href="pone.0088901.e224.jpg"/></inline-formula> generation but instead of rows we are interested in <inline-formula><inline-graphic xlink:href="pone.0088901.e225.jpg"/></inline-formula> columns. Therefore, the transformation to the sparse form is done in two passes. In the first pass the number of non-zero elements in <inline-formula><inline-graphic xlink:href="pone.0088901.e226.jpg"/></inline-formula> rows (or columns) is determined and stored in <inline-formula><inline-graphic xlink:href="pone.0088901.e227.jpg"/></inline-formula> (or <inline-formula><inline-graphic xlink:href="pone.0088901.e228.jpg"/></inline-formula>). In the second pass <inline-formula><inline-graphic xlink:href="pone.0088901.e229.jpg"/></inline-formula> rows (columns) are transformed to the sparse form concurrently producing final <inline-formula><inline-graphic xlink:href="pone.0088901.e230.jpg"/></inline-formula> (or <inline-formula><inline-graphic xlink:href="pone.0088901.e231.jpg"/></inline-formula>) arrays. As <inline-formula><inline-graphic xlink:href="pone.0088901.e232.jpg"/></inline-formula> matrix is stored in the jagged form, <inline-formula><inline-graphic xlink:href="pone.0088901.e233.jpg"/></inline-formula> is traversed anti-diagonally during both passes of <inline-formula><inline-graphic xlink:href="pone.0088901.e234.jpg"/></inline-formula> (or <inline-formula><inline-graphic xlink:href="pone.0088901.e235.jpg"/></inline-formula>) generation. The procedure of transforming <inline-formula><inline-graphic xlink:href="pone.0088901.e236.jpg"/></inline-formula> dense matrix to sparse <inline-formula><inline-graphic xlink:href="pone.0088901.e237.jpg"/></inline-formula> form is presented in <xref ref-type="table" rid="pone-0088901-t003">Table 3</xref>.</p>
      <table-wrap id="pone-0088901-t003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t003</object-id>
        <label>Table 3</label>
        <caption>
          <title>Algorithm 3.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t003-3" xlink:href="pone.0088901.t003"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">
                  <bold>Input:</bold>
                </td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0088901.e238.jpg"/></inline-formula>—dense matrix to be translated to sparse form, <inline-formula><inline-graphic xlink:href="pone.0088901.e239.jpg"/></inline-formula>—work-item identifier (column number)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">
                  <bold>Output:</bold>
                </td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0088901.e240.jpg"/></inline-formula>—output sparse matrix described by <inline-formula><inline-graphic xlink:href="pone.0088901.e241.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e242.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e243.jpg"/></inline-formula> arrays.</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">1:</td>
                <td align="left" rowspan="1" colspan="1">Initialise in parallel <inline-formula><inline-graphic xlink:href="pone.0088901.e244.jpg"/></inline-formula> vector with 0.</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">2:</td>
                <td align="left" rowspan="1" colspan="1">
                  <sc>synchronise</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">3:</td>
                <td align="left" rowspan="1" colspan="1"><bold>for</bold><inline-formula><inline-graphic xlink:href="pone.0088901.e245.jpg"/></inline-formula><bold>do</bold><inline-formula><inline-graphic xlink:href="pone.0088901.e246.jpg"/></inline-formula>First pass: fill sizes vector.</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">4:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e247.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">5:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>if</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e248.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">6:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>if</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e249.jpg"/>
                  </inline-formula>
                  <bold>then</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">7:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e250.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">8:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end if</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">9:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end if</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">10:</td>
                <td align="left" rowspan="1" colspan="1">
                  <sc>synchronise</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">11:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">12:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>if</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e251.jpg"/>
                  </inline-formula>
                  <bold>then</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">13:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e252.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">14:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>for</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e253.jpg"/>
                  </inline-formula>
                  <bold>do</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">15:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e254.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">16:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">17:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end if</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">18:</td>
                <td align="left" rowspan="1" colspan="1">
                  <sc>synchronise</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">19:</td>
                <td align="left" rowspan="1" colspan="1">Copy in parallel <inline-formula><inline-graphic xlink:href="pone.0088901.e255.jpg"/></inline-formula> to auxiliary vector <inline-formula><inline-graphic xlink:href="pone.0088901.e256.jpg"/></inline-formula>.</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">20:</td>
                <td align="left" rowspan="1" colspan="1">
                  <sc>synchronise</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">21:</td>
                <td align="left" rowspan="1" colspan="1"><bold>for</bold><inline-formula><inline-graphic xlink:href="pone.0088901.e257.jpg"/></inline-formula><bold>do</bold><inline-formula><inline-graphic xlink:href="pone.0088901.e258.jpg"/></inline-formula> Second pass: fill sparse elements array.</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">22:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e259.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">23:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>if</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e260.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">24:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>if</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e261.jpg"/>
                  </inline-formula>
                  <bold>then</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">25:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e262.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">26:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e263.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">27:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e264.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">28:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end if</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">29:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end if</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">30:</td>
                <td align="left" rowspan="1" colspan="1">
                  <sc>synchronise</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">31:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt103">
            <label/>
            <p>Pseudo-code of the sparse matrix generation procedure.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>If column numbers and indices are of the same size as matrix elements, storing <inline-formula><inline-graphic xlink:href="pone.0088901.e265.jpg"/></inline-formula> requires at most <inline-formula><inline-graphic xlink:href="pone.0088901.e266.jpg"/></inline-formula> elements for <inline-formula><inline-graphic xlink:href="pone.0088901.e267.jpg"/></inline-formula> (if none of <inline-formula><inline-graphic xlink:href="pone.0088901.e268.jpg"/></inline-formula> elements is below <inline-formula><inline-graphic xlink:href="pone.0088901.e269.jpg"/></inline-formula>) and <inline-formula><inline-graphic xlink:href="pone.0088901.e270.jpg"/></inline-formula> elements for <inline-formula><inline-graphic xlink:href="pone.0088901.e271.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e272.jpg"/></inline-formula>. Calculations of <inline-formula><inline-graphic xlink:href="pone.0088901.e273.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e274.jpg"/></inline-formula> matrices are serialised, i.e., the algorithm executes step (2), reads the resulting sparse matrix from device memory, executes step (3), and reads the result once again. Therefore, the same memory space can be reused for both <inline-formula><inline-graphic xlink:href="pone.0088901.e275.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e276.jpg"/></inline-formula> matrices. Taking into account space needed for storing the input dense matrix, total memory requirements for executing steps (2) and (3) is <inline-formula><inline-graphic xlink:href="pone.0088901.e277.jpg"/></inline-formula>.</p>
      <p>Assuming that <inline-formula><inline-graphic xlink:href="pone.0088901.e278.jpg"/></inline-formula>, execution of a single task requires in total <disp-formula id="pone.0088901.e279"><graphic xlink:href="pone.0088901.e279.jpg" position="anchor" orientation="portrait"/><label>(7)</label></disp-formula>
</p>
      <p>elements in device memory. The space for storing posterior layers and output sparse matrices, i.e., <inline-formula><inline-graphic xlink:href="pone.0088901.e280.jpg"/></inline-formula> elements, is allocated in device global memory. Auxiliary rows consisting of <inline-formula><inline-graphic xlink:href="pone.0088901.e281.jpg"/></inline-formula> elements are placed in local memory to reduce transfer overheads. Let <inline-formula><inline-graphic xlink:href="pone.0088901.e282.jpg"/></inline-formula> which is the maximum size of a workgroup that can be processed by modern GPUs. For such tasks the local memory requirement is 8,192 elements which equals 32 KB assuming 32-bit floating-point values. The last few generations of graphics processors are equipped in such amount of local memory. Thus storing auxiliary rows in local memory does not limit the size of datasets that can be processed by QuickProbs.</p>
      <p><bold>Consistency transformation.</bold> QuickProbs version of consistency transformation differs from its predecessor. First of all, as GPU computations are strongly memory limited, QuickProbs operates directly on sparse representations. As a result, the elements of <inline-formula><inline-graphic xlink:href="pone.0088901.e283.jpg"/></inline-formula> that do not appear in <inline-formula><inline-graphic xlink:href="pone.0088901.e284.jpg"/></inline-formula> are discarded during multiplication procedure, not after, as in MSAProbs. Secondly, in order to eliminate divergence in kernel executions only one version of the sparse matrix multiplication procedure is implemented. This, however, requires all <inline-formula><inline-graphic xlink:href="pone.0088901.e285.jpg"/></inline-formula> matrices at the input of the consistency transformation. These are provided by the modified stage I of QuickProbs. Additionally, as the output of <inline-formula><inline-graphic xlink:href="pone.0088901.e286.jpg"/></inline-formula>'th consistency iteration is also the input to <inline-formula><inline-graphic xlink:href="pone.0088901.e287.jpg"/></inline-formula>'th, all <inline-formula><inline-graphic xlink:href="pone.0088901.e288.jpg"/></inline-formula> must be computed in the consistency stage. Since computational effort of matrix transposition is irrelevant with respect to the relaxation, QuickProbs calculates on GPU <inline-formula><inline-graphic xlink:href="pone.0088901.e289.jpg"/></inline-formula> matrices only for <inline-formula><inline-graphic xlink:href="pone.0088901.e290.jpg"/></inline-formula> and then transposes them in parallel on CPU with a use of OpenMP generating <inline-formula><inline-graphic xlink:href="pone.0088901.e291.jpg"/></inline-formula>. The last difference concerns parallelisation scheme, which was changed to intra-task, i.e., each task is analysed by entire workgroup. As previously, after each transformation <inline-formula><inline-graphic xlink:href="pone.0088901.e292.jpg"/></inline-formula> matrices are replaced by <inline-formula><inline-graphic xlink:href="pone.0088901.e293.jpg"/></inline-formula>. Posterior matrices after performing all <inline-formula><inline-graphic xlink:href="pone.0088901.e294.jpg"/></inline-formula> consistency transformations will be referred to as <inline-formula><inline-graphic xlink:href="pone.0088901.e295.jpg"/></inline-formula>.</p>
      <p>At the beginning of the consistency transformation QuickProbs generates descriptions of all <inline-formula><inline-graphic xlink:href="pone.0088901.e296.jpg"/></inline-formula> relaxation tasks. In order to reduce GPU global memory requirements the relaxation is performed in batches, similarly to the posterior matrices calculation. Namely, set of sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e297.jpg"/></inline-formula> is divided in equally-sized subsets <inline-formula><inline-graphic xlink:href="pone.0088901.e298.jpg"/></inline-formula>. As a result, table of <inline-formula><inline-graphic xlink:href="pone.0088901.e299.jpg"/></inline-formula> matrices can be divided in square sectors denoted as <inline-formula><inline-graphic xlink:href="pone.0088901.e300.jpg"/></inline-formula>. Afterwards, the execution of two nested loops begins. The outer loop iterates over sectors <inline-formula><inline-graphic xlink:href="pone.0088901.e301.jpg"/></inline-formula> to be computed. As QuickProbs calculates on GPU <inline-formula><inline-graphic xlink:href="pone.0088901.e302.jpg"/></inline-formula> matrices only for <inline-formula><inline-graphic xlink:href="pone.0088901.e303.jpg"/></inline-formula> sequences, the outer loop concerns sectors for which <inline-formula><inline-graphic xlink:href="pone.0088901.e304.jpg"/></inline-formula>. The inner loop iterates over all sequence subsets <inline-formula><inline-graphic xlink:href="pone.0088901.e305.jpg"/></inline-formula> and performs on GPU relaxations of all matrices from <inline-formula><inline-graphic xlink:href="pone.0088901.e306.jpg"/></inline-formula> over all sequences from <inline-formula><inline-graphic xlink:href="pone.0088901.e307.jpg"/></inline-formula>. In order to perform the relaxation of particular <inline-formula><inline-graphic xlink:href="pone.0088901.e308.jpg"/></inline-formula> sector over <inline-formula><inline-graphic xlink:href="pone.0088901.e309.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e310.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e311.jpg"/></inline-formula> sectors are also required. As a result, for each calculated sector, a buffer for three sectors must be allocated at GPU. Sector sizes are adjusted in the way that buffer size does not exceed size of global memory <inline-formula><inline-graphic xlink:href="pone.0088901.e312.jpg"/></inline-formula>.</p>
      <p>The relaxation procedure performed at GPU starts from weighting input matrix by <inline-formula><inline-graphic xlink:href="pone.0088901.e313.jpg"/></inline-formula> (sequence weights are computed during construction of the guide tree) and storing in <inline-formula><inline-graphic xlink:href="pone.0088901.e314.jpg"/></inline-formula>. After that <inline-formula><inline-graphic xlink:href="pone.0088901.e315.jpg"/></inline-formula> is relaxed over all sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e316.jpg"/></inline-formula>. The relaxation over single sequence consists in performing a sparse-sparse matrix multiplication and adding the result to <inline-formula><inline-graphic xlink:href="pone.0088901.e317.jpg"/></inline-formula>. Let <inline-formula><inline-graphic xlink:href="pone.0088901.e318.jpg"/></inline-formula> be the sequence over which <inline-formula><inline-graphic xlink:href="pone.0088901.e319.jpg"/></inline-formula> is relaxed. For simplicity let <inline-formula><inline-graphic xlink:href="pone.0088901.e320.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e321.jpg"/></inline-formula>, and <inline-formula><inline-graphic xlink:href="pone.0088901.e322.jpg"/></inline-formula>. The update is performed as follows: <inline-formula><inline-graphic xlink:href="pone.0088901.e323.jpg"/></inline-formula>. The multiplication is done by traversing all elements of <inline-formula><inline-graphic xlink:href="pone.0088901.e324.jpg"/></inline-formula>, loading corresponding fragments of <inline-formula><inline-graphic xlink:href="pone.0088901.e325.jpg"/></inline-formula> for each <inline-formula><inline-graphic xlink:href="pone.0088901.e326.jpg"/></inline-formula>, making computations and adding result to <inline-formula><inline-graphic xlink:href="pone.0088901.e327.jpg"/></inline-formula>. Processing of <inline-formula><inline-graphic xlink:href="pone.0088901.e328.jpg"/></inline-formula> matrix is performed in horizontal blocks called <italic>stripes</italic>. There are <inline-formula><inline-graphic xlink:href="pone.0088901.e329.jpg"/></inline-formula> stripes executed concurrently, each having <inline-formula><inline-graphic xlink:href="pone.0088901.e330.jpg"/></inline-formula> sparse elements. Let <italic>subgroup</italic> indicate a set of work-items which processes a stripe. As single sparse element is analysed by a single work-item, there are <inline-formula><inline-graphic xlink:href="pone.0088901.e331.jpg"/></inline-formula> work-items in a subgroup and <inline-formula><inline-graphic xlink:href="pone.0088901.e332.jpg"/></inline-formula> work-items in a workgroup. An important note is that consecutive subgroups are assigned to consecutive rows of <inline-formula><inline-graphic xlink:href="pone.0088901.e333.jpg"/></inline-formula> matrix, thus at any given moment only one stripe in a row is being processed. The scheme of traversing <inline-formula><inline-graphic xlink:href="pone.0088901.e334.jpg"/></inline-formula> matrix is presented in <xref ref-type="fig" rid="pone-0088901-g004">Figure 4</xref>.</p>
      <fig id="pone-0088901-g004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.g004</object-id>
        <label>Figure 4</label>
        <caption>
          <title>Scheme of traversing sparse matrix in multiplication procedure.</title>
          <p><inline-formula><inline-graphic xlink:href="pone.0088901.e335.jpg"/></inline-formula> There are <inline-formula><inline-graphic xlink:href="pone.0088901.e336.jpg"/></inline-formula> subgroups, each assigned to a single row of <inline-formula><inline-graphic xlink:href="pone.0088901.e337.jpg"/></inline-formula> matrix. Each row is divided into stripes having <inline-formula><inline-graphic xlink:href="pone.0088901.e338.jpg"/></inline-formula> sparse elements. Subgroups process consecutive stripes of their rows. Stripes are represented by rectangles with corresponding subgroup identifier (upper left number) and their own identifier (bottom right number). Colours indicate stripes being calculated concurrently by a workgroup.</p>
        </caption>
        <graphic xlink:href="pone.0088901.g004"/>
      </fig>
      <p>A detailed description of actions performed by a single subgroup is presented below. For convenience, let us introduce an additional notion: <inline-formula><inline-graphic xlink:href="pone.0088901.e339.jpg"/></inline-formula>—<inline-formula><inline-graphic xlink:href="pone.0088901.e340.jpg"/></inline-formula>'th row of <inline-formula><inline-graphic xlink:href="pone.0088901.e341.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e342.jpg"/></inline-formula>—<inline-formula><inline-graphic xlink:href="pone.0088901.e343.jpg"/></inline-formula>'th element of <inline-formula><inline-graphic xlink:href="pone.0088901.e344.jpg"/></inline-formula>'th row of <inline-formula><inline-graphic xlink:href="pone.0088901.e345.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e346.jpg"/></inline-formula>—some stripe of <inline-formula><inline-graphic xlink:href="pone.0088901.e347.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e348.jpg"/></inline-formula>—<inline-formula><inline-graphic xlink:href="pone.0088901.e349.jpg"/></inline-formula>'th element of <inline-formula><inline-graphic xlink:href="pone.0088901.e350.jpg"/></inline-formula>. At the beginning, each work-item computes an identifier of its subgroup <inline-formula><inline-graphic xlink:href="pone.0088901.e351.jpg"/></inline-formula> and an offset within it <inline-formula><inline-graphic xlink:href="pone.0088901.e352.jpg"/></inline-formula>. Then the subgroup sets itself on <inline-formula><inline-graphic xlink:href="pone.0088901.e353.jpg"/></inline-formula> row and copies the first stripe <inline-formula><inline-graphic xlink:href="pone.0088901.e354.jpg"/></inline-formula> of <inline-formula><inline-graphic xlink:href="pone.0088901.e355.jpg"/></inline-formula> to local memory (each sparse element is copied by a single work-item). After that it iterates over sparse elements <inline-formula><inline-graphic xlink:href="pone.0088901.e356.jpg"/></inline-formula>. Note, that for each element <inline-formula><inline-graphic xlink:href="pone.0088901.e357.jpg"/></inline-formula> there is a corresponding row <inline-formula><inline-graphic xlink:href="pone.0088901.e358.jpg"/></inline-formula> in <inline-formula><inline-graphic xlink:href="pone.0088901.e359.jpg"/></inline-formula> such that <inline-formula><inline-graphic xlink:href="pone.0088901.e360.jpg"/></inline-formula>. In the following steps, the subgroup processes consecutive stripes of these rows. Each work-item reads its sparse element <inline-formula><inline-graphic xlink:href="pone.0088901.e361.jpg"/></inline-formula> of the current stripe, calculates <inline-formula><inline-graphic xlink:href="pone.0088901.e362.jpg"/></inline-formula> and adds it to the proper element of <inline-formula><inline-graphic xlink:href="pone.0088901.e363.jpg"/></inline-formula>. In MSAProbs <inline-formula><inline-graphic xlink:href="pone.0088901.e364.jpg"/></inline-formula> was temporarily stored in the dense form, therefore the algorithm updated directly <inline-formula><inline-graphic xlink:href="pone.0088901.e365.jpg"/></inline-formula>. This approach is not used in QuickProbs as it renders inferior results. This is mainly because of increase in global memory requirements for a task which limits the size of a dataset that can be processed on a graphics processor. Moreover, as input matrices are sparse, accesses to <inline-formula><inline-graphic xlink:href="pone.0088901.e366.jpg"/></inline-formula> are non-coalesced which decreases performance. An alternative solution is to use local memory for buffering in the dense form only <inline-formula><inline-graphic xlink:href="pone.0088901.e367.jpg"/></inline-formula> row. Nevertheless, as tests show, this variant is also inappropriate for graphics processor execution. Since maximum length of a dense row is 1024 and a single element is a 32-bit floating-point value, 8 dense rows are sufficient to fill whole 32 KB GPU local memory limiting GPU occupancy.</p>
      <p>After considering all these factors, we decided to store <inline-formula><inline-graphic xlink:href="pone.0088901.e368.jpg"/></inline-formula> rows in local memory directly in the sparse form. The problem that emerges here concerns finding an element to be updated <inline-formula><inline-graphic xlink:href="pone.0088901.e369.jpg"/></inline-formula>, where <inline-formula><inline-graphic xlink:href="pone.0088901.e370.jpg"/></inline-formula> is index of a sparse element with column number equal to <inline-formula><inline-graphic xlink:href="pone.0088901.e371.jpg"/></inline-formula>. We examined two methods of overcoming this issue—hashing <inline-formula><inline-graphic xlink:href="pone.0088901.e372.jpg"/></inline-formula> values according to column indices and performing binary search. As the latter turned out to be more efficient, it is employed in QuickProbs. If there is no index <inline-formula><inline-graphic xlink:href="pone.0088901.e373.jpg"/></inline-formula> such that <inline-formula><inline-graphic xlink:href="pone.0088901.e374.jpg"/></inline-formula>, no update is performed (no new sparse elements can be introduced to <inline-formula><inline-graphic xlink:href="pone.0088901.e375.jpg"/></inline-formula>). After subgroup finishes processing <inline-formula><inline-graphic xlink:href="pone.0088901.e376.jpg"/></inline-formula> rows for all elements <inline-formula><inline-graphic xlink:href="pone.0088901.e377.jpg"/></inline-formula>, it reads another stripe of <inline-formula><inline-graphic xlink:href="pone.0088901.e378.jpg"/></inline-formula>. When processing of <inline-formula><inline-graphic xlink:href="pone.0088901.e379.jpg"/></inline-formula> ends, <inline-formula><inline-graphic xlink:href="pone.0088901.e380.jpg"/></inline-formula> is incremented by <inline-formula><inline-graphic xlink:href="pone.0088901.e381.jpg"/></inline-formula> and the aforementioned scheme is repeated. After relaxing <inline-formula><inline-graphic xlink:href="pone.0088901.e382.jpg"/></inline-formula> matrix over all sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e383.jpg"/></inline-formula>, sparse elements smaller than <inline-formula><inline-graphic xlink:href="pone.0088901.e384.jpg"/></inline-formula> are filtered out. The pseudo-code of a single relaxation is presented in <xref ref-type="table" rid="pone-0088901-t004">Table 4</xref>.</p>
      <table-wrap id="pone-0088901-t004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t004</object-id>
        <label>Table 4</label>
        <caption>
          <title>Algorithm 4.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t004-4" xlink:href="pone.0088901.t004"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">
                  <bold>Input:</bold>
                </td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0088901.e385.jpg"/></inline-formula>—set of sequences, <inline-formula><inline-graphic xlink:href="pone.0088901.e386.jpg"/></inline-formula>—sparse matrix to be relaxed, <inline-formula><inline-graphic xlink:href="pone.0088901.e387.jpg"/></inline-formula>—work-item identifier, <inline-formula><inline-graphic xlink:href="pone.0088901.e388.jpg"/></inline-formula>—number of stripes processed concurrently, <inline-formula><inline-graphic xlink:href="pone.0088901.e389.jpg"/></inline-formula>—stripe length.</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">
                  <bold>Output:</bold>
                </td>
                <td align="left" rowspan="1" colspan="1">Matrix <inline-formula><inline-graphic xlink:href="pone.0088901.e390.jpg"/></inline-formula> after relaxation.</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">1:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e391.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">2:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e392.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">3:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e393.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">4:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e394.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">5:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>for all</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e395.jpg"/>
                  </inline-formula>
                  <bold>do</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">6:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e396.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">7:</td>
                <td align="left" rowspan="1" colspan="1"><sc>relax</sc> (<inline-formula><inline-graphic xlink:href="pone.0088901.e397.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e398.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e399.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e400.jpg"/></inline-formula>)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">8:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">9:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e401.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">10:</td>
                <td align="left" rowspan="1" colspan="1"><bold>funtion</bold><sc>relax</sc>(<inline-formula><inline-graphic xlink:href="pone.0088901.e402.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e403.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e404.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0088901.e405.jpg"/></inline-formula>) <inline-formula><inline-graphic xlink:href="pone.0088901.e406.jpg"/></inline-formula>Function modifies C matrix</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">11:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>for</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e407.jpg"/>
                  </inline-formula>
                  <bold>do</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">12:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>for all</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e408.jpg"/>
                  </inline-formula>
                  <bold>do</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">13:</td>
                <td align="left" rowspan="1" colspan="1">Copy <inline-formula><inline-graphic xlink:href="pone.0088901.e409.jpg"/></inline-formula> to local memory.</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">14:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">15:</td>
                <td align="left" rowspan="1" colspan="1">
                  <sc>synchronise</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">16:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>for all</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e410.jpg"/>
                  </inline-formula>
                  <bold>do</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">17:</td>
                <td align="left" rowspan="1" colspan="1">Copy <inline-formula><inline-graphic xlink:href="pone.0088901.e411.jpg"/></inline-formula> to local memory.</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">18:</td>
                <td align="left" rowspan="1" colspan="1">
                  <sc>synchronise</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">19:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>for all</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e412.jpg"/>
                  </inline-formula>
                  <bold>do</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">20:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e413.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">21:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>for all</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e414.jpg"/>
                  </inline-formula>
                  <bold>do</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">22:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e415.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">23:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e416.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">24:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>if</bold>
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e417.jpg"/>
                  </inline-formula>
                  <bold>then</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">25:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e418.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">26:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end if</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">27:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">28:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">29:</td>
                <td align="left" rowspan="1" colspan="1">
                  <sc>synchronise</sc>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">30:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">31:</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e419.jpg"/>
                  </inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">32:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">33:</td>
                <td align="left" rowspan="1" colspan="1">
                  <bold>end function</bold>
                </td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt104">
            <label/>
            <p>Pseudo-code of the posterior matrix relaxation procedure.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The relaxation of <inline-formula><inline-graphic xlink:href="pone.0088901.e420.jpg"/></inline-formula> requires <inline-formula><inline-graphic xlink:href="pone.0088901.e421.jpg"/></inline-formula> sparse elements for buffering <inline-formula><inline-graphic xlink:href="pone.0088901.e422.jpg"/></inline-formula> rows and <inline-formula><inline-graphic xlink:href="pone.0088901.e423.jpg"/></inline-formula> sparse elements for <inline-formula><inline-graphic xlink:href="pone.0088901.e424.jpg"/></inline-formula> stripes. Additionally <inline-formula><inline-graphic xlink:href="pone.0088901.e425.jpg"/></inline-formula> dense elements are needed for storing new sizes of <inline-formula><inline-graphic xlink:href="pone.0088901.e426.jpg"/></inline-formula> rows. Taking into account that a sparse element takes twice as much memory as a dense one, total local memory requirement for relaxation task equals <disp-formula id="pone.0088901.e427"><graphic xlink:href="pone.0088901.e427.jpg" position="anchor" orientation="portrait"/><label>(8)</label></disp-formula>
</p>
      <p>elements. In our preliminary experiments performed on both NVidia and AMD GPUs the best results were obtained for <inline-formula><inline-graphic xlink:href="pone.0088901.e428.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e429.jpg"/></inline-formula>. As we observed, for default value of <inline-formula><inline-graphic xlink:href="pone.0088901.e430.jpg"/></inline-formula>, transforming matrix to sparse representation <inline-formula><inline-graphic xlink:href="pone.0088901.e431.jpg"/></inline-formula> retains on average 5–10% of <inline-formula><inline-graphic xlink:href="pone.0088901.e432.jpg"/></inline-formula> elements. Assuming that sequences are shorter than 1,000, which is often the case, <inline-formula><inline-graphic xlink:href="pone.0088901.e433.jpg"/></inline-formula> usually does not exceed 100. Local memory requirements are less than 12 KB/task assuming 32-bit elements. This results in better occupancy than in variant storing dense rows locally.</p>
      <p>The most important disadvantage of the described method is its sensitivity for divergence of sparse matrices widths. This effect is especially visible for large datasets and is caused by multiplication algorithm containing several data-dependant nested loops. Branch divergence within a wavefront (warp) in outer-loop caused by different lengths of rows is very expensive, as alternative execution paths are time consuming. This effect is partially reduced by using stripes, but not entirely removed. To avoid waste of computational power, the diversity of sparse row lengths have to be minimised. The simplest way of obtaining it is gathering in sectors <inline-formula><inline-graphic xlink:href="pone.0088901.e434.jpg"/></inline-formula> matrices of similar size. We plan to implement this feature in the next release of QuickProbs.</p>
      <p>Final alignment construction and refinement. In MSAProbs the last stage of the algorithm is executed serially, which is appropriate for small datasets when profiles contain few sequences. When the number of sequences is larger, the computation time of stage IV becomes comparable to the execution times of stages I and III. Since QuickProbs uses significantly faster algorithms for stages I and III, the last stage, if performed serially, would be the most time consuming part of the entire algorithm. Thus, we decided to parallelise this stage for multi-core central processors. There are two main parallelisation approaches possible.</p>
      <p>The first one follows inter-task concurrency scheme utilised by original MSAProbs for stages I and III. The <xref ref-type="disp-formula" rid="pone.0088901.e080">Eqn. (3</xref>) is computed for all pairs of sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e435.jpg"/></inline-formula> such that <inline-formula><inline-graphic xlink:href="pone.0088901.e436.jpg"/></inline-formula>. Processing of each pair can be treated as an independent task. In the assumed parallelisation model each thread executes one or several tasks. Second parallelisation scheme can be referred to as intra-task and consists in parallel computation of <xref ref-type="disp-formula" rid="pone.0088901.e080">Eqn. (3</xref>). In theory it would be profitable even for small datasets. However, such computation model requires tens or hundreds times more threads than inter-task. Central processors, unlike GPUs, are not massively parallel devices, hence the costs of invocation and synchronisation of threads could be higher than the gains from parallel processing. This is why QuickProbs utilises inter-task parallelisation based on OpenMP as more appropriate for architecture of multi-core CPUs. In the future release we plan to customise stage IV for graphics processor execution. In this case, intra-task parallelisation will be the choice.</p>
      <p>Beside parallelisation, QuickProbs introduces a simple optimisation to the final alignment calculation. When MSAProbs computes <xref ref-type="disp-formula" rid="pone.0088901.e080">Eqn. (3</xref>), the processing is row-wise or column-wise, depending on the indexes of sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e437.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0088901.e438.jpg"/></inline-formula>, i.e., whether <inline-formula><inline-graphic xlink:href="pone.0088901.e439.jpg"/></inline-formula> or <inline-formula><inline-graphic xlink:href="pone.0088901.e440.jpg"/></inline-formula> matrix is available. Since in stage III of QuickProbs both of these matrices are computed, the recurrence is always solved in a row-wise manner, which uses cache memory more effectively.</p>
      <p>In QuickProbs the refinement stage is also done in parallel with the use of the profile alignment inter-task algorithm described above.</p>
      <p><bold>Accurate mode.</bold> QuickProbs, similarly to MSAProbs, has two parameters influencing quality of a final alignment, the number of consistency transformations <inline-formula><inline-graphic xlink:href="pone.0088901.e441.jpg"/></inline-formula> and the number of refinement iterations <inline-formula><inline-graphic xlink:href="pone.0088901.e442.jpg"/></inline-formula>. By default they equal 2 and 10, respectively. As QuickProbs in default settings turned out to be faster than its predecessor, we investigated whether it is possible to increase QuickProbs accuracy by tuning its parameters without exceeding MSAProbs computation times. At first we independently altered the number of refinement iterations to 20, 35, 50, 100, 150, 200 and the number of consistency transformations to 3, 4, 5. We established that increasing <inline-formula><inline-graphic xlink:href="pone.0088901.e443.jpg"/></inline-formula> over default value 10 does not influence alignment accuracy, while increasing <inline-formula><inline-graphic xlink:href="pone.0088901.e444.jpg"/></inline-formula> reduces results quality. This is because information loss caused by removing posterior elements below <inline-formula><inline-graphic xlink:href="pone.0088901.e445.jpg"/></inline-formula> at the end of each transformation exceeds gains from the consistency. This was confirmed by the experiment in which <inline-formula><inline-graphic xlink:href="pone.0088901.e446.jpg"/></inline-formula> was set to <inline-formula><inline-graphic xlink:href="pone.0088901.e447.jpg"/></inline-formula> resulting in much less posterior elements being discarded and elevated accuracy. Increasing in this scenario number of consistency transformations to <inline-formula><inline-graphic xlink:href="pone.0088901.e448.jpg"/></inline-formula> worsened accuracy. Even though, decrease is smaller than for <inline-formula><inline-graphic xlink:href="pone.0088901.e449.jpg"/></inline-formula>, it is still noticeable suggesting that default <inline-formula><inline-graphic xlink:href="pone.0088901.e450.jpg"/></inline-formula> value produces best results.</p>
      <p>The main disadvantage of approach based on global <inline-formula><inline-graphic xlink:href="pone.0088901.e451.jpg"/></inline-formula> value is that fraction of elements removed from posterior matrices differs across sequence pairs. Thus, information loss for distant sequences (those having small <inline-formula><inline-graphic xlink:href="pone.0088901.e452.jpg"/></inline-formula> values) is much higher than for closely related sequences. Therefore, we decided to test an alternative variant in which <inline-formula><inline-graphic xlink:href="pone.0088901.e453.jpg"/></inline-formula> value is computed independently for each posterior matrix in order to retain assumed fraction <inline-formula><inline-graphic xlink:href="pone.0088901.e454.jpg"/></inline-formula> of elements. Such variant turned out to be a better compromise between computation time and result quality than static <inline-formula><inline-graphic xlink:href="pone.0088901.e455.jpg"/></inline-formula>. Thus, in the accurate mode of QuickProbs algorithm (referred to as QuickProbs-acc) we decided to use the adaptive filtering with <inline-formula><inline-graphic xlink:href="pone.0088901.e456.jpg"/></inline-formula> as it gave the best results in our experiments.</p>
    </sec>
  </sec>
  <sec id="s3">
    <title>Results</title>
    <sec id="s3a">
      <title>Experimental setting</title>
      <p>Experiments were performed on several hardware configurations built upon three CPUs (Intel Xeon W3550, Intel Xeon E5-2630, and AMD Phenom II X6 1090) and four graphics cards (NVidia GeForce GTX 480, 560, 680, and AMD Radeon HD 7970). All computers used for the tests were controlled by Windows operating system. Detailed parameters of hardware used in the experiments can be found in <xref ref-type="table" rid="pone-0088901-t005">Table 5</xref>. As majority of modern computers are equipped with quad-core processors, the basic experimental platform contained Xeon W3550 CPU which was coupled with GeForce 480, 680, and Radeon 7970 GPUs. Another testing PC represented class of high-end desktop computers and consisted of Xeon E5-2630 hexa-core CPU and GeForce 680 which is one of the fastest single-chip graphic cards on the market. The experiments on quad-core PC reported Radeon 7970 to be faster than GeForce 680. However, AMD GPU was not supported properly by our hexa-core platform preventing us from testing it with Xeon E5-2630. Additional experiments were carried out on a mid-range hexa-core Phenom II X6 platform with GeForce 560. All examined processors are equipped with a dynamic overclocking feature which increases clocking frequency when CPU is not exceeding its thermal design power (this is usually the case when some cores are not loaded). Additionally, Intel processors utilise hyper-threading technology which improves task parallelism on a single core by duplicating some CPU logic. Operating system reports these processors to have twice as many cores as they physically posses.</p>
      <table-wrap id="pone-0088901-t005" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t005</object-id>
        <label>Table 5</label>
        <caption>
          <title>Characteristics of hardware used in the experiments.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t005-5" xlink:href="pone.0088901.t005"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1"/>
                <td colspan="3" align="left" rowspan="1">Cache</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">Local</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Hardware</td>
                <td align="left" rowspan="1" colspan="1">Frequency</td>
                <td align="left" rowspan="1" colspan="1">Cores</td>
                <td align="left" rowspan="1" colspan="1">L1</td>
                <td align="left" rowspan="1" colspan="1">L2</td>
                <td align="left" rowspan="1" colspan="1">L3</td>
                <td align="left" rowspan="1" colspan="1">Memory</td>
                <td align="left" rowspan="1" colspan="1">Bandwidth</td>
                <td align="left" rowspan="1" colspan="1">memory</td>
                <td align="left" rowspan="1" colspan="1">GFLOPS</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">[GHz]</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">[KB]</td>
                <td align="left" rowspan="1" colspan="1">[KB]</td>
                <td align="left" rowspan="1" colspan="1">[MB]</td>
                <td align="left" rowspan="1" colspan="1">[GB]</td>
                <td align="left" rowspan="1" colspan="1">[GB/s]</td>
                <td align="left" rowspan="1" colspan="1">[KB]</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550</td>
                <td align="left" rowspan="1" colspan="1">3.0–3.3</td>
                <td align="left" rowspan="1" colspan="1">4<xref ref-type="table-fn" rid="nt106">1</xref>
</td>
                <td align="left" rowspan="1" colspan="1">4×32</td>
                <td align="left" rowspan="1" colspan="1">4×256</td>
                <td align="left" rowspan="1" colspan="1">8</td>
                <td align="left" rowspan="1" colspan="1">24.0</td>
                <td align="left" rowspan="1" colspan="1">26</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">50</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon E5-2630</td>
                <td align="left" rowspan="1" colspan="1">2.3–2.8</td>
                <td align="left" rowspan="1" colspan="1">6<xref ref-type="table-fn" rid="nt106">1</xref>
</td>
                <td align="left" rowspan="1" colspan="1">6×32</td>
                <td align="left" rowspan="1" colspan="1">6×256</td>
                <td align="left" rowspan="1" colspan="1">15</td>
                <td align="left" rowspan="1" colspan="1">32.0</td>
                <td align="left" rowspan="1" colspan="1">43</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">110</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Phenom II X6</td>
                <td align="left" rowspan="1" colspan="1">3.2–3.6</td>
                <td align="left" rowspan="1" colspan="1">6</td>
                <td align="left" rowspan="1" colspan="1">6×64</td>
                <td align="left" rowspan="1" colspan="1">6×512</td>
                <td align="left" rowspan="1" colspan="1">6</td>
                <td align="left" rowspan="1" colspan="1">16.0</td>
                <td align="left" rowspan="1" colspan="1">21</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">47</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">GeForce 480</td>
                <td align="left" rowspan="1" colspan="1">1.4</td>
                <td align="left" rowspan="1" colspan="1">15×32</td>
                <td align="left" rowspan="1" colspan="1">15×16<xref ref-type="table-fn" rid="nt107">2</xref>
</td>
                <td align="left" rowspan="1" colspan="1">768</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">1.5</td>
                <td align="left" rowspan="1" colspan="1">177</td>
                <td align="left" rowspan="1" colspan="1">15×48<xref ref-type="table-fn" rid="nt107">2</xref>
</td>
                <td align="left" rowspan="1" colspan="1">1345</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">GeForce 560</td>
                <td align="left" rowspan="1" colspan="1">1.8</td>
                <td align="left" rowspan="1" colspan="1">8×48</td>
                <td align="left" rowspan="1" colspan="1">8×16<xref ref-type="table-fn" rid="nt107">2</xref>
</td>
                <td align="left" rowspan="1" colspan="1">512</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">1.0</td>
                <td align="left" rowspan="1" colspan="1">128</td>
                <td align="left" rowspan="1" colspan="1">8×48<xref ref-type="table-fn" rid="nt107">2</xref>
</td>
                <td align="left" rowspan="1" colspan="1">1263</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">GeForce 680</td>
                <td align="left" rowspan="1" colspan="1">1.0</td>
                <td align="left" rowspan="1" colspan="1">8×192</td>
                <td align="left" rowspan="1" colspan="1">8×16<xref ref-type="table-fn" rid="nt107">2</xref>
</td>
                <td align="left" rowspan="1" colspan="1">768</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">4.0</td>
                <td align="left" rowspan="1" colspan="1">192</td>
                <td align="left" rowspan="1" colspan="1">8×48<xref ref-type="table-fn" rid="nt107">2</xref>
</td>
                <td align="left" rowspan="1" colspan="1">3090</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Radeon 7970</td>
                <td align="left" rowspan="1" colspan="1">0.9</td>
                <td align="left" rowspan="1" colspan="1">32×64</td>
                <td align="left" rowspan="1" colspan="1">32×16</td>
                <td align="left" rowspan="1" colspan="1">768</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">3.0</td>
                <td align="left" rowspan="1" colspan="1">264</td>
                <td align="left" rowspan="1" colspan="1">32×32</td>
                <td align="left" rowspan="1" colspan="1">3789</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt105">
            <label/>
            <p>Top three rows describe the CPUs. The bottom four rows describe the GPUs.</p>
          </fn>
          <fn id="nt106">
            <label>1</label>
            <p>CPUs are equipped with HT technology. Table gives the number of physical cores.</p>
          </fn>
          <fn id="nt107">
            <label>2</label>
            <p>On GeForce GPUs each compute unit posses 64 KB memory shared by L1 cache and local memory configured by default in ratio 16/48.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The main tests were performed on three popular benchmarks containing amino acid sequences, i.e., BAliBASE 3 <xref rid="pone.0088901-Thompson3" ref-type="bibr">[52]</xref>, PREFAB 4 <xref rid="pone.0088901-Edgar1" ref-type="bibr">[9]</xref>, and extended variant of OXBench <xref rid="pone.0088901-Edgar2" ref-type="bibr">[54]</xref>. All datasets were downloaded from Robert Edgar Web page in a standardised FASTA format <xref rid="pone.0088901-Edgar2" ref-type="bibr">[54]</xref>. All benchmarks are constituted of hundreds of sequence sets (see <xref ref-type="table" rid="pone-0088901-t006">Table 6</xref> for more details). As many algorithms were tuned on BAliBASE, sequence sets from this benchmark were shuffled randomly in order to remove potential bias. Additional experiments were carried out on real protein families downloaded from Pfam database <xref rid="pone.0088901-Finn1" ref-type="bibr">[55]</xref>. The detailed characteristics of these datasets are presented in <xref ref-type="table" rid="pone-0088901-t007">Table 7</xref>.</p>
      <table-wrap id="pone-0088901-t006" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t006</object-id>
        <label>Table 6</label>
        <caption>
          <title>Characteristics of amino-acid benchmarks used in experiments.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t006-6" xlink:href="pone.0088901.t006"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td colspan="2" align="left" rowspan="1">Dataset</td>
                <td colspan="4" align="left" rowspan="1">Sequence statistics</td>
                <td align="left" rowspan="1" colspan="1">No.</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e457.jpg"/>
                  </inline-formula>
                </td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e458.jpg"/>
                  </inline-formula>
                </td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e459.jpg"/>
                  </inline-formula>
                </td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e460.jpg"/>
                  </inline-formula>
                </td>
                <td align="left" rowspan="1" colspan="1">sets</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">BAliBASE</td>
                <td align="left" rowspan="1" colspan="1">RV11</td>
                <td align="left" rowspan="1" colspan="1">6.9</td>
                <td align="left" rowspan="1" colspan="1">3.1</td>
                <td align="left" rowspan="1" colspan="1">294</td>
                <td align="left" rowspan="1" colspan="1">143</td>
                <td align="left" rowspan="1" colspan="1">38</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">RV12</td>
                <td align="left" rowspan="1" colspan="1">9.0</td>
                <td align="left" rowspan="1" colspan="1">5.8</td>
                <td align="left" rowspan="1" colspan="1">389</td>
                <td align="left" rowspan="1" colspan="1">256</td>
                <td align="left" rowspan="1" colspan="1">44</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">RV20</td>
                <td align="left" rowspan="1" colspan="1">45.6</td>
                <td align="left" rowspan="1" colspan="1">20.0</td>
                <td align="left" rowspan="1" colspan="1">391</td>
                <td align="left" rowspan="1" colspan="1">204</td>
                <td align="left" rowspan="1" colspan="1">41</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">RV30</td>
                <td align="left" rowspan="1" colspan="1">63.2</td>
                <td align="left" rowspan="1" colspan="1">34.1</td>
                <td align="left" rowspan="1" colspan="1">359</td>
                <td align="left" rowspan="1" colspan="1">155</td>
                <td align="left" rowspan="1" colspan="1">30</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">RV40</td>
                <td align="left" rowspan="1" colspan="1">27.1</td>
                <td align="left" rowspan="1" colspan="1">14.9</td>
                <td align="left" rowspan="1" colspan="1">479</td>
                <td align="left" rowspan="1" colspan="1">255</td>
                <td align="left" rowspan="1" colspan="1">49</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">RV50</td>
                <td align="left" rowspan="1" colspan="1">27.9</td>
                <td align="left" rowspan="1" colspan="1">13.8</td>
                <td align="left" rowspan="1" colspan="1">488</td>
                <td align="left" rowspan="1" colspan="1">138</td>
                <td align="left" rowspan="1" colspan="1">16</td>
              </tr>
              <tr>
                <td colspan="2" align="left" rowspan="1">BAliBASE all</td>
                <td align="left" rowspan="1" colspan="1">28.5</td>
                <td align="left" rowspan="1" colspan="1">26.2</td>
                <td align="left" rowspan="1" colspan="1">396</td>
                <td align="left" rowspan="1" colspan="1">219</td>
                <td align="left" rowspan="1" colspan="1">218</td>
              </tr>
              <tr>
                <td colspan="2" align="left" rowspan="1">PREFAB</td>
                <td align="left" rowspan="1" colspan="1">45.2</td>
                <td align="left" rowspan="1" colspan="1">10.8</td>
                <td align="left" rowspan="1" colspan="1">289</td>
                <td align="left" rowspan="1" colspan="1">126</td>
                <td align="left" rowspan="1" colspan="1">1692</td>
              </tr>
              <tr>
                <td colspan="2" align="left" rowspan="1">OXBench-X</td>
                <td align="left" rowspan="1" colspan="1">122.5</td>
                <td align="left" rowspan="1" colspan="1">100.7</td>
                <td align="left" rowspan="1" colspan="1">147</td>
                <td align="left" rowspan="1" colspan="1">82</td>
                <td align="left" rowspan="1" colspan="1">395</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt108">
            <label/>
            <p>A single set of sequences is described by the number of sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e461.jpg"/></inline-formula> and the average sequence length <inline-formula><inline-graphic xlink:href="pone.0088901.e462.jpg"/></inline-formula>.</p>
          </fn>
          <fn id="nt109">
            <label/>
            <p>Table presents means and standard deviations of these parameters for BAliBASE 3.0, PREFAB 4.0, and OXBench-X.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="pone-0088901-t007" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t007</object-id>
        <label>Table 7</label>
        <caption>
          <title>Detailed characteristics of the protein families taken from Pfam database.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t007-7" xlink:href="pone.0088901.t007"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">Dataset</td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e463.jpg"/>
                  </inline-formula>
                </td>
                <td align="left" rowspan="1" colspan="1">
                  <inline-formula>
                    <inline-graphic xlink:href="pone.0088901.e464.jpg"/>
                  </inline-formula>
                </td>
                <td align="left" rowspan="1" colspan="1">Description</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF02324</td>
                <td align="left" rowspan="1" colspan="1">260</td>
                <td align="left" rowspan="1" colspan="1">706</td>
                <td align="left" rowspan="1" colspan="1">glycoside hydrolase</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF04762</td>
                <td align="left" rowspan="1" colspan="1">404</td>
                <td align="left" rowspan="1" colspan="1">667</td>
                <td align="left" rowspan="1" colspan="1">IKI3 family</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF05110</td>
                <td align="left" rowspan="1" colspan="1">483</td>
                <td align="left" rowspan="1" colspan="1">611</td>
                <td align="left" rowspan="1" colspan="1">AF4/FMR2-related protein</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF07095</td>
                <td align="left" rowspan="1" colspan="1">600</td>
                <td align="left" rowspan="1" colspan="1">642</td>
                <td align="left" rowspan="1" colspan="1">growth attenuator protein</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF07520</td>
                <td align="left" rowspan="1" colspan="1">283</td>
                <td align="left" rowspan="1" colspan="1">878</td>
                <td align="left" rowspan="1" colspan="1">virulence factor SrfB</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF08689</td>
                <td align="left" rowspan="1" colspan="1">144</td>
                <td align="left" rowspan="1" colspan="1">741</td>
                <td align="left" rowspan="1" colspan="1">mediator complex subunit Med5</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF10136</td>
                <td align="left" rowspan="1" colspan="1">317</td>
                <td align="left" rowspan="1" colspan="1">626</td>
                <td align="left" rowspan="1" colspan="1">site-specific recombinase</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF11573</td>
                <td align="left" rowspan="1" colspan="1">204</td>
                <td align="left" rowspan="1" colspan="1">794</td>
                <td align="left" rowspan="1" colspan="1">mediator complex subunit 23</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt110">
            <label/>
            <p>Each set is described by the number of sequences <inline-formula><inline-graphic xlink:href="pone.0088901.e465.jpg"/></inline-formula> and the average sequence length <inline-formula><inline-graphic xlink:href="pone.0088901.e466.jpg"/></inline-formula>.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>For each dataset we calculated sum-of-pairs (SP) and column-scores (TC) measures with a use of Qscore software <xref rid="pone.0088901-Edgar3" ref-type="bibr">[56]</xref>. Note that PREFAB benchmark is constructed in the way that SP and TC are equal. All experiments were divided into two phases. First one consisted in comparing execution times of MSAProbs and QuickProbs stages across different hardware platforms. The results are presented in <xref ref-type="table" rid="pone-0088901-t008">Tables 8</xref>, <xref ref-type="table" rid="pone-0088901-t009">9</xref>, <xref ref-type="table" rid="pone-0088901-t010">10</xref>, and <xref ref-type="table" rid="pone-0088901-t011">11</xref>. We report times for stage I (posterior matrix calculation), III (consistency transformation), IV (construction and refinement of final alignment). Stage II (building a guide tree) is omitted on purpose—its execution times are irrelevant with respect to the other stages and do not differ across hardware platforms. The overall times of algorithm execution are also given. Note, that for benchmark datasets tables present sum of processing times of all sequence sets within benchmarks. SP and TC scores were only used for checking the correctness of QuickProbs and are not reported. In <xref ref-type="table" rid="pone-0088901-t008">Tables 8</xref>, <xref ref-type="table" rid="pone-0088901-t009">9</xref>, and <xref ref-type="table" rid="pone-0088901-t010">10</xref> CPU results represent execution times of MSAProbs, while CPU+GPU configurations correspond to QuickProbs.</p>
      <table-wrap id="pone-0088901-t008" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t008</object-id>
        <label>Table 8</label>
        <caption>
          <title>Execution times for BAliBASE 3 benchmark reported in <inline-formula><inline-graphic xlink:href="pone.0088901.e467.jpg"/></inline-formula> format.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t008-8" xlink:href="pone.0088901.t008"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">Hardware</td>
                <td colspan="2" align="left" rowspan="1">Stage I</td>
                <td colspan="2" align="left" rowspan="1">Stage III</td>
                <td colspan="2" align="left" rowspan="1">Stage IV</td>
                <td colspan="2" align="left" rowspan="1">Total(I-IV)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550</td>
                <td align="left" rowspan="1" colspan="1">39:33</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">5:08</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">9:13</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">53:54</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550 + GeForce 480</td>
                <td align="left" rowspan="1" colspan="1">10:28</td>
                <td align="left" rowspan="1" colspan="1">(×3.8)</td>
                <td align="left" rowspan="1" colspan="1">2:43</td>
                <td align="left" rowspan="1" colspan="1">(×2.2)</td>
                <td align="left" rowspan="1" colspan="1">4:28</td>
                <td align="left" rowspan="1" colspan="1">(×2.1)</td>
                <td align="left" rowspan="1" colspan="1">17:21</td>
                <td align="left" rowspan="1" colspan="1">(×3.1)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550 + GeForce 680</td>
                <td align="left" rowspan="1" colspan="1">4:01</td>
                <td align="left" rowspan="1" colspan="1">(×9.9)</td>
                <td align="left" rowspan="1" colspan="1">2:12</td>
                <td align="left" rowspan="1" colspan="1">(×2.3)</td>
                <td align="left" rowspan="1" colspan="1">4:28</td>
                <td align="left" rowspan="1" colspan="1">(×2.1)</td>
                <td align="left" rowspan="1" colspan="1">10:42</td>
                <td align="left" rowspan="1" colspan="1">(×5.0)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550 + Radeon 7970</td>
                <td align="left" rowspan="1" colspan="1">2:58</td>
                <td align="left" rowspan="1" colspan="1">(×13.3)</td>
                <td align="left" rowspan="1" colspan="1">1:06</td>
                <td align="left" rowspan="1" colspan="1">(×4.7)</td>
                <td align="left" rowspan="1" colspan="1">4:27</td>
                <td align="left" rowspan="1" colspan="1">(×2.1)</td>
                <td align="left" rowspan="1" colspan="1">8:33</td>
                <td align="left" rowspan="1" colspan="1">(×6.3)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon E5-2630</td>
                <td align="left" rowspan="1" colspan="1">30:35</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">2:45</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">10:05</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">43:31</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon E5-2630 + GeForce 680</td>
                <td align="left" rowspan="1" colspan="1">3:43</td>
                <td align="left" rowspan="1" colspan="1">(×8.2)</td>
                <td align="left" rowspan="1" colspan="1">2:10</td>
                <td align="left" rowspan="1" colspan="1">(×1.3)</td>
                <td align="left" rowspan="1" colspan="1">2:56</td>
                <td align="left" rowspan="1" colspan="1">(×3.4)</td>
                <td align="left" rowspan="1" colspan="1">8:51</td>
                <td align="left" rowspan="1" colspan="1">(×4.9)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Phenom II X6</td>
                <td align="left" rowspan="1" colspan="1">51:38</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">5:35</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">11:27</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">68:41</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Phenom II X6 + GeForce 560</td>
                <td align="left" rowspan="1" colspan="1">12:21</td>
                <td align="left" rowspan="1" colspan="1">(×2.9)</td>
                <td align="left" rowspan="1" colspan="1">3:26</td>
                <td align="left" rowspan="1" colspan="1">(×1.6)</td>
                <td align="left" rowspan="1" colspan="1">3:24</td>
                <td align="left" rowspan="1" colspan="1">(×3.3)</td>
                <td align="left" rowspan="1" colspan="1">19:13</td>
                <td align="left" rowspan="1" colspan="1">(×3.1)</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt111">
            <label/>
            <p>Speed-ups of QuickProbs (CPU+GPU) over MSAProbs (CPU) across different hardware configurations are also shown.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="pone-0088901-t009" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t009</object-id>
        <label>Table 9</label>
        <caption>
          <title>Execution times for PREFAB 4 benchmark reported in <inline-formula><inline-graphic xlink:href="pone.0088901.e468.jpg"/></inline-formula> format.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t009-9" xlink:href="pone.0088901.t009"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">Hardware</td>
                <td colspan="2" align="left" rowspan="1">Stage I</td>
                <td colspan="2" align="left" rowspan="1">Stage III</td>
                <td colspan="2" align="left" rowspan="1">Stage IV</td>
                <td colspan="2" align="left" rowspan="1">Total(I-IV)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550</td>
                <td align="left" rowspan="1" colspan="1">169:19</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">16:11</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">23:15</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">208:50</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550 + GeForce 480</td>
                <td align="left" rowspan="1" colspan="1">30:23</td>
                <td align="left" rowspan="1" colspan="1">(×5.6)</td>
                <td align="left" rowspan="1" colspan="1">9:15</td>
                <td align="left" rowspan="1" colspan="1">(×1.8)</td>
                <td align="left" rowspan="1" colspan="1">7:55</td>
                <td align="left" rowspan="1" colspan="1">(×2.9)</td>
                <td align="left" rowspan="1" colspan="1">47:40</td>
                <td align="left" rowspan="1" colspan="1">(×4.4)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550 + GeForce 680</td>
                <td align="left" rowspan="1" colspan="1">13:41</td>
                <td align="left" rowspan="1" colspan="1">(×12.4)</td>
                <td align="left" rowspan="1" colspan="1">8:46</td>
                <td align="left" rowspan="1" colspan="1">(×1.8)</td>
                <td align="left" rowspan="1" colspan="1">8:00</td>
                <td align="left" rowspan="1" colspan="1">(×2.9)</td>
                <td align="left" rowspan="1" colspan="1">30:34</td>
                <td align="left" rowspan="1" colspan="1">(×6.8)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550 + Radeon 7970</td>
                <td align="left" rowspan="1" colspan="1">8:47</td>
                <td align="left" rowspan="1" colspan="1">(×19.2)</td>
                <td align="left" rowspan="1" colspan="1">4:47</td>
                <td align="left" rowspan="1" colspan="1">(×3.4)</td>
                <td align="left" rowspan="1" colspan="1">7:55</td>
                <td align="left" rowspan="1" colspan="1">(×2.9)</td>
                <td align="left" rowspan="1" colspan="1">21:35</td>
                <td align="left" rowspan="1" colspan="1">(×9.7)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon E5-2630</td>
                <td align="left" rowspan="1" colspan="1">130:50</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">9:39</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">23:59</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">164:36</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon E5-2630 + GeForce 680</td>
                <td align="left" rowspan="1" colspan="1">13:31</td>
                <td align="left" rowspan="1" colspan="1">(×9.7)</td>
                <td align="left" rowspan="1" colspan="1">8:42</td>
                <td align="left" rowspan="1" colspan="1">(×1.1)</td>
                <td align="left" rowspan="1" colspan="1">5:21</td>
                <td align="left" rowspan="1" colspan="1">(×4.4)</td>
                <td align="left" rowspan="1" colspan="1">27:42</td>
                <td align="left" rowspan="1" colspan="1">(×5.9)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Phenom</td>
                <td align="left" rowspan="1" colspan="1">231:41</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">18:34</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">31:53</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">282:16</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Phenom + GeForce 560</td>
                <td align="left" rowspan="1" colspan="1">40:01</td>
                <td align="left" rowspan="1" colspan="1">(×5.8)</td>
                <td align="left" rowspan="1" colspan="1">13:47</td>
                <td align="left" rowspan="1" colspan="1">(×1.4)</td>
                <td align="left" rowspan="1" colspan="1">7:36</td>
                <td align="left" rowspan="1" colspan="1">(×4.2)</td>
                <td align="left" rowspan="1" colspan="1">61:29</td>
                <td align="left" rowspan="1" colspan="1">(×4.6)</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt112">
            <label/>
            <p>Speed-ups of QuickProbs (CPU+GPU) over MSAProbs (CPU) across different hardware configurations are also shown.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="pone-0088901-t010" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t010</object-id>
        <label>Table 10</label>
        <caption>
          <title>Execution times for OXBench-X benchmark reported in <inline-formula><inline-graphic xlink:href="pone.0088901.e469.jpg"/></inline-formula> format.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t010-10" xlink:href="pone.0088901.t010"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">Hardware</td>
                <td colspan="2" align="left" rowspan="1">Stage I</td>
                <td colspan="2" align="left" rowspan="1">Stage III</td>
                <td colspan="2" align="left" rowspan="1">Stage IV</td>
                <td colspan="2" align="left" rowspan="1">Total(I-IV)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">speed-up</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550</td>
                <td align="left" rowspan="1" colspan="1">133:49</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">89:12</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">17:36</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">240:58</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550 + GeForce 480</td>
                <td align="left" rowspan="1" colspan="1">12:42</td>
                <td align="left" rowspan="1" colspan="1">(×10.6)</td>
                <td align="left" rowspan="1" colspan="1">77:59</td>
                <td align="left" rowspan="1" colspan="1">(×1.1)</td>
                <td align="left" rowspan="1" colspan="1">6:41</td>
                <td align="left" rowspan="1" colspan="1">(×2.7)</td>
                <td align="left" rowspan="1" colspan="1">98:02</td>
                <td align="left" rowspan="1" colspan="1">(×2.5)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550 + GeForce 680</td>
                <td align="left" rowspan="1" colspan="1">10:36</td>
                <td align="left" rowspan="1" colspan="1">(×12.7)</td>
                <td align="left" rowspan="1" colspan="1">71:28</td>
                <td align="left" rowspan="1" colspan="1">(×1.2)</td>
                <td align="left" rowspan="1" colspan="1">6:44</td>
                <td align="left" rowspan="1" colspan="1">(×2.6)</td>
                <td align="left" rowspan="1" colspan="1">89:26</td>
                <td align="left" rowspan="1" colspan="1">(×2.7)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon W3550 + Radeon 7970</td>
                <td align="left" rowspan="1" colspan="1">7:19</td>
                <td align="left" rowspan="1" colspan="1">(×18.3)</td>
                <td align="left" rowspan="1" colspan="1">27:29</td>
                <td align="left" rowspan="1" colspan="1">(×3.2)</td>
                <td align="left" rowspan="1" colspan="1">6:36</td>
                <td align="left" rowspan="1" colspan="1">(×2.7)</td>
                <td align="left" rowspan="1" colspan="1">42:03</td>
                <td align="left" rowspan="1" colspan="1">(×5.7)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon E5-2630</td>
                <td align="left" rowspan="1" colspan="1">101:03</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">62:55</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">18:09</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">182:41</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Xeon E5-2630 + GeForce 680</td>
                <td align="left" rowspan="1" colspan="1">10:27</td>
                <td align="left" rowspan="1" colspan="1">(×9.7)</td>
                <td align="left" rowspan="1" colspan="1">70:57</td>
                <td align="left" rowspan="1" colspan="1">(×0.9)</td>
                <td align="left" rowspan="1" colspan="1">3:20</td>
                <td align="left" rowspan="1" colspan="1">(×5.4)</td>
                <td align="left" rowspan="1" colspan="1">85:28</td>
                <td align="left" rowspan="1" colspan="1">(×2.1)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Phenom</td>
                <td align="left" rowspan="1" colspan="1">184:03</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">123:25</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">24:35</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">332:23</td>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Phenom + GeForce 560</td>
                <td align="left" rowspan="1" colspan="1">19:19</td>
                <td align="left" rowspan="1" colspan="1">(×9.5)</td>
                <td align="left" rowspan="1" colspan="1">110:50</td>
                <td align="left" rowspan="1" colspan="1">(×1.1)</td>
                <td align="left" rowspan="1" colspan="1">5:46</td>
                <td align="left" rowspan="1" colspan="1">(×4.3)</td>
                <td align="left" rowspan="1" colspan="1">136:04</td>
                <td align="left" rowspan="1" colspan="1">(×2.4)</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt113">
            <label/>
            <p>Speed-ups of QuickProbs (CPU+GPU) over MSAProbs (CPU) across different hardware configurations are also shown.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="pone-0088901-t011" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t011</object-id>
        <label>Table 11</label>
        <caption>
          <title>Detailed results for the real-life datasets from Pfam database.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t011-11" xlink:href="pone.0088901.t011"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">Dataset</td>
                <td colspan="4" align="left" rowspan="1">MSAProbs</td>
                <td colspan="4" align="left" rowspan="1">QuickProbs</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">I</td>
                <td align="left" rowspan="1" colspan="1">III</td>
                <td align="left" rowspan="1" colspan="1">IV</td>
                <td align="left" rowspan="1" colspan="1">Total</td>
                <td align="left" rowspan="1" colspan="1">I</td>
                <td align="left" rowspan="1" colspan="1">III</td>
                <td align="left" rowspan="1" colspan="1">IV</td>
                <td align="left" rowspan="1" colspan="1">Total</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF02324</td>
                <td align="left" rowspan="1" colspan="1">21:30</td>
                <td align="left" rowspan="1" colspan="1">2:39</td>
                <td align="left" rowspan="1" colspan="1">7:08</td>
                <td align="left" rowspan="1" colspan="1">31:17</td>
                <td align="left" rowspan="1" colspan="1">0:59(×22.0)</td>
                <td align="left" rowspan="1" colspan="1">0:25(×6.3)</td>
                <td align="left" rowspan="1" colspan="1">1:10(×6.1)</td>
                <td align="left" rowspan="1" colspan="1">2:34(×12.2)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF04762</td>
                <td align="left" rowspan="1" colspan="1">46:54</td>
                <td align="left" rowspan="1" colspan="1">13:37</td>
                <td align="left" rowspan="1" colspan="1">16:45</td>
                <td align="left" rowspan="1" colspan="1">77:18</td>
                <td align="left" rowspan="1" colspan="1">1:54(× 24.7)</td>
                <td align="left" rowspan="1" colspan="1">3:30(×3.9)</td>
                <td align="left" rowspan="1" colspan="1">4:47(×3.5)</td>
                <td align="left" rowspan="1" colspan="1">10:42(×7.2)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF05110</td>
                <td align="left" rowspan="1" colspan="1">55:36</td>
                <td align="left" rowspan="1" colspan="1">23:13</td>
                <td align="left" rowspan="1" colspan="1">18:34</td>
                <td align="left" rowspan="1" colspan="1">97:27</td>
                <td align="left" rowspan="1" colspan="1">12:22(×4.5)</td>
                <td align="left" rowspan="1" colspan="1">6:27(×3.6)</td>
                <td align="left" rowspan="1" colspan="1">5:20(×3.5)</td>
                <td align="left" rowspan="1" colspan="1">25:32(×3.8)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF07095</td>
                <td align="left" rowspan="1" colspan="1">91:17</td>
                <td align="left" rowspan="1" colspan="1">16:03</td>
                <td align="left" rowspan="1" colspan="1">19:58</td>
                <td align="left" rowspan="1" colspan="1">126:22</td>
                <td align="left" rowspan="1" colspan="1">3:57(×23.0)</td>
                <td align="left" rowspan="1" colspan="1">3:46(×4.3)</td>
                <td align="left" rowspan="1" colspan="1">4:26(×4.3)</td>
                <td align="left" rowspan="1" colspan="1">12:11(×10.3)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF07520</td>
                <td align="left" rowspan="1" colspan="1">39:40</td>
                <td align="left" rowspan="1" colspan="1">5:01</td>
                <td align="left" rowspan="1" colspan="1">14:07</td>
                <td align="left" rowspan="1" colspan="1">58:52</td>
                <td align="left" rowspan="1" colspan="1">1:42(×23.3)</td>
                <td align="left" rowspan="1" colspan="1">0:39(×7.7)</td>
                <td align="left" rowspan="1" colspan="1">2:29(×5.7)</td>
                <td align="left" rowspan="1" colspan="1">4:53(×12.1)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF08689</td>
                <td align="left" rowspan="1" colspan="1">7:16</td>
                <td align="left" rowspan="1" colspan="1">1:20</td>
                <td align="left" rowspan="1" colspan="1">2:33</td>
                <td align="left" rowspan="1" colspan="1">1:09</td>
                <td align="left" rowspan="1" colspan="1">0:23(×18.7)</td>
                <td align="left" rowspan="1" colspan="1">0:13(×6.3)</td>
                <td align="left" rowspan="1" colspan="1">0:35(×4.4)</td>
                <td align="left" rowspan="1" colspan="1">1:12(×9.3)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF10136</td>
                <td align="left" rowspan="1" colspan="1">25:19</td>
                <td align="left" rowspan="1" colspan="1">4:24</td>
                <td align="left" rowspan="1" colspan="1">4:42</td>
                <td align="left" rowspan="1" colspan="1">34:26</td>
                <td align="left" rowspan="1" colspan="1">1:10(×21.6)</td>
                <td align="left" rowspan="1" colspan="1">1:05(×4.1)</td>
                <td align="left" rowspan="1" colspan="1">1:14(×3.8)</td>
                <td align="left" rowspan="1" colspan="1">3:37(×9.5)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PF11573</td>
                <td align="left" rowspan="1" colspan="1">16:50</td>
                <td align="left" rowspan="1" colspan="1">2:33</td>
                <td align="left" rowspan="1" colspan="1">6:02</td>
                <td align="left" rowspan="1" colspan="1">5:25</td>
                <td align="left" rowspan="1" colspan="1">6:53(×2.4)</td>
                <td align="left" rowspan="1" colspan="1">0:19(×8.0)</td>
                <td align="left" rowspan="1" colspan="1">1:07(×5.4)</td>
                <td align="left" rowspan="1" colspan="1">8:20(×3.0)</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">All</td>
                <td align="left" rowspan="1" colspan="1">304:22</td>
                <td align="left" rowspan="1" colspan="1">68:54</td>
                <td align="left" rowspan="1" colspan="1">88:49</td>
                <td align="left" rowspan="1" colspan="1">462:16</td>
                <td align="left" rowspan="1" colspan="1">29:20(×10.4)</td>
                <td align="left" rowspan="1" colspan="1">16:24(×4.2)</td>
                <td align="left" rowspan="1" colspan="1">21:08(×4.2)</td>
                <td align="left" rowspan="1" colspan="1">69:01(×6.7)</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt114">
            <label/>
            <p>Times are given in <inline-formula><inline-graphic xlink:href="pone.0088901.e470.jpg"/></inline-formula> format.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The aim of the second experimental step was to compare base QuickProbs version and its accurate variant QuickProbs-acc with competing algorithms. SP and TC were used as quality measures and are reported together with total execution times in <xref ref-type="table" rid="pone-0088901-t012">Table 12</xref>. Experiments were carried out on a machine equipped with Xeon W3550 and Radeon 7970. Packages that were chosen for experiments are MSAProbs 0.9.7, ClustalW v2.1, Clustal<inline-formula><inline-graphic xlink:href="pone.0088901.e471.jpg"/></inline-formula> v1.2.0, Kalign2 v2.04, Kalign-LCS v1.0, MAFFT v7.053b, and MUSCLE v3.8.31. ClustalW was executed in the default and fast mode (distances calculated using full pairwise alignments and <inline-formula><inline-graphic xlink:href="pone.0088901.e472.jpg"/></inline-formula>-tuple matches, respectively). MAFFT was run in the default mode without consistency and auto mode which selectively turns consistency on. MSAProbs algorithm in both experimental parts was compiled with a use of MinGW compiler due to support of long double floating-point precision which is used in the implementation. Additionally, we examined MSA-CUDA, a ClustalW variant suited for graphics processors. As CUDA is not supported by AMD GPUs, MSA-CUDA was run on a platform with Xeon W3550 and GeForce 680.</p>
      <table-wrap id="pone-0088901-t012" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0088901.t012</object-id>
        <label>Table 12</label>
        <caption>
          <title>Qualitative results for BAliBASE, PREFAB, and OXBench-X run on Xeon W3550 + Radeon 7970 (GeForce 680 was used for MSA-CUDA).</title>
        </caption>
        <alternatives>
          <graphic id="pone-0088901-t012-12" xlink:href="pone.0088901.t012"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">Algorithm</td>
                <td colspan="3" align="left" rowspan="1">BAliBASE</td>
                <td colspan="2" align="left" rowspan="1">PREFAB</td>
                <td colspan="3" align="left" rowspan="1">OXBench-X</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">SP</td>
                <td align="left" rowspan="1" colspan="1">TC</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">SP/TC</td>
                <td align="left" rowspan="1" colspan="1">time</td>
                <td align="left" rowspan="1" colspan="1">SP</td>
                <td align="left" rowspan="1" colspan="1">TC</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">QuickProbs-acc</td>
                <td align="left" rowspan="1" colspan="1">28:19</td>
                <td align="left" rowspan="1" colspan="1">87.9</td>
                <td align="left" rowspan="1" colspan="1">60.8</td>
                <td align="left" rowspan="1" colspan="1">64:48</td>
                <td align="left" rowspan="1" colspan="1">74.0</td>
                <td align="left" rowspan="1" colspan="1">255:36</td>
                <td align="left" rowspan="1" colspan="1">89.3</td>
                <td align="left" rowspan="1" colspan="1">80.2</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">MSAProbs</td>
                <td align="left" rowspan="1" colspan="1">53:54</td>
                <td align="left" rowspan="1" colspan="1">87.8</td>
                <td align="left" rowspan="1" colspan="1">60.8</td>
                <td align="left" rowspan="1" colspan="1">208:50</td>
                <td align="left" rowspan="1" colspan="1">73.7</td>
                <td align="left" rowspan="1" colspan="1">240:58</td>
                <td align="left" rowspan="1" colspan="1">89.1</td>
                <td align="left" rowspan="1" colspan="1">80.0</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">QuickProbs</td>
                <td align="left" rowspan="1" colspan="1">8:33</td>
                <td align="left" rowspan="1" colspan="1">87.8</td>
                <td align="left" rowspan="1" colspan="1">60.7</td>
                <td align="left" rowspan="1" colspan="1">21:35</td>
                <td align="left" rowspan="1" colspan="1">73.6</td>
                <td align="left" rowspan="1" colspan="1">42:03</td>
                <td align="left" rowspan="1" colspan="1">89.1</td>
                <td align="left" rowspan="1" colspan="1">80.0</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">MAFFT-auto</td>
                <td align="left" rowspan="1" colspan="1">21:49</td>
                <td align="left" rowspan="1" colspan="1">86.7</td>
                <td align="left" rowspan="1" colspan="1">58.3</td>
                <td align="left" rowspan="1" colspan="1">77:49</td>
                <td align="left" rowspan="1" colspan="1">72.3</td>
                <td align="left" rowspan="1" colspan="1">22:01</td>
                <td align="left" rowspan="1" colspan="1">87.7</td>
                <td align="left" rowspan="1" colspan="1">78.4</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Clustal<inline-formula><inline-graphic xlink:href="pone.0088901.e473.jpg"/></inline-formula>
</td>
                <td align="left" rowspan="1" colspan="1">7:33</td>
                <td align="left" rowspan="1" colspan="1">83.6</td>
                <td align="left" rowspan="1" colspan="1">54.8</td>
                <td align="left" rowspan="1" colspan="1">23:07</td>
                <td align="left" rowspan="1" colspan="1">70.0</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">—</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">MUSCLE</td>
                <td align="left" rowspan="1" colspan="1">15:17</td>
                <td align="left" rowspan="1" colspan="1">81.7</td>
                <td align="left" rowspan="1" colspan="1">46.8</td>
                <td align="left" rowspan="1" colspan="1">40:38</td>
                <td align="left" rowspan="1" colspan="1">67.7</td>
                <td align="left" rowspan="1" colspan="1">30:36</td>
                <td align="left" rowspan="1" colspan="1">87.5</td>
                <td align="left" rowspan="1" colspan="1">77.6</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Kalign-LCS</td>
                <td align="left" rowspan="1" colspan="1">0:27</td>
                <td align="left" rowspan="1" colspan="1">82.9</td>
                <td align="left" rowspan="1" colspan="1">50.4</td>
                <td align="left" rowspan="1" colspan="1">1:47</td>
                <td align="left" rowspan="1" colspan="1">65.9</td>
                <td align="left" rowspan="1" colspan="1">0:36</td>
                <td align="left" rowspan="1" colspan="1">86.8</td>
                <td align="left" rowspan="1" colspan="1">76.4</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">MAFTT-default</td>
                <td align="left" rowspan="1" colspan="1">3:47</td>
                <td align="left" rowspan="1" colspan="1">81.3</td>
                <td align="left" rowspan="1" colspan="1">46.2</td>
                <td align="left" rowspan="1" colspan="1">24:54</td>
                <td align="left" rowspan="1" colspan="1">67.7</td>
                <td align="left" rowspan="1" colspan="1">6:02</td>
                <td align="left" rowspan="1" colspan="1">86.1</td>
                <td align="left" rowspan="1" colspan="1">75.6</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">Kalign2</td>
                <td align="left" rowspan="1" colspan="1">0:39</td>
                <td align="left" rowspan="1" colspan="1">81.4</td>
                <td align="left" rowspan="1" colspan="1">47.5</td>
                <td align="left" rowspan="1" colspan="1">1:58</td>
                <td align="left" rowspan="1" colspan="1">64.9</td>
                <td align="left" rowspan="1" colspan="1">0:56</td>
                <td align="left" rowspan="1" colspan="1">85.7</td>
                <td align="left" rowspan="1" colspan="1">75.1</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">ClustalW</td>
                <td align="left" rowspan="1" colspan="1">27:22</td>
                <td align="left" rowspan="1" colspan="1">75.8</td>
                <td align="left" rowspan="1" colspan="1">38.3</td>
                <td align="left" rowspan="1" colspan="1">124:30</td>
                <td align="left" rowspan="1" colspan="1">61.9</td>
                <td align="left" rowspan="1" colspan="1">89:36</td>
                <td align="left" rowspan="1" colspan="1">85.3</td>
                <td align="left" rowspan="1" colspan="1">74.2</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">ClustalW-quicktree</td>
                <td align="left" rowspan="1" colspan="1">6:25</td>
                <td align="left" rowspan="1" colspan="1">73.7</td>
                <td align="left" rowspan="1" colspan="1">37.1</td>
                <td align="left" rowspan="1" colspan="1">22:19</td>
                <td align="left" rowspan="1" colspan="1">61.9</td>
                <td align="left" rowspan="1" colspan="1">8:04</td>
                <td align="left" rowspan="1" colspan="1">84.9</td>
                <td align="left" rowspan="1" colspan="1">73.8</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">MSA-CUDA</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">—</td>
                <td align="left" rowspan="1" colspan="1">27:01</td>
                <td align="left" rowspan="1" colspan="1">61.7</td>
                <td align="left" rowspan="1" colspan="1">9:07</td>
                <td align="left" rowspan="1" colspan="1">85.3</td>
                <td align="left" rowspan="1" colspan="1">74.1</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">MSA-CUDA-quicktree</td>
                <td align="left" rowspan="1" colspan="1">3:20</td>
                <td align="left" rowspan="1" colspan="1">72.9</td>
                <td align="left" rowspan="1" colspan="1">36.9</td>
                <td align="left" rowspan="1" colspan="1">13:31</td>
                <td align="left" rowspan="1" colspan="1">61.6</td>
                <td align="left" rowspan="1" colspan="1">7:03</td>
                <td align="left" rowspan="1" colspan="1">85.0</td>
                <td align="left" rowspan="1" colspan="1">74.0</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt115">
            <label/>
            <p>Aligners are sorted according to the average quality rank. Times are given in <inline-formula><inline-graphic xlink:href="pone.0088901.e474.jpg"/></inline-formula> format.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec id="s3b">
      <title>Benchmark datasets: central processor running times</title>
      <p>The first observation when analysing results for benchmark datasets from <xref ref-type="table" rid="pone-0088901-t008">Tables 8</xref>, <xref ref-type="table" rid="pone-0088901-t009">9</xref>, and <xref ref-type="table" rid="pone-0088901-t010">10</xref> is that relative execution times of original MSAProbs agree with relative theoretical computational power of CPUs used in the experiments. Xeon E5-2630 is the fastest central processor and it outperforms Xeon W3550 and Phenom II X6, respectively second and third CPU in the comparison. Nevertheless, when analysing results of stage IV of MSAProbs which is implemented in serial manner, it is apparent that quad-core Xeon performs better than its hexa-core counterpart. This can be explained by the fact, that single core of Xeon W3550 has a higher clock rate and is faster than E5-2630 even though the latter represents a newer CPU generation. When stage IV is parallelised with a use of OpenMP, as it is done in QuickProbs, E5-2630 takes the first place. An interesting observation is, that Phenom performs in this situation better than Xeon W3550. We believe, this may be caused by the memory access pattern in this part of the algorithm that prefers AMD CPU cache architecture over competitor. Another important conclusion is that parallel variant of stage IV does not scale perfectly with the number of cores—speed-ups with respect to the serial version are always lower. This is probably because some parts of stage IV were not subject to an OpenMP parallelisation and run for the same time independently of the number of cores.</p>
    </sec>
    <sec id="s3c">
      <title>Benchmark datasets: graphics processor running times</title>
      <p>The shortest absolute execution times of analyses as well as highest speed-ups with respect to the original MSAProbs were obtained by Xeon W3550 + Radeon 7970 platform (see <xref ref-type="table" rid="pone-0088901-t008">Tables 8</xref>, <xref ref-type="table" rid="pone-0088901-t009">9</xref>, <xref ref-type="table" rid="pone-0088901-t010">10</xref>). This coincides with a fact that Radeon has the greatest computational power from the examined GPUs. Since computations executed at graphic processor dominate in terms of execution time over CPU-parallel steps, this configuration is superior to the machine with faster CPU and slower GPU (E5-2630 + GeForce 680).</p>
      <p>When detailed results for particular stages are analysed, the highest speed-ups are obtained for stage I. For Xeon W3550 + Radeon 7970 they vary from 13.3 (BAliBASE) to 19.2 (PREFAB). GeForce 680 turned out to be slower with speed-ups varying from 9.9 to 12.7. On hexa-core Xeon machine speed-ups are lower, but execution times are still superior to the original MSAProbs. Interesting observation comes from analysis of times obtained by GeForce 480 and 560, which are noticeably smaller than is suggested by the difference in computational power. After deeper investigation it became clear that the problem is caused by a number of registers in these GPUs which limits maximum size of a workgroup <inline-formula><inline-graphic xlink:href="pone.0088901.e475.jpg"/></inline-formula> from 1024 to 576. Task can be processed at graphics processor if shorter of its sequence does not exceed <inline-formula><inline-graphic xlink:href="pone.0088901.e476.jpg"/></inline-formula>. Therefore, smaller workgroups reduce performance as many tasks have to be calculated at CPU instead of GPU. Additionally, they limit occupancy for tasks executed at graphics processor preventing GPU computational power from full utilisation. In the case of stage III speed-ups of QuickProbs algorithm with respect to MSAProbs are lower than in stage I. For BAliBASE, PREFAB, and OXBench-X benchmarks run on quad-core CPU and Radeon 7970 they equal 4.7, 3.4, and 3.2, respectively. Significantly worse results were observed for GeForce 680 which indicates that parallelisation scheme of stage III prefers architecture of AMD GPUs. Another interesting observation is that differences between GeForce 480 cards and GeForce 680 are smaller than in the case of stage I. The explanation is that relaxation procedure is not limited by the register count. The worst speed-ups were reported for OXBench-X that contains large sets having hundreds of sequences. The consistency stage executed at GPU is vulnerable for divergence in width of sparse rows of input matrices. For large sets, the divergence is significant, thus lots of computational power is wasted resulting in lower speed-ups.</p>
    </sec>
    <sec id="s3d">
      <title>Pfam datasets running times</title>
      <p>Experiments on real protein families were performed on our fastest testing platform equipped with Xeon W3550 CPU and Radeon 7970 GPU. Results are presented in <xref ref-type="table" rid="pone-0088901-t011">Table 11</xref>. As in benchmark datasets, the best speed-ups are observed for stage I—in the majority of cases they exceed 20 with a maximum value of 24.7. The only exceptions are PF05110 and PF11573 with speed-ups equal to 4.5 and 2.4, respectively. This is caused by the presence of long sequences (<inline-formula><inline-graphic xlink:href="pone.0088901.e477.jpg"/></inline-formula>) that are processed on the CPU and dominate whole posterior calculation stage. Speed-ups for stage III are smaller which also coincides with the benchmark results. They vary from 3.6 to 8.0. In the case of stage IV which was parallelised for multi-core CPUs, execution times are 3.5 to 6.1 times shorter than in MSAProbs. An interesting fact is that for the majority of datasets speed-ups exceed 4, the number of physical cores in our testing platform. This differs from benchmark results where speed-ups were always lower than number of cores. There are many reasons for this. Firstly, families from Pfam are much larger than benchmark sequence sets, thus proportions between parallel and serial operations are better. Thanks to this, the modification that improved cache utilisation is also more beneficial. Finally, Xeon W3550 CPU is equipped with a hyper-threading technology which increases task parallelism of a single core. The overall QuickProbs speed-up on all families equals 6.7. One must keep in mind, that this result is strongly skewed by PF05110 and PF11573 sets for which performance is limited by the presence of long sequences (stage I is the most time consuming part of the algorithm). If we exclude them from the comparison, the speed-up increases to 9.7.</p>
    </sec>
    <sec id="s3e">
      <title>Comparison with other methods</title>
      <p>Aligners from <xref ref-type="table" rid="pone-0088901-t012">Table 12</xref> were ranked on all datasets according to the result quality (SP and TC can be used interchangeably for this purpose as they generate identical ranks), and ordered by the average rank. The first group of algorithms gathers most accurate, consistency-based methods: QuickProbs in base and accurate variant, MSAProbs, and MAFFT-auto. The best aligner in terms of result quality is QuickProbs-acc which is superior to MSAProbs, the most accurate method so far. In order to statistically analyse observed differences in SP and TC, we performed Wilcoxon signed-rank tests <xref rid="pone.0088901-Wilcoxon1" ref-type="bibr">[57]</xref> at the significance level <inline-formula><inline-graphic xlink:href="pone.0088901.e478.jpg"/></inline-formula>. If one considers entire benchmarks, the significance was reported for PREFAB only (<inline-formula><inline-graphic xlink:href="pone.0088901.e479.jpg"/></inline-formula>-value = 0.000491). However, we suspected that adaptive filtering of sparse matrices used by QuickProbs-acc would be beneficial mainly for distantly related sequences, where static <inline-formula><inline-graphic xlink:href="pone.0088901.e480.jpg"/></inline-formula> may result in the information loss. Therefore, we clustered sets in benchmarks according to the average sequence identity and analysed differences on groups. In the case of OXBench-X it turned out that for 94 sets from twilight zone (average identity below 30%), the predominance of QuickProbs-acc with respect to MSAProbs was statistically significant (<inline-formula><inline-graphic xlink:href="pone.0088901.e481.jpg"/></inline-formula>-values equalled to 0.002074 and 0.024536 for SP and TC, respectively). Same analysis performed for PREFAB also revealed strong evidence that QuickProbs-acc is particularly suited for distantly related sequences: <inline-formula><inline-graphic xlink:href="pone.0088901.e482.jpg"/></inline-formula>-value for 535 twilight sets was two orders of magnitude lower than in the case of whole benchmark and equalled 0.000004. In the case of BAliBASE dataset, we compared different RV groups but no significant differences were discovered. An important observation is that all these results were obtained without exceeding MSAProbs execution times (in the case of BAliBASE and PREFAB QuickProbs-acc was much faster, for OXBench-X it was only 6% slower). This is important, since MSAProbs is the most time consuming from all tested algorithms.</p>
      <p>In cases where MSAProbs accuracy is sufficient, default mode of QuickProbs should be used as it produces almost identical results as MSAProbs, at a fraction of the time. Small discrepancy in accuracies is caused by using double floating-point precision in partition function calculation at GPU instead of long double. This was confirmed by the fact, that MSAProbs compiled without long double support gives exactly the same results as QuickProbs. Fourth aligner in terms of quality rank was MAFFT in automatic mode. Additionally, it turned out to be slower than QuickProbs on BAliBASE and PREFAB benchmarks.</p>
      <p>Second group of packages consists of algorithms without consistency: Clustal<inline-formula><inline-graphic xlink:href="pone.0088901.e483.jpg"/></inline-formula>, Kalign-LCS, MUSCLE, MAFTT-default, Kalign2, and ClustalW. The first from aforementioned methods, Clustal<inline-formula><inline-graphic xlink:href="pone.0088901.e484.jpg"/></inline-formula> produces the best results on BAliBASE and PREFAB datasets, however, it failed to run properly on OXBench-X. The best algorithm which executed successfully on all datasets is MUSCLE. Its execution times may be an issue in some applications, though. Kalign-LCS, the modification of Kalign2, is inferior to MUSCLE only by a small margin. Moreover, it is the fastest method in the comparison outperforming also CUDA-based algorithms, which makes it the best choice when one is interested in aligning large sets of sequences. An interesting observation is that ClustalW performs significantly worse than other aligners in comparison. Taking into account relatively long execution times, it is clear that ClustalW, still the most popular MSA software, should be replaced in biological analyses by other packages. The ClustalW variant suited for GPU processing (MSA-CUDA) is characterised by much shorter execution times. Nevertheless, it is still inferior to fast and more accurate CPU aligners like Kalign-LCS. Additionally, its default variant failed to execute properly on BAliBASE benchmark.</p>
    </sec>
  </sec>
  <sec id="s4">
    <title>Discussion</title>
    <p>In the paper we present QuickProbs, a variant of MSAProbs algorithm suited for graphics processors. We designed and implemented GPU versions of two most time consuming stages of the strategy, which originally were customised for multi-core architecture with the use of OpenMP. These are the calculation of posterior probability matrices and the consistency transformation. Posterior matrices are calculated on the basis of pair hidden Markov models and partition functions. From algorithmic point of view the stage performs several dynamic programming passes. Customising computation scheme to massively parallel GPU architecture, optimising global memory accesses by using jagged pattern and exploiting advanced method of work balancing resulted in significant speed-ups at this stage. On the main testing platform equipped with a quad-core Xeon W3550 and Radeon 7970, QuickProbs calculated posterior matrices as much as 24.7 times faster than original CPU-parallel method. The consistency transformation stage relies on performing set of small sparse matrix multiplications. We designed an algorithm for this purpose customised for graphics processors. As experiments on the basic testing platform show, it outperforms its MSAProbs equivalent with speed-ups reaching 8.0. In order to further improve execution times, we additionally suited the last stage of QuickProbs for multi-core CPU architectures with a use of OpenMP. Thanks to this, the construction and refinement of final alignment is done even 6.1 times faster than previously.</p>
    <p>Assessed on BAliBASE, PREFAB, and OXBench-X benchmarks, QuickProbs turned out to be respectively, 6.3, 9.7, and 5.7 times faster than MSAProbs. In the experiments on protein families from Pfam database, the overall speed-up was 6.7. This makes QuickProbs competitive to faster aligners like MAFFT, Clustal<inline-formula><inline-graphic xlink:href="pone.0088901.e485.jpg"/></inline-formula>, or MUSCLE. In the research we additionally introduced QuickProbs-acc, a tuned version of QuickProbs which is significantly more accurate than MSAProbs on sequence sets from twilight zone (identity <inline-formula><inline-graphic xlink:href="pone.0088901.e486.jpg"/></inline-formula> 30%) without exceeding its running time. Unlike previously published GPU-suited multiple sequence alignment methods, computations in QuickProbs algorithm are performed in OpenCL making it suitable for graphics processors produced by both main vendors, NVidia and AMD.</p>
    <p>Our future plans focuses three main tasks: (1) removing limitation of sequence lengths that can be processed at GPU at posterior stage, (2) redesigning consistency transformation to make it less vulnerable for divergence in sparse rows lengths, (3) customising final alignment construction and refinement procedures for graphics processors.</p>
    <p>QuickProbs algorithm together with all the datasets used in the research are available at <ext-link ext-link-type="uri" xlink:href="http://adaa.polsl.pl/agudys/quickprobs/quickprobs.htm">http://adaa.polsl.pl/agudys/quickprobs/quickprobs.htm</ext-link>. The detailed analysis of the time complexity of MSAProbs and QuickProbs can be found in the <xref ref-type="supplementary-material" rid="pone.0088901.s001">Supplement S1</xref>.</p>
  </sec>
  <sec sec-type="supplementary-material" id="s5">
    <title>Supporting Information</title>
    <supplementary-material content-type="local-data" id="pone.0088901.s001">
      <label>Supplement S1</label>
      <caption>
        <p>
          <bold>Detailed analysis of MSAProbs and QuickProbs time complexities.</bold>
        </p>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pone.0088901.s001.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <p>We wish to thank Adam Adamarek for proofreading the manuscript.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="pone.0088901-Wang1">
      <label>1</label>
      <mixed-citation publication-type="journal"><name><surname>Wang</surname><given-names>L</given-names></name>, <name><surname>Jiang</surname><given-names>T</given-names></name> (<year>1994</year>) <article-title>On the complexity of multiple sequence alignment</article-title>. <source>Journal of Computational Biology</source>
<volume>1</volume>: <fpage>337</fpage>–<lpage>348</lpage>.<pub-id pub-id-type="pmid">8790475</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Just1">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Just</surname><given-names>W</given-names></name> (<year>1999</year>) <article-title>Computational complexity of multiple sequence alignment with SP-Score</article-title>. <source>Journal of Computational Biology</source>
<volume>8</volume>: <fpage>615</fpage>–<lpage>623</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Feng1">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Feng</surname><given-names>DF</given-names></name>, <name><surname>Doolittle</surname><given-names>RF</given-names></name> (<year>1987</year>) <article-title>Progressive sequence alignment as a prerequisite to correct phylogenetic trees</article-title>. <source>Journal of Molecular Evolution</source>
<volume>25</volume>: <fpage>351</fpage>–<lpage>360</lpage>.<pub-id pub-id-type="pmid">3118049</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Barton1">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Barton</surname><given-names>GJ</given-names></name>, <name><surname>Sternberg</surname><given-names>MJ</given-names></name> (<year>1987</year>) <article-title>A strategy for the rapid multiple alignment of protein sequences. Confidence levels from tertiary structure comparisons</article-title>. <source>Journal of Molecular Biology</source>
<volume>198</volume>: <fpage>327</fpage>–<lpage>337</lpage>.<pub-id pub-id-type="pmid">3430611</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Krogh1">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Krogh</surname><given-names>A</given-names></name>, <name><surname>Brown</surname><given-names>M</given-names></name>, <name><surname>Mian</surname><given-names>IS</given-names></name>, <name><surname>Sjölander</surname><given-names>K</given-names></name>, <name><surname>Haussler</surname><given-names>D</given-names></name> (<year>1994</year>) <article-title>Hidden Markov models in computational biology: applications to protein modeling</article-title>. <source>Journal of Molecular Biology</source>
<volume>235</volume>: <fpage>1501</fpage>–<lpage>1531</lpage>.<pub-id pub-id-type="pmid">8107089</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Thompson1">
      <label>6</label>
      <mixed-citation publication-type="journal"><name><surname>Thompson</surname><given-names>JD</given-names></name>, <name><surname>Higgins</surname><given-names>DG</given-names></name>, <name><surname>Gibson</surname><given-names>TJ</given-names></name> (<year>1994</year>) <article-title>CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice</article-title>. <source>Nucleic Acids Research</source>
<volume>22</volume>: <fpage>4673</fpage>–<lpage>4680</lpage>.<pub-id pub-id-type="pmid">7984417</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Notredame1">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Notredame</surname><given-names>C</given-names></name>, <name><surname>Higgins</surname><given-names>D</given-names></name>, <name><surname>Heringa</surname><given-names>J</given-names></name> (<year>2000</year>) <article-title>T-Coffee: A novel method for fast and accurate multiple sequence alignment</article-title>. <source>Journal of Molecular Biology</source>
<volume>302</volume>: <fpage>205</fpage>–<lpage>217</lpage>.<pub-id pub-id-type="pmid">10964570</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Katoh1">
      <label>8</label>
      <mixed-citation publication-type="journal"><name><surname>Katoh</surname><given-names>K</given-names></name>, <name><surname>Misawa</surname><given-names>K</given-names></name>, <name><surname>Kuma</surname><given-names>K</given-names></name>, <name><surname>Miyata</surname><given-names>T</given-names></name> (<year>2002</year>) <article-title>MAFFT: a novel method for rapid multiple sequence alignment based on fast Fourier transform</article-title>. <source>Nucleic Acids Research</source>
<volume>30</volume>: <fpage>3059</fpage>–<lpage>3066</lpage>.<pub-id pub-id-type="pmid">12136088</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Edgar1">
      <label>9</label>
      <mixed-citation publication-type="journal"><name><surname>Edgar</surname><given-names>RC</given-names></name> (<year>2004</year>) <article-title>MUSCLE: multiple sequence alignment with high accuracy and high throughput</article-title>. <source>Nucleic Acids Research</source>
<volume>32</volume>: <fpage>1792</fpage>–<lpage>1797</lpage>.<pub-id pub-id-type="pmid">15034147</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Do1">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Do</surname><given-names>C</given-names></name>, <name><surname>Mahabhashyam</surname><given-names>M</given-names></name>, <name><surname>Brudno</surname><given-names>M</given-names></name>, <name><surname>Batzoglou</surname><given-names>S</given-names></name> (<year>2005</year>) <article-title>ProbCons: Probabilistic consistencybased multiple sequence alignment</article-title>. <source>Genome Research</source>
<volume>15</volume>: <fpage>330</fpage>–<lpage>340</lpage>.<pub-id pub-id-type="pmid">15687296</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Roshan1">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Roshan</surname><given-names>U</given-names></name>, <name><surname>Livesay</surname><given-names>DR</given-names></name> (<year>2006</year>) <article-title>Probalign: multiple sequence alignment using partition function posterior probabilities</article-title>. <source>Bioinformatics</source>
<volume>22</volume>: <fpage>2715</fpage>–<lpage>2721</lpage>.<pub-id pub-id-type="pmid">16954142</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Liu1">
      <label>12</label>
      <mixed-citation publication-type="journal"><name><surname>Liu</surname><given-names>Y</given-names></name>, <name><surname>Schmidt</surname><given-names>B</given-names></name>, <name><surname>Maskell</surname><given-names>D</given-names></name> (<year>2010</year>) <article-title>MSAProbs: multiple sequence alignment based on pair hidden Markov models and partition function posterior probabilities</article-title>. <source>Bioinformatics</source>
<volume>26</volume>: <fpage>1958</fpage>–<lpage>1964</lpage>.<pub-id pub-id-type="pmid">20576627</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-OSullivan1">
      <label>13</label>
      <mixed-citation publication-type="journal"><name><surname>O′Sullivan</surname><given-names>O</given-names></name>, <name><surname>Suhre</surname><given-names>K</given-names></name>, <name><surname>Abergel</surname><given-names>C</given-names></name>, <name><surname>Higgins</surname><given-names>D</given-names></name>, <name><surname>Notredame</surname><given-names>C</given-names></name> (<year>2004</year>) <article-title>3DCoffee: Combining protein sequences and structures within multiple sequence alignments</article-title>. <source>Journal of Molecular Biology</source>
<volume>340</volume>: <fpage>385</fpage>–<lpage>395</lpage>.<pub-id pub-id-type="pmid">15201059</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Deng1">
      <label>14</label>
      <mixed-citation publication-type="journal"><name><surname>Deng</surname><given-names>X</given-names></name>, <name><surname>Cheng</surname><given-names>J</given-names></name> (<year>2011</year>) <article-title>MSACompro: protein multiple sequence alignment using predicted secondary structure, solvent accessibility, and residue-residue contacts</article-title>. <source>BMC Bioinformatics</source>
<volume>12</volume>: <fpage>472</fpage>.<pub-id pub-id-type="pmid">22168237</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Katoh2">
      <label>15</label>
      <mixed-citation publication-type="journal"><name><surname>Katoh</surname><given-names>K</given-names></name>, <name><surname>Kuma</surname><given-names>Ki</given-names></name>, <name><surname>Toh</surname><given-names>H</given-names></name>, <name><surname>Miyata</surname><given-names>T</given-names></name> (<year>2005</year>) <article-title>MAFFT version 5: improvement in accuracy of multiple sequence alignment</article-title>. <source>Nucleic Acids Research</source>
<volume>33</volume>: <fpage>511</fpage>–<lpage>518</lpage>.<pub-id pub-id-type="pmid">15661851</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-HuertaCepas1">
      <label>16</label>
      <mixed-citation publication-type="journal"><name><surname>Huerta-Cepas</surname><given-names>J</given-names></name>, <name><surname>Capella-Gutierrez</surname><given-names>S</given-names></name>, <name><surname>Pryszcz</surname><given-names>LP</given-names></name>, <name><surname>Denisov</surname><given-names>I</given-names></name>, <name><surname>Kormes</surname><given-names>D</given-names></name>, <etal>et al</etal> (<year>2011</year>) <article-title>PhylomeDB v3.0: an expanding repository of genome-wide collections of trees, alignments and phylogeny-based orthology and paralogy predictions</article-title>. <source>Nucleic Acids Research</source>
<volume>39</volume>: <fpage>556</fpage>–<lpage>560</lpage>.<pub-id pub-id-type="pmid">20852259</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-CapellaGutierrez1">
      <label>17</label>
      <mixed-citation publication-type="other">Capella-Gutierrez S (2012) Analysis of multiple protein sequence alignments and phylogenetic trees in the context of phylogenomics studies. Pompeu Fabra UniversityPh.D. thesis</mixed-citation>
    </ref>
    <ref id="pone.0088901-Lassmann1">
      <label>18</label>
      <mixed-citation publication-type="journal"><name><surname>Lassmann</surname><given-names>T</given-names></name>, <name><surname>Sonnhammer</surname><given-names>E</given-names></name> (<year>2005</year>) <article-title>Kalign|an accurate and fast multiple sequence alignment algorithm</article-title>. <source>BMC Bioinformatics</source>
<volume>6</volume>: <fpage>298</fpage>.<pub-id pub-id-type="pmid">16343337</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Lassmann2">
      <label>19</label>
      <mixed-citation publication-type="journal"><name><surname>Lassmann</surname><given-names>T</given-names></name>, <name><surname>Frings</surname><given-names>O</given-names></name>, <name><surname>Sonnhammer</surname><given-names>E</given-names></name> (<year>2009</year>) <article-title>Kalign2: high-performance multiple alignment of protein and nucleotide sequences allowing external features</article-title>. <source>Nucleic Acids Research</source>
<volume>37</volume>: <fpage>858</fpage>–<lpage>865</lpage>.<pub-id pub-id-type="pmid">19103665</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Wu1">
      <label>20</label>
      <mixed-citation publication-type="journal"><name><surname>Wu</surname><given-names>S</given-names></name>, <name><surname>Manber</surname><given-names>U</given-names></name> (<year>1992</year>) <article-title>Fast text searching: allowing errors</article-title>. <source>Communications of the ACM</source>
<volume>35</volume>: <fpage>83</fpage>–<lpage>91</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Muth1">
      <label>21</label>
      <mixed-citation publication-type="other">Muth R, Manber U (1996) Approximate multiple string search. In: Proceedings of the 7th Annual Symposium on Combinatorial Pattern Matching. pp. 75-86.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Deorowicz1">
      <label>22</label>
      <mixed-citation publication-type="other">Deorowicz S, Debudaj-Grabysz A, Gudyś A (2014) Kalign-LCS|more accurate and faster variant of Kalign2 algorithm for the multiple sequence alignment problem. In: Man-Machine Interactions 3, Springer Cham Heidelberg New York Dordrecht London. pp. 495-502.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Katoh3">
      <label>23</label>
      <mixed-citation publication-type="journal"><name><surname>Katoh</surname><given-names>K</given-names></name>, <name><surname>Toh</surname><given-names>H</given-names></name> (<year>2007</year>) <article-title>Parttree: an algorithm to build an approximate tree from a large number of unaligned sequences</article-title>. <source>Bioinformatics</source>
<volume>23</volume>: <fpage>372</fpage>–<lpage>374</lpage>.<pub-id pub-id-type="pmid">17118958</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Sievers1">
      <label>24</label>
      <mixed-citation publication-type="journal"><name><surname>Sievers</surname><given-names>F</given-names></name>, <name><surname>Wilm</surname><given-names>A</given-names></name>, <name><surname>Dineen</surname><given-names>D</given-names></name>, <name><surname>Gibson</surname><given-names>T</given-names></name>, <name><surname>Karplus</surname><given-names>K</given-names></name>, <etal>et al</etal> (<year>2011</year>) <article-title>Fast, scalable generation of highquality protein multiple sequence alignments using Clustal Omega</article-title>. <source>Molecular Systems Biology</source>
<volume>7</volume>: <fpage>539</fpage>.<pub-id pub-id-type="pmid">21988835</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Blackshields1">
      <label>25</label>
      <mixed-citation publication-type="journal"><name><surname>Blackshields</surname><given-names>G</given-names></name>, <name><surname>Sievers</surname><given-names>F</given-names></name>, <name><surname>Shi</surname><given-names>W</given-names></name>, <name><surname>Wilm</surname><given-names>A</given-names></name>, <name><surname>Higgins</surname><given-names>D</given-names></name> (<year>2010</year>) <article-title>Sequence embedding for fast construction of guide trees for multiple sequence alignment</article-title>. <source>Algorithms for Molecular Biology</source>
<volume>5</volume>: <fpage>21</fpage>.<pub-id pub-id-type="pmid">20470396</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Liu2">
      <label>26</label>
      <mixed-citation publication-type="journal"><name><surname>Liu</surname><given-names>W</given-names></name>, <name><surname>Schmidt</surname><given-names>B</given-names></name>, <name><surname>Voss</surname><given-names>G</given-names></name>, <name><surname>Muller-Wittig</surname><given-names>W</given-names></name> (<year>2006</year>) <article-title>GPU-ClustalW: Using graphics hardware to accelerate multiple sequence alignment</article-title>. <source>Lecture Notes in Computer Science</source>
<volume>4297</volume>: <fpage>363</fpage>–<lpage>374</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Liu3">
      <label>27</label>
      <mixed-citation publication-type="other">Liu Y, Schmidt B, Maskell D (2009) MSA-CUDA: Multiple sequence alignment on graphics processing units with CUDA. In: Proceedings of the 20th IEEE International Conference on Applicationspecific Systems, Architectures and Processors. pp. 121-128.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Gudy1">
      <label>28</label>
      <mixed-citation publication-type="journal"><name><surname>Gudyś</surname><given-names>A</given-names></name>, <name><surname>Deorowicz</surname><given-names>S</given-names></name> (<year>2012</year>) <article-title>A parallel algorithm for the constrained multiple sequence alignment problem designed for GPUs</article-title>. <source>International Journal of Foundations of Computer Science</source>
<volume>23</volume>: <fpage>877</fpage>–<lpage>901</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Lin1">
      <label>29</label>
      <mixed-citation publication-type="other">Lin YS, Lin CY, Li ST, Lee JY, Tang CY (2010) GPU-REMuSiC: the implementation of constrain multiple sequence alignment on graphics processing units. In: Proceedings of the 2010 GPU Technology Conference. NVidia.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Blazewicz1">
      <label>30</label>
      <mixed-citation publication-type="journal"><name><surname>Blazewicz</surname><given-names>J</given-names></name>, <name><surname>Frohmberg</surname><given-names>W</given-names></name>, <name><surname>Kierzynka</surname><given-names>M</given-names></name>, <name><surname>Wojciechowski</surname><given-names>P</given-names></name> (<year>2013</year>) <article-title>G-MSA|A GPU-based, fast and accurate algorithm for multiple sequence alignment</article-title>. <source>Journal of Parallel and Distributed Computing</source>
<volume>73</volume>: <fpage>32</fpage>–<lpage>41</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-OpenMP1">
      <label>31</label>
      <mixed-citation publication-type="other">OpenMP ARB (2013) OpenMP Application Program Interface version 4.0. Available: <ext-link ext-link-type="uri" xlink:href="http://www.openmp.org/mp-documents/OpenMP4.0.0.pdf">http://www.openmp.org/mp-documents/OpenMP4.0.0.pdf</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Manavski1">
      <label>32</label>
      <mixed-citation publication-type="journal"><name><surname>Manavski</surname><given-names>S</given-names></name>, <name><surname>Valle</surname><given-names>G</given-names></name> (<year>2008</year>) <article-title>CUDA compatible GPU cards as efficient hardware accelerators for Smith-Waterman sequence alignment</article-title>. <source>BMC Bioinformatics</source>
<volume>9</volume>: <fpage>S10</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Ligowski1">
      <label>33</label>
      <mixed-citation publication-type="other">Ligowski L, Rudnicki W (2009) An efficient implementation of Smith Waterman algorithm on GPU using CUDA, for massively parallel scanning of sequence databases. In: Proceedings of the 2009 IEEE International Symposium on Parallel&amp;Distributed Processing. Washington,USA: IEEE Computer Society, pp. 1-8.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Liu4">
      <label>34</label>
      <mixed-citation publication-type="journal"><name><surname>Liu</surname><given-names>Y</given-names></name>, <name><surname>Schmidt</surname><given-names>B</given-names></name>, <name><surname>Maskell</surname><given-names>D</given-names></name> (<year>2010</year>) <article-title>CUDASW++2.0: enhanced Smith-Waterman protein database search on CUDA-enabled GPUs based on SIMT and virtualized SIMD abstractions</article-title>. <source>BMC Research Notes</source>
<volume>3</volume>: <fpage>93</fpage>.<pub-id pub-id-type="pmid">20370891</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-KhajehSaeed1">
      <label>35</label>
      <mixed-citation publication-type="journal"><name><surname>Khajeh-Saeed</surname><given-names>A</given-names></name>, <name><surname>Poole</surname><given-names>S</given-names></name>, <name><surname>Perot</surname><given-names>J</given-names></name> (<year>2010</year>) <article-title>Acceleration of the Smith-Waterman algorithm using single and multiple graphics processors</article-title>. <source>Journal of Computational Physics</source>
<volume>229</volume>: <fpage>4247</fpage>–<lpage>4258</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Blazewicz2">
      <label>36</label>
      <mixed-citation publication-type="journal"><name><surname>Blazewicz</surname><given-names>J</given-names></name>, <name><surname>Frohmberg</surname><given-names>W</given-names></name>, <name><surname>Kierzynka</surname><given-names>M</given-names></name>, <name><surname>Pesch</surname><given-names>E</given-names></name>, <name><surname>Wojciechowski</surname><given-names>P</given-names></name> (<year>2011</year>) <article-title>Protein alignment algorithms with an efficient backtracking routine on multiple GPUs</article-title>. <source>BMC Bioinformatics</source>
<volume>12</volume>: <fpage>181</fpage>.<pub-id pub-id-type="pmid">21599912</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Liu5">
      <label>37</label>
      <mixed-citation publication-type="journal"><name><surname>Liu</surname><given-names>Y</given-names></name>, <name><surname>Wirawan</surname><given-names>A</given-names></name>, <name><surname>Schmidt</surname><given-names>B</given-names></name> (<year>2013</year>) <article-title>CUDASW++ 3.0: accelerating Smith-Waterman protein database search by coupling CPU and GPU SIMD instructions</article-title>. <source>BMC Bioinformatics</source>
<volume>14</volume>: <fpage>117</fpage>.<pub-id pub-id-type="pmid">23557111</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Liu6">
      <label>38</label>
      <mixed-citation publication-type="journal"><name><surname>Liu</surname><given-names>CM</given-names></name>, <name><surname>Wong</surname><given-names>T</given-names></name>, <name><surname>Wu</surname><given-names>E</given-names></name>, <name><surname>Luo</surname><given-names>R</given-names></name>, <name><surname>Yiu</surname><given-names>SM</given-names></name>, <etal>et al</etal> (<year>2012</year>) <article-title>SOAP3: ultra-fast GPU-based parallel alignment tool for short reads</article-title>. <source>Bioinformatics</source>
<volume>28</volume>: <fpage>878</fpage>–<lpage>879</lpage>.<pub-id pub-id-type="pmid">22285832</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Chang1">
      <label>39</label>
      <mixed-citation publication-type="journal"><name><surname>Chang</surname><given-names>DJ</given-names></name>, <name><surname>Kimmer</surname><given-names>C</given-names></name>, <name><surname>Ouyang</surname><given-names>M</given-names></name> (<year>2010</year>) <article-title>Accelerating the Nussinov RNA folding algorithm with CUDA/GPU</article-title>. <source>In: Proceedings of the 10th IEEE International Symposium on Signal Processing and Information. IEEE Computer Society, pp</source>. <volume>120-125</volume>: <fpage>20</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Suchard1">
      <label>40</label>
      <mixed-citation publication-type="journal"><name><surname>Suchard</surname><given-names>MA</given-names></name>, <name><surname>Rambaut</surname><given-names>A</given-names></name> (<year>2009</year>) <article-title>Many-core algorithms for statistical phylogenetics</article-title>. <source>Bioinformatics</source>
<volume>25</volume>: <fpage>1370</fpage>–<lpage>1376</lpage>.<pub-id pub-id-type="pmid">19369496</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Demouth1">
      <label>41</label>
      <mixed-citation publication-type="other">Demouth J (2012) Sparse Matrix-Matrix Multiplication on the GPU. In: Proceedings of the GPU Technology Conference 2012. NVidia.</mixed-citation>
    </ref>
    <ref id="pone.0088901-NVidia1">
      <label>42</label>
      <mixed-citation publication-type="other">NVidia (2013) CUSP library version 0.4.0. Available: <ext-link ext-link-type="uri" xlink:href="https://developer.nvidia.com/cusp">https://developer.nvidia.com/cusp</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-NVidia2">
      <label>43</label>
      <mixed-citation publication-type="other">NVidia (2013) cuSPARSE library version 5.5. Available: <ext-link ext-link-type="uri" xlink:href="https://developer.nvidia.com/cusparse">https://developer.nvidia.com/cusparse</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Durbin1">
      <label>44</label>
      <mixed-citation publication-type="other">Durbin R, Eddy SR, Krogh A, Mitchison G (1998) Biological Sequence Analysis: Probabilistic Models of Proteins and Nucleic Acids. Cambridge University Press.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Thompson2">
      <label>45</label>
      <mixed-citation publication-type="journal"><name><surname>Thompson</surname><given-names>JD</given-names></name>, <name><surname>Plewniak</surname><given-names>F</given-names></name>, <name><surname>Poch</surname><given-names>O</given-names></name> (<year>1999</year>) <article-title>A comprehensive comparison of multiple sequence alignment programs</article-title>. <source>Nucleic Acids Research</source>
<volume>27</volume>: <fpage>2682</fpage>–<lpage>2690</lpage>.<pub-id pub-id-type="pmid">10373585</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Stoye1">
      <label>46</label>
      <mixed-citation publication-type="journal"><name><surname>Stoye</surname><given-names>J</given-names></name>, <name><surname>Evers</surname><given-names>D</given-names></name>, <name><surname>Meyer</surname><given-names>F</given-names></name> (<year>1998</year>) <article-title>Rose: generating sequence families</article-title>. <source>Bioinformatics</source>
<volume>14</volume>: <fpage>157</fpage>–<lpage>163</lpage>.<pub-id pub-id-type="pmid">9545448</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-NVidia3">
      <label>47</label>
      <mixed-citation publication-type="other">NVidia (2013) CUDA Parallel Computing Platform version 5.5. Available: <ext-link ext-link-type="uri" xlink:href="http://docs.nvidia.com/cuda/pdf/CUDA_C_Programming_Guide.pdf">http://docs.nvidia.com/cuda/pdf/CUDA_C_Programming_Guide.pdf</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Khronos1">
      <label>48</label>
      <mixed-citation publication-type="other">Khronos Group (2013) The OpenCL Specification version 2.0. Available: <ext-link ext-link-type="uri" xlink:href="http://www.khronos.org/registry/cl/specs/opencl-2.0.pdf">http://www.khronos.org/registry/cl/specs/opencl-2.0.pdf</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Viterbi1">
      <label>49</label>
      <mixed-citation publication-type="journal"><name><surname>Viterbi</surname><given-names>A</given-names></name> (<year>1967</year>) <article-title>Error bounds for convolutional codes and an asymptotically optimum decoding algorithm</article-title>. <source>IEEE Transactions on Information Theory</source>
<volume>13</volume>: <fpage>260</fpage>–<lpage>269</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Sneath1">
      <label>50</label>
      <mixed-citation publication-type="other">Sneath P, Sokal R (1973) Numerical Taxonomy. The Principles and Practice of Numerical Classification. San Francisco, USA: W.H. Freeman Limited.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Needleman1">
      <label>51</label>
      <mixed-citation publication-type="other">Needleman S, Wunsch C (1970) A general method applicable to the search for similarities in the amino acid sequence of two proteins. Journal of Molecular Biology 48: 443 - 453.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Thompson3">
      <label>52</label>
      <mixed-citation publication-type="journal"><name><surname>Thompson</surname><given-names>J</given-names></name>, <name><surname>Koehl</surname><given-names>P</given-names></name>, <name><surname>Ripp</surname><given-names>R</given-names></name>, <name><surname>Poch</surname><given-names>O</given-names></name> (<year>2005</year>) <article-title>BAliBASE 3.0: latest developments of the multiple sequence alignment benchmark</article-title>. <source>Proteins</source>
<volume>61</volume>: <fpage>127</fpage>–<lpage>136</lpage>.<pub-id pub-id-type="pmid">16044462</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Raghava1">
      <label>53</label>
      <mixed-citation publication-type="journal"><name><surname>Raghava</surname><given-names>GPS</given-names></name>, <name><surname>Searle</surname><given-names>S</given-names></name>, <name><surname>Audley</surname><given-names>P</given-names></name>, <name><surname>Barber</surname><given-names>J</given-names></name>, <name><surname>Barton</surname><given-names>G</given-names></name> (<year>2003</year>) <article-title>OXBench: A benchmark for evaluation of protein multiple sequence alignment accuracy</article-title>. <source>BMC Bioinformatics</source>
<volume>4</volume>: <fpage>47</fpage>.<pub-id pub-id-type="pmid">14552658</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Edgar2">
      <label>54</label>
      <mixed-citation publication-type="other">Edgar RC (2009) Benchmark collection. Available: <ext-link ext-link-type="uri" xlink:href="http://www.drive5.com/bench">http://www.drive5.com/bench</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Finn1">
      <label>55</label>
      <mixed-citation publication-type="journal"><name><surname>Finn</surname><given-names>RD</given-names></name>, <name><surname>Tate</surname><given-names>J</given-names></name>, <name><surname>Mistry</surname><given-names>J</given-names></name>, <name><surname>Coggill</surname><given-names>PC</given-names></name>, <name><surname>Sammut</surname><given-names>SJ</given-names></name>, <etal>et al</etal> (<year>2008</year>) <article-title>The Pfam protein families database</article-title>. <source>Nucleic Acids Research</source>
<volume>36</volume>: <fpage>D281</fpage>–<lpage>D288</lpage>.<pub-id pub-id-type="pmid">18039703</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0088901-Edgar3">
      <label>56</label>
      <mixed-citation publication-type="other">Edgar RC (2009) QSCORE multiple alignment scoring software. Available: <ext-link ext-link-type="uri" xlink:href="http://www.drive5.com/qscore">http://www.drive5.com/qscore</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0088901-Wilcoxon1">
      <label>57</label>
      <mixed-citation publication-type="journal"><name><surname>Wilcoxon</surname><given-names>F</given-names></name> (<year>1945</year>) <article-title>Individual Comparisons by Ranking Methods</article-title>. <source>Biometrics Bulletin</source>
<volume>1</volume>: <fpage>80</fpage>–<lpage>83</lpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
