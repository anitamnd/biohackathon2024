<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6820941</article-id>
    <article-id pub-id-type="publisher-id">3114</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-019-3114-9</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>SLR: a scaffolding algorithm based on long reads and contig classification</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Luo</surname>
          <given-names>Junwei</given-names>
        </name>
        <address>
          <email>luojunwei@hpu.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lyu</surname>
          <given-names>Mengna</given-names>
        </name>
        <address>
          <email>211809020031@home.hpu.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chen</surname>
          <given-names>Ranran</given-names>
        </name>
        <address>
          <email>211709020027@home.hpu.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zhang</surname>
          <given-names>Xiaohong</given-names>
        </name>
        <address>
          <email>xh.zhang@hpu.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Luo</surname>
          <given-names>Huimin</given-names>
        </name>
        <address>
          <email>luohuimin@henu.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Yan</surname>
          <given-names>Chaokun</given-names>
        </name>
        <address>
          <email>ckyan@henu.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0000 8645 6375</institution-id><institution-id institution-id-type="GRID">grid.412097.9</institution-id><institution>College of Computer Science and Technology, Henan Polytechnic University, </institution></institution-wrap>Jiaozuo, 454000 China </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0000 9139 560X</institution-id><institution-id institution-id-type="GRID">grid.256922.8</institution-id><institution>School of Computer and Information Engineering, Henan University, </institution></institution-wrap>Kaifeng, 475001 China </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>30</day>
      <month>10</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>10</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>539</elocation-id>
    <history>
      <date date-type="received">
        <day>19</day>
        <month>12</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>23</day>
        <month>9</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License(<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver(<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">Scaffolding is an important step in genome assembly that orders and orients the contigs produced by assemblers. However, repetitive regions in contigs usually prevent scaffolding from producing accurate results. How to solve the problem of repetitive regions has received a great deal of attention. In the past few years, long reads sequenced by third-generation sequencing technologies (Pacific Biosciences and Oxford Nanopore) have been demonstrated to be useful for sequencing repetitive regions in genomes. Although some stand-alone scaffolding algorithms based on long reads have been presented, scaffolding still requires a new strategy to take full advantage of the characteristics of long reads.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">Here, we present a new scaffolding algorithm based on long reads and contig classification (SLR). Through the alignment information of long reads and contigs, SLR classifies the contigs into unique contigs and ambiguous contigs for addressing the problem of repetitive regions. Next, SLR uses only unique contigs to produce draft scaffolds. Then, SLR inserts the ambiguous contigs into the draft scaffolds and produces the final scaffolds. We compare SLR to three popular scaffolding tools by using long read datasets sequenced with Pacific Biosciences and Oxford Nanopore technologies. The experimental results show that SLR can produce better results in terms of accuracy and completeness. The open-source code of SLR is available at https://github.com/luojunwei/SLR.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p id="Par3">In this paper, we describes SLR, which is designed to scaffold contigs using long reads. We conclude that SLR can improve the completeness of genome assembly.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Scaffolding</kwd>
      <kwd>Genome assembly</kwd>
      <kwd>Sequence analysis</kwd>
      <kwd>Pacific biosciences</kwd>
      <kwd>Oxford Nanopore</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>With the increasing availability of third-generation sequencing technologies, which include Single-Molecule Real-Time (SMRT) technology from Pacific Biosciences and Nanopore-based technology from Oxford Nanopore, many biological applications have been greatly improved. Compared with second-generation sequencing technologies, third-generation sequencing technologies produce longer reads with a higher sequencing error rate [<xref ref-type="bibr" rid="CR1">1</xref>]. In the field of de novo genome assembly, a large number of assembly tools based on third-generation sequencing technologies have been presented to resolve the most prominent problem: repetitive regions. However, producing a complete and accurate assembly is still a challenging task. Scaffolding is an important step in the pipeline of genome assembly, and aims to orient and order contigs [<xref ref-type="bibr" rid="CR2">2</xref>, <xref ref-type="bibr" rid="CR3">3</xref>]. Scaffolding generates scaffolds consisting of sequence fragments including oriented and ordered contigs. The gap between two adjacent contigs in a scaffold is filled with ’N’ characters. Scaffolding can significantly increase the continuity of assembly results and benefit downstream analyses such as those of gene order, comparative or functional genomics and patterns of recombination [<xref ref-type="bibr" rid="CR4">4</xref>].</p>
    <p>According to the kind of reads used for scaffolding, existing scaffolding tools generally fall into the following three categories:</p>
    <p>(i) Using paired reads for scaffolding. The insert size of paired reads can reach a few thousands bases, so this technique can partially resolve the problem of repetitive regions. Such scaffolding tools, such as OPERA [<xref ref-type="bibr" rid="CR5">5</xref>], SSPACE [<xref ref-type="bibr" rid="CR6">6</xref>], BESST [<xref ref-type="bibr" rid="CR7">7</xref>], ScaffMatch [<xref ref-type="bibr" rid="CR8">8</xref>], SCARPA [<xref ref-type="bibr" rid="CR9">9</xref>], ScaffoldScaffolder [<xref ref-type="bibr" rid="CR10">10</xref>], and BOSS [<xref ref-type="bibr" rid="CR11">11</xref>], usually use greedy heuristic algorithms to generate scaffolds based on a scaffold graph, in which a vertex denotes a contig and an edge represents the existence of paired reads that can be separately aligned to the two corresponding contigs. However, because the length of reads from second-generation technologies is commonly only a few hundred bases, the reads can usually be aligned with two or more positions in the contigs. Moreover, the region between the paired reads is unknown, and there are sequencing errors in the reads. Some spurious edges are usually introduced into a scaffold graph, which complicates the scaffolding task. Obtaining more accurate and contiguous scaffolding results based on paired reads is a difficult task.</p>
    <p>(ii) Using long reads for scaffolding. This kind of scaffolding tool usually aligns the long reads against contigs first and then finds contigs that can be aligned with the same long read. Then, these tools use the local alignment result to infer the global order and orientation of contigs. For instance, SSPACE-LongRead [<xref ref-type="bibr" rid="CR12">12</xref>] first aligns whole long reads with contigs using the alignment tool BLASR [<xref ref-type="bibr" rid="CR13">13</xref>]. Next, contig pairs and multi-contig linkage information are obtained and used to order and orient the contigs and generate scaffolds. LINKS [<xref ref-type="bibr" rid="CR14">14</xref>] does not align the whole long reads to the contigs; it first extracts the k-mer pairs in an interval from long reads. Afterwards, these k-mer pairs are aligned to the contigs, and the alignment results are used to link the contigs. Finally, LINKS selects a neighbour of a contig as its correct neighbour based on the number of links. SMSC [<xref ref-type="bibr" rid="CR15">15</xref>] first aligns the long reads to the contigs using either Nucmer [<xref ref-type="bibr" rid="CR16">16</xref>] or BLASR and then constructs a breakpoint graph in which a vertex is a contig and an edge is added to indicate a long read bridging two vertices. It transforms the scaffolding problem to a maximum alternating path coverage problem in the breakpoint graph and resolves this problem using a 2-approximation algorithm. RAILS [<xref ref-type="bibr" rid="CR17">17</xref>] scaffolds contigs with long reads using the scaffolding engine originally developed for SSAKE [<xref ref-type="bibr" rid="CR18">18</xref>] and LINKS. Based on the sequencing coverage of each contig, npScarf [<xref ref-type="bibr" rid="CR19">19</xref>] classifies contigs into unique contigs and repetitive contigs. npScarf first bridges the unique contigs and generates scaffolds based on a greedy strategy and then fills the gaps by repetitive contigs. However, most contig sets used for scaffolding do not include information on sequencing coverage, which limits the application of npScarf.</p>
    <p>(iii) Using optical mapping data or Hi-C data for scaffolding. Optical mapping data can serve as a unique "fingerprint" or "barcode" for genome sequences. By comparing optical mapping data with a restriction enzyme map of the contigs, the order and orientation of contigs can be inferred. Supernova [<xref ref-type="bibr" rid="CR20">20</xref>], Architect [<xref ref-type="bibr" rid="CR21">21</xref>], ARCS [<xref ref-type="bibr" rid="CR22">22</xref>] and fragScaff [<xref ref-type="bibr" rid="CR23">23</xref>] attempt to find pairs of contigs based on linked reads. The problem with using optical mapping data is that a barcode used to locate contigs may have many different alignment positions, which usually causes contradictions between contigs. Hi-C data are commonly sequenced by paired-end sequencing. The paired reads come from the interacting fragments between genomic loci that are nearby in three-dimensional space but may be separated by many nucleotides in the linear genome. Scaffolding using Hi-C data is the most challenging method, as the genomic distance between a given Hi-C-based read pair is highly variable and may span a few kilobases to megabases without any direct indication of the true distance [<xref ref-type="bibr" rid="CR1">1</xref>].</p>
    <p>Although some scaffolding tools based on long reads have made great progress, two primary issues still require more attention. (i) Scaffold graph construction: In a scaffold graph, each vertex refers to a contig, and an edge is created between two vertices if the two contigs can be aligned with the same long read. Due to the repetitive regions in contigs and the high sequencing error rate of long reads, the scaffold graph usually becomes very complicated, which has negative effects on the later scaffolding steps. Hence, simplifying the scaffold graph is a significant goal for scaffolding. (ii) Edge weighting: In the scaffold graph, most current methods prefer to weight each edge by the number of long reads that can be aligned with two vertices simultaneously. However, the length of the alignment between a long read and a contig can reflect the confidence level of the alignment, which is usually ignored by existing methods.</p>
    <p>When a long read links the two flanking regions of a repetitive region, the problem of the repetitive region can be resolved because the order and orientation of the two flanking regions can be obtained directly. Moreover, a repetitive region can usually be aligned with more than one long read, and their 5’-end (or 3’-end) neighbour regions are not the same. After aligning the long reads against the contigs, we can identify whether contigs are repetitive based on their aligniment positions in the long reads. When constructing a scaffold graph, it is difficult to avoid spurious edges introduced by repetitive contigs and sequencing errors. We can identify spurious edges by detecting orientation and position contradictions in the scaffold graph [<xref ref-type="bibr" rid="CR10">10</xref>, <xref ref-type="bibr" rid="CR11">11</xref>]. Using only non-repetitive contigs to construct a scaffold graph not only simplifies the complexity of the scaffold graph but also improves the accuracy of spurious edge detection.</p>
    <p>In this paper, we present a scaffolding algorithm based on long reads and contig classification (SLR), which utilizes two new strategies to address the two issues above. For issue (i), SLR classifies the contigs into unique contigs and ambiguous contigs. SLR utilizes the unique contigs to construct a scaffold graph, which can decrease the complexity of the scaffold graph and simplify the following scaffolding steps. For issue (ii), SLR uses the alignment length to weight each edge in the scaffold graph. Moreover, SLR employs linear programming to detect and remove the contradictions in the scaffold graph, which guarantees that the scaffold graph includes only simple paths.</p>
    <p>Based on these two new strategies, SLR determines the orientations and orders of the contigs. In experiments, SLR is compared with three popular scaffolding tools by scaffolding five long-read datasets with Pacific Biosciences and Oxford Nanopore technologies. The experimental results show that SLR produces better results in terms of accuracy and completion for most datasets.</p>
  </sec>
  <sec id="Sec2" sec-type="results">
    <title>Results</title>
    <p>To evaluate the performance of SLR, we compared SLR with three popular scaffolding tools based on long reads, namely, SSPACE-LongRead (SSPACE-LR), LINKS and npScarf.</p>
    <sec id="Sec3">
      <title>Datasets and metrics</title>
      <p>Contig and long-read datasets for <italic>Escherichia coli (E. coli)</italic>, <italic>Saccharomyces cerevisiae W303 (S. cerevisiae)</italic>, and <italic>Human chromosome X (Chr X)</italic> were utilized as input for all tools. <italic>E. coli</italic> and <italic>S. cerevisiae</italic> include two different long-read datasets sequenced with Pacific Biosciences and Oxford Nanopore technologies and consist of two different contig sets assembled by different assemblers. The long reads for <italic>Chr X</italic> are from Pacific Biosciences. The details of the long-read datasets are shown in Table <xref rid="Tab1" ref-type="table">1</xref>. The contig sets, which were evaluated by QUAST [<xref ref-type="bibr" rid="CR24">24</xref>], are shown in Table <xref rid="Tab2" ref-type="table">2</xref>. Then, these contig sets and long-read sets form nine datasets, shown in Table <xref rid="Tab3" ref-type="table">3</xref>, were used for scaffolding, and each dataset included one contig set and one long-read set. We named the nine datasets as <italic>E. coli</italic>_1_SMRT, <italic>E. coli</italic>_2_SMRT, <italic>S. cerevisiae</italic>_1_SMRT, <italic>S. cerevisiae</italic>_2_SMRT, <italic>Chr X</italic>_1_SMRT, <italic>E. coli</italic>_1_ONT, <italic>E. coli</italic>_2_ONT, <italic>S. cerevisiae</italic>_1_ONT, and <italic>S. cerevisiae</italic>_2_ONT.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Details of long-read datasets</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"/><th align="left" colspan="2"><italic>E. coli</italic></th><th align="left" colspan="2"><italic>S. cerevisiae</italic></th><th align="left"><italic>Chr X</italic></th></tr></thead><tbody><tr><td align="left">Genome size(Mbp)</td><td align="center" colspan="2">4.6</td><td align="center" colspan="2">12.1</td><td align="center">155.2</td></tr><tr><td align="left">Sequencing technology</td><td align="left">SMRT</td><td align="left">Nanopore</td><td align="left">SMRT</td><td align="left">Nanopore</td><td align="center">SMRT</td></tr><tr><td align="left">Read N50(bp)</td><td align="left">5,189</td><td align="left">8,484</td><td align="left">6,794</td><td align="left">8,608</td><td align="center">11,030</td></tr><tr><td align="left">Number of reads</td><td align="left">81,737</td><td align="left">20,750</td><td align="left">594,243</td><td align="left">410,344</td><td align="center">1,135,220</td></tr><tr><td align="left">Name</td><td align="left"><italic>E. coli</italic>_SMRT</td><td align="left"><italic>E. coli</italic>_ONT</td><td align="left"><italic>S. cerevisiae</italic>_SMRT</td><td align="left"><italic>S. cerevisiae</italic>_ONT</td><td align="center"><italic>Chr X</italic>_SMRT</td></tr></tbody></table></table-wrap><table-wrap id="Tab2"><label>Table 2</label><caption><p>Details of contig sets</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Contig set</th><th align="left">Count</th><th align="left">Errors</th><th align="left">Genome</th><th align="left">Mismatches</th><th align="left">Indels</th><th align="left">Largest</th><th align="left">NA50</th><th align="left">NGA50</th></tr><tr><th align="left"/><th align="left"/><th align="left"/><th align="left">Fraction(%)</th><th align="left"/><th align="left"/><th align="left">alignment</th><th align="left"/><th align="left"/></tr></thead><tbody><tr><td align="left"><italic>E. coli</italic>_1</td><td align="left">182</td><td align="left">2</td><td align="left">99.363</td><td align="left">1.32</td><td align="left">0.37</td><td align="left">315,628</td><td align="left">106,208</td><td align="left">106,208</td></tr><tr><td align="left"><italic>E. coli</italic>_2</td><td align="left">167</td><td align="left">7</td><td align="left">99.351</td><td align="left">2.28</td><td align="left">0.11</td><td align="left">360,084</td><td align="left">164,044</td><td align="left">164,044</td></tr><tr><td align="left"><italic>S. cerevisiae</italic>_1</td><td align="left">3179</td><td align="left">35</td><td align="left">96.688</td><td align="left">79.03</td><td align="left">8.42</td><td align="left">233,103</td><td align="left">47,994</td><td align="left">52,239</td></tr><tr><td align="left"><italic>S. cerevisiae</italic>_2</td><td align="left">6953</td><td align="left">53</td><td align="left">96.687</td><td align="left">85.54</td><td align="left">8.76</td><td align="left">250,180</td><td align="left">49,258</td><td align="left">54,160</td></tr><tr><td align="left"><italic>Chr X</italic>_1</td><td align="left">8623</td><td align="left">41</td><td align="left">97.037</td><td align="left">2.40</td><td align="left">1.28</td><td align="left">793,618</td><td align="left">76,506</td><td align="left">71,372</td></tr></tbody></table><table-wrap-foot><p>The contig set about <italic>E. coli</italic>_1 and <italic>S. cerevisiae</italic>_1 are provided by [<xref ref-type="bibr" rid="CR29">29</xref>], the contig set about <italic>E. coli</italic>_2 and <italic>S. cerevisiae</italic>_2 are provided by [<xref ref-type="bibr" rid="CR30">30</xref>], and the contig set about <italic>Chr X</italic>_1 are provided by [<xref ref-type="bibr" rid="CR31">31</xref>]</p></table-wrap-foot></table-wrap><table-wrap id="Tab3"><label>Table 3</label><caption><p>Datasets used for scaffolding and evaluations for SLR and SLR1</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Dataset</th><th align="left"/><th align="left">Genome</th><th align="left">Contig set</th><th align="left">Long read set</th><th align="left"/><th align="left" colspan="2">Misassemblies</th><th align="left"/><th align="left" colspan="2">NGA50</th></tr><tr><th align="left"/><th align="left"/><th align="left"/><th align="left"/><th align="left"/><th align="left"/><th align="left">SLR</th><th align="left">SLR1</th><th align="left"/><th align="left">SLR</th><th align="left">SLR1</th></tr></thead><tbody><tr><td align="left"><italic>E. coli</italic>_1_SMRT</td><td align="left"/><td align="left"><italic>E. coli</italic></td><td align="left"><italic>E. coli</italic>_1</td><td align="left"><italic>E. coli</italic>_SMRT</td><td align="left"/><td align="left">4</td><td align="left">12</td><td align="left"/><td align="left">723,879</td><td align="left">295,999</td></tr><tr><td align="left"><italic>E. coli</italic>_2_SMRT</td><td align="left"/><td align="left"><italic>E. coli</italic></td><td align="left"><italic>E. coli</italic>_2</td><td align="left"><italic>E. coli</italic>_SMRT</td><td align="left"/><td align="left">10</td><td align="left">11</td><td align="left"/><td align="left">565,864</td><td align="left">197,175</td></tr><tr><td align="left"><italic>S. cerevisiae</italic>_1_SMRT</td><td align="left"/><td align="left"><italic>S. cerevisiae</italic></td><td align="left"><italic>S. cerevisiae</italic>_1</td><td align="left"><italic>S. cerevisiae</italic>_SMRT</td><td align="left"/><td align="left">52</td><td align="left">57</td><td align="left"/><td align="left">374,744</td><td align="left">232,712</td></tr><tr><td align="left"><italic>S. cerevisiae</italic>_2_SMRT</td><td align="left"/><td align="left"><italic>S. cerevisiae</italic></td><td align="left"><italic>S. cerevisiae</italic>_2</td><td align="left"><italic>S. cerevisiae</italic>_SMRT</td><td align="left"/><td align="left">71</td><td align="left">67</td><td align="left"/><td align="left">270,402</td><td align="left">201,922</td></tr><tr><td align="left"><italic>Chr X</italic>_1_SMRT</td><td align="left"/><td align="left"><italic>Chr X</italic></td><td align="left"><italic>Chr X</italic>_1</td><td align="left"><italic>Chr X</italic>_SMRT</td><td align="left"/><td align="left">83</td><td align="left">82</td><td align="left"/><td align="left">2,390,483</td><td align="left">2,165,615</td></tr><tr><td align="left"><italic>E. coli</italic>_1_ONT</td><td align="left"/><td align="left"><italic>E. coli</italic></td><td align="left"><italic>E. coli</italic>_1</td><td align="left"><italic>E. coli</italic>_ONT</td><td align="left"/><td align="left">4</td><td align="left">8</td><td align="left"/><td align="left">2,927,247</td><td align="left">674,408</td></tr><tr><td align="left"><italic>E. coli</italic>_2_ONT</td><td align="left"/><td align="left"><italic>E. coli</italic></td><td align="left"><italic>E. coli</italic>_2</td><td align="left"><italic>E. coli</italic>_ONT</td><td align="left"/><td align="left">9</td><td align="left">14</td><td align="left"/><td align="left">733,062</td><td align="left">361,345</td></tr><tr><td align="left"><italic>S. cerevisiae</italic>_1_ONT</td><td align="left"/><td align="left"><italic>S. cerevisiae</italic></td><td align="left"><italic>S. cerevisiae</italic>_1</td><td align="left"><italic>S. cerevisiae</italic>_ONT</td><td align="left"/><td align="left">46</td><td align="left">66</td><td align="left"/><td align="left">374,835</td><td align="left">244,417</td></tr><tr><td align="left"><italic>S. cerevisiae</italic>_2_ONT</td><td align="left"/><td align="left"><italic>S. cerevisiae</italic></td><td align="left"><italic>S. cerevisiae</italic>_2</td><td align="left"><italic>S. cerevisiae</italic>_ONT</td><td align="left"/><td align="left">68</td><td align="left">85</td><td align="left"/><td align="left">270,362</td><td align="left">201,066</td></tr></tbody></table><table-wrap-foot><p>Each dataset includes one contig set and one long-read set, and corresponds to one genome.</p></table-wrap-foot></table-wrap>
</p>
      <p>QUAST aligns the contigs (or scaffolds) to the reference genome and obtains some metrics. NG50 is the length of the longest contig (or scaffold) such that all the contigs (or scaffolds) of that length or longer cover at least half of the reference genome. N50 is the length of the longest contig (or scaffold) such that all the contigs (or scaffolds) of that length or longer cover at least half of the length of all contigs (or scaffolds). Misassemblies (Errors) is the number of positions (breakpoints) in the contigs or scaffolds in which errors (Translocation, Inversion, Relocation) occur. NGA50 is the NG50 of contigs or scaffolds after they have been broken at every breakpoint. Genome Fraction is the percentage of aligned bases in the reference genome. Usually, Misassemblies can represent the accuracy of the scaffolding result, and NGA50 and NA50 can reflect the completion and continuity of the scaffolding result. In the experiments below, we used QUAST to evaluate the scaffolding results for SSPACE-LR, LINKS, npScarf and SLR.</p>
    </sec>
    <sec id="Sec4">
      <title>Evaluations on nine datasets</title>
      <p>The long-read sets about first five datasets are obtained by SMRT technology. And, the long-read sets about last four datasets are obtained by Nanopore technology. All the scaffolding tools were run on these nine datasets, and detailed evaluation results from QUAST are shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Tables S1 and S2. Because NGA50 and Misassemblies are two important metrics for evaluating scaffolding tools, we show NGA50 vs Misassemblies in Fig. <xref rid="Fig1" ref-type="fig">1</xref>. The best scaffolding result can found in the top-left corner of each figure. Except in Fig. <xref rid="Fig1" ref-type="fig">1</xref>(b) and Fig. <xref rid="Fig1" ref-type="fig">1</xref>(i), SLR is in the top-left corner throughout Fig. <xref rid="Fig1" ref-type="fig">1</xref>, which indicates that SLR has lower Misassemblies and a higher NGA50. Although npScarf performs better in Fig. <xref rid="Fig1" ref-type="fig">1</xref>(b) and Fig. <xref rid="Fig1" ref-type="fig">1</xref>(i), the performance of SLR is close to it.
<fig id="Fig1"><label>Fig. 1</label><caption><p>Nine figures plotting NGA50 vs Misassemblies. The results of SLR usually can be found in the top-left corner, which can illustrate the advantage of SLR</p></caption><graphic xlink:href="12859_2019_3114_Fig1_HTML" id="MO1"/></fig>
</p>
    </sec>
    <sec id="Sec5">
      <title>Running time and peak memory</title>
      <p>Due to the high error rate in long reads, aligning long reads with contigs usually takes a long time. LINKS selects k-mer pairs from the long reads to link the contigs, which avoids long read alignment. However, LINKS requires more memory to store the k-mer pairs. As shown in Table <xref rid="Tab4" ref-type="table">4</xref>, we find that LINKS consumes less time and more memory. SLR and npScarf have similar time consumption, because both use BWA-MEM [<xref ref-type="bibr" rid="CR25">25</xref>] to align long reads against contigs. In all experiments, npScarf allocates a large memory despite the size of the dataset. When extracting alignment information from the BAM file, SLR keeps the alignment of one long read in memory and produces a local scaffold that is saved on the hard disk. After processing one long read, SLR processes the next long read, which can reduce the memory requirement. Compared with other tools, SSPACE-LR and SLR require less memory for scaffolding.
<table-wrap id="Tab4"><label>Table 4</label><caption><p>Running time and peak memory</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Dataset</th><th align="left"/><th align="left" colspan="4">Running time</th><th align="left"/><th align="left" colspan="4">Peak memory (G)</th></tr><tr><th align="left"/><th align="left"/><th align="left">SSPACE-LR</th><th align="left">LINKS</th><th align="left">npScarf</th><th align="left">SLR</th><th align="left"/><th align="left">SSPACE-LR</th><th align="left">LINKS</th><th align="left">npScarf</th><th align="left">SLR</th></tr></thead><tbody><tr><td align="left"><italic>E. coli</italic>_1_SMRT</td><td align="left"/><td align="left">41m42s</td><td align="left">1m42s</td><td align="left">26m34s</td><td align="left">26m58s</td><td align="left"/><td align="left">1.00</td><td align="left">6.23</td><td align="left">10.28</td><td align="left">1.04</td></tr><tr><td align="left"><italic>E. coli</italic>_2_SMRT</td><td align="left"/><td align="left">42m12s</td><td align="left">1m42s</td><td align="left">26m46s</td><td align="left">28m17s</td><td align="left"/><td align="left">1.00</td><td align="left">6.22</td><td align="left">10.28</td><td align="left">1.17</td></tr><tr><td align="left"><italic>S. cerevisiae</italic>_1_SMRT</td><td align="left"/><td align="left">880m22s</td><td align="left">38m26s</td><td align="left">929m36s</td><td align="left">907m23s</td><td align="left"/><td align="left">3.96</td><td align="left">93.27</td><td align="left">10.28</td><td align="left">1.86</td></tr><tr><td align="left"><italic>S. cerevisiae</italic>_2_SMRT</td><td align="left"/><td align="left">1162m28s</td><td align="left">40m35s</td><td align="left">1012m27s</td><td align="left">957m59s</td><td align="left"/><td align="left">3.96</td><td align="left">93.3</td><td align="left">10.28</td><td align="left">3.60</td></tr><tr><td align="left"><italic>Chr X</italic>_1_SMRT</td><td align="left"/><td align="left">8413m53s</td><td align="left">41m2s</td><td align="left">6617m53s</td><td align="left">7782m13s</td><td align="left"/><td align="left">12.56</td><td align="left">114.2</td><td align="left">12.82</td><td align="left">3.98</td></tr><tr><td align="left"><italic>E. coli</italic>_1_ONT</td><td align="left"/><td align="left">46m25s</td><td align="left">2m22s</td><td align="left">28m6s</td><td align="left">26m57s</td><td align="left"/><td align="left">1.02</td><td align="left">8.60</td><td align="left">10.28</td><td align="left">1.05</td></tr><tr><td align="left"><italic>E. coli</italic>_2_ONT</td><td align="left"/><td align="left">47m57s</td><td align="left">2m25s</td><td align="left">28m17s</td><td align="left">28m42s</td><td align="left"/><td align="left">1.01</td><td align="left">8.60</td><td align="left">10.28</td><td align="left">1.11</td></tr><tr><td align="left"><italic>S. cerevisiae</italic>_1_ONT</td><td align="left"/><td align="left">676m26s</td><td align="left">41m20s</td><td align="left">962m51s</td><td align="left">1001m25s</td><td align="left"/><td align="left">3.43</td><td align="left">117.97</td><td align="left">10.28</td><td align="left">1.84</td></tr><tr><td align="left"><italic>S. cerevisiae</italic>_2_ONT</td><td align="left"/><td align="left">830m48s</td><td align="left">40m54s</td><td align="left">1046m16s</td><td align="left">1051m53s</td><td align="left"/><td align="left">3.52</td><td align="left">117.99</td><td align="left">10.28</td><td align="left">3.47</td></tr></tbody></table></table-wrap>
</p>
    </sec>
    <sec id="Sec6">
      <title>Effectiveness of contig classification</title>
      <p>To verify the effectiveness of the contig classification method presented in this paper, we removed the step of contig classification from SLR and this new algorithm was named SLR1. Then, we benchmarked SLR with SLR1 on all datasets. The scaffolding results for SLR and SLR1 are shown in Table <xref rid="Tab3" ref-type="table">3</xref>. We can see that SLR performs better than SLR1 in terms of Misassemblies and NGA50. Therefore, we can prove that our proposed contig classification method is effective.</p>
      <p>Next, we combined the contig classification method with other scaffolding tools. SLR classified each contig set into a unique contig set and an ambiguous contig set. We first ran SSPACE-LR and LINKS on the unique contig set, generating some scaffolds. Then, we inserted the ambiguous contigs into the scaffolds. For this purpose, we should determine the order and orientation of the unique contigs in these scaffolds. BWA-MEM is used to align the unique contigs against these scaffolds. Only if a unique contig is completely aligned in a scaffold, the corresponding alignment is retained. Then, we can obtain the order and orientation of the unique contigs in these scaffolds. The final scaffolding results is shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. SSPACE-LR-CC represents the method based on SSPACE-LR combined with contig classification. LINKS-CC represents the method based on LINKS combined with contig classification. According to Fig. <xref rid="Fig2" ref-type="fig">2</xref>, we find that SSPACE-LR-CC and LINKS-CC outperformed SSPACE-LR and LINKS in NGA50. This further confirms the effectiveness of the method of contig classification.
<fig id="Fig2"><label>Fig. 2</label><caption><p>Contig classification combines with SSPACE-LR and LINKS</p></caption><graphic xlink:href="12859_2019_3114_Fig2_HTML" id="MO2"/></fig>
</p>
      <p>Compared with SLR, SSPACE-LR-CC outperformed SLR in NGA50 for <italic>E. coli</italic>_2_SMRT and <italic>Chr X</italic>_1_SMRT. For the remaining seven datasets, SLR performed better than SSPACE-LR-CC in NGA50. SLR performed better than LINKS-CC in NGA50 for all datasets. Meanwhile, SLR outperformed SSPACE-LR-CC and LINKS-CC in Misassemblies for all datasets.</p>
      <p>The detailed evaluation results are provided in Additional file <xref rid="MOESM1" ref-type="media">1</xref>. Note that, because npScarf makes sequence consensus between contigs and long reads, it is difficult to identify the order of the unique contigs in the scaffolds. We did not use npScarf in the this experiment.</p>
    </sec>
    <sec id="Sec7">
      <title>Evaluation using a repeat-aware evaluation framework</title>
      <p>We also used a repeat-aware evaluation framework [<xref ref-type="bibr" rid="CR26">26</xref>] to evaluate the performance of SSPACE-LR, LINKS, npScarf and SLR. For each original contig set, by aligning contigs with the reference genome, this framework splits contigs in misassembly events, and extracts repetitive sub-contig from original contigs. Then, it outputs a new contig set. The framework records the number of correct links, which is the number of correct contig joins. After a scaffolding tool runs on this new contig set and a long-read set, the framework computes the number of correctly predicted links. Therefore, we can compute precision, recall and F1-score for the scaffolding results. For the contig set about <italic>Chr X</italic>, the framework ran for more than one week and gave no new contig set. Hence, we processed only the remaining original contig sets. So, there are eight new datasets used for this experiment, which are named <italic>E. coli</italic>_1_SMRT_R, <italic>E. coli</italic>_2_SMRT_R, <italic>S. cerevisiae</italic>_1_SMRT_R, <italic>S. cerevisiae</italic>_2_SMRT_R, <italic>E. coli</italic>_1_ONT_R, <italic>E. coli</italic>_2_ONT_R, <italic>S. cerevisiae</italic>_1_ONT_R, and <italic>S. cerevisiae</italic>_2_ONT_R. The detailed evaluation results provided by the framework are shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Tables S9 and S10.</p>
      <p>In addition, for these new datasets, we also evaluated the scaffolding results by QUAST, which are shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref>. According to Fig. <xref rid="Fig3" ref-type="fig">3</xref>, SLR achieved the best NGA50 values for all the datasets. This experiment shows that SLR can identify repetitive contigs and overcome the problem of repeating regions.
<fig id="Fig3"><label>Fig. 3</label><caption><p>NGA50 for datasets produced by repeat-aware evaluation framework</p></caption><graphic xlink:href="12859_2019_3114_Fig3_HTML" id="MO3"/></fig>
</p>
    </sec>
  </sec>
  <sec id="Sec8" sec-type="discussion">
    <title>Discussion</title>
    <p>npScarf utilizes sequencing coverage to classify contigs. However, most contigs used for scaffolding do not include information about sequencing coverage, which limits the application of npScarf. SLR can classify contigs without any additional information about the contig set. SSPACE-LR uses a greedy heuristic strategy to determine the neighbour of a contig based on the number of long reads that can be aligned. LINKS uses a strategy similar to that of SSPACE-LR to determine the neighbours by counting the number of k-mer pairs between two contigs. These two tools have difficulty identifying the correct neighbours when encountering complex repetitive regions.</p>
  </sec>
  <sec id="Sec9" sec-type="conclusion">
    <title>Conclusion</title>
    <p>With the development of third-generation high-throughput sequencing technologies, scaffolding methods based on long reads have undergone substantial improvement. A scaffold graph is the basis for inferring the orders and orientations of contigs. However, the problems introduced by repetitive regions and sequencing errors pose challenges in the process of constructing scaffold graphs. In this paper, we presented a novel scaffolder, SLR, for determining the orientations and orders of contigs based on long reads and contig classification. SLR employs a new contig classification procedure to overcome the problems associated with repetitive regions in scaffolding. SLR first produces local scaffolds based on the alignment between long reads and contigs. A local scaffold corresponds to a long read and the contigs that can be aligned with it. SLR classifies contigs into unique and ambiguous contigs based on local scaffolds. A scaffold graph including only unique contigs is constructed; this process can simplify the scaffold graph and improve the accuracy of detecting and removing contradictions. Experiments were conducted that included long reads obtained with SMRT-based and Nanopore-based technologies. The experimental results illustrated that SLR is superior in terms of continuity and accuracy. For larger genomes, such as the complete human genome, however, SLR is difficult to scale due to its long run time.</p>
  </sec>
  <sec id="Sec10">
    <title>Method</title>
    <p>A contig set <italic>C</italic> and a long read set <italic>LR</italic> are used as input data. The algorithm is composed of four steps: (i) producing local scaffolds; (ii) classifying contigs; (iii) constructing a scaffold graph; and (iv) generating scaffolds. In the first step, the alignment tool BWA-MEM is used to align <italic>LR</italic> against <italic>C</italic>. For each long read and set of contigs that can be aligned with it, SLR determines the orders and orientations of the contigs and forms a local scaffold. In the second step, SLR classifies the contigs into unique contigs and ambiguous contigs based on their positions in the local scaffolds. In the third step, SLR constructs a scaffold graph based on unique contigs and then detects and removes the contradictions in the scaffold graph. In the fourth step, SLR extracts the simple paths from the scaffold graph to yield a draft scaffold set. Next, SLR inserts the ambiguous contigs into the draft scaffolds. The details of each step are described below. Note that the long reads whose lengths are longer than <italic>L</italic><sub><italic>r</italic></sub> and the contigs whose lengthes are longer than <italic>L</italic><sub><italic>c</italic></sub> are used by SLR. <italic>L</italic><sub><italic>r</italic></sub> and <italic>L</italic><sub><italic>c</italic></sub> are two parameters that can be defined by users. In addition, if a contig is completely contained in other contigs, SLR will ignore it in the following scaffolding steps.</p>
    <sec id="Sec11">
      <title>Producing local scaffolds</title>
      <p>SLR utilizes BWA-MEM to align <italic>LR</italic> against <italic>C</italic>, and the SAM file is converted to a BAM file by Bamtools [<xref ref-type="bibr" rid="CR27">27</xref>]. Due to the high sequencing error rate in long reads, the alignment positions are usually different from the real positions. With the following method, SLR first revises the alignment positions and obtains reliable alignments.</p>
      <p>For an alignment between the <italic>j</italic>-th long read <italic>l</italic><italic>r</italic><sub><italic>j</italic></sub> and the <italic>i</italic>-th contig <italic>c</italic><sub><italic>i</italic></sub>, we assume that the region [ <italic>s</italic><italic>r</italic><sub><italic>ij</italic></sub>, <italic>e</italic><italic>r</italic><sub><italic>ij</italic></sub>] in <italic>l</italic><italic>r</italic><sub><italic>j</italic></sub> is aligned with the region [ <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub>, <italic>e</italic><italic>c</italic><sub><italic>ij</italic></sub>] in <italic>c</italic><sub><italic>i</italic></sub>. If <italic>s</italic><italic>r</italic><sub><italic>ij</italic></sub>&lt;<italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub>, <italic>s</italic><italic>r</italic><italic>ij</italic>′ = 0 and <italic>s</italic><italic>c</italic><italic>ij</italic>′ = <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub> - <italic>s</italic><italic>r</italic><sub><italic>ij</italic></sub>, else <italic>s</italic><italic>c</italic><italic>ij</italic>′ = 0 and <italic>s</italic><italic>r</italic><italic>ij</italic>′ = <italic>s</italic><italic>r</italic><sub><italic>ij</italic></sub> - <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub>. If <italic>L</italic><italic>E</italic><italic>N</italic>(<italic>l</italic><italic>r</italic><sub><italic>j</italic></sub>)−<italic>e</italic><italic>r</italic><sub><italic>ij</italic></sub>&gt;<italic>L</italic><italic>E</italic><italic>N</italic>(<italic>c</italic><sub><italic>i</italic></sub>)−<italic>e</italic><italic>c</italic><sub><italic>ij</italic></sub>, <italic>e</italic><italic>r</italic><italic>ij</italic>′=<italic>e</italic><italic>r</italic><sub><italic>ij</italic></sub>+<italic>L</italic><italic>E</italic><italic>N</italic>(<italic>c</italic><sub><italic>i</italic></sub>)−<italic>e</italic><italic>c</italic><sub><italic>ij</italic></sub> and <italic>e</italic><italic>c</italic><italic>ij</italic>′ = <italic>L</italic><italic>E</italic><italic>N</italic>(<italic>c</italic><sub><italic>i</italic></sub>)−1, else <italic>e</italic><italic>c</italic><italic>ij</italic>′=<italic>e</italic><italic>c</italic><sub><italic>ij</italic></sub>+<italic>L</italic><italic>E</italic><italic>N</italic>(<italic>l</italic><italic>r</italic><sub><italic>j</italic></sub>)−<italic>e</italic><italic>r</italic><sub><italic>ij</italic></sub> and <italic>e</italic><italic>r</italic><italic>ij</italic>′=<italic>L</italic><italic>E</italic><italic>N</italic>(<italic>l</italic><italic>r</italic><sub><italic>j</italic></sub>)−1. <italic>L</italic><italic>E</italic><italic>N</italic>(<italic>l</italic><italic>r</italic><sub><italic>j</italic></sub>) and <italic>L</italic><italic>E</italic><italic>N</italic>(<italic>c</italic><sub><italic>i</italic></sub>) are the lengths of <italic>l</italic><italic>r</italic><sub><italic>j</italic></sub> and <italic>c</italic><sub><italic>i</italic></sub> respectively. [ <italic>s</italic><italic>r</italic><italic>ij</italic>′, <italic>e</italic><italic>r</italic><italic>ij</italic>′] and [ <italic>s</italic><italic>c</italic><italic>ij</italic>′, <italic>e</italic><italic>c</italic><italic>ij</italic>′] are the real alignment regions. An example of the revision is shown in Fig. <xref rid="Fig4" ref-type="fig">4</xref>. After revision, the alignment will be reliable if the following hold: i) The mapping quality is higher than <italic>s</italic><sub><italic>m</italic></sub> (a threshold with a default 20); ii) both the values <italic>e</italic><italic>r</italic><sub><italic>ij</italic></sub>−<italic>s</italic><italic>r</italic><sub><italic>ij</italic></sub> and <italic>e</italic><italic>c</italic><sub><italic>ij</italic></sub>−<italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub> are greater than <italic>l</italic><sub><italic>m</italic></sub> (a threshold with a default 100); iii) for each of <italic>s</italic><italic>r</italic><sub><italic>ij</italic></sub>, <italic>e</italic><italic>r</italic><sub><italic>ij</italic></sub>, <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub> and <italic>e</italic><italic>c</italic><sub><italic>ij</italic></sub>, the difference between its original position and its revised position is smaller than <italic>α</italic> (a threshold with a default 150). SLR retains only reliable alignments.
<fig id="Fig4"><label>Fig. 4</label><caption><p>An example of alignment position revision. For an alignment given by the alignment tool, the region [ <italic>s</italic><italic>r</italic><sub>11</sub>, <italic>e</italic><italic>r</italic><sub>11</sub>] (<italic>r</italic><italic>e</italic><italic>g</italic><italic>i</italic><italic>o</italic><italic>n</italic><sub>3</sub>) in the long read <italic>l</italic><italic>r</italic><sub>1</sub> is aligned with the region [ <italic>s</italic><italic>c</italic><sub>11</sub>, <italic>e</italic><italic>c</italic><sub>11</sub>] (<italic>r</italic><italic>e</italic><italic>g</italic><italic>i</italic><italic>o</italic><italic>n</italic><sub>1</sub>) in the contig <italic>c</italic><sub>1</sub>. Because <italic>s</italic><italic>r</italic><sub>11</sub>&lt;<italic>s</italic><italic>c</italic><sub>11</sub> and <italic>L</italic><italic>E</italic><italic>N</italic>(<italic>l</italic><italic>r</italic><sub>1</sub>)−<italic>e</italic><italic>r</italic><sub>11</sub>&gt;<italic>L</italic><italic>E</italic><italic>N</italic>(<italic>c</italic><sub>1</sub>)−<italic>e</italic><italic>c</italic><sub>11</sub>, it means the region [0, <italic>s</italic><italic>r</italic><sub>11</sub>] (<italic>r</italic><italic>e</italic><italic>g</italic><italic>i</italic><italic>o</italic><italic>n</italic><sub>4</sub>) in <italic>l</italic><italic>r</italic><sub>1</sub> is not aligned with <italic>c</italic><sub>1</sub>, and the region [ <italic>e</italic><italic>c</italic><sub>11</sub>,<italic>L</italic><italic>E</italic><italic>N</italic>(<italic>c</italic><sub>1</sub>)−1] (<italic>r</italic><italic>e</italic><italic>g</italic><italic>i</italic><italic>o</italic><italic>n</italic><sub>2</sub>) is not aligned with <italic>l</italic><italic>r</italic><sub>1</sub>. However, when <italic>l</italic><italic>r</italic><sub>1</sub> is truely aligned with <italic>c</italic><sub>1</sub> and the alignment is reliable, <italic>r</italic><italic>e</italic><italic>g</italic><italic>i</italic><italic>o</italic><italic>n</italic><sub>4</sub> should be aligned with the region [ <italic>s</italic><italic>c</italic><sub>11</sub>−<italic>s</italic><italic>r</italic><sub>11</sub>, <italic>s</italic><italic>c</italic><sub>11</sub>] in <italic>c</italic><sub>1</sub>, and <italic>r</italic><italic>e</italic><italic>g</italic><italic>i</italic><italic>o</italic><italic>n</italic><sub>2</sub> should be aligned with the region [ <italic>e</italic><italic>r</italic><sub>11</sub>, <italic>e</italic><italic>r</italic><sub>11</sub>+<italic>L</italic><italic>E</italic><italic>N</italic>(<italic>c</italic><sub>1</sub>)−<italic>e</italic><italic>c</italic><sub>11</sub>]. Because of the high sequencing error rate in long reads, the alignment tool usually does not provide accurate alignment start and end positions. Then, SLR sets <italic>s</italic><italic>c</italic>11′=<italic>s</italic><italic>c</italic><sub>11</sub>−<italic>s</italic><italic>r</italic><sub>11</sub>, <italic>s</italic><italic>r</italic>11′=0, <italic>e</italic><italic>c</italic>11′=<italic>L</italic><italic>E</italic><italic>N</italic>(<italic>c</italic><sub>1</sub>)−1 and <italic>e</italic><italic>r</italic>11′=<italic>e</italic><italic>r</italic><sub>11</sub>+<italic>L</italic><italic>E</italic><italic>N</italic>(<italic>c</italic><sub>1</sub>)−<italic>e</italic><italic>c</italic><sub>11</sub>. When the alignment is reliable, the region [ <italic>s</italic><italic>c</italic>11′, <italic>e</italic><italic>c</italic>11′] in <italic>c</italic><sub>1</sub> is aligned with the region [ <italic>s</italic><italic>r</italic>11′, <italic>e</italic><italic>r</italic>11′] in <italic>l</italic><italic>r</italic><sub>1</sub></p></caption><graphic xlink:href="12859_2019_3114_Fig4_HTML" id="MO4"/></fig>
</p>
      <p>A local scaffold is composed of ordered and oriented contigs that can be aligned with the same long read. The <italic>i</italic>-th local scaffold <italic>l</italic><italic>s</italic><sub><italic>i</italic></sub> is represented by the vertex sequence <italic>s</italic><sub><italic>i</italic>1</sub>,<italic>s</italic><sub><italic>i</italic>2</sub>,...<italic>s</italic><sub><italic>im</italic></sub>, where <italic>m</italic> is the number of contigs in the <italic>i</italic>-th local scaffold. <italic>s</italic><sub><italic>ij</italic></sub> is represented by a four-tuple (<italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub>,<italic>s</italic><italic>c</italic><italic>o</italic><sub><italic>ij</italic></sub>,<italic>s</italic><italic>c</italic><italic>g</italic><sub><italic>ij</italic></sub>,<italic>s</italic><italic>c</italic><italic>l</italic><sub><italic>ij</italic></sub>). <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub> refers to the <italic>j</italic>-th contig in <italic>l</italic><italic>s</italic><sub><italic>i</italic></sub>. <italic>s</italic><italic>c</italic><italic>o</italic><sub><italic>ij</italic></sub> denotes the alignment orientation between the contig and the long read. <italic>s</italic><italic>c</italic><italic>o</italic><sub><italic>ij</italic></sub>=1 represents forward alignment. <italic>s</italic><italic>c</italic><italic>o</italic><sub><italic>ij</italic></sub>=0 represents reverse alignment. <italic>s</italic><italic>c</italic><italic>g</italic><sub><italic>ij</italic></sub> denotes the gap distance between <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub> and <italic>s</italic><italic>c</italic><sub><italic>i</italic>(<italic>j</italic>+1)</sub>. In particular, the gap distance of the last vertex is zero. <italic>s</italic><italic>c</italic><italic>l</italic><sub><italic>ij</italic></sub> is the alignment length between <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub> and the long read. Note that if there are two or more contigs aligned with the same end of the long read, SLR keeps only the contig that has the greast alignment length. An example is shown in Fig. <xref rid="Fig5" ref-type="fig">5</xref>.
<fig id="Fig5"><label>Fig. 5</label><caption><p>There are six contigs (<italic>c</italic><sub>1</sub>,<italic>c</italic><sub>2</sub>,<italic>c</italic><sub>3</sub>,<italic>c</italic><sub>4</sub>,<italic>c</italic><sub>5</sub>,<italic>a</italic><italic>n</italic><italic>d</italic><italic>c</italic><sub>6</sub>) that can be aligned with the long read <italic>l</italic><italic>r</italic><sub>1</sub>. Because <italic>c</italic><sub>1</sub> and <italic>c</italic><sub>2</sub> are simultaneously aligned with the left end of <italic>l</italic><italic>r</italic><sub>1</sub>, SLR retains only contig <italic>c</italic><sub>1</sub> which has the greatest alignment length, and deletes the alignment information between <italic>c</italic><sub>2</sub> and <italic>l</italic><italic>r</italic><sub>1</sub>. Because <italic>c</italic><sub>5</sub> and <italic>c</italic><sub>6</sub> have been simultaneously aligned with the right end of <italic>l</italic><italic>r</italic><sub>1</sub>, we keep only <italic>c</italic><sub>5</sub>, and delete the alignment information between <italic>c</italic><sub>6</sub> and <italic>l</italic><italic>r</italic><sub>1</sub>. Finally, SLR determines the orders and orientations of <italic>c</italic><sub>1</sub>, <italic>c</italic><sub>3</sub>, <italic>c</italic><sub>4</sub> and <italic>c</italic><sub>5</sub>, which form a local scaffold</p></caption><graphic xlink:href="12859_2019_3114_Fig5_HTML" id="MO5"/></fig>
</p>
      <p>The contig <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub> is in the middle position of <italic>l</italic><italic>s</italic><sub><italic>i</italic></sub> if 1&lt;<italic>j</italic>&lt;<italic>m</italic>. <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub> and <italic>s</italic><italic>c</italic><sub><italic>i</italic>(<italic>j</italic>+1)</sub> are adjacent in <italic>l</italic><italic>s</italic><sub><italic>i</italic></sub>. If <italic>s</italic><italic>c</italic><italic>o</italic><sub><italic>ij</italic></sub>=1, <italic>s</italic><italic>c</italic><sub><italic>i</italic>(<italic>j</italic>−1)</sub>(<italic>j</italic>&gt;1) is the 5’-end neighbour contig of <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub>, and <italic>s</italic><italic>c</italic><sub><italic>i</italic>(<italic>j</italic>+1)</sub>(<italic>j</italic>&lt;<italic>m</italic>) is the 3’-end neighbour contig of <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub>. If <italic>s</italic><italic>c</italic><italic>o</italic><sub><italic>ij</italic></sub>=0, <italic>s</italic><italic>c</italic><sub><italic>i</italic>(<italic>j</italic>−1)</sub>(<italic>j</italic>&gt;1) is the 3’-end neighbour contig of <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub>, and <italic>s</italic><italic>c</italic><sub><italic>i</italic>(<italic>j</italic>+1)</sub>(<italic>j</italic>&lt;<italic>m</italic>) is the 5’-end neighbour contig of <italic>s</italic><italic>c</italic><sub><italic>ij</italic></sub>.</p>
      <p>In this step, SLR finally obtains a local scaffold set <italic>LS</italic>. Due to the high sequencing error rate, a contig may not be aligned with the long read that connects its left and right neighbour contigs. To resolve this problem, SLR deletes some local scaffolds. For example, the local scaffold <italic>l</italic><italic>s</italic><sub>1</sub> is (<italic>A</italic>,<italic>C</italic>), and the local scaffold <italic>l</italic><italic>s</italic><sub>2</sub> is (<italic>B</italic>,<italic>C</italic>). If the sum of <italic>L</italic><italic>E</italic><italic>N</italic>(<italic>B</italic>) and the gap distance between <italic>B</italic> and <italic>C</italic> in <italic>l</italic><italic>s</italic><sub>2</sub> is smaller than the gap distance between <italic>A</italic> and <italic>C</italic> in <italic>l</italic><italic>s</italic><sub>1</sub> and there exists a local scaffold (<italic>A</italic>,<italic>B</italic>,<italic>C</italic>), SLR removes <italic>l</italic><italic>s</italic><sub>1</sub>.</p>
    </sec>
    <sec id="Sec12">
      <title>Classifying contigs</title>
      <p>Repetitive regions are the critical problem in the process of scaffolding. When constructing a scaffold graph, the 5’-end (or 3’-end) of a repetitive contig can usually be linked with two or more other contigs, which complicates the scaffold graph. Because repetitive contigs commonly emerge in many different local scaffolds, they have two or more distinct 5’-end (or 3’-end) neighbour contigs. When a contig is not in the middle position of any local scaffold, no long read can span the contig to link its two neighbour contigs, and this contig is usually a long unique contig. Although the contig has multiple 5’-end or 3’-end neighbour contigs, SLR uses contradiction removal step to identify its correct neighbour contigs. Hence, SLR can identify whether a contig is unique based on its positions in the local scaffolds.</p>
      <p>To reduce the negative effects of short repetitive contigs, SLR considers a contig whose length is shorter than <italic>L</italic><sub><italic>ca</italic></sub> (a threshold that can be set by users) to be an ambiguous contig. These short contigs are temporally ignored in the local scaffolds. Next, the contigs longer than <italic>L</italic><sub><italic>ca</italic></sub> are classified using the following method.</p>
      <p>SLR identifies a contig as ambiguous if the following hold: i) The contig is in the middle position of one or more local scaffolds and ii) the number of 5’-end (or 3’-end) neighbour contigs of the contig is greater than one.</p>
      <p>After all ambiguous contigs have been identified, the remaining contigs are considered unique contigs. In this way, the contigs are classified into unique contigs and ambiguous contigs by SLR. An example of such contig classification is shown in Fig. <xref rid="Fig6" ref-type="fig">6</xref>.
<fig id="Fig6"><label>Fig. 6</label><caption><p>(a) There are six long reads: <italic>l</italic><italic>r</italic><sub>1</sub>, <italic>l</italic><italic>r</italic><sub>2</sub>, <italic>l</italic><italic>r</italic><sub>3</sub>, <italic>l</italic><italic>r</italic><sub>4</sub>, <italic>l</italic><italic>r</italic><sub>5</sub>, and <italic>l</italic><italic>r</italic><sub>6</sub>. The contigs <italic>c</italic><sub>1</sub> and <italic>c</italic><sub>2</sub> are aligned with <italic>l</italic><italic>r</italic><sub>1</sub>. <italic>c</italic><sub>3</sub>, <italic>c</italic><sub>4</sub> and <italic>c</italic><sub>5</sub> are aligned with <italic>l</italic><italic>r</italic><sub>2</sub>. <italic>c</italic><sub>6</sub>, <italic>c</italic><sub>4</sub> and <italic>c</italic><sub>7</sub> are aligned with <italic>l</italic><italic>r</italic><sub>3</sub>. <italic>c</italic><sub>7</sub>, <italic>c</italic><sub>8</sub> and <italic>c</italic><sub>9</sub> are aligned with <italic>l</italic><italic>r</italic><sub>4</sub>. <italic>c</italic><sub>10</sub>, <italic>c</italic><sub>11</sub> and <italic>c</italic><sub>12</sub> are aligned with <italic>l</italic><italic>r</italic><sub>5</sub>. <italic>c</italic><sub>9</sub>, <italic>c</italic><sub>11</sub>, <italic>c</italic><sub>13</sub> and <italic>c</italic><sub>2</sub> are aligned with <italic>l</italic><italic>r</italic><sub>6</sub>. We assume that all these alignments are forward, and all contigs are longer than <italic>L</italic><sub><italic>ca</italic></sub>. (b) Based on the alignment result described in (a), SLR obtains six local scaffolds: <italic>l</italic><italic>s</italic><sub>1</sub>, <italic>l</italic><italic>s</italic><sub>2</sub>, <italic>l</italic><italic>s</italic><sub>3</sub>, <italic>l</italic><italic>s</italic><sub>4</sub>, <italic>l</italic><italic>s</italic><sub>5</sub>, and <italic>l</italic><italic>s</italic><sub>6</sub>. (c) The scaffold graph <italic>G</italic><sub>1</sub> is built using all contigs. We find that <italic>G</italic><sub>1</sub> is complicated. (d) Based on the contig classification method described in Section 2.2, the contigs can be divided into two categories. Because <italic>c</italic><sub>4</sub> is located in the middle position of <italic>l</italic><italic>s</italic><sub>2</sub> and <italic>l</italic><italic>s</italic><sub>3</sub> and has two distinct 3’-end neighbours and two distinct 5’-end neighbour contigs, it is identified as an ambiguous contig. <italic>c</italic><sub>11</sub> is also an ambiguous contig. The remaining contigs are identified as unique contigs. The scaffold graph <italic>G</italic><sub>2</sub> is built based on unique contigs and is thus less complicated than <italic>G</italic><sub>1</sub></p></caption><graphic xlink:href="12859_2019_3114_Fig6_HTML" id="MO6"/></fig>
</p>
    </sec>
    <sec id="Sec13">
      <title>Constructing a scaffold graph</title>
      <p>A scaffold graph <italic>G</italic> is represented by a vertex set <italic>V</italic> and an edge set <italic>E</italic>. A vertex <italic>v</italic><sub><italic>i</italic></sub> corresponds to a contig <italic>c</italic><sub><italic>i</italic></sub>. An edge <italic>e</italic><sub><italic>ij</italic></sub> is denoted by a five-tuple (<italic>v</italic><sub><italic>i</italic></sub>,<italic>v</italic><sub><italic>j</italic></sub>,<italic>o</italic><sub><italic>ij</italic></sub>,<italic>g</italic><sub><italic>ij</italic></sub>,<italic>w</italic><sub><italic>ij</italic></sub>). Two vertices <italic>v</italic><sub><italic>i</italic></sub> and <italic>v</italic><sub><italic>j</italic></sub> are connected by <italic>e</italic><sub><italic>ij</italic></sub>. <italic>g</italic><sub><italic>ij</italic></sub> is the gap distance between <italic>v</italic><sub><italic>i</italic></sub> and <italic>v</italic><sub><italic>j</italic></sub>. <italic>o</italic><sub><italic>ij</italic></sub> is the relative orientation of <italic>v</italic><sub><italic>i</italic></sub> and <italic>v</italic><sub><italic>j</italic></sub>. There are four types of relative orientation between <italic>v</italic><sub><italic>i</italic></sub> and <italic>v</italic><sub><italic>j</italic></sub>: (i) the 3’-end of <italic>v</italic><sub><italic>i</italic></sub> is connected to the 5’-end of <italic>v</italic><sub><italic>j</italic></sub>; (ii) the 5’-end of <italic>v</italic><sub><italic>i</italic></sub> is connected to the 3’-end of <italic>v</italic><sub><italic>j</italic></sub>; (iii) the 5’-end of <italic>v</italic><sub><italic>i</italic></sub> is connected to the 5’-end of <italic>v</italic><sub><italic>j</italic></sub>, and (iv) the 3’-end of <italic>v</italic><sub><italic>i</italic></sub> is connected to the 3’-end of <italic>v</italic><sub><italic>j</italic></sub>. For types (i) and (ii), <italic>v</italic><sub><italic>i</italic></sub> and <italic>v</italic><sub><italic>j</italic></sub> are on the same strand. For the other two types, <italic>v</italic><sub><italic>i</italic></sub> and <italic>v</italic><sub><italic>j</italic></sub> are on the opposite strands. <italic>w</italic><sub><italic>ij</italic></sub> is the weight of the edge, which reflects its confidence.</p>
      <p>Neglecting the ambiguous contigs and constructing scaffold graph <italic>G</italic> with only unique contigs will significantly simplify <italic>G</italic> and reduce the difficulties in inferring the orders and orientations of the unique contigs. Therefore, all unique contigs make up the vertex set <italic>V</italic>. Below, we describe how to create the edge set <italic>E</italic>. The superiority of constructing a scaffold graph using unique contigs is illustrated in Fig. <xref rid="Fig6" ref-type="fig">6</xref>.</p>
      <sec id="Sec14">
        <title>Adding edges to the scaffold graph</title>
        <p>First, SLR ignores the ambiguous contigs in all local scaffolds; therefore, some non-adjacent unique contigs may become adjacent in one local scaffold. Assume that the <italic>i</italic>-th local scaffold <italic>l</italic><italic>s</italic><sub><italic>i</italic></sub>(<italic>s</italic><sub><italic>i</italic>1</sub>,<italic>s</italic><sub><italic>i</italic>2</sub>,...<italic>s</italic><sub><italic>im</italic></sub>) in <italic>LS</italic> includes two adjacent unique contigs <italic>s</italic><italic>c</italic><sub><italic>ip</italic></sub> and <italic>s</italic><italic>c</italic><sub><italic>is</italic></sub>. If one or more ambiguous contigs exist between <italic>s</italic><italic>c</italic><sub><italic>ip</italic></sub> and <italic>s</italic><italic>c</italic><sub><italic>is</italic></sub>, the gap distance between <italic>s</italic><italic>c</italic><sub><italic>ip</italic></sub> and <italic>s</italic><italic>c</italic><sub><italic>is</italic></sub> is re-calculated by formula (<xref rid="Equ1" ref-type="">1</xref>); otherwise, it is equal to <italic>s</italic><italic>c</italic><italic>g</italic><sub><italic>ip</italic></sub>. Here, <italic>G</italic><italic>D</italic>(<italic>s</italic><italic>c</italic><sub><italic>ip</italic></sub>,<italic>s</italic><italic>c</italic><sub><italic>is</italic></sub>,<italic>l</italic><italic>r</italic><sub><italic>i</italic></sub>) represents the gap distance between <italic>s</italic><italic>c</italic><sub><italic>ip</italic></sub> and <italic>s</italic><italic>c</italic><sub><italic>is</italic></sub> in <italic>l</italic><italic>s</italic><sub><italic>i</italic></sub>. Moreover, SLR can obtain a weight value, which is the minimum value of <italic>s</italic><italic>c</italic><italic>l</italic><sub><italic>ip</italic></sub> and <italic>s</italic><italic>c</italic><italic>l</italic><sub><italic>is</italic></sub>. The weight value can be used to evaluate the confidence level of the relation between <italic>s</italic><italic>c</italic><sub><italic>ip</italic></sub> and <italic>s</italic><italic>c</italic><sub><italic>is</italic></sub>. As the weight value becomes larger, the order of the two unique contigs becomes more reliable. 
<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ GD(sc_{ip}, sc_{is}, lr_{i}) = \sum\limits_{j = p}^{s - 1} {scg_{ij}} + \sum\limits_{j = p + 1}^{s - 1} {LEN(sc_{ij})}  $$ \end{document}</tex-math><mml:math id="M2"><mml:mtext mathvariant="italic">GD</mml:mtext><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ip</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">is</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mtext mathvariant="italic">sc</mml:mtext><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mtext mathvariant="italic">LEN</mml:mtext><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math><graphic xlink:href="12859_2019_3114_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>We assume that <italic>s</italic><italic>c</italic><sub><italic>ip</italic></sub> is represented by <italic>c</italic><sub><italic>a</italic></sub> and that <italic>s</italic><italic>c</italic><sub><italic>is</italic></sub> is represented by <italic>c</italic><sub><italic>b</italic></sub>. For <italic>c</italic><sub><italic>a</italic></sub> and <italic>c</italic><sub><italic>b</italic></sub>, SLR selects all local scaffolds in which <italic>c</italic><sub><italic>a</italic></sub> and <italic>c</italic><sub><italic>b</italic></sub> are adjacent. Next, SLR determines the relative orientation of the gap distance between and weight of <italic>c</italic><sub><italic>a</italic></sub> and <italic>c</italic><sub><italic>b</italic></sub> based on these local scaffolds. For two unique contigs, the relative order and orientation should be unique. If different values of <italic>o</italic><sub><italic>ab</italic></sub> are obtained from the local scaffolds, SLR keeps only the local scaffold set <italic>L</italic><italic>S</italic><sub><italic>ab</italic></sub> for which the value of <italic>o</italic><sub><italic>ab</italic></sub> is the same, and the number of elements in <italic>L</italic><italic>S</italic><sub><italic>ab</italic></sub> is the largest. The gap distance between <italic>c</italic><sub><italic>a</italic></sub> and <italic>c</italic><sub><italic>b</italic></sub> is calculated according to formula (<xref rid="Equ2" ref-type="">2</xref>). In addition, we can obtain a weight value for each local scaffold in <italic>L</italic><italic>S</italic><sub><italic>ab</italic></sub>. The final weight of <italic>c</italic><sub><italic>a</italic></sub> and <italic>c</italic><sub><italic>b</italic></sub> (denoted <italic>w</italic><sub><italic>ab</italic></sub>) can be obtained by seeking the maximum weight value obtained by the local scaffolds in <italic>L</italic><italic>S</italic><sub><italic>ab</italic></sub>. Then, SLR adds an edge <italic>e</italic><sub><italic>ab</italic></sub> to <italic>G</italic>. 
<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ g_{ab} = \frac{{\sum\limits_{i = 1}^{n} {GD(c_{a},c_{b},ls_{i})}}}{n}  $$ \end{document}</tex-math><mml:math id="M4"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ab</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mtext mathvariant="italic">GD</mml:mtext><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="12859_2019_3114_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>in which <italic>n</italic> is the number of elements in <italic>L</italic><italic>S</italic><sub><italic>ab</italic></sub>, and <italic>l</italic><italic>s</italic><sub><italic>i</italic></sub>∈<italic>L</italic><italic>S</italic><sub><italic>ab</italic></sub>.</p>
        <p>After processing all pairs of unique contigs in <italic>LS</italic>, a draft scaffold graph <italic>G</italic> can be constructed by SLR for the subsequent steps.</p>
      </sec>
      <sec id="Sec15">
        <title>Removing contradictions</title>
        <p>Due to sequencing errors in long reads and complex repetitive regions, the scaffold graph <italic>G</italic> may still contain some spurious edges. Detecting and removing the spurious edges in <italic>G</italic> can be viewed as detecting and removing the orientation and position contradictions [<xref ref-type="bibr" rid="CR10">10</xref>, <xref ref-type="bibr" rid="CR11">11</xref>]. BOSS utilizes an iterative strategy to detect and remove contradictions. BOSS first constructs a sub-graph that includes only edges with a high weight. Next, it iteratively adds the remaining edges to the sub-graph from high to low weight. Each iteration includes a sub-graph, and BOSS builds two linear programming models [<xref ref-type="bibr" rid="CR28">28</xref>] to solve orientation and position contradictions in the sub-graph. SLR utilizes a revised method based on BOSS to remove contradictions. The difference in SLR compared to BOSS is that SLR adds all edges to the sub-graph in the first iteration. Hence, SLR completes contradiction removal within one iteration, while BOSS requires several iterations. The methods of building the linear programming model of BOSS and SLR are the same, as described below.</p>
        <p>First, SLR detects and deletes orientation contradictions. For the edge <italic>e</italic><sub><italic>ij</italic></sub>∈<italic>G</italic>, if <italic>o</italic><sub><italic>i</italic></sub>≠<italic>o</italic><sub><italic>j</italic></sub>, SLR constructs constraint Eq. (<xref rid="Equ3" ref-type="">3</xref>). If <italic>o</italic><sub><italic>i</italic></sub>=<italic>o</italic><sub><italic>j</italic></sub>, SLR constructs constraint Eq. (<xref rid="Equ4" ref-type="">4</xref>). 
<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \eta_{ij} &lt; = o_{i} + o_{j} &lt; = 2 - \eta_{ij}  $$ \end{document}</tex-math><mml:math id="M6"><mml:msub><mml:mrow><mml:mi>η</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>o</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>o</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>η</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub></mml:math><graphic xlink:href="12859_2019_3114_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>
          <disp-formula id="Equ4">
            <label>4</label>
            <alternatives>
              <tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \eta_{ij} - 1 &lt; = o_{i} - o_{j} &lt; = 1 - \eta_{ij}  $$ \end{document}</tex-math>
              <mml:math id="M8">
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>η</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext mathvariant="italic">ij</mml:mtext>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>&lt;</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>o</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>−</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>o</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>&lt;</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>−</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>η</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext mathvariant="italic">ij</mml:mtext>
                  </mml:mrow>
                </mml:msub>
              </mml:math>
              <graphic xlink:href="12859_2019_3114_Article_Equ4.gif" position="anchor"/>
            </alternatives>
          </disp-formula>
        </p>
        <p>in which <italic>η</italic><sub><italic>ij</italic></sub>∈{0,1} is a variable that represents whether <italic>e</italic><sub><italic>ij</italic></sub> is spurious. 0<sub><italic>i</italic></sub>∈{0,1} is also a variable that denotes the orientation of <italic>v</italic><sub><italic>i</italic></sub>. The objective function is <inline-formula id="IEq1"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$MAX(\sum \ {(w_{ij}*\eta _{ij})})$\end{document}</tex-math><mml:math id="M10"><mml:mtext mathvariant="italic">MAX</mml:mtext><mml:mo>(</mml:mo><mml:mo>∑</mml:mo><mml:mspace width="1em"/><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>∗</mml:mo><mml:msub><mml:mrow><mml:mi>η</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_3114_Article_IEq1.gif"/></alternatives></inline-formula>.</p>
        <p>Second, SLR detects and deletes position contradictions. For the edge <italic>e</italic><sub><italic>ij</italic></sub>∈<italic>G</italic>, SLR constructs constraint Eq. (<xref rid="Equ5" ref-type="">5</xref>). 
<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ L(\phi_{ij} - 1) &lt; = p_{j} - p_{i} - len(c_{i}) - gd_{ij} &lt; = L(1 - \phi_{ij})  $$ \end{document}</tex-math><mml:math id="M12"><mml:mi>L</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>&lt;</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mtext mathvariant="italic">len</mml:mtext><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>g</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math><graphic xlink:href="12859_2019_3114_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>in which <italic>p</italic><sub><italic>i</italic></sub> is a variable that represents the assigned position of <italic>v</italic><sub><italic>i</italic></sub>. <italic>ϕ</italic><sub><italic>ij</italic></sub> is a slack variable in the range [0,1] that reflects the consistency between <italic>g</italic><sub><italic>ij</italic></sub> and |<italic>p</italic><sub><italic>j</italic></sub>−<italic>p</italic><sub><italic>i</italic></sub>|. The objective function is <inline-formula id="IEq2"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$MAX(\sum \ {(w_{ij}*\phi _{ij})})$\end{document}</tex-math><mml:math id="M14"><mml:mtext mathvariant="italic">MAX</mml:mtext><mml:mo>(</mml:mo><mml:mo>∑</mml:mo><mml:mspace width="1em"/><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>∗</mml:mo><mml:msub><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ij</mml:mtext></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_3114_Article_IEq2.gif"/></alternatives></inline-formula>. For an edge, if the gap distance computed by the assigned position is far from the original one, the edge is deemed spurious one, and then SLR deletes it from <italic>G</italic>.</p>
        <p>After eliminating the orientation and position contradictions, if there are two or more edges linking the same end of a vertex, SLR keeps only the edge with the highest weight and removes the others. Consequently, the scaffold graph <italic>G</italic> contains only simple paths.</p>
      </sec>
    </sec>
    <sec id="Sec16">
      <title>Generating scaffolds</title>
      <p>Each simple path in <italic>G</italic> refers to a scaffold, and SLR selects all simple paths and constructs a draft scaffold set. For any two adjacent vertices in the draft scaffold, SLR scans the local scaffold set <italic>LS</italic> again and finds local scaffolds that contain them. If ambiguous contigs exist between these vertices in a local scaffold, these ordered and oriented ambiguous contigs correspond to a path. If there are two or more different paths, SLR selects the one with the greatest number of local scaffolds that support it and then inserts it between the two vertices. Note that an ambiguous contig may occur two or more times in the scaffolds.</p>
      <p>Next, SLR selects local scaffolds that contain the first contig of a scaffold. SLR constructs a scaffold graph based on these local scaffolds. If a simple path starts from the first contig in the scaffold graph, it is merged with the head of the scaffold. In the same way, SLR extends the tail of the scaffold. Once the first <italic>t</italic> contigs of a scaffold are the same as the last <italic>t</italic> contigs of another scaffold (<italic>t</italic> is a threshold set by users), SLR will merge them together to form a new scaffold. In the same way, SLR will reverse a scaffold and detect whether it can be merged with other scaffolds. Finally, SLR outputs the scaffolds as the final result.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary information</title>
    <sec id="Sec17">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="12859_2019_3114_MOESM1_ESM.doc">
            <caption>
              <p><bold>Additional file 1</bold> It includes seven sections: (i) Datasets; (ii) Command lines; (iii) Scaffolding results about nine datasets; (iv) Different values of <italic>L</italic><sub><italic>ca</italic></sub> for scaffolding; (v) Scaffolding results about SLR1 and SLR2; (vi) SSPACE-LR and LINKS combined with contig classification method; (vii) Scaffolding results based on repeat-aware evaluation framework.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>
          <italic>Chr X</italic>
        </term>
        <def>
          <p>
            <italic>Human chromosome X</italic>
          </p>
        </def>
      </def-item>
      <def-item>
        <term>
          <italic>E. coli</italic>
        </term>
        <def>
          <p>
            <italic>Escherichia coli</italic>
          </p>
        </def>
      </def-item>
      <def-item>
        <term>
          <italic>S. cerevisiae</italic>
        </term>
        <def>
          <p>
            <italic>Saccharomyces cerevisiae W303</italic>
          </p>
        </def>
      </def-item>
      <def-item>
        <term>SLR</term>
        <def>
          <p>Scaffolding algorithm based on Long Reads and contig classification</p>
        </def>
      </def-item>
      <def-item>
        <term>SMRT</term>
        <def>
          <p>Single-Molecule Real-Time</p>
        </def>
      </def-item>
      <def-item>
        <term>SSPACE-LR</term>
        <def>
          <p>SSPACE-LongRead</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Supplementary information</title>
    <p><bold>Supplementary information</bold> accompanies this paper at 10.1186/s12859-019-3114-9.</p>
  </sec>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors would like to thank professor Zhiheng Wang, anonymous reviewers, and editors for their helpful comments and suggestions.</p>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>JW participated in the design of the study and the analysis of the experimental results. MN, XH, and RR performed the implementation. HM and CK wrote the manuscript. All authors have read and approved the final manuscript for publication.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>This work was supported in part by the National Natural Science Foundation of China under Grant No.61602156, No.61972134, No.61802113, No.61772557, and No.61433012, Henan Provincial Department of Science and Technology Research Project under Grant No.192102210118, Doctor Foundation of Henan Polytechnic University under Grant No.B2018-36, Henan Science and Technology Innovation Outstanding Youth Program under Grant No.184100510009, Henan University Scientific and Technological Innovation Team Support Program under Grant No.19IRTSTHN012. The funding bodies did not play any role in the design of the study and collection, analysis, and interpretation of data and in writing the manuscript.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>All datasets used in this paper and command lines for all scaffolding tools are provided in Additional file <xref rid="MOESM1" ref-type="media">1</xref>.</p>
  </notes>
  <notes>
    <title>Ethics approval and consent to participate</title>
    <p>Not applicable.</p>
  </notes>
  <notes>
    <title>Consent for publication</title>
    <p>Not applicable.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sedlazeck</surname>
            <given-names>FJ</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Darby</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Schatz</surname>
            <given-names>MC</given-names>
          </name>
        </person-group>
        <article-title>Piercing the dark matter: bioinformatics of long-range sequencing and mapping</article-title>
        <source>Nature Rev Genet</source>
        <year>2018</year>
        <volume>19</volume>
        <issue>6</issue>
        <fpage>329</fpage>
        <?supplied-pmid 29599501?>
        <pub-id pub-id-type="pmid">29599501</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Junwei</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Jianxin</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Zhen</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Fang-Xiang</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Min</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Yi</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Epga: de novo assembly using the distributions of reads and insert size</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <issue>6</issue>
        <fpage>825</fpage>
        <lpage>33</lpage>
        <pub-id pub-id-type="pmid">25406329</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Luo</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>FX</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Pan</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>Epga2: memory-efficient de novo assembler</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <issue>24</issue>
        <fpage>3988</fpage>
        <lpage>90</lpage>
        <?supplied-pmid 26315905?>
        <pub-id pub-id-type="pmid">26315905</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hunt</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Newbold</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Berriman</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Otto</surname>
            <given-names>TD</given-names>
          </name>
        </person-group>
        <article-title>A comprehensive evaluation of assembly scaffolding tools</article-title>
        <source>Genome Biol,15,3(2014-03-03)</source>
        <year>2014</year>
        <volume>15</volume>
        <issue>3</issue>
        <fpage>42</fpage>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gao</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Sung</surname>
            <given-names>WK</given-names>
          </name>
          <name>
            <surname>Nagarajan</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Opera: Reconstructing optimal genomic scaffolds with high-throughput paired-end sequences</article-title>
        <source>J Comput Biol</source>
        <year>2011</year>
        <volume>18</volume>
        <issue>11</issue>
        <fpage>1681</fpage>
        <lpage>91</lpage>
        <?supplied-pmid 21929371?>
        <pub-id pub-id-type="pmid">21929371</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Marten</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Christiaan V</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Hans J</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Derek</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Walter</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Scaffolding pre-assembled contigs using sspace</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>4</issue>
        <fpage>578</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="pmid">21149342</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sahlin</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Vezzi</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Nystedt</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Lundeberg</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Arvestad</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Besst - efficient scaffolding of large fragmented assemblies</article-title>
        <source>Bmc Bioinformatics</source>
        <year>2014</year>
        <volume>15</volume>
        <issue>1</issue>
        <fpage>281</fpage>
        <?supplied-pmid 25128196?>
        <pub-id pub-id-type="pmid">25128196</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mandric</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Zelikovsky</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Scaffmatch: Scaffolding algorithm based on maximum weight matching</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <issue>16</issue>
        <fpage>2632</fpage>
        <lpage>8</lpage>
        <?supplied-pmid 25890305?>
        <pub-id pub-id-type="pmid">25890305</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nilgun</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Michael</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Scarpa: scaffolding reads with practical algorithms</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <issue>4</issue>
        <fpage>428</fpage>
        <lpage>34</lpage>
        <pub-id pub-id-type="pmid">23274213</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bodily</surname>
            <given-names>PM</given-names>
          </name>
          <name>
            <surname>Fujimoto</surname>
            <given-names>MS</given-names>
          </name>
          <name>
            <surname>Snell</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Dan</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Clement</surname>
            <given-names>MJ</given-names>
          </name>
        </person-group>
        <article-title>Scaffoldscaffolder: solving contig orientation via bidirected to directed graph reduction</article-title>
        <source>Bioinformatics</source>
        <year>2016</year>
        <volume>32</volume>
        <issue>1</issue>
        <fpage>17</fpage>
        <?supplied-pmid 26382194?>
        <pub-id pub-id-type="pmid">26382194</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Luo</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>FX</given-names>
          </name>
        </person-group>
        <article-title>Boss: a novel scaffolding algorithm based on an optimized scaffold graph</article-title>
        <source>Bioinformatics</source>
        <year>2016</year>
        <volume>33</volume>
        <issue>2</issue>
        <fpage>169</fpage>
        <?supplied-pmid 27634951?>
        <pub-id pub-id-type="pmid">27634951</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Boetzer</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Pirovano</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Sspace-longread: scaffolding bacterial draft genomes using long read sequence information</article-title>
        <source>Bmc Bioinformatics</source>
        <year>2014</year>
        <volume>15</volume>
        <issue>1</issue>
        <fpage>211</fpage>
        <lpage>1</lpage>
        <?supplied-pmid 24950923?>
        <pub-id pub-id-type="pmid">24950923</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chaisson</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Mapping single molecule sequencing reads using basic local alignment with successive refinement (blasr): application and theory</article-title>
        <source>Bmc Bioinformatics</source>
        <year>2012</year>
        <volume>13</volume>
        <issue>1</issue>
        <fpage>238</fpage>
        <?supplied-pmid 22988817?>
        <pub-id pub-id-type="pmid">22988817</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Warren</surname>
            <given-names>RL</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Vandervalk</surname>
            <given-names>BP</given-names>
          </name>
          <name>
            <surname>Behsaz</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Lagman</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>SJM</given-names>
          </name>
          <name>
            <surname>Birol</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <article-title>Links: Scalable, alignment-free scaffolding of draft genomes with long reads</article-title>
        <source>GigaScience,4,1(2015-08-04)</source>
        <year>2015</year>
        <volume>4</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <lpage>11</lpage>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhu</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>DZ</given-names>
          </name>
          <name>
            <surname>Emrich</surname>
            <given-names>SJ</given-names>
          </name>
        </person-group>
        <article-title>Single molecule sequencing-guided scaffolding and correction of draft assemblies</article-title>
        <source>BMC genomics</source>
        <year>2017</year>
        <volume>18</volume>
        <issue>10</issue>
        <fpage>879</fpage>
        <?supplied-pmid 29244003?>
        <pub-id pub-id-type="pmid">29244003</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Delcher</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Smoot</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Shumway</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Antonescu</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Versatile and open software for comparing large genomes</article-title>
        <source>Genome Biol</source>
        <year>2004</year>
        <volume>5</volume>
        <issue>2</issue>
        <fpage>12</fpage>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Warren</surname>
            <given-names>RL</given-names>
          </name>
        </person-group>
        <article-title>Rails and cobbler: Scaffolding and automated finishing of draft genomes using long dna sequences</article-title>
        <source>J Open Source Softw</source>
        <year>2016</year>
        <volume>1</volume>
        <issue>7</issue>
        <fpage>116</fpage>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>René L</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Granger G</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Steven J M</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Robert A</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Assembling millions of short dna sequences using ssake</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <issue>4</issue>
        <fpage>500</fpage>
        <lpage>1</lpage>
        <pub-id pub-id-type="pmid">17158514</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cao</surname>
            <given-names>MD</given-names>
          </name>
          <name>
            <surname>Nguyen</surname>
            <given-names>SH</given-names>
          </name>
          <name>
            <surname>Ganesamoorthy</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Elliott</surname>
            <given-names>AG</given-names>
          </name>
          <name>
            <surname>Cooper</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Coin</surname>
            <given-names>LJM</given-names>
          </name>
        </person-group>
        <article-title>Scaffolding and completing genome assemblies in real-time with nanopore sequencing</article-title>
        <source>Nature Commun</source>
        <year>2017</year>
        <volume>8</volume>
        <fpage>14515</fpage>
        <pub-id pub-id-type="pmid">28218240</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weisenfeld</surname>
            <given-names>NI</given-names>
          </name>
          <name>
            <surname>Kumar</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Shah</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Church</surname>
            <given-names>DM</given-names>
          </name>
          <name>
            <surname>Jaffe</surname>
            <given-names>DB</given-names>
          </name>
        </person-group>
        <article-title>Direct determination of diploid genome sequences</article-title>
        <source>Genome Res</source>
        <year>2017</year>
        <volume>27</volume>
        <issue>5</issue>
        <fpage>757</fpage>
        <lpage>67</lpage>
        <?supplied-pmid 28381613?>
        <pub-id pub-id-type="pmid">28381613</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kuleshov</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Snyder</surname>
            <given-names>MP</given-names>
          </name>
          <name>
            <surname>Batzoglou</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Genome assembly from synthetic long read clouds</article-title>
        <source>Bioinformatics</source>
        <year>2016</year>
        <volume>32</volume>
        <issue>12</issue>
        <fpage>216</fpage>
        <lpage>24</lpage>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yeo</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Coombe</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Chu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Warren</surname>
            <given-names>RL</given-names>
          </name>
          <name>
            <surname>Birol</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <article-title>Arcs: Scaffolding genome drafts with linked reads</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>34</volume>
        <issue>5</issue>
        <fpage>725</fpage>
        <lpage>31</lpage>
        <?supplied-pmid 29069293?>
        <pub-id pub-id-type="pmid">29069293</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Andrew</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Kitzman</surname>
            <given-names>JO</given-names>
          </name>
          <name>
            <surname>Burton</surname>
            <given-names>JN</given-names>
          </name>
          <name>
            <surname>Riza</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Akash</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Lena</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Mostafa</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Sasan</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Kevin</surname>
            <given-names>LG</given-names>
          </name>
          <name>
            <surname>Steemers</surname>
            <given-names>FJ</given-names>
          </name>
        </person-group>
        <article-title>In vitro, long-range sequence information for de novo genome assembly via transposase contiguity</article-title>
        <source>Genome Res</source>
        <year>2014</year>
        <volume>24</volume>
        <issue>12</issue>
        <fpage>2041</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="pmid">25327137</pub-id>
      </element-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gurevich</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Saveliev</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Vyahhi</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Quast: quality assessment tool for genome assemblies</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <issue>8</issue>
        <fpage>1072</fpage>
        <lpage>5</lpage>
        <?supplied-pmid 23422339?>
        <pub-id pub-id-type="pmid">23422339</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <mixed-citation publication-type="other">Li H. Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM. 2013. arXiv preprint arXiv:1303.3997.</mixed-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mandric</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Knyazev</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Zelikovsky</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Repeat aware evaluation of scaffolding tools</article-title>
        <source>Bioinformatics</source>
        <year>2017</year>
        <volume>34</volume>
        <issue>15</issue>
        <fpage>2530</fpage>
        <lpage>7</lpage>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Barnett</surname>
            <given-names>DW</given-names>
          </name>
          <name>
            <surname>Garrison</surname>
            <given-names>EK</given-names>
          </name>
          <name>
            <surname>Quinlan</surname>
            <given-names>AR</given-names>
          </name>
          <name>
            <surname>Stromberg</surname>
            <given-names>MP</given-names>
          </name>
          <name>
            <surname>Marth</surname>
            <given-names>GT</given-names>
          </name>
        </person-group>
        <article-title>Bamtools: a c++ api and toolkit for analyzing and managing bam files</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>12</issue>
        <fpage>1691</fpage>
        <lpage>2</lpage>
        <?supplied-pmid 21493652?>
        <pub-id pub-id-type="pmid">21493652</pub-id>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <mixed-citation publication-type="other">Berkelaar M, Eikland K, Notebaert P. lp_solve 5.5, open source (mixed-integer) linear programming system. Software. May 1 2004.</mixed-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <mixed-citation publication-type="other">Lee H, Gurtowski J, Yoo S, Marcus S, Mccombie WR, Schatz M. Error correction and assembly complexity of single molecule sequencing reads. Biorxiv. 2014:006395.</mixed-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goodwin</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Gurtowski</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Ethe-Sayers</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Deshpande</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Schatz</surname>
            <given-names>MC</given-names>
          </name>
          <name>
            <surname>Mccombie</surname>
            <given-names>WR</given-names>
          </name>
        </person-group>
        <article-title>Oxford nanopore sequencing, hybrid error correction, and de novo assembly of a eukaryotic genome</article-title>
        <source>Genome Res</source>
        <year>2015</year>
        <volume>25</volume>
        <issue>11</issue>
        <fpage>1750</fpage>
        <?supplied-pmid 26447147?>
        <pub-id pub-id-type="pmid">26447147</pub-id>
      </element-citation>
    </ref>
    <ref id="CR31">
      <label>31</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Xu</surname>
            <given-names>G-C</given-names>
          </name>
          <name>
            <surname>Xu</surname>
            <given-names>T-J</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>S-Q</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>H-W</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>J-T</given-names>
          </name>
        </person-group>
        <article-title>Lr_gapcloser: a tiling path-based gap closer that uses long reads to complete genome assembly</article-title>
        <source>GigaScience</source>
        <year>2019</year>
        <volume>8</volume>
        <issue>1</issue>
        <fpage>giy157</fpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
