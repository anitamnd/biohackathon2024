<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title>BMC Bioinformatics</journal-title>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2246154</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-9-11</article-id>
    <article-id pub-id-type="pmid">18184432</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-9-11</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>SeqAn An efficient, generic C++ library for sequence analysis</article-title>
    </title-group>
    <contrib-group>
      <contrib id="A1" corresp="yes" contrib-type="author">
        <name>
          <surname>Döring</surname>
          <given-names>Andreas</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>doering@inf.fu-berlin.de</email>
      </contrib>
      <contrib id="A2" contrib-type="author">
        <name>
          <surname>Weese</surname>
          <given-names>David</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>weese@inf.fu-berlin.de</email>
      </contrib>
      <contrib id="A3" contrib-type="author">
        <name>
          <surname>Rausch</surname>
          <given-names>Tobias</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>rausch@inf.fu-berlin.de</email>
      </contrib>
      <contrib id="A4" contrib-type="author">
        <name>
          <surname>Reinert</surname>
          <given-names>Knut</given-names>
        </name>
        <email>reinert@inf.fu-berlin.de</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Algorithmische Bioinformatik, Institut für Informatik, Takustr. 9, 14195 Berlin, Germany</aff>
    <aff id="I2"><label>2</label>International Max Planck Research School for Computational Biology and Scientific Computing, Ihnestr. 63 – 73, 14195 Berlin, Germany</aff>
    <pub-date pub-type="collection">
      <year>2008</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>9</day>
      <month>1</month>
      <year>2008</year>
    </pub-date>
    <volume>9</volume>
    <fpage>11</fpage>
    <lpage>11</lpage>
    <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/9/11"/>
    <history>
      <date date-type="received">
        <day>21</day>
        <month>8</month>
        <year>2007</year>
      </date>
      <date date-type="accepted">
        <day>9</day>
        <month>1</month>
        <year>2008</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2008 Döring et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2008</copyright-year>
      <copyright-holder>Döring et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        <!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               D&#x000f6;ring
               Andreas
               
               doering@inf.fu-berlin.de
            </dc:author><dc:title>
            SeqAn An efficient, generic C++ library for sequence analysis
         </dc:title><dc:date>2008</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 9(1): 11-. (2008)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2008)9:1&#x0003c;11&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>-->
      </license>
    </permissions>
    <abstract>
      <sec>
        <title>Background</title>
        <p>The use of novel algorithmic techniques is pivotal to many important problems in life science. For example the sequencing of the human genome [<xref ref-type="bibr" rid="B1">1</xref>] would not have been possible without advanced assembly algorithms. However, owing to the high speed of technological progress and the urgent need for bioinformatics tools, there is a widening gap between state-of-the-art algorithmic techniques and the actual algorithmic components of tools that are in widespread use.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>To remedy this trend we propose the use of SeqAn, a library of efficient data types and algorithms for sequence analysis in computational biology. SeqAn comprises implementations of existing, practical state-of-the-art algorithmic components to provide a sound basis for algorithm testing and development. In this paper we describe the design and content of SeqAn and demonstrate its use by giving two examples. In the first example we show an application of SeqAn as an experimental platform by comparing different exact string matching algorithms. The second example is a simple version of the well-known MUMmer tool rewritten in SeqAn. Results indicate that our implementation is very efficient and versatile to use.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>We anticipate that SeqAn greatly simplifies the rapid development of new bioinformatics tools by providing a collection of readily usable, well-designed algorithmic components which are fundamental for the field of sequence analysis. This leverages not only the implementation of new algorithms, but also enables a sound analysis and comparison of existing algorithms.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Biological sequence analysis is the heart of computational biology. Many successful algorithms (e.g., Myers' bit-vector search algorithm [<xref ref-type="bibr" rid="B2">2</xref>], BLAST [<xref ref-type="bibr" rid="B3">3</xref>]) and data structures (e.g., suffix arrays [<xref ref-type="bibr" rid="B4">4</xref>], <italic>q</italic>-gram based string indices, sequence profiles) have been developed over the last twenty years. The assemblies of large eucaryotic genomes like <italic>Drosophila melanogaster </italic>[<xref ref-type="bibr" rid="B5">5</xref>], human [<xref ref-type="bibr" rid="B1">1</xref>], and mouse [<xref ref-type="bibr" rid="B6">6</xref>] are prime examples where algorithm research was successfully applied to a biological problem. However, with entire genomes at hand, large scale analysis algorithms that require considerable computing resources are becoming increasingly important (e.g., Lagan [<xref ref-type="bibr" rid="B7">7</xref>], MUMmer [<xref ref-type="bibr" rid="B8">8</xref>], MGA [<xref ref-type="bibr" rid="B9">9</xref>], Mauve [<xref ref-type="bibr" rid="B10">10</xref>]). Although these tools use slightly different algorithms, nearly all of them require some basic algorithmic components, like suffix arrays, string searches, alignments, or the chaining of fragments. This is illustrated in Fig. <xref ref-type="fig" rid="F1">1</xref> for the case of genome comparison tools. However, it is non-trivial to obtain efficient implementations of these components. Therefore, suboptimal data types and <italic>ad-hoc </italic>algorithms are frequently employed in practice, or one has to resort to stringing standalone tools together. Both approaches may be suitable at times, but it would clearly be much more desirable to use an integrated library of state-of-the-art components that can be combined in various ways, either to develop new applications or to compare alternative implementations. In this article we propose SeqAn, a novel C++ library of efficient data types and algorithms for sequence analysis in computational biology.</p>
    <fig position="float" id="F1">
      <label>Figure 1</label>
      <caption>
        <p>Genome comparison tools and their algorithmic components.</p>
      </caption>
      <graphic xlink:href="1471-2105-9-11-1"/>
    </fig>
    <p>In other fields, software libraries have greatly advanced the transfer of algorithmic knowledge to the tool programming process. Two of the best known examples are the LEDA library [<xref ref-type="bibr" rid="B11">11</xref>] for algorithms on graphs and efficient data types and the CGAL library [<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>] for computational geometry. In bioinformatics, a comparable library is still missing although there is a need for integrated implementations of algorithms for aligning sequences, computing substring indices in primary and secondary memory, or filter algorithms. In addition, a library that adheres to the principles of algorithm engineering is essential as a means to test and compare existing tools as well as to evaluate the results from algorithmic research. The lack of such a library becomes evident when reviewing the related work of the past years.</p>
    <p>A few C++ libraries with sequence analysis features have already been developed, including Bio++ [<xref ref-type="bibr" rid="B14">14</xref>], Libcov [<xref ref-type="bibr" rid="B15">15</xref>], the Bioinformatics Template Library (BTL) [<xref ref-type="bibr" rid="B16">16</xref>], the NCBI C++ Toolkit [<xref ref-type="bibr" rid="B17">17</xref>], or the Sequence Class Library (SCL) [<xref ref-type="bibr" rid="B18">18</xref>]. Bio++ is the most comprehensive library providing re-usable components for phylogenetics, molecular evolution, and population genetics. The sequence analysis part is, however, limited to basic import/export capabilities and string manipulations. In contrast to SeqAn, which is based upon the generic programming paradigm, Bio++ is a purely object-oriented library, favoring ease of development over performance and scalability. Libcov focusses on phylogenetics and clustering algorithms. It offers only basic data structures to handle sets of sequences. Alignment algorithms, database indices, or scoring matrices are not provided. The BTL emphasizes basic <italic>mathematical </italic>algorithms and data structures. It currently comprises graph classes and linear algebra algorithms but only a single sequence alignment algorithm, Needleman-Wunsch [<xref ref-type="bibr" rid="B19">19</xref>] with cubic running time. The NCBI C++ Toolkit also offers, beside other things, some sequence analysis functionality, e.g. alignment algorithms. The SCL, providing some basic sequence analysis components, is to our knowledge not activly developed anymore.</p>
    <p>Besides these C++ libraries, we are aware of alternative approaches like BioPerl [<xref ref-type="bibr" rid="B20">20</xref>] or BioJava [<xref ref-type="bibr" rid="B21">21</xref>]. The main purpose of BioPerl is to ease the development of sequence analysis pipelines by providing an interface to already existing tools. BioJava on the other hand is suited for developing new sequence analysis tools by providing many relevant data structures and algorithms and as such is from the overall goals perhaps closest to SeqAn. Some algorithms are shared by both libraries (like Needleman-Wunsch and Smith Waterman). A closer inspection, however, reveals that BioJava does only offer a small part of SeqAn's functionality (no indices, no algorithms for de novo motif search, no algorithms for multiple alignment, etc.). Hence both libraries are in this sense complementary. In addition, we show in the result section that our implementations are for standard alignment problems by a factor of 6 to 350 times faster and by a factor of 600 to 1500 times more space efficient.</p>
    <p>The exposition is structured as follows: To emphasize the usefulness of SeqAn, this article centers around the contents of the library, described in Section and the practical application of SeqAn, exemplified in Section. In the following section we start by giving a brief outline of the design principles SeqAn is based on.</p>
  </sec>
  <sec>
    <title>Implementation</title>
    <sec>
      <title>Library Design</title>
      <p>For developing the basic design, SeqAn has gone through an extensive conceptual phase in which we evaluated many designs and prototypic implementations. SeqAn has now a generic programming design that guarantees high performance, generality, extensibility, simplicity, and easy integration with other libraries. This design is based on four design principles which we will describe now.</p>
      <sec>
        <title>Generic Programming</title>
        <p>SeqAn adopts the generic programming paradigm that proved to be a key technique for achieving high performance algorithms in the C++ standard library [<xref ref-type="bibr" rid="B22">22</xref>]. Generic programming refers to a special style of programming where concrete types are substituted by exchangeable template types. Hence, classes and algorithms are written only once, but can be applied to different data types.</p>
      </sec>
      <sec>
        <title>Global Function Interfaces</title>
        <p>SeqAn uses global functions instead of member functions to access objects (we act here on an advice of [<xref ref-type="bibr" rid="B23">23</xref>], see Section 6.10.2.). This strategy improves the flexibility and the scalability of our library, since global functions, unlike member functions, can be added to a program at any time and without changing the existing code. Moreover, global function interfaces enable us to incorporate the C++ built-in types and handle them like user defined types. It is even possible to adapt arbitrary interfaces, i.e. of classes that are implemented in external libraries, to a common interface by using small global functions called <italic>'shims' </italic>(Chapter 20 in [<xref ref-type="bibr" rid="B24">24</xref>]). Algorithms that access objects only via global functions can therefore be applied to a great variety of types, including built-in types and external classes.</p>
      </sec>
      <sec>
        <title>Traits</title>
        <p>Generic algorithms usually have to know certain types that correspond to their arguments: An algorithm on strings may need to know which type of characters are stored in the string, or what kind of iterator can be used to browse it. SeqAn uses type traits [<xref ref-type="bibr" rid="B25">25</xref>] for that purpose. In C++, trait classes are implemented as class templates that map types or constants given by template arguments to other types but also other C++ enties like constants, functions, or objects at compile time. Most of the advantages we already stated for global functions also apply to traits, i.e. new traits and new specializations of already existing traits can be added without changing other parts of the library.</p>
      </sec>
      <sec>
        <title>Template Argument Subclassing</title>
        <p>SeqAn uses a special kind of hierarchical structure that we call 'template argument subclassing', which means that different specializations of a given class template are specified by template arguments. For example, String&lt;Compressed&gt; is a subclass of String in the sense that all functions and traits which are applicable to String can also be applied to String&lt;Compressed&gt;, while it is possible to overload some functions especially for String&lt;Compressed&gt;. The rules of C++ overload resolution guarantee that the compiler always applies the most specific variant out of all existing implementations when an algorithm or trait has been called. This approach resembles class derivation in standard object-oriented programming, but it is often faster, because it does not require a type conversion for a subclass calling a function that is already defined for the base class, and since the actual type of the object used in a function is therefore already known at compile time, it is not necessary to detect it at run time using virtual functions. Non-virtual functions have the advantage that C++ compilers can use function inlining to save their overhead completely. Template argument subclassing enables us both to specialize functions and to delegate tasks soundly to base classes while still maintaining static binding.</p>
      </sec>
      <sec>
        <title>Design Goals</title>
        <p>These design principles support our design goals in the following way:</p>
        <p>• <bold>Performance: </bold>The library produces code that is competitive with manually optimized programs. Template argument subclassing makes it possible to plug in optimized specializations for algorithms whenever needed. Our generic programming design also speeds up the code in avoiding unnecessary virtual function calls.</p>
        <p>• <bold>Generality: </bold>All parts of the library are as flexible as possible. Algorithms can be applied to various data types and new types can be added if necessary. For example, generic alignment algorithms in SeqAn work on strings for arbitrary alphabets. However, specialized implementations that make use of certain attributes of the alphabet can still be developed using template argument subclassing.</p>
        <p>• <bold>Integration: </bold>SeqAn components are designed to fulfill the requirements specified in the C++ standard. In addition, SeqAn easily interacts with other libraries because the global interface can be expanded. Hence, algorithms and classes of other libraries are at hand.</p>
        <p>• <bold>Extensibility: </bold>The open-closed principle ('Be open for extension but closed for modifications!') is satisfied in so far as it is possible to extend the library by simply adding new code. SeqAn has this feature because it relies on stand-alone global functions and traits that can be added at any time without changing the existing code.</p>
        <p>• <bold>Simplicity: </bold>While a pure object-oriented library may be more familiar to some users, SeqAn is still simple enough to be used even by developers with average skills in C++.</p>
      </sec>
    </sec>
    <sec>
      <title>Library Contents</title>
      <p>SeqAn is a software library that is supposed to cover all areas of sequence analysis. Fig. <xref ref-type="fig" rid="F2">2</xref> gives an overview of the contents of the library in the current state.</p>
      <fig position="float" id="F2">
        <label>Figure 2</label>
        <caption>
          <p>SeqAn Contents Overview.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-11-2"/>
      </fig>
      <sec>
        <title>Sequences</title>
        <p>The storage and manipulation of sequences is essential for all algorithms in the field of sequence analysis. In SeqAn, sequences are represented as strings of characters over various alphabets. Multiple string classes for different settings are available: Large sequences can be stored in secondary memory using external strings, bit-packed strings can be used to take advantage of small alphabets, or strings allocated on the stack can be used to guarantee fast access. String modifiers can be used to implement distinct views on a given sequence without copying it. A string segment, for instance, is a string modifier used to get access to an infix, suffix, or prefix of a given sequence.</p>
      </sec>
      <sec>
        <title>Alignments</title>
        <p>Alignments require the insertion of gaps into sequences. SeqAn does not actually insert these gaps directly into the sequence but treats them separately. The benefit is twofold: A single sequence can be used in multiple alignments simultaneously and the actual alphabet of the string must not include a special gap character. SeqAn offers both pairwise and multiple sequence alignment algorithms. Algorithms can be configured for different scoring schemes and different treatments of sequence ends (e.g, ends free-space alignments). In the pairwise case, local and global alignment algorithm are available. Besides the classical Needleman-Wunsch algorithm [<xref ref-type="bibr" rid="B19">19</xref>], more sophisticated algorithms are available, including an affine gap cost alignment [<xref ref-type="bibr" rid="B26">26</xref>] and Myer's bit vector algorithm [<xref ref-type="bibr" rid="B2">2</xref>]. Moreover, SeqAn offers efficient algorithms to chain alignment fragments [<xref ref-type="bibr" rid="B27">27</xref>,<xref ref-type="bibr" rid="B28">28</xref>]. We are also currently integrating code for motif finding in multiple sequences.</p>
      </sec>
      <sec>
        <title>Indices</title>
        <p>The <italic>enhanced suffix array (ESA) </italic>[<xref ref-type="bibr" rid="B29">29</xref>] is probably the most fundamental indexing data structure in bioinformatics with various applications, e.g., finding maximal repeats, super maximal repeats, or maximal unique matches in sequences. An enhanced suffix array is a normal suffix array extended with an additional <italic>lcp </italic>table that stores the length of the longest common prefix of adjacent suffixes in the suffix array. SeqAn offers an ESA that can be build up in primary or in secondary memory, depending on the sequence size. The user has two choices to access the ESA, either as a regular suffix array or as a suffix tree. The later view on an ESA is realized using the concept of iterators that simulate a tree traversal. A more space and time efficient data structure for top-down traversals through only parts of the suffix tree is the lazy suffix tree [<xref ref-type="bibr" rid="B30">30</xref>] which is also implemented in SeqAn. Besides the sophisticated ESA, simpler indices are available, including basic hash tables like gapped- and ungapped q-gram indices (for their use see [<xref ref-type="bibr" rid="B31">31</xref>-<xref ref-type="bibr" rid="B33">33</xref>]).</p>
      </sec>
      <sec>
        <title>Searching</title>
        <p>Flexible pattern matching algorithms are fundamental to sequence analysis. Exact and approximate string matching algorithms are provided. For the exact string matching task, SeqAn offers the algorithms Shift-And, Shift-Or, Horspool, Backward Oracle Matching, and Backward Nondeterministic Dawg Machine [<xref ref-type="bibr" rid="B34">34</xref>]. For searching multiple patterns, SeqAn currently supports the Multiple Shift-And, the Set Horspool, and the Aho-Corasick algorithm [<xref ref-type="bibr" rid="B34">34</xref>]. Myer's bit vector algorithm [<xref ref-type="bibr" rid="B2">2</xref>] can be used for approximate string matching. Note that SeqAn's index data structures can naturally be used to search for strings as well.</p>
      </sec>
      <sec>
        <title>Graphs</title>
        <p>Graphs are increasingly important to a number of bioinformatics problems. Prime examples are string matching algorithms (e.g., Aho-Corasick, Backward Oracle Matching [<xref ref-type="bibr" rid="B34">34</xref>]), phylogenetic algorithms (e.g., upgma, neighbor joining tree [<xref ref-type="bibr" rid="B35">35</xref>]), or alignment representations [<xref ref-type="bibr" rid="B36">36</xref>]. Hence, we decided to include our own graph type implementation, including directed graphs, undirected graphs, trees, automata, alignment graphs, tries, wordgraphs, and oracles. Graph algorithms currently comprise breath-first search, depth-first search, topological sort, strongly-connected components, minimum spanning trees (e.g., Prim's algorithm, Kruskal's algorithm), shortest path algorithms (e.g., Bellman-Ford, Dijkstra, Floyd-Warshall), transitive closure, and the Ford-Fulkerson maximum flow algorithm [<xref ref-type="bibr" rid="B37">37</xref>]. Trees are heavily used in clustering algorithms and as guide trees during a progressive multiple sequence alignment. Alignment graphs are used to implement a heuristic multiple sequence alignment algorithm, which is similar to T-Coffee [<xref ref-type="bibr" rid="B38">38</xref>] but makes use of segments and a sophisticated refinement algorithm [<xref ref-type="bibr" rid="B39">39</xref>] to enable large-scale sequence alignments.</p>
      </sec>
      <sec>
        <title>Biologicals</title>
        <p>Besides the fundamental alphabets for biological purposes, like DNA or amino acids, SeqAn offers different scoring schemes for evaluating the distance of two characters, e.g., PAM, and BLOSUM. SeqAn also supports several file formats that are common in the field of bioinformatics, e.g., FASTA, EMBL, and genbank. Is is possible the access (e.g. to search) sequence data stored in such file formats without loading the whole data into memory. The integration of external tools (e.g., BLAST) and the parsing of metainformation is ongoing work.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Results</title>
    <p>We anticipate two different user groups for SeqAn. The first group is the bioinformatics practitioner with some programming knowledge who wants to quickly prototype efficient tools for analyzing genomic or protein sequences <italic>using </italic>SeqAn. The other prototypic user is the algorithmicist who is proficient in programming <italic>in </italic>SeqAn and wants to test and compare an algorithmic component for a specific well-defined algorithmic problem.</p>
    <p>The next examples will demonstrate how things could be done in SeqAn. We would like to point out the very good performance of SeqAn as well as the fact that the necessary code is small, easy to understand, generic, and greatly profits from using an integrated algorithmic library.</p>
    <sec>
      <title>Example: String Matching</title>
      <p>We start with a small example of how SeqAn could be used as an experimental platform to test various implementations to solve the same algorithmic problem. In Fig. <xref ref-type="fig" rid="F3">3</xref> we show the results of a runtime comparison between three string matching algorithms implemented in SeqAn and the find method for strings from the standard template library. Different pattern lengths and alphabet sizes were used. It turned out that there is always string matching routines in SeqAn that is faster than standard library code. This demonstrates that the coding standard used in SeqAn is competitive to a widely used STL implementation. Note that none of the tested algorithms performs the best for all settings. A library like SeqAn makes it possible to switch between different algorithms easily, so users can apply the best algorithm depending on the requirements. Moreover, SeqAn can act as an experimental platform to compare new string matching methods with the set of well known algorithms present in SeqAn.</p>
      <fig position="float" id="F3">
        <label>Figure 3</label>
        <caption>
          <p><bold>Runtimes of String Matching Algorithms</bold>. We compared three exact string matching algorithms from SeqAn with the member function basic_string::find of the standard library, as it was implemented for Microsoft Visual C++. The left figure shows the runtimes (in <italic>ms</italic>) for searching a DNA sequence (human chromosome 21), the right figure for searching a proteine database. The search pattern was taken randomly from the sequence. The figures show the average time needed to find all occurrences of patterns of a given length.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-11-3"/>
      </fig>
    </sec>
    <sec>
      <title>Example: Global Alignments</title>
      <p>Now we switch to a more biologically motivated example: Computing a global alignment between two given DNA sequences with minimal edit distance. Alignment problems are very popular in the biological context. Even libraries with little sequence analysis content support one or more relevant functions that are mostly based on the dynamic programming approach by Needleman and Wunsch [<xref ref-type="bibr" rid="B19">19</xref>], which is certainly one of the most popular algorithms in bioinformatics. Gotoh's algorithm [<xref ref-type="bibr" rid="B26">26</xref>] extends it by affine gap cost models. Some libraries also support Hirschberg's algorithm [<xref ref-type="bibr" rid="B40">40</xref>], another well-known alignment method that takes only linear space.</p>
      <p>Table <xref ref-type="table" rid="T1">1</xref> lists time and space requirements for aligning the genomes of two human influenca viruses. The results show that SeqAn can compete with other libraries regardeless of scoring scheme and gap cost model. In the case of edit distance, SeqAn actually beats all competitors with a special algorithm that combines Hirschberg's algorithm with Myers' bitvector algorithm [<xref ref-type="bibr" rid="B2">2</xref>] to compute an optimal alignment one order of magnitude faster than all other programs we observed.</p>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p>Runtimes and internal space requirements for computing sequence alignments. The table shows average time and space requirements for aligning the genomes of two human influenca viruses, each of length about 15.6 kbp. Runtimes printed in bold face show for each library the time of the fastest algorithm for computing an alignment using edit distance.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td align="center" colspan="2">
                <bold>linear gap costs</bold>
              </td>
              <td align="center" colspan="2">
                <bold>affine gap costs</bold>
              </td>
            </tr>
            <tr>
              <td/>
              <td align="right">time (s)</td>
              <td align="right">space (MB)</td>
              <td align="right">time (s)</td>
              <td align="right">space (MB)</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">
                <bold>SeqAn</bold>
              </td>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left"> Needleman-Wunsch</td>
              <td align="right">3.3</td>
              <td align="right">236</td>
              <td align="right">6.3</td>
              <td align="right">236</td>
            </tr>
            <tr>
              <td align="left"> Hirschberg</td>
              <td/>
              <td/>
              <td align="right">14.7</td>
              <td align="right">4</td>
            </tr>
            <tr>
              <td align="left"> Myers-Hirschberg</td>
              <td align="right">
                <bold>0.2</bold>
              </td>
              <td align="right">3</td>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left">
                <bold>NCBI C++ toolkit</bold>
              </td>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left"> Needleman-Wunsch</td>
              <td/>
              <td/>
              <td align="right">
                <bold>4.0</bold>
              </td>
              <td align="right">245</td>
            </tr>
            <tr>
              <td align="left"> Hirschberg</td>
              <td/>
              <td/>
              <td align="right">6.6</td>
              <td align="right">14</td>
            </tr>
            <tr>
              <td align="left">
                <bold>Bio++</bold>
              </td>
              <td align="right">
                <bold>13.4</bold>
              </td>
              <td align="right">2100</td>
              <td align="right">28.0</td>
              <td align="right">≈6000</td>
            </tr>
            <tr>
              <td align="left">
                <bold>BTL</bold>
              </td>
              <td/>
              <td/>
              <td align="right">
                <bold>96162</bold>
              </td>
              <td align="right">933</td>
            </tr>
            <tr>
              <td align="left">
                <bold>BioJava</bold>
              </td>
              <td align="right">
                <bold>76</bold>
              </td>
              <td align="right">2000</td>
              <td align="right">93</td>
              <td align="right">≈6000</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>Example: MUMmer</title>
      <p>In this example, we want to convince the reader that programming <italic>using </italic>SeqAn is not difficult and that SeqAn is simple enough to meet the needs of the first user group while it is efficient and generic enough to allow expert users to use SeqAn as an experimental platform for testing algorithmic components.</p>
      <p>We choose as an example the well-known MUMmer [<xref ref-type="bibr" rid="B8">8</xref>] tool and show in the listing (see Additional File <xref ref-type="supplementary-material" rid="S1">1</xref>) an implementation of a (simplified) version of the tool which reads a number of sequences and computes all maximal unique matches (MUMs) of length at least 20. For the sake of exposition we only show code pieces that are illustrative for SeqAn.</p>
      <p>A MUM of a set of sequences is a subsequence that occurs exactly once in each sequence and that is not part of any longer such subsequence. To find MUMs MUMmer builds a suffix tree [<xref ref-type="bibr" rid="B41">41</xref>] of a reference sequence and streams one or more query sequences against it. The downside of designating one sequence as the reference is that matches are only unique in the reference sequence but not necessarily in the query sequence. To guarantee the uniqueness of a match in all sequences it is necessary to construct a generalized suffix tree. A generalized suffx tree is a suffix tree of the concatenated sequences seperated by unique characters [<xref ref-type="bibr" rid="B42">42</xref>]. It is the primary index data structure in SeqAn and based on an enhanced suffix array [<xref ref-type="bibr" rid="B43">43</xref>]. In the first part of the example (Additional File <xref ref-type="supplementary-material" rid="S1">1</xref>: Listing 1) we build a string index for a set of strings consisting of characters from the Dna5 alphabet, which is an extension of the Dna alphabet including the 'N' character. SeqAn supports a number of different alphabets of biological relevance (e.g., Dna, Amino Acid, or compressed amino acid alphabets). All these alphabets enable us to store sequences efficiently because of the reduced number of characters compared to normal text. The index is first resized to the appropriate number of sequences. Subsequently, the sequences are imported using the Fasta read function and simultaneously, these sequences are added to the index, which is our enhanced suffix array.</p>
      <p>SeqAn provides iterators that make it possible to traverse the enhanced suffix array like a suffix tree in a bottom-up fashion. This is illustrated in Additional File <xref ref-type="supplementary-material" rid="S1">1</xref>: Listing 2. The iterator it visits each node <italic>u </italic>in the generalized suffix tree. To find a MUM <italic>u</italic>, it suffices to test whether <italic>u </italic>occurs exactly 2 times (line 16), at most once in each sequence (line 18), and cannot be extended to the left (line 19) (see Chapt. 3.4, [<xref ref-type="bibr" rid="B43">43</xref>]). If the length of the representative string of <italic>u </italic>is also at least 20 (line 17) we report the position and length of the MUM <italic>u </italic>(lines 26–31). Assuming a computational biologist is not all too interested in these algorithmic details but in performance and a simple interface, SeqAn provides specialized iterators to get all MUMs (Additional File <xref ref-type="supplementary-material" rid="S1">1</xref>: Listing 3), maximal or supermaximal repeats, or MultiMEMs [<xref ref-type="bibr" rid="B43">43</xref>]). Since performance is a crucial issue in any kind of sequence analysis task, we compared our code example with the latest MUMmer release [<xref ref-type="bibr" rid="B8">8</xref>] and Multimat of the MGA distribution [<xref ref-type="bibr" rid="B9">9</xref>]. To the best of our knowledge these are the only tools to find MUMs. None of the libraries introduced in chapter support generalized suffix trees or even algorithms on suffix trees, like those to find MUMs. Our testset consisted of various bacteria strains and vertebrate chromosomes.</p>
      <p>Table <xref ref-type="table" rid="T2">2</xref> readily reveals that MUMmer is about twice as fast as SeqAn on the 2 sequence datasets and that it uses only half of the space. This is, however, not suprising because MUMmer's index represents only one sequence whereas the generalized suffix tree implemented in SeqAn builds an index over all sequences. But in contrast to SeqAn and MGA, MUMmer is not able to find real MUMs between more than 2 sequences. Similar to SeqAn, MGA also constructs a generalized suffix tree of all sequences and its memory consumption is approximately equal to SeqAn's. However, SeqAn outperforms MGA on all datasets and surprisingly, MGA even takes more than 1 hour on the E. coli strains.</p>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p>Runtimes and internal space requirements for finding MUMs. We compared MUMmer 3.19 [8], MGA [9], and SeqAn for different DNA sequences on a 3.2 GHz Intel Xeon computer with 3 GB of internal memory running Linux. Because MUMmer finds MUMs of not more than two sequences, its results on the Chlamydia and Escherichia coli strains are left empty. For the last dataset, we used SeqAn's external memory data strutures to limit the internal memory consumption.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">
                <bold>Species</bold>
              </td>
              <td/>
              <td align="center" colspan="2">
                <bold>MUMer</bold>
              </td>
              <td align="center" colspan="2">
                <bold>MGA</bold>
              </td>
              <td align="center" colspan="2">
                <bold>SeqAn</bold>
              </td>
            </tr>
            <tr>
              <td/>
              <td align="right">size (Mbp)</td>
              <td align="right">time (m:s)</td>
              <td align="right">space (MB)</td>
              <td align="right">time (m:s)</td>
              <td align="right">space (MB)</td>
              <td align="right">time (m:s)</td>
              <td align="right">space (MB)</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">C. trachomatis D/UW-3/CX</td>
              <td align="right">1.043</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left">C. muridarum Nigg</td>
              <td align="right">1.073</td>
              <td align="right">-</td>
              <td align="right">-</td>
              <td align="right">0:06</td>
              <td align="right">33.8</td>
              <td align="right">0:04</td>
              <td align="right">31.6</td>
            </tr>
            <tr>
              <td align="left">C. trachomatis A/HAR-13</td>
              <td align="right">1.044</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left">E. coli K12</td>
              <td align="right">4.640</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left">E. coli O157:H7 str. Sakai</td>
              <td align="right">5.498</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left">E. coli CFT073</td>
              <td align="right">5.231</td>
              <td align="right">-</td>
              <td align="right">-</td>
              <td align="right">105:40</td>
              <td align="right">353.5</td>
              <td align="right">0:58</td>
              <td align="right">304.6</td>
            </tr>
            <tr>
              <td align="left">E. coli UTI89</td>
              <td align="right">5.066</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left">E. coli 536</td>
              <td align="right">4.939</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left">E. coli APEC O1</td>
              <td align="right">5.082</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left">H. sapiens (chr. 21)</td>
              <td align="right">46.94</td>
              <td align="right">2:25</td>
              <td align="right">568</td>
              <td align="right">4:44</td>
              <td align="right">1188</td>
              <td align="right">4:06</td>
              <td align="right">1307</td>
            </tr>
            <tr>
              <td align="left">M. musculus (chr. 16)</td>
              <td align="right">98.25</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="left">H. sapiens (chr. 16)</td>
              <td align="right">98.25</td>
              <td align="right">2:55</td>
              <td align="right">1362</td>
              <td align="right">18:48</td>
              <td align="right">1500</td>
              <td align="right">5:38</td>
              <td align="right">1627</td>
            </tr>
            <tr>
              <td align="left">P. troglodytes (chr. 16)</td>
              <td align="right">88.83</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td align="center" colspan="2">
                <bold>external string</bold>
              </td>
            </tr>
            <tr>
              <td colspan="8">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">H. sapiens (chr. 1)</td>
              <td align="right">247.2</td>
              <td align="center" colspan="2">insufficient memory</td>
              <td align="center" colspan="2">insufficient memory</td>
              <td align="right">66:20</td>
              <td align="right">510</td>
            </tr>
            <tr>
              <td align="left">M. musculus (chr. 1)</td>
              <td align="right">197.1</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Index data structures of whole genomes easily reach 10–30 GB, so they must rely on external memory. SeqAn provides such data structures. They can be used by simply exchanging the standard string of SeqAn by an external memory string in order to construct the generalized suffix tree in external memory. We did this for the last row of Table <xref ref-type="table" rid="T1">1</xref> and simply replaced Dna5String by String&lt;Dna5, External&lt;&gt;&gt; in the code example. This reduces the main memory space requirements of the algorithm at the expense of speed. However, this makes it possible to construct generalized suffix trees for sequences of nearly arbitrary length. As can be seen in Table <xref ref-type="table" rid="T1">1</xref>, these external strings enable SeqAn to handle long sequences where MUMmer and MGA simply run out of memory.</p>
    </sec>
  </sec>
  <sec>
    <title>Conclusion</title>
    <p>We presented a new software library with an efficient and generic design that addresses a wide range of problems in sequence analysis. SeqAn is under active development and we hope that it will become one of the standard platforms for algorithmic engineering at the interface of stringology, algorithm design and computational biology. Besides the planned extensions mentioned in Section, we are working on integrating external libraries and plan to intensify our collaborations with other research groups.</p>
  </sec>
  <sec>
    <title>Availability and requirements</title>
    <p>SeqAn is freely distributed under the GNU Lesser General Public Licence (LGPL), both for academic and non-academic use. The library and its documentation can be downloaded from <ext-link ext-link-type="uri" xlink:href="http://www.seqan.de"/>. All parts of the library are tested on Windows with Microsoft Visual Studio 2003 and 2005 and on Linux with G++ compilers version 3.0 and above.</p>
    <sec>
      <title>Competing interests</title>
      <p>The author(s) declares that there are no competing interests.</p>
    </sec>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>AD worked out the overall design of the library and implemented a large part of the kernel functionality. DW took responsibility mainly for the index data structures and the pipelining in SeqAn. The work of TR includes everything in the library that has to do with graphs. Programming SeqAn was team work, so all three programmers (AD, DW, and TR) left tracks in almost every part of the library. KR supervised the project. All authors participated equally in composing this manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Listings</bold>. The listings show C++ code that uses SeqAn to implement a simplified version of the well-known MUMmer tool [<xref ref-type="bibr" rid="B8">8</xref>].</p>
      </caption>
      <media xlink:href="1471-2105-9-11-S1.PDF" mimetype="text" mime-subtype="plain">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <sec>
      <title>Acknowledgements</title>
      <p>We would like to acknowledge all students of the BSc and MSc program in bioinformatics at the FU Berlin who have contributed to SeqAn so far. Amongst others those are most notably Stephan Aiche, Anne-Katrin Emde, Ji-Hyun Lim, and Henrik Wöhrle.</p>
    </sec>
  </ack>
  <ref-list>
    <ref id="B1">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Venter</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The Sequence of the Human Genome</article-title>
        <source>Science</source>
        <year>2001</year>
        <volume>291</volume>
        <fpage>1145</fpage>
        <lpage>1434</lpage>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
        </person-group>
        <article-title>A fast bit-vector algorithm for approximate string matching based on dynamic programming</article-title>
        <source>Journal of the ACM</source>
        <year>1999</year>
        <volume>46</volume>
        <fpage>395</fpage>
        <lpage>415</lpage>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>Journal of Molecular Biology</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Manber</surname>
            <given-names>U</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Suffix arrays: a new method for on-line string searches</article-title>
        <source>SODA'90: Proceedings of the first annual ACM-SIAM symposium on Discrete algorithms</source>
        <year>1990</year>
        <publisher-name>Society for Industrial and Applied Mathematics</publisher-name>
        <fpage>319</fpage>
        <lpage>327</lpage>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Sutton</surname>
            <given-names>GG</given-names>
          </name>
          <name>
            <surname>Delcher</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Dew</surname>
            <given-names>IM</given-names>
          </name>
          <name>
            <surname>Fasulo</surname>
            <given-names>DP</given-names>
          </name>
          <name>
            <surname>Flanigan</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Kravitz</surname>
            <given-names>SA</given-names>
          </name>
          <name>
            <surname>Mobarry</surname>
            <given-names>CM</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>KHJ</given-names>
          </name>
          <name>
            <surname>Remington</surname>
            <given-names>KA</given-names>
          </name>
          <name>
            <surname>Anson</surname>
            <given-names>EL</given-names>
          </name>
          <name>
            <surname>Bolanos</surname>
            <given-names>RA</given-names>
          </name>
          <name>
            <surname>Chou</surname>
            <given-names>HH</given-names>
          </name>
          <name>
            <surname>Jordan</surname>
            <given-names>CM</given-names>
          </name>
          <name>
            <surname>Halpern</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Lonardi</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Beasley</surname>
            <given-names>EM</given-names>
          </name>
          <name>
            <surname>Brandon</surname>
            <given-names>RC</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Dunn</surname>
            <given-names>PJ</given-names>
          </name>
          <name>
            <surname>Lai</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Liang</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Nusskern</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>Zhan</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Zheng</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Rubin</surname>
            <given-names>GM</given-names>
          </name>
          <name>
            <surname>Adams</surname>
            <given-names>MD</given-names>
          </name>
          <name>
            <surname>Venter</surname>
            <given-names>JC</given-names>
          </name>
        </person-group>
        <article-title>A Whole-Genome Assembly of Drosophila</article-title>
        <source>Science</source>
        <year>2000</year>
        <volume>287</volume>
        <fpage>2196</fpage>
        <lpage>2204</lpage>
        <pub-id pub-id-type="pmid">10731133</pub-id>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mural</surname>
            <given-names>RJ</given-names>
          </name>
          <name>
            <surname>Adams</surname>
            <given-names>MD</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>GW</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A Comparison of Whole-Genome Shotgun-Derived Mouse Chromosome 16 and the Human Genome</article-title>
        <source>Science</source>
        <year>2002</year>
        <volume>296</volume>
        <fpage>1661</fpage>
        <lpage>1671</lpage>
        <pub-id pub-id-type="pmid">12040188</pub-id>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Do</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Cooper</surname>
            <given-names>GM</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>MF</given-names>
          </name>
          <name>
            <surname>Davydov</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Program</surname>
            <given-names>NCS</given-names>
          </name>
          <name>
            <surname>Green</surname>
            <given-names>ED</given-names>
          </name>
          <name>
            <surname>Sidow</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Batzoglou</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>LAGAN and Multi-LAGAN: Efficient Tools for Large-Scale Multiple Alignment of Genomic DNA</article-title>
        <source>Genome Research</source>
        <year>2003</year>
        <volume>13</volume>
        <fpage>721</fpage>
        <lpage>731</lpage>
        <pub-id pub-id-type="pmid">12654723</pub-id>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Delcher</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Smoot</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Shumway</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Antonescu</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Versatile and open software for comparing large genomes</article-title>
        <source>Genome Biology</source>
        <year>2004</year>
        <volume>5</volume>
        <fpage>R12</fpage>
        <pub-id pub-id-type="pmid">14759262</pub-id>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Höhl</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ohlebusch</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Efficient multiple genome alignment</article-title>
        <source>ISMB (Supplement of Bioinformatics)</source>
        <year>2002</year>
        <fpage>312</fpage>
        <lpage>320</lpage>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Darling</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Mau</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Blattner</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Perna</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Mauve: Multiple Alignment of Conserved Genomic Sequence with Rearrangements</article-title>
        <source>Genome Research</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>1394</fpage>
        <lpage>1403</lpage>
        <pub-id pub-id-type="pmid">15231754</pub-id>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Mehlhorn</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Näher</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <source>The LEDA Platform of Combinatorial and Geometric Computing</source>
        <year>1999</year>
        <publisher-name>Cambridge University Press</publisher-name>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Overmars</surname>
            <given-names>MH</given-names>
          </name>
        </person-group>
        <article-title>Designing the Computational Geometry Algorithms Library CGAL</article-title>
        <source>Proceedings Workshop on Applied Computational Geometry</source>
        <year>1996</year>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Fabri</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Giezeman</surname>
            <given-names>GJ</given-names>
          </name>
          <name>
            <surname>Kettner</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Schirra</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Schönherr</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>The CGAL Kernel: A Basis for Geometric Computation</article-title>
        <source>WACG: 1st Workshop on Applied Computational Geometry: Towards Geometric Engineering, WACG</source>
        <year>1996</year>
        <publisher-name>LNCS</publisher-name>
        <ext-link ext-link-type="uri" xlink:href="http://citeseer.ist.psu.edu/fabri96cgal.html"/>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dutheil</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Gaillard</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Bazin</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Glemin</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ranwez</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Galtier</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Belkhir</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Bio++: a set of C++ libraries for sequence analysis, phylogenetics, molecular evolution and population genetics</article-title>
        <source>BMC Bioinformatics</source>
        <year>2006</year>
        <volume>7</volume>
        <fpage>188</fpage>
        <pub-id pub-id-type="pmid">16594991</pub-id>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Butt</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Roger</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Blouin</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>libcov: A C++ bioinformatic library to manipulate protein structures, sequence alignments and phylogeny</article-title>
        <source>BMC Bioinformatics</source>
        <year>2005</year>
        <volume>6</volume>
        <fpage>138</fpage>
        <pub-id pub-id-type="pmid">15938750</pub-id>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pitt</surname>
            <given-names>WR</given-names>
          </name>
          <name>
            <surname>Williams</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Steven</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Sweeney</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Bleasby</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Moss</surname>
            <given-names>DS</given-names>
          </name>
        </person-group>
        <article-title>The Bioinformatics Template Library – generic components for biocomputing</article-title>
        <source>Bioinformatics</source>
        <year>2001</year>
        <volume>17</volume>
        <fpage>729</fpage>
        <lpage>737</lpage>
        <pub-id pub-id-type="pmid">11524374</pub-id>
      </citation>
    </ref>
    <ref id="B17">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Vakatov</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Siyan</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Ostell</surname>
            <given-names>J</given-names>
          </name>
          <collab>editors</collab>
        </person-group>
        <source>The NCBI C++ Toolkit [Internet]</source>
        <year>2003</year>
        <publisher-name>National Library of Medicine, National Center for Biotechnology Information, Bethesda (MD)</publisher-name>
        <ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/books/bv.fcgi?rid=toolkit"/>
      </citation>
    </ref>
    <ref id="B18">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Vahrson</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Hermann</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Kleffe</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wittig</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Object-oriented sequence analysis: SCL-a C++ class library</article-title>
        <source>Bioinformatics</source>
        <year>1996</year>
        <volume>12</volume>
        <fpage>119</fpage>
        <lpage>127</lpage>
      </citation>
    </ref>
    <ref id="B19">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Needleman</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Wunsch</surname>
            <given-names>CD</given-names>
          </name>
        </person-group>
        <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>
        <source>J Molecular Biol</source>
        <year>1970</year>
        <volume>48</volume>
        <fpage>443</fpage>
        <lpage>453</lpage>
      </citation>
    </ref>
    <ref id="B20">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Stajich</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Block</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Boulez</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Brenner</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Chervitz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Dagdigian</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Fuellen</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Gilbert</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Korf</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Lapp</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Lehvaslaiho</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Matsalla</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Mungall</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Osborne</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Pocock</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Schattner</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Senger</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Stein</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Stupka</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Wilkinson</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>The Bioperl toolkit: Perl modules for the life sciences</article-title>
        <year>2002</year>
      </citation>
    </ref>
    <ref id="B21">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pocock</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Down</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Hubbard</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>BioJava: Open Source Components for Bioinformatics</article-title>
        <source>ACM SIGBIO Newsletter</source>
        <year>2000</year>
        <volume>20</volume>
        <fpage>10</fpage>
        <lpage>12</lpage>
      </citation>
    </ref>
    <ref id="B22">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Austern</surname>
            <given-names>MH</given-names>
          </name>
        </person-group>
        <source>Generic Programming and the STL</source>
        <year>1998</year>
        <publisher-name>Addison Wesley</publisher-name>
      </citation>
    </ref>
    <ref id="B23">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Czarnecki</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Eisenecker</surname>
            <given-names>UW</given-names>
          </name>
        </person-group>
        <source>Generative Programming Methods, Tools, and Applications</source>
        <year>2000</year>
        <publisher-name>Addison Wesley</publisher-name>
      </citation>
    </ref>
    <ref id="B24">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Wilson</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <source>Imperfect C++ Practical Solutions for Real-Life Programming</source>
        <year>2004</year>
        <publisher-name>Addison Wesley</publisher-name>
      </citation>
    </ref>
    <ref id="B25">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Vandevoorde</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Josuttis</surname>
            <given-names>NM</given-names>
          </name>
        </person-group>
        <source>C++ Templates The Complete Guide</source>
        <year>2003</year>
        <publisher-name>Addison Wesley</publisher-name>
      </citation>
    </ref>
    <ref id="B26">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gotoh</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>An improved algorithm for matching biological sequences</article-title>
        <source>J Mol Biol</source>
        <year>1982</year>
        <volume>162</volume>
        <fpage>705</fpage>
        <lpage>708</lpage>
        <pub-id pub-id-type="pmid">7166760</pub-id>
      </citation>
    </ref>
    <ref id="B27">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Abouelhoda</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Ohlebusch</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Chaining methods revisited</article-title>
        <source>Proceedings of the 14th Annual Symposium on Combinatorial pattern matching (CPM) 2003</source>
        <year>2003</year>
        <fpage>1</fpage>
        <lpage>16</lpage>
      </citation>
    </ref>
    <ref id="B28">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Chaining Multiple-Alignment Fragments in Sub-Quadratic Time</article-title>
        <source>SODA: ACM-SIAM Symposium on Discrete Algorithms (A Conference on Theoretical and Experimental Analysis of Discrete Algorithms)</source>
        <year>1995</year>
        <ext-link ext-link-type="uri" xlink:href="http://citeseer.ist.psu.edu/miller95chaining.html"/>
      </citation>
    </ref>
    <ref id="B29">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Abouelhoda</surname>
            <given-names>MI</given-names>
          </name>
          <name>
            <surname>Ohlebusch</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Optimal Exact String Matching Based on Suffix Arrays</article-title>
        <source>Proceedings of the Ninth International Symposium on String Processing and Information Retrieval, Lecture Notes in Computer Science 2476</source>
        <year>2002</year>
        <publisher-name>Springer-Verlag</publisher-name>
        <fpage>31</fpage>
        <lpage>43</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://www.zbh.uni-hamburg.de/staff/kurtz/papers/AboOhlKur2002.pdf"/>
      </citation>
    </ref>
    <ref id="B30">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Giegerich</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Stoye</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Efficient Implementation of Lazy Suffix Trees</article-title>
        <source>Software: Practice and Experience</source>
        <year>2003</year>
        <volume>33</volume>
        <fpage>1035</fpage>
        <lpage>1049</lpage>
      </citation>
    </ref>
    <ref id="B31">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Burkhardt</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Crauser</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ferragina</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Lenhof</surname>
            <given-names>HP</given-names>
          </name>
          <name>
            <surname>Rivals</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Vingron</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>q-gram based database searching using suffix arrays</article-title>
        <source>Proceedings of the third Annual International Conference on Computational Molecular Biology (RECOMB-99)</source>
        <year>1999</year>
        <fpage>77</fpage>
        <lpage>83</lpage>
      </citation>
    </ref>
    <ref id="B32">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Burkhardt</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kärkkäinen</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Better Filtering with Gapped q-grams</article-title>
        <source>CPM'01: Proceedings of the 12th Annual Symposium on Combinatorial Pattern Matching</source>
        <year>2001</year>
        <publisher-name>London, UK: Springer-Verlag</publisher-name>
        <fpage>73</fpage>
        <lpage>85</lpage>
      </citation>
    </ref>
    <ref id="B33">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Ma</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Kisman</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Tromp</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>PatternHunter II: Highly sensitive and fast homology search</article-title>
        <source>Genome Informatics</source>
        <year>2003</year>
        <volume>14</volume>
        <fpage>164</fpage>
        <lpage>175</lpage>
        <pub-id pub-id-type="pmid">15706531</pub-id>
      </citation>
    </ref>
    <ref id="B34">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Raffinot</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <source>Flexible Pattern Matching in Strings</source>
        <year>2002</year>
        <publisher-name>CUP</publisher-name>
      </citation>
    </ref>
    <ref id="B35">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Saitou</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Nei</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The Neighbor-Joining method: a new method, for reconstructing phylogenetic trees</article-title>
        <source>Mol Biol Evol</source>
        <year>1987</year>
        <volume>4</volume>
        <fpage>406</fpage>
        <lpage>425</lpage>
        <pub-id pub-id-type="pmid">3447015</pub-id>
      </citation>
    </ref>
    <ref id="B36">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Kececioglu</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>The maximum weight trace problem in multiple sequence alignment</article-title>
        <source>Proc 4-th Symp Combinatorial Pattern Matching, no 684 in Lecture Notes in Computer Science</source>
        <year>1993</year>
        <publisher-name>Springer-Verlag</publisher-name>
        <fpage>106</fpage>
        <lpage>119</lpage>
      </citation>
    </ref>
    <ref id="B37">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Cormen</surname>
            <given-names>TH</given-names>
          </name>
          <name>
            <surname>Leiserson</surname>
            <given-names>CE</given-names>
          </name>
          <name>
            <surname>Rivest</surname>
            <given-names>RL</given-names>
          </name>
          <name>
            <surname>Stein</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <source>Introduction to Algorithms</source>
        <year>2001</year>
        <publisher-name>Cambridge, MA: MIT Press</publisher-name>
      </citation>
    </ref>
    <ref id="B38">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Notredame</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Higgins</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Heringa</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>T-Coffee: A Novel Method for Fast and Accurate Multiple Sequence Alignment</article-title>
        <source>Journal of Molecular Biology</source>
        <year>2000</year>
        <volume>302</volume>
        <fpage>205</fpage>
        <lpage>217</lpage>
        <pub-id pub-id-type="pmid">10964570</pub-id>
      </citation>
    </ref>
    <ref id="B39">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Halpern</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Huson</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Segment Match refinment and applications</article-title>
        <source>Proceedings of the 2nd Workshop on Algorithms Bioinformatics (WABI-02)</source>
        <year>2002</year>
        <fpage>126</fpage>
        <lpage>139</lpage>
      </citation>
    </ref>
    <ref id="B40">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Hirschberg</surname>
            <given-names>DS</given-names>
          </name>
        </person-group>
        <source>A linear space algorithm for computing maximal common subsequences</source>
        <year>1975</year>
        <volume>18</volume>
        <publisher-name>ACM Press</publisher-name>
        <fpage>341</fpage>
        <lpage>343</lpage>
      </citation>
    </ref>
    <ref id="B41">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Weiner</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Linear pattern matching algorithms</article-title>
        <source>Proceedings of the 14th IEEE Symposium on Switching and Automata Theory</source>
        <year>1973</year>
        <fpage>1</fpage>
        <lpage>11</lpage>
      </citation>
    </ref>
    <ref id="B42">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Bieganski</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Riedl</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Carlis</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Generalized Suffix Trees for Biological Sequence Data: Applications and Implementation</article-title>
        <source>Twentyseventh Annual Hawaii International Conference on System Sciences</source>
        <year>1994</year>
      </citation>
    </ref>
    <ref id="B43">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abouelhoda</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ohlebusch</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Replacing Suffix Trees with Enhanced Suffix Arrays</article-title>
        <source>Journal of Discrete Algorithms</source>
        <year>2004</year>
        <volume>2</volume>
        <fpage>53</fpage>
        <lpage>86</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://www.zbh.uni-hamburg.de/staff/kurtz/papers/AboKurOhl2004.pdf"/>
      </citation>
    </ref>
  </ref-list>
</back>
