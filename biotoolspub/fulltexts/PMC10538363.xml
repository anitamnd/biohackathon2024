<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.0 20120330//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genome Res</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genome Res</journal-id>
    <journal-id journal-id-type="hwp">genome</journal-id>
    <journal-id journal-id-type="publisher-id">GENOME</journal-id>
    <journal-title-group>
      <journal-title>Genome Research</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1088-9051</issn>
    <issn pub-type="epub">1549-5469</issn>
    <publisher>
      <publisher-name>Cold Spring Harbor Laboratory Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10538363</article-id>
    <article-id pub-id-type="pmid">37253540</article-id>
    <article-id pub-id-type="medline">9509184</article-id>
    <article-id pub-id-type="doi">10.1101/gr.277615.122</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methods</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Extremely fast construction and querying of compacted and colored de Bruijn graphs with GGCAT</article-title>
      <alt-title alt-title-type="left-running">Cracco and Tomescu</alt-title>
      <alt-title alt-title-type="right-running">Constructing compacted de Bruijn graphs with GGCAT</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-6973-995X</contrib-id>
        <name>
          <surname>Cracco</surname>
          <given-names>Andrea</given-names>
        </name>
        <xref rid="af1" ref-type="aff">1</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-5747-8350</contrib-id>
        <name>
          <surname>Tomescu</surname>
          <given-names>Alexandru I.</given-names>
        </name>
        <xref rid="af2" ref-type="aff">2</xref>
      </contrib>
    </contrib-group>
    <aff id="af1"><label>1</label>Department of Computer Science, University of Verona, 37134 Verona, Italy;</aff>
    <aff id="af2"><label>2</label>Department of Computer Science, University of Helsinki, Helsinki 00560, Finland</aff>
    <author-notes>
      <corresp>Corresponding authors: <email>alexandru.tomescu@helsinki.fi</email>, <email>andrea.cracco@univr.it</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <volume>33</volume>
    <issue>7</issue>
    <fpage>1198</fpage>
    <lpage>1207</lpage>
    <history>
      <date date-type="received">
        <day>6</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>16</day>
        <month>5</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>
        <ext-link xlink:href="http://genome.cshlp.org/site/misc/terms.xhtml" ext-link-type="uri">© 2023 Cracco and Tomescu; Published by Cold Spring Harbor Laboratory Press</ext-link>
      </copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This article, published in <italic>Genome Research</italic>, is available under a Creative Commons License (Attribution 4.0 International), as described at <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="1198.pdf"/>
    <abstract>
      <p>Compacted de Bruijn graphs are one of the most fundamental data structures in computational genomics. Colored compacted de Bruijn graphs are a variant built on a <italic>collection</italic> of sequences and associate to each <italic>k</italic>-mer the sequences in which it appears. We present GGCAT, a tool for constructing both types of graphs, based on a new approach merging the <italic>k</italic>-mer counting step with the unitig construction step, as well as on numerous practical optimizations. For compacted de Bruijn graph construction, GGCAT achieves speed-ups of 3× to 21× compared with the state-of-the-art tool Cuttlefish 2. When constructing the colored variant, GGCAT achieves speed-ups of 5× to 39× compared with the state-of-the-art tool BiFrost. Additionally, GGCAT is up to 480× faster than BiFrost for batch sequence queries on colored graphs.</p>
    </abstract>
    <funding-group>
      <award-group id="funding-1">
        <funding-source>
          <institution-wrap>
            <institution>European Research Council (ERC) </institution>
            <institution-id institution-id-type="doi">10.13039/501100000781</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>851093</award-id>
      </award-group>
      <award-group id="funding-2">
        <funding-source>
          <institution-wrap>
            <institution>Academy of Finland </institution>
            <institution-id institution-id-type="doi">10.13039/501100002341</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>322595</award-id>
        <award-id>352821</award-id>
        <award-id>346968</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <p>de Bruijn graphs are one of the most fundamental data structures in computational genomics, appearing in countless applications, for example, assembly and analysis of sequencing data (<xref rid="GR277615CRAC14" ref-type="bibr">Compeau et al. 2011</xref>) or RNA-seq data (<xref rid="GR277615CRAC39" ref-type="bibr">Robertson et al. 2010</xref>), read error correction (<xref rid="GR277615CRAC41" ref-type="bibr">Salmela and Rivals 2014</xref>; <xref rid="GR277615CRAC25" ref-type="bibr">Limasset et al. 2020</xref>), alignment (<xref rid="GR277615CRAC26" ref-type="bibr">Liu et al. 2016</xref>), compression (<xref rid="GR277615CRAC5" ref-type="bibr">Benoit et al. 2015</xref>), and rearrangement detection (<xref rid="GR277615CRAC10" ref-type="bibr">Cameron et al. 2017</xref>), just to name a few. To obtain a de Bruijn graph of order <italic>k</italic> for a multiset of strings (usually sequencing reads, or assembled genomes), for every <italic>k</italic>-mer in the strings, one adds an edge from the node corresponding to its prefix of length <italic>k</italic> − 1 to the node corresponding to its suffix of length <italic>k</italic> − 1. de Bruijn graphs usually also have associated an <italic>abundance</italic> threshold <italic>a</italic> so that edges (and thus nodes) are added only for <italic>k</italic>-mers appearing at least <italic>a</italic> times in the input strings.</p>
  <p>de Bruijn graphs are appealing for several reasons. First, by increasing the abundance threshold, one can have a very simple but effective method of filtering out sequencing errors (i.e., erroneous <italic>k</italic>-mers). Second, having a graph structure allows for a smaller representation of the data in the presence of repeated regions, because equal substrings are represented only once in the graph. Third, by focusing on maximal <italic>nonbranching</italic> paths, that is, maximal paths whose internal nodes have in-degree and out-degree equal to one (also called <italic>maximal unitigs</italic>), one can discover “variation-free” regions.</p>
  <p>Originally, maximal unitigs were introduced for the genome assembly problem; for example, assembly contigs are usually unitigs of a corrected assembly graph (<xref rid="GR277615CRAC16" ref-type="bibr">Drezen et al. 2014</xref>; <xref rid="GR277615CRAC40" ref-type="bibr">Ruan and Li 2020</xref>). However, by replacing each unitig with, for example, an edge labeled with the label of the unitig (label obtained by identifying the overlapping (<italic>k</italic> − 2)-mers), one gets an equivalent graph, but of much smaller size. Such a graph is usually called a <italic>compacted de Bruijn graph</italic>. Because the first and the last <italic>k</italic>-mer of every maximal unitig is a node of the compacted de Bruijn graph, it often suffices to compute only the strings labeling the maximal unitigs of a de Bruijn graph, not the actual graph structure. Moreover, reverse complements need special handling, which we describe in the Methods subsection “Preliminaries.” Many of the applications cited above actually use a compacted graph, owing to its equivalent representation power but significantly smaller size. In fact, if one just wants to represent the <italic>k</italic>-mers of a data set in plain text form, there exist more efficient equivalent representations (<xref rid="GR277615CRAC9" ref-type="bibr">Břinda et al. 2021</xref>; <xref rid="GR277615CRAC37" ref-type="bibr">Rahman and Medvedev 2021</xref>; <xref rid="GR277615CRAC22" ref-type="bibr">Khan et al. 2022</xref>; and, even optimal, <xref rid="GR277615CRAC42" ref-type="bibr">Schmidt and Alanko 2022</xref>; <xref rid="GR277615CRAC43" ref-type="bibr">Schmidt et al. 2023</xref>), but all of these use maximal unitigs as a starting point.</p>
  <p>A popular variant of a de Bruijn graph is the <italic>colored</italic> de Bruijn graph, originally introduced for de novo assembly and genotyping of variants (<xref rid="GR277615CRAC20" ref-type="bibr">Iqbal et al. 2012</xref>). Such a graph is built from a <italic>collection</italic> of data sets, for example, different sequencing data sets or different (full) genome sequences. For every <italic>k</italic>-mer, colored de Bruijn graphs also store the identifiers (<italic>colors</italic>) of the data sets in which the <italic>k</italic>-mer appears. One can think of a colored de Bruijn graph as a compressed representation of the <italic>k</italic>-mers in a <italic>collection</italic> of data sets, but it retains enough information (i.e., the color of every <italic>k</italic>-mer) in order to identify each data set in this combined graph. Later applications include pangenomics (<xref rid="GR277615CRAC44" ref-type="bibr">Zekic et al. 2018</xref>), RNA-seq quantification (<xref rid="GR277615CRAC8" ref-type="bibr">Bray et al. 2016</xref>), bacterial genome querying (<xref rid="GR277615CRAC27" ref-type="bibr">Luhmann et al. 2021</xref>), alignment and reference-free phylogenomics (<xref rid="GR277615CRAC44" ref-type="bibr">Zekic et al. 2018</xref>), and microbiome research (<xref rid="GR277615CRAC17" ref-type="bibr">Dufault-Thompson and Jiang 2022</xref>), just to name a few.</p>
  <p>Although computing the maximal unitigs of a de Bruijn graph can be performed with a simple linear-time algorithm, the practical hardness of the problem stems from the fact that the initial de Bruijn graph does not fit the main memory in applications. Practical tools computing compacted de Bruijn graphs have to cleverly use the disk to store intermediary data, partition the data in order to use many CPU cores efficiently, and minimize CPU, RAM, and I/O bottlenecks. One of the first major tools for computing maximal unitigs was BCALM2 (<xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. 2016</xref>). BCALM2 first does a <italic>k</italic>-mer counting step inspired by KMC2 (<xref rid="GR277615CRAC15" ref-type="bibr">Deorowicz et al. 2015</xref>) and a filtering pass based on the multiplicity of the <italic>k</italic>-mers. Then it finds <italic>k</italic>-mers that should be joined together by bucketing them on their left/right minimizers (corresponding to the minimizers of the leftmost and rightmost (<italic>k</italic> − 1)-mers) (<xref rid="GR277615CRAC38" ref-type="bibr">Roberts et al. 2004</xref>). Each bucket is processed independently and in parallel to find all the possible extensions. Finally, BCALM2 glues all the unitigs that were produced in different buckets together using a union-find data structure.</p>
  <p>The state-of-the-art tool for maximal unitig computation is Cuttlefish 2 (<xref rid="GR277615CRAC22" ref-type="bibr">Khan et al. 2022</xref>). It starts with an initial <italic>k</italic>-mer counting step using KMC3 (<xref rid="GR277615CRAC23" ref-type="bibr">Kokot et al. 2017</xref>). It uses a perfect hash computation on the <italic>k</italic>-mers using BBHash (<xref rid="GR277615CRAC24" ref-type="bibr">Limasset et al. 2017</xref>). The key insight relies on a novel automaton-based approach to compute the branching state of every (<italic>k</italic> − 1)-mer, using only the minimum amount of information, that is, zero, one, or more than one left/right neighbors. Then, it builds the graph by looking at the automaton of every (<italic>k</italic> − 1)-mer, extending the unitig if the current (<italic>k</italic> − 1)-mer does not branch forward and the following (<italic>k</italic> − 1)-mer does not branch backward. Cuttlefish 2 tends to significantly write to disk to further resplit the intermediate buckets and keep the maximum memory usage low. Like BCALM2, it also does not compress the buckets on disk (except for prefix collapsing), and thus, very repetitive data sets still require large disk I/O. Moreover, for higher <italic>k</italic> values, KMC3 tends to use more time and memory, as it has to store the exact <italic>k</italic>-mers all the time, which, in consequence, also affects the behavior of Cuttlefish 2.</p>
  <p>The state-of-the-art tool for maximal unitig computation with associated color information is BiFrost (<xref rid="GR277615CRAC19" ref-type="bibr">Holley and Melsted 2020</xref>). It uses an in-memory only approach, with various blocked Bloom filters (<xref rid="GR277615CRAC7" ref-type="bibr">Bloom 1970</xref>; <xref rid="GR277615CRAC36" ref-type="bibr">Putze et al. 2010</xref>) partially indexed by minimizers that approximate the <italic>k</italic>-mers present in the final graph, and does several passes on the original input to remove the false edges wrongly created owing to the use of Bloom filters. Then it internally stores the <italic>k</italic>-mers grouped by minimizers, allowing for relatively fast deletions and insertions of new <italic>k</italic>-mers. However, although blocked Bloom filters are very memory efficient, they are not very cache efficient, even with the infra-block sse2 optimizations performed in BiFrost. Also, the memory representation of the <italic>k</italic>-mers gives a trade-off between the ease of doing small updates to the graph and the speed of inserting batches of <italic>k</italic>-mers; thus, the build time of the graph is still considerably high. To (optionally) build a colored graph, it uses various types of compressed bitmaps (roaring or simple bitsets) (<xref rid="GR277615CRAC11" ref-type="bibr">Chambi et al. 2016</xref>) to store the set of colors of each <italic>k</italic>-mer. Although this allows fast insertions and querying, it stores redundant color sets information because <italic>k</italic>-mers that share the same set of colors are still encoded as two separate sets. We refer the reader to Section 7.5 of the survey (<xref rid="GR277615CRAC13" ref-type="bibr">Chikhi et al. 2022</xref>) for other data structures for representing colored de Bruijn graphs.</p>
  <p>In this paper, we present GGCAT, a software tool for efficient construction of compacted, and optionally colored, de Bruijn graphs, both in terms of running time and of memory usage; GGCAT also supports batched <italic>k</italic>-mer queries against a (colored) de Bruijn graph. In all these tasks, GGCAT is faster by at least an order of magnitude than the state-of-the-art tools.</p>
  <sec sec-type="results" id="s1">
    <title>Results</title>
    <sec id="s1a">
      <title>GGCAT overview</title>
      <p>We propose a new tool for constructing compacted, and optionally colored, de Bruijn graphs, GGCAT. As opposed to BCALM2 and Cuttlefish 2, the first idea of GGCAT is to merge the <italic>k</italic>-mer counting step with unitig construction by adding a little more “context” information, which allows us to compute valid global unitigs inside each bucket that the input is split into. This avoids the storage of every single <italic>k</italic>-mer, because only unitigs built inside the buckets are written to disk. Moreover, as opposed to other tools, these unitigs are lz4-compressed before writing to disk, which allows for a substantial reduction in disk usage for highly repetitive data sets. Second, we avoid a union-find data structure (used by BCALM2) with a new joining step across buckets that guarantees exact results with very low <italic>expected</italic> running time. Third, we devise a parallelization pipeline that divides the algorithm into smaller execution units (e.g., reading from disk, <italic>k</italic>-mer counting, <italic>k</italic>-mer extension), thus preventing core stalling owing to waiting for data and thus lowering the dependence on the speed of the RAM.</p>
      <p>On the theoretical side, we give a string-based definition of maximal unitig in the presence of reverse complements (<italic>canonical maximal unitig</italic>; <xref rid="st1" ref-type="statement">Definition 1</xref>) that (1) allows us to avoid introducing a heavy formalism based on, for example, bidirected de Bruijn graphs and (2) closely mimics our algorithm, thus leading to a simple proof of correctness. Moreover, because our unitigs are in an edge-centric graph, in the <xref rid="SD2" ref-type="supplementary-material">Supplemental Methods</xref> (see also <xref rid="SD2" ref-type="supplementary-material">Supplemental Figs. S1, S2</xref>), we prove that they are equivalent to node-centric unitigs in a node-centric graph, as used by, for example, BCALM2 (which we also confirm experimentally) (<xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. 2016</xref>), a result that we did not find in the literature and may be of independent interest.</p>
      <p>For colored graphs, we extend our algorithm above with an approach inspired by BiFrost but with several optimizations that allow comparable color map sizes with substantially improved build times. The main difference from BiFrost is that, instead of using an individual (compressed) color bitmap for each possible <italic>k</italic>-mer, GGCAT maps each color set to a <italic>color set index</italic>, an approach similar to, for example, <xref rid="GR277615CRAC3" ref-type="bibr">Almodaresi et al. (2017)</xref>, <xref rid="GR277615CRAC34" ref-type="bibr">Pandey et al. (2018)</xref>, and <xref rid="GR277615CRAC28" ref-type="bibr">Mäklin et al. (2021)</xref>. Moreover, to store each color set, we compute the difference between consecutive colors and compress them using a run-length encoding. Finally, when storing to disk, the color set indices of the consecutive <italic>k</italic>-mers of each unitig are also run-length encoded. This strategy proves efficient because unitigs are “variation-free” and thus usually have few color set indices associated to their <italic>k</italic>-mers. Because Cuttlefish 2 is significantly faster than BiFrost (on noncolored graphs), these ideas, combined with our improvements over Cuttlefish 2, lead to a major speed up over BiFrost for colored graphs.</p>
      <p>Similar to BiFrost (<xref rid="GR277615CRAC19" ref-type="bibr">Holley and Melsted 2020</xref>), GGCAT also supports querying the produced colored graph against batch input sequence queries. More precisely, for every query sequence in the uncolored case, we need to return the numbers (equivalently, percentage) of <italic>k</italic>-mers of the sequence that also appear in the entire target graph. In the colored case, for every color <italic>c</italic>, we need to return the number of <italic>k</italic>-mers of the query sequence matching <italic>k</italic>-mers of the graph that are colored with <italic>c</italic>. In practice, we need to query many input sequences at the same time (e.g., a FASTA file). GGCAT solves both types of batch queries by an approach very similar to the graph construction steps.</p>
      <p>For <italic>k</italic> ≤ 64, GGCAT represents <italic>k</italic>-mers exactly. However, in some applications, larger values of <italic>k</italic> are needed. For example, for longer Illumina reads, the latest version of the SPAdes assembler (<xref rid="GR277615CRAC35" ref-type="bibr">Prjibelski et al. 2020</xref>) recommends also <italic>k</italic> ∈ {77, 99, 127}. For long HiFi reads, the LJA assembler (<xref rid="GR277615CRAC4" ref-type="bibr">Bankevich et al. 2022</xref>) uses values of <italic>k</italic> up to 5001. For comparing microbial genomes, the synteny block finder Sibelia (<xref rid="GR277615CRAC31" ref-type="bibr">Minkin et al. 2013</xref>) uses <italic>k</italic> up to 5000. To support values larger than 64, GGCAT uses a nonbijective 128-bit Rabin–Karp hash function to represent each <italic>k</italic>-mer (where each of the four bases is represented by a different prime number) to avoid storing it in full length. In extremely rare cases, it can lead to some collisions in hash values that can cause unwanted joining of some unitigs or extra splittings of a maximal unitig. GGCAT can detect (but not correct) most of the collisions, warning the user if some errors can be expected in the graph. In all the tested data sets with <italic>k</italic> &gt; 64, we found no occurrence of a hash collision.</p>
      <p>GGCAT is written in Rust, and it is usable either as a stand-alone command line tool or with an API that supports both building and querying. The API is callable and supported in both Rust and C++ to allow easy integration with other tools. For example, the GGCAT C++ API for colored graph construction has already been successfully integrated by the Themisto pseudoalignment tool v3 (<xref rid="GR277615CRAC2" ref-type="bibr">Alanko et al. 2023</xref>). When used as part of a pipeline to characterize pathogen competition and colonization dynamics in a longitudinal cohort of neonatal gut microbiomes (<xref rid="GR277615CRAC29" ref-type="bibr">Mäklin et al. 2022</xref>), Themisto index construction using GGCAT is seven times faster than in v2.1 of Themisto (<xref rid="GR277615CRAC28" ref-type="bibr">Mäklin et al. 2021</xref>; T. Mäklin, pers. comm.).</p>
      <p>Finally, GGCAT also integrates the matchtig (<xref rid="GR277615CRAC43" ref-type="bibr">Schmidt et al. 2023</xref>) and eulertig (<xref rid="GR277615CRAC42" ref-type="bibr">Schmidt and Alanko 2022</xref>) Rust libraries, thus (optionally) computing also minimum plain-text representations of the set of <italic>k</italic>-mers of the input FASTA files.</p>
    </sec>
    <sec id="s1b">
      <title>Tested tools, data sets, and hardware</title>
      <p>To compute compacted de Bruijn graphs, we chose to compare only against Cuttlefish 2, because the article introducing it (<xref rid="GR277615CRAC22" ref-type="bibr">Khan et al. 2022</xref>) showed that it significantly outperforms popular tools such as BCALM2 (<xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. 2016</xref>) and BiFrost (in its noncolored variant) (<xref rid="GR277615CRAC19" ref-type="bibr">Holley and Melsted 2020</xref>) or other tools such as deGSM (<xref rid="GR277615CRAC18" ref-type="bibr">Guo et al. 2021</xref>). To compute colored de Bruijn graphs, we chose to compare only against BiFrost, because the article introducing it (<xref rid="GR277615CRAC19" ref-type="bibr">Holley and Melsted 2020</xref>) showed that it significantly outperforms popular tools such as VARI-merge (<xref rid="GR277615CRAC33" ref-type="bibr">Muggli et al. 2019</xref>). We decided to not compare against Cuttlefish (<xref rid="GR277615CRAC21" ref-type="bibr">Khan and Patro 2021</xref>) for colored graphs because it adopts a different convention for colors (each unitig can have only one subset of colors) and does not support querying the resulting graph. We run all tools in their default settings (for the commands used, see <xref rid="SD2" ref-type="supplementary-material">Supplemental Methods</xref>).</p>
      <p>For the uncolored case, we use an Illumina whole-genome sequencing Human read data set, a Human gut microbiome read data set, 309,000 (309 K) <italic>Salmonella</italic> genome sequences, and 649,000 (649 K) Bacterial genomes. For the colored case, we use 100 Human genome sequences, 100,000 (100 K) <italic>Salmonella</italic> sequences from the full 309 K <italic>Salmonella</italic> data set (to save computational resources), and all Bacterial genomes. See the section “Software availability” for accession details and <xref rid="GR277615CRATB1" ref-type="table">Table 1</xref> for structural characteristics of these data sets. For the read data sets, we use an abundance threshold of two, and for the genome reference data sets, we use an abundance threshold of one. For a sanity check, we checked that for GGCAT the maximal canonical unitigs are exactly equivalent to the ones produced by BCALM2, for the uncolored graphs produced from 1000 <italic>Salmonella</italic> genomes, and from the Human read data set.</p>
      <table-wrap position="float" id="GR277615CRATB1">
        <label>Table 1.</label>
        <caption>
          <p>Data set statistics with various values of <italic>k</italic></p>
        </caption>
        <graphic xlink:href="1198tb01" position="float"/>
      </table-wrap>
      <p>We ran the experiments on three servers of increasing power: a <italic>small</italic> server with an AMD Ryzen 5 3600 six-core CPU, 64 GB RAM, and a RAID 0 with two 7200 RPM HDDs; a <italic>medium</italic> server with an AMD Ryzen Threadripper PRO 3975WX 32-core CPU, 512 GB RAM, and a RAID 5 7200 RPM HDD; and a <italic>large</italic> server with two AMD EPYC 7H12 64-core CPUs, 2 TB RAM, and a SATA SSD.</p>
    </sec>
    <sec id="s1c">
      <title>Construction results</title>
      <p>In the uncolored case, for the Human read data set, we run two realistic values of <italic>k</italic>, 27 and 63. On the other three data sets used in the uncolored case, we tested the behavior for larger <italic>k</italic> values, where the graphs still remain complex: for gut microbiome reads, <italic>k</italic> = 119, and for the 309 K <italic>Salmonella</italic> genomes and 649 K Bacterial genomes, <italic>k</italic> ∈ {119, 255}. To save computational resources, we did not run Cuttlefish 2 for the latter data set for larger <italic>k</italic> values because the tool does not scale. We show the results in <xref rid="GR277615CRATB2" ref-type="table">Table 2</xref>.</p>
      <table-wrap position="float" id="GR277615CRATB2">
        <label>Table 2.</label>
        <caption>
          <p>Uncolored construction, wall clock time, memory usage (in parentheses) and maximum disk usage including the size of the output files (in square brackets)</p>
        </caption>
        <graphic xlink:href="1198tb02" position="float"/>
      </table-wrap>
      <p>For Human reads and <italic>k</italic> = 27, GGCAT has a similar performance as Cuttlefish 2. However, for larger <italic>k</italic> values and on the other three larger data sets, GGCAT outperforms Cuttlefish 2 in terms of speed by up to 4.3× for <italic>k</italic> ≤ 63. The main speed improvements come from our new approach that merges the <italic>k</italic>-mer counting and unitig building steps into one unified step, which proves most useful for larger <italic>k</italic> values. For larger <italic>k</italic> values (119 and 255), GGCAT is faster than Cuttlefish 2 by up to 20.8×. (Notice also that, as opposed to GGCAT, Cuttlefish 2 does not support <italic>k</italic> values larger than 255.) Despite this, in all cases, GGCAT has an overall memory usage in the same order of magnitude as Cuttlefish 2 or one even substantially lower in the complex Bacterial genomes data set.</p>
      <p>We also tested the scalability of GGCAT by computing the uncolored graph of an increasing number of <italic>Salmonella</italic> genomes (see <xref rid="SD2" ref-type="supplementary-material">Supplemental Fig. S3</xref>), the results showing a linear relation between the number of genomes and the running time.</p>
      <p>The colored construction results are in <xref rid="GR277615CRATB3" ref-type="table">Table 3</xref>. Compared with BiFrost, in the first data set GGCAT is 5.1× faster for <italic>k</italic> = 27 and 4.6× faster for <italic>k</italic> = 63. For the <italic>Salmonella</italic> genomes, for <italic>k</italic> = 27, GGCAT is 33.3× faster than BiFrost, and for <italic>k</italic> = 63, GGCAT is 39.3× faster than BiFrost. For <italic>k</italic> = 27, BiFrost crashed, whereas for <italic>k</italic> = 63, we stopped its run after 10 d to save computational resources. Instead, GGCAT completed both cases in under 14 h. The memory used by GGCAT in the colored construction tests is from 3.7× to 12× less than BiFrost, but this is not directly comparable because GGCAT uses disk intermediate storage and BiFrost uses a fully in-memory algorithm. Moreover, in <xref rid="SD2" ref-type="supplementary-material">Supplemental Table S1</xref>, we measure the size of the color index constructed by GGCAT and BiFrost (i.e., the set of colors of each <italic>k</italic>-mer). In the tested data sets, GGCAT's index is from 20 to two times smaller than that of BiFrost.</p>
      <table-wrap position="float" id="GR277615CRATB3">
        <label>Table 3.</label>
        <caption>
          <p>Colored construction, wall clock time, memory usage (in parentheses), and the total maximum disk space including the size of the output files (in square brackets), using 16 threads</p>
        </caption>
        <graphic xlink:href="1198tb03" position="float"/>
      </table-wrap>
      <p>Depending on the characteristics of the data set, the available disk space for temporary files should be from 2× to 7× the size of the input, whereas the main memory for uncolored construction should be at least 16 GB for medium-sized genome collections and 32 GB for large ones (GGCAT usually consumes significantly less memory than these amounts but can consume more if inputs with particular characteristics are passed to it). For uncolored construction, an empirical way to have a rough estimation of the size of the needed main memory is by dividing the input size by 30.</p>
    </sec>
    <sec id="s1d">
      <title>Colored querying results</title>
      <p>To test querying, we used the colored graphs of 100 Human genomes for <italic>k</italic> ∈ {27, 63} produced in the previous test, and queried them (cold runs) using 4 million 250-bp sequencing reads from the first data set of Human reads (first 4 million sequences from the <monospace>D3_S1_L001_R1_008.fastq.gz</monospace> file of the Human genome data set). Results (in <xref rid="GR277615CRATB4" ref-type="table">Table 4</xref>) show that GGCAT outperformed BiFrost by 83.6× for <italic>k</italic> = 63, whereas for <italic>k</italic> = 27, GGCAT was more than 480× faster than BiFrost. This significant improvement is because we implement querying as a natural extension of the unitig construction step, thus benefiting from all its optimizations.</p>
      <table-wrap position="float" id="GR277615CRATB4">
        <label>Table 4.</label>
        <caption>
          <p>Querying in the colored graph of 100 Human genomes, wall clock time, and memory usage, using 16 threads on the <italic>large</italic> server</p>
        </caption>
        <graphic xlink:href="1198tb04" position="float"/>
      </table-wrap>
    </sec>
  </sec>
  <sec sec-type="discussion" id="s2">
    <title>Discussion</title>
    <p>Computing a compacted de Bruijn graph (and optionally colored) is one of the most fundamental problems in computational genomics, with a long history of computational tools developed for this problem. GGCAT pushes the boundary not only in terms of a highly efficient implementation based on both novel algorithmic aspects (e.g., combining <italic>k</italic>-mer counting with unitig construction, and a new strategy of joining partial unitig across buckets) but also in terms of an efficient parallelization pipeline minimizing idle CPU cores and disk I/O bottlenecks, or further optimizations such as lz4-compression of data written to disk. GGCAT reduces sequence queries to an approach similar to graph construction, thus benefiting from its highly optimized architecture.</p>
    <p>Overall, this leads to a several times improvement over Cuttlefish 2 (and even bigger for larger <italic>k</italic> values) and a two orders of magnitude improvement over BiFrost for colored construction and querying. GGCAT can thus have a significant impact in all downstream analyses that require computing a compacted de Bruijn graph.</p>
    <p>One algorithmic limitation of GGCAT is that it is not optimized for very small values of <italic>k</italic> (i.e., <italic>k</italic> &lt; 15). Moreover, like most disk-based de Bruijn construction tools, GGCAT's performance significantly depends on the disk and RAM speed. Thus, an NVME disk and a fast RAM are heavily preferred. GGCAT scales well in terms of number of threads, so for practical purposes, we recommend a CPU with at least eight cores/16 threads. Moreover, our experiments show that the suggestions above are valid for all the data sets we tested, that is, reads or references of small or large genomes, for both colored and uncolored construction. As future work, it would also be useful to extend GGCAT to support online updates, meaning updating the compacted colored de Bruijn graph with multiple small sets of reads or genomes while being able to query the graph between the updates.</p>
  </sec>
  <sec sec-type="methods" id="s3">
    <title>Methods</title>
    <sec id="s3a">
      <title>Preliminaries</title>
      <p>In this paper, all strings are over the same alphabet Σ = {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>}. We denote concatenation of two strings <italic>x</italic> and <italic>y</italic> as <italic>x</italic> · <italic>y</italic>. If <italic>x</italic> is a substring of <italic>y</italic>, we write <italic>x</italic> ∈ <italic>y</italic>. We denote the length of a string <italic>x</italic> as |<italic>x</italic>|. Given a string <italic>x</italic> of length at least <italic>k</italic>, we denote by pre<sub><italic>k</italic></sub>(<italic>x</italic>) the prefix of <italic>x</italic> of length <italic>k</italic>; by suf<sub><italic>k</italic></sub>(<italic>x</italic>), the suffix of <italic>x</italic> of length <italic>k</italic>. For two strings <italic>x</italic> and <italic>y</italic> such that suf<sub><italic>k</italic></sub>(<italic>x</italic>) = pre<sub><italic>k</italic></sub>(<italic>y</italic>), we denote by <inline-formula id="il1"><mml:math id="IL1" display="inline" overflow="scroll"><mml:mi>x</mml:mi><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mi>y</mml:mi></mml:math></inline-formula> the string <italic>x</italic> · suf<sub>|<italic>y</italic>|−<italic>k</italic></sub>(<italic>y</italic>) (the <italic>merge</italic> of <italic>x</italic> and <italic>y</italic>). Given a set or multiset <italic>R</italic> of strings, we denote ends<sub><italic>k</italic></sub>(<italic>R</italic>) = {pre<sub><italic>k</italic></sub>(<italic>x</italic>), suf<sub><italic>k</italic></sub>(<italic>x</italic>):<italic>x</italic> ∈ <italic>R</italic>}.</p>
      <p>A <italic>k-mer</italic> is a string of a given length <italic>k</italic> over the alphabet Σ. Given a <italic>k</italic>-mer <italic>q</italic>, we say that <italic>q</italic> is a <italic>k</italic>-mer of a string <italic>x</italic> if <italic>q</italic> ∈ <italic>x</italic> (in this case, we also say that <italic>q appears</italic>, or <italic>occurs</italic>, in <italic>x</italic>). Given a set or a multiset <italic>R</italic> of strings, we say that <italic>q appears</italic> in <italic>R</italic>, and write <italic>q</italic> ∈ <italic>R</italic> if <italic>q</italic> appears in some string in <italic>R</italic>. The <italic>edge-centric</italic> de Bruijn graph or order <italic>k</italic> of a multiset <italic>R</italic> of strings is defined as the directed graph having as nodes the (<italic>k</italic> − 1)-mers appearing in <italic>R</italic>, where we add an edge from a node <italic>x</italic> to a node <italic>y</italic> if suf<sub><italic>k</italic>−2</sub>(<italic>x</italic>) = pre<sub><italic>k</italic>−2</sub>(<italic>y</italic>) and <inline-formula id="il2"><mml:math id="IL2" display="inline" overflow="scroll"><mml:mi>x</mml:mi><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:math></inline-formula>. That is, the set of edges is exactly the set of all <italic>k</italic>-mers of <italic>R</italic>. In such an edge-centric graph, the <italic>spelling</italic> of a path <italic>P</italic> = (<italic>x</italic><sub>1</sub>, …, <italic>x</italic><sub><italic>t</italic></sub>) is the string <inline-formula id="il3"><mml:math id="IL3" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>⋯</mml:mo><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <p>A <italic>unitig</italic> is defined as a path of the de Bruijn graph of <italic>R</italic> containing at least one edge, such that all the internal nodes of the path (i.e., different from the first and the last) have an in-degree and an out-degree equal to one. In this paper, paths do not repeat nodes, except for possibly the first and the last, in which case we say that the path is a <italic>cycle</italic>. If two cycles <italic>C</italic><sub>1</sub> and <italic>C</italic><sub>2</sub> are such that <italic>C</italic><sub>2</sub> can be obtained from <italic>C</italic><sub>1</sub> by a cyclic shift, then we say that <italic>C</italic><sub>1</sub> and <italic>C</italic><sub>2</sub> are <italic>equivalent</italic>. A <italic>maximal</italic> unitig is one that cannot be extended by one node without losing the property that it is a unitig. We are interested in outputting the <italic>set</italic> of all maximal unitigs of a de Bruijn graph, where for unitigs that are cycles we need to output only one cyclic shift (i.e., in the output, there can be no equivalent cycles). Our definition of unitigs is for edge-centric graphs. For <italic>node-centric de Bruijn graphs</italic>, unitigs need to be defined by imposing an additional condition (see, e.g., <xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. 2016</xref>; <xref rid="GR277615CRAC22" ref-type="bibr">Khan et al. 2022</xref>). To the best of our knowledge, we are not aware of a formal proof of equivalence between these types of unitigs in the two types of graphs. As such, we give this proof in the <xref rid="SD2" ref-type="supplementary-material">Supplemental Methods</xref>.</p>
      <p>For ease of notation, by unitig we will also refer to its <italic>spelling</italic>. Clearly, the first and last node of a unitig different from a cycle must satisfy the condition that <italic>either</italic> its in-degree is different from one or its out-degree is different from one. Note that under this definition, the maximal unitigs form a partition of the edges, that is, of the <italic>k</italic>-mers of <italic>R</italic>.</p>
      <p>For the rest of this paper, we consider an alternative definition of maximal unitigs that does not explicitly use a de Bruijn graph. This has several advantages: It connects to the recent literature on <italic>spectrum preserving string sets</italic> (unitigs being one such type of set) (<xref rid="GR277615CRAC9" ref-type="bibr">Břinda et al. 2021</xref>; <xref rid="GR277615CRAC37" ref-type="bibr">Rahman and Medvedev 2021</xref>; <xref rid="GR277615CRAC43" ref-type="bibr">Schmidt et al. 2023</xref>); it naturally extends to reverse complements without introducing heavy definitions related to bidirected de Bruijn graphs; and, ultimately it matches our algorithm, which proceeds bottom-up by iteratively merging <italic>k</italic>-mers and unitigs as long as possible (i.e., the existence of branches in the de Bruijn graph is checked implicitly via <italic>k</italic>-mer queries).</p>
      <p>Given a multiset <italic>R</italic> of strings, and a string <italic>x</italic>, we denote by occ(<italic>x</italic>, <italic>R</italic>) the number of occurrences of <italic>x</italic> in the strings of <italic>R</italic>, each different occurrence in a same string in <italic>R</italic> being counted individually. Given a string <italic>x</italic> ∈ Σ, we denote by <italic>x</italic><sup>−1</sup> ∈ Σ the reverse complement of <italic>x</italic>. Given a multiset <italic>R</italic> of strings and a string <italic>x</italic>, if <italic>x</italic> ≠ <italic>x</italic><sup>−1</sup>, we define occ<sub>cn</sub>(<italic>x</italic>, <italic>R</italic>) = occ(<italic>x</italic>, <italic>R</italic>) + occ(<italic>x</italic><sup>−1</sup>, <italic>R</italic>); otherwise, occ<sub>cn</sub>(<italic>x</italic>, <italic>R</italic>) = occ(<italic>x</italic>, <italic>R</italic>). We analogously define app(<italic>x</italic>, <italic>R</italic>) = min (1, occ(<italic>x</italic>, <italic>R</italic>)) and app<sub>cn</sub>(<italic>x</italic>, <italic>R</italic>) = min (1, occ<sub>cn</sub>(<italic>x</italic>, <italic>R</italic>)).</p>
      <p>Given multisets of strings <italic>R</italic> and <italic>U</italic>, we say that <italic>R</italic> and <italic>U</italic> have the same <italic>k-mer set</italic> if any <italic>k</italic>-mer that appears in one of the sets also appears in the other set. Analogously, we say that <italic>R</italic> and <italic>U</italic> have the same <italic>canonical k-mer set</italic> if for any <italic>k</italic>-mer <italic>q</italic> that appears in one of the sets, it holds that <italic>q</italic> or <italic>q</italic><sup>−1</sup> appears in the other set. We can equivalently express the fact that sets <italic>R</italic> and <italic>U</italic> have the same noncanonical <italic>k</italic>-mer set with the condition
<disp-formula id="GR277615CRAUM1"><mml:math id="UM1" display="block" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">iff</mml:mi><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1.</mml:mn></mml:math></disp-formula>
Likewise, <italic>R</italic> and <italic>U</italic> have the same <italic>canonical k-mer set</italic> if
<disp-formula id="GR277615CRAUM2"><mml:math id="UM2" display="block" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mrow><mml:mi mathvariant="normal">oc</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">c</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">iff</mml:mi><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">oc</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">c</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1.</mml:mn></mml:math></disp-formula>
We now give an equivalent <italic>string-centric</italic> definition of the <italic>set U</italic> of maximal unitigs of a multiset <italic>R</italic> of strings, under our formalism. As a warm-up, we start with the case when we do not have reverse complements.</p>
      <p>First, we require that all strings in the <italic>set U</italic> have a length of at least <italic>k</italic>, meaning unitigs contain at least one edge. Second, we require that <italic>R</italic> and <italic>U</italic> have the same <italic>k</italic>-mer set. Third, if a (<italic>k</italic> − 1)-mer appears at least two times in <italic>U</italic>, then it cannot be an internal node in any unitig. In other words, we forbid merging two separate unitigs at a branching (<italic>k</italic> − 1)-mer, because such branching (<italic>k</italic> − 1)-mer must appear in at least one other string in <italic>U</italic>:
<disp-formula id="GR277615CRAUM3"><mml:math id="UM3" display="block" overflow="scroll"><mml:mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mml:mtr><mml:mtd/><mml:mtd><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">if</mml:mi><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">then</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mi>q</mml:mi><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">appears</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">only</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">as</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">prefix</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">or</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">suffix</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:mi mathvariant="normal">of</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">strings</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">in</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mi>U</mml:mi><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
Note that the above property also ensures that no two equivalent cyclic unitigs are in <italic>U</italic>.</p>
      <p>To also impose maximality, we state that a (<italic>k</italic> − 1)-mer is a prefix or a suffix of a unitig if and only if it is either branching, a sink, or a source:
<disp-formula id="GR277615CRAUM4"><mml:math id="UM4" display="block" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="normal">end</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mi>U</mml:mi><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:munder><mml:mrow><mml:mo movablelimits="false">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:munder><mml:mspace width="0.2em"/><mml:mrow><mml:mi mathvariant="normal">app</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>⋅</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">or</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mspace width="0.4em"/></mml:mrow><mml:munder><mml:mrow><mml:mo movablelimits="false">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:munder><mml:mspace width="0.2em"/><mml:mrow><mml:mi mathvariant="normal">app</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>⋅</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mn>1.</mml:mn></mml:math></disp-formula>
 Having defined maximal unitigs without reverse complements, we now give the string-centric definition of maximal unitigs also assuming reverse complements (which we call <italic>canonical maximal unitigs</italic>). In fact, we give a more general one, also handling a required abundance threshold of the <italic>k</italic>-mers in <italic>R</italic>, further underlining the flexibility of our string-centric view.</p>
      <statement id="st1" content-type="definition">
        <label>Definition 1 (canonical maximal unitigs).</label>
        <p><italic>Given a multiset R of strings and integers k</italic> ≥ 2 <italic>and a</italic> ≥ 1<italic>, we say that a</italic> set <italic>U of strings is the set of</italic> canonical maximal unitigs <italic>of R with k-mer size k and abundance threshold a if the following conditions hold:</italic>
<list list-type="order"><list-item><p><inline-formula id="il4"><mml:math id="IL4" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:math></inline-formula><italic>,</italic> |<italic>x</italic>| ≥ <italic>k, and</italic>
<inline-formula id="il5"><mml:math id="IL5" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:math></inline-formula><italic>, x</italic> ≠ <italic>y</italic><sup>−1</sup>
<italic>(note that x</italic> ≠ <italic>y is guaranteed by the fact that U is a set);</italic></p></list-item><list-item><p><inline-formula id="il6"><mml:math id="IL6" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mrow><mml:mi mathvariant="normal">oc</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">c</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mspace width="0.4em"/></mml:mrow><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mi>f</mml:mi><mml:mspace width="0.4em"/><mml:mrow><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">oc</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">c</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula><italic>(same canonical k-mer multiset, with abundances);</italic></p></list-item><list-item><p><inline-formula id="il7"><mml:math id="IL7" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula><italic>, if</italic>  occ<sub>cn</sub>(<italic>q</italic>, <italic>U</italic>) &gt; 1, <italic>then q and q</italic><sup>−1</sup>
<italic>appear only as prefix or suffix of strings in U (unitigs do not span over branching</italic> (<italic>k</italic> − 1)<italic>-mers); and</italic></p></list-item><list-item><p><inline-formula id="il8"><mml:math id="IL8" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="normal">end</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mi>U</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula><italic>,</italic><inline-formula id="il9"><mml:math id="IL9" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mi mathvariant="normal">ap</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">p</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>⋅</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.4em"/><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mspace width="0.4em"/><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mi mathvariant="normal">ap</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">p</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>⋅</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula><italic>(maximality)</italic>.</p></list-item></list></p>
        <p>In our algorithm, we build unitigs incrementally, starting from individual <italic>k</italic>-mers (i.e., individual edges of the de Bruijn graph, which are unitigs) and extending them in both directions, as long as the resulting string remains a unitig (by checking for the satisfaction of Condition 3 in <xref rid="st1" ref-type="statement">Definition 1</xref> at each step, that is, whether we have reached the end of a unitig or not). Even though this is a simple strategy, behind other tools such as that of <xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. (2016)</xref>, it is nontrivial how to implement this efficiently in terms of running time, memory consumption, disk usage, and parallelization.</p>
        <p>Given an integer <italic>m</italic> ≤ <italic>k</italic> and a rolling function hash:Σ<sup><italic>m</italic></sup> → ℤ, the <italic>minimizer</italic> of a <italic>k</italic>-mer <italic>x</italic> is
<disp-formula id="GR277615CRAUM5"><mml:math id="UM5" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="normal">mini</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo form="prefix">min</mml:mo></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>m</mml:mi></mml:msup></mml:mrow><mml:mo>∧</mml:mo><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:munder><mml:mspace width="0.2em"/><mml:mrow><mml:mi mathvariant="normal">hash</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mi>y</mml:mi><mml:mo>)</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula>
Note that in this definition the minimizer is only a hash value and does not keep track of the particular position of the <italic>m</italic>-mer that has that minimum hash value. The <italic>m</italic> parameter is automatically chosen by GGCAT (it can also be user-defined) based on the value of <italic>k</italic>; for the precise function used to compute <italic>m</italic> from <italic>k</italic>, see <xref rid="SD2" ref-type="supplementary-material">Supplemental Table S2</xref>.</p>
        <p>Throughout the algorithm, we will refer to <italic>buckets</italic> as a partition of the data that is stored as a single blob; for example, when stored on disk each bucket corresponds to a file. Multiple buckets are used to partition data in a way that is optimized for parallelization, thereby allowing for parallel and independent processing of each bucket. They are also used to reduce the memory consumption of the algorithm because only the buckets that are currently being processed occupy main memory, whereas the other ones use only disk space.</p>
        <p>In the rest of this section, we present the algorithm for maximal unitigs without reverse complements, and then in the section “Construction correctness,” we explain the changes for canonical maximal unitigs.</p>
      </statement>
    </sec>
    <sec id="s3b">
      <title>Read splitting</title>
      <p>Each read <italic>R</italic><sub><italic>j</italic></sub> is split into substrings <inline-formula id="il10"><mml:math id="IL10" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that overlap on <italic>k</italic> − 2 characters, such that all (<italic>k</italic> − 1)-mers of <italic>S</italic><sub><italic>i</italic></sub> have the same minimizer, for all <italic>i</italic> ∈ {1, …, ℓ<sub><italic>j</italic></sub>}. For the minimizer hash function hash, we use the ntHash (<xref rid="GR277615CRAC32" ref-type="bibr">Mohamadi et al. 2016</xref>) function because it can give fast computation while ensuring good randomness in its value. Note that we can have multiple minimizer locations in the same substring <italic>S</italic><sub><italic>i</italic></sub> as long as they have the same hash value. We can compute <inline-formula id="il11"><mml:math id="IL11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in linear time in the size of <italic>R</italic><sub><italic>j</italic></sub> as follows. First, for every <italic>m</italic>-mer <italic>x</italic> of <italic>R</italic><sub><italic>j</italic></sub>, we compute hash(<italic>x</italic>) in a rolling manner. Then, in a sliding window manner, we compute the minimum of each window of <italic>k</italic> − <italic>m</italic> consecutive <italic>m</italic>-mers (which correspond to a (<italic>k</italic> − 1)-mer). Finally, we group consecutive (<italic>k</italic> − 1)-mers that share the same minimum in their corresponding window. For efficiency, we perform these three steps in a single pass over <italic>R</italic><sub><italic>j</italic></sub>.</p>
      <p>For every <italic>S</italic><sub><italic>i</italic></sub> obtained in this manner, let <italic>a</italic> and <italic>b</italic> be the characters of <italic>R</italic><sub><italic>j</italic></sub> immediately preceding and succeeding <italic>S</italic><sub><italic>i</italic></sub> in <italic>R</italic><sub><italic>j</italic></sub>, respectively, or the character $ if they do not exist. We call <italic>a</italic> and <italic>b linking characters</italic>. Consider the string <inline-formula id="il12"><mml:math id="IL12" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>S</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo>:=</mml:mo><mml:mi>a</mml:mi><mml:mo>⋅</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>⋅</mml:mo><mml:mi>b</mml:mi></mml:math></inline-formula> and observe that <inline-formula id="il13"><mml:math id="IL13" display="inline" overflow="scroll"><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:msubsup></mml:math></inline-formula> and <inline-formula id="il14"><mml:math id="IL14" display="inline" overflow="scroll"><mml:msubsup><mml:mi>S</mml:mi><mml:mi>i</mml:mi><mml:mi mathvariant="normal">′</mml:mi></mml:msubsup></mml:math></inline-formula> have a suffix–prefix overlap of <italic>k</italic> characters, because <italic>S</italic><sub><italic>i</italic>−1</sub> and <italic>S</italic><sub><italic>i</italic></sub> have a suffix–prefix overlap of <italic>k</italic> − 2 characters and we added <italic>b</italic> at the end of <italic>S</italic><sub><italic>i</italic>−1</sub> and <italic>a</italic> at the beginning of <italic>S</italic><sub><italic>i</italic></sub>. For an illustration, see <xref rid="GR277615CRAF1" ref-type="fig">Figure 1</xref>. Recall that all (<italic>k</italic> − 1)-mers of <italic>S</italic><sub><italic>i</italic></sub> have the same minimizer, say <italic>h</italic>; we assign each extended string <inline-formula id="il15"><mml:math id="IL15" display="inline" overflow="scroll"><mml:msubsup><mml:mi>S</mml:mi><mml:mi>i</mml:mi><mml:mi mathvariant="normal">′</mml:mi></mml:msubsup></mml:math></inline-formula> to a <italic>group G</italic><sub><italic>h</italic></sub> associated to such unique minimizer <italic>h</italic>. We say that a <italic>k</italic>-mer <italic>x</italic> appears in a group <italic>G</italic><sub><italic>h</italic></sub> if <italic>x</italic> is a substring of some <inline-formula id="il16"><mml:math id="IL16" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>S</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> in <italic>G</italic><sub><italic>h</italic></sub>.</p>
      <fig position="float" id="GR277615CRAF1">
        <label>Figure 1.</label>
        <caption>
          <p>Illustration of the read splitting step. Read <italic>R</italic><sub><italic>j</italic></sub> is split into substrings <italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>, <italic>S</italic><sub>3</sub> such that all <italic>k</italic>-mers of each <italic>S</italic><sub><italic>i</italic></sub> have the same minimizer, and extra linking characters (in red) are added to each <italic>S</italic><sub><italic>i</italic></sub>. The overlap between two such consecutive extended <italic>S</italic><sub><italic>i</italic></sub>s is of exactly <italic>k</italic> characters.</p>
        </caption>
        <graphic xlink:href="1198f01" position="float"/>
      </fig>
      <p>The above grouping strategy is similar to the one of <xref rid="GR277615CRAC23" ref-type="bibr">Kokot et al. (2017)</xref>, applied to <italic>k</italic>-mers instead of (<italic>k</italic> − 1)-mers (our strings <inline-formula id="il17"><mml:math id="IL17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are called <italic>super</italic> (<italic>k</italic> − 1)<italic>-mers</italic> by <xref rid="GR277615CRAC15" ref-type="bibr">Deorowicz et al. 2015</xref>), with the exception that when we group we add the linking characters. The following simple properties are key to ensuring the correctness of our approach.</p>
      <statement id="st2" content-type="lemma">
        <label>Lemma 1.</label>
        <p><italic>Let x be a k-mer appearing in the reads R, and in a group G</italic><sub><italic>h</italic></sub>. <italic>The following properties hold:</italic><list list-type="alpha-lower"><list-item><p>There is at most one other group in which <italic>x</italic> appears, and moreover, <italic>x</italic> appears in two distinct groups if and only if mini(pre<sub><italic>k</italic>−1</sub>(<italic>x</italic>)) ≠ mini(suf<sub><italic>k</italic>−1</sub>(<italic>x</italic>));</p></list-item><list-item><p>occ(<italic>x</italic>, <italic>G</italic><sub><italic>h</italic></sub>) = occ(<italic>x</italic>, <italic>R</italic>);</p></list-item><list-item><p>If mini(<italic>x</italic>) = <italic>h</italic> (i.e., <italic>x</italic> does not contain a linking character) and it has a (<italic>k</italic> − 1) suffix–prefix overlap with some <italic>k</italic>-mer <italic>y</italic> (in either order), then also <italic>y</italic> appears in group <italic>G</italic><sub><italic>h</italic></sub>.</p></list-item></list></p>
      </statement>
      <statement id="st3" content-type="proof">
        <label>Proof.</label>
        <p>
          <list list-type="alpha-lower">
            <list-item>
              <p>Let <italic>h</italic><sub>1</sub>: = mini(pre<sub><italic>k</italic>−1</sub>(<italic>x</italic>)) and <italic>h</italic><sub>2</sub>: = mini(suf<sub><italic>k</italic>−1</sub>(<italic>x</italic>)). The <italic>k</italic>-mer <italic>x</italic> appears only in groups <inline-formula id="il18"><mml:math id="IL18" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="il19"><mml:math id="IL19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which two distinct groups if <italic>h</italic><sub>1</sub> ≠ <italic>h</italic><sub>2</sub>.</p>
            </list-item>
            <list-item>
              <p>This follows by construction of the group, because all the <italic>k</italic>-mer occurrences that have the same minimizer are put in the same group.</p>
            </list-item>
            <list-item>
              <p>If the minimizer of <italic>y</italic> is also <italic>h</italic> (i.e., it does not contain a linking character), then <italic>y</italic> also appears in <italic>G</italic><sub><italic>h</italic></sub>. If not, recall that we added an extra character at the beginning and end of every string assigned to <italic>G</italic><sub><italic>h</italic></sub>; thus, <italic>y</italic> is a <italic>k</italic>-mer containing a linking character and thus appears in <italic>G</italic><sub><italic>h</italic></sub>.</p>
            </list-item>
          </list>
        </p>
      </statement>
      <p>Because we want to write the groups to disk and their number is the number of distinct minimizers, we merge the groups into a smaller number of buckets that are written to disk.</p>
    </sec>
    <sec id="s3c">
      <title>Construction of intermediate (nonmaximal) unitigs</title>
      <p><xref rid="st2" ref-type="statement">Lemma 1</xref> ensures that extending any <italic>k</italic>-mer <italic>x</italic> can be correctly performed just by querying the group of <italic>x</italic>.</p>
      <p>For each group, we perform the following:
<list list-type="order"><list-item><p>A <italic>k</italic>-mer counting step of the strings in the group, using a hashmap, while also keeping track if a <italic>k</italic>-mer contains a linking character. More precisely, we scan each string in a group, and for each <italic>k</italic>-mer that we encounter, we increase by one its abundance in the hashmap and add a flag if it contains a linking character.</p></list-item><list-item><p>From the hashmap, we create a list of unique <italic>k</italic>-mers of the group that have the required abundance. This abundance check is correct thanks to <xref rid="st2" ref-type="statement">Lemma 1</xref>(b).</p></list-item><list-item><p>We traverse the list of <italic>k</italic>-mers, and for each nonused <italic>k</italic>-mer <italic>x</italic>, we initialize a string <italic>z</italic>: = <italic>x</italic>, which will be extended right and left as long as it is a unitig (see <xref rid="GR277615CRAF2" ref-type="fig">Figs. 2</xref>, <xref rid="GR277615CRAF3" ref-type="fig">3</xref>). We try to extend <italic>z</italic> to the right by querying the hashmap for suf<sub><italic>k</italic>−1</sub>(<italic>z</italic>) · <italic>c</italic>, for all <italic>c</italic> ∈ {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>}. If there is a unique extension <italic>y</italic> such that suf<sub><italic>k</italic>−1</sub>(<italic>z</italic>) = pre<sub><italic>k</italic>−1</sub>(<italic>y</italic>), then we query the hashmap for <italic>c</italic> · pre<sub><italic>k</italic>−1</sub>(<italic>y</italic>), for all <italic>c</italic> ∈ {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>}. If exactly one match is found (i.e., suf<sub><italic>k</italic></sub>(<italic>z</italic>)), then we replace <italic>z</italic> with <inline-formula id="il20"><mml:math id="IL20" display="inline" overflow="scroll"><mml:mi>z</mml:mi><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mi>y</mml:mi></mml:math></inline-formula>, and we mark <italic>k</italic>-mer <italic>y</italic> as used in the hashmap. If <italic>y</italic> is not marked in the hashmap as having a linking character, then we repeat this right extension with the new string <italic>z</italic>. The queries to the hashmap are correct thanks to <xref rid="st2" ref-type="statement">Lemma 1</xref>(c). When we stop the right extension, we perform a symmetric left extension of <italic>z</italic>. After both extensions are completed, the resulting unitig <italic>z</italic> is given a unique index <italic>id</italic><sub><italic>z</italic></sub>. If the extension of <italic>z</italic> was stopped because of a linking character in the first or last <italic>k</italic>-mer <italic>y</italic> of <italic>z</italic>, we add (<italic>y</italic>, <italic>id</italic><sub><italic>z</italic></sub>) to a list <italic>L</italic>.</p></list-item></list>Notice that, after all groups have been processed, for any (<italic>y</italic>, <italic>id</italic><sub><italic>z</italic></sub>) in <italic>L</italic>, there exist exactly one other <inline-formula id="il21"><mml:math id="IL21" display="inline" overflow="scroll"><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:msup><mml:mi>z</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula> in <italic>L</italic>, added from a different group, by <xref rid="st2" ref-type="statement">Lemma 1</xref>(a). These two tuples indicate (nonmaximal) unitigs that have to be iteratively merged to obtain the maximal unitigs.</p>
      <fig position="float" id="GR277615CRAF2">
        <label>Figure 2.</label>
        <caption>
          <p>The extension step of the intermediate unitig construction happens inside each group. For each <italic>k</italic>-mer (<italic>top</italic>), it looks for a possible extension by checking all of the four possible neighbor <italic>k</italic>-mers in both directions and extends the <italic>k</italic>-mer (<italic>bottom</italic>) only if there is exactly one match both forward and backward (depicted in green in the first two figures from the <italic>top</italic>). Then it repeats the same process until no more extensions can be performed.</p>
        </caption>
        <graphic xlink:href="1198f02" position="float"/>
      </fig>
      <fig position="float" id="GR277615CRAF3">
        <label>Figure 3.</label>
        <caption>
          <p>The result of the intermediate unitig construction. Each intermediate unitig that has a possible extension shares an ending with another intermediate unitig.</p>
        </caption>
        <graphic xlink:href="1198f03" position="float"/>
      </fig>
    </sec>
    <sec id="s3d">
      <title>Unitig merging</title>
      <p>The tuples (<italic>y</italic>, <italic>id</italic><sub><italic>z</italic></sub>) in <italic>L</italic> are sorted by <italic>y</italic>, such that the two entries (<italic>y</italic>, <italic>id</italic><sub><italic>z</italic></sub>) and <inline-formula id="il22"><mml:math id="IL22" display="inline" overflow="scroll"><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:msup><mml:mi>z</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula> appear consecutively. Moreover, for any unitig <italic>z</italic>, there are at most two entries (<italic>x</italic>, <italic>id</italic><sub><italic>z</italic></sub>) and (<italic>y</italic>, <italic>id</italic><sub><italic>z</italic></sub>) in <italic>L</italic> (corresponding to its two end points). From these, we construct a list <inline-formula id="il23"><mml:math id="IL23" display="inline" overflow="scroll"><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:msup><mml:mi>z</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula> that is put in another list <italic>P</italic> of pairs of unitig that must be merged into maximal unitigs. This is one of the hardest steps to parallelize, because no partitioning can be performed ahead of time that puts all the unitigs that are contained in a maximal unitig in the same partition. In other tools, for example, BCALM2 (<xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. 2016</xref>), this step is performed using a union-find data structure that can be difficult to be used with concurrency. Our solution uses a randomized approach (i.e., with guaranteed correctness and only <italic>expected</italic> running time) to put in the same partition the unitigs that should be merged, repeating the process until all the unitigs are merged into the final maximal unitigs.</p>
      <p>We proceed as follows (see <xref rid="GR277615CRAF4" ref-type="fig">Fig. 4</xref>). We allocate a fixed number of buckets. Initially, for each list in <italic>P</italic>, we mark both its ends as <italic>unsealed</italic>. We repeat the following procedure until <italic>P</italic> is empty:
<list list-type="order"><list-item><p>For each list in <italic>P</italic>, we choose at random one of its unsealed ends. Without loss of generality, let this end be <italic>l</italic>. We put the list in the bucket corresponding to <italic>l</italic>, whereas in the bucket corresponding to the other ending <italic>r</italic>, we put a placeholder.</p></list-item><list-item><p>Inside each bucket, we sort the lists by the ending that caused the list to be placed in the bucket. Then, we merge all the endings that are equal to produce longer lists. If an ending in a bucket is not merged and it has no corresponding placeholder (of another list) in the bucket, then it is marked as <italic>sealed</italic>.</p></list-item><list-item><p>Finally, we remove from <italic>P</italic> each list having both ends sealed.</p></list-item></list>In the above process, given two lists in <italic>P</italic> that must be merged, there is at least a probability of at least 1/4 that they are assigned to the same bucket to be merged (in the worst case, both ends are unsealed). Thus, in expectation, this desired outcome happens only after four tries.</p>
      <fig position="float" id="GR277615CRAF4">
        <label>Figure 4.</label>
        <caption>
          <p>The unitig merging step on the unitigs from <xref rid="GR277615CRAF3" ref-type="fig">Figure 3</xref>. Each pair (ending, unitig index) is sorted by ending, and indexes of unitigs that share the same ending are joined in a tuple. Each such tuple is assigned to a bucket corresponding to one of its unsealed end point indices chosen at random (solid arrows in the figure). For the other end point index of the tuple (dashed arrow), we put a <italic>placeholder</italic> in its corresponding bucket (in gray). Then, inside each bucket, pairs sharing the same unitig index are joined to form larger tuples. If an ending cannot be joined and does not have a corresponding placeholder, then is it marked as sealed and is not selected anymore for bucket assignment. For example, in the first step, in <inline-formula id="il24"><mml:math id="IL24" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> the pair (<italic>id</italic><sub>1</sub>, <italic>id</italic><sub>2</sub>) is sealed at <italic>id</italic><sub>1</sub> because there is no placeholder for <italic>id</italic><sub>1</sub>; however, in <inline-formula id="il25"><mml:math id="IL25" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> the pair (<italic>id</italic><sub>2</sub>, <italic>id</italic><sub>3</sub>) is not sealed at <italic>id</italic><sub>2</sub> because <italic>id</italic><sub>2</sub> has a placeholder. The steps are repeated until no more tuples can be joined. For the noncanonical case, we can merge the pairs if one extremity is at the end and the other one at the beginning of the pairs. For canonical <italic>k</italic>-mers, we also have to keep track of the direction of the <italic>k</italic>-mer before joining them; for more details, see the section “Construction correctness.”</p>
        </caption>
        <graphic xlink:href="1198f04" position="float"/>
      </fig>
      <p>Both <italic>L</italic> and <italic>P</italic> are also stored in buckets to allow a better concurrency while processing them.</p>
    </sec>
    <sec id="s3e">
      <title>Construction correctness</title>
      <p>We start by proving the correctness of the algorithm (without reverse complements).</p>
      <statement id="st4" content-type="theorem">
        <label>Theorem 1.</label>
        <p><italic>Given a multiset R of strings, the strings U obtained at the end of our algorithm are the maximal unitigs of R</italic>.</p>
      </statement>
      <statement id="st5" content-type="proof">
        <label>Proof.</label>
        <p>We prove that <italic>U</italic> satisfied the conditions of <xref rid="st1" ref-type="statement">Definition 1</xref> (for noncanonical unitigs).</p>
        <p>For condition 0, because we start from <italic>k</italic>-mers, all strings in <italic>U</italic> have length at least <italic>k</italic>. To see that <italic>U</italic> is also a <italic>set</italic> (i.e., contains no duplicates), in our algorithm every <italic>k</italic>-mer is considered only once and is assigned to a unique unitig.</p>
        <p>For condition 1, observe that the algorithm does not introduce any <italic>k</italic>-mer that is not also in <italic>R</italic>, and does not exclude any <italic>k</italic>-mer from <italic>R</italic>; thus, <inline-formula id="il26"><mml:math id="IL26" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mtext> </mml:mtext><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">iff</mml:mi><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> holds. <xref rid="st2" ref-type="statement">Lemma 1</xref>(b) guarantees that occ(<italic>q</italic>, <italic>R</italic>) the number of occurrences of <italic>k</italic>-mer <italic>q</italic> is the same as the number of occurrences in its group, and thus, the operation from the section “Construction of intermediate (nonmaximal) unitigs” performed inside its group respects its abundance in <italic>R</italic>. Thus, <inline-formula id="il27"><mml:math id="IL27" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mtext> </mml:mtext><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">iff</mml:mi><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula>.</p>
        <p>Next, we prove conditions 3 and 2. Given an intermediary unitig <italic>z</italic>, we check for the eight <italic>k</italic>-mers that contain suf<sub><italic>k</italic>−1</sub>(<italic>z</italic>); we extend <italic>z</italic> iff only two <italic>k</italic>-mers appear (one out-going from, and one in-coming to suf<sub><italic>k</italic>−1</sub>(<italic>z</italic>)); thus, condition 3 is satisfied.</p>
        <p>After merging <italic>z</italic> with this out-going <italic>k</italic>-mer, there are no other <italic>k</italic>-mers (and thus no other unitigs in <italic>U</italic> because each <italic>k</italic>-mer appears exactly once in <italic>U</italic>, because in the section “Construction of intermediate (nonmaximal) unitigs” we mark the used <italic>k</italic>-mers) that contain suf<sub><italic>k</italic>−1</sub>(<italic>z</italic>) so condition 2 holds for single groups. This condition is still not satisfied globally, owing to the repetition of all the <italic>k</italic>-mers containing a linking character.</p>
        <p>We now prove condition 2 after the unitig merging step. Note that the unitigs fed to the unitig merging step are the ones that start or end with a linking character, so they always overlap on <italic>k</italic> characters. After merging all the repeated <italic>k</italic>-mers, we satisfy condition 2 globally.</p>
      </statement>
      <p>All the steps described so far can be easily adapted to work with canonical <italic>k</italic>-mers to obtain canonical maximal unitigs (<xref rid="st1" ref-type="statement">Definition 1</xref>). This can be performed by changing two steps. First, the hash functions are replaced by their “canonical” version, such that the hash of a <italic>k</italic>-mer is always equal to the one of its reverse complement. Second, in the unitig merging steps, relative orientations of the unitigs are tracked to allow joining unitigs that can be present in opposite orientations in the input data set, by reverse-complementing one of them.</p>
    </sec>
    <sec id="s3f">
      <title>Coloring</title>
      <p>Computing the colors for each <italic>k</italic>-mer of a de Bruijn graph has two main challenges: (1) tracking all colors that belong to each <italic>k</italic>-mer and (2) storing the colors in a storage- and time-efficient manner.</p>
      <p>To solve these two challenges, we propose a method partially inspired by the way BiFrost handles the colors, but with numerous improvements that allow for a smaller representation and a faster computation. The main idea is to merge color information for <italic>k</italic>-mers that share the same set of colors (see <xref rid="GR277615CRAC3" ref-type="bibr">Almodaresi et al. 2017</xref>; <xref rid="GR277615CRAC34" ref-type="bibr">Pandey et al. 2018</xref>; <xref rid="GR277615CRAC28" ref-type="bibr">Mäklin et al. 2021</xref>), while avoiding costly comparisons of the entire sets for each <italic>k</italic>-mer. More precisely, for each <italic>k</italic>-mer, a normalized list <italic>C</italic> of colors is obtained by tracking the source of each <italic>k</italic>-mer, saving all the colors in a possibly redundant way (e.g., if the <italic>k</italic>-mer appears multiple times in a reference sequence), and then sorting and deduplicating them. From <italic>C</italic>, a 128-bit strong hash <italic>h</italic> is generated and is checked against a global hashmap that maps <italic>h</italic> to a color subset index. If a match is not found, then the list <italic>L</italic> is written to the color map, and a new incremental subset index for <italic>L</italic> is generated. Otherwise, it means that the color set already appeared in a previously processed <italic>k</italic>-mer, so the subset index of that color set is returned. Finally, the <italic>k</italic>-mer in the graph is labeled with its corresponding subset index, which, as discussed above, uniquely identifies a color subset. Overall, this allows a better compression, because each subset is encoded only once and not for every <italic>k</italic>-mer that belongs to it.</p>
      <p>To optimize the disk space of the color map, this is encoded using a run-length compression scheme on the differences of the sorted colors of the subset, then it is divided into chunks for faster access and compressed again with a run of the lz4 algorithm. Furthermore, when writing the unitigs to disk, we mark the colors of each unitig in the header of the unitig sequence in the FASTA file by also run-length encoding the color set indices of all the <italic>k</italic>-mers of the unitigs. This strategy works well because most unitigs are “variation-free” and thus tend to have only a small number of possible color subsets associated to its <italic>k</italic>-mers.</p>
    </sec>
    <sec id="s3g">
      <title>Sequence querying</title>
      <p>GGCAT performs queries by dividing unitigs of the input graph and the queries in buckets, using an approach similar to the reads splitting step of the build algorithm. Then, independently for each bucket, a <italic>k</italic>-mer counting is performed to find the number of <italic>k</italic>-mers that match for each query. Finally, all the counters from different buckets are summed up to find for each query the number of <italic>k</italic>-mers that are present in the input graph. This also allows the partial matching of queries, because the output is the exact number of <italic>k</italic>-mer matches for each input sequence, and a percentage of required matching <italic>k</italic>-mers can be put as threshold to report a query as present. Similar to BiFrost, for the uncolored case, we return in output a CSV file with a line for each input query, containing the number and percentage of matched <italic>k</italic>-mers. For the colored case, we opted instead for a JSON Lines (JSONL) file with a line for each query, containing the number (if positive) of <italic>k</italic>-mer matches for each color <italic>c</italic> of the graph.</p>
    </sec>
    <sec id="s3h">
      <title>Details of the data sets used in the evaluation</title>
      <p>The Human Illumina read data set is the Illumina WGS 2 × 250-bp data set from the GIAB project, accession number HG004, <uri xlink:href="https://github.com/genome-in-a-bottle/giab·data·indexes/blob/master/AshkenazimTrio/sequence.index.AJtrio·Illumina·2×250bps·06012016.HG004">https://github.com/genome-in-a-bottle/giab·data·indexes/blob/master/AshkenazimTrio/sequence.index.AJtrio·Illumina·2×250bps·06012016.HG004</uri>. The Human gut microbiome read data set was obtained from the NCBI BioProject database (<uri xlink:href="https://www.ncbi.nlm.nih.gov/bioproject/">https://www.ncbi.nlm.nih.gov/bioproject/</uri>) under accession number PRJEB33098 (<xref rid="GR277615CRAC30" ref-type="bibr">Mas-Lloret et al. 2020</xref>). The 309 K <italic>Salmonella</italic> genome sequences were downloaded by us in February 2022 from the EnteroBase database (<xref rid="GR277615CRAC45" ref-type="bibr">Zhou et al. 2020</xref>) and gzipped. The 100 Human genomes are from the set of 2505 Human genomes generated by <xref rid="GR277615CRAC43" ref-type="bibr">Schmidt et al. (2023)</xref> using GRCh37 and the variant files from the 1000 Genomes Project (<xref rid="GR277615CRAC1" ref-type="bibr">The 1000 Genomes Project Consortium 2015</xref>). For convenience we uploaded the Human genomes used for the benchmark to Zenodo (<uri xlink:href="https://doi.org/10.5281/zenodo.2597496">https://doi.org/10.5281/zenodo.2597496</uri>). The use of a newer Human genome reference would not significantly affect the conclusions of this study. Indeed, the computational performance of the tools are mainly dependent on the number of unique <italic>k</italic>-mers, which is mainly dependent on the variant files. However, in this setting, we would use the same variant files, even if a newer genome reference was used. The Bacterial genome sequences are from the data set used by <xref rid="GR277615CRAC6" ref-type="bibr">Blackwell et al. (2021)</xref>.</p>
    </sec>
    <sec id="s3i">
      <title>Software availability</title>
      <p>GGCAT is implemented in Rust and is available at GitHub (<uri xlink:href="https://github.com/algbio/ggcat">https://github.com/algbio/ggcat</uri>) and as <xref rid="SD1" ref-type="supplementary-material">Supplemental Code</xref>. For all tests, we used GGCAT commit <monospace>f56da4d35f99f3537ec0a33f44d575898a8c91ea</monospace> (<uri xlink:href="https://github.com/algbio/ggcat/tree/f56da4d35f99f3537ec0a33f44d575898a8c91ea">https://github.com/algbio/ggcat/tree/f56da4d35f99f3537ec0a33f44d575898a8c91ea</uri>). The tools and scripts used to perform the benchmarks are available at GitHub (<uri xlink:href="https://github.com/Guilucand/ggcat-test-benchmarks">https://github.com/Guilucand/ggcat-test-benchmarks</uri>) and as <xref rid="SD1" ref-type="supplementary-material">Supplemental Code</xref>. The scripts for downloading the data sets used in the evaluation are available in the datasets-download/ folder of this repository.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material" id="SM1">
    <title>Supplementary Material</title>
    <supplementary-material id="SD1" position="float" content-type="local-data">
      <label>Supplement 1</label>
      <media xlink:href="Supplemental_Code.zip" id="d64e3263" position="anchor"/>
    </supplementary-material>
    <supplementary-material id="SD2" position="float" content-type="local-data">
      <label>Supplement 2</label>
      <media xlink:href="Supplemental_Methods.pdf" id="d64e3266" position="anchor"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgments</title>
    <p>We thank Massimo Cairo and Romeo Rizzi for initial discussions on this problem. We thank Paul Medvedev for spotting some errors in the initial manuscript, pointing us to relevant literature, and suggesting that the equivalence between edge-centric and node-centric unitigs exists, which we proved in the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.277615.122/-/DC1" ext-link-type="uri">Supplemental Methods</ext-link>. We thank Jarno Alanko, Tommi Mäklin, and Rob Patro for pointing us to relevant literature. We thank Jarno Alanko for spotting and fixing some concurrency-related bugs in GGCAT. We thank Sebastian Schmidt for help with the integration of eulertigs (<xref rid="GR277615CRAC42" ref-type="bibr">Schmidt and Alanko 2022</xref>) and matchtigs (<xref rid="GR277615CRAC43" ref-type="bibr">Schmidt et al. 2023</xref>) into GGCAT. This work was partially funded by the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement no. 851093, SAFEBIO), and partially by the Academy of Finland (grant nos. 322595, 352821, and 346968).</p>
  </ack>
  <fn-group>
    <fn fn-type="supplementary-material">
      <p>[Supplemental material is available for this article.]</p>
    </fn>
    <fn>
      <p>Article published online before print. Article, supplemental material, and publication date are at <ext-link xlink:href="https://www.genome.org/cgi/doi/10.1101/gr.277615.122" ext-link-type="uri">https://www.genome.org/cgi/doi/10.1101/gr.277615.122</ext-link>.</p>
    </fn>
    <fn>
      <p>Freely available online through the <italic>Genome Research</italic> Open Access option.</p>
    </fn>
  </fn-group>
  <sec id="s5">
    <title>Competing interest statement</title>
    <p>The authors declare no competing interests.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="GR277615CRAC1">
      <mixed-citation publication-type="journal"><collab>The 1000 Genomes Project Consortium</collab>. <year>2015</year>. <article-title>A global reference for human genetic variation</article-title>. <source>Nature</source><volume>526</volume>: <fpage>68</fpage>–<lpage>74</lpage>. <pub-id pub-id-type="doi">10.1038/nature15393</pub-id><pub-id pub-id-type="pmid">26432245</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC2">
      <mixed-citation publication-type="journal"><string-name><surname>Alanko</surname><given-names>JN</given-names></string-name>, <string-name><surname>Vuohtoniemi</surname><given-names>J</given-names></string-name>, <string-name><surname>Mäklin</surname><given-names>T</given-names></string-name>, <string-name><surname>Puglisi</surname><given-names>SJ</given-names></string-name>. <year>2023</year>. <article-title>Themisto: a scalable colored <italic>k</italic>-mer index for sensitive pseudoalignment against hundreds of thousands of bacterial genomes</article-title>. <source>Bioinformatics</source><volume>39</volume>(<issue>39 Suppl 1</issue>): <fpage>i260</fpage>–<lpage>i269</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btad233</pub-id><pub-id pub-id-type="pmid">37387143</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC3">
      <mixed-citation publication-type="confproc"><string-name><surname>Almodaresi</surname><given-names>F</given-names></string-name>, <string-name><surname>Pandey</surname><given-names>P</given-names></string-name>, <string-name><surname>Patro</surname><given-names>R</given-names></string-name>. <year>2017</year>. <article-title>Rainbowfish: a succinct colored de Bruijn graph representation</article-title>. In <conf-name>17th International Workshop on Algorithms in Bioinformatics, WABI 2017</conf-name>, Vol. 88 <italic>of LIPIcs</italic> (ed. <string-name><surname>Schwartz</surname><given-names>R</given-names></string-name>, <string-name><surname>Reinert</surname><given-names>K</given-names></string-name>), pp. <fpage>18:1</fpage>–<lpage>18:15</lpage>. <publisher-name>Leibniz-Zentrum für Informatik, Schloss Dagstuhl</publisher-name>, <publisher-loc>Wadern, Germany</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR277615CRAC4">
      <mixed-citation publication-type="journal"><string-name><surname>Bankevich</surname><given-names>A</given-names></string-name>, <string-name><surname>Bzikadze</surname><given-names>AV</given-names></string-name>, <string-name><surname>Kolmogorov</surname><given-names>M</given-names></string-name>, <string-name><surname>Antipov</surname><given-names>D</given-names></string-name>, <string-name><surname>Pevzner</surname><given-names>PA</given-names></string-name>. <year>2022</year>. <article-title>Multiplex de Bruijn graphs enable genome assembly from long, high-fidelity reads</article-title>. <source>Nat Biotechnol</source><volume>40</volume>: <fpage>1075</fpage>–<lpage>1081</lpage>. <pub-id pub-id-type="doi">10.1038/s41587-022-01220-6</pub-id><pub-id pub-id-type="pmid">35228706</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC5">
      <mixed-citation publication-type="journal"><string-name><surname>Benoit</surname><given-names>G</given-names></string-name>, <string-name><surname>Lemaitre</surname><given-names>C</given-names></string-name>, <string-name><surname>Lavenier</surname><given-names>D</given-names></string-name>, <string-name><surname>Drezen</surname><given-names>D</given-names></string-name>, <string-name><surname>Dayris</surname><given-names>T</given-names></string-name>, <string-name><surname>Uricaru</surname><given-names>R</given-names></string-name>, <string-name><surname>Rizk</surname><given-names>G</given-names></string-name>. <year>2015</year>. <article-title>Reference-free compression of high throughput sequencing data with a probabilistic de Bruijn graph</article-title>. <source>BMC Bioinformatics</source><volume>16</volume>: <fpage>288</fpage>. <pub-id pub-id-type="doi">10.1186/s12859-015-0709-7</pub-id><pub-id pub-id-type="pmid">26370285</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC6">
      <mixed-citation publication-type="journal"><string-name><surname>Blackwell</surname><given-names>GA</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>M</given-names></string-name>, <string-name><surname>Malone</surname><given-names>KM</given-names></string-name>, <string-name><surname>Lima</surname><given-names>L</given-names></string-name>, <string-name><surname>Horesh</surname><given-names>G</given-names></string-name>, <string-name><surname>Alako</surname><given-names>BTF</given-names></string-name>, <string-name><surname>Thomson</surname><given-names>NR</given-names></string-name>, <string-name><surname>Iqbal</surname><given-names>Z</given-names></string-name>. <year>2021</year>. <article-title>Exploring bacterial diversity via a curated and searchable snapshot of archived DNA sequences</article-title>. <source>PLoS Biol</source><volume>19</volume>: <fpage>e3001421</fpage>. <pub-id pub-id-type="doi">10.1371/journal.pbio.3001421</pub-id><pub-id pub-id-type="pmid">34752446</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC7">
      <mixed-citation publication-type="journal"><string-name><surname>Bloom</surname><given-names>BH</given-names></string-name>. <year>1970</year>. <article-title>Space/time trade-offs in hash coding with allowable errors</article-title>. <source>Commun ACM</source><volume>13</volume>: <fpage>422</fpage>–<lpage>426</lpage>. <pub-id pub-id-type="doi">10.1145/362686.362692</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC8">
      <mixed-citation publication-type="journal"><string-name><surname>Bray</surname><given-names>NL</given-names></string-name>, <string-name><surname>Pimentel</surname><given-names>H</given-names></string-name>, <string-name><surname>Melsted</surname><given-names>P</given-names></string-name>, <string-name><surname>Pachter</surname><given-names>L</given-names></string-name>. <year>2016</year>. <article-title>Near-optimal probabilistic RNA-seq quantification</article-title>. <source>Nat Biotechnol</source><volume>34</volume>: <fpage>525</fpage>–<lpage>527</lpage>. <pub-id pub-id-type="doi">10.1038/nbt.3519</pub-id><pub-id pub-id-type="pmid">27043002</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC9">
      <mixed-citation publication-type="journal"><string-name><surname>Břinda</surname><given-names>K</given-names></string-name>, <string-name><surname>Baym</surname><given-names>M</given-names></string-name>, <string-name><surname>Kucherov</surname><given-names>G</given-names></string-name>. <year>2021</year>. <article-title>Simplitigs as an efficient and scalable representation of de Bruijn graphs</article-title>. <source>Genome Biol</source><volume>22</volume>: <fpage>96</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-021-02297-z</pub-id><pub-id pub-id-type="pmid">33823902</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC10">
      <mixed-citation publication-type="journal"><string-name><surname>Cameron</surname><given-names>DL</given-names></string-name>, <string-name><surname>Schröder</surname><given-names>J</given-names></string-name>, <string-name><surname>Penington</surname><given-names>JS</given-names></string-name>, <string-name><surname>Do</surname><given-names>H</given-names></string-name>, <string-name><surname>Molania</surname><given-names>R</given-names></string-name>, <string-name><surname>Dobrovic</surname><given-names>A</given-names></string-name>, <string-name><surname>Speed</surname><given-names>TP</given-names></string-name>, <string-name><surname>Papenfuss</surname><given-names>AT</given-names></string-name>. <year>2017</year>. <article-title>GRIDSS: sensitive and specific genomic rearrangement detection using positional de Bruijn graph assembly</article-title>. <source>Genome Res</source><volume>27</volume>: <fpage>2050</fpage>–<lpage>2060</lpage>. <pub-id pub-id-type="doi">10.1101/gr.222109.117</pub-id><pub-id pub-id-type="pmid">29097403</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC11">
      <mixed-citation publication-type="journal"><string-name><surname>Chambi</surname><given-names>S</given-names></string-name>, <string-name><surname>Lemire</surname><given-names>D</given-names></string-name>, <string-name><surname>Kaser</surname><given-names>O</given-names></string-name>, <string-name><surname>Godin</surname><given-names>R</given-names></string-name>. <year>2016</year>. <article-title>Better bitmap performance with roaring bitmaps</article-title>. <source>Softw Pract Exp</source><volume>46</volume>: <fpage>709</fpage>–<lpage>719</lpage>. <pub-id pub-id-type="doi">10.1002/spe.2325</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC12">
      <mixed-citation publication-type="journal"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P</given-names></string-name>. <year>2016</year>. <article-title>Compacting de Bruijn graphs from sequencing data quickly and in low memory</article-title>. <source>Bioinformatics</source><volume>32</volume>: <fpage>i201</fpage>–<lpage>i208</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btw279</pub-id><pub-id pub-id-type="pmid">27307618</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC13">
      <mixed-citation publication-type="journal"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Holub</surname><given-names>J</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P</given-names></string-name>. <year>2022</year>. <article-title>Data structures to represent a set of <italic>k</italic>-long DNA sequences</article-title>. <source>ACM Comput Surv</source><volume>54</volume>: <fpage>17</fpage>. <pub-id pub-id-type="doi">10.1145/3445967</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC14">
      <mixed-citation publication-type="journal"><string-name><surname>Compeau</surname><given-names>PEC</given-names></string-name>, <string-name><surname>Pevzner</surname><given-names>PA</given-names></string-name>, <string-name><surname>Tesler</surname><given-names>G</given-names></string-name>. <year>2011</year>. <article-title>How to apply de Bruijn graphs to genome assembly</article-title>. <source>Nat Biotechnol</source><volume>29</volume>: <fpage>987</fpage>–<lpage>991</lpage>. <pub-id pub-id-type="doi">10.1038/nbt.2023</pub-id><pub-id pub-id-type="pmid">22068540</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC15">
      <mixed-citation publication-type="journal"><string-name><surname>Deorowicz</surname><given-names>S</given-names></string-name>, <string-name><surname>Kokot</surname><given-names>M</given-names></string-name>, <string-name><surname>Grabowski</surname><given-names>S</given-names></string-name>, <string-name><surname>Debudaj-Grabysz</surname><given-names>A</given-names></string-name>. <year>2015</year>. <article-title>KMC 2: fast and resource-frugal <italic>k</italic>-mer counting</article-title>. <source>Bioinformatics</source><volume>31</volume>: <fpage>1569</fpage>–<lpage>1576</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btv022</pub-id><pub-id pub-id-type="pmid">25609798</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC16">
      <mixed-citation publication-type="journal"><string-name><surname>Drezen</surname><given-names>E</given-names></string-name>, <string-name><surname>Rizk</surname><given-names>G</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Deltel</surname><given-names>C</given-names></string-name>, <string-name><surname>Lemaitre</surname><given-names>C</given-names></string-name>, <string-name><surname>Peterlongo</surname><given-names>P</given-names></string-name>, <string-name><surname>Lavenier</surname><given-names>D</given-names></string-name>. <year>2014</year>. <article-title>GATB: genome assembly &amp; analysis tool box</article-title>. <source>Bioinformatics</source><volume>30</volume>: <fpage>2959</fpage>–<lpage>2961</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btu406</pub-id><pub-id pub-id-type="pmid">24990603</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC17">
      <mixed-citation publication-type="journal"><string-name><surname>Dufault-Thompson</surname><given-names>K</given-names></string-name>, <string-name><surname>Jiang</surname><given-names>X</given-names></string-name>. <year>2022</year>. <article-title>Applications of de Bruijn graphs in microbiome research</article-title>. <source>iMeta</source><volume>1</volume>: <fpage>e4</fpage>. <pub-id pub-id-type="doi">10.1002/imt2.4</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC18">
      <mixed-citation publication-type="journal"><string-name><surname>Guo</surname><given-names>H</given-names></string-name>, <string-name><surname>Fu</surname><given-names>Y</given-names></string-name>, <string-name><surname>Gao</surname><given-names>Y</given-names></string-name>, <string-name><surname>Li</surname><given-names>J</given-names></string-name>, <string-name><surname>Wang</surname><given-names>Y</given-names></string-name>, <string-name><surname>Liu</surname><given-names>B</given-names></string-name>. <year>2021</year>. <article-title>deGSM: memory scalable construction of large scale de Bruijn graph</article-title>. <source>IEEE/ACM Trans Comput Biol Bioinform</source><volume>18</volume>: <fpage>2157</fpage>–<lpage>2166</lpage>. <pub-id pub-id-type="doi">10.1109/TCBB.2019.2913932</pub-id><pub-id pub-id-type="pmid">31056509</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC19">
      <mixed-citation publication-type="journal"><string-name><surname>Holley</surname><given-names>G</given-names></string-name>, <string-name><surname>Melsted</surname><given-names>P</given-names></string-name>. <year>2020</year>. <article-title>Bifrost: highly parallel construction and indexing of colored and compacted de Bruijn graphs</article-title>. <source>Genome Biol</source><volume>21</volume>: <fpage>249</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-020-02135-8</pub-id><pub-id pub-id-type="pmid">32943081</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC20">
      <mixed-citation publication-type="journal"><string-name><surname>Iqbal</surname><given-names>Z</given-names></string-name>, <string-name><surname>Caccamo</surname><given-names>M</given-names></string-name>, <string-name><surname>Turner</surname><given-names>O</given-names></string-name>, <string-name><surname>Flicek</surname><given-names>P</given-names></string-name>, <string-name><surname>McVean</surname><given-names>G</given-names></string-name>. <year>2012</year>. <article-title><italic>De novo</italic> assembly and genotyping of variants using colored de Bruijn graphs</article-title>. <source>Nat Genet</source><volume>44</volume>: <fpage>226</fpage>–<lpage>232</lpage>. <pub-id pub-id-type="doi">10.1038/ng.1028</pub-id><pub-id pub-id-type="pmid">22231483</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC21">
      <mixed-citation publication-type="journal"><string-name><surname>Khan</surname><given-names>J</given-names></string-name>, <string-name><surname>Patro</surname><given-names>R</given-names></string-name>. <year>2021</year>. <article-title>Cuttlefish: fast, parallel and low-memory compaction of de Bruijn graphs from large-scale genome collections</article-title>. <source>Bioinformatics</source><volume>37</volume>: <fpage>i177</fpage>–<lpage>i186</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btab309</pub-id><pub-id pub-id-type="pmid">34252958</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC22">
      <mixed-citation publication-type="journal"><string-name><surname>Khan</surname><given-names>J</given-names></string-name>, <string-name><surname>Kokot</surname><given-names>M</given-names></string-name>, <string-name><surname>Deorowicz</surname><given-names>S</given-names></string-name>, <string-name><surname>Patro</surname><given-names>R</given-names></string-name>. <year>2022</year>. <article-title>Scalable, ultra-fast, and low-memory construction of compacted de Bruijn graphs with Cuttlefish 2</article-title>. <source>Genome Biol</source><volume>23</volume>: <fpage>190</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-022-02743-6</pub-id><pub-id pub-id-type="pmid">36076275</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC23">
      <mixed-citation publication-type="journal"><string-name><surname>Kokot</surname><given-names>M</given-names></string-name>, <string-name><surname>Długosz</surname><given-names>M</given-names></string-name>, <string-name><surname>Deorowicz</surname><given-names>S</given-names></string-name>. <year>2017</year>. <article-title>KMC 3: counting and manipulating <italic>k</italic>-mer statistics</article-title>. <source>Bioinformatics</source><volume>33</volume>: <fpage>2759</fpage>–<lpage>2761</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btx304</pub-id><pub-id pub-id-type="pmid">28472236</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC24">
      <mixed-citation publication-type="confproc"><string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Rizk</surname><given-names>G</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Peterlongo</surname><given-names>R</given-names></string-name>. <year>2017</year>. <article-title>Fast and scalable minimal perfect hashing for massive key sets</article-title>. In <conf-name>16th International Symposium on Experimental Algorithms (SEA 2017)</conf-name>, Vol. 75 <italic>of LIPIcs</italic> (ed. <string-name><surname>Iliopoulos</surname></string-name> C <etal/>), pp. <fpage>25:1</fpage>–<lpage>25:16</lpage>. <publisher-name>Leibniz-Zentrum für Informatik, Schloss Dagstuhl</publisher-name>, <publisher-loc>Wadern, Germany</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR277615CRAC25">
      <mixed-citation publication-type="journal"><string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Flot</surname><given-names>JF</given-names></string-name>, <string-name><surname>Peterlongo</surname><given-names>P</given-names></string-name>. <year>2020</year>. <article-title>Toward perfect reads: self-correction of short reads via mapping on de Bruijn graphs</article-title>. <source>Bioinformatics</source><volume>36</volume>: <fpage>1374</fpage>–<lpage>1381</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btz102</pub-id><pub-id pub-id-type="pmid">30785192</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC26">
      <mixed-citation publication-type="journal"><string-name><surname>Liu</surname><given-names>B</given-names></string-name>, <string-name><surname>Guo</surname><given-names>H</given-names></string-name>, <string-name><surname>Brudno</surname><given-names>M</given-names></string-name>, <string-name><surname>Wang</surname><given-names>Y</given-names></string-name>. <year>2016</year>. <article-title>deBGA: read alignment with de Bruijn graph-based seed and extension</article-title>. <source>Bioinformatics</source><volume>32</volume>: <fpage>3224</fpage>–<lpage>3232</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btw371</pub-id><pub-id pub-id-type="pmid">27378303</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC27">
      <mixed-citation publication-type="journal"><string-name><surname>Luhmann</surname><given-names>N</given-names></string-name>, <string-name><surname>Holley</surname><given-names>G</given-names></string-name>, <string-name><surname>Achtman</surname><given-names>M</given-names></string-name>. <year>2021</year>. <article-title>BlastFrost: fast querying of 100,000s of bacterial genomes in Bifrost graphs</article-title>. <source>Genome Biol</source><volume>22</volume>: <fpage>30</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-020-02237-3</pub-id><pub-id pub-id-type="pmid">33430919</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC28">
      <mixed-citation publication-type="journal"><string-name><surname>Mäklin</surname><given-names>T</given-names></string-name>, <string-name><surname>Kallonen</surname><given-names>T</given-names></string-name>, <string-name><surname>Alanko</surname><given-names>J</given-names></string-name>, <string-name><surname>Samuelsen</surname><given-names>Ø</given-names></string-name>, <string-name><surname>Hegstad</surname><given-names>K</given-names></string-name>, <string-name><surname>Mäkinen</surname><given-names>V</given-names></string-name>, <string-name><surname>Corander</surname><given-names>J</given-names></string-name>, <string-name><surname>Heinz</surname><given-names>E</given-names></string-name>, <string-name><surname>Honkela</surname><given-names>A</given-names></string-name>. <year>2021</year>. <article-title>Bacterial genomic epidemiology with mixed samples</article-title>. <source>Microb Genom</source><volume>7</volume>: <fpage>000691</fpage>. <pub-id pub-id-type="doi">10.1099/mgen.0.000691</pub-id><pub-id pub-id-type="pmid">34779765</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC29">
      <mixed-citation publication-type="journal"><string-name><surname>Mäklin</surname><given-names>T</given-names></string-name>, <string-name><surname>Thorpe</surname><given-names>HA</given-names></string-name>, <string-name><surname>Pöntinen</surname><given-names>AK</given-names></string-name>, <string-name><surname>Gladstone</surname><given-names>RA</given-names></string-name>, <string-name><surname>Shao</surname><given-names>Y</given-names></string-name>, <string-name><surname>Pesonen</surname><given-names>M</given-names></string-name>, <string-name><surname>McNally</surname><given-names>A</given-names></string-name>, <string-name><surname>Johnsen</surname><given-names>PJ</given-names></string-name>, <string-name><surname>Samuelsen</surname><given-names>Ø</given-names></string-name>, <string-name><surname>Lawley</surname><given-names>TD</given-names></string-name>, <etal/><year>2022</year>. <article-title>Strong pathogen competition in neonatal gut colonisation</article-title>. <source>Nat Commun</source><volume>13</volume>: <fpage>7417</fpage>. <pub-id pub-id-type="doi">10.1038/s41467-022-35178-5</pub-id><pub-id pub-id-type="pmid">36456554</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC30">
      <mixed-citation publication-type="journal"><string-name><surname>Mas-Lloret</surname><given-names>J</given-names></string-name>, <string-name><surname>Obón-Santacana</surname><given-names>M</given-names></string-name>, <string-name><surname>Ibáñez-Sanz</surname><given-names>G</given-names></string-name>, <string-name><surname>Guinó</surname><given-names>E</given-names></string-name>, <string-name><surname>Pato</surname><given-names>ML</given-names></string-name>, <string-name><surname>Rodriguez-Moranta</surname><given-names>F</given-names></string-name>, <string-name><surname>Mata</surname><given-names>A</given-names></string-name>, <string-name><surname>García-Rodríguez</surname><given-names>A</given-names></string-name>, <string-name><surname>Moreno</surname><given-names>V</given-names></string-name>, <string-name><surname>Pimenoff</surname><given-names>VN</given-names></string-name>. <year>2020</year>. <article-title>Gut microbiome diversity detected by high-coverage 16s and shotgun sequencing of paired stool and colon sample</article-title>. <source>Sci Data</source><volume>7</volume>: <fpage>92</fpage>. <pub-id pub-id-type="doi">10.1038/s41597-020-0427-5</pub-id><pub-id pub-id-type="pmid">32179734</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC31">
      <mixed-citation publication-type="confproc"><string-name><surname>Minkin</surname><given-names>I</given-names></string-name>, <string-name><surname>Patel</surname><given-names>A</given-names></string-name>, <string-name><surname>Kolmogorov</surname><given-names>M</given-names></string-name>, <string-name><surname>Vyahhi</surname><given-names>N</given-names></string-name>, <string-name><surname>Pham</surname><given-names>S</given-names></string-name>. <year>2013</year>. <article-title>Sibelia: a scalable and comprehensive synteny block generation tool for closely related microbial genomes</article-title>. In <conf-name>Algorithms in bioinformatics (WABI 2013), Vol. 8126 of LNCS</conf-name> (ed. <string-name><surname>Darling</surname><given-names>A</given-names></string-name>, <string-name><surname>Stoye</surname><given-names>J</given-names></string-name>), pp. <fpage>215</fpage>–<lpage>229</lpage>. <publisher-name>Springer</publisher-name>, <publisher-loc>Berlin</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR277615CRAC32">
      <mixed-citation publication-type="journal"><string-name><surname>Mohamadi</surname><given-names>H</given-names></string-name>, <string-name><surname>Chu</surname><given-names>J</given-names></string-name>, <string-name><surname>Vandervalk</surname><given-names>BP</given-names></string-name>, <string-name><surname>Birol</surname><given-names>I</given-names></string-name>. <year>2016</year>. <article-title>ntHash: recursive nucleotide hashing</article-title>. <source>Bioinformatics</source><volume>32</volume>: <fpage>3492</fpage>–<lpage>3494</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btw397</pub-id><pub-id pub-id-type="pmid">27423894</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC33">
      <mixed-citation publication-type="journal"><string-name><surname>Muggli</surname><given-names>MD</given-names></string-name>, <string-name><surname>Alipanahi</surname><given-names>B</given-names></string-name>, <string-name><surname>Boucher</surname><given-names>C</given-names></string-name>. <year>2019</year>. <article-title>Building large updatable colored de Bruijn graphs via merging</article-title>. <source>Bioinformatics</source><volume>35</volume>: <fpage>i51</fpage>–<lpage>i60</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btz350</pub-id><pub-id pub-id-type="pmid">31510647</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC34">
      <mixed-citation publication-type="journal"><string-name><surname>Pandey</surname><given-names>P</given-names></string-name>, <string-name><surname>Almodaresi</surname><given-names>F</given-names></string-name>, <string-name><surname>Bender</surname><given-names>MA</given-names></string-name>, <string-name><surname>Ferdman</surname><given-names>M</given-names></string-name>, <string-name><surname>Johnson</surname><given-names>R</given-names></string-name>, <string-name><surname>Patro</surname><given-names>R</given-names></string-name>. <year>2018</year>. <article-title>Mantis: a fast, small, and exact large-scale sequence-search index</article-title>. <source>Cell Syst</source><volume>7</volume>: <fpage>201</fpage>–<lpage>207.e4</lpage>. <pub-id pub-id-type="doi">10.1016/j.cels.2018.05.021</pub-id><pub-id pub-id-type="pmid">29936185</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC35">
      <mixed-citation publication-type="journal"><string-name><surname>Prjibelski</surname><given-names>A</given-names></string-name>, <string-name><surname>Antipov</surname><given-names>D</given-names></string-name>, <string-name><surname>Meleshko</surname><given-names>D</given-names></string-name>, <string-name><surname>Lapidus</surname><given-names>A</given-names></string-name>, <string-name><surname>Korobeynikov</surname><given-names>A</given-names></string-name>. <year>2020</year>. <article-title>Using SPAdes de novo assembler</article-title>. <source>Curr Protoc Bioinform</source><volume>70</volume>: <fpage>e102</fpage>. <pub-id pub-id-type="doi">10.1002/cpbi.102</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC36">
      <mixed-citation publication-type="journal"><string-name><surname>Putze</surname><given-names>F</given-names></string-name>, <string-name><surname>Sanders</surname><given-names>P</given-names></string-name>, <string-name><surname>Singler</surname><given-names>J</given-names></string-name>. <year>2010</year>. <article-title>Cache-, hash-, and space-efficient bloom filters</article-title>. <source>ACM J Exp Algorithmics</source><volume>14</volume>: <fpage>4.4</fpage>–<lpage>4.18</lpage>. <pub-id pub-id-type="doi">10.1145/1498698.1594230</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC37">
      <mixed-citation publication-type="journal"><string-name><surname>Rahman</surname><given-names>A</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P</given-names></string-name>. <year>2021</year>. <article-title>Representation of <italic>k</italic>-mer sets using spectrum-preserving string sets</article-title>. <source>J Comput Biol</source><volume>28</volume>: <fpage>381</fpage>–<lpage>394</lpage>. <pub-id pub-id-type="doi">10.1089/cmb.2020.0431</pub-id><pub-id pub-id-type="pmid">33290137</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC38">
      <mixed-citation publication-type="journal"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hayes</surname><given-names>W</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name>, <string-name><surname>Mount</surname><given-names>SM</given-names></string-name>, <string-name><surname>Yorke</surname><given-names>JA</given-names></string-name>. <year>2004</year>. <article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source><volume>20</volume>: <fpage>3363</fpage>–<lpage>3369</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/bth408</pub-id><pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC39">
      <mixed-citation publication-type="journal"><string-name><surname>Robertson</surname><given-names>G</given-names></string-name>, <string-name><surname>Schein</surname><given-names>J</given-names></string-name>, <string-name><surname>Chiu</surname><given-names>R</given-names></string-name>, <string-name><surname>Corbett</surname><given-names>R</given-names></string-name>, <string-name><surname>Field</surname><given-names>M</given-names></string-name>, <string-name><surname>Jackman</surname><given-names>SD</given-names></string-name>, <string-name><surname>Mungall</surname><given-names>K</given-names></string-name>, <string-name><surname>Lee</surname><given-names>S</given-names></string-name>, <string-name><surname>Okada</surname><given-names>HM</given-names></string-name>, <string-name><surname>Qian</surname><given-names>JQ</given-names></string-name>, <etal/><year>2010</year>. <article-title><italic>De novo</italic> assembly and analysis of RNA-seq data</article-title>. <source>Nat Methods</source><volume>7</volume>: <fpage>909</fpage>–<lpage>912</lpage>. <pub-id pub-id-type="doi">10.1038/nmeth.1517</pub-id><pub-id pub-id-type="pmid">20935650</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC40">
      <mixed-citation publication-type="journal"><string-name><surname>Ruan</surname><given-names>J</given-names></string-name>, <string-name><surname>Li</surname><given-names>H</given-names></string-name>. <year>2020</year>. <article-title>Fast and accurate long-read assembly with wtdbg2</article-title>. <source>Nat Methods</source><volume>17</volume>: <fpage>155</fpage>–<lpage>158</lpage>. <pub-id pub-id-type="doi">10.1038/s41592-019-0669-3</pub-id><pub-id pub-id-type="pmid">31819265</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC41">
      <mixed-citation publication-type="journal"><string-name><surname>Salmela</surname><given-names>L</given-names></string-name>, <string-name><surname>Rivals</surname><given-names>E</given-names></string-name>. <year>2014</year>. <article-title>LoRDEC: accurate and efficient long read error correction</article-title>. <source>Bioinformatics</source><volume>30</volume>: <fpage>3506</fpage>–<lpage>3514</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btu538</pub-id><pub-id pub-id-type="pmid">25165095</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC42">
      <mixed-citation publication-type="confproc"><string-name><surname>Schmidt</surname><given-names>S</given-names></string-name>, <string-name><surname>Alanko</surname><given-names>JN</given-names></string-name>. <year>2022</year>. <article-title>Eulertigs: minimum plain text representation of <italic>k</italic>-mer sets without repetitions in linear time</article-title>. In <conf-name>22nd International Workshop on Algorithms in Bioinformatics, WABI 2022, Vol. 242 of LIPIcs</conf-name> (ed. <string-name><surname>Boucher</surname><given-names>C</given-names></string-name>, <string-name><surname>Rahmann</surname><given-names>S</given-names></string-name>), pp. <fpage>2:1</fpage>–<lpage>2:21</lpage>. <publisher-name>Leibniz-Zentrum für Informatik, Schloss Dagstuhl</publisher-name>, <publisher-loc>Wadern, Germany</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR277615CRAC43">
      <mixed-citation publication-type="journal"><string-name><surname>Schmidt</surname><given-names>S</given-names></string-name>, <string-name><surname>Khan</surname><given-names>S</given-names></string-name>, <string-name><surname>Alanko</surname><given-names>J</given-names></string-name>, <string-name><surname>Pibiri</surname><given-names>GE</given-names></string-name>, <string-name><surname>Tomescu</surname><given-names>AI</given-names></string-name>. <year>2023</year>. <article-title>Matchtigs: minimum plain text representation of <italic>k</italic>-mer sets</article-title>. <source>Genome Biol</source><volume>24</volume>: <fpage>136</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-023-02968-z</pub-id><pub-id pub-id-type="pmid">37296461</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC44">
      <mixed-citation publication-type="book"><string-name><surname>Zekic</surname><given-names>T</given-names></string-name>, <string-name><surname>Holley</surname><given-names>G</given-names></string-name>, <string-name><surname>Stoye</surname><given-names>J</given-names></string-name>. <year>2018</year>. <part-title>Pan-genome storage and analysis techniques</part-title>. In <source>Comparative genomics: methods in molecular biology</source> (ed. <string-name><surname>Setubal</surname><given-names>J</given-names></string-name>
<etal/>), Vol. <volume>1704</volume>, pp. <fpage>29</fpage>–<lpage>53</lpage>. <publisher-name>Humana Press</publisher-name>, <publisher-loc>New York</publisher-loc>.<pub-id pub-id-type="pmid">29277862</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC45">
      <mixed-citation publication-type="journal"><string-name><surname>Zhou</surname><given-names>Z</given-names></string-name>, <string-name><surname>Alikhan</surname><given-names>NF</given-names></string-name>, <string-name><surname>Mohamed</surname><given-names>K</given-names></string-name>, <string-name><surname>Fan</surname><given-names>Y</given-names></string-name>, <string-name><surname>Achtman</surname><given-names>M</given-names></string-name>. <year>2020</year>. <article-title>The EnteroBase user's guide, with case studies on <italic>Salmonella</italic> transmissions, <italic>Yersinia pestis</italic> phylogeny, and <italic>Escherichia</italic> core genomic diversity</article-title>. <source>Genome Res</source><volume>30</volume>: <fpage>138</fpage>–<lpage>152</lpage>. <pub-id pub-id-type="doi">10.1101/gr.251678.119</pub-id><pub-id pub-id-type="pmid">31809257</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.0 20120330//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genome Res</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genome Res</journal-id>
    <journal-id journal-id-type="hwp">genome</journal-id>
    <journal-id journal-id-type="publisher-id">GENOME</journal-id>
    <journal-title-group>
      <journal-title>Genome Research</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1088-9051</issn>
    <issn pub-type="epub">1549-5469</issn>
    <publisher>
      <publisher-name>Cold Spring Harbor Laboratory Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10538363</article-id>
    <article-id pub-id-type="pmid">37253540</article-id>
    <article-id pub-id-type="medline">9509184</article-id>
    <article-id pub-id-type="doi">10.1101/gr.277615.122</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methods</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Extremely fast construction and querying of compacted and colored de Bruijn graphs with GGCAT</article-title>
      <alt-title alt-title-type="left-running">Cracco and Tomescu</alt-title>
      <alt-title alt-title-type="right-running">Constructing compacted de Bruijn graphs with GGCAT</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-6973-995X</contrib-id>
        <name>
          <surname>Cracco</surname>
          <given-names>Andrea</given-names>
        </name>
        <xref rid="af1" ref-type="aff">1</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-5747-8350</contrib-id>
        <name>
          <surname>Tomescu</surname>
          <given-names>Alexandru I.</given-names>
        </name>
        <xref rid="af2" ref-type="aff">2</xref>
      </contrib>
    </contrib-group>
    <aff id="af1"><label>1</label>Department of Computer Science, University of Verona, 37134 Verona, Italy;</aff>
    <aff id="af2"><label>2</label>Department of Computer Science, University of Helsinki, Helsinki 00560, Finland</aff>
    <author-notes>
      <corresp>Corresponding authors: <email>alexandru.tomescu@helsinki.fi</email>, <email>andrea.cracco@univr.it</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <volume>33</volume>
    <issue>7</issue>
    <fpage>1198</fpage>
    <lpage>1207</lpage>
    <history>
      <date date-type="received">
        <day>6</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>16</day>
        <month>5</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>
        <ext-link xlink:href="http://genome.cshlp.org/site/misc/terms.xhtml" ext-link-type="uri">© 2023 Cracco and Tomescu; Published by Cold Spring Harbor Laboratory Press</ext-link>
      </copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This article, published in <italic>Genome Research</italic>, is available under a Creative Commons License (Attribution 4.0 International), as described at <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="1198.pdf"/>
    <abstract>
      <p>Compacted de Bruijn graphs are one of the most fundamental data structures in computational genomics. Colored compacted de Bruijn graphs are a variant built on a <italic>collection</italic> of sequences and associate to each <italic>k</italic>-mer the sequences in which it appears. We present GGCAT, a tool for constructing both types of graphs, based on a new approach merging the <italic>k</italic>-mer counting step with the unitig construction step, as well as on numerous practical optimizations. For compacted de Bruijn graph construction, GGCAT achieves speed-ups of 3× to 21× compared with the state-of-the-art tool Cuttlefish 2. When constructing the colored variant, GGCAT achieves speed-ups of 5× to 39× compared with the state-of-the-art tool BiFrost. Additionally, GGCAT is up to 480× faster than BiFrost for batch sequence queries on colored graphs.</p>
    </abstract>
    <funding-group>
      <award-group id="funding-1">
        <funding-source>
          <institution-wrap>
            <institution>European Research Council (ERC) </institution>
            <institution-id institution-id-type="doi">10.13039/501100000781</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>851093</award-id>
      </award-group>
      <award-group id="funding-2">
        <funding-source>
          <institution-wrap>
            <institution>Academy of Finland </institution>
            <institution-id institution-id-type="doi">10.13039/501100002341</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>322595</award-id>
        <award-id>352821</award-id>
        <award-id>346968</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <p>de Bruijn graphs are one of the most fundamental data structures in computational genomics, appearing in countless applications, for example, assembly and analysis of sequencing data (<xref rid="GR277615CRAC14" ref-type="bibr">Compeau et al. 2011</xref>) or RNA-seq data (<xref rid="GR277615CRAC39" ref-type="bibr">Robertson et al. 2010</xref>), read error correction (<xref rid="GR277615CRAC41" ref-type="bibr">Salmela and Rivals 2014</xref>; <xref rid="GR277615CRAC25" ref-type="bibr">Limasset et al. 2020</xref>), alignment (<xref rid="GR277615CRAC26" ref-type="bibr">Liu et al. 2016</xref>), compression (<xref rid="GR277615CRAC5" ref-type="bibr">Benoit et al. 2015</xref>), and rearrangement detection (<xref rid="GR277615CRAC10" ref-type="bibr">Cameron et al. 2017</xref>), just to name a few. To obtain a de Bruijn graph of order <italic>k</italic> for a multiset of strings (usually sequencing reads, or assembled genomes), for every <italic>k</italic>-mer in the strings, one adds an edge from the node corresponding to its prefix of length <italic>k</italic> − 1 to the node corresponding to its suffix of length <italic>k</italic> − 1. de Bruijn graphs usually also have associated an <italic>abundance</italic> threshold <italic>a</italic> so that edges (and thus nodes) are added only for <italic>k</italic>-mers appearing at least <italic>a</italic> times in the input strings.</p>
  <p>de Bruijn graphs are appealing for several reasons. First, by increasing the abundance threshold, one can have a very simple but effective method of filtering out sequencing errors (i.e., erroneous <italic>k</italic>-mers). Second, having a graph structure allows for a smaller representation of the data in the presence of repeated regions, because equal substrings are represented only once in the graph. Third, by focusing on maximal <italic>nonbranching</italic> paths, that is, maximal paths whose internal nodes have in-degree and out-degree equal to one (also called <italic>maximal unitigs</italic>), one can discover “variation-free” regions.</p>
  <p>Originally, maximal unitigs were introduced for the genome assembly problem; for example, assembly contigs are usually unitigs of a corrected assembly graph (<xref rid="GR277615CRAC16" ref-type="bibr">Drezen et al. 2014</xref>; <xref rid="GR277615CRAC40" ref-type="bibr">Ruan and Li 2020</xref>). However, by replacing each unitig with, for example, an edge labeled with the label of the unitig (label obtained by identifying the overlapping (<italic>k</italic> − 2)-mers), one gets an equivalent graph, but of much smaller size. Such a graph is usually called a <italic>compacted de Bruijn graph</italic>. Because the first and the last <italic>k</italic>-mer of every maximal unitig is a node of the compacted de Bruijn graph, it often suffices to compute only the strings labeling the maximal unitigs of a de Bruijn graph, not the actual graph structure. Moreover, reverse complements need special handling, which we describe in the Methods subsection “Preliminaries.” Many of the applications cited above actually use a compacted graph, owing to its equivalent representation power but significantly smaller size. In fact, if one just wants to represent the <italic>k</italic>-mers of a data set in plain text form, there exist more efficient equivalent representations (<xref rid="GR277615CRAC9" ref-type="bibr">Břinda et al. 2021</xref>; <xref rid="GR277615CRAC37" ref-type="bibr">Rahman and Medvedev 2021</xref>; <xref rid="GR277615CRAC22" ref-type="bibr">Khan et al. 2022</xref>; and, even optimal, <xref rid="GR277615CRAC42" ref-type="bibr">Schmidt and Alanko 2022</xref>; <xref rid="GR277615CRAC43" ref-type="bibr">Schmidt et al. 2023</xref>), but all of these use maximal unitigs as a starting point.</p>
  <p>A popular variant of a de Bruijn graph is the <italic>colored</italic> de Bruijn graph, originally introduced for de novo assembly and genotyping of variants (<xref rid="GR277615CRAC20" ref-type="bibr">Iqbal et al. 2012</xref>). Such a graph is built from a <italic>collection</italic> of data sets, for example, different sequencing data sets or different (full) genome sequences. For every <italic>k</italic>-mer, colored de Bruijn graphs also store the identifiers (<italic>colors</italic>) of the data sets in which the <italic>k</italic>-mer appears. One can think of a colored de Bruijn graph as a compressed representation of the <italic>k</italic>-mers in a <italic>collection</italic> of data sets, but it retains enough information (i.e., the color of every <italic>k</italic>-mer) in order to identify each data set in this combined graph. Later applications include pangenomics (<xref rid="GR277615CRAC44" ref-type="bibr">Zekic et al. 2018</xref>), RNA-seq quantification (<xref rid="GR277615CRAC8" ref-type="bibr">Bray et al. 2016</xref>), bacterial genome querying (<xref rid="GR277615CRAC27" ref-type="bibr">Luhmann et al. 2021</xref>), alignment and reference-free phylogenomics (<xref rid="GR277615CRAC44" ref-type="bibr">Zekic et al. 2018</xref>), and microbiome research (<xref rid="GR277615CRAC17" ref-type="bibr">Dufault-Thompson and Jiang 2022</xref>), just to name a few.</p>
  <p>Although computing the maximal unitigs of a de Bruijn graph can be performed with a simple linear-time algorithm, the practical hardness of the problem stems from the fact that the initial de Bruijn graph does not fit the main memory in applications. Practical tools computing compacted de Bruijn graphs have to cleverly use the disk to store intermediary data, partition the data in order to use many CPU cores efficiently, and minimize CPU, RAM, and I/O bottlenecks. One of the first major tools for computing maximal unitigs was BCALM2 (<xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. 2016</xref>). BCALM2 first does a <italic>k</italic>-mer counting step inspired by KMC2 (<xref rid="GR277615CRAC15" ref-type="bibr">Deorowicz et al. 2015</xref>) and a filtering pass based on the multiplicity of the <italic>k</italic>-mers. Then it finds <italic>k</italic>-mers that should be joined together by bucketing them on their left/right minimizers (corresponding to the minimizers of the leftmost and rightmost (<italic>k</italic> − 1)-mers) (<xref rid="GR277615CRAC38" ref-type="bibr">Roberts et al. 2004</xref>). Each bucket is processed independently and in parallel to find all the possible extensions. Finally, BCALM2 glues all the unitigs that were produced in different buckets together using a union-find data structure.</p>
  <p>The state-of-the-art tool for maximal unitig computation is Cuttlefish 2 (<xref rid="GR277615CRAC22" ref-type="bibr">Khan et al. 2022</xref>). It starts with an initial <italic>k</italic>-mer counting step using KMC3 (<xref rid="GR277615CRAC23" ref-type="bibr">Kokot et al. 2017</xref>). It uses a perfect hash computation on the <italic>k</italic>-mers using BBHash (<xref rid="GR277615CRAC24" ref-type="bibr">Limasset et al. 2017</xref>). The key insight relies on a novel automaton-based approach to compute the branching state of every (<italic>k</italic> − 1)-mer, using only the minimum amount of information, that is, zero, one, or more than one left/right neighbors. Then, it builds the graph by looking at the automaton of every (<italic>k</italic> − 1)-mer, extending the unitig if the current (<italic>k</italic> − 1)-mer does not branch forward and the following (<italic>k</italic> − 1)-mer does not branch backward. Cuttlefish 2 tends to significantly write to disk to further resplit the intermediate buckets and keep the maximum memory usage low. Like BCALM2, it also does not compress the buckets on disk (except for prefix collapsing), and thus, very repetitive data sets still require large disk I/O. Moreover, for higher <italic>k</italic> values, KMC3 tends to use more time and memory, as it has to store the exact <italic>k</italic>-mers all the time, which, in consequence, also affects the behavior of Cuttlefish 2.</p>
  <p>The state-of-the-art tool for maximal unitig computation with associated color information is BiFrost (<xref rid="GR277615CRAC19" ref-type="bibr">Holley and Melsted 2020</xref>). It uses an in-memory only approach, with various blocked Bloom filters (<xref rid="GR277615CRAC7" ref-type="bibr">Bloom 1970</xref>; <xref rid="GR277615CRAC36" ref-type="bibr">Putze et al. 2010</xref>) partially indexed by minimizers that approximate the <italic>k</italic>-mers present in the final graph, and does several passes on the original input to remove the false edges wrongly created owing to the use of Bloom filters. Then it internally stores the <italic>k</italic>-mers grouped by minimizers, allowing for relatively fast deletions and insertions of new <italic>k</italic>-mers. However, although blocked Bloom filters are very memory efficient, they are not very cache efficient, even with the infra-block sse2 optimizations performed in BiFrost. Also, the memory representation of the <italic>k</italic>-mers gives a trade-off between the ease of doing small updates to the graph and the speed of inserting batches of <italic>k</italic>-mers; thus, the build time of the graph is still considerably high. To (optionally) build a colored graph, it uses various types of compressed bitmaps (roaring or simple bitsets) (<xref rid="GR277615CRAC11" ref-type="bibr">Chambi et al. 2016</xref>) to store the set of colors of each <italic>k</italic>-mer. Although this allows fast insertions and querying, it stores redundant color sets information because <italic>k</italic>-mers that share the same set of colors are still encoded as two separate sets. We refer the reader to Section 7.5 of the survey (<xref rid="GR277615CRAC13" ref-type="bibr">Chikhi et al. 2022</xref>) for other data structures for representing colored de Bruijn graphs.</p>
  <p>In this paper, we present GGCAT, a software tool for efficient construction of compacted, and optionally colored, de Bruijn graphs, both in terms of running time and of memory usage; GGCAT also supports batched <italic>k</italic>-mer queries against a (colored) de Bruijn graph. In all these tasks, GGCAT is faster by at least an order of magnitude than the state-of-the-art tools.</p>
  <sec sec-type="results" id="s1">
    <title>Results</title>
    <sec id="s1a">
      <title>GGCAT overview</title>
      <p>We propose a new tool for constructing compacted, and optionally colored, de Bruijn graphs, GGCAT. As opposed to BCALM2 and Cuttlefish 2, the first idea of GGCAT is to merge the <italic>k</italic>-mer counting step with unitig construction by adding a little more “context” information, which allows us to compute valid global unitigs inside each bucket that the input is split into. This avoids the storage of every single <italic>k</italic>-mer, because only unitigs built inside the buckets are written to disk. Moreover, as opposed to other tools, these unitigs are lz4-compressed before writing to disk, which allows for a substantial reduction in disk usage for highly repetitive data sets. Second, we avoid a union-find data structure (used by BCALM2) with a new joining step across buckets that guarantees exact results with very low <italic>expected</italic> running time. Third, we devise a parallelization pipeline that divides the algorithm into smaller execution units (e.g., reading from disk, <italic>k</italic>-mer counting, <italic>k</italic>-mer extension), thus preventing core stalling owing to waiting for data and thus lowering the dependence on the speed of the RAM.</p>
      <p>On the theoretical side, we give a string-based definition of maximal unitig in the presence of reverse complements (<italic>canonical maximal unitig</italic>; <xref rid="st1" ref-type="statement">Definition 1</xref>) that (1) allows us to avoid introducing a heavy formalism based on, for example, bidirected de Bruijn graphs and (2) closely mimics our algorithm, thus leading to a simple proof of correctness. Moreover, because our unitigs are in an edge-centric graph, in the <xref rid="SD2" ref-type="supplementary-material">Supplemental Methods</xref> (see also <xref rid="SD2" ref-type="supplementary-material">Supplemental Figs. S1, S2</xref>), we prove that they are equivalent to node-centric unitigs in a node-centric graph, as used by, for example, BCALM2 (which we also confirm experimentally) (<xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. 2016</xref>), a result that we did not find in the literature and may be of independent interest.</p>
      <p>For colored graphs, we extend our algorithm above with an approach inspired by BiFrost but with several optimizations that allow comparable color map sizes with substantially improved build times. The main difference from BiFrost is that, instead of using an individual (compressed) color bitmap for each possible <italic>k</italic>-mer, GGCAT maps each color set to a <italic>color set index</italic>, an approach similar to, for example, <xref rid="GR277615CRAC3" ref-type="bibr">Almodaresi et al. (2017)</xref>, <xref rid="GR277615CRAC34" ref-type="bibr">Pandey et al. (2018)</xref>, and <xref rid="GR277615CRAC28" ref-type="bibr">Mäklin et al. (2021)</xref>. Moreover, to store each color set, we compute the difference between consecutive colors and compress them using a run-length encoding. Finally, when storing to disk, the color set indices of the consecutive <italic>k</italic>-mers of each unitig are also run-length encoded. This strategy proves efficient because unitigs are “variation-free” and thus usually have few color set indices associated to their <italic>k</italic>-mers. Because Cuttlefish 2 is significantly faster than BiFrost (on noncolored graphs), these ideas, combined with our improvements over Cuttlefish 2, lead to a major speed up over BiFrost for colored graphs.</p>
      <p>Similar to BiFrost (<xref rid="GR277615CRAC19" ref-type="bibr">Holley and Melsted 2020</xref>), GGCAT also supports querying the produced colored graph against batch input sequence queries. More precisely, for every query sequence in the uncolored case, we need to return the numbers (equivalently, percentage) of <italic>k</italic>-mers of the sequence that also appear in the entire target graph. In the colored case, for every color <italic>c</italic>, we need to return the number of <italic>k</italic>-mers of the query sequence matching <italic>k</italic>-mers of the graph that are colored with <italic>c</italic>. In practice, we need to query many input sequences at the same time (e.g., a FASTA file). GGCAT solves both types of batch queries by an approach very similar to the graph construction steps.</p>
      <p>For <italic>k</italic> ≤ 64, GGCAT represents <italic>k</italic>-mers exactly. However, in some applications, larger values of <italic>k</italic> are needed. For example, for longer Illumina reads, the latest version of the SPAdes assembler (<xref rid="GR277615CRAC35" ref-type="bibr">Prjibelski et al. 2020</xref>) recommends also <italic>k</italic> ∈ {77, 99, 127}. For long HiFi reads, the LJA assembler (<xref rid="GR277615CRAC4" ref-type="bibr">Bankevich et al. 2022</xref>) uses values of <italic>k</italic> up to 5001. For comparing microbial genomes, the synteny block finder Sibelia (<xref rid="GR277615CRAC31" ref-type="bibr">Minkin et al. 2013</xref>) uses <italic>k</italic> up to 5000. To support values larger than 64, GGCAT uses a nonbijective 128-bit Rabin–Karp hash function to represent each <italic>k</italic>-mer (where each of the four bases is represented by a different prime number) to avoid storing it in full length. In extremely rare cases, it can lead to some collisions in hash values that can cause unwanted joining of some unitigs or extra splittings of a maximal unitig. GGCAT can detect (but not correct) most of the collisions, warning the user if some errors can be expected in the graph. In all the tested data sets with <italic>k</italic> &gt; 64, we found no occurrence of a hash collision.</p>
      <p>GGCAT is written in Rust, and it is usable either as a stand-alone command line tool or with an API that supports both building and querying. The API is callable and supported in both Rust and C++ to allow easy integration with other tools. For example, the GGCAT C++ API for colored graph construction has already been successfully integrated by the Themisto pseudoalignment tool v3 (<xref rid="GR277615CRAC2" ref-type="bibr">Alanko et al. 2023</xref>). When used as part of a pipeline to characterize pathogen competition and colonization dynamics in a longitudinal cohort of neonatal gut microbiomes (<xref rid="GR277615CRAC29" ref-type="bibr">Mäklin et al. 2022</xref>), Themisto index construction using GGCAT is seven times faster than in v2.1 of Themisto (<xref rid="GR277615CRAC28" ref-type="bibr">Mäklin et al. 2021</xref>; T. Mäklin, pers. comm.).</p>
      <p>Finally, GGCAT also integrates the matchtig (<xref rid="GR277615CRAC43" ref-type="bibr">Schmidt et al. 2023</xref>) and eulertig (<xref rid="GR277615CRAC42" ref-type="bibr">Schmidt and Alanko 2022</xref>) Rust libraries, thus (optionally) computing also minimum plain-text representations of the set of <italic>k</italic>-mers of the input FASTA files.</p>
    </sec>
    <sec id="s1b">
      <title>Tested tools, data sets, and hardware</title>
      <p>To compute compacted de Bruijn graphs, we chose to compare only against Cuttlefish 2, because the article introducing it (<xref rid="GR277615CRAC22" ref-type="bibr">Khan et al. 2022</xref>) showed that it significantly outperforms popular tools such as BCALM2 (<xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. 2016</xref>) and BiFrost (in its noncolored variant) (<xref rid="GR277615CRAC19" ref-type="bibr">Holley and Melsted 2020</xref>) or other tools such as deGSM (<xref rid="GR277615CRAC18" ref-type="bibr">Guo et al. 2021</xref>). To compute colored de Bruijn graphs, we chose to compare only against BiFrost, because the article introducing it (<xref rid="GR277615CRAC19" ref-type="bibr">Holley and Melsted 2020</xref>) showed that it significantly outperforms popular tools such as VARI-merge (<xref rid="GR277615CRAC33" ref-type="bibr">Muggli et al. 2019</xref>). We decided to not compare against Cuttlefish (<xref rid="GR277615CRAC21" ref-type="bibr">Khan and Patro 2021</xref>) for colored graphs because it adopts a different convention for colors (each unitig can have only one subset of colors) and does not support querying the resulting graph. We run all tools in their default settings (for the commands used, see <xref rid="SD2" ref-type="supplementary-material">Supplemental Methods</xref>).</p>
      <p>For the uncolored case, we use an Illumina whole-genome sequencing Human read data set, a Human gut microbiome read data set, 309,000 (309 K) <italic>Salmonella</italic> genome sequences, and 649,000 (649 K) Bacterial genomes. For the colored case, we use 100 Human genome sequences, 100,000 (100 K) <italic>Salmonella</italic> sequences from the full 309 K <italic>Salmonella</italic> data set (to save computational resources), and all Bacterial genomes. See the section “Software availability” for accession details and <xref rid="GR277615CRATB1" ref-type="table">Table 1</xref> for structural characteristics of these data sets. For the read data sets, we use an abundance threshold of two, and for the genome reference data sets, we use an abundance threshold of one. For a sanity check, we checked that for GGCAT the maximal canonical unitigs are exactly equivalent to the ones produced by BCALM2, for the uncolored graphs produced from 1000 <italic>Salmonella</italic> genomes, and from the Human read data set.</p>
      <table-wrap position="float" id="GR277615CRATB1">
        <label>Table 1.</label>
        <caption>
          <p>Data set statistics with various values of <italic>k</italic></p>
        </caption>
        <graphic xlink:href="1198tb01" position="float"/>
      </table-wrap>
      <p>We ran the experiments on three servers of increasing power: a <italic>small</italic> server with an AMD Ryzen 5 3600 six-core CPU, 64 GB RAM, and a RAID 0 with two 7200 RPM HDDs; a <italic>medium</italic> server with an AMD Ryzen Threadripper PRO 3975WX 32-core CPU, 512 GB RAM, and a RAID 5 7200 RPM HDD; and a <italic>large</italic> server with two AMD EPYC 7H12 64-core CPUs, 2 TB RAM, and a SATA SSD.</p>
    </sec>
    <sec id="s1c">
      <title>Construction results</title>
      <p>In the uncolored case, for the Human read data set, we run two realistic values of <italic>k</italic>, 27 and 63. On the other three data sets used in the uncolored case, we tested the behavior for larger <italic>k</italic> values, where the graphs still remain complex: for gut microbiome reads, <italic>k</italic> = 119, and for the 309 K <italic>Salmonella</italic> genomes and 649 K Bacterial genomes, <italic>k</italic> ∈ {119, 255}. To save computational resources, we did not run Cuttlefish 2 for the latter data set for larger <italic>k</italic> values because the tool does not scale. We show the results in <xref rid="GR277615CRATB2" ref-type="table">Table 2</xref>.</p>
      <table-wrap position="float" id="GR277615CRATB2">
        <label>Table 2.</label>
        <caption>
          <p>Uncolored construction, wall clock time, memory usage (in parentheses) and maximum disk usage including the size of the output files (in square brackets)</p>
        </caption>
        <graphic xlink:href="1198tb02" position="float"/>
      </table-wrap>
      <p>For Human reads and <italic>k</italic> = 27, GGCAT has a similar performance as Cuttlefish 2. However, for larger <italic>k</italic> values and on the other three larger data sets, GGCAT outperforms Cuttlefish 2 in terms of speed by up to 4.3× for <italic>k</italic> ≤ 63. The main speed improvements come from our new approach that merges the <italic>k</italic>-mer counting and unitig building steps into one unified step, which proves most useful for larger <italic>k</italic> values. For larger <italic>k</italic> values (119 and 255), GGCAT is faster than Cuttlefish 2 by up to 20.8×. (Notice also that, as opposed to GGCAT, Cuttlefish 2 does not support <italic>k</italic> values larger than 255.) Despite this, in all cases, GGCAT has an overall memory usage in the same order of magnitude as Cuttlefish 2 or one even substantially lower in the complex Bacterial genomes data set.</p>
      <p>We also tested the scalability of GGCAT by computing the uncolored graph of an increasing number of <italic>Salmonella</italic> genomes (see <xref rid="SD2" ref-type="supplementary-material">Supplemental Fig. S3</xref>), the results showing a linear relation between the number of genomes and the running time.</p>
      <p>The colored construction results are in <xref rid="GR277615CRATB3" ref-type="table">Table 3</xref>. Compared with BiFrost, in the first data set GGCAT is 5.1× faster for <italic>k</italic> = 27 and 4.6× faster for <italic>k</italic> = 63. For the <italic>Salmonella</italic> genomes, for <italic>k</italic> = 27, GGCAT is 33.3× faster than BiFrost, and for <italic>k</italic> = 63, GGCAT is 39.3× faster than BiFrost. For <italic>k</italic> = 27, BiFrost crashed, whereas for <italic>k</italic> = 63, we stopped its run after 10 d to save computational resources. Instead, GGCAT completed both cases in under 14 h. The memory used by GGCAT in the colored construction tests is from 3.7× to 12× less than BiFrost, but this is not directly comparable because GGCAT uses disk intermediate storage and BiFrost uses a fully in-memory algorithm. Moreover, in <xref rid="SD2" ref-type="supplementary-material">Supplemental Table S1</xref>, we measure the size of the color index constructed by GGCAT and BiFrost (i.e., the set of colors of each <italic>k</italic>-mer). In the tested data sets, GGCAT's index is from 20 to two times smaller than that of BiFrost.</p>
      <table-wrap position="float" id="GR277615CRATB3">
        <label>Table 3.</label>
        <caption>
          <p>Colored construction, wall clock time, memory usage (in parentheses), and the total maximum disk space including the size of the output files (in square brackets), using 16 threads</p>
        </caption>
        <graphic xlink:href="1198tb03" position="float"/>
      </table-wrap>
      <p>Depending on the characteristics of the data set, the available disk space for temporary files should be from 2× to 7× the size of the input, whereas the main memory for uncolored construction should be at least 16 GB for medium-sized genome collections and 32 GB for large ones (GGCAT usually consumes significantly less memory than these amounts but can consume more if inputs with particular characteristics are passed to it). For uncolored construction, an empirical way to have a rough estimation of the size of the needed main memory is by dividing the input size by 30.</p>
    </sec>
    <sec id="s1d">
      <title>Colored querying results</title>
      <p>To test querying, we used the colored graphs of 100 Human genomes for <italic>k</italic> ∈ {27, 63} produced in the previous test, and queried them (cold runs) using 4 million 250-bp sequencing reads from the first data set of Human reads (first 4 million sequences from the <monospace>D3_S1_L001_R1_008.fastq.gz</monospace> file of the Human genome data set). Results (in <xref rid="GR277615CRATB4" ref-type="table">Table 4</xref>) show that GGCAT outperformed BiFrost by 83.6× for <italic>k</italic> = 63, whereas for <italic>k</italic> = 27, GGCAT was more than 480× faster than BiFrost. This significant improvement is because we implement querying as a natural extension of the unitig construction step, thus benefiting from all its optimizations.</p>
      <table-wrap position="float" id="GR277615CRATB4">
        <label>Table 4.</label>
        <caption>
          <p>Querying in the colored graph of 100 Human genomes, wall clock time, and memory usage, using 16 threads on the <italic>large</italic> server</p>
        </caption>
        <graphic xlink:href="1198tb04" position="float"/>
      </table-wrap>
    </sec>
  </sec>
  <sec sec-type="discussion" id="s2">
    <title>Discussion</title>
    <p>Computing a compacted de Bruijn graph (and optionally colored) is one of the most fundamental problems in computational genomics, with a long history of computational tools developed for this problem. GGCAT pushes the boundary not only in terms of a highly efficient implementation based on both novel algorithmic aspects (e.g., combining <italic>k</italic>-mer counting with unitig construction, and a new strategy of joining partial unitig across buckets) but also in terms of an efficient parallelization pipeline minimizing idle CPU cores and disk I/O bottlenecks, or further optimizations such as lz4-compression of data written to disk. GGCAT reduces sequence queries to an approach similar to graph construction, thus benefiting from its highly optimized architecture.</p>
    <p>Overall, this leads to a several times improvement over Cuttlefish 2 (and even bigger for larger <italic>k</italic> values) and a two orders of magnitude improvement over BiFrost for colored construction and querying. GGCAT can thus have a significant impact in all downstream analyses that require computing a compacted de Bruijn graph.</p>
    <p>One algorithmic limitation of GGCAT is that it is not optimized for very small values of <italic>k</italic> (i.e., <italic>k</italic> &lt; 15). Moreover, like most disk-based de Bruijn construction tools, GGCAT's performance significantly depends on the disk and RAM speed. Thus, an NVME disk and a fast RAM are heavily preferred. GGCAT scales well in terms of number of threads, so for practical purposes, we recommend a CPU with at least eight cores/16 threads. Moreover, our experiments show that the suggestions above are valid for all the data sets we tested, that is, reads or references of small or large genomes, for both colored and uncolored construction. As future work, it would also be useful to extend GGCAT to support online updates, meaning updating the compacted colored de Bruijn graph with multiple small sets of reads or genomes while being able to query the graph between the updates.</p>
  </sec>
  <sec sec-type="methods" id="s3">
    <title>Methods</title>
    <sec id="s3a">
      <title>Preliminaries</title>
      <p>In this paper, all strings are over the same alphabet Σ = {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>}. We denote concatenation of two strings <italic>x</italic> and <italic>y</italic> as <italic>x</italic> · <italic>y</italic>. If <italic>x</italic> is a substring of <italic>y</italic>, we write <italic>x</italic> ∈ <italic>y</italic>. We denote the length of a string <italic>x</italic> as |<italic>x</italic>|. Given a string <italic>x</italic> of length at least <italic>k</italic>, we denote by pre<sub><italic>k</italic></sub>(<italic>x</italic>) the prefix of <italic>x</italic> of length <italic>k</italic>; by suf<sub><italic>k</italic></sub>(<italic>x</italic>), the suffix of <italic>x</italic> of length <italic>k</italic>. For two strings <italic>x</italic> and <italic>y</italic> such that suf<sub><italic>k</italic></sub>(<italic>x</italic>) = pre<sub><italic>k</italic></sub>(<italic>y</italic>), we denote by <inline-formula id="il1"><mml:math id="IL1" display="inline" overflow="scroll"><mml:mi>x</mml:mi><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mi>y</mml:mi></mml:math></inline-formula> the string <italic>x</italic> · suf<sub>|<italic>y</italic>|−<italic>k</italic></sub>(<italic>y</italic>) (the <italic>merge</italic> of <italic>x</italic> and <italic>y</italic>). Given a set or multiset <italic>R</italic> of strings, we denote ends<sub><italic>k</italic></sub>(<italic>R</italic>) = {pre<sub><italic>k</italic></sub>(<italic>x</italic>), suf<sub><italic>k</italic></sub>(<italic>x</italic>):<italic>x</italic> ∈ <italic>R</italic>}.</p>
      <p>A <italic>k-mer</italic> is a string of a given length <italic>k</italic> over the alphabet Σ. Given a <italic>k</italic>-mer <italic>q</italic>, we say that <italic>q</italic> is a <italic>k</italic>-mer of a string <italic>x</italic> if <italic>q</italic> ∈ <italic>x</italic> (in this case, we also say that <italic>q appears</italic>, or <italic>occurs</italic>, in <italic>x</italic>). Given a set or a multiset <italic>R</italic> of strings, we say that <italic>q appears</italic> in <italic>R</italic>, and write <italic>q</italic> ∈ <italic>R</italic> if <italic>q</italic> appears in some string in <italic>R</italic>. The <italic>edge-centric</italic> de Bruijn graph or order <italic>k</italic> of a multiset <italic>R</italic> of strings is defined as the directed graph having as nodes the (<italic>k</italic> − 1)-mers appearing in <italic>R</italic>, where we add an edge from a node <italic>x</italic> to a node <italic>y</italic> if suf<sub><italic>k</italic>−2</sub>(<italic>x</italic>) = pre<sub><italic>k</italic>−2</sub>(<italic>y</italic>) and <inline-formula id="il2"><mml:math id="IL2" display="inline" overflow="scroll"><mml:mi>x</mml:mi><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:math></inline-formula>. That is, the set of edges is exactly the set of all <italic>k</italic>-mers of <italic>R</italic>. In such an edge-centric graph, the <italic>spelling</italic> of a path <italic>P</italic> = (<italic>x</italic><sub>1</sub>, …, <italic>x</italic><sub><italic>t</italic></sub>) is the string <inline-formula id="il3"><mml:math id="IL3" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>⋯</mml:mo><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <p>A <italic>unitig</italic> is defined as a path of the de Bruijn graph of <italic>R</italic> containing at least one edge, such that all the internal nodes of the path (i.e., different from the first and the last) have an in-degree and an out-degree equal to one. In this paper, paths do not repeat nodes, except for possibly the first and the last, in which case we say that the path is a <italic>cycle</italic>. If two cycles <italic>C</italic><sub>1</sub> and <italic>C</italic><sub>2</sub> are such that <italic>C</italic><sub>2</sub> can be obtained from <italic>C</italic><sub>1</sub> by a cyclic shift, then we say that <italic>C</italic><sub>1</sub> and <italic>C</italic><sub>2</sub> are <italic>equivalent</italic>. A <italic>maximal</italic> unitig is one that cannot be extended by one node without losing the property that it is a unitig. We are interested in outputting the <italic>set</italic> of all maximal unitigs of a de Bruijn graph, where for unitigs that are cycles we need to output only one cyclic shift (i.e., in the output, there can be no equivalent cycles). Our definition of unitigs is for edge-centric graphs. For <italic>node-centric de Bruijn graphs</italic>, unitigs need to be defined by imposing an additional condition (see, e.g., <xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. 2016</xref>; <xref rid="GR277615CRAC22" ref-type="bibr">Khan et al. 2022</xref>). To the best of our knowledge, we are not aware of a formal proof of equivalence between these types of unitigs in the two types of graphs. As such, we give this proof in the <xref rid="SD2" ref-type="supplementary-material">Supplemental Methods</xref>.</p>
      <p>For ease of notation, by unitig we will also refer to its <italic>spelling</italic>. Clearly, the first and last node of a unitig different from a cycle must satisfy the condition that <italic>either</italic> its in-degree is different from one or its out-degree is different from one. Note that under this definition, the maximal unitigs form a partition of the edges, that is, of the <italic>k</italic>-mers of <italic>R</italic>.</p>
      <p>For the rest of this paper, we consider an alternative definition of maximal unitigs that does not explicitly use a de Bruijn graph. This has several advantages: It connects to the recent literature on <italic>spectrum preserving string sets</italic> (unitigs being one such type of set) (<xref rid="GR277615CRAC9" ref-type="bibr">Břinda et al. 2021</xref>; <xref rid="GR277615CRAC37" ref-type="bibr">Rahman and Medvedev 2021</xref>; <xref rid="GR277615CRAC43" ref-type="bibr">Schmidt et al. 2023</xref>); it naturally extends to reverse complements without introducing heavy definitions related to bidirected de Bruijn graphs; and, ultimately it matches our algorithm, which proceeds bottom-up by iteratively merging <italic>k</italic>-mers and unitigs as long as possible (i.e., the existence of branches in the de Bruijn graph is checked implicitly via <italic>k</italic>-mer queries).</p>
      <p>Given a multiset <italic>R</italic> of strings, and a string <italic>x</italic>, we denote by occ(<italic>x</italic>, <italic>R</italic>) the number of occurrences of <italic>x</italic> in the strings of <italic>R</italic>, each different occurrence in a same string in <italic>R</italic> being counted individually. Given a string <italic>x</italic> ∈ Σ, we denote by <italic>x</italic><sup>−1</sup> ∈ Σ the reverse complement of <italic>x</italic>. Given a multiset <italic>R</italic> of strings and a string <italic>x</italic>, if <italic>x</italic> ≠ <italic>x</italic><sup>−1</sup>, we define occ<sub>cn</sub>(<italic>x</italic>, <italic>R</italic>) = occ(<italic>x</italic>, <italic>R</italic>) + occ(<italic>x</italic><sup>−1</sup>, <italic>R</italic>); otherwise, occ<sub>cn</sub>(<italic>x</italic>, <italic>R</italic>) = occ(<italic>x</italic>, <italic>R</italic>). We analogously define app(<italic>x</italic>, <italic>R</italic>) = min (1, occ(<italic>x</italic>, <italic>R</italic>)) and app<sub>cn</sub>(<italic>x</italic>, <italic>R</italic>) = min (1, occ<sub>cn</sub>(<italic>x</italic>, <italic>R</italic>)).</p>
      <p>Given multisets of strings <italic>R</italic> and <italic>U</italic>, we say that <italic>R</italic> and <italic>U</italic> have the same <italic>k-mer set</italic> if any <italic>k</italic>-mer that appears in one of the sets also appears in the other set. Analogously, we say that <italic>R</italic> and <italic>U</italic> have the same <italic>canonical k-mer set</italic> if for any <italic>k</italic>-mer <italic>q</italic> that appears in one of the sets, it holds that <italic>q</italic> or <italic>q</italic><sup>−1</sup> appears in the other set. We can equivalently express the fact that sets <italic>R</italic> and <italic>U</italic> have the same noncanonical <italic>k</italic>-mer set with the condition
<disp-formula id="GR277615CRAUM1"><mml:math id="UM1" display="block" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">iff</mml:mi><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1.</mml:mn></mml:math></disp-formula>
Likewise, <italic>R</italic> and <italic>U</italic> have the same <italic>canonical k-mer set</italic> if
<disp-formula id="GR277615CRAUM2"><mml:math id="UM2" display="block" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mrow><mml:mi mathvariant="normal">oc</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">c</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">iff</mml:mi><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">oc</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">c</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1.</mml:mn></mml:math></disp-formula>
We now give an equivalent <italic>string-centric</italic> definition of the <italic>set U</italic> of maximal unitigs of a multiset <italic>R</italic> of strings, under our formalism. As a warm-up, we start with the case when we do not have reverse complements.</p>
      <p>First, we require that all strings in the <italic>set U</italic> have a length of at least <italic>k</italic>, meaning unitigs contain at least one edge. Second, we require that <italic>R</italic> and <italic>U</italic> have the same <italic>k</italic>-mer set. Third, if a (<italic>k</italic> − 1)-mer appears at least two times in <italic>U</italic>, then it cannot be an internal node in any unitig. In other words, we forbid merging two separate unitigs at a branching (<italic>k</italic> − 1)-mer, because such branching (<italic>k</italic> − 1)-mer must appear in at least one other string in <italic>U</italic>:
<disp-formula id="GR277615CRAUM3"><mml:math id="UM3" display="block" overflow="scroll"><mml:mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mml:mtr><mml:mtd/><mml:mtd><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">if</mml:mi><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">then</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mi>q</mml:mi><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">appears</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">only</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">as</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">prefix</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">or</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">suffix</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:mi mathvariant="normal">of</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">strings</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">in</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mi>U</mml:mi><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
Note that the above property also ensures that no two equivalent cyclic unitigs are in <italic>U</italic>.</p>
      <p>To also impose maximality, we state that a (<italic>k</italic> − 1)-mer is a prefix or a suffix of a unitig if and only if it is either branching, a sink, or a source:
<disp-formula id="GR277615CRAUM4"><mml:math id="UM4" display="block" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="normal">end</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mi>U</mml:mi><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:munder><mml:mrow><mml:mo movablelimits="false">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:munder><mml:mspace width="0.2em"/><mml:mrow><mml:mi mathvariant="normal">app</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>⋅</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.4em"/><mml:mrow><mml:mi mathvariant="normal">or</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:mrow><mml:mspace width="0.4em"/></mml:mrow><mml:munder><mml:mrow><mml:mo movablelimits="false">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:munder><mml:mspace width="0.2em"/><mml:mrow><mml:mi mathvariant="normal">app</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>⋅</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mn>1.</mml:mn></mml:math></disp-formula>
 Having defined maximal unitigs without reverse complements, we now give the string-centric definition of maximal unitigs also assuming reverse complements (which we call <italic>canonical maximal unitigs</italic>). In fact, we give a more general one, also handling a required abundance threshold of the <italic>k</italic>-mers in <italic>R</italic>, further underlining the flexibility of our string-centric view.</p>
      <statement id="st1" content-type="definition">
        <label>Definition 1 (canonical maximal unitigs).</label>
        <p><italic>Given a multiset R of strings and integers k</italic> ≥ 2 <italic>and a</italic> ≥ 1<italic>, we say that a</italic> set <italic>U of strings is the set of</italic> canonical maximal unitigs <italic>of R with k-mer size k and abundance threshold a if the following conditions hold:</italic>
<list list-type="order"><list-item><p><inline-formula id="il4"><mml:math id="IL4" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:math></inline-formula><italic>,</italic> |<italic>x</italic>| ≥ <italic>k, and</italic>
<inline-formula id="il5"><mml:math id="IL5" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:math></inline-formula><italic>, x</italic> ≠ <italic>y</italic><sup>−1</sup>
<italic>(note that x</italic> ≠ <italic>y is guaranteed by the fact that U is a set);</italic></p></list-item><list-item><p><inline-formula id="il6"><mml:math id="IL6" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mrow><mml:mi mathvariant="normal">oc</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">c</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mspace width="0.4em"/></mml:mrow><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mi>f</mml:mi><mml:mspace width="0.4em"/><mml:mrow><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">oc</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">c</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula><italic>(same canonical k-mer multiset, with abundances);</italic></p></list-item><list-item><p><inline-formula id="il7"><mml:math id="IL7" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula><italic>, if</italic>  occ<sub>cn</sub>(<italic>q</italic>, <italic>U</italic>) &gt; 1, <italic>then q and q</italic><sup>−1</sup>
<italic>appear only as prefix or suffix of strings in U (unitigs do not span over branching</italic> (<italic>k</italic> − 1)<italic>-mers); and</italic></p></list-item><list-item><p><inline-formula id="il8"><mml:math id="IL8" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mi mathvariant="normal">end</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mi>U</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula><italic>,</italic><inline-formula id="il9"><mml:math id="IL9" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mi mathvariant="normal">ap</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">p</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>⋅</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.4em"/><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mspace width="0.4em"/><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">Σ</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mi mathvariant="normal">ap</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">p</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cn</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo>⋅</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula><italic>(maximality)</italic>.</p></list-item></list></p>
        <p>In our algorithm, we build unitigs incrementally, starting from individual <italic>k</italic>-mers (i.e., individual edges of the de Bruijn graph, which are unitigs) and extending them in both directions, as long as the resulting string remains a unitig (by checking for the satisfaction of Condition 3 in <xref rid="st1" ref-type="statement">Definition 1</xref> at each step, that is, whether we have reached the end of a unitig or not). Even though this is a simple strategy, behind other tools such as that of <xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. (2016)</xref>, it is nontrivial how to implement this efficiently in terms of running time, memory consumption, disk usage, and parallelization.</p>
        <p>Given an integer <italic>m</italic> ≤ <italic>k</italic> and a rolling function hash:Σ<sup><italic>m</italic></sup> → ℤ, the <italic>minimizer</italic> of a <italic>k</italic>-mer <italic>x</italic> is
<disp-formula id="GR277615CRAUM5"><mml:math id="UM5" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="normal">mini</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo form="prefix">min</mml:mo></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>m</mml:mi></mml:msup></mml:mrow><mml:mo>∧</mml:mo><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:munder><mml:mspace width="0.2em"/><mml:mrow><mml:mi mathvariant="normal">hash</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mi>y</mml:mi><mml:mo>)</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula>
Note that in this definition the minimizer is only a hash value and does not keep track of the particular position of the <italic>m</italic>-mer that has that minimum hash value. The <italic>m</italic> parameter is automatically chosen by GGCAT (it can also be user-defined) based on the value of <italic>k</italic>; for the precise function used to compute <italic>m</italic> from <italic>k</italic>, see <xref rid="SD2" ref-type="supplementary-material">Supplemental Table S2</xref>.</p>
        <p>Throughout the algorithm, we will refer to <italic>buckets</italic> as a partition of the data that is stored as a single blob; for example, when stored on disk each bucket corresponds to a file. Multiple buckets are used to partition data in a way that is optimized for parallelization, thereby allowing for parallel and independent processing of each bucket. They are also used to reduce the memory consumption of the algorithm because only the buckets that are currently being processed occupy main memory, whereas the other ones use only disk space.</p>
        <p>In the rest of this section, we present the algorithm for maximal unitigs without reverse complements, and then in the section “Construction correctness,” we explain the changes for canonical maximal unitigs.</p>
      </statement>
    </sec>
    <sec id="s3b">
      <title>Read splitting</title>
      <p>Each read <italic>R</italic><sub><italic>j</italic></sub> is split into substrings <inline-formula id="il10"><mml:math id="IL10" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that overlap on <italic>k</italic> − 2 characters, such that all (<italic>k</italic> − 1)-mers of <italic>S</italic><sub><italic>i</italic></sub> have the same minimizer, for all <italic>i</italic> ∈ {1, …, ℓ<sub><italic>j</italic></sub>}. For the minimizer hash function hash, we use the ntHash (<xref rid="GR277615CRAC32" ref-type="bibr">Mohamadi et al. 2016</xref>) function because it can give fast computation while ensuring good randomness in its value. Note that we can have multiple minimizer locations in the same substring <italic>S</italic><sub><italic>i</italic></sub> as long as they have the same hash value. We can compute <inline-formula id="il11"><mml:math id="IL11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in linear time in the size of <italic>R</italic><sub><italic>j</italic></sub> as follows. First, for every <italic>m</italic>-mer <italic>x</italic> of <italic>R</italic><sub><italic>j</italic></sub>, we compute hash(<italic>x</italic>) in a rolling manner. Then, in a sliding window manner, we compute the minimum of each window of <italic>k</italic> − <italic>m</italic> consecutive <italic>m</italic>-mers (which correspond to a (<italic>k</italic> − 1)-mer). Finally, we group consecutive (<italic>k</italic> − 1)-mers that share the same minimum in their corresponding window. For efficiency, we perform these three steps in a single pass over <italic>R</italic><sub><italic>j</italic></sub>.</p>
      <p>For every <italic>S</italic><sub><italic>i</italic></sub> obtained in this manner, let <italic>a</italic> and <italic>b</italic> be the characters of <italic>R</italic><sub><italic>j</italic></sub> immediately preceding and succeeding <italic>S</italic><sub><italic>i</italic></sub> in <italic>R</italic><sub><italic>j</italic></sub>, respectively, or the character $ if they do not exist. We call <italic>a</italic> and <italic>b linking characters</italic>. Consider the string <inline-formula id="il12"><mml:math id="IL12" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>S</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo>:=</mml:mo><mml:mi>a</mml:mi><mml:mo>⋅</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>⋅</mml:mo><mml:mi>b</mml:mi></mml:math></inline-formula> and observe that <inline-formula id="il13"><mml:math id="IL13" display="inline" overflow="scroll"><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:msubsup></mml:math></inline-formula> and <inline-formula id="il14"><mml:math id="IL14" display="inline" overflow="scroll"><mml:msubsup><mml:mi>S</mml:mi><mml:mi>i</mml:mi><mml:mi mathvariant="normal">′</mml:mi></mml:msubsup></mml:math></inline-formula> have a suffix–prefix overlap of <italic>k</italic> characters, because <italic>S</italic><sub><italic>i</italic>−1</sub> and <italic>S</italic><sub><italic>i</italic></sub> have a suffix–prefix overlap of <italic>k</italic> − 2 characters and we added <italic>b</italic> at the end of <italic>S</italic><sub><italic>i</italic>−1</sub> and <italic>a</italic> at the beginning of <italic>S</italic><sub><italic>i</italic></sub>. For an illustration, see <xref rid="GR277615CRAF1" ref-type="fig">Figure 1</xref>. Recall that all (<italic>k</italic> − 1)-mers of <italic>S</italic><sub><italic>i</italic></sub> have the same minimizer, say <italic>h</italic>; we assign each extended string <inline-formula id="il15"><mml:math id="IL15" display="inline" overflow="scroll"><mml:msubsup><mml:mi>S</mml:mi><mml:mi>i</mml:mi><mml:mi mathvariant="normal">′</mml:mi></mml:msubsup></mml:math></inline-formula> to a <italic>group G</italic><sub><italic>h</italic></sub> associated to such unique minimizer <italic>h</italic>. We say that a <italic>k</italic>-mer <italic>x</italic> appears in a group <italic>G</italic><sub><italic>h</italic></sub> if <italic>x</italic> is a substring of some <inline-formula id="il16"><mml:math id="IL16" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>S</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> in <italic>G</italic><sub><italic>h</italic></sub>.</p>
      <fig position="float" id="GR277615CRAF1">
        <label>Figure 1.</label>
        <caption>
          <p>Illustration of the read splitting step. Read <italic>R</italic><sub><italic>j</italic></sub> is split into substrings <italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>, <italic>S</italic><sub>3</sub> such that all <italic>k</italic>-mers of each <italic>S</italic><sub><italic>i</italic></sub> have the same minimizer, and extra linking characters (in red) are added to each <italic>S</italic><sub><italic>i</italic></sub>. The overlap between two such consecutive extended <italic>S</italic><sub><italic>i</italic></sub>s is of exactly <italic>k</italic> characters.</p>
        </caption>
        <graphic xlink:href="1198f01" position="float"/>
      </fig>
      <p>The above grouping strategy is similar to the one of <xref rid="GR277615CRAC23" ref-type="bibr">Kokot et al. (2017)</xref>, applied to <italic>k</italic>-mers instead of (<italic>k</italic> − 1)-mers (our strings <inline-formula id="il17"><mml:math id="IL17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are called <italic>super</italic> (<italic>k</italic> − 1)<italic>-mers</italic> by <xref rid="GR277615CRAC15" ref-type="bibr">Deorowicz et al. 2015</xref>), with the exception that when we group we add the linking characters. The following simple properties are key to ensuring the correctness of our approach.</p>
      <statement id="st2" content-type="lemma">
        <label>Lemma 1.</label>
        <p><italic>Let x be a k-mer appearing in the reads R, and in a group G</italic><sub><italic>h</italic></sub>. <italic>The following properties hold:</italic><list list-type="alpha-lower"><list-item><p>There is at most one other group in which <italic>x</italic> appears, and moreover, <italic>x</italic> appears in two distinct groups if and only if mini(pre<sub><italic>k</italic>−1</sub>(<italic>x</italic>)) ≠ mini(suf<sub><italic>k</italic>−1</sub>(<italic>x</italic>));</p></list-item><list-item><p>occ(<italic>x</italic>, <italic>G</italic><sub><italic>h</italic></sub>) = occ(<italic>x</italic>, <italic>R</italic>);</p></list-item><list-item><p>If mini(<italic>x</italic>) = <italic>h</italic> (i.e., <italic>x</italic> does not contain a linking character) and it has a (<italic>k</italic> − 1) suffix–prefix overlap with some <italic>k</italic>-mer <italic>y</italic> (in either order), then also <italic>y</italic> appears in group <italic>G</italic><sub><italic>h</italic></sub>.</p></list-item></list></p>
      </statement>
      <statement id="st3" content-type="proof">
        <label>Proof.</label>
        <p>
          <list list-type="alpha-lower">
            <list-item>
              <p>Let <italic>h</italic><sub>1</sub>: = mini(pre<sub><italic>k</italic>−1</sub>(<italic>x</italic>)) and <italic>h</italic><sub>2</sub>: = mini(suf<sub><italic>k</italic>−1</sub>(<italic>x</italic>)). The <italic>k</italic>-mer <italic>x</italic> appears only in groups <inline-formula id="il18"><mml:math id="IL18" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="il19"><mml:math id="IL19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>G</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which two distinct groups if <italic>h</italic><sub>1</sub> ≠ <italic>h</italic><sub>2</sub>.</p>
            </list-item>
            <list-item>
              <p>This follows by construction of the group, because all the <italic>k</italic>-mer occurrences that have the same minimizer are put in the same group.</p>
            </list-item>
            <list-item>
              <p>If the minimizer of <italic>y</italic> is also <italic>h</italic> (i.e., it does not contain a linking character), then <italic>y</italic> also appears in <italic>G</italic><sub><italic>h</italic></sub>. If not, recall that we added an extra character at the beginning and end of every string assigned to <italic>G</italic><sub><italic>h</italic></sub>; thus, <italic>y</italic> is a <italic>k</italic>-mer containing a linking character and thus appears in <italic>G</italic><sub><italic>h</italic></sub>.</p>
            </list-item>
          </list>
        </p>
      </statement>
      <p>Because we want to write the groups to disk and their number is the number of distinct minimizers, we merge the groups into a smaller number of buckets that are written to disk.</p>
    </sec>
    <sec id="s3c">
      <title>Construction of intermediate (nonmaximal) unitigs</title>
      <p><xref rid="st2" ref-type="statement">Lemma 1</xref> ensures that extending any <italic>k</italic>-mer <italic>x</italic> can be correctly performed just by querying the group of <italic>x</italic>.</p>
      <p>For each group, we perform the following:
<list list-type="order"><list-item><p>A <italic>k</italic>-mer counting step of the strings in the group, using a hashmap, while also keeping track if a <italic>k</italic>-mer contains a linking character. More precisely, we scan each string in a group, and for each <italic>k</italic>-mer that we encounter, we increase by one its abundance in the hashmap and add a flag if it contains a linking character.</p></list-item><list-item><p>From the hashmap, we create a list of unique <italic>k</italic>-mers of the group that have the required abundance. This abundance check is correct thanks to <xref rid="st2" ref-type="statement">Lemma 1</xref>(b).</p></list-item><list-item><p>We traverse the list of <italic>k</italic>-mers, and for each nonused <italic>k</italic>-mer <italic>x</italic>, we initialize a string <italic>z</italic>: = <italic>x</italic>, which will be extended right and left as long as it is a unitig (see <xref rid="GR277615CRAF2" ref-type="fig">Figs. 2</xref>, <xref rid="GR277615CRAF3" ref-type="fig">3</xref>). We try to extend <italic>z</italic> to the right by querying the hashmap for suf<sub><italic>k</italic>−1</sub>(<italic>z</italic>) · <italic>c</italic>, for all <italic>c</italic> ∈ {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>}. If there is a unique extension <italic>y</italic> such that suf<sub><italic>k</italic>−1</sub>(<italic>z</italic>) = pre<sub><italic>k</italic>−1</sub>(<italic>y</italic>), then we query the hashmap for <italic>c</italic> · pre<sub><italic>k</italic>−1</sub>(<italic>y</italic>), for all <italic>c</italic> ∈ {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>}. If exactly one match is found (i.e., suf<sub><italic>k</italic></sub>(<italic>z</italic>)), then we replace <italic>z</italic> with <inline-formula id="il20"><mml:math id="IL20" display="inline" overflow="scroll"><mml:mi>z</mml:mi><mml:mrow><mml:msup><mml:mo>⊙</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mi>y</mml:mi></mml:math></inline-formula>, and we mark <italic>k</italic>-mer <italic>y</italic> as used in the hashmap. If <italic>y</italic> is not marked in the hashmap as having a linking character, then we repeat this right extension with the new string <italic>z</italic>. The queries to the hashmap are correct thanks to <xref rid="st2" ref-type="statement">Lemma 1</xref>(c). When we stop the right extension, we perform a symmetric left extension of <italic>z</italic>. After both extensions are completed, the resulting unitig <italic>z</italic> is given a unique index <italic>id</italic><sub><italic>z</italic></sub>. If the extension of <italic>z</italic> was stopped because of a linking character in the first or last <italic>k</italic>-mer <italic>y</italic> of <italic>z</italic>, we add (<italic>y</italic>, <italic>id</italic><sub><italic>z</italic></sub>) to a list <italic>L</italic>.</p></list-item></list>Notice that, after all groups have been processed, for any (<italic>y</italic>, <italic>id</italic><sub><italic>z</italic></sub>) in <italic>L</italic>, there exist exactly one other <inline-formula id="il21"><mml:math id="IL21" display="inline" overflow="scroll"><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:msup><mml:mi>z</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula> in <italic>L</italic>, added from a different group, by <xref rid="st2" ref-type="statement">Lemma 1</xref>(a). These two tuples indicate (nonmaximal) unitigs that have to be iteratively merged to obtain the maximal unitigs.</p>
      <fig position="float" id="GR277615CRAF2">
        <label>Figure 2.</label>
        <caption>
          <p>The extension step of the intermediate unitig construction happens inside each group. For each <italic>k</italic>-mer (<italic>top</italic>), it looks for a possible extension by checking all of the four possible neighbor <italic>k</italic>-mers in both directions and extends the <italic>k</italic>-mer (<italic>bottom</italic>) only if there is exactly one match both forward and backward (depicted in green in the first two figures from the <italic>top</italic>). Then it repeats the same process until no more extensions can be performed.</p>
        </caption>
        <graphic xlink:href="1198f02" position="float"/>
      </fig>
      <fig position="float" id="GR277615CRAF3">
        <label>Figure 3.</label>
        <caption>
          <p>The result of the intermediate unitig construction. Each intermediate unitig that has a possible extension shares an ending with another intermediate unitig.</p>
        </caption>
        <graphic xlink:href="1198f03" position="float"/>
      </fig>
    </sec>
    <sec id="s3d">
      <title>Unitig merging</title>
      <p>The tuples (<italic>y</italic>, <italic>id</italic><sub><italic>z</italic></sub>) in <italic>L</italic> are sorted by <italic>y</italic>, such that the two entries (<italic>y</italic>, <italic>id</italic><sub><italic>z</italic></sub>) and <inline-formula id="il22"><mml:math id="IL22" display="inline" overflow="scroll"><mml:mo>(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:msup><mml:mi>z</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula> appear consecutively. Moreover, for any unitig <italic>z</italic>, there are at most two entries (<italic>x</italic>, <italic>id</italic><sub><italic>z</italic></sub>) and (<italic>y</italic>, <italic>id</italic><sub><italic>z</italic></sub>) in <italic>L</italic> (corresponding to its two end points). From these, we construct a list <inline-formula id="il23"><mml:math id="IL23" display="inline" overflow="scroll"><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>z</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:msup><mml:mi>z</mml:mi><mml:mrow><mml:mi mathvariant="normal">′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula> that is put in another list <italic>P</italic> of pairs of unitig that must be merged into maximal unitigs. This is one of the hardest steps to parallelize, because no partitioning can be performed ahead of time that puts all the unitigs that are contained in a maximal unitig in the same partition. In other tools, for example, BCALM2 (<xref rid="GR277615CRAC12" ref-type="bibr">Chikhi et al. 2016</xref>), this step is performed using a union-find data structure that can be difficult to be used with concurrency. Our solution uses a randomized approach (i.e., with guaranteed correctness and only <italic>expected</italic> running time) to put in the same partition the unitigs that should be merged, repeating the process until all the unitigs are merged into the final maximal unitigs.</p>
      <p>We proceed as follows (see <xref rid="GR277615CRAF4" ref-type="fig">Fig. 4</xref>). We allocate a fixed number of buckets. Initially, for each list in <italic>P</italic>, we mark both its ends as <italic>unsealed</italic>. We repeat the following procedure until <italic>P</italic> is empty:
<list list-type="order"><list-item><p>For each list in <italic>P</italic>, we choose at random one of its unsealed ends. Without loss of generality, let this end be <italic>l</italic>. We put the list in the bucket corresponding to <italic>l</italic>, whereas in the bucket corresponding to the other ending <italic>r</italic>, we put a placeholder.</p></list-item><list-item><p>Inside each bucket, we sort the lists by the ending that caused the list to be placed in the bucket. Then, we merge all the endings that are equal to produce longer lists. If an ending in a bucket is not merged and it has no corresponding placeholder (of another list) in the bucket, then it is marked as <italic>sealed</italic>.</p></list-item><list-item><p>Finally, we remove from <italic>P</italic> each list having both ends sealed.</p></list-item></list>In the above process, given two lists in <italic>P</italic> that must be merged, there is at least a probability of at least 1/4 that they are assigned to the same bucket to be merged (in the worst case, both ends are unsealed). Thus, in expectation, this desired outcome happens only after four tries.</p>
      <fig position="float" id="GR277615CRAF4">
        <label>Figure 4.</label>
        <caption>
          <p>The unitig merging step on the unitigs from <xref rid="GR277615CRAF3" ref-type="fig">Figure 3</xref>. Each pair (ending, unitig index) is sorted by ending, and indexes of unitigs that share the same ending are joined in a tuple. Each such tuple is assigned to a bucket corresponding to one of its unsealed end point indices chosen at random (solid arrows in the figure). For the other end point index of the tuple (dashed arrow), we put a <italic>placeholder</italic> in its corresponding bucket (in gray). Then, inside each bucket, pairs sharing the same unitig index are joined to form larger tuples. If an ending cannot be joined and does not have a corresponding placeholder, then is it marked as sealed and is not selected anymore for bucket assignment. For example, in the first step, in <inline-formula id="il24"><mml:math id="IL24" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> the pair (<italic>id</italic><sub>1</sub>, <italic>id</italic><sub>2</sub>) is sealed at <italic>id</italic><sub>1</sub> because there is no placeholder for <italic>id</italic><sub>1</sub>; however, in <inline-formula id="il25"><mml:math id="IL25" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> the pair (<italic>id</italic><sub>2</sub>, <italic>id</italic><sub>3</sub>) is not sealed at <italic>id</italic><sub>2</sub> because <italic>id</italic><sub>2</sub> has a placeholder. The steps are repeated until no more tuples can be joined. For the noncanonical case, we can merge the pairs if one extremity is at the end and the other one at the beginning of the pairs. For canonical <italic>k</italic>-mers, we also have to keep track of the direction of the <italic>k</italic>-mer before joining them; for more details, see the section “Construction correctness.”</p>
        </caption>
        <graphic xlink:href="1198f04" position="float"/>
      </fig>
      <p>Both <italic>L</italic> and <italic>P</italic> are also stored in buckets to allow a better concurrency while processing them.</p>
    </sec>
    <sec id="s3e">
      <title>Construction correctness</title>
      <p>We start by proving the correctness of the algorithm (without reverse complements).</p>
      <statement id="st4" content-type="theorem">
        <label>Theorem 1.</label>
        <p><italic>Given a multiset R of strings, the strings U obtained at the end of our algorithm are the maximal unitigs of R</italic>.</p>
      </statement>
      <statement id="st5" content-type="proof">
        <label>Proof.</label>
        <p>We prove that <italic>U</italic> satisfied the conditions of <xref rid="st1" ref-type="statement">Definition 1</xref> (for noncanonical unitigs).</p>
        <p>For condition 0, because we start from <italic>k</italic>-mers, all strings in <italic>U</italic> have length at least <italic>k</italic>. To see that <italic>U</italic> is also a <italic>set</italic> (i.e., contains no duplicates), in our algorithm every <italic>k</italic>-mer is considered only once and is assigned to a unique unitig.</p>
        <p>For condition 1, observe that the algorithm does not introduce any <italic>k</italic>-mer that is not also in <italic>R</italic>, and does not exclude any <italic>k</italic>-mer from <italic>R</italic>; thus, <inline-formula id="il26"><mml:math id="IL26" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mtext> </mml:mtext><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mrow><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">iff</mml:mi><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> holds. <xref rid="st2" ref-type="statement">Lemma 1</xref>(b) guarantees that occ(<italic>q</italic>, <italic>R</italic>) the number of occurrences of <italic>k</italic>-mer <italic>q</italic> is the same as the number of occurrences in its group, and thus, the operation from the section “Construction of intermediate (nonmaximal) unitigs” performed inside its group respects its abundance in <italic>R</italic>. Thus, <inline-formula id="il27"><mml:math id="IL27" display="inline" overflow="scroll"><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mtext> </mml:mtext><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mi>a</mml:mi><mml:mrow><mml:mspace width="0.4em"/><mml:mi mathvariant="normal">iff</mml:mi><mml:mspace width="0.4em"/></mml:mrow><mml:mrow><mml:mi mathvariant="normal">occ</mml:mi></mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula>.</p>
        <p>Next, we prove conditions 3 and 2. Given an intermediary unitig <italic>z</italic>, we check for the eight <italic>k</italic>-mers that contain suf<sub><italic>k</italic>−1</sub>(<italic>z</italic>); we extend <italic>z</italic> iff only two <italic>k</italic>-mers appear (one out-going from, and one in-coming to suf<sub><italic>k</italic>−1</sub>(<italic>z</italic>)); thus, condition 3 is satisfied.</p>
        <p>After merging <italic>z</italic> with this out-going <italic>k</italic>-mer, there are no other <italic>k</italic>-mers (and thus no other unitigs in <italic>U</italic> because each <italic>k</italic>-mer appears exactly once in <italic>U</italic>, because in the section “Construction of intermediate (nonmaximal) unitigs” we mark the used <italic>k</italic>-mers) that contain suf<sub><italic>k</italic>−1</sub>(<italic>z</italic>) so condition 2 holds for single groups. This condition is still not satisfied globally, owing to the repetition of all the <italic>k</italic>-mers containing a linking character.</p>
        <p>We now prove condition 2 after the unitig merging step. Note that the unitigs fed to the unitig merging step are the ones that start or end with a linking character, so they always overlap on <italic>k</italic> characters. After merging all the repeated <italic>k</italic>-mers, we satisfy condition 2 globally.</p>
      </statement>
      <p>All the steps described so far can be easily adapted to work with canonical <italic>k</italic>-mers to obtain canonical maximal unitigs (<xref rid="st1" ref-type="statement">Definition 1</xref>). This can be performed by changing two steps. First, the hash functions are replaced by their “canonical” version, such that the hash of a <italic>k</italic>-mer is always equal to the one of its reverse complement. Second, in the unitig merging steps, relative orientations of the unitigs are tracked to allow joining unitigs that can be present in opposite orientations in the input data set, by reverse-complementing one of them.</p>
    </sec>
    <sec id="s3f">
      <title>Coloring</title>
      <p>Computing the colors for each <italic>k</italic>-mer of a de Bruijn graph has two main challenges: (1) tracking all colors that belong to each <italic>k</italic>-mer and (2) storing the colors in a storage- and time-efficient manner.</p>
      <p>To solve these two challenges, we propose a method partially inspired by the way BiFrost handles the colors, but with numerous improvements that allow for a smaller representation and a faster computation. The main idea is to merge color information for <italic>k</italic>-mers that share the same set of colors (see <xref rid="GR277615CRAC3" ref-type="bibr">Almodaresi et al. 2017</xref>; <xref rid="GR277615CRAC34" ref-type="bibr">Pandey et al. 2018</xref>; <xref rid="GR277615CRAC28" ref-type="bibr">Mäklin et al. 2021</xref>), while avoiding costly comparisons of the entire sets for each <italic>k</italic>-mer. More precisely, for each <italic>k</italic>-mer, a normalized list <italic>C</italic> of colors is obtained by tracking the source of each <italic>k</italic>-mer, saving all the colors in a possibly redundant way (e.g., if the <italic>k</italic>-mer appears multiple times in a reference sequence), and then sorting and deduplicating them. From <italic>C</italic>, a 128-bit strong hash <italic>h</italic> is generated and is checked against a global hashmap that maps <italic>h</italic> to a color subset index. If a match is not found, then the list <italic>L</italic> is written to the color map, and a new incremental subset index for <italic>L</italic> is generated. Otherwise, it means that the color set already appeared in a previously processed <italic>k</italic>-mer, so the subset index of that color set is returned. Finally, the <italic>k</italic>-mer in the graph is labeled with its corresponding subset index, which, as discussed above, uniquely identifies a color subset. Overall, this allows a better compression, because each subset is encoded only once and not for every <italic>k</italic>-mer that belongs to it.</p>
      <p>To optimize the disk space of the color map, this is encoded using a run-length compression scheme on the differences of the sorted colors of the subset, then it is divided into chunks for faster access and compressed again with a run of the lz4 algorithm. Furthermore, when writing the unitigs to disk, we mark the colors of each unitig in the header of the unitig sequence in the FASTA file by also run-length encoding the color set indices of all the <italic>k</italic>-mers of the unitigs. This strategy works well because most unitigs are “variation-free” and thus tend to have only a small number of possible color subsets associated to its <italic>k</italic>-mers.</p>
    </sec>
    <sec id="s3g">
      <title>Sequence querying</title>
      <p>GGCAT performs queries by dividing unitigs of the input graph and the queries in buckets, using an approach similar to the reads splitting step of the build algorithm. Then, independently for each bucket, a <italic>k</italic>-mer counting is performed to find the number of <italic>k</italic>-mers that match for each query. Finally, all the counters from different buckets are summed up to find for each query the number of <italic>k</italic>-mers that are present in the input graph. This also allows the partial matching of queries, because the output is the exact number of <italic>k</italic>-mer matches for each input sequence, and a percentage of required matching <italic>k</italic>-mers can be put as threshold to report a query as present. Similar to BiFrost, for the uncolored case, we return in output a CSV file with a line for each input query, containing the number and percentage of matched <italic>k</italic>-mers. For the colored case, we opted instead for a JSON Lines (JSONL) file with a line for each query, containing the number (if positive) of <italic>k</italic>-mer matches for each color <italic>c</italic> of the graph.</p>
    </sec>
    <sec id="s3h">
      <title>Details of the data sets used in the evaluation</title>
      <p>The Human Illumina read data set is the Illumina WGS 2 × 250-bp data set from the GIAB project, accession number HG004, <uri xlink:href="https://github.com/genome-in-a-bottle/giab·data·indexes/blob/master/AshkenazimTrio/sequence.index.AJtrio·Illumina·2×250bps·06012016.HG004">https://github.com/genome-in-a-bottle/giab·data·indexes/blob/master/AshkenazimTrio/sequence.index.AJtrio·Illumina·2×250bps·06012016.HG004</uri>. The Human gut microbiome read data set was obtained from the NCBI BioProject database (<uri xlink:href="https://www.ncbi.nlm.nih.gov/bioproject/">https://www.ncbi.nlm.nih.gov/bioproject/</uri>) under accession number PRJEB33098 (<xref rid="GR277615CRAC30" ref-type="bibr">Mas-Lloret et al. 2020</xref>). The 309 K <italic>Salmonella</italic> genome sequences were downloaded by us in February 2022 from the EnteroBase database (<xref rid="GR277615CRAC45" ref-type="bibr">Zhou et al. 2020</xref>) and gzipped. The 100 Human genomes are from the set of 2505 Human genomes generated by <xref rid="GR277615CRAC43" ref-type="bibr">Schmidt et al. (2023)</xref> using GRCh37 and the variant files from the 1000 Genomes Project (<xref rid="GR277615CRAC1" ref-type="bibr">The 1000 Genomes Project Consortium 2015</xref>). For convenience we uploaded the Human genomes used for the benchmark to Zenodo (<uri xlink:href="https://doi.org/10.5281/zenodo.2597496">https://doi.org/10.5281/zenodo.2597496</uri>). The use of a newer Human genome reference would not significantly affect the conclusions of this study. Indeed, the computational performance of the tools are mainly dependent on the number of unique <italic>k</italic>-mers, which is mainly dependent on the variant files. However, in this setting, we would use the same variant files, even if a newer genome reference was used. The Bacterial genome sequences are from the data set used by <xref rid="GR277615CRAC6" ref-type="bibr">Blackwell et al. (2021)</xref>.</p>
    </sec>
    <sec id="s3i">
      <title>Software availability</title>
      <p>GGCAT is implemented in Rust and is available at GitHub (<uri xlink:href="https://github.com/algbio/ggcat">https://github.com/algbio/ggcat</uri>) and as <xref rid="SD1" ref-type="supplementary-material">Supplemental Code</xref>. For all tests, we used GGCAT commit <monospace>f56da4d35f99f3537ec0a33f44d575898a8c91ea</monospace> (<uri xlink:href="https://github.com/algbio/ggcat/tree/f56da4d35f99f3537ec0a33f44d575898a8c91ea">https://github.com/algbio/ggcat/tree/f56da4d35f99f3537ec0a33f44d575898a8c91ea</uri>). The tools and scripts used to perform the benchmarks are available at GitHub (<uri xlink:href="https://github.com/Guilucand/ggcat-test-benchmarks">https://github.com/Guilucand/ggcat-test-benchmarks</uri>) and as <xref rid="SD1" ref-type="supplementary-material">Supplemental Code</xref>. The scripts for downloading the data sets used in the evaluation are available in the datasets-download/ folder of this repository.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material" id="SM1">
    <title>Supplementary Material</title>
    <supplementary-material id="SD1" position="float" content-type="local-data">
      <label>Supplement 1</label>
      <media xlink:href="Supplemental_Code.zip" id="d64e3263" position="anchor"/>
    </supplementary-material>
    <supplementary-material id="SD2" position="float" content-type="local-data">
      <label>Supplement 2</label>
      <media xlink:href="Supplemental_Methods.pdf" id="d64e3266" position="anchor"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgments</title>
    <p>We thank Massimo Cairo and Romeo Rizzi for initial discussions on this problem. We thank Paul Medvedev for spotting some errors in the initial manuscript, pointing us to relevant literature, and suggesting that the equivalence between edge-centric and node-centric unitigs exists, which we proved in the <ext-link xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.277615.122/-/DC1" ext-link-type="uri">Supplemental Methods</ext-link>. We thank Jarno Alanko, Tommi Mäklin, and Rob Patro for pointing us to relevant literature. We thank Jarno Alanko for spotting and fixing some concurrency-related bugs in GGCAT. We thank Sebastian Schmidt for help with the integration of eulertigs (<xref rid="GR277615CRAC42" ref-type="bibr">Schmidt and Alanko 2022</xref>) and matchtigs (<xref rid="GR277615CRAC43" ref-type="bibr">Schmidt et al. 2023</xref>) into GGCAT. This work was partially funded by the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement no. 851093, SAFEBIO), and partially by the Academy of Finland (grant nos. 322595, 352821, and 346968).</p>
  </ack>
  <fn-group>
    <fn fn-type="supplementary-material">
      <p>[Supplemental material is available for this article.]</p>
    </fn>
    <fn>
      <p>Article published online before print. Article, supplemental material, and publication date are at <ext-link xlink:href="https://www.genome.org/cgi/doi/10.1101/gr.277615.122" ext-link-type="uri">https://www.genome.org/cgi/doi/10.1101/gr.277615.122</ext-link>.</p>
    </fn>
    <fn>
      <p>Freely available online through the <italic>Genome Research</italic> Open Access option.</p>
    </fn>
  </fn-group>
  <sec id="s5">
    <title>Competing interest statement</title>
    <p>The authors declare no competing interests.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="GR277615CRAC1">
      <mixed-citation publication-type="journal"><collab>The 1000 Genomes Project Consortium</collab>. <year>2015</year>. <article-title>A global reference for human genetic variation</article-title>. <source>Nature</source><volume>526</volume>: <fpage>68</fpage>–<lpage>74</lpage>. <pub-id pub-id-type="doi">10.1038/nature15393</pub-id><pub-id pub-id-type="pmid">26432245</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC2">
      <mixed-citation publication-type="journal"><string-name><surname>Alanko</surname><given-names>JN</given-names></string-name>, <string-name><surname>Vuohtoniemi</surname><given-names>J</given-names></string-name>, <string-name><surname>Mäklin</surname><given-names>T</given-names></string-name>, <string-name><surname>Puglisi</surname><given-names>SJ</given-names></string-name>. <year>2023</year>. <article-title>Themisto: a scalable colored <italic>k</italic>-mer index for sensitive pseudoalignment against hundreds of thousands of bacterial genomes</article-title>. <source>Bioinformatics</source><volume>39</volume>(<issue>39 Suppl 1</issue>): <fpage>i260</fpage>–<lpage>i269</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btad233</pub-id><pub-id pub-id-type="pmid">37387143</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC3">
      <mixed-citation publication-type="confproc"><string-name><surname>Almodaresi</surname><given-names>F</given-names></string-name>, <string-name><surname>Pandey</surname><given-names>P</given-names></string-name>, <string-name><surname>Patro</surname><given-names>R</given-names></string-name>. <year>2017</year>. <article-title>Rainbowfish: a succinct colored de Bruijn graph representation</article-title>. In <conf-name>17th International Workshop on Algorithms in Bioinformatics, WABI 2017</conf-name>, Vol. 88 <italic>of LIPIcs</italic> (ed. <string-name><surname>Schwartz</surname><given-names>R</given-names></string-name>, <string-name><surname>Reinert</surname><given-names>K</given-names></string-name>), pp. <fpage>18:1</fpage>–<lpage>18:15</lpage>. <publisher-name>Leibniz-Zentrum für Informatik, Schloss Dagstuhl</publisher-name>, <publisher-loc>Wadern, Germany</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR277615CRAC4">
      <mixed-citation publication-type="journal"><string-name><surname>Bankevich</surname><given-names>A</given-names></string-name>, <string-name><surname>Bzikadze</surname><given-names>AV</given-names></string-name>, <string-name><surname>Kolmogorov</surname><given-names>M</given-names></string-name>, <string-name><surname>Antipov</surname><given-names>D</given-names></string-name>, <string-name><surname>Pevzner</surname><given-names>PA</given-names></string-name>. <year>2022</year>. <article-title>Multiplex de Bruijn graphs enable genome assembly from long, high-fidelity reads</article-title>. <source>Nat Biotechnol</source><volume>40</volume>: <fpage>1075</fpage>–<lpage>1081</lpage>. <pub-id pub-id-type="doi">10.1038/s41587-022-01220-6</pub-id><pub-id pub-id-type="pmid">35228706</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC5">
      <mixed-citation publication-type="journal"><string-name><surname>Benoit</surname><given-names>G</given-names></string-name>, <string-name><surname>Lemaitre</surname><given-names>C</given-names></string-name>, <string-name><surname>Lavenier</surname><given-names>D</given-names></string-name>, <string-name><surname>Drezen</surname><given-names>D</given-names></string-name>, <string-name><surname>Dayris</surname><given-names>T</given-names></string-name>, <string-name><surname>Uricaru</surname><given-names>R</given-names></string-name>, <string-name><surname>Rizk</surname><given-names>G</given-names></string-name>. <year>2015</year>. <article-title>Reference-free compression of high throughput sequencing data with a probabilistic de Bruijn graph</article-title>. <source>BMC Bioinformatics</source><volume>16</volume>: <fpage>288</fpage>. <pub-id pub-id-type="doi">10.1186/s12859-015-0709-7</pub-id><pub-id pub-id-type="pmid">26370285</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC6">
      <mixed-citation publication-type="journal"><string-name><surname>Blackwell</surname><given-names>GA</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>M</given-names></string-name>, <string-name><surname>Malone</surname><given-names>KM</given-names></string-name>, <string-name><surname>Lima</surname><given-names>L</given-names></string-name>, <string-name><surname>Horesh</surname><given-names>G</given-names></string-name>, <string-name><surname>Alako</surname><given-names>BTF</given-names></string-name>, <string-name><surname>Thomson</surname><given-names>NR</given-names></string-name>, <string-name><surname>Iqbal</surname><given-names>Z</given-names></string-name>. <year>2021</year>. <article-title>Exploring bacterial diversity via a curated and searchable snapshot of archived DNA sequences</article-title>. <source>PLoS Biol</source><volume>19</volume>: <fpage>e3001421</fpage>. <pub-id pub-id-type="doi">10.1371/journal.pbio.3001421</pub-id><pub-id pub-id-type="pmid">34752446</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC7">
      <mixed-citation publication-type="journal"><string-name><surname>Bloom</surname><given-names>BH</given-names></string-name>. <year>1970</year>. <article-title>Space/time trade-offs in hash coding with allowable errors</article-title>. <source>Commun ACM</source><volume>13</volume>: <fpage>422</fpage>–<lpage>426</lpage>. <pub-id pub-id-type="doi">10.1145/362686.362692</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC8">
      <mixed-citation publication-type="journal"><string-name><surname>Bray</surname><given-names>NL</given-names></string-name>, <string-name><surname>Pimentel</surname><given-names>H</given-names></string-name>, <string-name><surname>Melsted</surname><given-names>P</given-names></string-name>, <string-name><surname>Pachter</surname><given-names>L</given-names></string-name>. <year>2016</year>. <article-title>Near-optimal probabilistic RNA-seq quantification</article-title>. <source>Nat Biotechnol</source><volume>34</volume>: <fpage>525</fpage>–<lpage>527</lpage>. <pub-id pub-id-type="doi">10.1038/nbt.3519</pub-id><pub-id pub-id-type="pmid">27043002</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC9">
      <mixed-citation publication-type="journal"><string-name><surname>Břinda</surname><given-names>K</given-names></string-name>, <string-name><surname>Baym</surname><given-names>M</given-names></string-name>, <string-name><surname>Kucherov</surname><given-names>G</given-names></string-name>. <year>2021</year>. <article-title>Simplitigs as an efficient and scalable representation of de Bruijn graphs</article-title>. <source>Genome Biol</source><volume>22</volume>: <fpage>96</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-021-02297-z</pub-id><pub-id pub-id-type="pmid">33823902</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC10">
      <mixed-citation publication-type="journal"><string-name><surname>Cameron</surname><given-names>DL</given-names></string-name>, <string-name><surname>Schröder</surname><given-names>J</given-names></string-name>, <string-name><surname>Penington</surname><given-names>JS</given-names></string-name>, <string-name><surname>Do</surname><given-names>H</given-names></string-name>, <string-name><surname>Molania</surname><given-names>R</given-names></string-name>, <string-name><surname>Dobrovic</surname><given-names>A</given-names></string-name>, <string-name><surname>Speed</surname><given-names>TP</given-names></string-name>, <string-name><surname>Papenfuss</surname><given-names>AT</given-names></string-name>. <year>2017</year>. <article-title>GRIDSS: sensitive and specific genomic rearrangement detection using positional de Bruijn graph assembly</article-title>. <source>Genome Res</source><volume>27</volume>: <fpage>2050</fpage>–<lpage>2060</lpage>. <pub-id pub-id-type="doi">10.1101/gr.222109.117</pub-id><pub-id pub-id-type="pmid">29097403</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC11">
      <mixed-citation publication-type="journal"><string-name><surname>Chambi</surname><given-names>S</given-names></string-name>, <string-name><surname>Lemire</surname><given-names>D</given-names></string-name>, <string-name><surname>Kaser</surname><given-names>O</given-names></string-name>, <string-name><surname>Godin</surname><given-names>R</given-names></string-name>. <year>2016</year>. <article-title>Better bitmap performance with roaring bitmaps</article-title>. <source>Softw Pract Exp</source><volume>46</volume>: <fpage>709</fpage>–<lpage>719</lpage>. <pub-id pub-id-type="doi">10.1002/spe.2325</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC12">
      <mixed-citation publication-type="journal"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P</given-names></string-name>. <year>2016</year>. <article-title>Compacting de Bruijn graphs from sequencing data quickly and in low memory</article-title>. <source>Bioinformatics</source><volume>32</volume>: <fpage>i201</fpage>–<lpage>i208</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btw279</pub-id><pub-id pub-id-type="pmid">27307618</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC13">
      <mixed-citation publication-type="journal"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Holub</surname><given-names>J</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P</given-names></string-name>. <year>2022</year>. <article-title>Data structures to represent a set of <italic>k</italic>-long DNA sequences</article-title>. <source>ACM Comput Surv</source><volume>54</volume>: <fpage>17</fpage>. <pub-id pub-id-type="doi">10.1145/3445967</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC14">
      <mixed-citation publication-type="journal"><string-name><surname>Compeau</surname><given-names>PEC</given-names></string-name>, <string-name><surname>Pevzner</surname><given-names>PA</given-names></string-name>, <string-name><surname>Tesler</surname><given-names>G</given-names></string-name>. <year>2011</year>. <article-title>How to apply de Bruijn graphs to genome assembly</article-title>. <source>Nat Biotechnol</source><volume>29</volume>: <fpage>987</fpage>–<lpage>991</lpage>. <pub-id pub-id-type="doi">10.1038/nbt.2023</pub-id><pub-id pub-id-type="pmid">22068540</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC15">
      <mixed-citation publication-type="journal"><string-name><surname>Deorowicz</surname><given-names>S</given-names></string-name>, <string-name><surname>Kokot</surname><given-names>M</given-names></string-name>, <string-name><surname>Grabowski</surname><given-names>S</given-names></string-name>, <string-name><surname>Debudaj-Grabysz</surname><given-names>A</given-names></string-name>. <year>2015</year>. <article-title>KMC 2: fast and resource-frugal <italic>k</italic>-mer counting</article-title>. <source>Bioinformatics</source><volume>31</volume>: <fpage>1569</fpage>–<lpage>1576</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btv022</pub-id><pub-id pub-id-type="pmid">25609798</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC16">
      <mixed-citation publication-type="journal"><string-name><surname>Drezen</surname><given-names>E</given-names></string-name>, <string-name><surname>Rizk</surname><given-names>G</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Deltel</surname><given-names>C</given-names></string-name>, <string-name><surname>Lemaitre</surname><given-names>C</given-names></string-name>, <string-name><surname>Peterlongo</surname><given-names>P</given-names></string-name>, <string-name><surname>Lavenier</surname><given-names>D</given-names></string-name>. <year>2014</year>. <article-title>GATB: genome assembly &amp; analysis tool box</article-title>. <source>Bioinformatics</source><volume>30</volume>: <fpage>2959</fpage>–<lpage>2961</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btu406</pub-id><pub-id pub-id-type="pmid">24990603</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC17">
      <mixed-citation publication-type="journal"><string-name><surname>Dufault-Thompson</surname><given-names>K</given-names></string-name>, <string-name><surname>Jiang</surname><given-names>X</given-names></string-name>. <year>2022</year>. <article-title>Applications of de Bruijn graphs in microbiome research</article-title>. <source>iMeta</source><volume>1</volume>: <fpage>e4</fpage>. <pub-id pub-id-type="doi">10.1002/imt2.4</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC18">
      <mixed-citation publication-type="journal"><string-name><surname>Guo</surname><given-names>H</given-names></string-name>, <string-name><surname>Fu</surname><given-names>Y</given-names></string-name>, <string-name><surname>Gao</surname><given-names>Y</given-names></string-name>, <string-name><surname>Li</surname><given-names>J</given-names></string-name>, <string-name><surname>Wang</surname><given-names>Y</given-names></string-name>, <string-name><surname>Liu</surname><given-names>B</given-names></string-name>. <year>2021</year>. <article-title>deGSM: memory scalable construction of large scale de Bruijn graph</article-title>. <source>IEEE/ACM Trans Comput Biol Bioinform</source><volume>18</volume>: <fpage>2157</fpage>–<lpage>2166</lpage>. <pub-id pub-id-type="doi">10.1109/TCBB.2019.2913932</pub-id><pub-id pub-id-type="pmid">31056509</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC19">
      <mixed-citation publication-type="journal"><string-name><surname>Holley</surname><given-names>G</given-names></string-name>, <string-name><surname>Melsted</surname><given-names>P</given-names></string-name>. <year>2020</year>. <article-title>Bifrost: highly parallel construction and indexing of colored and compacted de Bruijn graphs</article-title>. <source>Genome Biol</source><volume>21</volume>: <fpage>249</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-020-02135-8</pub-id><pub-id pub-id-type="pmid">32943081</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC20">
      <mixed-citation publication-type="journal"><string-name><surname>Iqbal</surname><given-names>Z</given-names></string-name>, <string-name><surname>Caccamo</surname><given-names>M</given-names></string-name>, <string-name><surname>Turner</surname><given-names>O</given-names></string-name>, <string-name><surname>Flicek</surname><given-names>P</given-names></string-name>, <string-name><surname>McVean</surname><given-names>G</given-names></string-name>. <year>2012</year>. <article-title><italic>De novo</italic> assembly and genotyping of variants using colored de Bruijn graphs</article-title>. <source>Nat Genet</source><volume>44</volume>: <fpage>226</fpage>–<lpage>232</lpage>. <pub-id pub-id-type="doi">10.1038/ng.1028</pub-id><pub-id pub-id-type="pmid">22231483</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC21">
      <mixed-citation publication-type="journal"><string-name><surname>Khan</surname><given-names>J</given-names></string-name>, <string-name><surname>Patro</surname><given-names>R</given-names></string-name>. <year>2021</year>. <article-title>Cuttlefish: fast, parallel and low-memory compaction of de Bruijn graphs from large-scale genome collections</article-title>. <source>Bioinformatics</source><volume>37</volume>: <fpage>i177</fpage>–<lpage>i186</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btab309</pub-id><pub-id pub-id-type="pmid">34252958</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC22">
      <mixed-citation publication-type="journal"><string-name><surname>Khan</surname><given-names>J</given-names></string-name>, <string-name><surname>Kokot</surname><given-names>M</given-names></string-name>, <string-name><surname>Deorowicz</surname><given-names>S</given-names></string-name>, <string-name><surname>Patro</surname><given-names>R</given-names></string-name>. <year>2022</year>. <article-title>Scalable, ultra-fast, and low-memory construction of compacted de Bruijn graphs with Cuttlefish 2</article-title>. <source>Genome Biol</source><volume>23</volume>: <fpage>190</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-022-02743-6</pub-id><pub-id pub-id-type="pmid">36076275</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC23">
      <mixed-citation publication-type="journal"><string-name><surname>Kokot</surname><given-names>M</given-names></string-name>, <string-name><surname>Długosz</surname><given-names>M</given-names></string-name>, <string-name><surname>Deorowicz</surname><given-names>S</given-names></string-name>. <year>2017</year>. <article-title>KMC 3: counting and manipulating <italic>k</italic>-mer statistics</article-title>. <source>Bioinformatics</source><volume>33</volume>: <fpage>2759</fpage>–<lpage>2761</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btx304</pub-id><pub-id pub-id-type="pmid">28472236</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC24">
      <mixed-citation publication-type="confproc"><string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Rizk</surname><given-names>G</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Peterlongo</surname><given-names>R</given-names></string-name>. <year>2017</year>. <article-title>Fast and scalable minimal perfect hashing for massive key sets</article-title>. In <conf-name>16th International Symposium on Experimental Algorithms (SEA 2017)</conf-name>, Vol. 75 <italic>of LIPIcs</italic> (ed. <string-name><surname>Iliopoulos</surname></string-name> C <etal/>), pp. <fpage>25:1</fpage>–<lpage>25:16</lpage>. <publisher-name>Leibniz-Zentrum für Informatik, Schloss Dagstuhl</publisher-name>, <publisher-loc>Wadern, Germany</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR277615CRAC25">
      <mixed-citation publication-type="journal"><string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Flot</surname><given-names>JF</given-names></string-name>, <string-name><surname>Peterlongo</surname><given-names>P</given-names></string-name>. <year>2020</year>. <article-title>Toward perfect reads: self-correction of short reads via mapping on de Bruijn graphs</article-title>. <source>Bioinformatics</source><volume>36</volume>: <fpage>1374</fpage>–<lpage>1381</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btz102</pub-id><pub-id pub-id-type="pmid">30785192</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC26">
      <mixed-citation publication-type="journal"><string-name><surname>Liu</surname><given-names>B</given-names></string-name>, <string-name><surname>Guo</surname><given-names>H</given-names></string-name>, <string-name><surname>Brudno</surname><given-names>M</given-names></string-name>, <string-name><surname>Wang</surname><given-names>Y</given-names></string-name>. <year>2016</year>. <article-title>deBGA: read alignment with de Bruijn graph-based seed and extension</article-title>. <source>Bioinformatics</source><volume>32</volume>: <fpage>3224</fpage>–<lpage>3232</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btw371</pub-id><pub-id pub-id-type="pmid">27378303</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC27">
      <mixed-citation publication-type="journal"><string-name><surname>Luhmann</surname><given-names>N</given-names></string-name>, <string-name><surname>Holley</surname><given-names>G</given-names></string-name>, <string-name><surname>Achtman</surname><given-names>M</given-names></string-name>. <year>2021</year>. <article-title>BlastFrost: fast querying of 100,000s of bacterial genomes in Bifrost graphs</article-title>. <source>Genome Biol</source><volume>22</volume>: <fpage>30</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-020-02237-3</pub-id><pub-id pub-id-type="pmid">33430919</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC28">
      <mixed-citation publication-type="journal"><string-name><surname>Mäklin</surname><given-names>T</given-names></string-name>, <string-name><surname>Kallonen</surname><given-names>T</given-names></string-name>, <string-name><surname>Alanko</surname><given-names>J</given-names></string-name>, <string-name><surname>Samuelsen</surname><given-names>Ø</given-names></string-name>, <string-name><surname>Hegstad</surname><given-names>K</given-names></string-name>, <string-name><surname>Mäkinen</surname><given-names>V</given-names></string-name>, <string-name><surname>Corander</surname><given-names>J</given-names></string-name>, <string-name><surname>Heinz</surname><given-names>E</given-names></string-name>, <string-name><surname>Honkela</surname><given-names>A</given-names></string-name>. <year>2021</year>. <article-title>Bacterial genomic epidemiology with mixed samples</article-title>. <source>Microb Genom</source><volume>7</volume>: <fpage>000691</fpage>. <pub-id pub-id-type="doi">10.1099/mgen.0.000691</pub-id><pub-id pub-id-type="pmid">34779765</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC29">
      <mixed-citation publication-type="journal"><string-name><surname>Mäklin</surname><given-names>T</given-names></string-name>, <string-name><surname>Thorpe</surname><given-names>HA</given-names></string-name>, <string-name><surname>Pöntinen</surname><given-names>AK</given-names></string-name>, <string-name><surname>Gladstone</surname><given-names>RA</given-names></string-name>, <string-name><surname>Shao</surname><given-names>Y</given-names></string-name>, <string-name><surname>Pesonen</surname><given-names>M</given-names></string-name>, <string-name><surname>McNally</surname><given-names>A</given-names></string-name>, <string-name><surname>Johnsen</surname><given-names>PJ</given-names></string-name>, <string-name><surname>Samuelsen</surname><given-names>Ø</given-names></string-name>, <string-name><surname>Lawley</surname><given-names>TD</given-names></string-name>, <etal/><year>2022</year>. <article-title>Strong pathogen competition in neonatal gut colonisation</article-title>. <source>Nat Commun</source><volume>13</volume>: <fpage>7417</fpage>. <pub-id pub-id-type="doi">10.1038/s41467-022-35178-5</pub-id><pub-id pub-id-type="pmid">36456554</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC30">
      <mixed-citation publication-type="journal"><string-name><surname>Mas-Lloret</surname><given-names>J</given-names></string-name>, <string-name><surname>Obón-Santacana</surname><given-names>M</given-names></string-name>, <string-name><surname>Ibáñez-Sanz</surname><given-names>G</given-names></string-name>, <string-name><surname>Guinó</surname><given-names>E</given-names></string-name>, <string-name><surname>Pato</surname><given-names>ML</given-names></string-name>, <string-name><surname>Rodriguez-Moranta</surname><given-names>F</given-names></string-name>, <string-name><surname>Mata</surname><given-names>A</given-names></string-name>, <string-name><surname>García-Rodríguez</surname><given-names>A</given-names></string-name>, <string-name><surname>Moreno</surname><given-names>V</given-names></string-name>, <string-name><surname>Pimenoff</surname><given-names>VN</given-names></string-name>. <year>2020</year>. <article-title>Gut microbiome diversity detected by high-coverage 16s and shotgun sequencing of paired stool and colon sample</article-title>. <source>Sci Data</source><volume>7</volume>: <fpage>92</fpage>. <pub-id pub-id-type="doi">10.1038/s41597-020-0427-5</pub-id><pub-id pub-id-type="pmid">32179734</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC31">
      <mixed-citation publication-type="confproc"><string-name><surname>Minkin</surname><given-names>I</given-names></string-name>, <string-name><surname>Patel</surname><given-names>A</given-names></string-name>, <string-name><surname>Kolmogorov</surname><given-names>M</given-names></string-name>, <string-name><surname>Vyahhi</surname><given-names>N</given-names></string-name>, <string-name><surname>Pham</surname><given-names>S</given-names></string-name>. <year>2013</year>. <article-title>Sibelia: a scalable and comprehensive synteny block generation tool for closely related microbial genomes</article-title>. In <conf-name>Algorithms in bioinformatics (WABI 2013), Vol. 8126 of LNCS</conf-name> (ed. <string-name><surname>Darling</surname><given-names>A</given-names></string-name>, <string-name><surname>Stoye</surname><given-names>J</given-names></string-name>), pp. <fpage>215</fpage>–<lpage>229</lpage>. <publisher-name>Springer</publisher-name>, <publisher-loc>Berlin</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR277615CRAC32">
      <mixed-citation publication-type="journal"><string-name><surname>Mohamadi</surname><given-names>H</given-names></string-name>, <string-name><surname>Chu</surname><given-names>J</given-names></string-name>, <string-name><surname>Vandervalk</surname><given-names>BP</given-names></string-name>, <string-name><surname>Birol</surname><given-names>I</given-names></string-name>. <year>2016</year>. <article-title>ntHash: recursive nucleotide hashing</article-title>. <source>Bioinformatics</source><volume>32</volume>: <fpage>3492</fpage>–<lpage>3494</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btw397</pub-id><pub-id pub-id-type="pmid">27423894</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC33">
      <mixed-citation publication-type="journal"><string-name><surname>Muggli</surname><given-names>MD</given-names></string-name>, <string-name><surname>Alipanahi</surname><given-names>B</given-names></string-name>, <string-name><surname>Boucher</surname><given-names>C</given-names></string-name>. <year>2019</year>. <article-title>Building large updatable colored de Bruijn graphs via merging</article-title>. <source>Bioinformatics</source><volume>35</volume>: <fpage>i51</fpage>–<lpage>i60</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btz350</pub-id><pub-id pub-id-type="pmid">31510647</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC34">
      <mixed-citation publication-type="journal"><string-name><surname>Pandey</surname><given-names>P</given-names></string-name>, <string-name><surname>Almodaresi</surname><given-names>F</given-names></string-name>, <string-name><surname>Bender</surname><given-names>MA</given-names></string-name>, <string-name><surname>Ferdman</surname><given-names>M</given-names></string-name>, <string-name><surname>Johnson</surname><given-names>R</given-names></string-name>, <string-name><surname>Patro</surname><given-names>R</given-names></string-name>. <year>2018</year>. <article-title>Mantis: a fast, small, and exact large-scale sequence-search index</article-title>. <source>Cell Syst</source><volume>7</volume>: <fpage>201</fpage>–<lpage>207.e4</lpage>. <pub-id pub-id-type="doi">10.1016/j.cels.2018.05.021</pub-id><pub-id pub-id-type="pmid">29936185</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC35">
      <mixed-citation publication-type="journal"><string-name><surname>Prjibelski</surname><given-names>A</given-names></string-name>, <string-name><surname>Antipov</surname><given-names>D</given-names></string-name>, <string-name><surname>Meleshko</surname><given-names>D</given-names></string-name>, <string-name><surname>Lapidus</surname><given-names>A</given-names></string-name>, <string-name><surname>Korobeynikov</surname><given-names>A</given-names></string-name>. <year>2020</year>. <article-title>Using SPAdes de novo assembler</article-title>. <source>Curr Protoc Bioinform</source><volume>70</volume>: <fpage>e102</fpage>. <pub-id pub-id-type="doi">10.1002/cpbi.102</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC36">
      <mixed-citation publication-type="journal"><string-name><surname>Putze</surname><given-names>F</given-names></string-name>, <string-name><surname>Sanders</surname><given-names>P</given-names></string-name>, <string-name><surname>Singler</surname><given-names>J</given-names></string-name>. <year>2010</year>. <article-title>Cache-, hash-, and space-efficient bloom filters</article-title>. <source>ACM J Exp Algorithmics</source><volume>14</volume>: <fpage>4.4</fpage>–<lpage>4.18</lpage>. <pub-id pub-id-type="doi">10.1145/1498698.1594230</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC37">
      <mixed-citation publication-type="journal"><string-name><surname>Rahman</surname><given-names>A</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P</given-names></string-name>. <year>2021</year>. <article-title>Representation of <italic>k</italic>-mer sets using spectrum-preserving string sets</article-title>. <source>J Comput Biol</source><volume>28</volume>: <fpage>381</fpage>–<lpage>394</lpage>. <pub-id pub-id-type="doi">10.1089/cmb.2020.0431</pub-id><pub-id pub-id-type="pmid">33290137</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC38">
      <mixed-citation publication-type="journal"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hayes</surname><given-names>W</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name>, <string-name><surname>Mount</surname><given-names>SM</given-names></string-name>, <string-name><surname>Yorke</surname><given-names>JA</given-names></string-name>. <year>2004</year>. <article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source><volume>20</volume>: <fpage>3363</fpage>–<lpage>3369</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/bth408</pub-id><pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC39">
      <mixed-citation publication-type="journal"><string-name><surname>Robertson</surname><given-names>G</given-names></string-name>, <string-name><surname>Schein</surname><given-names>J</given-names></string-name>, <string-name><surname>Chiu</surname><given-names>R</given-names></string-name>, <string-name><surname>Corbett</surname><given-names>R</given-names></string-name>, <string-name><surname>Field</surname><given-names>M</given-names></string-name>, <string-name><surname>Jackman</surname><given-names>SD</given-names></string-name>, <string-name><surname>Mungall</surname><given-names>K</given-names></string-name>, <string-name><surname>Lee</surname><given-names>S</given-names></string-name>, <string-name><surname>Okada</surname><given-names>HM</given-names></string-name>, <string-name><surname>Qian</surname><given-names>JQ</given-names></string-name>, <etal/><year>2010</year>. <article-title><italic>De novo</italic> assembly and analysis of RNA-seq data</article-title>. <source>Nat Methods</source><volume>7</volume>: <fpage>909</fpage>–<lpage>912</lpage>. <pub-id pub-id-type="doi">10.1038/nmeth.1517</pub-id><pub-id pub-id-type="pmid">20935650</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC40">
      <mixed-citation publication-type="journal"><string-name><surname>Ruan</surname><given-names>J</given-names></string-name>, <string-name><surname>Li</surname><given-names>H</given-names></string-name>. <year>2020</year>. <article-title>Fast and accurate long-read assembly with wtdbg2</article-title>. <source>Nat Methods</source><volume>17</volume>: <fpage>155</fpage>–<lpage>158</lpage>. <pub-id pub-id-type="doi">10.1038/s41592-019-0669-3</pub-id><pub-id pub-id-type="pmid">31819265</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC41">
      <mixed-citation publication-type="journal"><string-name><surname>Salmela</surname><given-names>L</given-names></string-name>, <string-name><surname>Rivals</surname><given-names>E</given-names></string-name>. <year>2014</year>. <article-title>LoRDEC: accurate and efficient long read error correction</article-title>. <source>Bioinformatics</source><volume>30</volume>: <fpage>3506</fpage>–<lpage>3514</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btu538</pub-id><pub-id pub-id-type="pmid">25165095</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC42">
      <mixed-citation publication-type="confproc"><string-name><surname>Schmidt</surname><given-names>S</given-names></string-name>, <string-name><surname>Alanko</surname><given-names>JN</given-names></string-name>. <year>2022</year>. <article-title>Eulertigs: minimum plain text representation of <italic>k</italic>-mer sets without repetitions in linear time</article-title>. In <conf-name>22nd International Workshop on Algorithms in Bioinformatics, WABI 2022, Vol. 242 of LIPIcs</conf-name> (ed. <string-name><surname>Boucher</surname><given-names>C</given-names></string-name>, <string-name><surname>Rahmann</surname><given-names>S</given-names></string-name>), pp. <fpage>2:1</fpage>–<lpage>2:21</lpage>. <publisher-name>Leibniz-Zentrum für Informatik, Schloss Dagstuhl</publisher-name>, <publisher-loc>Wadern, Germany</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR277615CRAC43">
      <mixed-citation publication-type="journal"><string-name><surname>Schmidt</surname><given-names>S</given-names></string-name>, <string-name><surname>Khan</surname><given-names>S</given-names></string-name>, <string-name><surname>Alanko</surname><given-names>J</given-names></string-name>, <string-name><surname>Pibiri</surname><given-names>GE</given-names></string-name>, <string-name><surname>Tomescu</surname><given-names>AI</given-names></string-name>. <year>2023</year>. <article-title>Matchtigs: minimum plain text representation of <italic>k</italic>-mer sets</article-title>. <source>Genome Biol</source><volume>24</volume>: <fpage>136</fpage>. <pub-id pub-id-type="doi">10.1186/s13059-023-02968-z</pub-id><pub-id pub-id-type="pmid">37296461</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC44">
      <mixed-citation publication-type="book"><string-name><surname>Zekic</surname><given-names>T</given-names></string-name>, <string-name><surname>Holley</surname><given-names>G</given-names></string-name>, <string-name><surname>Stoye</surname><given-names>J</given-names></string-name>. <year>2018</year>. <part-title>Pan-genome storage and analysis techniques</part-title>. In <source>Comparative genomics: methods in molecular biology</source> (ed. <string-name><surname>Setubal</surname><given-names>J</given-names></string-name>
<etal/>), Vol. <volume>1704</volume>, pp. <fpage>29</fpage>–<lpage>53</lpage>. <publisher-name>Humana Press</publisher-name>, <publisher-loc>New York</publisher-loc>.<pub-id pub-id-type="pmid">29277862</pub-id></mixed-citation>
    </ref>
    <ref id="GR277615CRAC45">
      <mixed-citation publication-type="journal"><string-name><surname>Zhou</surname><given-names>Z</given-names></string-name>, <string-name><surname>Alikhan</surname><given-names>NF</given-names></string-name>, <string-name><surname>Mohamed</surname><given-names>K</given-names></string-name>, <string-name><surname>Fan</surname><given-names>Y</given-names></string-name>, <string-name><surname>Achtman</surname><given-names>M</given-names></string-name>. <year>2020</year>. <article-title>The EnteroBase user's guide, with case studies on <italic>Salmonella</italic> transmissions, <italic>Yersinia pestis</italic> phylogeny, and <italic>Escherichia</italic> core genomic diversity</article-title>. <source>Genome Res</source><volume>30</volume>: <fpage>138</fpage>–<lpage>152</lpage>. <pub-id pub-id-type="doi">10.1101/gr.251678.119</pub-id><pub-id pub-id-type="pmid">31809257</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
