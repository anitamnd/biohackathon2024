<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3154205</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-12-214</article-id>
    <article-id pub-id-type="pmid">21619640</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-12-214</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Structator: fast index-based search for RNA sequence-structure patterns</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="A1">
        <name>
          <surname>Meyer</surname>
          <given-names>Fernando</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>meyer@zbh.uni-hamburg.de</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Kurtz</surname>
          <given-names>Stefan</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>kurtz@zbh.uni-hamburg.de</email>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Backofen</surname>
          <given-names>Rolf</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>backofen@informatik.uni-freiburg.de</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A4">
        <name>
          <surname>Will</surname>
          <given-names>Sebastian</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>swill@csail.mit.edu</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A5">
        <name>
          <surname>Beckstette</surname>
          <given-names>Michael</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>beckstette@zbh.uni-hamburg.de</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Center for Bioinformatics, University of Hamburg, Bundesstrasse 43, 20146 Hamburg, Germany</aff>
    <aff id="I2"><label>2</label>Chair for Bioinformatics, University of Freiburg, Georges-Köhler-Allee 106, 79110 Freiburg, Germany</aff>
    <aff id="I3"><label>3</label>Computer Science and Artificial Intelligence Lab, Massachusetts Institute of Technology, Cambridge, MA 02139, USA</aff>
    <pub-date pub-type="collection">
      <year>2011</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>27</day>
      <month>5</month>
      <year>2011</year>
    </pub-date>
    <volume>12</volume>
    <fpage>214</fpage>
    <lpage>214</lpage>
    <history>
      <date date-type="received">
        <day>10</day>
        <month>12</month>
        <year>2010</year>
      </date>
      <date date-type="accepted">
        <day>27</day>
        <month>5</month>
        <year>2011</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright ©2011 Meyer et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2011</copyright-year>
      <copyright-holder>Meyer et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/12/214"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>The secondary structure of RNA molecules is intimately related to their function and often more conserved than the sequence. Hence, the important task of searching databases for RNAs requires to match sequence-structure patterns. Unfortunately, current tools for this task have, in the best case, a running time that is only linear in the size of sequence databases. Furthermore, established index data structures for fast sequence matching, like suffix trees or arrays, cannot benefit from the complementarity constraints introduced by the secondary structure of RNAs.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We present a novel method and readily applicable software for time efficient matching of RNA sequence-structure patterns in sequence databases. Our approach is based on affix arrays, a recently introduced index data structure, preprocessed from the target database. Affix arrays support bidirectional pattern search, which is required for efficiently handling the structural constraints of the pattern. Structural patterns like stem-loops can be matched inside out, such that the loop region is matched first and then the pairing bases on the boundaries are matched consecutively. This allows to exploit base pairing information for search space reduction and leads to an expected running time that is sublinear in the size of the sequence database. The incorporation of a new chaining approach in the search of RNA sequence-structure patterns enables the description of molecules folding into complex secondary structures with multiple ordered patterns. The chaining approach removes spurious matches from the set of intermediate results, in particular of patterns with little specificity. In benchmark experiments on the Rfam database, our method runs up to two orders of magnitude faster than previous methods.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>The presented method's sublinear expected running time makes it well suited for RNA sequence-structure pattern matching in large sequence databases. RNA molecules containing several stem-loop substructures can be described by multiple sequence-structure patterns and their matches are efficiently handled by a novel chaining method. Beyond our algorithmic contributions, we provide with <italic>Structator </italic>a complete and robust open-source software solution for index-based search of RNA sequence-structure patterns. The <italic>Structator </italic>software is available at <ext-link ext-link-type="uri" xlink:href="http://www.zbh.uni-hamburg.de/Structator">http://www.zbh.uni-hamburg.de/Structator</ext-link>.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>The discovery of new roles of non-coding RNAs (ncRNAs) has made them of central research interest in molecular biology [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>]. Like proteins, ncRNA sequences that have evolved from a common ancestor can be grouped into families. For instance, the Rfam database [<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B4">4</xref>] release 10.0 compiles 1,446 such families. Members of a family share, to different degrees, sequence and structure similarity. In many cases, however, the members of a family share only few sequence features, but share by far more specific structural and functional properties. Prominent examples of such cases are tRNAs and microRNA precursors.</p>
    <p>In this paper, we consider the problem of searching nucleotide databases for occurrences of RNA family members. As sequence similarity is often remote even within well-established RNA families, we cannot rely on pure sequence alignment and related techniques for this task. Indeed, it has been shown that sequence alignments of structured RNAs fail at pairwise sequence identities below about 60% [<xref ref-type="bibr" rid="B5">5</xref>]. Therefore, we briefly review nucleotide database search methods that make use of sequence and structure information. There are general sequence-structure alignment tools, which determine structural similarities and derive consensus structure patterns for RNAs that are too diverse to be alignable at sequence level. We identify two classes of such tools. The first class, with <italic>RNAforrester </italic>[<xref ref-type="bibr" rid="B6">6</xref>] and <italic>MARNA </italic>[<xref ref-type="bibr" rid="B7">7</xref>] being the main representatives, require a known or predicted secondary structure for both sequences as input. However, they suffer from the low quality of secondary structure prediction, especially if the boundary of the RNA elements are not exactly known. The second class of methods are derivatives of the Sankoff algorithm [<xref ref-type="bibr" rid="B8">8</xref>], which provides a general solution to the problem of simultaneously computing an alignment and the common secondary structure of the two aligned sequences. Due to its high complexity (<inline-formula><inline-graphic xlink:href="1471-2105-12-214-i1.gif"/></inline-formula>time and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i2.gif"/></inline-formula> memory) several variants of this approach have been introduced such as <italic>foldalign </italic>[<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B10">10</xref>], <italic>dynalign </italic>[<xref ref-type="bibr" rid="B11">11</xref>] and <italic>LocaRNA </italic>[<xref ref-type="bibr" rid="B12">12</xref>]. Still, these tools have a time complexity that is generally too high for a rapid database search. Thus, more specialized tools for searching RNA families in nucleotide databases have been introduced. Tools like <italic>RNAMotif </italic>[<xref ref-type="bibr" rid="B13">13</xref>], <italic>RNAMOT </italic>[<xref ref-type="bibr" rid="B14">14</xref>], <italic>RNABOB </italic>[<xref ref-type="bibr" rid="B15">15</xref>], <italic>RNAMST </italic>[<xref ref-type="bibr" rid="B16">16</xref>], <italic>PatScan </italic>[<xref ref-type="bibr" rid="B17">17</xref>], and <italic>PatSearch </italic>[<xref ref-type="bibr" rid="B18">18</xref>] are based on motif descriptors defining primary and secondary structure properties of the families to be searched for. They provide a language for defining descriptors and a method to search with these in large nucleotide databases. For these tools, the motif descriptor for a family has to be extracted externally from other information (such as a multiple sequence-structure alignment) about the specific RNA family. There are also tools that automatically derive descriptors from structure-annotated sequences or a multiple sequence alignment of related RNA sequences such as <italic>Infernal </italic>[<xref ref-type="bibr" rid="B19">19</xref>,<xref ref-type="bibr" rid="B20">20</xref>], <italic>RSEARCH </italic>[<xref ref-type="bibr" rid="B21">21</xref>], and <italic>PHMMTS </italic>[<xref ref-type="bibr" rid="B22">22</xref>]. They use variants of stochastic context-free grammars as descriptors, whereas <italic>ERPIN </italic>[<xref ref-type="bibr" rid="B23">23</xref>] uses sequential and structural profiles. Despite being fast compared to other methods, descriptor-based tools available today have a running time that is, in the best case, linear in the size of the target sequence database. This makes their application challenging when it comes to large sequence databases. A solution with sublinear running time would require index data structures. However, widely used index structures like suffix trees [<xref ref-type="bibr" rid="B24">24</xref>] or arrays [<xref ref-type="bibr" rid="B25">25</xref>] or the FM-index [<xref ref-type="bibr" rid="B26">26</xref>] perform badly on typical RNA sequence-structure patterns, because they cannot take advantage of the RNA structure information. Here, we present a fast descriptor-based method and software for RNA sequence-structure pattern matching. The method consists of initially building an affix array [<xref ref-type="bibr" rid="B27">27</xref>], i.e. an index data structure of the target database. Affix arrays cope well with structural pattern constraints by allowing for an efficient matching order of the bases constituting the pattern. Structurally symmetric patterns like stem-loops can be matched inside out, such that first the loop region is matched and, in subsequent extensions, pairing positions on the boundaries are matched consecutively. Because the matched substring is extended to the left and to the right, this pattern matching scheme is known as bidirectional search. Unlike traditional left-to-right search where the two substrings constituting the stem region of the pattern are matched sequentially, in bidirectional search, base complementarity constraints are checked as early as possible. This leads to a significant reduction of the search space that has to be explored and in turn to a reduced running time. We note that bidirectional search for RNA sequence-structure patterns was also presented by Mauri et al. in [<xref ref-type="bibr" rid="B28">28</xref>]. However, their method uses affix trees [<xref ref-type="bibr" rid="B29">29</xref>] instead of the more memory efficient affix arrays. Affix trees require with approximately 45 bytes per input symbol more than twice the memory of affix arrays (18 bytes per input symbol), making their application infeasible on a large scale. Moreover, their method traverses the affix tree in a breadth-first manner, leading to a space requirement that grows exponentially with increasing reading depth. We instead employ a depth-first search algorithm whose space requirement is only proportional to the length of the searched substring.</p>
    <p>The affix array directly supports the search for sequence-structure patterns that describe sequence-structure motifs with non-branching structure, for example stem-loops. In contrast, e.g. the search for stems closing a multi-loop is not directly supported. Nevertheless, even for RNA containing multi-loops, the affix array can still speed up the search. Our general approach for finding RNA families with branching structure is to describe each stem-loop substructure by a sequence-structure pattern. Each of these patterns is matched independently using the affix array. Then, with a new efficient chaining algorithm, we compute chains of matches such that the chained matches reflect the order of occurrence of the respective patterns in the molecule. Note that complex structures containing one or more multi-loops can be expected to contain sufficiently many non-branching patterns, such that the proposed chaining strategy identifies true matches with high specificity.</p>
    <p>For a better understanding of the concepts underlying our method, we begin with formalizing RNA structural motifs. We then describe the concepts and ideas of affix arrays and show how to use them in an algorithm for fast bidirectional search for sequence-structure patterns. After presenting a detailed complexity analysis of the algorithm, we proceed with a detailed description and analysis of a novel method for computing chains of sequence-structure pattern matches. Finally, we benchmark and validate our method in several experiments.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Preliminaries</title>
      <p>A <italic>sequence S </italic>of length <italic>n </italic>= |<italic>S</italic>| over an alphabet <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i3.gif"/></inline-formula> is a juxtaposition of <italic>n </italic>elements (<italic>characters</italic>) from the set <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i3.gif"/></inline-formula>. <italic>S</italic>[<italic>i</italic>], 0 ≤ <italic>i &lt; n </italic>denotes the <italic>character of S at position i</italic>. Let <italic>ε </italic>denote the empty sequence, the only sequence of length 0. By <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i4.gif"/></inline-formula> we denote the set of sequences of length <italic>n </italic>≥ 0 over <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i3.gif"/></inline-formula>. The set of all possible sequences over <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i3.gif"/></inline-formula> including the empty sequence <italic>ε </italic>is denoted by <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i5.gif"/></inline-formula>.</p>
      <p>For a sequence <italic>S </italic>= <italic>S</italic>[0]<italic>S</italic>[1] ... <italic>S</italic>[<italic>n </italic>- 1] and 0 ≤ <italic>i </italic>≤ <italic>j &lt; n</italic>, <italic>S</italic>[<italic>i</italic>..<italic>j</italic>] denotes the <italic>substring S</italic>[<italic>i</italic>]<italic>S</italic>[<italic>i </italic>+ 1] ... <italic>S</italic>[<italic>j</italic>] of <italic>S</italic>. We denote the <italic>reverse sequence </italic>of <italic>S </italic>with <italic>S</italic><sup>-1 </sup>= <italic>S</italic>[<italic>n </italic>- 1]<italic>S</italic>[<italic>n </italic>- 2] ... <italic>S</italic>[0]. For <italic>S </italic>= <italic>uv</italic>, <italic>u </italic>and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i6.gif"/></inline-formula>, <italic>u </italic>is a <italic>prefix </italic>of <italic>S</italic>, and <italic>v </italic>is a <italic>suffix </italic>of <italic>S</italic>. The <italic>k</italic>-th suffix of <italic>S </italic>starts at position <italic>k</italic>, while the <italic>k</italic>-th prefix of <italic>S </italic>ends at <italic>k</italic>. Note that the 0-th suffix of <italic>S </italic>is <italic>S </italic>itself and that <italic>S</italic>[0] is the 0-th prefix of <italic>S</italic>. The <italic>k</italic>-th <italic>reverse prefix </italic>of <italic>S </italic>is the <italic>k</italic>-th suffix of <italic>S</italic><sup>-1</sup>. For 0 ≤ <italic>k </italic>&lt;<italic>n</italic>, <italic>S<sub>k </sub></italic>denotes the <italic>k</italic>-th suffix of <italic>S</italic>, and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i7.gif"/></inline-formula>, denotes the <italic>k</italic>-th reverse prefix of <italic>S</italic>.</p>
      <p>Let <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i3.gif"/></inline-formula> denote the <italic>RNA alphabet </italic>{<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>U</italic>}. Its characters code for the nucleotides adenine (A), cytosine (C), guanine (G), and uracil (U). In the following we fix a sequence <italic>S </italic>over the RNA alphabet <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i3.gif"/></inline-formula>. For stating the space requirements of our index structures, we assume that |<italic>S</italic>|&lt; 2<sup>32</sup>, such that sequence positions and lengths can be stored in 4 bytes.</p>
    </sec>
    <sec>
      <title>RNA structural motifs</title>
      <p>RNA molecules can form complex secondary structures consisting of different structural elements like stem-loops with or without bulges or internal loops. See Figure <xref ref-type="fig" rid="F1">1</xref> for an overview of some secondary structure elements. Such elements are often important for the function of the molecule and are structurally conserved throughout evolution. The secondary structure is formed by Watson-Crick pairing of complementary bases and also by the slightly weaker wobble pairs. We say that two bases <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i8.gif"/></inline-formula> are <italic>complementary </italic>and can form a <italic>base pair </italic>if and only if <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i9.gif"/></inline-formula>. A <italic>non-crossing RNA structure R of length m </italic>is a set of <italic>base pairs </italic>(<italic>i</italic>, <italic>j</italic>), 0 ≤ <italic>i &lt; j &lt; m</italic>, stating that the base at position <italic>i </italic>pairs with the base at position <italic>j</italic>, such that for all (<italic>i</italic>, <italic>j</italic>), (<italic>i'</italic>, <italic>j'</italic>) ∈ <italic>R</italic>: <italic>i &lt; i' </italic>&lt;<italic>j' </italic>&lt;<italic>j </italic>or <italic>i' </italic>&lt;<italic>i &lt; j &lt; j' </italic>or <italic>i &lt; j &lt; i' </italic>&lt;<italic>j' </italic>or <italic>i' </italic>&lt;<italic>j' </italic>&lt;<italic>i &lt; j</italic>. For the algorithms and methods presented in this paper we only consider this class of structures. For an example of such an RNA secondary structure see Figure <xref ref-type="fig" rid="F1">1</xref>. An important structural motif occurring in many RNA molecules is the <italic>stem-loop </italic>structure. We call <italic>R </italic>a <italic>stem-loop </italic>RNA structure if and only if for all (<italic>i</italic>, <italic>j</italic>), (<italic>i'</italic>, <italic>j'</italic>) ∈ <italic>R </italic>: <italic>i &lt; i' </italic>&lt;<italic>j' </italic>&lt;<italic>j </italic>or <italic>i' </italic>&lt;<italic>i &lt; j &lt; j'</italic>. Note that due to our definition a stem-loop can contain bulges and interior loops (see Figure <xref ref-type="fig" rid="F1">1</xref>). We equivalently call such a structure <italic>non-branching</italic>. In Figure <xref ref-type="fig" rid="F1">1</xref>, such stem-loop structures occur as substructures.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Secondary structure elements of an RNA molecule represented by a base-pair graph (left) and as arc-annotated sequence (right)</bold>. The depicted structure contains three stem-loop substructures. Observe that all arcs representing base pairings are <italic>non-crossing </italic>and stem-loop substructures can contain interior loops and bulges. Hence this molecule forms a <italic>non-crossing </italic>secondary structure that does not contain higher order structural elements like pseudoknots. Secondary structure drawings were generated with the <italic>VARNA </italic>program [<xref ref-type="bibr" rid="B55">55</xref>].</p>
        </caption>
        <graphic xlink:href="1471-2105-12-214-1"/>
      </fig>
      <p>A <italic>structure string H </italic>is a sequence over the alphabet <bold>{</bold>., <bold>(</bold>,<bold>)</bold><bold>}</bold> with an equal number of characters (and ). There is a bijection between the set of (non-crossing) RNA structures <italic>R </italic>and the set of structure strings <italic>H</italic>, both of length <italic>m</italic>, such that for each base pair (<italic>i</italic>, <italic>j</italic>) ∈ <italic>R</italic>, <italic>H</italic>[<italic>i</italic>] = (and <italic>H</italic>[<italic>j</italic>] = ), and <italic>H</italic>[<italic>r</italic>] = . for positions <italic>r</italic>, 0 ≤ <italic>r &lt; m</italic>, that do not occur in any base pair of <italic>R</italic>, i.e. <italic>r </italic>≠ <italic>i </italic>∧ <italic>r </italic>≠ <italic>j </italic>for all (<italic>i</italic>, <italic>j</italic>) ∈ <italic>R</italic>. Due to this equivalence we identify both representations.</p>
      <p>Let Φ = {R, Y, M, K, W, S, B, D, H, V, N} be a set of characters. The IUPAC nucleotide base code introduces the characters in Φ to code nucleotide ambiguity and assigns a specific character class <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i10.gif"/></inline-formula> to each <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i11.gif"/></inline-formula>. In particular, for <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i12.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i13.gif"/></inline-formula>. A <italic>sequence pattern </italic>is a sequence <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i14.gif"/></inline-formula>. Let <italic>m </italic>denote its length |<italic>P</italic>|. An <italic>occurrence </italic>of <italic>P </italic>in a sequence <italic>S </italic>is a position <italic>i</italic>, 0 ≤ <italic>i &lt; n</italic>, such that <italic>P</italic>[<italic>k</italic>] = <italic>S</italic>[<italic>i </italic>+ <italic>k</italic>] with <italic>S</italic>[<italic>i </italic>+ <italic>k</italic>] ∈ <italic>φ</italic>(<italic>P</italic>[<italic>k</italic>]) for all 0 ≤ <italic>k &lt; m</italic>. An <italic>RNA sequence-structure pattern (RSSP) </italic><inline-formula><inline-graphic xlink:href="1471-2105-12-214-i15.gif"/></inline-formula> of length <italic>m </italic>is a pair of a <italic>sequence pattern P </italic>and a <italic>structure string R</italic>, both of length <italic>m</italic>. A <italic>match </italic>or <italic>occurrence </italic>of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i16.gif"/></inline-formula> of length <italic>m </italic>in an RNA sequence <italic>S </italic>is an occurrence <italic>i </italic>of <italic>P </italic>in <italic>S</italic>, such that for all base pairs (<italic>l</italic>, <italic>r</italic>) ∈ <italic>R</italic>: <italic>S</italic>[<italic>i </italic>+ <italic>l</italic>] and <italic>S</italic>[<italic>i </italic>+ <italic>r</italic>] are complementary. Furthermore, define <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i17.gif"/></inline-formula> as a mapping of a character <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i18.gif"/></inline-formula> to the set of its complementary characters in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i3.gif"/></inline-formula>, i.e. <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i19.gif"/></inline-formula>.</p>
      <p>In this paper, structures described by RSSPs are non-branching.</p>
    </sec>
    <sec>
      <title>The affix array data structure</title>
      <p>In [<xref ref-type="bibr" rid="B27">27</xref>] the theoretical concept of an index data structure called <italic>affix array </italic>is described. This index structure supports efficient unidirectional as well as bidirectional searches and is more space efficient than the affix tree [<xref ref-type="bibr" rid="B29">29</xref>,<xref ref-type="bibr" rid="B30">30</xref>]. The term <italic>unidirectional search </italic>refers to the search for occurrences of a sequence pattern where the pattern characters are compared with sequence characters in a left-to-right (right-to-left) order, i.e. the already compared (matched) prefix (suffix), of the pattern is extended to the right (left). Notably, a change of the direction is not possible.</p>
      <p>When searching for occurrences of sequence-structure patterns, however, unidirectional search cannot exploit the complementarity condition on base paired pattern positions. To utilize this condition as effectively as possible, both positions of a base pair need to be accessed immediately after each other. This is enabled by <italic>bidirectional search</italic>, which refers to methods where the direction of the match extension can be changed freely. Figure <xref ref-type="fig" rid="F2">2</xref> illustrates the order of the character comparisons of a sequence-structure pattern in the unidirectional and bidirectional searches.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Unidirectional (left) and bidirectional (right) searches for the RNA sequence-structure pattern (RSSP) <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i125.gif"/></inline-formula> with <italic>P </italic>= NNNUGCUNNN and <italic>R </italic>= (((....))), which represents a stem-loop structure of length <italic>m </italic>= 10</bold>. The numbers indicate the order in which the pattern characters are matched against the target sequence. In the unidirectional search, the characters are matched in a single direction, beginning (ending) with a character in <italic>φ</italic>(<italic>P</italic>[0]) (<italic>φ</italic>(<italic>P</italic>[<italic>m </italic>- 1])). In the bidirectional search, the loop region of the pattern can be matched first. Then, pairing bases are matched consecutively by switching the search direction, represented by the red arrows.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-214-2"/>
      </fig>
      <p>Until now, affix arrays have received little attention in bioinformatics. Presumably, this has been due to the lack of an open and robust implementation. As a consequence, their potential for efficient database search with RSSPs has hardly been recognized and the details of this data structure are not widely known in the field. Therefore, we briefly recall the basic ideas of the affix array, which constitutes the central component of our <italic>Structator </italic>approach.</p>
      <p>For notational convenience, we define <italic>S</italic><sup>F </sup>= <italic>S </italic>and <italic>S</italic><sup>R </sup>= <italic>S</italic><sup>-1</sup>. We use <italic>S</italic><sup><italic>X </italic></sup>for statements that apply to <italic>S</italic><sup>F </sup>and <italic>S</italic><sup>R</sup>. The subscript <italic>X </italic>is used for other notions depending on <italic>S</italic><sup>F </sup>and <italic>S</italic><sup>R </sup>in an analogous way. Furthermore, we introduce the notation <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i20.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i21.gif"/></inline-formula>. We reserve a character <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i22.gif"/></inline-formula>, called <italic>terminator symbol</italic>, for marking the end of a sequence. $ is lexicographically larger than all the characters in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i3.gif"/></inline-formula>. The affix array data structure of a sequence <italic>S </italic>is composed of six tables, namely suf<sub>F </sub>and suf<sub>R</sub>, lcp<sub>F </sub>and lcp<sub>R</sub>, and aflk<sub>F </sub>and aflk<sub>R</sub>. They are called <italic>suffix</italic>, <italic>longest common prefix</italic>, and <italic>affix link arrays </italic>of <italic>S</italic><sup>F </sup>and <italic>S</italic><sup>R</sup>, respectively. Table suf<sub>R </sub>is also known as <italic>reverse prefix array</italic>. suf<italic><sub>X </sub></italic>is an array of integers in the range 0 to <italic>n </italic>specifying the lexicographic order of the <italic>n </italic>+ 1 suffixes of the string <italic>S</italic><sup><italic>X</italic></sup>$. That is, <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i23.gif"/></inline-formula> is the sequence of suffixes of <italic>S<sup>X</sup></italic>$ in ascending lexicographic order. Each of the tables suf<sub>F </sub>and suf<sub>R </sub>requires 4<italic>n </italic>bytes and can be constructed in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula> time and space [<xref ref-type="bibr" rid="B31">31</xref>]. In practice non-linear time [<xref ref-type="bibr" rid="B32">32</xref>,<xref ref-type="bibr" rid="B33">33</xref>] construction algorithms are often used as they are faster and require less space. lcp<italic><sub>X </sub></italic>is a table in the range 0 to <italic>n </italic>such that lcp<italic><sub>X </sub></italic>[0] = 0, and lcp<italic><sub>X </sub></italic>[<italic>i</italic>] is the length of the longest common prefix between <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i25.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i26.gif"/></inline-formula> for 1 ≤ <italic>i </italic>≤ <italic>n</italic>. Each of the tables lcp<sub>F </sub>and lcp<sub>R </sub>requires <italic>n </italic>bytes and store entries with value up to 255, whereas occasional larger entries are stored in an exception table using 8 bytes per entry [<xref ref-type="bibr" rid="B34">34</xref>]. More space efficient representations of the lcp table are possible (see [<xref ref-type="bibr" rid="B35">35</xref>]). The construction of lcp<sub>F </sub>and lcp<sub>R </sub>can be accomplished in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula> time and space given suf<sub>F </sub>and suf<sub>R </sub>[<xref ref-type="bibr" rid="B36">36</xref>]. In contrast to [<xref ref-type="bibr" rid="B27">27</xref>] where affix arrays were described using a terminology derived from tree-like data structures, we explain the underlying concepts of this data structure in terms of intervals in the suffix array suf<italic><sub>X </sub></italic>. Two important concepts of affix arrays are suffix-intervals and lcp-intervals. An interval [<italic>i</italic>..<italic>j</italic>] representing the set of suffixes <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i27.gif"/></inline-formula>, 0 ≤ <italic>i </italic>≤ <italic>j </italic>≤ <italic>n</italic>, of <italic>width j </italic>- <italic>i </italic>+ 1, is a <italic>suffix-interval </italic>in suf<italic><sub>X </sub></italic>with <italic>depth (prefix length) ℓ </italic>∈ {0,..., <italic>n</italic>}, or <italic>ℓ-suffix-interval</italic>, denoted <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>], if and only if the following three conditions hold:</p>
      <p>1. lcp<italic><sub>X </sub></italic>[<italic>i</italic>] &lt;<italic>ℓ</italic>;</p>
      <p>2. lcp<italic><sub>X </sub></italic>[<italic>j </italic>+ 1] &lt;<italic>ℓ</italic>; and</p>
      <p>3. lcp<italic><sub>X </sub></italic>[<italic>k</italic>] ≥ <italic>ℓ </italic>for all <italic>k </italic>∈ {<italic>i </italic>+ 1,..., <italic>j</italic>}.</p>
      <p>We call a suffix-interval <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>] in suf<sub><italic>X </italic></sub><italic>lcp-interval </italic>in suf<italic><sub>X </sub></italic>with <italic>lcp-value ℓ </italic>∈ {0,..., <italic>n</italic>}, or <italic>ℓ-interval</italic>, if and only if <italic>i &lt; j </italic>and lcp<italic><sub>X </sub></italic>[<italic>k</italic>] = <italic>ℓ </italic>for at least one <italic>k </italic>∈ {<italic>i </italic>+ 1,..., <italic>j</italic>}.</p>
      <p>For a suffix-interval <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>] in suf<italic><sub>X </sub></italic>, we denote the common prefix of length <italic>ℓ </italic>of its suffixes <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i27.gif"/></inline-formula> by <italic>δ<sub>X</sub></italic>(<italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>]) = <italic>S<sup>X</sup></italic>[suf<italic><sub>X </sub></italic>[<italic>i</italic>]..suf<italic><sub>X </sub></italic>[<italic>i</italic>] + <italic>ℓ </italic>- 1]. In case of an lcp-interval <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>] in suf<italic><sub>X </sub></italic>, <italic>δ<sub>X </sub></italic>(<italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>]) is the longest common prefix of all suffixes in this interval.</p>
      <p>In summary, a suffix-interval <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>] in suf<italic><sub>X </sub></italic>describes simultaneously:</p>
      <p>• A location in the index structure suf<italic><sub>X </sub></italic>by interval borders <italic>i </italic>and <italic>j </italic>and depth <italic>ℓ</italic>. For an example, see the yellow marked region in Figure <xref ref-type="fig" rid="F3">3</xref> which corresponds to the suffix-interval 4 - [4..6] in suf<sub>F</sub>.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Affix array for <italic>S </italic>= AUAGCUGCUGCUGCA</bold>. Some lcp-intervals are marked by rectangles and the affix links from an lcp-interval to its reverse interval are represented by arcs. The solid arc points in two directions, from the the lcp-interval <italic>q </italic>= 5 - [8..10] in suf<sub>F </sub>(on the left-hand side) to its reverse interval <italic>q</italic><sup>-1 </sup>= 5 - [4..6] in suf<sub>R </sub>(on the right-hand side) and vice versa. That is, <italic>q </italic>= (<italic>q</italic><sup>-1</sup>)<sup>-1 </sup>(see Lemma 2). The dotted arc points in only one direction, from the lcp-interval <italic>q </italic>= 4 - [4..6] in suf<sub>F </sub>to its reverse interval <italic>q</italic><sup>-1 </sup>= 5 - [4..6] in suf<sub>R</sub>. In this case, the reverse of <italic>q</italic><sup>-1 </sup>is (<italic>q</italic><sup>-1</sup>)<sup>-1 </sup>= 5 - [8..10], and <italic>q ≠ </italic>(<italic>q</italic><sup>-1</sup>)<sup>-1</sup>.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-214-3"/>
      </fig>
      <p>• A (lexicographically ordered) sequence of suffixes <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i27.gif"/></inline-formula>. For an example, consider the lexicographically ordered sequence <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i28.gif"/></inline-formula> of suffixes in the suffix-interval 4 - [4..6] in suf<sub>F </sub>in Figure <xref ref-type="fig" rid="F3">3</xref>.</p>
      <p>• A substring of <italic>S</italic><sup><italic>X </italic></sup>of length <italic>ℓ</italic>, namely <italic>δ<sub>X</sub></italic>(<italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>]). That is, for the suffix-interval 4 - [4..6] in suf<sub>F </sub>in Figure <xref ref-type="fig" rid="F3">3</xref>, <italic>δ</italic><sub>F</sub>(4 - [4..6]) = CUGC.</p>
      <p>• The occurrences of this substring in <italic>S<sup>X</sup></italic>, namely at positions suf<italic><sub>X </sub></italic>[<italic>i</italic>],..., suf<italic><sub>X </sub></italic>[<italic>j</italic>]. To give an example, consider Figure <xref ref-type="fig" rid="F3">3</xref> and observe that substring CUGC occurs at positions suf<sub>F</sub>
[4] = 10, suf<sub>F</sub>
[5] = 7, and suf<sub>F</sub>
[6] = 4 in <italic>S</italic><sup>F </sup>= AUAGCUGCUGCUGCA.</p>
      <p>For unidirectional left-to-right search of some pattern in <italic>S </italic>it is sufficient to process lcp-intervals only in suf<sub>F</sub>. For bidirectional pattern search using affix arrays, described in detail in the next section, we employ information from table suf<sub>F </sub>as well as suf<sub>R</sub>. Therefore, we need to associate information of one table to the other. This is done by linking intervals via tables aflk<sub>F </sub>and aflk<sub>R</sub>. We observe that there exists a mapping between lcp-intervals in suf<sub>F </sub>and suf<sub>R</sub>. This is stated by the following proven lemma [<xref ref-type="bibr" rid="B27">27</xref>].</p>
      <p><bold>Lemma 1 </bold><italic>For every lcp-interval q </italic>= <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>] <italic>in table </italic>suf<sub><italic>X </italic></sub><italic>there is exactly one lcp-interval q</italic><sup>-1 </sup>= <italic>ℓ' </italic>- [<italic>i'</italic>..<italic>j'</italic>] <italic>in table </italic><inline-formula><inline-graphic xlink:href="1471-2105-12-214-i29.gif"/></inline-formula><italic> called reverse lcp-interval of q, such that ℓ' </italic>≥ <italic>ℓ and the ℓ </italic>- 1<italic>-th prefix of </italic><inline-formula><inline-graphic xlink:href="1471-2105-12-214-i30.gif"/></inline-formula><italic> equals </italic>(<italic>δ</italic><sub><italic>X</italic></sub>(<italic>q</italic>))<sup>-1</sup>. <italic>The number of suffixes (prefixes) represented by q and q</italic><sup>-1 </sup><italic>are the same</italic>, <italic>i</italic>.<italic>e</italic>., <italic>j </italic>- <italic>i </italic>= <italic>j' </italic>- <italic>i'</italic>.</p>
      <p>We note that the equivalence <italic>q </italic>= (<italic>q</italic><sup>-1</sup>)<sup>-1 </sup>is not necessarily true. This is stated by the next lemma.</p>
      <p><bold>Lemma 2 </bold><italic>If the lcp-interval q</italic><sup>-1 </sup><italic>with depth ℓ' in </italic><inline-formula><inline-graphic xlink:href="1471-2105-12-214-i29.gif"/></inline-formula><italic> is the reverse of the lcp-interval q with depth ℓ in </italic>suf<italic><sub>X </sub>and ℓ </italic>= <italic>ℓ'</italic>, <italic>then q </italic>= (<italic>q</italic><sup>-1</sup>)<sup>-1</sup>. <italic>Otherwise</italic>, <italic>if ℓ' &gt; ℓ</italic>, <italic>then q </italic>≠ (<italic>q</italic><sup>-1</sup>)<sup>-1</sup>.</p>
      <p>The mapping between intervals in <italic>S</italic><sup>F </sup>and <italic>S</italic><sup>R </sup>is encoded in tables aflk<sub>F </sub>and aflk<sub>R </sub>as follows. Tables aflk<sub>F </sub>and aflk<sub>R </sub>store, for each lcp-interval in suf<sub>F </sub>and suf<sub>R </sub>respectively, a pointer to the reverse interval in the reverse tables <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i31.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i32.gif"/></inline-formula>. The position in the tables where the pointers are stored is determined by the function home<italic><sub>X </sub></italic>, defined as<disp-formula id="bmcM1"><label>(1)</label><graphic xlink:href="1471-2105-12-214-i33.gif"/></disp-formula></p>
      <p>where <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>] is an lcp-interval in suf<italic><sub>X </sub></italic>. Hence, the home position is one of two boundary positions. Strothmann [<xref ref-type="bibr" rid="B27">27</xref>] shows that home<italic><sub>X </sub></italic>([<italic>i</italic>..<italic>j</italic>]) ≠ home<italic><sub>X </sub></italic>([<italic>i'</italic>..<italic>j'</italic>]) for different lcp-intervals <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>] and <italic>ℓ' </italic>- [<italic>i'</italic>..<italic>j'</italic>].</p>
      <p>Table aflk<italic><sub>X </sub></italic>of string <italic>S<sup>X</sup></italic>$ with total length <italic>n </italic>+ 1 can now be defined as a table in the range 0 to <italic>n </italic>such that aflk<italic><sub>X </sub></italic>[home<italic><sub>X </sub></italic>(<italic>q</italic>)] = <italic>i'</italic>, where <italic>q </italic>is an lcp-interval in suf<italic><sub>X </sub></italic>and <italic>i' </italic>is the left border of the reverse interval <italic>q</italic><sup>-1 </sup>= [<italic>i'</italic>..<italic>j'</italic>] in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i29.gif"/></inline-formula>. We refer to the entries in table aflk<italic><sub>X </sub></italic>as <italic>affix links</italic>. Tables aflk<sub>F </sub>and aflk<sub>R </sub>occupy 4<italic>n </italic>bytes each. They can be computed by traversing the lcp-intervals in suf<italic><sub>X </sub></italic>while simultaneously looking for the corresponding reverse lcp-intervals in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i29.gif"/></inline-formula>. Locating reverse lcp-intervals can be accelerated by skp-tables. These tables, introduced in Beckstette <italic>et al. </italic>[<xref ref-type="bibr" rid="B37">37</xref>] and hereinafter referred to as skp<sub>F </sub>and skp<sub>R</sub>, can be constructed in linear time [<xref ref-type="bibr" rid="B38">38</xref>] and allow one to quickly skip intervals in suf<italic><sub>X </sub></italic>(for details, see [<xref ref-type="bibr" rid="B37">37</xref>]).</p>
      <p>The construction of tables aflk<sub>F </sub>and aflk<sub>R </sub>takes <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i34.gif"/></inline-formula> time. Although the use of skp-tables requires additional 2 × 4<italic>n </italic>bytes of memory, they considerably reduce the construction times of tables aflk<sub>R </sub>and aflk<sub>R </sub>in practice. We note that Strothmann [<xref ref-type="bibr" rid="B27">27</xref>] describes a linear time construction algorithm for tables aflk<sub>F </sub>and aflk<sub>R</sub>, which employs suffix link and child-tables [<xref ref-type="bibr" rid="B34">34</xref>] and an additional table. Altogether these tables require together at least additional 7<italic>n </italic>bytes of space. Moreover, even without applying the skp-table based acceleration, Strothmann states that the quadratic time construction algorithm is fast in practice. An example of the affix array for sequence <italic>S </italic>= AUAGCUGCUGCUGCA highlighted with some of its lcp-intervals connected to the respective reverse interval via the aflk<italic><sub>X </sub></italic>table is shown in Figure <xref ref-type="fig" rid="F3">3</xref>.</p>
      <p>Because affix links in table aflk<italic><sub>X </sub></italic>are only defined for lcp-intervals but not suffix-intervals in general, which we require in bidirectional search, we introduce the concept of <italic>affix-intervals</italic>. Affix-intervals are similar to affix nodes as defined in [<xref ref-type="bibr" rid="B27">27</xref>]. An affix-interval in suf<italic><sub>X </sub></italic>is a triple <italic>v </italic>= 〈<italic>k</italic>, <italic>q</italic>, <italic>X</italic>〉, where <italic>k </italic>is an integer designated <italic>context </italic>of <italic>v </italic>and <italic>q </italic>is a suffix-interval in suf<italic><sub>X </sub></italic>.</p>
      <p>An affix-interval <italic>v </italic>= 〈<italic>k</italic>, <italic>q</italic>, <italic>X</italic>〉 in suf<italic><sub>X </sub></italic>, with <italic>q </italic>= <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>], <italic>ℓ &gt;</italic>0, -<italic>m &lt; k &lt; ℓ</italic>, describes a substring <italic>ω<sub>X</sub></italic>(<italic>v</italic>) of <italic>S<sup>X </sup></italic>of length <italic>ℓ </italic>- <italic>k</italic>, defined as the <italic>k</italic>-th suffix of <italic>δ<sub>X</sub></italic>(<italic>q</italic>), i.e. <italic>ω<sub>X</sub></italic>(<italic>v</italic>) = <italic>S<sup>X</sup></italic>[suf<italic><sub>X </sub></italic>[<italic>i</italic>] + <italic>k</italic>..suf<italic><sub>X </sub></italic>[<italic>i</italic>] + <italic>ℓ </italic>- 1]. At the same time <italic>v </italic>identifies all occurrences of <italic>ω<sub>X</sub></italic>(<italic>v</italic>) in <italic>S<sup>X</sup></italic>, namely the positions suf<italic><sub>X </sub></italic>[<italic>i</italic>] + <italic>k</italic>,..., suf<italic><sub>X </sub></italic>[<italic>j</italic>] + <italic>k</italic>.</p>
      <p>For <italic>v </italic> = 〈<italic>k</italic>, <italic>q</italic>, <italic>X</italic>〉, we therefore also use the notation <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i35.gif"/></inline-formula> if <italic>X </italic>= F and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i36.gif"/></inline-formula> if <italic>X </italic>= R. As an example, consider the affix-interval <italic>v </italic>= 〈1, 4 - [4..6], F〉 in suf<sub>F </sub>of the affix array shown in Figure <xref ref-type="fig" rid="F3">3</xref>. In this case, <italic>k </italic>= 1, <italic>q </italic>= 4 - [4..6], and <italic>X </italic>= F. <italic>v </italic>identifies all occurrences of substring <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i37.gif"/></inline-formula> in <italic>S</italic><sup>F </sup>at positions suf<sub>F</sub>
[4] + 1 = 11, suf<sub>F</sub>
[5] + 1 = 8, and suf<sub>F</sub>
[6] + 1 = 5. Observe that <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i37.gif"/></inline-formula> is the first suffix of <italic>δ</italic><sub>F</sub>(<italic>q</italic>) = CUGC due to context <italic>k </italic>= 1.</p>
    </sec>
    <sec>
      <title>Searching RNA databases for RSSPs with affix arrays</title>
      <p>Pattern matching using affix arrays means the sequential processing of characters in the pattern guiding the traversal of the data structure. This can be performed in either a traditional left-to-right order resulting in a unidirectional search or in a bidirectional way where character comparison is started at any position of the pattern extending the already matched substring of the pattern to the left or to the right. We will see that bidirectional search using alternating series of left and right extensions is very well suited for fast database search with RNA sequence-structure patterns (RSSPs) containing both paired and unpaired bases. In the following we will explain the two different traversal strategies underlying unidirectional and bidirectional search using affix arrays.</p>
      <sec>
        <title>Unidirectional traversal</title>
        <p>Let <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i38.gif"/></inline-formula> be a sequence pattern to be searched in <italic>S </italic>in a unidirectional left-to-right way using information from table suf<sub>F </sub>only. To search for <italic>P </italic>, we call the procedure <italic>unidir-search </italic>of Figure <xref ref-type="fig" rid="F4">4</xref> by <italic>unidir-search</italic>([0..|<italic>S</italic>|], <italic>P</italic>, 0). Therefore, in step 0 we start searching for the characters in <italic>φ</italic>(<italic>P</italic>[0]) in the suffix-interval <italic>q</italic><sub>0 </sub>= 0 - [0..<italic>n</italic>] in suf<sub>F</sub>, which represents all suffixes of <italic>S</italic>$. In each step <italic>k</italic>, <italic>k </italic>≥ 0, we locate the <italic>k </italic>+ 1-suffix-intervals <italic>q<sub>k </sub></italic>of maximal width, such that <italic>P </italic>[0..<italic>k </italic>- 1]<italic>d </italic>matches <italic>δ</italic><sub>F</sub>(<italic>q<sub>k</sub></italic>). For each <italic>d </italic>∈ <italic>φ</italic>(<italic>P </italic>[<italic>k</italic>]), this step is performed by a binary search in the suffix-interval <italic>q</italic><sub><italic>k</italic>-1 </sub>= <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>] for <italic>q<sub>k </sub></italic>= (<italic>ℓ </italic>+ 1) - [<italic>i'</italic>..<italic>j'</italic>], <italic>i </italic>≤ <italic>i' </italic>≤ <italic>j' </italic>≤ <italic>j</italic>, <italic>j' </italic>- <italic>i' </italic>maximal, and <italic>S</italic>[suf<sub>F</sub>[<italic>i'</italic>] + <italic>k</italic>] = <italic>d</italic>.</p>
        <fig id="F4" position="float">
          <label>Figure 4</label>
          <caption>
            <p><bold>Unidirectional search algorithm for searching for a sequence pattern <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i126.gif"/></inline-formula></bold>. Given the suffix array suf<sub>F </sub>of <italic>S</italic>, the procedure enumerates all occurrences of <italic>P </italic>in <italic>S </italic>when called by <italic>unidir-search</italic>([0..|<italic>S</italic>|], <italic>P</italic>, 0). In line 5, the suffix-interval <italic>q' </italic>is located by binary search in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i65.gif"/></inline-formula>.</p>
          </caption>
          <graphic xlink:href="1471-2105-12-214-4"/>
        </fig>
        <p>After <italic>m </italic>steps, if all <italic>q<sub>k </sub></italic>could be located, <italic>δ</italic><sub>F</sub>(<italic>q<sub>m</sub></italic>), <italic>q<sub>m </sub></italic>= <italic>m </italic>- [<italic>r</italic>..<italic>s</italic>], matches the pattern <italic>P </italic>and the occurrences suf<sub>F</sub>[<italic>r</italic>], suf<sub>F</sub>[<italic>r </italic>+ 1],..., suf<sub>F</sub>[<italic>s</italic>] of <italic>δ</italic><sub>F</sub>(<italic>q<sub>m</sub></italic>) are reported as occurrences of <italic>P </italic>in <italic>S</italic>. Note that in this approach the matched substring of <italic>S </italic>is extended only to the right and at each step <italic>k </italic>the occurrences of the already matched prefix are represented by a suffix-interval.</p>
      </sec>
      <sec>
        <title>Bidirectional traversal</title>
        <p>For the bidirectional search, we start at some position in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i39.gif"/></inline-formula> and then compare the pattern <italic>P </italic>character by character to the text, where we can freely switch between extending to the left or to the right. Note that as in the case of unidirectional search, ambiguous nucleotides <italic>x </italic>in the pattern can be handled by enumerating all characters <italic>c </italic>in the corresponding character class <italic>φ</italic>(<italic>x</italic>). We can focus on the situation in the search, where</p>
        <p>• a range <italic>r</italic>..<italic>r' </italic>(0 ≤ <italic>r </italic>≤ <italic>r' </italic>&lt;<italic>m</italic>) of the pattern <italic>P </italic>is already compared,</p>
        <p>• the occurrences of a substring <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i40.gif"/></inline-formula> of <italic>S </italic>matching <italic>P</italic>[<italic>r</italic>..<italic>r'</italic>] are represented by an affix-interval <italic>v </italic>= 〈<italic>k</italic>, <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>], <italic>X</italic>〉 in suf<italic><sub>X </sub></italic>, and</p>
        <p>• we want to extend <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i41.gif"/></inline-formula> either to the left or to the right by a sequence character <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i42.gif"/></inline-formula> (that matches the respective pattern character <italic>P</italic>[<italic>r </italic>- 1] or <italic>P</italic>[<italic>r' </italic>+ 1]). This will result in a new, extended affix-interval <italic>v<sub>x</sub></italic>.</p>
        <sec>
          <title>Switch of the search direction</title>
          <p>Like its suffix-interval, an affix-interval directly supports extension of the represented substring in only one direction, namely searching to the left for <italic>X </italic>= F and to the right for <italic>X </italic>= R. However, there are "corresponding" affix-intervals representing the same substring of <italic>S </italic>but allowing extension to the opposite direction.</p>
          <p>If the new search direction differs from the supported search direction of <italic>v</italic>, this <italic>switch of the search direction </italic>requires determining the corresponding affix-interval <italic>v' </italic>in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i29.gif"/></inline-formula> unless <italic>i </italic>= <italic>j </italic>or <italic>v </italic>has non-empty context <italic>k </italic>≠ 0. There are these two exceptions, since first if <italic>i </italic>= <italic>j</italic>, independently of the value of <italic>k</italic>, <italic>ω<sub>X</sub></italic>(<italic>v</italic>) is already a unique substring of <italic>S<sup>X</sup></italic>. Second, for a non-empty context <italic>k </italic>≠ 0, all occurrences of substring <italic>ω<sub>X</sub></italic>(<italic>v</italic>) in <italic>S</italic><sup><italic>X </italic></sup>are followed (if <italic>k </italic>&gt; 0) or preceded (if <italic>k </italic>&lt; 0) by the same substring <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i43.gif"/></inline-formula>.</p>
          <p>Let <italic>k </italic>= 0 and <italic>i &lt; j</italic>. The affix-interval <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i44.gif"/></inline-formula> in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i29.gif"/></inline-formula> is called the <italic>reverse affix-interval </italic>of <italic>v </italic>= 〈<italic>k</italic>, <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>], <italic>X</italic>〉 if and only if <italic>j' </italic>- <italic>i' </italic>= <italic>j </italic>- <italic>i</italic>, <italic>ℓ' </italic>≥ <italic>ℓ</italic>, and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i45.gif"/></inline-formula>. The interval boundaries <italic>i' </italic>and <italic>j' </italic>of <italic>v' </italic>are determined via a lookup in table aflk<italic><sub>X </sub></italic>. We set <italic>i' </italic>= aflk<italic><sub>X </sub></italic>[home<italic><sub>X </sub></italic>([<italic>i</italic>..<italic>j</italic>])] and <italic>j' </italic>= <italic>i' </italic>+ (<italic>j </italic>- <italic>i</italic>). Observe that <italic>ℓ </italic>is not necessarily the length of the longest common prefix of all suffixes in [<italic>i</italic>..<italic>j</italic>]. For this reason we define <italic>ℓ</italic><sub>lcp </sub>= <italic>min</italic>{lcp<italic><sub>X </sub></italic>[<italic>k</italic>] | <italic>i &lt; k </italic>≤ <italic>j</italic>} ≥ <italic>ℓ </italic>and compute the context of <italic>v' </italic>as <italic>k' </italic>= <italic>ℓ</italic><sub>lcp </sub>- <italic>ℓ</italic>. Further, we set <italic>ℓ' </italic>= <italic>ℓ</italic><sub>lcp</sub>. Hence the reverse affix-interval <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i44.gif"/></inline-formula> is well defined and <italic>v' </italic>is the required corresponding interval of <italic>v</italic>.</p>
        </sec>
        <sec>
          <title>Right/left <italic>c</italic>-extension of an affix-interval</title>
          <p>In our situation, <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i46.gif"/></inline-formula> represents the occurrences of a substring <italic>u </italic>of <italic>S </italic>matching <italic>P</italic>[<italic>r</italic>..<italic>r'</italic>].</p>
          <p>The <italic>right (left) extension of v by a character </italic><inline-formula><inline-graphic xlink:href="1471-2105-12-214-i42.gif"/></inline-formula>, also called <italic>c-extension of v</italic>, is an operation that computes the affix-interval <italic>v<sub>x </sub></italic>representing all occurrences of a substring <italic>uc </italic>(<italic>cu</italic>). It fails, if there is no such substring. We elaborate the cases for right extension. The cases for left extension are symmetric and therefore omitted. For right <italic>c</italic>-extension of <italic>v </italic>= 〈<italic>k</italic>, <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>], <italic>X</italic>〉, we determine the interval <italic>v<sub>x </sub></italic>= 〈<italic>k<sub>x</sub></italic>, <italic>ℓ<sub>x </sub></italic>- [<italic>i<sub>x</sub></italic>..<italic>j<sub>x</sub></italic>], <italic>X<sub>x</sub></italic>〉 with <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i47.gif"/></inline-formula>. The first two cases do not require switching the search direction.</p>
          <p>• Case <italic>X </italic>= F and <italic>i </italic>= <italic>j</italic>. <italic>u </italic>is a unique substring <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i41.gif"/></inline-formula> of <italic>S</italic>. If <italic>S</italic>[suf<sub>F</sub>[<italic>i</italic>] + <italic>ℓ</italic>] = <italic>c</italic>, then <italic>v<sub>x </sub></italic>= 〈<italic>k</italic>, (<italic>ℓ </italic>+ 1) - [<italic>i</italic>..<italic>j</italic>], F〉.</p>
          <p>• Case <italic>X </italic>= F and <italic>i &lt; j</italic>. We determine the minimal <italic>i<sub>x </sub></italic>≥ <italic>i </italic>and maximal <italic>j<sub>x </sub></italic>≤ <italic>j </italic>in suf<sub>F </sub>such that <italic>S</italic>[suf<sub>F</sub>[<italic>i<sub>x</sub></italic>] + <italic>ℓ</italic>] = <italic>c </italic>and <italic>S</italic>[suf<sub>F</sub>[<italic>j<sub>x</sub></italic>] + <italic>ℓ</italic>] = <italic>c </italic>by binary search in the suffix-interval <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>]. If <italic>i<sub>x </sub></italic>and <italic>j<sub>x </sub></italic>exist, we set <italic>v<sub>x </sub></italic>= 〈<italic>k</italic>, (<italic>ℓ </italic>+ 1) - [<italic>i<sub>x</sub></italic>..<italic>j<sub>x</sub></italic>], F〉.</p>
          <p>The following cases require switching the search direction.</p>
          <p>• Case <italic>X </italic>= R, <italic>i </italic>= <italic>j</italic>. We evaluate <italic>S</italic><sup>R</sup>[suf<sub>R</sub>[<italic>i</italic>] + <italic>k </italic>- 1]. If <italic>S</italic><sup>R</sup>[suf<sub>R</sub>[<italic>i</italic>] + <italic>k </italic>- 1] = <italic>c</italic>, set <italic>v<sub>x </sub></italic>= 〈<italic>k </italic>- 1, <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>], R〉.</p>
          <p>• Case <italic>X </italic>= R, <italic>i &lt; j</italic>, and <italic>k </italic>= 0. We first determine the reverse affix-interval <italic>v' </italic>= 〈<italic>k'</italic>, <italic>ℓ' </italic>- [<italic>i'</italic>..<italic>j'</italic>], F〉 of <italic>v </italic>via a switch of the search direction as described above. Then we compute the minimal <italic>i<sub>x </sub></italic>≥ <italic>i' </italic>and maximal <italic>j<sub>x </sub></italic>≤ <italic>j' </italic>via binary search, such that <italic>S</italic>[suf<sub>F</sub>[<italic>i<sub>x</sub></italic>] + <italic>ℓ'</italic>] = <italic>c </italic>and <italic>S</italic>[suf<sub>F</sub>[<italic>j<sub>x</sub></italic>] + <italic>ℓ'</italic>] = <italic>c</italic>. If <italic>i<sub>x </sub></italic>and <italic>j<sub>x </sub></italic>exist, we set <italic>v<sub>x </sub></italic>= 〈<italic>k'</italic>, (<italic>ℓ' </italic>+ 1) - [<italic>i<sub>x</sub></italic>..<italic>j<sub>x</sub></italic>], F〉.</p>
          <p>• Case <italic>X </italic>= R, <italic>i &lt; j</italic>, and <italic>k &gt;</italic>0. We evaluate the (<italic>k </italic>- 1)-th character of <italic>δ</italic><sub>R</sub>(<italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>]). That is, if <italic>δ</italic><sub>R</sub>(<italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>])[<italic>k </italic>- 1] = <italic>c</italic>, then we consume the context <italic>k </italic>by setting <italic>v<sub>x </sub></italic>= 〈<italic>k </italic>- 1, <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>], R〉.</p>
          <p>The operation fails if <italic>v<sub>x </sub></italic>cannot be determined.</p>
        </sec>
      </sec>
      <sec>
        <title>RSSP matching using affix arrays</title>
        <p>Searching a sequence <italic>S </italic>with an RNA sequence-structure pattern (RSSP) <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i48.gif"/></inline-formula> means to find the occurrences of <italic>P </italic>in <italic>S </italic>under the complementarity constraints imposed by the structure string <italic>R </italic>(cf. our definition of RSSP-occurrence). We introduce a search algorithm that checks for complementarity constraints as early as possible in bidirectional search to maximally reduce the search time due to this restriction.</p>
        <p>For further considerations, we will assume a special 'canonical' form for RSSPs, which we define in the following. Independently of a sequence <italic>S</italic>, each RSSP describes a set of pattern instances, i.e. the set of potential subsequences matching the pattern. Often, there are several patterns that describe the same set of instances. For example, the pattern (UNUACACGNR, ( ( ( . . . . ) ) ) ) describes the same set of instances as (UNUACACGNR, ( ( . . . . . . ) ) )  since the additional base pair (2, 7) in ( ( ( . . . . ) ) ) does not make the pattern more specific. We will define a pattern to be structure minimal if there is no, in this sense, equivalent pattern containing a true subset of the base pairs. An RSSP <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i48.gif"/></inline-formula> is <italic>structure minimal </italic>if and only if for all base pairs (<italic>i</italic>, <italic>j</italic>) ∈ <italic>R </italic>it holds that<disp-formula><graphic xlink:href="1471-2105-12-214-i49.gif"/></disp-formula></p>
        <p>Furthermore, a general pattern is called <italic>inconsistent </italic>if it does not have any instance. Formally, a pattern is <italic>consistent </italic>if and only if for each base pair (<italic>i, j</italic>) it holds that <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i50.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i51.gif"/></inline-formula>. An example of an inconsistent RSSP is <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i48.gif"/></inline-formula> with <italic>P </italic>= UAUACACGAN and <italic>R </italic>= ( ( . . . . . . ) ).<inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> is not consistent because there is a base pair (1, 8) ∈ <italic>R </italic>but the bases <italic>P</italic>[1] = A and <italic>P</italic>[8] = A are not complementary. An example of a structure minimal and consistent RSSP is (UNUACACGNR, ( ( . . . . . . ) ) ). Note that a pattern can be transformed into an equivalent structure minimal pattern and checked for consistency in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i53.gif"/></inline-formula> time. For complexity considerations, we can therefore safely assume that patterns are consistent and structure minimal.</p>
        <p>In this case, one can restrict the search space by comparing the two positions of each base pair immediately after each other. Due to this, the enumeration of characters matching the pattern symbols at each base pair can be restricted to the smaller number of complementary ones. In the search for a sequence-structure pattern this can reduce the number of enumerated combinations of matching characters exponentially. Thus, for structure minimal patterns (<italic>P, R</italic>), the non-branching structure <italic>R </italic>suggests a search strategy, i.e. an order of left and right extensions, which requires switching the search direction at every base pair but makes optimal use of the complementarity constraints due to the base pairs.</p>
        <p>Following this idea, Mauri and Pavesi [<xref ref-type="bibr" rid="B28">28</xref>] presented an algorithm for matching RNA stem-loop structures using affix trees. This algorithm explores the search space in a breadth-first manner, so memory use grows exponentially with increasing depth. Instead of an affix tree, we employ the more space efficient affix array data structure and use a depth-first search algorithm which only requires space for the search proportional to the length of the substring searched. The depth-first search for all occurrences of a stem-loop RSSP <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i48.gif"/></inline-formula> is performed by calling procedure <italic>bidir-search </italic>of Algorithm 2 (see Figure <xref ref-type="fig" rid="F5">5</xref>). Note that we explicitly support bulges and internal loops in the stem-loop pattern, i.e. we do not require perfect stacking of the base pairs but allow general non-branching structures.</p>
        <fig id="F5" position="float">
          <label>Figure 5</label>
          <caption>
            <p><bold>Bidirectional recursive RSSP matching using an affix array</bold>. Procedure <italic>bidir-search </italic>finds all matches of a given RSSP (<italic>P, R</italic>), beginning the pattern extensions from any position in the loop region or any position in a completely unpaired pattern. In each call, parameter <italic>v </italic>denotes the affix-interval representing matches of the pattern substring <italic>P</italic>[<italic>r </italic>+ 1..<italic>r' </italic>- 1], 0 ≤ <italic>r </italic>≤ <italic>r' </italic>&lt;<italic>m </italic>satisfying the structural constraints imposed by <italic>R</italic>[<italic>r </italic>+ 1..<italic>r' </italic>- 1]. The procedure takes care to change the search direction only as often as necessary, in particular it changes the direction only once per base pair.</p>
          </caption>
          <graphic xlink:href="1471-2105-12-214-5"/>
        </fig>
        <p>In our algorithm, we switch the search direction only once per base pair when matching the stem region of the pattern, thus halving the number of lookups in the affix link tables compared to a naive algorithm without this optimization. This was also observed by Strothmann [<xref ref-type="bibr" rid="B27">27</xref>] whose algorithm did not support RSSPs containing bulges and internal loops.</p>
        <p>To match <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> we call procedure <italic>bidir-search </italic>initially as <italic>bidir-search</italic>(〈0, 0 - [0..<italic>n</italic>], F〉, <italic>r</italic><sub>0 </sub>- 1, <italic>r</italic><sub>0</sub>), where 〈0, 0 - [0..<italic>n</italic>], F〉 is an affix-interval and <italic>r</italic><sub>0 </sub>is any position in the loop region of the RSSP or any position of a completely unpaired pattern. Then, the procedure traverses the affix-intervals by performing right and left extensions, while at the same time checking base complementarity of paired positions. This verification takes constant time by using a binary table of size <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i54.gif"/></inline-formula> containing all valid base pairings. Matching positions are reported whenever the boundaries of the RSSP are reached.</p>
        <p>In principle, we are free to choose any loop position <italic>r</italic><sub>0 </sub>(or any position if <italic>R </italic>is empty) for starting our bidirectional search algorithm. However, in order to reduce the combinatorial explosion of the search space due to ambiguous IUPAC characters, it is preferable to match non-ambiguous pattern characters first. To keep the selection simple, we set <italic>r</italic><sub>0 </sub>to the position of the first character <italic>c </italic>in the possible range such that |<italic>φ</italic>(<italic>c</italic>)| is minimal. That is, we start the search with the most specific (least ambiguous) character.</p>
        <p>A detailed example of bidirectional RSSP search along with the underlying affix array traversal is provided in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> Section S1. We remark that procedure <italic>bidir-search </italic>can be extended to support variable-length RSSPs. Such an extended version of <italic>bidir-search </italic>is provided in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> Section S3.</p>
      </sec>
      <sec>
        <title>Analysis</title>
        <p>We analyze the complexity for searching in a sequence <italic>S </italic>of length <italic>n </italic>for an RSSP <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> of length <italic>m &lt; n</italic>, where the index structures for <italic>S </italic>are already computed.</p>
        <p>The bidirectional search algorithm requires tables suf<sub>F </sub>and suf<sub>R</sub>, lcp<sub>F </sub>and lcp<sub>R</sub>, and aflk<sub>F </sub>and aflk<sub>R</sub>. Under our assumption that <italic>n &lt;</italic>2<sup>32</sup>, each of the four tables suf<italic><sub>X </sub></italic>and aflk<italic><sub>X </sub></italic>consumes 4<italic>n </italic>bytes, and the two tables lcp<sub>X </sub>are each stored in <italic>n </italic>bytes (<italic>X </italic>∈ {F, R}). This amounts to a space consumption of 18<italic>n </italic>bytes for the index structures. The algorithm performs a depth first search, where the depth is limited by <italic>m</italic>, and therefore requires <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i53.gif"/></inline-formula> space. The total space complexity is therefore <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula>.</p>
        <p>We assume that <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i48.gif"/></inline-formula> is structure minimal. Such a pattern <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> without ambiguity, i.e. <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i55.gif"/></inline-formula>, does not contain base pairs and the search for <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> does not profit from bidirectional search. Although such a pattern is processed by Algorithm 2, it can be handled by Algorithm 1 using only a suffix array and saving some overhead.</p>
        <p>Algorithm 1 accomplishes the search for a non-ambiguous pattern <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> on the suffix array suf<sub>F </sub>using binary search for locating intervals in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i56.gif"/></inline-formula> time, where <italic>z </italic>is the number of occurrences of <italic>P </italic>in <italic>S</italic>. We remark that this time bound can be lowered at the price of higher memory consumption to <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i57.gif"/></inline-formula>[<xref ref-type="bibr" rid="B25">25</xref>] or even <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i58.gif"/></inline-formula>[<xref ref-type="bibr" rid="B34">34</xref>,<xref ref-type="bibr" rid="B39">39</xref>] time by using additional precomputed information.</p>
        <p>Notably, if there is ambiguity but no base pair in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula>, bidirectional search can still be beneficial in practice. This is the case when searching for a pattern in which a string of unambiguous characters is surrounded on both sides by ambiguous IUPAC characters, because the comparison can start at the most specific part of the pattern. The time complexities for searching ambiguous patterns with Algorithm 1 can be estimated as <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i59.gif"/></inline-formula> in the worst case of searching for the sequence pattern <italic>P </italic>consisting only of Ns. Furthermore, note that our Algorithm 2 behaves exactly like Algorithm 1 on patterns without base pairs if we invoke the search procedure with <italic>r </italic>= -1 and <italic>r' </italic>= 0.</p>
        <p>For a pattern <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i48.gif"/></inline-formula> of length <italic>m</italic>, let <italic>p </italic>≥ 0 be the number of base pairs in <italic>R</italic>. In the worst case <italic>P </italic>consists only of Ns. Moreover, all possible strings of length <italic>m </italic>satisfying the complementarity constraints specified in <italic>R </italic>occur in the text <italic>S</italic>. Recall that, since we allow (G, U) pairs, there are <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i60.gif"/></inline-formula> possible complementary base pairs. Thus, there are <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i61.gif"/></inline-formula> such strings and Algorithm 2 spans a virtual tree with <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i62.gif"/></inline-formula> paths from the root to a leaf. At each leaf, it reports the occurrences of the respective matched substring.</p>
        <p>On each path from the root to the leaf the algorithm performs <italic>m </italic>- 2<italic>p c</italic>-extensions and at most one switch of the search direction for matching the <italic>m </italic>- 2<italic>p </italic>unpaired characters. Then, it performs 2<italic>p </italic>c-extensions and <italic>p </italic>switches of the direction for matching the base paired positions. Therefore, we count the total number of c-extensions as<disp-formula><graphic xlink:href="1471-2105-12-214-i63.gif"/></disp-formula></p>
        <p>which is in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i64.gif"/></inline-formula>.</p>
        <p>The cost of each <italic>c</italic>-extension consists of the cost of locating the suffix-interval of the new affix-interval, which is performed by binary search in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i65.gif"/></inline-formula>, and the cost for potentially computing the reverse affix-interval when switching the search direction.</p>
        <p>Instead of performing the binary search over the suffix tables, one can use the child-tables introduced by Abouelhoda <italic>et al</italic>. in [<xref ref-type="bibr" rid="B34">34</xref>] to determine the child intervals and switch the search direction in constant time. The child-tables, however, add at least 2<italic>n </italic>bytes to the index and require additional involved index construction. As the child-tables improve the worst case behavior but, on the other hand, require more space, we analyze the complexity with and without these tables (i.e. with tables suf<italic><sub>X</sub></italic>, lcp<italic><sub>X</sub></italic>, and aflk<italic><sub>X </sub></italic>only).</p>
        <p>First, we analyze the time required for performing a single switch of the search direction. Therefore we assume that the current affix-interval is <italic>v </italic>= 〈<italic>k</italic>, <italic>ℓ </italic>- [<italic>i</italic>..<italic>j</italic>], <italic>X</italic>〉. Consider the following two cases.</p>
        <p>(1) Case <italic>i </italic>= <italic>j </italic>or <italic>k ≠ </italic>0. If <italic>i </italic>= <italic>j</italic>, <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i41.gif"/></inline-formula> represents a unique substring of <italic>S</italic>, or, if <italic>k ≠ </italic>0, all occurrences of  substring <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i41.gif"/></inline-formula> in <italic>S </italic>are followed (if <italic>k &gt;</italic>0) or preceded (if <italic>k &lt;</italic>0) by the same substring of length |<italic>k</italic>| (known as context). Switching the search direction does not require locating the reverse interval of <italic>v</italic>, because the algorithm can perform the <italic>c</italic>-extension in the new search direction by consuming context. Therefore, this case requires constant time.</p>
        <p>(2) Case <italic>i &lt; j </italic>and <italic>k </italic>= 0. The algorithm needs to locate the reverse affix-interval <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i44.gif"/></inline-formula> of <italic>v</italic>. Interval boundaries <italic>i' </italic>= aflk<italic><sub>X </sub></italic>[home<italic><sub>X </sub></italic>([<italic>i..j</italic>])] and <italic>j' </italic>= <italic>i' </italic>+ (<italic>j </italic>- <italic>i</italic>) of <italic>v' </italic>are computed in constant time.</p>
        <p>By definition, computing the reverse affix-interval of <italic>v </italic>requires knowing <italic>ℓ</italic><sub>lcp</sub>. Then, <italic>ℓ' </italic>= <italic>ℓ</italic><sub>lcp </sub>and <italic>k' </italic>= <italic>ℓ' </italic>- <italic>ℓ</italic>. Without child-tables, we determine <italic>ℓ</italic><sub>lcp </sub>by computing the length of the longest common prefix between <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i26.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i66.gif"/></inline-formula>. It suffices to perform <italic>ℓ</italic><sub>lcp </sub>- <italic>ℓ </italic>+ 1 = <italic>k' </italic>+ 1 character comparisons only, since both suffixes <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i26.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i66.gif"/></inline-formula> share a common prefix of at least length <italic>ℓ</italic>. With the help of child-tables, <italic>ℓ</italic><sub>lcp </sub>is determined in constant time [<xref ref-type="bibr" rid="B34">34</xref>].</p>
        <p>Due to the following lemma, the computation of all reverse affix-intervals on one path of our virtual tree is in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula> if child-tables are not used.</p>
        <p><bold>Lemma 3 </bold><italic>Using tables </italic>suf<italic><sub>X</sub></italic>, lcp<italic><sub>X</sub>, and </italic>aflk<italic><sub>X</sub>, the computation of all contexts on a path in the recursion of Algorithm 2 is in </italic><inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula>.</p>
        <p><bold>Proof</bold>. Let <italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>, <italic>v</italic><sub><italic>t </italic></sub>..., <italic>v</italic><sub><italic>C </italic></sub>be the sequence of reverse intervals processed when matching <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula>, and let <italic>k<sub>t </sub></italic>denote the context of <italic>v<sub>t </sub></italic>for 1 ≤ <italic>t </italic>≤ <italic>C</italic>.</p>
        <p>To show <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i67.gif"/></inline-formula>, let <italic>v </italic>= 〈<italic>k</italic>, <italic>ℓ </italic>- [<italic>i..j</italic>], <italic>X</italic>〉, with <italic>k </italic>= 0, <italic>i &lt; j</italic>, and <italic>X </italic>= F (<italic>X </italic>= R), be the current affix-interval. We assume without loss of generality that we perform a left (right) <italic>c</italic>-extension of <italic>v </italic>and thus locate the reverse interval <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i68.gif"/></inline-formula>. Then the following statements hold: <italic>k<sub>t </sub></italic>≥ 0, <italic>ℓ<sub>t </sub></italic>= <italic>ℓ </italic>+ <italic>k<sub>t</sub></italic>, and <italic>j<sub>t </sub></italic>- <italic>i<sub>t </sub></italic>= <italic>j </italic>- <italic>i </italic>(see Lemma 1). Observe that <italic>k<sub>t </sub></italic>= 0 implies <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i69.gif"/></inline-formula> and <italic>k</italic><sub><italic>t </italic></sub>&gt; 0 implies that substring <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i70.gif"/></inline-formula> has a non-empty prefix of length <italic>k<sub>t</sub></italic>, namely <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i71.gif"/></inline-formula>.</p>
        <p>Note that <italic>v<sub>t </sub></italic>is only located if <italic>k </italic>= 0, otherwise the context <italic>k </italic>has to be consumed. Hence there is no reverse interval <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i72.gif"/></inline-formula>, with 1 ≤ <italic>s </italic>≤ <italic>C</italic>, <italic>s </italic>≠ <italic>t</italic>, and <italic>k</italic><sub><italic>s </italic></sub>&gt; 0, such that the (<italic>k<sub>s </sub></italic>- 1)-th prefix of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i73.gif"/></inline-formula> overlaps with <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i71.gif"/></inline-formula> for the same positions in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i74.gif"/></inline-formula>. From this, <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i75.gif"/></inline-formula> follows. Since a single context <italic>k<sub>t </sub></italic>can be determined by performing exactly <italic>k<sub>t </sub></italic>+ 1 character comparisons, this implies <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula> time to compute all these contexts. With this, we conclude that all switches of the search direction performed while finding one substring <italic>w </italic>in <italic>S </italic>that matches <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> take up to <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula> time. □</p>
        <p>Therefore, when searching for <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> without child-tables, the total time for switching search directions is coarsely estimated by multiplying the complexity for one path with the number of paths as <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i76.gif"/></inline-formula>. The use of child-tables removes the linear factor.</p>
        <p>For the worst case that all strings matching the pattern actually occur as substrings in <italic>S</italic>, the sequence <italic>S </italic>must have a certain minimal length. In the case of <italic>p </italic>= 0, the possible matches are the words in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i77.gif"/></inline-formula> and a sequence that contains all these matches is called <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i78.gif"/></inline-formula>-ary <italic>de Bruijn </italic>sequence of order <italic>m </italic>[<xref ref-type="bibr" rid="B40">40</xref>] without wrap-around, i.e. a <italic>de Bruijn </italic>sequence with its first <italic>m </italic>- 1 characters concatenated to its end. Such a sequence was shown to have a length of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i79.gif"/></inline-formula>. As a consequence, the worst case requires <italic>n </italic>≥ <italic>n</italic><sub>0</sub>.</p>
        <p>We summarize the worst-case time complexities for Algorithm 2 as follows. 1.) From determining new suffix-intervals, we get a contribution of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i80.gif"/></inline-formula>. For <italic>n </italic>≥ <italic>n</italic><sub>0</sub>, this is in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i59.gif"/></inline-formula>. Child-tables reduce this time further to <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula>. 2.) Switching directions without child-tables is in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i76.gif"/></inline-formula> worst-case time, which is reduced to <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i64.gif"/></inline-formula> when using child-tables. For <italic>n </italic>≥ <italic>n</italic><sub>0</sub>, <italic>E<sub>m, p </sub></italic>is in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula>. Finally, Algorithm 2 runs in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i81.gif"/></inline-formula>, which is reduced to <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i64.gif"/></inline-formula> using child-tables (i.e. <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula> for <italic>n </italic>≥ <italic>n</italic><sub>0</sub>).</p>
        <p>One should note that the worst-case time complexity of bidirectional search for sequence-structure pattern is only in the order of online search algorithms. In our implementation, we use a minimal set of tables in order to keep the implementation simple and save space.</p>
        <p>However, it can be clearly seen from this analysis that the worst case is based on extremely pessimistic assumptions that are almost contrary to the expected application. 1.) It is assumed that a pattern consists of wildcards N only. In the expected application, however, patterns will often specify bases in the loop region, which is of particular benefit for our algorithm. 2.) Sequences, like the <italic>de Bruijn </italic>sequence, that contain all possible matches of an average sized pattern will be rare in practice. E.g. it could be assumed that a sequence that contains all possible matches of a pattern <italic>Q </italic>with <italic>p </italic>base pairs (and <italic>P </italic>= N ... N) is at least as long as the <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i78.gif"/></inline-formula>-ary <italic>de Bruijn </italic>sequence of order <italic>m</italic>, since one expects no significant bias for the specific complementarity due to <italic>R </italic>over all substrings of length <italic>m</italic>. However, <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i82.gif"/></inline-formula> is even for small <italic>p </italic>much smaller than <italic>n</italic><sub>0 </sub>= 4<italic><sup>m </sup></italic>+ <italic>m </italic>- 1. For example, four base pairs (i.e., <italic>p </italic>= 4) reduce the time bound by a factor of (16<italic>/</italic>6)<sup>4 </sup>≈ 50 and eight base pairs reduce time by a factor of about 2500.</p>
      </sec>
    </sec>
    <sec>
      <title>RNA secondary structure descriptors based on multiple ordered RSSPs</title>
      <p>Obviously RNAs with complex, branching structures cannot be described completely by a single RSSP. Describing an RNA by only a single unbranched fragment is often inappropriate, since searching a large sequence database or a complete genome for structurally conserved RNAs (RNA homology search) with a single RSSP will likely generate many spurious matches. However, larger RNAs can often adequately be described by a sequence of RSSPs. This holds for 1,247 out of 1,446 RNA families in Rfam 10.0 which have a structure containing several stem-loops but no multi-loop. Only 199 out of 1,446 (13.76%) RNA families in Rfam 10.0 containing multi-loops cannot be modeled completely this way. Still, the consensus structures of these 199 families contain on average 4.06 stem-loops (standard deviation 2.08, median 3) which can be modeled as RSSPs. In consequence, we can use a sequence of RSSPs that consist of at least one pattern per stem-loop (and potentially also unstructured patterns) for the description of those families. This allows to accurately identify members even of those families containing multi-loops.</p>
      <p>We address search for complex structured RNA families with the new concept of RNA secondary structure descriptors (SSD for short). SSDs use the information of multiple ordered RSSPs derived from the decomposition of an RNA's secondary structure or from the consensus secondary structure of a multiple sequence-structure alignment of related RNAs into stem-loop-like structural elements. Such consensus secondary structures for multiple RNAs can be computed with a variety of programs following one of the three strategies introduced in [<xref ref-type="bibr" rid="B41">41</xref>]. Namely: (A) alignment of the sequences followed by joint folding [<xref ref-type="bibr" rid="B42">42</xref>-<xref ref-type="bibr" rid="B45">45</xref>], (B) Sankoff style [<xref ref-type="bibr" rid="B8">8</xref>] simultaneous alignment and folding [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B46">46</xref>,<xref ref-type="bibr" rid="B47">47</xref>], and (C) individual folding of the sequences followed by alignment of their structures [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B48">48</xref>,<xref ref-type="bibr" rid="B49">49</xref>]. In the following we make the concept of SSDs more precise. Let <italic>A </italic>= <italic>A</italic><sub>1</sub>, <italic>A</italic><sub>2</sub>,..., <italic>A<sub>L </sub></italic>be a sequence of non-overlapping alignment blocks. These alignment blocks are excised from a multiple sequence(-structure) alignment and represent regions of the molecule that fold into stem-loop-like structures or remain unfolded. The indexing from 1 to <italic>L </italic>reflects their order of occurrence in the alignment. Hence <italic>A </italic>represents a sequential decomposition of the molecule's secondary structure (in 5' → 3' direction) into regions, each of which can be described by an RSSP. See Figure <xref ref-type="fig" rid="F6">6(A)</xref> for an example.</p>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p><bold>Construction of RNA secondary structure descriptors. </bold>(A) Non-overlapping alignment blocks of stem-loop regions excised from a multiple sequence-structure alignment and derived sequence-structure patterns. Since <italic>l<sub>i </sub></italic>≤ <italic>r</italic><sub><italic>i </italic></sub>&lt;<italic>l</italic><sub><italic>j </italic></sub>≤ <italic>r<sub>j </sub></italic>and sequence regions <italic>S</italic>[<italic>l</italic><sub><italic>i </italic></sub>... <italic>r</italic><sub><italic>i</italic></sub>] fold into stem-loop structures for 1 ≤ <italic>i </italic>≤ <italic>j </italic>≤ 7, <italic>A </italic>= <italic>A</italic><sub>1</sub>, <italic>A</italic><sub>2</sub>, <italic>A</italic><sub>3</sub>, <italic>A</italic><sub>4</sub>, <italic>A</italic><sub>5</sub>, <italic>A</italic><sub>6</sub>, <italic>A</italic><sub>7 </sub>is an ordered sequence of non-overlapping alignment blocks suitable to construct an RNA secondary structure descriptor <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i83.gif"/></inline-formula>. The sequence-structure patterns <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i86.gif"/></inline-formula>, <italic>i </italic>∈ [1, 7] of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i84.gif"/></inline-formula> given on top of their underlying alignment blocks describe the seven marked stem-loops shown in the RNA secondary structure (B) of the Citrus tristeza virus replication signal (Rfam: RF00193). (C) Matches of RSSPs <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i86.gif"/></inline-formula>, <italic>i </italic>∈ [1, 7], on sequence <italic>S</italic>, sorted in ascending order of their start position. (D) Graph-based representation of the matches of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i86.gif"/></inline-formula>, <italic>i </italic>∈ [1, 7]. An optimal chain of collinear non-overlapping matches is determined by computing an optimal path in the directed acyclic graph. Observe that not all edges in the graph are shown in this example and that the optimal chain (indicated here by their red marked members) is not necessarily the longest possible chain.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-214-6"/>
      </fig>
      <p>An SSD <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i84.gif"/></inline-formula> of length <italic>L </italic>is a sequence of <italic>L </italic>RSSPs <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i85.gif"/></inline-formula> where <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i86.gif"/></inline-formula> denotes the RSSP describing <italic>A<sub>i</sub></italic>, <italic>i </italic>∈ [1, <italic>L</italic>]. The order ≪ of the RSSPs in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i84.gif"/></inline-formula> is imposed by the order of the corresponding alignment blocks. By <italic>l<sub>i </sub></italic>and <italic>r<sub>i </sub></italic>we denote the start and end positions of <italic>A<sub>i </sub></italic>in the multiple alignment, respectively. In practice, <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i84.gif"/></inline-formula> can be obtained from multiple sequence-structure alignments of related RNA sequences (i.e., of an RNA family) as they are available in databases like Rfam [<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B4">4</xref>]. A match to <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i84.gif"/></inline-formula> is a non-overlapping sequence of matches for some or all of the RSSPs in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i84.gif"/></inline-formula> in their specified order. We will now make this more precise.</p>
      <p>Consider an RNA SSD <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i84.gif"/></inline-formula> with total order ≪. Let <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i87.gif"/></inline-formula> be the set of all matches for all RSSP from <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i84.gif"/></inline-formula> in sequence <italic>S </italic>of length <italic>n</italic>. A match is represented by a pair <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i88.gif"/></inline-formula> such that <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> matches at position <italic>p </italic>in <italic>S</italic>. With each <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i84.gif"/></inline-formula> we associate a positive weight <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i89.gif"/></inline-formula> which can be defined by the user. This weight allows to quantify the expressiveness of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> and/or its significance. For example, <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i89.gif"/></inline-formula> can be the length of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> or it might be derived from the number of non-ambiguous nucleotides in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> or the probability of obtaining a match for <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i52.gif"/></inline-formula> just by chance assuming a certain (mono-)nucleotide background distribution. We say that matches <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i88.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i90.gif"/></inline-formula> are <italic>collinear</italic>, written as <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i91.gif"/></inline-formula> if <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i92.gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i93.gif"/></inline-formula>. A <italic>chain </italic><inline-formula><inline-graphic xlink:href="1471-2105-12-214-i96.gif"/></inline-formula> for an SSD <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i84.gif"/></inline-formula> is a sequence of matches<disp-formula><graphic xlink:href="1471-2105-12-214-i94.gif"/></disp-formula></p>
      <p>all from <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i87.gif"/></inline-formula>, such that <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i95.gif"/></inline-formula> for all <italic>i</italic>, 1 ≤ <italic>i </italic>≤ <italic>k </italic>- 1.</p>
      <p>There are two modes to score chains, depending on the nature of the search problem. If the multiple sequence-structure alignment our SSD is derived from and the searched sequences have comparable length, we want the chain to cover as much as possible of the sequence and we define the <italic>global chain score </italic>for chain <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i96.gif"/></inline-formula> as follows:<disp-formula id="bmcM2"><label>(2)</label><graphic xlink:href="1471-2105-12-214-i97.gif"/></disp-formula></p>
      <p>Then, the global chaining problem is to find a chain <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i96.gif"/></inline-formula> with maximum global chain score. If we are searching in a whole genome or chromosome for a relatively short structural RNA, we are interested in local chains covering only parts of the genome or chromosome. Then we have to penalize gaps using a penalty function <italic>g </italic>and thus the <italic>local chain score </italic>is defined by<disp-formula id="bmcM3"><label>(3)</label><graphic xlink:href="1471-2105-12-214-i98.gif"/></disp-formula></p>
      <p>where<disp-formula id="bmcM4"><label>(4)</label><graphic xlink:href="1471-2105-12-214-i99.gif"/></disp-formula></p>
      <p>To solve the local chaining problem we use our own implementation of a fast local chaining algorithm described in [<xref ref-type="bibr" rid="B50">50</xref>] with modified gap costs. While the algorithm of [<xref ref-type="bibr" rid="B50">50</xref>] penalizes gaps by the sum of their lengths, our solution is based on the difference between their observed lengths (in the chain of matches) and their expected lengths (as given by the multiple alignment of the family), confer Equation 4. This algorithm runs in <italic>O</italic>(<italic>q </italic>log <italic>q</italic>) time where <italic>q </italic>is the size of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i87.gif"/></inline-formula>.</p>
      <p>To solve the global chaining problem we have developed a new efficient chaining algorithm described next.</p>
      <sec>
        <title>An improved method for global RSSP match chaining</title>
        <p>So far our description was based on a single sequence. However, the results described below are based on a large set of sequences <italic>S</italic><sub>1</sub>,..., <italic>S<sub>k </sub></italic>as it occurs when searching a large sequence database. I.e. in case of databases like Rfam <italic>k </italic>can be in the range of millions. To handle these, we concatenate the single sequences with separator symbols and construct the affix array for the concatenation. For a given SSD <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i85.gif"/></inline-formula>, all RSSPs <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i86.gif"/></inline-formula>, 1 ≤ <italic>i </italic>≤ <italic>L</italic>, are matched one after the other using fast bidirectional search on the affix array. This results in match sets <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i100.gif"/></inline-formula> for RSSP <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i86.gif"/></inline-formula>. <italic>L </italic>is typically in the range of tens while the number of RSSP matches for a particular sequence <italic>S<sub>j </sub></italic>is in the order of hundreds to thousands if <italic>S<sub>j </sub></italic>is an mRNA or complete genome sequence. For each match <italic>f </italic>the following information is recorded:</p>
        <p>• The ordinal number <italic>i </italic>of the RSSP <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i86.gif"/></inline-formula> involved in <italic>f</italic>. This is denoted by <italic>f.rssp</italic>.</p>
        <p>• The length of the RSSP involved in <italic>f</italic>. This is denoted by <italic>f.length</italic>.</p>
        <p>• The number <italic>j </italic>of the sequence <italic>S</italic><sub><italic>j </italic></sub><italic>f </italic>occurs in. This is denoted by <italic>f.seqnum</italic>.</p>
        <p>• The starting position of <italic>f </italic>in <italic>S<sub>j</sub></italic>. This is denoted by <italic>f.pos</italic>.</p>
        <p>• The weight <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i101.gif"/></inline-formula> of <italic>f</italic>. The weight of <italic>f </italic>is denoted by <italic>f.weight</italic>.</p>
        <p>In an initial sorting step the union <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i87.gif"/></inline-formula> of all match sets <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i100.gif"/></inline-formula>, 1 ≤ <italic>i </italic>≤ <italic>L</italic>, is sorted in ascending order of <italic>f.seqnum</italic>. Matches with identical sequence numbers are sorted in ascending order of the ordinal number of the RSSP, i.e., by <italic>f.rssp</italic>. Suppose that <italic>b</italic>* is the size of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i87.gif"/></inline-formula>. As there are at most <italic>b</italic>* sequences with at least one RSSP match, the sorting according to the sequence numbers can be done in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i102.gif"/></inline-formula> time and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i103.gif"/></inline-formula> space using the counting sort algorithm [<xref ref-type="bibr" rid="B51">51</xref>]. Here, <italic>k</italic>* is the number of sequences with at least one RSSP match. As <italic>k</italic>* ≤ <italic>b</italic>*, the sorting requires <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i104.gif"/></inline-formula> time and space. We obtain disjoint subsets <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i105.gif"/></inline-formula>, 1 ≤ <italic>j </italic>≤ <italic>k</italic>, where <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i105.gif"/></inline-formula> is the set of all matches in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i87.gif"/></inline-formula> matching a substring of <italic>S<sub>j</sub></italic>. As <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i87.gif"/></inline-formula> is ordered by the ordinal number of the RSSP and the counting sort algorithm is stable, the sets <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i105.gif"/></inline-formula> are also sorted by the ordinal number of the RSSPs. Let <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i106.gif"/></inline-formula> denote the matches <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i107.gif"/></inline-formula> such that <italic>f.rssp </italic>= <italic>i</italic>. In a second sorting step, each <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i106.gif"/></inline-formula> is sorted according to the starting position of the matches. As this is a typical integer sorting problem, it requires <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i108.gif"/></inline-formula> time, where <italic>b<sub>j, i </sub></italic>is the size of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i106.gif"/></inline-formula>. Altogether, the two initial sorting steps can be performed in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i109.gif"/></inline-formula> time.</p>
        <p>For all <italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>,..., <italic>S<sub>k </sub></italic>one now solves independent chaining problems for sets <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i105.gif"/></inline-formula>, 1 ≤ <italic>j </italic>≤ <italic>k</italic>, of matches sorted according to the ordinal number of the RSSP and the starting position of the matches in <italic>S<sub>j</sub></italic>. Let <italic>j </italic>be fixed, but arbitrary. For each match <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i107.gif"/></inline-formula>, the weight <italic>f.weight </italic>is positive. Hence, an optimal chain ends with a match <italic>f </italic>such that there is no match <italic>f' </italic>satisfying <italic>f </italic>≪ <italic>f'</italic>. Similarly, an optimal chain begins with a match <italic>f' </italic>such that there is no match <italic>f </italic>satisfying <italic>f </italic>≪ <italic>f'</italic>.</p>
        <p>The chaining problem is solved by a dynamic programming algorithm which tabulates for all matches <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i110.gif"/></inline-formula> the maximum score <italic>f'.score </italic>of all chains ending with <italic>f'</italic>. In addition, it computes the predecessor <italic>f'.prec </italic>of <italic>f' </italic>in a chain with maximum score ending with <italic>f'</italic>. To obtain <italic>f'.score</italic>, one has to maximize over all matches <italic>f </italic>such that <italic>f.rssp &lt; f'.rssp </italic>and <italic>f.pos </italic>+ <italic>f.length </italic>- 1 &lt;<italic>f'.pos</italic>. This is a two dimensional search problem. As the matches in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i105.gif"/></inline-formula> are already sorted according to the first dimension (i.e., by the ordinal number of the RSSP), one can reduce it to a one dimensional sorting problem. This has already been observed in [<xref ref-type="bibr" rid="B50">50</xref>], and led to the development of an algorithm solving the chaining problem in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i111.gif"/></inline-formula>, where <italic>b </italic>is the number of matches in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i105.gif"/></inline-formula>. However, the algorithm of [<xref ref-type="bibr" rid="B50">50</xref>] was developed for chaining pairwise sequence matches. The RSSP chaining problem is a special instance of this problem: the first "sequence" consists of the positions 1,..., <italic>L</italic>, and a match for RSSP <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i86.gif"/></inline-formula> is a match of length one to position <italic>i</italic>. Moreover, matches at position <italic>i </italic>in the first sequence can be treated as being of equal length because they are matches to the same RSSP <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i86.gif"/></inline-formula>. In addition to this, our initial sorting step delivers, for all <italic>i</italic>, 1 ≤ <italic>i </italic>≤ <italic>L</italic>, the matches in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i106.gif"/></inline-formula> in sorted order according to the starting position in <italic>S<sub>j</sub></italic>. All these properties allow us to simplify and improve the algorithm of [<xref ref-type="bibr" rid="B50">50</xref>] in the following aspects:</p>
        <p>• While the algorithm of [<xref ref-type="bibr" rid="B50">50</xref>] requires a dictionary data structure with insert, delete, predecessor, and successor operations running in logarithmic time (e.g., an AVL-tree or a red-black tree [<xref ref-type="bibr" rid="B51">51</xref>]), our approach only needs a linear list, which is much easier to implement and requires less space.</p>
        <p>• While the algorithm of [<xref ref-type="bibr" rid="B50">50</xref>] requires an initial sorting step using <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i112.gif"/></inline-formula> time, our method only needs <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i109.gif"/></inline-formula> time for this step. Note that the <italic>b<sub>j, i </sub></italic>satisfy <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i113.gif"/></inline-formula>.</p>
        <p>• While the algorithm of [<xref ref-type="bibr" rid="B50">50</xref>] solves the chaining problem for <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i105.gif"/></inline-formula> in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i111.gif"/></inline-formula> time, our approach runs in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i114.gif"/></inline-formula> time. If <italic>L </italic>is considered to be a constant, the running time becomes linear in <italic>b</italic>, where <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i115.gif"/></inline-formula>.</p>
        <p>To explain our algorithm, let <italic>i</italic>, 1 ≤ <italic>i </italic>≤ <italic>L </italic>be arbitrary but fixed and assume that all match sets <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i127.gif"/></inline-formula> have been processed. In a first loop over the sorted matches in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i106.gif"/></inline-formula> one determines the score of the matches. In a second loop, one inserts them into a linear list if necessary. The linear list contains a subset of the previously processed and scored matches. This split of the computation into two loops is different from the algorithm of [<xref ref-type="bibr" rid="B50">50</xref>] where the scoring and insertions are interweaved in one loop, requiring an extra array of length 2<italic>b </italic>containing references to the matches. The separation into two loops allows us to get rid of this extra array.</p>
        <p>Now consider the first loop over all elements in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i106.gif"/></inline-formula> in sorted order of the match position in <italic>S<sub>j</sub></italic>. Let <italic>f' </italic>be the current element. At this point, all matches <italic>f </italic>such that <italic>f.rssp &lt; f'.rssp </italic>have been processed already. In particular, the score <italic>f.score </italic>and the previous match (if any) in an optimal chain ending with <italic>f </italic>has been determined. Among the processed matches we only have to consider those matches <italic>f </italic>satisfying <italic>f.pos </italic>+ <italic>f.length </italic>- 1 &lt;<italic>f'.pos</italic>. If there is such a match, one takes the one with maximal score, say <italic>f</italic>. Then, the optimal chain ending with <italic>f' </italic>contains the previous match <italic>f</italic>, and the score is <italic>f'.score </italic>= <italic>f'.weight </italic>+ <italic>f.score</italic>. If there is no such match, then the optimal chain ending with <italic>f' </italic>only consists of <italic>f' </italic>and <italic>f'.score </italic>= <italic>f'.weight</italic>.</p>
        <p>Now consider the second loop over all elements in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i106.gif"/></inline-formula> for which the scores and predecessor matches (if any) are already determined. Let <italic>f' </italic>be the current element to be inserted. As explained in the previous case, one has to make sure that, among the processed matches, one can efficiently determine the match <italic>f </italic>with the maximum score such that <italic>f.pos </italic>+ <italic>f.length </italic>- 1 is smaller than some value depending on <italic>f'</italic>. The processed matches are stored in a linear list which is sorted in ascending order of the position of the matches in <italic>S<sub>j</sub></italic>. Let ≺<italic><sub>pos </sub></italic>denote this order, that is <italic>f </italic>≺<sub><italic>pos </italic></sub><italic>f" </italic>if and only if <italic>f.pos </italic>+ <italic>f.length &lt; f</italic>"<italic>.pos </italic>+ <italic>f".length </italic>for any matches <italic>f </italic>and <italic>f"</italic>. If for two processed matches <italic>f </italic>and <italic>f" </italic>one has <italic>f.pos &lt; f</italic>"<italic>.pos </italic>and <italic>f.score &gt; f</italic>"<italic>.score</italic>, then an optimal chain does not include <italic>f"</italic>. Each chain that uses <italic>f" </italic>can also use <italic>f </italic>and increase the chain score. As a consequence, one has to take care that <italic>f" </italic>is not inserted into the linear list or it is deleted if it was inserted earlier. In this way, <italic>f </italic>≺<sub><italic>pos </italic></sub><italic>f" </italic>always implies <italic>f.score </italic>≤ <italic>f".score </italic>for two matches <italic>f </italic>and <italic>f" </italic>in the linear list. As the elements to be scored in the first loop and to be inserted in the second loop are ordered in the same way as the elements in the linear list, one can perform the scoring and the insertion loop (which also may involve deletions) by merging two lists of length <italic>l</italic><sub>1 </sub>and <italic>l</italic><sub>2 </sub>in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i116.gif"/></inline-formula> time where <italic>l</italic><sub>1 </sub>is the number of matches to be scored and inserted and <italic>l</italic><sub>2 </sub>is the length of the linear list involved. Let <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i117.gif"/></inline-formula>. As <italic>l</italic><sub>1 </sub>+ <italic>l</italic><sub>2 </sub>≤ <italic>b</italic>, one obtains a running time of <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i118.gif"/></inline-formula> for each set <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i106.gif"/></inline-formula>. As there are <italic>L </italic>such sets, the running time is <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i114.gif"/></inline-formula>.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Results</title>
    <sec>
      <title>Implementation and computational results</title>
      <p>We implemented (1) the algorithms necessary for affix array construction, (2) the fast bidirectional search of RSSPs using affix arrays as sketched in Algorithm 2 (hereinafter called <italic>BIDsearch</italic>), (3) an online variant operating on the plain sequence (hereinafter called <italic>ONLsearch</italic>) for validation of <italic>BIDsearch </italic>and reference benchmarking, and (4) the efficient global and local chaining algorithms. Algorithm <italic>ONLsearch </italic>shifts a window of length <italic>m </italic>= |<italic>RSSP</italic>| along the sequence of length <italic>n </italic>to be searched and compares the substring inside the window with the RSSP from left to right until a mismatch occurs. Hence, it runs in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i119.gif"/></inline-formula> time in the worst and <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i24.gif"/></inline-formula> time in the best case. Algorithms <italic>BIDsearch </italic>and <italic>ONLsearch </italic>were implemented in the program <italic>afsearch</italic>. The <italic>afconstruct </italic>program makes use of routines from the <italic>libdivsufsort2 </italic>library (see <ext-link ext-link-type="uri" xlink:href="http://code.google.com/p/libdivsufsort">http://code.google.com/p/libdivsufsort</ext-link>/) for computing the suf<sub>F </sub>and suf<sub>R </sub>tables in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i59.gif"/></inline-formula> time. For the construction of the lcp<sub>F </sub>and lcp<sub>R </sub>tables we employ our own implementation of the linear time algorithm of [<xref ref-type="bibr" rid="B36">36</xref>]. Tables aflk<sub>F </sub>and aflk<sub>R </sub>are constructed in <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i34.gif"/></inline-formula> worst-case time with fast practical construction time due to the use of the skip tables skp<sub>F </sub>and skp<sub>R </sub>[<xref ref-type="bibr" rid="B37">37</xref>]. The programs were compiled with the GNU C compiler (version 4.3.2, optimization option -O3) and all measurements were performed on a Quad Core Xeon E5410 CPU running at 2.33 GHz, with 64 GB main memory (using only one CPU core). To minimize the influence of disk subsystem performance the reported running times are user times averaged over 10 runs. Allowed base pairs were canonical Watson-Crick (A, U), (U, A), (C, G), (G, C), and wobble (G, U), (U, G), unless stated otherwise.</p>
      <sec>
        <title>Affix array construction times</title>
        <p>In a first experiment we constructed the affix array for genomes of selected model organisms of different sizes and stored it on disk. We measured the total running times needed by <italic>afconstruct </italic>to construct each table comprising the affix array. See Figure <xref ref-type="fig" rid="F7">7</xref> for the results of this experiment. The total size for each table is given in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> Table S2. Construction times were in the range of 25 minutes for the <italic>C. elegans </italic>genome containing ~ 100 megabases to 15.7 hours for the ~ 2 gigabase genome of the megabat <italic>P. vampyrus</italic>.</p>
        <fig id="F7" position="float">
          <label>Figure 7</label>
          <caption>
            <p><bold>Experiment 1: Running times for affix array construction for genomes of different model organisms</bold>. Genome sizes are given for each organism in megabases in brackets. We measured the running time in seconds for all tables the affix array consists of (y-axis, log<sub>10 </sub>scale). Total construction times were in the range of ~ 25 minutes for <italic>C. elegans </italic>up to 15.7 hours for <italic>P. vampyrus</italic>.</p>
          </caption>
          <graphic xlink:href="1471-2105-12-214-7"/>
        </fig>
        <p>We also measured the running time of <italic>afconstruct </italic>to construct the affix array for a set of 3,192,599 RNA sequences with a total length of ~ 622 MB compiled from the full alignments of all Rfam release 10.0 families. The construction and storage on disk required 126 minutes. In the following we refer to this dataset as RFAM10 for short.</p>
      </sec>
      <sec>
        <title>Influence of loop length on search performance</title>
        <p>In a second experiment we investigated the influence of the loop length and the number of non-ambiguous characters in the loop of an RSSP on the running time of <italic>BIDsearch </italic>and <italic>ONLsearch</italic>. For this experiment we constructed artificial RSSPs with a fixed stem length of 7 and a loop length <italic>l </italic>varying from 3 to 20. For each loop length, we also varied the number of consecutive non-ambiguous characters <italic>q </italic>from 0 to 4. For <italic>q </italic>= 0 this means that the RSSP contains structural constraints only. That is, for <italic>q </italic>= 0 and <italic>l </italic>= 5 the used RSSP matches all substrings that are able to fold into a stem-loop structure with loop length 5 and stem length 7. Such a pattern is written in dot-bracket notation as ( ( ( ( ( ( ( . . . . . ) ) ) ) ) ) ). Allowed base pairs were (A, U), (U, A), (C, G), and (G, C). We measured the time needed by <italic>BIDsearch </italic>and <italic>ONLsearch </italic>to search for these patterns in the RFAM10 dataset. Results are given in Figure <xref ref-type="fig" rid="F8">8</xref>. In this experiment <italic>BIDsearch </italic>performed very well and was faster than <italic>ONLsearch </italic>for all parameter combinations. We also investigated the influence of different stem length (data not shown here) and found that the impact on the total running time is negligible. We observe that the advantage of <italic>BIDsearch </italic>over <italic>ONLsearch </italic>decreases with increasing loop length <italic>l </italic>for fixed <italic>q</italic>. We explain this behavior with the increasing number of affix-intervals that have to be processed for finding all different substrings of the sequences that match the RSSP. However, even for an RSSP with loop length <italic>l </italic>= 20 containing only structural constraints (<italic>q </italic>= 0), <italic>BIDsearch </italic>is still faster than <italic>ONLsearch</italic>. We further notice that the number of non-ambiguous characters in the loop region has a strong influence on the running time of <italic>BIDsearch</italic>. That is, by specifying only a few conserved nucleotides in the RSSP's loop region, the running time of <italic>BIDsearch </italic>is reduced dramatically. For an example of this effect, see the running times of <italic>BIDsearch </italic>in Figure <xref ref-type="fig" rid="F8">8</xref> for parameters <italic>l </italic>= 15 and <italic>q </italic>∈ {2, 3, 4}. This renders <italic>BIDsearch </italic>in particular useful for searching with RSSPs with moderate loop length or existing sequence conservation in the loop region. The speedup factors measured in this experiment were in the range from 1.001 to 78.1 for <italic>q </italic>= 0 and from 9.28 to 11 × 10<sup>3 </sup>for <italic>q </italic>= 4. Table <xref ref-type="table" rid="T1">1</xref> gives more details on the speedups of <italic>BIDsearch </italic>over <italic>ONLsearch </italic>for all investigated combinations of <italic>q </italic>and <italic>l</italic>.</p>
        <fig id="F8" position="float">
          <label>Figure 8</label>
          <caption>
            <p><bold>Experiment 2: Influence of loop length and number of non-ambiguous characters in loop region on total running time of <italic>BIDsearch </italic>and <italic>ONLsearch</italic></bold>. We measured the running time in milliseconds to search with artificial RSSPs with loops of varying length <italic>l </italic>∈ {3, <italic>... </italic>, 20} on ~ 622 MB of RNA sequence data. For each loop length <italic>l </italic>we also varied the number <italic>q </italic>∈ {0, <italic>... </italic>, 4} of non-ambiguous nucleotides in the loop. The used RSSPs had a fixed stem length of 7. For more details on this experiment see corresponding text.</p>
          </caption>
          <graphic xlink:href="1471-2105-12-214-8"/>
        </fig>
        <table-wrap id="T1" position="float">
          <label>Table 1</label>
          <caption>
            <p>Experiment 2: Obtained speedup of <italic>BIDsearch </italic>over <italic>ONLsearch </italic>for different loop length <italic>l </italic>∈ {3,..., 20} and number of non-ambiguous characters in the loop region <italic>q </italic>∈ {0, <italic>... </italic>, 4}</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th align="center">
                  <italic>l</italic>
                </th>
                <th align="right">3</th>
                <th align="right">4</th>
                <th align="right">5</th>
                <th align="right">6</th>
                <th align="right">7</th>
                <th align="right">8</th>
                <th align="right">9</th>
                <th align="right">10</th>
                <th align="right">11</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center"><italic>q </italic>= 0</td>
                <td align="right">78.10</td>
                <td align="right">48.64</td>
                <td align="right">35.42</td>
                <td align="right">23.55</td>
                <td align="right">16.35</td>
                <td align="right">11.01</td>
                <td align="right">7.31</td>
                <td align="right">4.89</td>
                <td align="right">3.48</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>= 1</td>
                <td align="right">329.81</td>
                <td align="right">180.45</td>
                <td align="right">105.67</td>
                <td align="right">57.41</td>
                <td align="right">33.75</td>
                <td align="right">19.20</td>
                <td align="right">11.30</td>
                <td align="right">7.14</td>
                <td align="right">4.81</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>= 2</td>
                <td align="right">749.94</td>
                <td align="right">418.65</td>
                <td align="right">227.45</td>
                <td align="right">121.80</td>
                <td align="right">67.81</td>
                <td align="right">36.99</td>
                <td align="right">21.44</td>
                <td align="right">12.73</td>
                <td align="right">8.41</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>= 3</td>
                <td align="right">2,345.17</td>
                <td align="right">1,169.53</td>
                <td align="right">653.31</td>
                <td align="right">353.49</td>
                <td align="right">188.34</td>
                <td align="right">103.34</td>
                <td align="right">56.59</td>
                <td align="right">33.08</td>
                <td align="right">20.79</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>= 4</td>
                <td align="right">11,045.75</td>
                <td align="right">3,638.14</td>
                <td align="right">2,144.8</td>
                <td align="right">1,132.53</td>
                <td align="right">610.63</td>
                <td align="right">338.77</td>
                <td align="right">184.56</td>
                <td align="right">106.11</td>
                <td align="right">64.93</td>
              </tr>
              <tr>
                <td colspan="10">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center">
                  <italic>
                    <bold>l</bold>
                  </italic>
                </td>
                <td align="right">
                  <bold>12</bold>
                </td>
                <td align="right">
                  <bold>13</bold>
                </td>
                <td align="right">
                  <bold>14</bold>
                </td>
                <td align="right">
                  <bold>15</bold>
                </td>
                <td align="right">
                  <bold>16</bold>
                </td>
                <td align="right">
                  <bold>17</bold>
                </td>
                <td align="right">
                  <bold>18</bold>
                </td>
                <td align="right">
                  <bold>19</bold>
                </td>
                <td align="right">
                  <bold>20</bold>
                </td>
              </tr>
              <tr>
                <td colspan="10">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>= 0</td>
                <td align="right">2.67</td>
                <td align="right">2.15</td>
                <td align="right">1.79</td>
                <td align="right">1.51</td>
                <td align="right">1.37</td>
                <td align="right">1.20</td>
                <td align="right">1.13</td>
                <td align="right">1.07</td>
                <td align="right">1.00</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>= 1</td>
                <td align="right">3.58</td>
                <td align="right">3.13</td>
                <td align="right">2.28</td>
                <td align="right">1.89</td>
                <td align="right">1.68</td>
                <td align="right">1.46</td>
                <td align="right">1.35</td>
                <td align="right">1.27</td>
                <td align="right">1.12</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>= 2</td>
                <td align="right">5.96</td>
                <td align="right">4.88</td>
                <td align="right">3.64</td>
                <td align="right">2.94</td>
                <td align="right">2.57</td>
                <td align="right">2.19</td>
                <td align="right">2.02</td>
                <td align="right">1.82</td>
                <td align="right">1.63</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>= 3</td>
                <td align="right">14.27</td>
                <td align="right">11.88</td>
                <td align="right">8.25</td>
                <td align="right">6.50</td>
                <td align="right">5.53</td>
                <td align="right">4.74</td>
                <td align="right">4.19</td>
                <td align="right">3.76</td>
                <td align="right">3.34</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>= 4</td>
                <td align="right">43.09</td>
                <td align="right">35.23</td>
                <td align="right">25.74</td>
                <td align="right">19.52</td>
                <td align="right">15.91</td>
                <td align="right">13.25</td>
                <td align="right">11.75</td>
                <td align="right">10.32</td>
                <td align="right">9.28</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>For the parameter combination <italic>l </italic>= 3, <italic>q </italic>= 4 also one character of the stem was specified.</p>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec>
        <title>Searching large sequence databases</title>
        <p>To measure the performance of <italic>BIDsearch </italic>for non-artificial real-world RSSPs, we manually compiled a set of 397 RSSPs describing 42 highly structured RNA families taken from the RFAM10 database. These were all families with a consensus secondary structure containing at least 5 stem-loop substructures. We measured the running time needed by <italic>BIDsearch</italic>, <italic>ONLsearch</italic>, and the widely used tools <italic>RNAMotif </italic>[<xref ref-type="bibr" rid="B13">13</xref>] and <italic>RNABOB </italic>[<xref ref-type="bibr" rid="B15">15</xref>] to search for these 397 RSSPs in the RFAM10 dataset. As expected, all tools delivered identical results. However, while it took <italic>BIDsearch </italic>less than 50 seconds to search for the 397 patterns as shown in Table <xref ref-type="table" rid="T2">2</xref>, <italic>RNABOB </italic>and <italic>RNAMotif </italic>needed more than 2.5 and 3.2 hours respectively to complete the same task. This made for a speedup factor of 196.5 (254.7) for <italic>BIDsearch </italic>over <italic>RNABOB </italic>(<italic>RNAMotif</italic>). Even if we include the time needed for affix array construction, <italic>BIDsearch </italic>is still faster than <italic>RNABOB </italic>and <italic>RNAMotif</italic>.</p>
        <table-wrap id="T2" position="float">
          <label>Table 2</label>
          <caption>
            <p>Experiment 3 (A): Running times in seconds needed by the programs to search for 397 RSSPs describing 42 RFAM10 families in ~ 622 megabases of RNA sequence data.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th align="center">
                  <italic>BIDsearch</italic>
                </th>
                <th align="center">
                  <italic>ONLsearch</italic>
                </th>
                <th align="center">
                  <italic>RNAMotif</italic>
                </th>
                <th align="center">
                  <italic>RNABOB</italic>
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">46.1(1)</td>
                <td align="center">6,203(134.5)</td>
                <td align="center">11,745(254.7)</td>
                <td align="center">9,061(196.5)</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>For each program the speedup factor of <italic>BIDsearch </italic>over the particular program is given in brackets.</p>
          </table-wrap-foot>
        </table-wrap>
        <p>We also investigated the distribution of speedup factors obtained by <italic>BIDsearch </italic>when searching for the 397 RSSPs. We observed that <italic>BIDsearch </italic>is more than 50,000 times faster than <italic>RNABOB </italic>and <italic>RNAMotif </italic>for the majority of the patterns and that the total search time required by <italic>BIDsearch </italic>is dominated by only a small number of patterns. These patterns describe large unconserved loop regions. See Figure S3 in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> for a graphical visualization of the distribution of speedup factors.</p>
      </sec>
      <sec>
        <title>Scaling behavior of bidirectional pattern search using affix arrays</title>
        <p>In a further experiment we investigated the scaling behavior of <italic>BIDsearch </italic>and <italic>ONLsearch </italic>for an increasing size of sequences to be searched. For this, we searched with different RSSPs on random subsets of RFAM10 of different sizes and measured the running time for both algorithms. The results are given in Figure <xref ref-type="fig" rid="F9">9</xref>. Here pattern1 is an RSSP containing only structural constraints. It describes a stem-loop with loop length 4, stem length 10 and no specified nucleotides in the loop region. The RSSP pattern2 (pattern3) only differ from pattern1 by containing one (two consecutively) non-ambiguous nucleotides in the loop region.</p>
        <fig id="F9" position="float">
          <label>Figure 9</label>
          <caption>
            <p><bold>Scaling behavior <italic>BIDsearch </italic>(left) and <italic>ONLsearch </italic>(right)</bold>. We measured the running time needed to search with three different patterns on random subsets of RFAM10 of different sizes. For details, see main text.</p>
          </caption>
          <graphic xlink:href="1471-2105-12-214-9"/>
        </fig>
        <p>In this experiment <italic>BIDsearch </italic>clearly showed a sublinear scaling behavior, whereas <italic>ONLsearch </italic>scaled only linearly. It took <italic>BIDsearch </italic>only 566.8 (pattern1), 133.8 (pattern2), and 37.1 (pattern3) milliseconds to search the whole RFAM10 dataset. The obtained speedups of <italic>BIDsearch </italic>over <italic>ONLsearch </italic>were in the range from 4.63 (<italic>1 MB subset</italic>) to 104.79 (<italic>full </italic>RFAM10) for pattern1, from 12.23 (<italic>1 MB subset</italic>) to 223.18 (<italic>full </italic>RFAM10) for pattern2, and from 35.0 (<italic>1 MB subset</italic>) to 618.37 (<italic>full </italic>RFAM10) for pattern3. We observe again that the specification of only one or two nucleotides in an RSSP's loop region considerably reduces the running time of the <italic>BIDsearch </italic>algorithm.</p>
      </sec>
      <sec>
        <title>RNA family classification by global chaining of RSSP matches</title>
        <p>To demonstrate the effect of global chaining of RSSP matches, we searched with an SSD built for the Rfam family of OxyS RNAs (Acc.: RF00035). OxyS is a small 109-nucleotide long non-coding RNA which is included in response to oxidative stress in <italic>E. coli </italic>[<xref ref-type="bibr" rid="B52">52</xref>]. Members of this family fold into a characteristic secondary structure consisting of three stem-loop substructures, referred to as HP1, HP2, and HP3 in Figure <xref ref-type="fig" rid="F10">10(C)</xref>. From the three stem-loops we derived three descriptors called RSSP1, RSSP2, and RSSP3, which constitute the SSD describing this family. We note that in this experiment the RSSPs were constructed to guarantee high specificity and thus to minimize the number of false positives. For the SSD specified in <italic>Structator </italic>syntax, see Figure <xref ref-type="fig" rid="F10">10(A)</xref>. Searching for this SSD in RFAM10, <italic>Structator </italic>delivers 8,619 matches for RSSP1, 1,699 matches for RSSP2, and 142,219 matches for RSSP3. Instead of reporting these matches, <italic>Structator </italic>computes high-scoring global chains for each sequence containing matches to all three RSSPs. The chains and the sequences they occur in are reported in descending order of the chain score. This procedure resulted in 61 sequences, all belonging to the OxyS family which contains 115 members in total. Hence, by considering only high-scoring chains all the spurious RSSP matches were eliminated. We also described the same three stem-loops in a format compatible with <italic>RNAMotif </italic>(see Figure <xref ref-type="fig" rid="F10">10(B)</xref>). A search on RFAM10 with this descriptor returned exactly the same 61 sequences. However, <italic>Structator </italic>operating in <italic>BIDsearch </italic>(<italic>ONLsearch</italic>) mode with subsequent global chaining of RSSP matches needed only 3.9 (122.5) seconds to identify all family members, whereas <italic>RNAMotif </italic>needed 84.7 seconds. The search times for <italic>Structator </italic>include 0.05 seconds required for the chaining.</p>
        <fig id="F10" position="float">
          <label>Figure 10</label>
          <caption>
            <p><bold>Descriptors for the OxyS RNA family.</bold> (A) Secondary structure descriptor for the family of OxyS RNAs in <italic>Structator </italic>syntax. The SSD consists of RSSPs RSSP1, RSSP2, and RSSP3 describing the three stem-loop structures (HP1, HP2, and HP3, see (C)) of this small non-coding RNA. (B) <italic>RNAMotif </italic>descriptor for the same structural elements. (C) Consensus secondary structure of the OxyS RNA family as drawn by <italic>VARNA </italic>[<xref ref-type="bibr" rid="B55">55</xref>]. Sequence information (non-wildcard nucleotides) used in both descriptors are marked with an asterisk. Observe that both descriptors use predominantly structure and very little sequence information.</p>
          </caption>
          <graphic xlink:href="1471-2105-12-214-10"/>
        </fig>
        <p>We also employed global chaining to detect members of the structurally more complex family of Citrus tristeza virus replication signal (Rfam Acc.: RF00193). Therefore we built an SSD comprising 8 RSSPs, describing 8 of 10 stem-loops the molecule is predicted to fold into. For more information on the molecule's secondary structure and the used descriptor, see Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> Figure S4. Using <italic>Structator </italic>operating in <italic>BIDsearch </italic>(<italic>ONLsearch</italic>) mode and global chaining of RSSP matches it took only 1.3 (138.7) seconds to search RFAM10 with this SSD, where 0.06 seconds were required for the chaining. The computed global chains with a minimum length of 5, computed from the 184,199 single RSSP matches, were ranked according to their global chain score. We observe that the sequences containing the 37 highest scoring chains are exactly all 37 members of the family.</p>
        <p>In addition we measured the performance of <italic>Structator </italic>using global chaining for RNA family classification with manually compiled SSDs for 42 Rfam families. For the results of this experiment see Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> Table S4.</p>
      </sec>
      <sec>
        <title>Searching whole genomes using local chains of RSSP matches</title>
        <p>As an example of searching a complete genome or whole chromosomes for non-coding RNAs, we searched for the RNA gene Human accelerated region 1F (HAR1F) on both strands of the human genome sequence. HAR1F is one of 49 regions in the human genome that differ significantly from highly conserved regions of the chimpanzee [<xref ref-type="bibr" rid="B53">53</xref>]. The consensus structure of the HAR1F family in Rfam (Acc.: RF00635) contains three stem-loop regions, denoted HP1, HP2, and HP3 in Figure <xref ref-type="fig" rid="F11">11(A)</xref>. From these regions, we built an SSD for the family with RSSPs RSSP1, RSSP2, and RSSP3, shown in Figure <xref ref-type="fig" rid="F11">11(B)</xref>. Since we were searching on complete chromosomes, we only wanted to consider RSSP matches that occurred at a similar distance to each other w.r.t. to the distances of the corresponding descriptors in the SSD. Therefore, unlike in the previous experiment where we searched for global chains of RSSP matches, we now computed high-scoring local chains. Gap costs were computed according to Equation (4) and we used an RSSP weight <italic>α</italic>(RSSP<italic><sub>i</sub></italic>) = 10, for 1 ≤ <italic>i </italic>≤ 3. Affix array construction for all human chromosomes was accomplished in 12.6 hours by <italic>afconstruct</italic>. We searched with <italic>Structator </italic>for the three RSSPs and found 15,090, 1,578, and 14,491 matches for RSSP1, RSSP2, and RSSP3, respectively. For these RSSP matches we computed local high-scoring chains (see Figure <xref ref-type="fig" rid="F11">11(D)</xref>). Chains <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i96.gif"/></inline-formula> were ranked according to their local chain score <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i120.gif"/></inline-formula>. We observed that the highest-scoring chain corresponds to the correct location of the gene on chromosome 20. Using <italic>BIDsearch </italic>(<italic>ONLsearch</italic>) this task needed 3.1 (633.4) seconds only, including 0.02 seconds for the chaining. <italic>RNAMotif </italic>also found a single match corresponding to the correct location of the gene, but needed 274.7 seconds. See Figure S5 in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> for the used <italic>RNAMotif </italic>descriptor.</p>
        <fig id="F11" position="float">
          <label>Figure 11</label>
          <caption>
            <p><bold>An example of local chains of RSSP matches</bold>. (A) Consensus secondary structure visualized with the <italic>VARNA </italic>program of the HAR1F RNA family showing stem-loops HP1, HP2, and HP3. (B) SSD consisting of RSSP1, RSSP2, and RSSP3 in <italic>Structator </italic>syntax describing the three stem-loop regions of HAR1F. (C) Regions of HAR1F described by the RSSPs, including distances <italic>l</italic><sub><italic>i</italic>+1 </sub>- <italic>r</italic><sub><italic>i</italic></sub>, 1 ≤ <italic>i </italic>&lt; 3, between neighbored RSSPs and RSSP weights <italic>α</italic>(RSSP<italic><sub>i</sub></italic>), 1 ≤ <italic>i </italic>≤ 3. (D) Examples of local chains <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i121.gif"/></inline-formula>, 1 ≤ <italic>i </italic>≤ 4 found with the SSD, showing, in each chain, the distance between RSSP matches and their local chain score <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i122.gif"/></inline-formula>. Gap cost computation according to Equation (4) is shown exemplary for the two RSSP matches of chain <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i123.gif"/></inline-formula>.</p>
          </caption>
          <graphic xlink:href="1471-2105-12-214-11"/>
        </fig>
      </sec>
      <sec>
        <title>Comparison of implementations of bidirectional pattern search</title>
        <p>In the last experiments we compared <italic>Structator'</italic>s running time using using <italic>BIDsearch </italic>with the time needed by a recently published bidirectional pattern search implementation for the same task. The implementation of [<xref ref-type="bibr" rid="B54">54</xref>], to which we refer as <italic>BWI</italic>, uses a compressed data structure called bidirectional wavelet index. We remark that <italic>BWI </italic>can only search with a small set of hard-coded patterns, i.e., the user cannot use it to search with his/her own patterns. Moreover, unlike <italic>Structator</italic>, which provides a full command line interface with many configurable options (see section about the software package), <italic>BWI </italic>reports neither matching substrings nor matching positions (which is known to be the most time consuming part when querying compressed index structures [<xref ref-type="bibr" rid="B26">26</xref>]). It only outputs the search time of individual patterns and the number of matches. Thus, it serves rather as a prototype implementation of the concepts introduced in [<xref ref-type="bibr" rid="B54">54</xref>]. Nevertheless, since it also makes use of bidirectional search, we compared <italic>BWI </italic>with <italic>Structator </italic>using <italic>BWI'</italic>s hard-coded patterns. See Table <xref ref-type="table" rid="T3">3</xref> for the results. Details of the database and patterns are as previously described [<xref ref-type="bibr" rid="B54">54</xref>]. We noticed that <italic>BIDsearch </italic>was faster than <italic>BWI </italic>for matching all patterns by up to factor 2, hence making it preferable when speed is most important. However, we note that <italic>BWI'</italic>s compressed wavelet index consumes significantly less memory than <italic>Structator'</italic>s affix array index, which would make <italic>BWI </italic>preferable in cases where space consumption is critical. See Table S3 in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> for the memory required by <italic>BWI'</italic>s index for different genomes. We also measured the speedup of <italic>Structator </italic>running in <italic>BIDsearch </italic>mode over <italic>ONLsearch </italic>and compared the results with previously reported measurements [<xref ref-type="bibr" rid="B27">27</xref>]. Because the implementation used there is not available (personal communication with the author), we calculated relative speedups based on the reported absolute running times. Details on this experiment are given in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> Section S2.</p>
        <table-wrap id="T3" position="float">
          <label>Table 3</label>
          <caption>
            <p>Search time comparison between <italic>Structator'</italic>s <italic>BIDsearch </italic>and an implementation, here called <italic>BWI</italic>, of bidirectional search using the wavelet tree data structure described in [<xref ref-type="bibr" rid="B54">54</xref>].</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th/>
                <th align="right">hairpin1</th>
                <th align="right">hairpin2</th>
                <th align="right">hairpin4</th>
                <th align="right">hloop(5)</th>
                <th align="right">acloop(5)</th>
                <th align="right">acloop(10)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center">
                  <italic>BWI</italic>
                </td>
                <td align="right">10,484</td>
                <td align="right">64</td>
                <td align="right">612</td>
                <td align="right">26,413</td>
                <td align="right">896</td>
                <td align="right">420</td>
              </tr>
              <tr>
                <td align="center">
                  <italic>BIDsearch</italic>
                </td>
                <td align="right">8,325</td>
                <td align="right">32</td>
                <td align="right">330</td>
                <td align="right">16,768</td>
                <td align="right">511</td>
                <td align="right">295</td>
              </tr>
              <tr>
                <td align="center"><italic>BIDsearch </italic>vs. <italic>BWI</italic></td>
                <td align="right">1.26</td>
                <td align="right">2</td>
                <td align="right">1.85</td>
                <td align="right">1.58</td>
                <td align="right">1.75</td>
                <td align="right">1.42</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Search times are in milliseconds. The last row shows the speedup of <italic>BIDsearch </italic>over <italic>BWI</italic>.</p>
          </table-wrap-foot>
        </table-wrap>
      </sec>
    </sec>
    <sec>
      <title>Structator software package</title>
      <p><italic>Structator </italic>is an open-source software package for fast database search with RNA structural patterns implementing the algorithms and ideas presented in this work. It consists of the command line programs <italic>afconstruct </italic>and <italic>afsearch</italic>.</p>
      <p><italic>afconstruct </italic>implements all algorithms necessary for affix array construction, namely a lightweight suffix sorting algorithm for construction of the suffix arrays suf<sub>F </sub>and suf<sub>R</sub>, the algorithm for construction of tables lcp<sub>F </sub>and lcp<sub>R </sub>[<xref ref-type="bibr" rid="B36">36</xref>], and the algorithm for computation of the affix link tables aflk<sub>F </sub>and aflk<sub>R</sub>. The program constructs all or if necessary only some of the tables of the affix array for a target database provided in FASTA format and stores them on disk. Therefore the program can also be used to compute only the tables needed for a traditional enhanced suffix array [<xref ref-type="bibr" rid="B34">34</xref>]. <italic>afconstruct </italic>can handle RNA as well as DNA sequences. Moreover, it supports the transformation of input sequences according to user-defined (reduced) alphabets and allows the index construction for transformed sequences. Such personalized alphabets are easily specified in a text file.</p>
      <p><italic>afsearch </italic>is the program for performing structural pattern matching. That is, it searches (ribo)nucleic acid sequence databases for entries that can adopt a particular secondary structure. For an overview of the supported RNA sequence-structure patterns (RSSPs), see Figure <xref ref-type="fig" rid="F12">12</xref>. The simplest RSSP describes a single-stranded region, where ambiguous (not well-conserved) nucleotides can be specified with IUPAC characters. All ambiguous IUPAC characters are hard-coded in <italic>afsearch</italic>, e.g. N standing for nucleotides A, C, G, and U (and T) and R standing for A and G. Besides fixed-length RSSPs with or without ambiguous characters (Figure <xref ref-type="fig" rid="F12">12(A)</xref> until <xref ref-type="fig" rid="F12">12(D)</xref>), also RSSPs describing loop or stem regions of variable size (Figure <xref ref-type="fig" rid="F12">12(E)</xref> until <xref ref-type="fig" rid="F12">12(H)</xref>) are supported. More precisely, one can specify with parameters <italic>maxleftloopextent (mllex) </italic>and <italic>maxrightloopextent (mrlex) </italic>a variable number of allowed extensions to the left (nucleotides marked in yellow in Figure <xref ref-type="fig" rid="F12">12(E)</xref>) and/or to the right (nucleotides marked in blue in Figure <xref ref-type="fig" rid="F12">12(F)</xref>) for the specified loop pattern. Variable stem sizes can be addressed with parameter <italic>maxstemlength (msl) </italic>(see regions marked in pink in Figure <xref ref-type="fig" rid="F12">12(G)</xref>). Also supported is the combination of variable loop and stem size (see Figure <xref ref-type="fig" rid="F12">12(H)</xref>) and a maximal number of allowed mispairings in the stem region. All these different RSSPs can be specified by the user in a text file which use, as shown in Figure <xref ref-type="fig" rid="F12">12</xref>, an expressive but easy to understand pattern syntax. For additional details on the supported patterns see the corresponding section in the <italic>Structator </italic>user manual. <italic>afsearch </italic>also permits user-defined base pairing rules. That is, the user can define an arbitrary subset from <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i124.gif"/></inline-formula> as valid pairings. This ensures a maximum of flexibility. For example, the standard canonical Watson-Crick pairings as well as non-standard pairings such as G-U can be specified.</p>
      <fig id="F12" position="float">
        <label>Figure 12</label>
        <caption>
          <p><bold>Supported structural patterns and corresponding pattern definitions in <italic>Structator </italic>syntax</bold>. Non-ambiguous nucleotides are marked in red. Positions containing ambiguous nucleotides, denoted here with character N, are marked in green and can contain any nucleotide from <inline-formula><inline-graphic xlink:href="1471-2105-12-214-i3.gif"/></inline-formula>. Maximal allowed left and right extensions of the loop region of a pattern as specified by parameters <italic>maxleftloopextent (mllex) </italic>and <italic>maxrightloopextent (mrlex) </italic>are marked in yellow and blue, respectively. Allowed possible extensions of a pattern's stem region as specified by parameter <italic>maxstemlength (msl) </italic>are marked in purple. As an example for the semantics of the parameter <italic>msl </italic>consider pattern (G): it matches all substrings of the searched sequence that are able to fold into a stem-loop structure with loop length 6 and stem length between 3 and 8. For further details see corresponding text.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-214-12"/>
      </fig>
      <p>The search is performed efficiently on a pre-computed affix array. <italic>afsearch </italic>implements the bidirectional index-based search algorithms <italic>BIDsearch </italic>and the online algorithm <italic>ONLsearch </italic>operating on the plain sequence, both extended to support patterns with variable loop size and/or stem length. Further, it implements the methods for fast global and local chaining of RSSP matches. The search with RSSPs can be performed on the forward and, in case of nucleotide sequences, also on the reverse strand. Searching on the reverse strand is implemented by reversal of the RSSP and transformation according to Watson-Crick base pairing. Hence it is sufficient to build the affix array for one strand only.</p>
      <p>RSSP matches can be reported directly by <italic>afsearch </italic>or can be used as input for the computation of high-scoring global or local chains of matches. Computed chains resemble the order of the RSSPs given in the pattern file and are reported in descending order of their chain score. This allows the description of complex secondary structures with our new concept of secondary structure descriptors (SSDs). This is done by simply specifying a series of RSSPs in the pattern file describing the stem-loop substructures the RNA molecule is composed of in the order of their occurrence in 5' to 3' direction. To incorporate different levels of importance or significance of an RSSP into SSD models and subsequently in the computation of chain scores, RSSP specific weights can be defined in the pattern file. This is particularly useful in the context of RNA family classification where the used SSD may be derived from a multiple sequence-structure alignment or a consensus structure-annotated multiple sequence alignment. Here, it permits the assignment of higher weights to RSSPs describing highly conserved functionally important structural elements occurring in a family of RNAs, and lower weights to RSSPs describing less conserved substructures that occur only in certain members of the family.</p>
      <p>The output format of <italic>afsearch </italic>contains all available information of a match or chain of matches, either in a human-readable, or a tab-delimited format. Moreover, <italic>afsearch </italic>can also report matches in BED format. This allows a direct visualization of the results in e.g. the UCSC genome browser.</p>
    </sec>
  </sec>
  <sec>
    <title>Discussion and conclusion</title>
    <p>We have presented a method for fast index-based search of RNA sequence-structure patterns (RSSPs), implemented in the <italic>Structator </italic>software. As part of the software, we give the first publicly available implementation of bidirectional pattern search using the affix array data structure. For the majority of biologically relevant RSSPs, our implementation of <italic>BIDsearch </italic>shows superior performance over previous programs. In a benchmark experiment on the Rfam database, <italic>BIDsearch </italic>was faster than <italic>RNAMotif </italic>and <italic>RNABOB </italic>by up to two orders of magnitude. Furthermore, in a comparison between <italic>BIDsearch </italic>and the program of [<xref ref-type="bibr" rid="B54">54</xref>], which works on compressed index data structures, <italic>BIDsearch </italic>was faster by up to 2 times. We observed that for RSSPs with long unconserved loop regions, the advantage of <italic>BIDsearch </italic>over <italic>ONLsearch </italic>decreases. For such cases, <italic>Structator </italic>can also employ <italic>ONLsearch </italic>on the plain sequence data. As a further contribution, we presented for the first time a detailed complexity analysis of bidirectional search using affix arrays. While bidirectional search does not does not improve the worst-case time complexity compared to online search, in practice it runs much faster than online search algorithms and the running time scales sublinearly with the length <italic>n </italic>of the searched sequences.</p>
    <p>Our implementation of the affix array data structure requires only 18<italic>n </italic>bytes of space. This is a significant space reduction compared to the ~ 45<italic>n </italic>bytes needed for the affix tree. With the program <italic>afconstruct </italic>we present for the first time a command line tool for the efficient construction and persistent storage of affix arrays that can also be used as a stand-alone program for index construction.</p>
    <p>With the new concept of RNA secondary structure descriptors (SSDs) combined with fast global and local chaining algorithms, all integrated into <italic>Structator</italic>, we also introduce a powerful technique to describe RNAs with complex secondary structures. This even allows to effectively describe RNA families containing branching substructures like multi-loops, by decomposition into sequences of non-branching substructures that can be described with RSSPs. Compared to programs like <italic>RNAMotif </italic>, <italic>Structator'</italic>s pattern description language for RSSP formulation is simple but powerful, in particular in combination with the SSD concept. Beyond the algorithmic contributions, we provide with the <italic>Structator </italic>software distribution a robust, well-documented, and easy-to-use software package implementing the ideas and algorithms presented in this manuscript.</p>
  </sec>
  <sec>
    <title>Availability</title>
    <p>The <italic>Structator </italic>software package including documentation is available in binary format for different operating systems and architectures and as source code under the GNU General Public License Version 3. See <ext-link ext-link-type="uri" xlink:href="http://www.zbh.uni-hamburg.de/Structator">http://www.zbh.uni-hamburg.de/Structator</ext-link> for details.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>FM implemented the presented algorithms and wrote parts of the manuscript and the <italic>Structator </italic>manual. SK developed and implemented the RSSP chaining algorithms and contributed to the manuscript. SW provided supervision and wrote parts of the manuscript. MB initiated the project, provided supervision and guidance, designed/performed the experiments and wrote large parts of the manuscript. RB contributed to the introduction. All authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Supplemental material</bold>. Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> contains additional examples, algorithms, experiments, figures, and tables.</p>
      </caption>
      <media xlink:href="1471-2105-12-214-S1.PDF" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>This work was supported by the German Research Foundation (grant WI 3628/1-1). We also thank the anonymous referees, especially referee 2, for their valuable comments and suggestions.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Mattick</surname>
          <given-names>J</given-names>
        </name>
        <article-title>RNA regulation: a new genetics?</article-title>
        <source>Nat Rev Genet</source>
        <year>2004</year>
        <volume>5</volume>
        <issue>4</issue>
        <fpage>316</fpage>
        <lpage>323</lpage>
        <pub-id pub-id-type="doi">10.1038/nrg1321</pub-id>
        <pub-id pub-id-type="pmid">15131654</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="other">
        <name>
          <surname>Mattick</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Taft</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Faulkner</surname>
          <given-names>G</given-names>
        </name>
        <article-title>A global view of genomic information - moving beyond the gene and the master regulator</article-title>
        <source>Trends Genet</source>
        <year>2009</year>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="other">
        <name>
          <surname>Gardner</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Daub</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Tate</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Moore</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Osuch</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Griffiths-Jones</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Finn</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Nawrocki</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Kolbe</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Bateman</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Rfam: Wikipedia, clans and the "decimal" release</article-title>
        <source>Nucl. Acids Res</source>
        <year>2010</year>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gardner</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Daub</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Tate</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Nawrocji</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Kolbe</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Lindgreen</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Wilkinson</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Finn</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Griffith-Jones</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Bateman</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Rfam: updates to the RNA families database</article-title>
        <source>Nucl. Acids Res</source>
        <year>2008</year>
        <volume>37</volume>
        <fpage>D136</fpage>
        <lpage>D140</lpage>
        <pub-id pub-id-type="pmid">18953034</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gardner</surname>
          <given-names>PP</given-names>
        </name>
        <name>
          <surname>Wilm</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Washietl</surname>
          <given-names>S</given-names>
        </name>
        <article-title>A benchmark of multiple sequence alignment programs upon structural RNAs</article-title>
        <source>Nucl. Acids Res</source>
        <year>2005</year>
        <volume>33</volume>
        <issue>8</issue>
        <fpage>2433</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gki541</pub-id>
        <pub-id pub-id-type="pmid">15860779</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Höchsmann</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Voss</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Giegerich</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Pure multiple RNA secondary structure alignments: a progressive profile approach</article-title>
        <source>IEEE/ACM Trans Comput Biol Bioinform</source>
        <year>2004</year>
        <volume>1</volume>
        <fpage>53</fpage>
        <lpage>62</lpage>
        <pub-id pub-id-type="doi">10.1109/TCBB.2004.11</pub-id>
        <pub-id pub-id-type="pmid">17048408</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Siebert</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Backofen</surname>
          <given-names>R</given-names>
        </name>
        <article-title>MARNA: multiple alignment and consensus structure prediction of RNAs based on sequence structure comparisons</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <issue>16</issue>
        <fpage>3352</fpage>
        <lpage>3359</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bti550</pub-id>
        <pub-id pub-id-type="pmid">15972285</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sankoff</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Simultaneous solution of the RNA folding, alignment and protosequence problem</article-title>
        <source>SIAM Journal on Applied Mathematics</source>
        <year>1985</year>
        <volume>45</volume>
        <fpage>810</fpage>
        <lpage>825</lpage>
        <pub-id pub-id-type="doi">10.1137/0145048</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gorodkin</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Heyer</surname>
          <given-names>LJ</given-names>
        </name>
        <name>
          <surname>Stormo</surname>
          <given-names>GD</given-names>
        </name>
        <article-title>Finding the most significant common sequence and structure motifs in a set of RNA sequences</article-title>
        <source>Nucl. Acids Res</source>
        <year>1997</year>
        <volume>25</volume>
        <issue>18</issue>
        <fpage>3724</fpage>
        <lpage>32</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/25.18.3724</pub-id>
        <pub-id pub-id-type="pmid">9278497</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Havgaard</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Lyngso</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Stormo</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Gorodkin</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Pairwise local structural alignment of RNA sequences with sequence similarity less than 40%</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <fpage>1815</fpage>
        <lpage>1824</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bti279</pub-id>
        <pub-id pub-id-type="pmid">15657094</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Mathews</surname>
          <given-names>DH</given-names>
        </name>
        <name>
          <surname>Turner</surname>
          <given-names>DH</given-names>
        </name>
        <article-title>Dynalign: an algorithm for finding the secondary structure common to two RNA sequences</article-title>
        <source>Journal of Molecular Biology</source>
        <year>2002</year>
        <volume>317</volume>
        <issue>2</issue>
        <fpage>191</fpage>
        <lpage>203</lpage>
        <pub-id pub-id-type="doi">10.1006/jmbi.2001.5351</pub-id>
        <pub-id pub-id-type="pmid">11902836</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Will</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Reiche</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Hofacker</surname>
          <given-names>IL</given-names>
        </name>
        <name>
          <surname>Stadler</surname>
          <given-names>PF</given-names>
        </name>
        <name>
          <surname>Backofen</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Inferring noncoding RNA families and classes by means of genome-scale structure-based clustering</article-title>
        <source>PLoS Comput. Biol</source>
        <year>2007</year>
        <volume>3</volume>
        <issue>4</issue>
        <fpage>e65</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.0030065</pub-id>
        <pub-id pub-id-type="pmid">17432929</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Macke</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Ecker</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Gutell</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Gautheret</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Case</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Sampath</surname>
          <given-names>R</given-names>
        </name>
        <article-title>RNAMotif - A new RNA secondary structure definition and discovery algorithm</article-title>
        <source>Nucl. Acids Res</source>
        <year>2001</year>
        <volume>29</volume>
        <issue>22</issue>
        <fpage>4724</fpage>
        <lpage>4735</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/29.22.4724</pub-id>
        <pub-id pub-id-type="pmid">11713323</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gautheret</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Major</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Cedergren</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Pattern searching/alignment with RNA primary and secondary structures: an effective descriptor for tRNA</article-title>
        <source>Comput Appl Biosci</source>
        <year>1990</year>
        <volume>6</volume>
        <issue>4</issue>
        <fpage>325</fpage>
        <lpage>31</lpage>
        <pub-id pub-id-type="pmid">1701686</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="other">
        <article-title>RNABOB: a program to search for RNA secondary structure motifs in sequence databases</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://selab.janelia.org/software.html">http://selab.janelia.org/software.html</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chang</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Huang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Chuang</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Shien</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Horng</surname>
          <given-names>J</given-names>
        </name>
        <article-title>RNAMST: efficient and flexible approach for identifying RNA structural homologs</article-title>
        <source>Nucl. Acids Res</source>
        <year>2006</year>
        <volume>34</volume>
        <fpage>W423</fpage>
        <lpage>W428</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkl231</pub-id>
        <pub-id pub-id-type="pmid">16845040</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dsouza</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Larsen</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Overbeek</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Searching for patterns in genomic data</article-title>
        <source>Trends Genet</source>
        <year>1997</year>
        <volume>13</volume>
        <issue>12</issue>
        <fpage>497</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="pmid">9433140</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Grillo</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Licciulli</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Liuni</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Sbisà</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Pesole</surname>
          <given-names>G</given-names>
        </name>
        <article-title>PatSearch: A program for the detection of patterns and structural motifs in nucleotide sequences</article-title>
        <source>Nucl. Acids Res</source>
        <year>2003</year>
        <volume>31</volume>
        <issue>13</issue>
        <fpage>3608</fpage>
        <lpage>12</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkg548</pub-id>
        <pub-id pub-id-type="pmid">12824377</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Nawrocki</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Query-dependent banding (QDB) for faster RNA similarity searches</article-title>
        <source>PLoS Comput. Biol</source>
        <year>2007</year>
        <volume>3</volume>
        <issue>56</issue>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Nawrocki</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Kolbe</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Infernal 1.0: inference of RNA alignments</article-title>
        <source>BMC Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1335</fpage>
        <lpage>1337</lpage>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Klein</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>S</given-names>
        </name>
        <article-title>RSEARCH: finding homologs of single structured RNA sequences</article-title>
        <source>BMC Bioinformatics</source>
        <year>2003</year>
        <volume>4</volume>
        <fpage>44</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-4-44</pub-id>
        <pub-id pub-id-type="pmid">14499004</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sakakibara</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>Pair hidden markov models on tree structures</article-title>
        <source>BMC Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <fpage>i232</fpage>
        <lpage>40</lpage>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gautheret</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Lambert</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Direct RNA motif definition and identification from multiple sequence alignments using secondary structure profiles</article-title>
        <source>J Mol Biol</source>
        <year>2001</year>
        <volume>313</volume>
        <fpage>1003</fpage>
        <lpage>11</lpage>
        <pub-id pub-id-type="doi">10.1006/jmbi.2001.5102</pub-id>
        <pub-id pub-id-type="pmid">11700055</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="book">
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <source>Algorithms on strings, trees, and sequences: computer science and computational biology</source>
        <year>1997</year>
        <publisher-name>Cambridge Univ. Press</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Manber</surname>
          <given-names>U</given-names>
        </name>
        <name>
          <surname>Myers</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Suffix arrays: a new method for on-line string searches</article-title>
        <source>SIAM Journal on Computing</source>
        <year>1993</year>
        <volume>22</volume>
        <issue>5</issue>
        <fpage>935</fpage>
        <lpage>948</lpage>
        <pub-id pub-id-type="doi">10.1137/0222058</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ferragina</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Manzini</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Indexing compressed text</article-title>
        <source>Journal of the ACM</source>
        <year>2005</year>
        <volume>52</volume>
        <issue>4</issue>
        <fpage>552</fpage>
        <lpage>581</lpage>
        <pub-id pub-id-type="doi">10.1145/1082036.1082039</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Strothmann</surname>
          <given-names>D</given-names>
        </name>
        <article-title>The affix array data structure and its applications to RNA secondary structure analysis</article-title>
        <source>Theor. Comput. Sci</source>
        <year>2007</year>
        <volume>389</volume>
        <issue>1-2</issue>
        <fpage>278</fpage>
        <lpage>294</lpage>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Mauri</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Pavesi</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Algorithms for pattern matching and discovery in RNA secondary structure</article-title>
        <source>Theor. Comput. Sci</source>
        <year>2005</year>
        <volume>335</volume>
        <fpage>29</fpage>
        <lpage>51</lpage>
        <pub-id pub-id-type="doi">10.1016/j.tcs.2004.12.015</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Maaß</surname>
          <given-names>MG</given-names>
        </name>
        <article-title>Linear bidirectional on-line construction of affix trees</article-title>
        <source>Algorithmica</source>
        <year>2003</year>
        <volume>37</volume>
        <fpage>43</fpage>
        <lpage>74</lpage>
        <pub-id pub-id-type="doi">10.1007/s00453-003-1029-2</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="book">
        <name>
          <surname>Mauri</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Pavesi</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Pattern discovery in RNA secondary structures using affix trees</article-title>
        <source>Proceedings of the 14th Annual Symposium on Combinatorial Pattern Matching</source>
        <year>2003</year>
        <volume>2676</volume>
        <publisher-name>Springer</publisher-name>
        <fpage>278</fpage>
        <lpage>294</lpage>
        <pub-id pub-id-type="doi">10.1007/3-540-44888-8_21</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="book">
        <name>
          <surname>Kärkkäinen</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Sanders</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Simple linear work suffix array construction</article-title>
        <source>Proceedings of the 13th International Conference on Automata, Languges and Programming</source>
        <year>2003</year>
        <publisher-name>Springer</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="book">
        <name>
          <surname>Puglisi</surname>
          <given-names>SJ</given-names>
        </name>
        <name>
          <surname>Smyth</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Turpin</surname>
          <given-names>A</given-names>
        </name>
        <article-title>The performance of linear time suffix sorting algorithms</article-title>
        <source>DCC '05: Proceedings of the Data Compression Conference</source>
        <year>2005</year>
        <publisher-name>Washington, DC, USA: IEEE Computer Society</publisher-name>
        <fpage>358</fpage>
        <lpage>367</lpage>
        <pub-id pub-id-type="pmid">21769715</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Manzini</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Ferragina</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Engineering a lightweight suffix array construction algorithm</article-title>
        <source>Algorithmica</source>
        <year>2004</year>
        <volume>40</volume>
        <fpage>33</fpage>
        <lpage>50</lpage>
        <pub-id pub-id-type="doi">10.1007/s00453-004-1094-1</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Abouelhoda</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kurtz</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Ohlebusch</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Replacing suffix trees with enhanced suffix arrays</article-title>
        <source>Journal of Discrete Algorithms</source>
        <year>2004</year>
        <volume>2</volume>
        <fpage>53</fpage>
        <lpage>86</lpage>
        <pub-id pub-id-type="doi">10.1016/S1570-8667(03)00065-0</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Fischer</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Wee LCP</article-title>
        <source>Information Processing Letters</source>
        <year>2010</year>
        <volume>110</volume>
        <issue>8-9</issue>
        <fpage>317</fpage>
        <lpage>320</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ipl.2010.02.010</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B36">
      <mixed-citation publication-type="other">
        <name>
          <surname>Kasai</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Lee</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Arimura</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Arikawa</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Park</surname>
          <given-names>K</given-names>
        </name>
        <article-title>Linear-time longest-common-prefix computation in suffix arrays and its applications</article-title>
        <source>Proceedings of the 18th Annual Symposium on Combinatorial Pattern Matching</source>
        <year>2001</year>
        <fpage>181</fpage>
        <lpage>192</lpage>
      </mixed-citation>
    </ref>
    <ref id="B37">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Beckstette</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Homann</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Giegerich</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Kurtz</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Fast index based algorithms and software for matching position specific scoring matrices</article-title>
        <source>BMC Bioinformatics</source>
        <year>2006</year>
        <volume>7</volume>
        <fpage>389</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-7-389</pub-id>
        <pub-id pub-id-type="pmid">16930469</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B38">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Beckstette</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Homann</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Giegerich</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Kurtz</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Significant speedup of database searches with HMMs by search space reduction with PSSM family models</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>24</issue>
        <fpage>3251</fpage>
        <lpage>3258</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp593</pub-id>
        <pub-id pub-id-type="pmid">19828575</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B39">
      <mixed-citation publication-type="book">
        <name>
          <surname>Abouelhoda</surname>
          <given-names>MI</given-names>
        </name>
        <name>
          <surname>Ohlebusch</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Kurtz</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Optimal exact string matching based on suffix arrays</article-title>
        <source>Proceedings of the 9th International Symposium on String Processing and Information Retrieval</source>
        <year>2002</year>
        <volume>2476</volume>
        <publisher-name>Springer</publisher-name>
        <fpage>31</fpage>
        <lpage>43</lpage>
      </mixed-citation>
    </ref>
    <ref id="B40">
      <mixed-citation publication-type="journal">
        <name>
          <surname>de Bruijn</surname>
          <given-names>N</given-names>
        </name>
        <article-title>A combinatorial problem</article-title>
        <source>Koninklijke Nederlandse Akademie v. Wetenschappen</source>
        <year>1946</year>
        <volume>49</volume>
        <fpage>758</fpage>
        <lpage>764</lpage>
      </mixed-citation>
    </ref>
    <ref id="B41">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gardner</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Giegerich</surname>
          <given-names>R</given-names>
        </name>
        <article-title>A comprehensive comparison of comparative RNA structure prediction approaches</article-title>
        <source>BMC Bioinformatics</source>
        <year>2004</year>
        <volume>5</volume>
        <issue>140</issue>
      </mixed-citation>
    </ref>
    <ref id="B42">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hofacker</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Fekete</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Stadler</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Secondary structure prediction for aligned RNA sequences</article-title>
        <source>Journal of Molecular Biology</source>
        <year>2002</year>
        <volume>319</volume>
        <issue>5</issue>
        <fpage>1059</fpage>
        <lpage>66</lpage>
        <pub-id pub-id-type="doi">10.1016/S0022-2836(02)00308-X</pub-id>
        <pub-id pub-id-type="pmid">12079347</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B43">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Knudsen</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Hein</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Pfold: RNA secondary structure prediction using stochastic context-free grammars</article-title>
        <source>Nucl. Acids Res</source>
        <year>2003</year>
        <volume>31</volume>
        <issue>13</issue>
        <fpage>3423</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkg614</pub-id>
        <pub-id pub-id-type="pmid">12824339</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B44">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hofacker</surname>
          <given-names>I</given-names>
        </name>
        <article-title>RNA consensus structure prediction with RNAalifold</article-title>
        <source>Methods Mol Biol</source>
        <year>2007</year>
        <volume>395</volume>
        <fpage>527</fpage>
        <lpage>544</lpage>
        <pub-id pub-id-type="doi">10.1007/978-1-59745-514-5_33</pub-id>
        <pub-id pub-id-type="pmid">17993696</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B45">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bremges</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Schirmer</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Giegerich</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Fine-tuning structural RNA alignments in the twilight zone</article-title>
        <source>BMC Bioinformatics</source>
        <year>2010</year>
        <volume>11</volume>
        <issue>222</issue>
      </mixed-citation>
    </ref>
    <ref id="B46">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Torarinsson</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Havgaard</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Gorodkin</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Multiple structural alignment and clustering of RNA sequences</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <fpage>926</fpage>
        <lpage>932</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btm049</pub-id>
        <pub-id pub-id-type="pmid">17324941</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B47">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Harmanci</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Sharma</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Mathews</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Efficient pairwise RNA structure prediction using probabilistic alignment constraints</article-title>
        <source>BMC Bioinformatics</source>
        <year>2007</year>
        <volume>8</volume>
        <issue>130</issue>
      </mixed-citation>
    </ref>
    <ref id="B48">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Reeder</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Giegerich</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Consensus shapes: an alternative to the Sankoff algorithm for RNA consensus structure prediction</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <issue>17</issue>
        <fpage>3516</fpage>
        <lpage>23</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bti577</pub-id>
        <pub-id pub-id-type="pmid">16020472</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B49">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wilm</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Higgins</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Notredame</surname>
          <given-names>C</given-names>
        </name>
        <article-title>R-Coffee: a method for multiple alignment of non-coding RNA</article-title>
        <source>Nucl. Acids Res</source>
        <year>2008</year>
        <volume>36</volume>
        <issue>9</issue>
      </mixed-citation>
    </ref>
    <ref id="B50">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Abouelhoda</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Ohlebusch</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Chaining algorithms for multiple genome comparison</article-title>
        <source>J. Discrete Algorithms</source>
        <year>2005</year>
        <volume>3</volume>
        <issue>2-4</issue>
        <fpage>321</fpage>
        <lpage>341</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jda.2004.08.011</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B51">
      <mixed-citation publication-type="book">
        <name>
          <surname>Cormen</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Leiserson</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Rivest</surname>
          <given-names>R</given-names>
        </name>
        <source>Introduction to algorithms</source>
        <year>1990</year>
        <publisher-name>Cambridge, MA: MIT Press</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B52">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Altuvia</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Argaman</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Tiwari</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Storz</surname>
          <given-names>G</given-names>
        </name>
        <article-title>The Escherichia coli OxyS regulatory RNA represses fhlA translation by blocking ribosome binding</article-title>
        <source>EMBO</source>
        <year>1998</year>
        <volume>15</volume>
        <issue>20</issue>
        <fpage>6069</fpage>
        <lpage>75</lpage>
      </mixed-citation>
    </ref>
    <ref id="B53">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pollard</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Salama</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Lambert</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Lambot</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Coppens</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Pedersen</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Katzman</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>King</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Onodera</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Siepel</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Kern</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Dehay</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Igel</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ares</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Vanderhaeghen</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Haussler</surname>
          <given-names>D</given-names>
        </name>
        <article-title>An RNA gene expressed during cortical development evolved rapidly in humans</article-title>
        <source>Nature</source>
        <year>2006</year>
        <volume>443</volume>
        <issue>7108</issue>
        <fpage>167</fpage>
        <lpage>172</lpage>
        <pub-id pub-id-type="doi">10.1038/nature05113</pub-id>
        <pub-id pub-id-type="pmid">16915236</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B54">
      <mixed-citation publication-type="book">
        <name>
          <surname>Schnattinger</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Ohlebusch</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Gog</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Bidirectional search in a string with wavelet trees</article-title>
        <source>Proceedings of the 21st Annual Symposium on Combinatorial Pattern Matching</source>
        <year>2010</year>
        <volume>6129</volume>
        <publisher-name>Springer</publisher-name>
        <fpage>40</fpage>
        <lpage>50</lpage>
        <pub-id pub-id-type="doi">10.1007/978-3-642-13509-5_5</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B55">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Darty</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Denise</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Ponty</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>VARNA: Interactive drawing and editing of the RNA seondary structure</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>15</issue>
        <fpage>1974</fpage>
        <lpage>1975</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp250</pub-id>
        <pub-id pub-id-type="pmid">19398448</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
