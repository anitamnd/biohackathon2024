<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6612878</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz344</article-id>
    <article-id pub-id-type="publisher-id">btz344</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2019 Conference Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Population Genomics and Molecular Evolution</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>TreeMerge: a new method for improving the scalability of species tree estimation methods</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Molloy</surname>
          <given-names>Erin K</given-names>
        </name>
        <xref ref-type="aff" rid="btz344-aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0001-7717-3514</contrib-id>
        <name>
          <surname>Warnow</surname>
          <given-names>Tandy</given-names>
        </name>
        <xref ref-type="corresp" rid="btz344-cor1"/>
        <!--<email>warnow@illinois.edu</email>-->
        <xref ref-type="aff" rid="btz344-aff1"/>
      </contrib>
    </contrib-group>
    <aff id="btz344-aff1">Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL, USA</aff>
    <author-notes>
      <corresp id="btz344-cor1">To whom correspondence should be addressed. <email>warnow@illinois.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-05">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>35</volume>
    <issue>14</issue>
    <fpage>i417</fpage>
    <lpage>i426</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz344.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>At RECOMB-CG 2018, we presented NJMerge and showed that it could be used within a divide-and-conquer framework to scale computationally intensive methods for species tree estimation to larger datasets. However, NJMerge has two significant limitations: it can fail to return a tree and, when used within the proposed divide-and-conquer framework, has <italic>O</italic>(<italic>n</italic><sup>5</sup>) running time for datasets with <italic>n</italic> species.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>Here we present a new method called ‘TreeMerge’ that improves on NJMerge in two ways: it is guaranteed to return a tree and it has dramatically faster running time within the same divide-and-conquer framework—only <italic>O</italic>(<italic>n</italic><sup>2</sup>) time. We use a simulation study to evaluate TreeMerge in the context of multi-locus species tree estimation with two leading methods, ASTRAL-III and RAxML. We find that the divide-and-conquer framework using TreeMerge has a minor impact on species tree accuracy, dramatically reduces running time, and enables both ASTRAL-III and RAxML to complete on datasets (that they would otherwise fail on), when given 64 GB of memory and 48 h maximum running time. Thus, TreeMerge is a step toward a larger vision of enabling researchers with limited computational resources to perform large-scale species tree estimation, which we call <italic>Phylogenomics for All</italic>.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>TreeMerge is publicly available on Github (<ext-link ext-link-type="uri" xlink:href="http://github.com/ekmolloy/treemerge">http://github.com/ekmolloy/treemerge</ext-link>).</p>
      </sec>
      <sec id="s4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">U.S. National Science Foundation</named-content>
        </funding-source>
        <award-id>CCF-1535977</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">NSF Graduate Research Fellowship</named-content>
        </funding-source>
        <award-id>DGE-1144245</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">NSF</named-content>
          <named-content content-type="funder-identifier">10.13039/100000001</named-content>
        </funding-source>
        <award-id>OCI-0725070</award-id>
        <award-id>ACI-1238993</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Species tree estimation is a basic step in many biological studies and has traditionally been performed by selecting regions from across the genomes for a set of species, constructing multiple sequence alignments on each of these regions, and then estimating a species tree from the concatenated alignment using popular phylogeny estimation methods, such as maximum likelihood (ML) heuristics. While these concatenation analyses are standard in systematic studies, the realization that different parts of the genome can have different evolutionary histories (<xref rid="btz344-B17" ref-type="bibr">Maddison, 1997</xref>) has spurred the development of new approaches to species tree estimation that can address heterogeneity across the genome. Many biological processes can result in gene trees being different from each other (and from the species phylogeny), including gene duplication and loss (GDL), incomplete lineage sorting (ILS), horizontal gene transfer (HGT) and hybridizing speciation. The presence of hybridization and HGT implies that phylogenetic networks are needed rather than trees, but ILS and GDL are consistent with a species tree. The inference of phylogenetic trees in the presence of GDL is particularly difficult and is related to the problems of orthology prediction and gene tree reconciliation (<xref rid="btz344-B2" ref-type="bibr">Bansal and Eulenstein, 2013</xref>; <xref rid="btz344-B3" ref-type="bibr">Bayzid and Warnow, 2018</xref>; <xref rid="btz344-B4" ref-type="bibr">Boussau <italic>et al.</italic>, 2013</xref>; <xref rid="btz344-B11" ref-type="bibr">Lai <italic>et al.</italic>, 2012</xref>; <xref rid="btz344-B28" ref-type="bibr">Nakhleh, 2013</xref>; <xref rid="btz344-B44" ref-type="bibr">The Quest for Orthologs Consortium <italic>et al.</italic>, 2014</xref>; <xref rid="btz344-B45" ref-type="bibr">Tofigh <italic>et al.</italic>, 2011</xref>).</p>
    <p>ILS, which is modeled by the multi-species coalescent (MSC) model (<xref rid="btz344-B8" ref-type="bibr">Kingman, 1982</xref>), has been shown to be a major challenge for estimating species trees for many biological datasets, including birds (<xref rid="btz344-B7" ref-type="bibr">Jarvis <italic>et al.</italic>, 2014</xref>) and plants (<xref rid="btz344-B49" ref-type="bibr">Wickett <italic>et al.</italic>, 2014</xref>). Concatenation analyses using ML are not statistically consistent under the MSC+ Generalized Time Reversible (GTR) model [even if run in a fully partitioned mode, as shown in <xref rid="btz344-B34" ref-type="bibr">Roch <italic>et al.</italic> (2019)</xref>], where the MSC+GTR model assumes that gene trees evolve within a species tree under the MSC model, and then sequences evolve down each gene tree under the GTR model (<xref rid="btz344-B43" ref-type="bibr">Tavaré, 1986</xref>). Furthermore, simulation studies have shown that concatenation analyses can have poor accuracy when ILS levels are high (<xref rid="btz344-B10" ref-type="bibr">Kubatko and Degnan, 2007</xref>; <xref rid="btz344-B22" ref-type="bibr">Mirarab <italic>et al.</italic>, 2014b</xref>, <xref rid="btz344-B24" ref-type="bibr">2016</xref>; <xref rid="btz344-B27" ref-type="bibr">Molloy and Warnow, 2018c</xref>).</p>
    <p>Because gene tree heterogeneity is frequently observed in biological datasets, many new methods have been developed to estimate species trees from multi-locus datasets taking ILS into consideration, surveyed in <xref rid="btz344-B47" ref-type="bibr">Warnow (2017)</xref>. Some of the most scalable species tree methods operate by estimating gene trees and then combining the estimated gene trees together, typically using summary statistics. Methods that combine gene trees, referred to as ‘summary methods’, are often provably statistically consistent under the MSC model when given true gene trees as input. However, in practice, gene trees are estimated, and standard summary methods can be statistically inconsistent (and even positively misleading) when using estimated gene trees (<xref rid="btz344-B34" ref-type="bibr">Roch <italic>et al.</italic>, 2019</xref>). Furthermore, summary methods tend to have poorer accuracy when gene tree estimation error is high (<xref rid="btz344-B20" ref-type="bibr">Mirarab and Warnow, 2015</xref>) and can be less accurate than concatenation analyses using ML even under high ILS conditions when gene tree estimation error is sufficiently high (<xref rid="btz344-B27" ref-type="bibr">Molloy and Warnow, 2018c</xref>). Note that gene tree estimation error can be impacted by the choice of sequencing methodologies and sampling strategies; for example, ultra-conserved elements (UCEs) typically have lower phylogenetic signal and thus higher gene tree estimation error (<xref rid="btz344-B19" ref-type="bibr">Meiklejohn <italic>et al.</italic>, 2016</xref>).</p>
    <p>Many phylogenomic analyses of biological datasets estimate species trees with both concatenation analyses and summary methods. Among summary methods, one of the most popular methods is ASTRAL (<xref rid="btz344-B21" ref-type="bibr">Mirarab <italic>et al.</italic>, 2014a</xref>), which has typically produced more accurate trees than other similarly scalable summary methods in simulation studies. ASTRAL has a polynomial running time that scales with the number of species, the number of gene trees, and the degree of heterogeneity in the input gene trees (which is greater when ILS levels are high). The most popular concatenation analysis is ML, often using RAxML (<xref rid="btz344-B36" ref-type="bibr">Stamatakis, 2014</xref>), which is optimized for multi-locus datasets. ML is NP-hard (<xref rid="btz344-B33" ref-type="bibr">Roch, 2006</xref>), so RAxML uses heuristics based on hill-climbing and randomization to search for an optimal ML tree within an exponentially-sized search space, terminating when its stopping criterion is met. As a result, RAxML can be very expensive to use for datasets with large numbers of species and even for datasets with only moderate numbers of species but with long alignments that are not highly compressible.</p>
    <p>Divide-and-conquer is a well-known approach for scaling methods to larger datasets. Recently, <xref rid="btz344-B25" ref-type="bibr">Molloy and Warnow (2018a</xref>) presented a divide-and-conquer framework that operates by dividing species into pairwise disjoint subsets, estimating trees on subsets, and merging subset trees together using a new method, called NJMerge. NJMerge uses an estimated distance matrix to perform the merger, treating the input subset trees as absolute constraints, so that the topology of the returned species tree must agree with the topology of each of the input subset trees. <xref rid="btz344-B26" ref-type="bibr">Molloy and Warnow (2018b</xref>) proved that some species tree estimation pipelines using NJMerge are statistically consistent under the MSC+GTR model, and furthermore, pipelines using NJMerge were shown to dramatically reduce the running time of ASTRAL-III and RAxML on large multi-locus datasets, while maintaining accuracy. Despite these promising results, NJMerge has two main issues that limit its utility in practice. First, NJMerge can <italic>fail</italic> to return a tree, and although the failure rate in these studies was low, the conditions under which NJMerge fails have not been carefully evaluated. Second, when used within the proposed divide-and-conquer framework, NJMerge has <italic>O</italic>(<italic>n</italic><sup>5</sup>) running time, where <italic>n</italic> is the number of species.</p>
    <p>Here, we present two new methods for merging trees on pairwise disjoint leaf sets using an estimated distance matrix: NJMerge-2, which is a minor modification to NJMerge, and TreeMerge. Both NJMerge-2 and TreeMerge are guaranteed to return a compatibility supertree on all inputs, and so never fail. When used within the proposed divide-and-conquer framework, NJMerge-2 and a slow variant of TreeMerge have the same running time as NJMerge—<italic>O</italic>(<italic>n</italic><sup>5</sup>). In contrast, a fast variant of TreeMerge has only <italic>O</italic>(<italic>n</italic><sup>2</sup>) running time. We establish that divide-and-conquer pipelines using NJMerge-2 and TreeMerge are provably statistically consistent under the MSC+GTR model; however, the requirements for pipelines using the fast variant of TreeMerge to be statistically consistent are stronger than the very mild requirements for pipelines using the slow variant of TreeMerge. Despite this difference in theory, our experimental results show that the less constrained divide-and-conquer pipelines using the fast variant of TreeMerge dramatically reduced the running time of both ASTRAL-III and RAxML and maintained accuracy. Most significantly, both ASTRAL-III and RAxML failed to complete on many datasets with 1000 species and 1000 genes using the available resources (64 GB of memory and 48 h maximum wall-clock time); however, the fast variant of TreeMerge enabled each method to complete on all the datasets using the same resources. Thus, TreeMerge is a promising technique for scaling species tree estimation methods to larger datasets.</p>
    <p>The rest of the paper is organized as follows. In Section 2, we present NJMerge-2 and TreeMerge and establish their theoretical guarantees. In Section 3, we describe how TreeMerge was used in a divide-and-conquer framework for species tree estimation and the experimental study designed to evaluate this approach. In Section 4, we discuss the results of this study, and we conclude in Section 5 with suggestions for future work.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Divide-and-conquer framework</title>
      <p>The input to the species tree estimation problem is a multi-locus dataset with sequences coming from <italic>m</italic> genomic regions for a set <italic>S</italic> of <italic>n</italic> species. We use a divide-and-conquer framework, introduced in <xref rid="btz344-B25" ref-type="bibr">Molloy and Warnow (2018a</xref>), to estimate the species tree (i.e. an unrooted binary tree with the <italic>n</italic> leaves labeled by the species set <italic>S</italic>) as follows:
<list list-type="order"><list-item><p>Decompose the species set <italic>S</italic> into pairwise disjoint subsets with a predetermined maximum size.</p></list-item><list-item><p>Estimate a species tree on each subset, producing a set <inline-formula id="IE1"><mml:math id="IM1"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of trees on pairwise disjoint subsets of species.</p></list-item><list-item><p>Compute any auxiliary information (e.g. a dissimilarity matrix <italic>D</italic> on <italic>S</italic> so that <italic>D</italic>[<italic>x</italic>, <italic>y</italic>] is an estimated ‘distance’ between species <italic>x</italic> and species <italic>y</italic>) required for step 4.</p></list-item><list-item><p>Merge the set <inline-formula id="IE2"><mml:math id="IM2"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of trees together into a compatibility supertree (Definitions 2 and 3) using the auxiliary information.</p></list-item></list></p>
      <p>This approach requires the user to specify methods for performing each of the five steps. Thus, users may choose to select methods that operate on gene trees or methods that operate on concatenated alignments, depending on their preferred approach. If the subset trees and the dissimilarity matrix are estimated using statistically consistent methods, then the divide-and-conquer pipeline using NJMerge is provably statistically consistent under the MSC+GTR model [Corollary 7 in <xref rid="btz344-B26" ref-type="bibr">Molloy and Warnow (2018b</xref>)]. As an example, the subset trees could be estimated using ASTRAL and the dissimilarity matrix could be estimated using average leaf-to-leaf distances in the input gene trees [referred to as the AGID or the USTAR distance matrix; see <xref rid="btz344-B16" ref-type="bibr">Liu and Yu (2011)</xref>; <xref rid="btz344-B1" ref-type="bibr">Allman <italic>et al.</italic> (2018)</xref>]. However, statistical consistency is not the main objective, as achieving high accuracy in practice is typically more challenging, especially for large heterogeneous datasets, which is the focus of this study.</p>
    </sec>
    <sec>
      <title>2.2 Terminology</title>
      <p>All trees in this paper are unrooted binary trees with leaves labeled by elements in a set <italic>S</italic> of species. <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is a set of <italic>k</italic> trees with the property that each species in <italic>S</italic> is a leaf in exactly one tree in <inline-formula id="IE4"><mml:math id="IM4"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>; thus, we say that the trees in <inline-formula id="IE5"><mml:math id="IM5"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> are <bold>leaf-disjoint</bold>. We denote the set of leaves in a tree <italic>T</italic> or in a set of trees <inline-formula id="IE6"><mml:math id="IM6"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> by <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. A <bold>dissimilarity matrix</bold> is a square matrix <italic>D</italic> that is zero on the diagonal and symmetric (i.e. <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>). We work with dissimilarity matrices (rather than distance matrices), because most statistical methods for estimating distances between species in phylogenetic analyses fail to satisfy the triangle inequality; see <xref rid="btz344-B47" ref-type="bibr">Warnow (2017)</xref>. Finally, given a dissimilarity matrix <italic>D</italic>, we denote the restriction of <italic>D</italic> to the rows and columns for <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
      <p>
        <statement id="mthst1">
          <p><sc>Definition</sc> 1. <italic>Let T be a tree with edge-weighting</italic><inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:mi>w</mml:mi><mml:mo>:</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula><italic>and leaves labeled</italic><inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula><italic>. We define the n × n matrix A by setting</italic><inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic>to be the sum of the edge weights in T between i and j; such a matrix is said to be</italic><bold><italic>additive</italic></bold><italic>for T. We say that an n × n matrix M is</italic><bold><italic>nearly additive</italic></bold><italic>for T if for all i, j</italic>, <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:mo>|</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>−</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>|</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>f</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula><italic>where f is the length of the shortest internal edge in T.</italic></p>
        </statement>
      </p>
      <p>
        <statement id="mthst2">
          <p><sc>Definition</sc> 2. <italic>Let T be a tree on leaf set S, and let</italic><inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><italic>be a tree on leaf set</italic><inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:mi>R</mml:mi><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula><italic>. We say that</italic><inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><bold><italic>agrees with</italic></bold><italic>T if restricting T to leaf set R induces a binary tree that (after suppressing the internal nodes of degree 2) is isomorphic to</italic><inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst3">
          <p><sc>Definition</sc> 3. <italic>We say that a tree T on leaf set S is a</italic><bold>compatibility supertree</bold><italic>for a set</italic><inline-formula id="IE20"><mml:math id="IM20"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula><italic>of k unrooted binary trees if each tree</italic><inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula><italic>agrees with T and</italic><inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:munderover><mml:mo>∪</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        </statement>
      </p>
      <p>We now describe the input and output for <bold>Disjoint Tree Merger (DTM)</bold> methods:
<list list-type="bullet"><list-item><p><bold>Input</bold>: A set <inline-formula id="IE23"><mml:math id="IM23"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of unrooted binary trees that are leaf-labeled by the set <italic>S</italic> so that each <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> labels exactly one leaf in exactly one tree in <inline-formula id="IE25"><mml:math id="IM25"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>, and auxiliary information (e.g. a dissimilarity matrix, a multiple sequence alignment, etc.)</p></list-item><list-item><p><bold>Output</bold>: A compatibility supertree <italic>T</italic> for <inline-formula id="IE26"><mml:math id="IM26"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> (Definition 3)</p></list-item></list></p>
      <p>Because the trees in <inline-formula id="IE27"><mml:math id="IM27"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> are leaf-disjoint, a compatibility supertree always exists (<xref ref-type="fig" rid="btz344-F1">Fig. 1</xref>), and the objective is to find a compatibility supertree <italic>T</italic> that is close to the (unknown) true tree <italic>T</italic>* in polynomial time by using the auxiliary information; note that no specific dependence between the input auxiliary information and the output supertree is implied.
</p>
      <fig id="btz344-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>Given a set of trees on pairwise disjoint leaf sets, many possible compatibility supertrees exist. Here we show two compatibility supertrees, labeled <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>, for <inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>; others can also be identified. Notably, the trees in <inline-formula id="IE31"><mml:math id="IM31"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> form connected subtrees in <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (i.e. <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is formed by connecting the trees in <inline-formula id="IE34"><mml:math id="IM34"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> by edges), but this is not the case for <inline-formula id="IE35"><mml:math id="IM35"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. We refer to the first type of compatibility supertree as <italic>un-blended</italic>, and the second type as <italic>blended</italic></p>
        </caption>
        <graphic xlink:href="btz344f1"/>
      </fig>
    </sec>
    <sec>
      <title>2.3 NJMerge and NJMerge-2</title>
      <p>NJMerge is a DTM method based on the well-known Neighbor Joining (NJ) method (<xref rid="btz344-B35" ref-type="bibr">Saitou and Nei, 1987</xref>), but modified to address the requirement of obeying the input constraint trees. As NJMerge considers siblinghood proposals, it modifies the constraint trees and checks to see if the set of constraint trees are still compatible. Because determining the compatibility of a set of <italic>k</italic> unrooted trees on overlapping leaf sets is NP-complete (<xref rid="btz344-B38" ref-type="bibr">Steel, 1992</xref>), NJMerge uses a <italic>heuristic</italic> that can fail for <italic>k </italic>&gt;<italic> </italic>2 trees. In other words, NJMerge sometimes accepts a siblinghood proposal that causes the set of constraint trees to become incompatible, in which case NJMerge fails to return a tree. This failure is not due to insufficient computational resources and is instead an <italic>algorithmic failure</italic>; however, anytime that NJMerge does <italic>not</italic> fail, it returns a compatibility supertree for <inline-formula id="IE36"><mml:math id="IM36"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>. A second limitation of NJMerge is its <italic>O</italic>(<italic>kn</italic><sup>4</sup>) running time, where the input has <italic>n</italic> species divided among <italic>k</italic> leaf-disjoint trees. Thus, NJMerge has two limitations: it can fail, and its running time (although polynomial) is not fast enough to run on ultra-large datasets.</p>
      <p>NJMerge-2 is a simple extension to NJMerge that is guaranteed to always return a compatibility supertree, addressing the first limitation of NJMerge. NJMerge-2 operates as follows:
<list list-type="order"><list-item><p>Select <inline-formula id="IE37"><mml:math id="IM37"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p>Build a compatibility supertree <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> by running NJMerge on the input pair <inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p>Update <inline-formula id="IE42"><mml:math id="IM42"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> by removing <italic>T<sub>i</sub></italic> and <italic>T<sub>j</sub></italic> and adding <inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p>Repeat Steps 1-3 until <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p>Return <inline-formula id="IE45"><mml:math id="IM45"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>.</p></list-item></list></p>
      <p>
        <statement id="mthst4">
          <p><sc>Theorem</sc> 4. NJMerge-2 returns a compatibility supertree in <italic>O</italic>(<italic>kn</italic><sup>4</sup>) time, where the input has <italic>n</italic> species divided among <italic>k</italic> leaf-disjoint subset trees. Furthermore, if every tree in <inline-formula id="IE46"><mml:math id="IM46"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> agrees with a tree <italic>T</italic>* and <italic>D</italic> is nearly additive for <italic>T</italic>*, then NJMerge-2 returns <italic>T</italic>*.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst5">
          <p><sc>Proof</sc>. It is easy to see that the constraint trees remain leaf-disjoint (and thus compatible) during the iterative process, and because the heuristic used by NJMerge correctly determines the compatibility for exactly two trees, NJMerge returns a compatibility supertree given any two compatible trees as input. Thus, by induction on the number of constraint trees, NJMerge-2 returns a compatibility supertree given any set of leaf-disjoint trees and dissimilarity matrix as input. If, in addition, the trees in <inline-formula id="IE47"><mml:math id="IM47"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> are compatible with <italic>T</italic>* and the dissimilarity matrix <italic>D</italic> is nearly additive for <italic>T</italic>*, then NJMerge applied to the input ({<italic>T<sub>i</sub>, T<sub>j</sub></italic>}, <italic>D<sup>i</sup><sup>,</sup><sup>j</sup></italic>) for any pair of trees <italic>T<sub>i</sub>, T<sub>j</sub> ∈</italic><inline-formula id="IE200"><mml:math id="IM48"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> returns a tree that agrees with <italic>T</italic>* [Theorem 3 in <xref rid="btz344-B26" ref-type="bibr">Molloy and Warnow (2018b</xref>)]. Thus, the set <inline-formula id="IE49"><mml:math id="IM49"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> remains compatible with <italic>T</italic>* during the iterative process, and, by induction on the number of constraint trees, NJMerge-2 returns <italic>T</italic>*. For the running time analysis, we make the simplifying assumption that each tree in <inline-formula id="IE50"><mml:math id="IM50"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> has exactly <italic>n</italic>/<italic>k</italic> leaves, where <inline-formula id="IE51"><mml:math id="IM51"><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. At iteration <italic>x</italic>, for any two trees <inline-formula id="IE52"><mml:math id="IM52"><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, so NJMerge can be run on any pair of trees in <inline-formula id="IE53"><mml:math id="IM53"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. A total of <italic>k</italic> – 1 iterations are required, and so the running time of NJMerge-2 scales with <inline-formula id="IE54"><mml:math id="IM54"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> (note that <inline-formula id="IE55"><mml:math id="IM55"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE56"><mml:math id="IM56"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). Thus, NJMerge-2 has <italic>O</italic>(<italic>kn</italic><sup>4</sup>) running time. □</p>
        </statement>
      </p>
    </sec>
    <sec>
      <title>2.4 TreeMerge</title>
      <p>We now present a new DTM method called TreeMerge that is inspired by PASTA (<xref rid="btz344-B23" ref-type="bibr">Mirarab <italic>et al.</italic>, 2015</xref>), a divide-and-conquer method for co-estimating large-scale multiple sequence alignments and gene trees. A generic version of the TreeMerge algorithm is presented in the box below. </p>
      <p>
        <boxed-text position="float" orientation="portrait">
          <caption>
            <p>The generic TreeMerge algorithm</p>
          </caption>
          <p><bold>Input:</bold> A set <inline-formula id="IE57"><mml:math id="IM57"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of leaf-disjoint trees on species set <italic>S</italic>, and auxiliary information (which includes a tree <inline-formula id="IE58"><mml:math id="IM58"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> with nodes labeled by <inline-formula id="IE59"><mml:math id="IM59"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> so that <inline-formula id="IE60"><mml:math id="IM60"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">G</mml:mi></mml:mrow></mml:math></inline-formula> labels exactly one node in <inline-formula id="IE61"><mml:math id="IM61"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>)</p>
          <p><bold>Output:</bold> A compatibility supertree <italic>T</italic> for <inline-formula id="IE62"><mml:math id="IM62"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula></p>
          <p><italic>Stage 1.</italic> For each edge <inline-formula id="IE63"><mml:math id="IM63"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, build a compatibility supertree <inline-formula id="IE64"><mml:math id="IM64"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE65"><mml:math id="IM65"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> using auxiliary information.</p>
          <p><italic>Stage 2.</italic> Iteratively merge pairs of trees via their shared backbone tree (defined in the text), as indicated by <inline-formula id="IE66"><mml:math id="IM66"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>.
<list list-type="simple"><list-item><p><italic>2a.</italic> Root <inline-formula id="IE67"><mml:math id="IM67"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> at an arbitrary edge (<italic>T<sub>x</sub></italic>, <italic>T<sub>y</sub></italic>), and let <inline-formula id="IE68"><mml:math id="IM68"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p><italic>2b.</italic> Perform a pre-order traversal of the edges in the rooted spanning tree <inline-formula id="IE69"><mml:math id="IM69"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>. For each edge <inline-formula id="IE70"><mml:math id="IM70"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>:
<list list-type="simple"><list-item><p>   - Build a compatibility supertree <inline-formula id="IE71"><mml:math id="IM71"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE72"><mml:math id="IM72"><mml:mrow><mml:mo>{</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> using auxiliary information.</p></list-item><list-item><p>    - Let <inline-formula id="IE73"><mml:math id="IM73"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p></list-item></list></p></list-item><list-item><p><italic>2c.</italic> Return <italic>T</italic>. </p></list-item></list></p>
        </boxed-text>
      </p>
      <p>We now describe how we performed stage 1 and stage 2 of the generic TreeMerge algorithm in our simulation study, using an estimated dissimilarity matrix <italic>D</italic> on <italic>S</italic> as auxiliary information.</p>
      <p><italic>Stage 1.</italic> We build a compatibility supertree <inline-formula id="IE74"><mml:math id="IM74"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE75"><mml:math id="IM75"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> by running NJMerge on the input pair (<inline-formula id="IE76"><mml:math id="IM76"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>).</p>
      <p><italic>Stage 2</italic>. We merge pairs of trees via their shared backbone tree using techniques similar to the Strict Consensus Merger (<xref rid="btz344-B41" ref-type="bibr">Swenson <italic>et al.</italic>, 2012</xref>; <xref rid="btz344-B48" ref-type="bibr">Warnow <italic>et al.</italic>, 2001</xref>). We describe this in the context of merging two trees <italic>T<sub>i</sub></italic><sub>,</sub><sub><italic>j</italic></sub> and <inline-formula id="IE77"><mml:math id="IM77"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE78"><mml:math id="IM78"><mml:mrow><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE79"><mml:math id="IM79"><mml:mrow><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Because <inline-formula id="IE80"><mml:math id="IM80"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE81"><mml:math id="IM81"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> induce a common tree topology <italic>T<sub>j</sub></italic> on their shared leaf set <inline-formula id="IE82"><mml:math id="IM82"><mml:mrow><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we refer to <italic>T<sub>j</sub></italic> as the <bold>backbone tree</bold>. A compatibility supertree for <inline-formula id="IE83"><mml:math id="IM83"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> can be built by simply inserting the missing leaves (i.e. <inline-formula id="IE84"><mml:math id="IM84"><mml:mrow><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) into the backbone tree <italic>T<sub>j</sub></italic>. Note that each edge <italic>e</italic> in <italic>T<sub>j</sub></italic> maps to a path <italic>p</italic> in <inline-formula id="IE85"><mml:math id="IM85"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and a path <inline-formula id="IE86"><mml:math id="IM86"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> in <inline-formula id="IE87"><mml:math id="IM87"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (where the paths may be of length 1). When the edge maps to a path of length greater than 1, the internal nodes on those paths define subtrees that need to be inserted into the backbone tree <italic>T<sub>j</sub></italic>. Thus, we iterate over each edge <inline-formula id="IE88"><mml:math id="IM88"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, adding subtrees from <inline-formula id="IE89"><mml:math id="IM89"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and/or <inline-formula id="IE90"><mml:math id="IM90"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to <italic>T<sub>j</sub></italic>, until all missing leaves have been inserted. This process is straightforward except when both <inline-formula id="IE91"><mml:math id="IM91"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE92"><mml:math id="IM92"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> contribute one or more subtrees to the same edge; this is called a <bold>collision</bold> (<xref rid="btz344-B48" ref-type="bibr">Warnow <italic>et al.</italic>, 2001</xref>). When collisions occur, there are multiple ways to merge the two trees while maintaining compatibility (<xref ref-type="fig" rid="btz344-F2">Fig. 2</xref>), and picking the best one cannot be done purely using topological information in the two input trees. We propose two methods, one slow and one fast, to resolve collisions using the dissimilarity matrix <italic>D</italic>, referred to as ‘TreeMerge-slow’ and ‘TreeMerge-fast’, respectively.
</p>
      <fig id="btz344-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>TreeMerge-slow versus TreeMerge-fast. TreeMerge-slow and TreeMerge-fast differ with respect to how they resolve edge collisions. Consider the case where we have two compatible trees <italic>t</italic> and <inline-formula id="IE93"><mml:math id="IM93"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> involved in a collision on edge (<italic>X</italic>, <italic>Y</italic>) in the backbone tree. We label the corresponding internal nodes in <italic>t</italic> and <inline-formula id="IE94"><mml:math id="IM94"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> also by <italic>X</italic> and <italic>Y</italic> and then restrict the trees to just the subtrees between <italic>X</italic> and <italic>Y</italic> to illustrate how the two methods perform on this input. Note that the subtree of <italic>t</italic> shown on the upper left needs to insert two subtrees [trees (<italic>A</italic>, <italic>B</italic>) and <italic>C</italic>] and the subtree of <inline-formula id="IE95"><mml:math id="IM95"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> shown on the upper right needs to insert one subtree [tree <inline-formula id="IE96"><mml:math id="IM96"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>] onto edge (<italic>X</italic>, <italic>Y</italic>). TreeMerge-slow runs NJMerge on the restricted versions of <inline-formula id="IE97"><mml:math id="IM97"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE98"><mml:math id="IM98"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> (as described in the main text), resulting in a ‘blended’ compatibility supertree that has only two subtrees inserted into the backbone edge. In contrast, TreeMerge-fast uses the branch lengths in <italic>t</italic> and <inline-formula id="IE99"><mml:math id="IM99"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and rescales them (if necessary) so that the lengths of the paths from <italic>X</italic> to <italic>Y</italic> in the two trees are the same (as shown here). These paths can then be superimposed, so that the ordering in which the subtrees appear along the path defines how the two trees are merged. Thus, TreeMerge-fast maintains the separation between the subtrees and does not allow ‘blending’ when resolving collisions</p>
        </caption>
        <graphic xlink:href="btz344f2"/>
      </fig>
      <p><italic>TreeMerge-slow.</italic> TreeMerge-slow resolves edge collisions between two trees as follows. Let <inline-formula id="IE100"><mml:math id="IM100"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be an edge in the backbone tree involved in a collision, and select two leaves <inline-formula id="IE101"><mml:math id="IM101"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> on opposite sides of <italic>e</italic>. Let <inline-formula id="IE102"><mml:math id="IM102"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (and <inline-formula id="IE103"><mml:math id="IM103"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) denote the set of subtrees in <inline-formula id="IE104"><mml:math id="IM104"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (and <inline-formula id="IE105"><mml:math id="IM105"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) that need to be attached to edge <inline-formula id="IE106"><mml:math id="IM106"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and define constraint trees <italic>t</italic> and <inline-formula id="IE107"><mml:math id="IM107"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> by restricting <inline-formula id="IE108"><mml:math id="IM108"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to leaf set <inline-formula id="IE109"><mml:math id="IM109"><mml:mrow><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and by restricting <inline-formula id="IE110"><mml:math id="IM110"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to leaf set <inline-formula id="IE111"><mml:math id="IM111"><mml:mrow><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Because <italic>t</italic> and <inline-formula id="IE112"><mml:math id="IM112"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> share only two leaves in common (and thus are compatible), a compatibility supertree for <inline-formula id="IE113"><mml:math id="IM113"><mml:mrow><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> can be computed in polynomial time by running NJMerge on the input pair <inline-formula id="IE114"><mml:math id="IM114"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">′)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>D′</italic> is <italic>D</italic> restricted to <italic>L</italic>(<italic>t</italic>) ∪ L(<italic>t′</italic>). The path from <italic>x</italic> to <italic>y</italic> in the resulting tree indicates how this compatibility supertree for <inline-formula id="IE115"><mml:math id="IM115"><mml:mrow><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> should be inserted into <inline-formula id="IE116"><mml:math id="IM116"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Note that this technique enables <italic>t</italic> and <inline-formula id="IE117"><mml:math id="IM117"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> to <bold>blend</bold>, as shown in <xref ref-type="fig" rid="btz344-F2">Figure 2</xref>.</p>
      <p><italic>TreeMerge-fast.</italic> TreeMerge-fast resolves edge collisions between two trees as follows. First, TreeMerge-fast fits branch lengths to all trees <inline-formula id="IE118"><mml:math id="IM118"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (computed in step 2) using the <italic>O</italic>(<italic>p</italic><sup>2</sup>) time algorithm from <xref rid="btz344-B5" ref-type="bibr">Bryant and Waddell (1998)</xref> that takes as input a tree topology with <italic>p</italic> leaves and a <italic>p</italic>×<italic> p</italic> dissimilarity matrix and computes the optimal branch lengths for <italic>T</italic> using a least squares approach. For two trees <inline-formula id="IE119"><mml:math id="IM119"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE120"><mml:math id="IM120"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, each contributing one or more subtrees to an edge <italic>e</italic> in the backbone tree <italic>T<sub>j</sub></italic>, TreeMerge-fast rescales the branch lengths so that the associated paths (corresponding to edge <italic>e</italic>) in the two trees have the same length. Then, the rescaled branch lengths determine the order in which the subtrees are inserted into <italic>e</italic> (<xref ref-type="fig" rid="btz344-F2">Fig. 2</xref>). Note that this technique never produces a blended compatibility supertree, so the subtrees added define clades (subtrees defined by edges in the tree) in the resulting compatibility supertree.</p>
      <p>
        <statement id="mthst6">
          <p><sc>Theorem</sc> 5. TreeMerge-slow and TreeMerge-fast return a compatibility supertree in O(<italic>kn</italic><sup>4</sup>) and <inline-formula id="IE121"><mml:math id="IM121"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">nk</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, respectively, where the input has <italic>n</italic> species divided among <italic>k</italic> leaf-disjoint subset trees. TreeMerge-slow and TreeMerge-fast require O(<italic>n</italic><sup>2</sup>) and O(<italic>n</italic><sup>2</sup>/<italic>k</italic>) storage, respectively.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst7">
          <p><sc>Proof</sc>. The proof that TreeMerge-slow and TreeMerge-fast return a compatibility supertree follows from NJMerge being guaranteed to return a compatibility supertree for two leaf-disjoint trees and from the techniques for handling collisions (i.e. using either NJMerge on pairs of compatible constraint trees or using branch lengths) being guaranteed to return a compatibility supertree for two trees that agree on their shared leaf set.</p>
          <p>For the running time analysis, we make the simplifying assumption that each tree in <inline-formula id="IE122"><mml:math id="IM122"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> has exactly <italic>n</italic>/<italic>k</italic> leaves, where <inline-formula id="IE123"><mml:math id="IM123"><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> In stage 1, both TreeMerge-slow and TreeMerge-fast run NJMerge on input pair (<inline-formula id="IE124"><mml:math id="IM124"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) for each of the <italic>k</italic>-1 edges in the spanning tree <inline-formula id="IE125"><mml:math id="IM125"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>. All input constraint trees have <italic>n</italic>/<italic>k</italic> leaves, so stage 1 uses <inline-formula id="IE126"><mml:math id="IM126"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE127"><mml:math id="IM127"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> storage.</p>
          <p>TreeMerge-fast and TreeMerge-slow address stage 2 differently; we discuss these methods separately, using the same notation presented in the box above. We begin by analyzing TreeMerge-slow’s running time for stage 2. At iteration <italic>x</italic>, TreeMerge-slow merges trees <inline-formula id="IE128"><mml:math id="IM128"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <italic>T</italic> using a shared backbone tree <italic>t<sub>B</sub></italic>, where <inline-formula id="IE129"><mml:math id="IM129"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE130"><mml:math id="IM130"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. Thus, there are <inline-formula id="IE131"><mml:math id="IM131"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> possible leaves that could be contributed to the <inline-formula id="IE132"><mml:math id="IM132"><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> edges in <italic>t<sub>B</sub></italic>. In the worst case analysis, <inline-formula id="IE133"><mml:math id="IM133"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> leaves are contributed to a single edge in <italic>t<sub>B</sub></italic>, and then NJMerge runs in <inline-formula id="IE134"><mml:math id="IM134"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. A total of <italic>k</italic> – 2 iterations are required, and so the running time scales with <inline-formula id="IE135"><mml:math id="IM135"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> (note that <inline-formula id="IE136"><mml:math id="IM136"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE137"><mml:math id="IM137"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). In the final iteration, NJMerge requires <italic>O</italic>(<italic>n</italic><sup>2</sup>) storage in the worst case analysis. Thus, TreeMerge-slow has <italic>O</italic>(<italic>kn</italic><sup>4</sup>) time and <italic>O</italic>(<italic>n</italic><sup>2</sup>) storage for stage 2. We now analyze TreeMerge-fast’s running time for stage 2. First, TreeMerge-fast computes branch lengths for the <italic>k</italic> – 1 trees (each with 2<italic>n</italic>/<italic>k</italic> leaves) from stage 1 using the quadratic time and space algorithm from <xref rid="btz344-B5" ref-type="bibr">Bryant and Waddell (1998)</xref>. Then, at iteration <italic>x</italic>, TreeMerge-fast merges trees <inline-formula id="IE138"><mml:math id="IM138"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <italic>T</italic> using a shared backbone tree <italic>t<sub>B</sub></italic> and branch lengths; note that this approach scales linearly with the number of leaves in the merged tree (i.e. <inline-formula id="IE139"><mml:math id="IM139"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="script">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>). A total of <italic>k</italic> – 2 iterations are required, and so the running time scales with <inline-formula id="IE140"><mml:math id="IM140"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mi>x</mml:mi></mml:mrow></mml:math></inline-formula> [note that <inline-formula id="IE141"><mml:math id="IM141"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mi>x</mml:mi></mml:mrow></mml:math></inline-formula> is <italic>O</italic>(<italic>k</italic><sup>2</sup>)]. Thus, TreeMerge-fast has <inline-formula id="IE142"><mml:math id="IM142"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">kn</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE143"><mml:math id="IM143"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> space for stage 2. Overall, TreeMerge-fast has <inline-formula id="IE144"><mml:math id="IM144"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">nk</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE145"><mml:math id="IM145"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> storage, while TreeMerge-slow has <italic>O</italic>(<italic>kn</italic><sup>4</sup>) time and requires <italic>O</italic>(<italic>n</italic><sup>2</sup>) storage. □</p>
        </statement>
      </p>
      <p>Corollary 6. <italic>When run within the divide-and-conquer framework proposed in Section 2.1, NJMerge, NJMerge-2 and TreeMerge-slow use O(n<sup>5</sup>) time. In contrast, TreeMerge-fast uses O(n<sup>2</sup>) time when run within this same divide-and-conquer framework.</italic></p>
      <p>
        <statement id="mthst8">
          <p><sc>Proof</sc>. In the divide-and-conquer framework, the input dataset of <italic>n</italic> species is divided into <italic>k</italic> pairwise disjoint subsets of bounded size, so that <italic>k </italic>=<italic> O</italic>(<italic>n</italic>). The time to run NJMerge, NJMerge-2 or TreeMerge-slow given the subset trees and the dissimilarity matrix as input is <italic>O</italic>(<italic>kn</italic><sup>4</sup>), and thus the total time to run NJMerge, NJMerge-2 or TreeMerge-slow within the divide-and-conquer framework is <italic>O</italic>(<italic>n</italic><sup>5</sup>). In contrast, the time to run TreeMerge-fast given the subset trees, the dissimilarity matrix, and the spanning tree on vertex set <inline-formula id="IE146"><mml:math id="IM146"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> as input is <inline-formula id="IE147"><mml:math id="IM147"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">nk</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and thus the total time to run TreeMerge-fast within the divide-and-conquer framework is <italic>O</italic>(<italic>n</italic><sup>2</sup>). □</p>
        </statement>
      </p>
      <p>
        <statement id="mthst9">
          <p><sc>Theorem</sc> 7. Suppose every tree in <inline-formula id="IE148"><mml:math id="IM148"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> agrees with a tree <italic>T</italic>* and <italic>D</italic> is nearly additive for <italic>T</italic>*. Then TreeMerge-slow returns <italic>T</italic>*.</p>
        </statement>
      </p>
      <p><sc>Proof</sc>. Let <italic>T<sub>x</sub></italic> and <italic>T<sub>y</sub></italic> be any two trees in <inline-formula id="IE149"><mml:math id="IM149"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>. By Theorem 3 in <xref rid="btz344-B26" ref-type="bibr">Molloy and Warnow (2018b</xref>), NJMerge applied to the input ({<italic>T<sub>x</sub>, T<sub>y</sub></italic>}, <italic>D<sup>x,y</sup></italic>) returns a compatibility supertree tree <inline-formula id="IE150"><mml:math id="IM150"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that agrees with <italic>T</italic>*. Since TreeMerge-slow performs all its mergers using NJMerge, the result follows by induction on the number of mergers. □</p>
      <p>Corollary 8 follows easily from Theorems 4 and 7 [see also Corollary 7 in <xref rid="btz344-B26" ref-type="bibr">Molloy and Warnow (2018b</xref>)], and its proof is omitted due to space constraints.</p>
      <p>Corollary 8. <italic>Any divide-and-conquer pipeline following the protocol in Section 2.1 and using NJMerge-2 or TreeMerge-slow is statistically consistent under the MSC+GTR model when Step 2 is performed with a statistically consistent method for estimating species trees on subsets and Step 3 is performed with a statistically consistent method for estimating distances</italic>.</p>
      <p>Unfortunately, TreeMerge-fast is not guaranteed to be statistically consistent for these general pipelines, because it can fail in some rare conditions to correctly combine trees in the presence of collisions. (The simplest example is where the decomposition strategy produces three subsets by deleting three edges all sharing a common endpoint, creating a condition where the correct merger technique must detect that the backbone edge should be subdivided into exactly two edges and not into three, which is what the current strategy in TreeMerge-fast would do.) However, a simple modification to the pipeline is sufficient to guarantee statistical consistency, as we now show.</p>
      <p>
        <statement id="mthst10">
          <p><sc>Theorem</sc> 9. Consider the pipeline where gene trees are computed using a statistically consistent method, the distance matrix <italic>D</italic> is the AGID matrix, and the starting tree <italic>T</italic><sub>0</sub> is computed using a statistically consistent method (e.g. NJ on the AGID matrix). Suppose that the starting tree is decomposed into disjoint subsets <inline-formula id="IE151"><mml:math id="IM151"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> by removing a set <italic>E</italic><sub>0</sub> of edges from <italic>T</italic><sub>0</sub> so that every pair of edges in <italic>E</italic><sub>0</sub> is separated by at least two edges in <italic>T</italic><sub>0</sub>. For <inline-formula id="IE152"><mml:math id="IM152"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, let <italic>t<sub>i</sub></italic> denote the constraint tree computed on subset <italic>A<sub>i</sub></italic> using a statistically consistent method (e.g. ASTRAL). Given node <italic>v</italic> in <italic>T</italic><sub>0</sub>, label <italic>v</italic> by <italic>i</italic> where <italic>v</italic> is on a path between two leaves that are both in <italic>A<sub>i</sub></italic>. Define the spanning tree <inline-formula id="IE153"><mml:math id="IM153"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> on the constraint trees by making <italic>t<sub>i</sub></italic> and <italic>t<sub>j</sub></italic> adjacent in <inline-formula id="IE154"><mml:math id="IM154"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> if and only if there is an edge in <italic>T</italic><sub>0</sub> whose endpoints are labelled by <italic>i</italic> and <italic>j</italic>. Then as the number of genes and number of sites per gene both increase, the species tree computed using TreeMerge-fast on input <inline-formula id="IE155"><mml:math id="IM155"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> will converge to the true species tree. In other words, this pipeline, using TreeMerge-fast to combine subset trees, is statistically consistent under the MSC+GTR model.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst11">
          <p><sc>Proof</sc>. As the number of genes and sites per gene increases, all estimated gene trees will converge to the true gene trees, the AGID distance matrix will converge to an additive matrix defined by the true species tree, the starting tree will converge to the true species tree, and each of the constraint trees will converge to a tree that agrees with the true species tree. Hence, for a large enough number of genes and sites per gene, with high probability (i) the deletion of the selected set of edges from the starting tree will partition the species set into subsets so that the labelling described above is unique for each internal node in the tree (i.e. the labelling is ‘convex’ on the starting tree), (ii) constraint trees computed on each subset will be equal to the true species tree on the subset, and (iii) constraint trees that are adjacent in the spanning tree will be adjacent in the true species tree as well. Under these conditions, it is then easy to see that applying TreeMerge-fast will return the true species tree, because neither conflicts nor collisions will ever occur. □</p>
        </statement>
      </p>
    </sec>
  </sec>
  <sec>
    <title>3 Performance study</title>
    <sec>
      <title>3.1 Overview</title>
      <p>The main goal of this paper is empirical performance on large multi-locus datasets, and so we focus our attention on TreeMerge-fast. We include a comparison to NJMerge and NJMerge-2, noting that TreeMerge-slow and NJMerge-2 have the same theoretical performance (i.e. asymptotic computational complexity and statistical consistency) and NJMerge-2 is simpler to implement. We explore species tree estimation using ASTRAL v5.6.1 (i.e. ASTRAL-III) and RAxML v8.2.12 (with SSE3 and pthreads). We computed species trees using these two methods <italic>de novo</italic> as well as within a divide-and-conquer framework, where they were used to estimate species trees on subsets and then the estimated subset (species) trees were combined using NJMerge, NJMerge-2, and TreeMerge-fast. We used the exact same commands (for ASTRAL-III and RAxML) to estimate trees on the full species set as well as on the subsets. We evaluated performance with respect to algorithmic failure rate (for NJMerge), computational failure rate (i.e. failure to complete due to insufficient computational resources), running time, and topological accuracy. All datasets used in this study are publicly available on the Illinois Data Bank (<ext-link ext-link-type="uri" xlink:href="https://databank.illinois.edu/datasets/IDB-9570561">https://databank.illinois.edu/datasets/IDB-9570561</ext-link>), and the exact software commands used in this study are in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Materials</xref>.</p>
    </sec>
    <sec>
      <title>3.2 Datasets</title>
      <p>We used datasets with 1000 species and 2000 genes from a prior study (<xref rid="btz344-B25" ref-type="bibr">Molloy and Warnow, 2018a</xref>) and describe the simulation protocol below. SimPhy (<xref rid="btz344-B18" ref-type="bibr">Mallo <italic>et al.</italic>, 2016</xref>) was used to generate gene trees within species trees under the MSC model. By holding the effective population size constant and varying the species tree height (in generations), model conditions with two different levels of ILS were created, each with 20 replicate datasets. The ILS level was measured by the average normalized Robinson–Foulds (RF) distance (<xref rid="btz344-B32" ref-type="bibr">Robinson and Foulds, 1981</xref>) between the true species tree and the true gene trees (called AD). For the two model conditions, the average AD was 8–10% and 68–69%, and we refer to these conditions as ‘low/moderate ILS’ and ‘very high ILS’, respectively.</p>
      <p>Sequence alignments were simulated for each true gene tree using INDELible (<xref rid="btz344-B6" ref-type="bibr">Fletcher and Yang, 2009</xref>) under the GTR + Γ model of evolution. Sequence lengths were drawn from a distribution (varying from 300 to 1500 bp). GTR + Γ model parameters were also drawn from distributions [see <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S2</xref> in <xref rid="btz344-B25" ref-type="bibr">Molloy and Warnow (2018a</xref>) for details] to simulate 1000 exon-like sequences and 1000 intron-like sequences. Exons were characterized by slower rates of evolution and thus had less phylogenetic signal than introns. Exons and introns were analyzed separately, so all datasets had 1000 species and 1000 genes.</p>
      <p>Finally, summary methods take gene trees as input, and we used estimated gene trees that had previously been computed by <xref rid="btz344-B25" ref-type="bibr">Molloy and Warnow (2018a</xref>) with FastTree-2 (<xref rid="btz344-B30" ref-type="bibr">Price <italic>et al.</italic>, 2010</xref>). The average gene tree estimation error across all replicate datasets was from 26–51% for introns and 38–64% for exons.</p>
    </sec>
    <sec>
      <title>3.3 Details for running divide-and-conquer pipelines</title>
      <p><italic>Subset decomposition</italic>. We evaluated divide-and-conquer pipelines that used an estimated starting tree to divide the species set into pairwise disjoint subsets. Specifically, the set of 1000 species was divided into 10–15 subsets by repeatedly deleting ‘centroid’ edges (i.e. edges whose deletions divide the leaf set roughly in half) in the starting tree until each subset was smaller than the maximum size of 120 species.</p>
      <p><italic>Running TreeMerge-fast.</italic> Because we used a starting tree <italic>T<sup>s</sup></italic> to decompose the species set into subsets, we also used <italic>T<sup>s</sup></italic> to construct a spanning tree on vertex set <inline-formula id="IE156"><mml:math id="IM156"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> (i.e. the tree <inline-formula id="IE157"><mml:math id="IM157"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> has vertices labeled by <inline-formula id="IE158"><mml:math id="IM158"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> so that <inline-formula id="IE159"><mml:math id="IM159"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">G</mml:mi></mml:mrow></mml:math></inline-formula> labels exactly one node in <inline-formula id="IE160"><mml:math id="IM160"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>) for TreeMerge-fast as follows: first, we randomly selected one leaf from each tree in <inline-formula id="IE161"><mml:math id="IM161"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> and deleted all remaining leaves from <italic>T<sup>s</sup></italic> (suppressing the internal nodes of degree 2), thus producing a tree <italic>T</italic> that has one leaf for every tree in <inline-formula id="IE162"><mml:math id="IM162"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>. Second, we built a complete graph <inline-formula id="IE163"><mml:math id="IM163"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> with nodes labeled by the trees in <inline-formula id="IE164"><mml:math id="IM164"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> and edges <inline-formula id="IE165"><mml:math id="IM165"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> weighted by the path distance between leaves labeled <italic>T<sub>i</sub></italic> and <italic>T<sub>j</sub></italic> in <italic>T</italic>. Third, we computed a minimum spanning tree <inline-formula id="IE166"><mml:math id="IM166"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> on <inline-formula id="IE167"><mml:math id="IM167"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="script">G</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> using <xref rid="btz344-B9" ref-type="bibr">Kruskal (1956)</xref>. Finally, TreeMerge-fast used PAUP* (<xref rid="btz344-B42" ref-type="bibr">Swofford, 2019</xref>) v4a163 to fit least squares branch lengths to trees using a distance matrix, prohibiting negative branch lengths.</p>
      <p><italic>Divide-and-conquer pipeline using ASTRAL-III.</italic> We evaluated these pipelines by giving NJMerge, NJMerge-2 and TreeMerge the following inputs:
<list list-type="bullet"><list-item><p><italic>Distance matrix:</italic> AGID matrix computed using ASTRID (<xref rid="btz344-B46" ref-type="bibr">Vachaspati and Warnow, 2015</xref>) v1.4 given estimated gene trees as input</p></list-item><list-item><p><italic>Starting tree:</italic> NJ tree computed using FastMe (<xref rid="btz344-B13" ref-type="bibr">Lefort <italic>et al.</italic>, 2015</xref>) v2.1.5 on the AGID distance matrix [i.e. the NJst tree from <xref rid="btz344-B16" ref-type="bibr">Liu and Yu (2011)</xref>]</p></list-item><list-item><p><italic>Constraint trees:</italic> Species trees computed using ASTRAL v5.6.1 (i.e. ASTRAL-III) on each subset given the induced subtrees from the estimated gene trees as input</p></list-item></list></p>
      <p><italic>Divide-and-conquer pipeline using RAxML</italic>. We evaluated these pipelines by giving NJMerge, NJMerge-2 and TreeMerge the following inputs:
<list list-type="bullet"><list-item><p><italic>Distance matrix:</italic> Matrix of log-det distances (<xref rid="btz344-B39" ref-type="bibr">Steel, 1994</xref>) computed using PAUP* v4a163 given the concatenated alignment as input</p></list-item><list-item><p><italic>Starting tree:</italic> Greedy maximum parsimony tree based on a random taxon addition order computed using RAxML v8.2.12 (with SSE3 and pthreads) given the concatenated alignment as input</p></list-item><list-item><p><italic>Constraint trees:</italic> Species trees computed under the GTR+Γ model of evolution using RAxML v2.12 (with SSE3 and pthreads) on each subset given the unpartitioned concatenated alignment for those species as input</p></list-item></list></p>
    </sec>
    <sec>
      <title>3.4 Evaluation criteria</title>
      <p><italic>Species tree error.</italic> Species tree error was measured as the RF error rate (i.e. the normalized RF distance between the true and the estimated species trees) using Dendropy (<xref rid="btz344-B40" ref-type="bibr">Sukumaran and Holder, 2010</xref>).</p>
      <p><italic>Running time.</italic> All analyses were performed using a single Blue Waters compute node (XE6 dual-socket nodes with 64 GB of physical memory and two AMD Interlagos model 6276 CPU processors, i.e. one per socket each with eight floating-point cores) and a maximum wall-clock time of 48 h. All methods were given access to 16 threads with 1 thread per bulldozer (floating-point) core; however, only RAxML was implemented with multi-threading at the time of this study. We used the last checkpoint file written by RAxML to evaluate species tree estimation error and running time; as a result the running time for RAxML was measured as the time between the info file and the last checkpoint file being written. Because we assumed that researchers had access to a single compute node, we approximated the total running time of divide-and-conquer pipelines as
<disp-formula id="E1"><label>(1)</label><mml:math id="M1"><mml:mrow><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Φ</mml:mo></mml:mrow><mml:mi>D</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Φ</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Φ</mml:mo></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where Φ<sub><italic>D</italic></sub> is the method used to estimate a distance matrix, Φ<sub><italic>T</italic></sub> is the method used to estimate constraint trees, and Φ<sub><italic>M</italic></sub> is the method used to merge the set of constraint trees using a distance matrix. The approximate running time does not include the time required to estimate starting trees, as these computations were relative fast, requiring only a few minutes.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Results and discussion</title>
    <sec>
      <title>4.1 How does TreeMerge compare with NJMerge and NJMerge-2?</title>
      <p>A comparison between these methods with respect to their theoretical properties is provided in <xref rid="btz344-T1" ref-type="table">Table 1</xref>; here we explore their empirical performance. When RAxML was used to construct subset trees, NJMerge failed to return a tree on 6 out of 80 datasets (i.e. the failure rate was 7.5%); note that these were algorithmic failures, not computational failures. For the same analyses in <xref rid="btz344-B25" ref-type="bibr">Molloy and Warnow (2018a</xref>), only 2 out of 80 datasets resulted in failures (i.e. the failure rate was 2.5%). The only difference between the analyses here and the ones in <xref rid="btz344-B25" ref-type="bibr">Molloy and Warnow (2018a</xref>) is the starting tree: here we used the randomized parsimony tree from RAxML, whereas in <xref rid="btz344-B25" ref-type="bibr">Molloy and Warnow (2018a</xref>) starting trees were computed using NJ on the log-det distance matrix. This finding suggests that the choice of starting tree may be a factor in whether or not NJMerge fails. In contrast, NJMerge-2 and TreeMerge-fast completed on all datasets within the allowed time using the allowed memory. Finally, we compared the accuracy of NJMerge, NJMerge-2, and TreeMerge-fast on the replicate datasets for which NJMerge returned a tree. In this analysis, NJMerge-2 produced trees with the same average error as NJMerge, while trees produced by TreeMerge-fast had at most 1% greater error on average than those produced by NJMerge (<xref ref-type="supplementary-material" rid="sup1">Supplementary Table S1</xref>).</p>
      <table-wrap id="btz344-T1" orientation="portrait" position="float">
        <label>Table 1.</label>
        <caption>
          <p>Theoretical properties of NJMerge, NJMerge-2, TreeMerge-slow, and TreeMerge-fast</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">NJMerge</th>
              <th rowspan="1" colspan="1">NJMerge-2</th>
              <th rowspan="1" colspan="1">TreeMerge-slow</th>
              <th rowspan="1" colspan="1">TreeMerge-fast</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Can fail?</td>
              <td rowspan="1" colspan="1">Yes</td>
              <td rowspan="1" colspan="1">No</td>
              <td rowspan="1" colspan="1">No</td>
              <td rowspan="1" colspan="1">No</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Consistent?</td>
              <td rowspan="1" colspan="1">Yes</td>
              <td rowspan="1" colspan="1">Yes</td>
              <td rowspan="1" colspan="1">Yes</td>
              <td rowspan="1" colspan="1">Yes*</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Runtime</td>
              <td rowspan="1" colspan="1"><italic>O</italic>(<italic>kn</italic><sup>4</sup>)</td>
              <td rowspan="1" colspan="1"><italic>O</italic>(<italic>kn</italic><sup>4</sup>)</td>
              <td rowspan="1" colspan="1"><italic>O</italic>(<italic>kn</italic><sup>4</sup>)</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE168">
                  <mml:math id="IM168">
                    <mml:mrow>
                      <mml:mi>O</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi mathvariant="italic">nk</mml:mi>
                      <mml:mo>+</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>n</mml:mi>
                        </mml:mrow>
                        <mml:mn>4</mml:mn>
                      </mml:msup>
                      <mml:mo>/</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                        </mml:mrow>
                        <mml:mn>3</mml:mn>
                      </mml:msup>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Storage</td>
              <td rowspan="1" colspan="1"><italic>O</italic>(<italic>n</italic><sup>2</sup>)</td>
              <td rowspan="1" colspan="1"><italic>O</italic>(<italic>n</italic><sup>2</sup>)</td>
              <td rowspan="1" colspan="1"><italic>O</italic>(<italic>n</italic><sup>2</sup>)</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE169">
                  <mml:math id="IM169">
                    <mml:mrow>
                      <mml:mi>O</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>n</mml:mi>
                        </mml:mrow>
                        <mml:mn>2</mml:mn>
                      </mml:msup>
                      <mml:mo>/</mml:mo>
                      <mml:mi>k</mml:mi>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">D&amp;C runtime</td>
              <td rowspan="1" colspan="1"><italic>O</italic>(<italic>n</italic><sup>5</sup>)</td>
              <td rowspan="1" colspan="1"><italic>O</italic>(<italic>n</italic><sup>5</sup>)</td>
              <td rowspan="1" colspan="1"><italic>O</italic>(<italic>n</italic><sup>5</sup>)</td>
              <td rowspan="1" colspan="1"><italic>O</italic>(<italic>n</italic><sup>2</sup>)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic>Note</italic>: ‘Can Fail?’ means that the method can, on some inputs, fail to return a tree due to algorithmic issues (rather than limited computational resources). ‘Consistent?’ means that the method is statistically consistent under the MSC+GTR model, when used within the divide-and-conquer framework described in Section 2.1. Runtime and storage are for worst-case analysis. ‘D&amp;C runtime’ is the runtime of the method, when used within the divide-and-conquer framework described in Section 2.1. ‘Yes*’ indicates that a slightly modified divide-and-conquer pipeline is needed to ensure statistical consistency for TreeMerge-fast; see Theorem 9.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>That TreeMerge-fast had similar performance compared with NJMerge and NJMerge-2 is noteworthy, as the ASTRAL-III pipeline guarantees statistical consistency for NJMerge and NJMerge-2, but does <italic>not</italic> for TreeMerge-fast. (The centroid edge decomposition does not prohibit the case described above Theorem 9.) There are two conclusions to be drawn from this result. First, it is a reminder that statistical consistency is a theoretical guarantee for what happens in the limit, as the amount of data increases, and does not predict performance given finite data. Second, it suggests the possibility that TreeMerge-fast might be even more accurate when used within pipelines that do provide a guarantee of statistical consistency, which we note in Section 5 as a topic for future research.</p>
    </sec>
    <sec>
      <title>4.2 What is the impact of using TreeMerge-fast on ASTRAL-III and RAxML?</title>
      <p><italic>Failure rate.</italic> In our experiments, ASTRAL-III and RAxML failed to complete analyses on many datasets, though for different reasons. ASTRAL-III failed to complete its analyses within 48 h using the available computational resources on 19 (out of 40) exon datasets and 4 (out of 40) intron datasets (i.e. the failure rate was 29%), and note that all failures occurred on datasets with very high ILS. RAxML reported Out Of Memory (OOM) errors on 39 (out of 40) intron datasets and on 3 (out of 40) exon datasets (i.e. the failure rate was 53%). In contrast, when run within divide-and-conquer pipelines using TreeMerge-fast, all analyses with ASTRAL-III and RAxML completed. Thus, TreeMerge-fast enabled both RAxML and ASTRAL-III to complete analyses on large datasets, when given only 64 GB of memory and 48 h wall-clock time.</p>
      <p>The failure rate for ASTRAL-III and RAxML depended on the model condition. RAxML failed (due to running out of memory) on more intron datasets than exon datasets. Exon-like sequences, which evolved more slowly than intron-like sequences, had fewer distinct alignment patterns, and so could be compressed. When the alignments could not be effectively compressed (as was the case for the intron datasets), RAxML was more likely to run out of memory. A distributed-memory version of RAxML, called ExaML (<xref rid="btz344-B37" ref-type="bibr">Stamatakis and Aberer, 2013</xref>), can be used to estimate trees when RAxML runs out of memory, provided the user has access to a distributed-memory system; however, in our study, we explicitly limited all methods to a single compute node. ASTRAL-III failed (due to running longer than 48 h) on datasets with very high ILS. High ILS datasets are characterized by true gene trees that are topologically very different from the true species tree and from each other, resulting in a very large number of distinct bipartitions. The running time of ASTRAL-III scales with the number of distinct bipartitions in the estimated gene trees (<xref rid="btz344-B50" ref-type="bibr">Zhang <italic>et al.</italic>, 2018a</xref>), explaining why ASTRAL-III failed to complete within 48 h on many of the high ILS datasets.</p>
      <p><italic>Species tree error.</italic> When ASTRAL-III or RAxML completed, we were able to compare the accuracy of species trees estimated by these base methods <italic>de novo</italic> or <italic>within the divide-and-conquer pipeline</italic>, where TreeMerge-fast was used to combine subset trees. We found that using the divide-and-conquer pipeline had little impact on the accuracy of ASTRAL-III and RAxML, with error rates differing on average by at most 1% (<xref ref-type="fig" rid="btz344-F3">Figs 3 and 4</xref>). In general, ASTRAL-III run <italic>de novo</italic> was on average 1% more accurate than when run within the divide-and-conquer pipeline. The impact on RAxML was approximately the same, with a difference of at most 1% on average, and for some datasets with very high ILS, the <italic>de novo</italic> approach was less accurate than the divide-and-conquer approach.
</p>
      <fig id="btz344-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Impact of using TreeMerge-fast with ASTRAL-III. The top row shows species tree estimation error for datasets with 1000 taxa and 1000 genes; gray bars represent medians, gray squares represent means, gray circles represent outliers, box plots extend from the first to the third quartiles, and whiskers extend to plus/minus 1.5 times the interquartile distance (unless greater/less than the maximum/minimum value). The bottom row shows running time (in minutes); bars represent means and error bars represent standard deviations across replicate datasets. The running time of TreeMerge-fast is the time to estimate the distance matrix, to estimate each subset tree using ASTRAL-III, and to combine the subset trees using TreeMerge-fast (<xref ref-type="disp-formula" rid="E1">Equation 1</xref>). The number <italic>N</italic> of replicates on which ASTRAL-III completed is shown on the <italic>x</italic>-axis; note that averages are taken across the replicates on which ASTRAL-III completed. When ASTRAL-III did not complete, it was due to running longer than the 48-h maximum wall-clock time</p>
        </caption>
        <graphic xlink:href="btz344f3"/>
      </fig>
      <fig id="btz344-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>Impact of using TreeMerge-fast with RAxML. The top row shows species tree estimation error for datasets with 1000 taxa and 1000 genes; note that gray bars represent medians, gray squares represent means, gray circles represent outliers, box plots extend from the first to the third quartiles, and whiskers extend to plus/minus 1.5 times the interquartile distance (unless greater/less than the maximum/minimum value). The bottom row shows running time (in minutes); bars represent means and error bars represent standard deviations across replicate datasets. The running time of TreeMerge-fast is the time to estimate the distance matrix, to estimate each subset tree using RAxML, and to combine the subset trees using TreeMerge-fast (<xref ref-type="disp-formula" rid="E1">Equation 1</xref>). The number <italic>N</italic> of replicates on which RAxML completed is shown on the <italic>x</italic>-axis; note that averages are taken across the replicates on which RAxML completed. When RAxML did not complete, it was due to OOM errors; otherwise the last checkpoint written by RAxML was evaluated</p>
        </caption>
        <graphic xlink:href="btz344f4"/>
      </fig>
      <p><italic>Running time.</italic> The divide-and-conquer pipeline using TreeMerge-fast reduced running time for both ASTRAL-III and RAxML, often dramatically (<xref ref-type="fig" rid="btz344-F3">Figs 3 and 4</xref>). For example, when the level of ILS was very high, ASTRAL-III run <italic>de novo</italic> used on average 42 h, whereas ASTRAL-III run within the divide-and-conquer pipeline used just under 4 h on average. On exon datasets, RAxML run <italic>de novo</italic> used 43 h on average, whereas RAxML used 11 h on average within the divide-and-conquer pipeline. Furthermore, the total time spent merging trees using TreeMerge-fast was always low: on average only 32 min and never more than 46 min, which was just a small percentage (on average 3–7%) of the time required to estimate subset trees using RAxML (<xref ref-type="supplementary-material" rid="sup1">Supplementary Table S2</xref>). We prototyped TreeMerge-fast (without parallelism) in Python using Dendropy (<xref rid="btz344-B40" ref-type="bibr">Sukumaran and Holder, 2010</xref>), and so an optimized implementation of TreeMerge-fast with multi-threading would produce even better results.</p>
      <p>Many phylogenomic studies [e.g. <xref rid="btz344-B31" ref-type="bibr">Prum <italic>et al.</italic> (2015</xref>) and <xref rid="btz344-B49" ref-type="bibr">Wickett <italic>et al.</italic> (2014)</xref>] have analyzed multi-locus datasets using <italic>both</italic> ASTRAL and RAxML, so that differences in computational requirements are of interest. The timings we report for ASTRAL-III and RAxML are <italic>not</italic> directly comparable, because the ASTRAL-III timings do not include the time required for gene tree estimation with FastTree-2, which has a worst case running time of <inline-formula id="IE170"><mml:math id="IM170"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>1.5</mml:mn></mml:mrow></mml:msup><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>n</italic> is the number of species and <italic>L</italic> is the length of the alignment (ML gene tree estimation using other methods would likely require more time). In our study, the average time (± standard deviation) to estimate the full set of 1000 gene trees, each with 1000 species, was 217 ± 20 min using a single Blue Waters compute node (with 64 GB of memory and 16 floating-point cores). Thus, the amount time spent estimating 1000 gene trees (3.6 h on average) was small in comparison to the amount of time spent running ASTRAL-III on datasets with very high ILS (42 h on average). However, if the time for gene tree estimation were included, then the <italic>percent</italic> difference between running ASTRAL-III <italic>de novo</italic> or within the divide-and-conquer pipeline would decrease.</p>
      <p>Recall that we earlier established that the component of the pipeline that uses TreeMerge-fast has a running time of only <italic>O</italic>(<italic>n</italic><sup>2</sup>); here we discuss the big-O complexity of the steps that proceed it. In the preprocessing component of the ASTRAL-III pipeline, <italic>m</italic> gene trees (each with <italic>n</italic> species) are computed, and the most expensive parts, after computing gene trees, are the calculation of the AGID matrix, which uses <italic>O</italic>(<italic>mn</italic><sup>2</sup>) time, and the calculation of the starting tree using NJ, which uses <italic>O</italic>(<italic>n</italic><sup>3</sup>) time (although this could be reduced by using FastME instead of NJ, as done in ASTRID). Thus the preprocessing component of the pipeline is more expensive than the merger of the subset trees using TreeMerge-fast.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Conclusion</title>
    <p>TreeMerge is a new technique for merging a set of leaf-disjoint trees through the use of an auxiliary dissimilarity matrix. TreeMerge is motivated by the success of NJMerge (Molloy and Warnow, <xref rid="btz344-B25" ref-type="bibr">2018a,b</xref>) and addresses two important limitations: NJMerge can fail to return a tree on some datasets due to algorithmic failure (rather than computational issues), and NJMerge has asymptotic complexity that scales with <italic>kn</italic><sup>4</sup> (where the input has <italic>n</italic> species divided among <italic>k</italic> leaf-disjoint trees), and so scales as <italic>n</italic><sup>5</sup> within the divide-and-conquer framework described in Section 2.1. In contrast, TreeMerge-fast runs in <italic>O</italic>(<italic>n</italic><sup>2</sup>) time within the same divide-and-conquer framework. Our study shows that the impact of TreeMerge-fast is greatest for those datasets on which ASTRAL-III or RAxML fails to complete, either due to limited running time (for ASTRAL-III) or limited memory (for RAxML). In practice, the computational requirements for ML analyses can be very large, even on ‘small’ numbers of species, when using genome-scale data; for example, the Avian phylogeomics project with whole genomes for 48 birds used 1TB of memory and took more than 200 CPU years to complete. Thus, TreeMerge-fast could make it computationally feasible for researchers with limited resources to analyze large multi-locus datasets, enabling ‘phylogenomics for all’.</p>
    <p>Our study suggests several directions for future research. For example, while we examined four model conditions (two levels of ILS and two types of sequence data), a more extensive study should evaluate performance on biological datasets as well as datasets simulated under different model conditions (especially, considering other sources of gene tree discord). Variations to the pipeline should be explicitly tested; for example, the dissimilarity matrix, the subset decomposition, and the spanning tree on the subsets could all be computed using different approaches; in particular, variants that ensure statistical consistency for TreeMerge-fast (as discussed in Theorem 9) may be useful to evaluate. Explicit testing of robustness to the starting tree (which impacts the subset decomposition and the spanning tree) is another important direction for future work. It is also worth evaluating this divide-and-conquer approach combined with iteration, which has been used successfully in similar applications (<xref rid="btz344-B14" ref-type="bibr">Liu <italic>et al.</italic>, 2009</xref>, <xref rid="btz344-B15" ref-type="bibr">2012</xref>; <xref rid="btz344-B23" ref-type="bibr">Mirarab <italic>et al.</italic>, 2015</xref>; <xref rid="btz344-B29" ref-type="bibr">Nelesen <italic>et al.</italic>, 2012</xref>), and may result in improved accuracy (and robustness to the starting tree), at an increase in running time. We tested the divide-and-conquer framework with ASTRAL-III and RAxML, but other species tree estimation methods could be explored. Other extensions include evaluating the divide-and-conquer framework in a distributed-memory computing environment to scale Bayesian methods, such as StarBEAST-2, to larger datasets. Finally, <xref rid="btz344-B51" ref-type="bibr">Zhang <italic>et al.</italic> (2018b)</xref> recently presented constrained-INC, a new algorithm for merging leaf-disjoint trees in the context of gene tree estimation, and <xref rid="btz344-B12" ref-type="bibr">Le <italic>et al.</italic> (2019)</xref> implemented and evaluated variants of the algorithm on simulated data within a similar pipeline. It would be interesting to see whether divide-and-conquer using constrained-INC is suitable for species tree estimation.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>btz344_Supplementary_Data</label>
      <media xlink:href="btz344_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank Sarah Christensen, William Gropp, Thien Le, Luay Nakhleh, Mike Nute, Srilakshmi Pattabiraman, Marc Snir, Pranjal Vachaspati and four anonymous reviewers for helpful comments that led to improvements in the quality of this work.</p>
    <sec>
      <title>Funding</title>
      <p>This work was supported by the U.S. National Science Foundation [Award No. CCF-1535977] to T.W. E.K.M. was supported by the NSF Graduate Research Fellowship [Award No. DGE-1144245] and the Ira and Debra Cohen Graduate Fellowship in Computer Science. Computational experiments were performed on Blue Waters. This research is part of the Blue Waters sustained-petascale computing project, which is supported by the NSF [Award Nos. OCI-0725070 and ACI-1238993] and the state of Illinois. Blue Waters is a joint effort of the University of Illinois at Urbana-Champaign and its National Center for Supercomputing Applications.</p>
      <p><italic>Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz344-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Allman</surname><given-names>E.S.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Species tree inference from gene splits by unrooted STAR methods</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinf</source>., <volume>15</volume>, <fpage>337</fpage>–<lpage>342</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bansal</surname><given-names>M.</given-names></name>, <name name-style="western"><surname>Eulenstein</surname><given-names>O.</given-names></name></person-group> (<year>2013</year>) 
<article-title>Algorithms for genome-scale phylogenetics using gene tree parsimony</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinf</source>., <volume>10</volume>, <fpage>939</fpage>–<lpage>956</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bayzid</surname><given-names>M.S.</given-names></name>, <name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Gene tree parsimony for incomplete gene trees: addressing true biological loss</article-title>. <source>Algorithms Mol. Biol</source>., <volume>13</volume>, <fpage>1.</fpage><pub-id pub-id-type="pmid">29387142</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Boussau</surname><given-names>B.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>Genome-scale coestimation of species and gene trees</article-title>. <source>Genome Res</source>., <volume>23</volume>, <fpage>323</fpage>–<lpage>330</lpage>.<pub-id pub-id-type="pmid">23132911</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bryant</surname><given-names>D.</given-names></name>, <name name-style="western"><surname>Waddell</surname><given-names>P.</given-names></name></person-group> (<year>1998</year>) 
<article-title>Rapid evaluation of least-squares and minimum-evolution criteria on phylogenetic trees</article-title>. <source>Mol. Biol. Evol</source>., <volume>15</volume>, <fpage>1346.</fpage></mixed-citation>
    </ref>
    <ref id="btz344-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Fletcher</surname><given-names>W.</given-names></name>, <name name-style="western"><surname>Yang</surname><given-names>Z.</given-names></name></person-group> (<year>2009</year>) 
<article-title>INDELible: a flexible simulator of biological sequence evolution</article-title>. <source>Mol. Biol. Evol</source>., <volume>26</volume>, <fpage>1879</fpage>–<lpage>1888</lpage>.<pub-id pub-id-type="pmid">19423664</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jarvis</surname><given-names>E.D.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Whole-genome analyses resolve early branches in the tree of life of modern birds</article-title>. <source>Science</source>, <volume>346</volume>, <fpage>1320</fpage>–<lpage>1331</lpage>.<pub-id pub-id-type="pmid">25504713</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kingman</surname><given-names>J.F.C.</given-names></name></person-group> (<year>1982</year>) 
<article-title>The coalescent</article-title>. <source>Stoch. Process. Appl</source>., <volume>13</volume>, <fpage>235</fpage>–<lpage>248</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kruskal</surname><given-names>J.B.</given-names></name></person-group> (<year>1956</year>) 
<article-title>On the shortest spanning subtree of a graph and the traveling salesman problem</article-title>. <source>Proc. Am. Math. Soc</source>., <volume>7</volume>, <fpage>48</fpage>–<lpage>50</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kubatko</surname><given-names>L.</given-names></name>, <name name-style="western"><surname>Degnan</surname><given-names>J.</given-names></name></person-group> (<year>2007</year>) 
<article-title>Inconsistency of phylogenetic estimates from concatenated data under coalescence</article-title>. <source>Syst. Biol</source>., <volume>56</volume>, <fpage>17</fpage>–<lpage>24</lpage>.<pub-id pub-id-type="pmid">17366134</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lai</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>Inferring duplications, losses, transfers and incomplete lineage sorting with nonbinary species trees</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>i409</fpage>–<lpage>i415</lpage>.<pub-id pub-id-type="pmid">22962460</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B12">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Le</surname><given-names>T.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) <chapter-title>Using INC within divide-and-conquer phylogeny estimation</chapter-title> In: <source>6th International Conference on Algorithms for Computational Biology, AlCoB 2019, May 28–30, 2019</source>, Berkeley, CA, USA, in press.</mixed-citation>
    </ref>
    <ref id="btz344-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lefort</surname><given-names>V.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>FastME 2.0: a comprehensive, accurate, and fast distance-based phylogeny inference program</article-title>. <source>Mol. Biol. Evol</source>., <volume>32</volume>, <fpage>2798</fpage>–<lpage>2800</lpage>.<pub-id pub-id-type="pmid">26130081</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Liu</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>Rapid and accurate large-scale coestimation of sequence alignments and phylogenetic trees</article-title>. <source>Science</source>, <volume>324</volume>, <fpage>1561</fpage>–<lpage>1564</lpage>.<pub-id pub-id-type="pmid">19541996</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Liu</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>SATé-II: very fast and accurate simultaneous estimation of multiple sequence alignments and phylogenetic trees</article-title>. <source>Syst. Biol</source>., <volume>61</volume>, <fpage>90</fpage>–<lpage>106</lpage>.<pub-id pub-id-type="pmid">22139466</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Liu</surname><given-names>L.</given-names></name>, <name name-style="western"><surname>Yu</surname><given-names>L.</given-names></name></person-group> (<year>2011</year>) 
<article-title>Estimating species trees from unrooted gene trees</article-title>. <source>Syst. Biol</source>., <volume>60</volume>, <fpage>661</fpage>–<lpage>667</lpage>.<pub-id pub-id-type="pmid">21447481</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Maddison</surname><given-names>W.P.</given-names></name></person-group> (<year>1997</year>) 
<article-title>Gene trees in species trees</article-title>. <source>Syst. Biol</source>., <volume>46</volume>, <fpage>523</fpage>–<lpage>536</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mallo</surname><given-names>D.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>SimPhy: phylogenomic simulation of gene, locus, and species trees</article-title>. <source>Syst. Biol</source>., <volume>65</volume>, <fpage>334</fpage>–<lpage>344</lpage>.<pub-id pub-id-type="pmid">26526427</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Meiklejohn</surname><given-names>K.A.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Analysis of a rapid evolutionary radiation using ultraconserved elements: evidence for a bias in some multispecies coalescent methods</article-title>. <source>Syst. Biol</source>., <volume>65</volume>, <fpage>612</fpage>–<lpage>627</lpage>.<pub-id pub-id-type="pmid">26865273</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mirarab</surname><given-names>S.</given-names></name>, <name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2015</year>) 
<article-title>ASTRAL-II: coalescent-based species tree estimation with many hundreds of taxa and thousands of genes</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>i44</fpage>–<lpage>i52</lpage>.<pub-id pub-id-type="pmid">26072508</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mirarab</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2014a</year>) 
<article-title>ASTRAL: genome-scale coalescent-based species tree estimation</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>i541</fpage>–<lpage>i548</lpage>.<pub-id pub-id-type="pmid">25161245</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mirarab</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2014b</year>) 
<article-title>Statistical binning enables an accurate coalescent-based estimation of the avian tree</article-title>. <source>Science</source>, <volume>346</volume>, <fpage>1250463.</fpage><pub-id pub-id-type="pmid">25504728</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mirarab</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>PASTA: ultra-large multiple sequence alignment for nucleotide and amino-acid sequences</article-title>. <source>J. Comput. Biol</source>., <volume>22</volume>, <fpage>377</fpage>–<lpage>386</lpage>.<pub-id pub-id-type="pmid">25549288</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mirarab</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Evaluating summary methods for multi-locus species tree estimation in the presence of incomplete lineage sorting</article-title>. <source>Syst. Biol</source>., <volume>65</volume>, <fpage>366</fpage>–<lpage>380</lpage>.<pub-id pub-id-type="pmid">25164915</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B25">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Molloy</surname><given-names>E.K.</given-names></name>, <name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2018a</year>) <chapter-title>NJMerge: a generic technique for scaling phylogeny estimation methods and its application to species trees</chapter-title> In: <person-group person-group-type="editor"><name name-style="western"><surname>Blanchette</surname><given-names>M.</given-names></name>, <name name-style="western"><surname>Ouangraoua</surname><given-names>A.</given-names></name></person-group> (eds.) <source>Comparative Genomics. RECOMB-CG 2018. Lecture Notes in Computer Science</source>. Vol. <volume>11183</volume>, 
<publisher-name>Springer</publisher-name>, 
<publisher-loc>Cham</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btz344-B26">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Molloy</surname><given-names>E.K.</given-names></name>, <name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2018b</year>) Statistically consistent divide-and-conquer pipelines for phylogeny estimation using NJMerge. <italic>Algorithms Mol. Biol</italic>., in press.</mixed-citation>
    </ref>
    <ref id="btz344-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Molloy</surname><given-names>E.K.</given-names></name>, <name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2018c</year>) 
<article-title>To include or not to include: the impact of gene filtering on species tree estimation methods</article-title>. <source>Syst. Biol</source>., <volume>67</volume>, <fpage>285</fpage>–<lpage>303</lpage>.<pub-id pub-id-type="pmid">29029338</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Nakhleh</surname><given-names>L.</given-names></name></person-group> (<year>2013</year>) 
<article-title>Computational approaches to species phylogeny inference and gene tree reconciliation</article-title>. <source>Trends Ecol. Evol</source>., <volume>28</volume>, <fpage>719</fpage>–<lpage>728</lpage>.<pub-id pub-id-type="pmid">24094331</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Nelesen</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>DACTAL: divide-and-conquer trees (almost) without alignments</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>i274</fpage>–<lpage>i282</lpage>.<pub-id pub-id-type="pmid">22689772</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Price</surname><given-names>M.N.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>FastTree 2—approximately maximum-likelihood trees for large alignments</article-title>. <source>PLOS One</source>, <volume>5</volume>, <fpage>1</fpage>–<lpage>10</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Prum</surname><given-names>R.O.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>A comprehensive phylogeny of birds (Aves) using targeted next-generation DNA sequencing</article-title>. <source>Nature</source>, <volume>526</volume>, <fpage>569</fpage>–<lpage>573</lpage>.<pub-id pub-id-type="pmid">26444237</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Robinson</surname><given-names>D.</given-names></name>, <name name-style="western"><surname>Foulds</surname><given-names>L.</given-names></name></person-group> (<year>1981</year>) 
<article-title>Comparison of phylogenetic trees</article-title>. <source>Math. Biosci</source>., <volume>53</volume>, <fpage>131</fpage>–<lpage>147</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Roch</surname><given-names>S.</given-names></name></person-group> (<year>2006</year>) 
<article-title>A short proof that phylogenetic tree reconstruction by maximum likelihood is hard</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinf</source>., <volume>3</volume>, <fpage>92</fpage>–<lpage>94</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Roch</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Long-branch attraction in species tree estimation: inconsistency of partitioned likelihood and topology-based summary methods</article-title>. <source>Syst. Biol</source>., <volume>68</volume>, <fpage>281</fpage>–<lpage>297</lpage>.<pub-id pub-id-type="pmid">30247732</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Saitou</surname><given-names>N.</given-names></name>, <name name-style="western"><surname>Nei</surname><given-names>M.</given-names></name></person-group> (<year>1987</year>) 
<article-title>The neighbor-joining method: a new method for reconstructing phylogenetic trees</article-title>. <source>Mol. Biol. Evol</source>., <volume>4</volume>, <fpage>406</fpage>–<lpage>425</lpage>.<pub-id pub-id-type="pmid">3447015</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Stamatakis</surname><given-names>A.</given-names></name></person-group> (<year>2014</year>) 
<article-title>RAxML version 8: a tool for phylogenetic analysis and post-analysis of large phylogenies</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>1312</fpage>–<lpage>1313</lpage>.<pub-id pub-id-type="pmid">24451623</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B37">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Stamatakis</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Aberer</surname><given-names>A.J.</given-names></name></person-group> (<year>2013</year>) <chapter-title>Novel parallelization schemes for large-scale likelihood-based phylogenetic inference</chapter-title> In: <source>2013 IEEE 27th International Symposium on Parallel and Distributed Processing, IPDPS 2013, May 20–24, 2013</source>, 
<publisher-name>Boston, MA, USA</publisher-name>, pp. <fpage>1195</fpage>–<lpage>1204</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Steel</surname><given-names>M.</given-names></name></person-group> (<year>1992</year>) 
<article-title>The complexity of reconstructing trees from qualitative characters and subtrees</article-title>. <source>J. Classif</source>., <volume>9</volume>, <fpage>91</fpage>–<lpage>116</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Steel</surname><given-names>M.</given-names></name></person-group> (<year>1994</year>) 
<article-title>Recovering a tree from the leaf colourations it generates under a Markov model</article-title>. <source>Appl. Math. Lett</source>., <volume>7</volume>, <fpage>19</fpage>–<lpage>24</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sukumaran</surname><given-names>J.</given-names></name>, <name name-style="western"><surname>Holder</surname><given-names>M.T.</given-names></name></person-group> (<year>2010</year>) 
<article-title>DendroPy: a Python library for phylogenetic computing</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>1569</fpage>–<lpage>1571</lpage>.<pub-id pub-id-type="pmid">20421198</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Swenson</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>SuperFine: fast and accurate supertree estimation</article-title>. <source>Syst. Biol</source>., <volume>61</volume>, <fpage>214</fpage>–<lpage>227</lpage>.<pub-id pub-id-type="pmid">21934137</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B42">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Swofford</surname><given-names>D.L.</given-names></name></person-group> (<year>2019</year>) PAUP* (*Phylogenetic Analysis Using PAUP). <ext-link ext-link-type="uri" xlink:href="http://phylosolutions.com/paup-test/">http://phylosolutions.com/paup-test/</ext-link>.</mixed-citation>
    </ref>
    <ref id="btz344-B43">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Tavaré</surname><given-names>S.</given-names></name></person-group> (<year>1986</year>) 
<article-title>Some probabilistic and statistical problems in the analysis of DNA sequences</article-title>. <source>Lect. Math. Life Sci</source>., <volume>17</volume>, <fpage>57</fpage>–<lpage>86</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B44">
      <mixed-citation publication-type="journal">The Quest for Orthologs Consortium (<year>2014</year>) 
<article-title>Big data and other challenges in the quest for orthologs</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>2993</fpage>–<lpage>2998</lpage>.<pub-id pub-id-type="pmid">25064571</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B45">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Tofigh</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2011</year>) 
<article-title>Simultaneous identification of duplications and lateral gene transfers</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinf</source>., <volume>8</volume>, <fpage>517</fpage>–<lpage>535</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B46">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Vachaspati</surname><given-names>P.</given-names></name>, <name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2015</year>) 
<article-title>ASTRID: accurate species trees from internode distances</article-title>. <source>BMC Genomics</source>, <volume>16</volume>, <fpage>S3.</fpage></mixed-citation>
    </ref>
    <ref id="btz344-B47">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2017</year>) <source>Computational Phylogenetics: An Introduction to Designing Methods for Phylogeny Estimation</source>. 
<publisher-name>Cambridge University Press</publisher-name>, 
<publisher-loc>Cambridge, UK</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btz344-B48">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group><etal>et al</etal> (<year>2001</year>) <chapter-title>Absolute convergence: true trees from short sequences</chapter-title> In: <source>Proceedings of the Twelfth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 2001, January 7–9, 2001</source>, 
<publisher-name>Washington, DC, USA</publisher-name>, pp. <fpage>186</fpage>–<lpage>195</lpage>.</mixed-citation>
    </ref>
    <ref id="btz344-B49">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wickett</surname><given-names>N.J.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Phylotranscriptomic analysis of the origin and early diversification of land plants</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>111</volume>, <fpage>E4859</fpage>–<lpage>E4868</lpage>.<pub-id pub-id-type="pmid">25355905</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B50">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zhang</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2018a</year>) 
<article-title>ASTRAL-III: polynomial time species tree reconstruction from partially resolved gene trees</article-title>. <source>BMC Bioinformatics</source>, <volume>19</volume>, <fpage>153.</fpage><pub-id pub-id-type="pmid">29745866</pub-id></mixed-citation>
    </ref>
    <ref id="btz344-B51">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Zhang</surname><given-names>Q.R.</given-names></name></person-group><etal>et al</etal> (<year>2018b</year>) New absolute fast converging phylogeny estimation methods with improved scalability and accuracy. In: <italic>18th International Workshop on Algorithms in Bioinformatics, WABI 2018, August 20–22, 2018, Helsinki, Finland</italic>, pp. 8:1–8:12.</mixed-citation>
    </ref>
  </ref-list>
</back>
