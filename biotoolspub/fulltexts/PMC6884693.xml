<?all-math-mml yes?>
<?use-mml?>
<?properties open_access?>
<?properties manuscript?>
<?origin nihpa?>
<?iso-abbr Nat. Methods?>
<?submitter-system nihms?>
<?submitter-canonical-name Nature Publishing Group?>
<?submitter-canonical-id NATURE-STRUCTUR?>
<?submitter-userid 8068858?>
<?submitter-authority myNCBI?>
<?submitter-login nature-structure?>
<?submitter-name Nature Publishing Group?>
<?domain nihpa?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-journal-id">101215604</journal-id>
    <journal-id journal-id-type="pubmed-jr-id">32338</journal-id>
    <journal-id journal-id-type="nlm-ta">Nat Methods</journal-id>
    <journal-id journal-id-type="iso-abbrev">Nat. Methods</journal-id>
    <journal-title-group>
      <journal-title>Nature methods</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1548-7091</issn>
    <issn pub-type="epub">1548-7105</issn>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6884693</article-id>
    <article-id pub-id-type="pmid">31740819</article-id>
    <article-id pub-id-type="doi">10.1038/s41592-019-0619-0</article-id>
    <article-id pub-id-type="manuscript">nihpa1539299</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Fast, sensitive, and accurate integration of single cell data with Harmony</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Korsunsky</surname>
          <given-names>Ilya</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
        <xref ref-type="aff" rid="A2">2</xref>
        <xref ref-type="aff" rid="A3">3</xref>
        <xref ref-type="aff" rid="A4">4</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Millard</surname>
          <given-names>Nghia</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
        <xref ref-type="aff" rid="A2">2</xref>
        <xref ref-type="aff" rid="A3">3</xref>
        <xref ref-type="aff" rid="A4">4</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Fan</surname>
          <given-names>Jean</given-names>
        </name>
        <xref ref-type="aff" rid="A5">5</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Slowikowski</surname>
          <given-names>Kamil</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
        <xref ref-type="aff" rid="A2">2</xref>
        <xref ref-type="aff" rid="A3">3</xref>
        <xref ref-type="aff" rid="A4">4</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zhang</surname>
          <given-names>Fan</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
        <xref ref-type="aff" rid="A2">2</xref>
        <xref ref-type="aff" rid="A3">3</xref>
        <xref ref-type="aff" rid="A4">4</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wei</surname>
          <given-names>Kevin</given-names>
        </name>
        <xref ref-type="aff" rid="A2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Baglaenko</surname>
          <given-names>Yuriy</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
        <xref ref-type="aff" rid="A2">2</xref>
        <xref ref-type="aff" rid="A3">3</xref>
        <xref ref-type="aff" rid="A4">4</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Brenner</surname>
          <given-names>Michael</given-names>
        </name>
        <xref ref-type="aff" rid="A2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Loh</surname>
          <given-names>Po-ru</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
        <xref ref-type="aff" rid="A3">3</xref>
        <xref ref-type="aff" rid="A4">4</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Raychaudhuri</surname>
          <given-names>Soumya</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
        <xref ref-type="aff" rid="A2">2</xref>
        <xref ref-type="aff" rid="A3">3</xref>
        <xref ref-type="aff" rid="A4">4</xref>
        <xref ref-type="aff" rid="A6">6</xref>
      </contrib>
    </contrib-group>
    <aff id="A1"><label>1</label>Center for Data Sciences, Brigham and Women's Hospital, Massachusetts, USA.</aff>
    <aff id="A2"><label>2</label>Divisions of Genetics and Rheumatology, Department of Medicine, Brigham and Women's Hospital and Harvard Medical School, Boston.</aff>
    <aff id="A3"><label>3</label>Department of Biomedical Informatics, Harvard Medical School, Massachusetts, USA.</aff>
    <aff id="A4"><label>4</label>Program in Medical and Population Genetics, Broad Institute of MIT and Harvard, Cambridge, MA, USA.</aff>
    <aff id="A5"><label>5</label>Department of Chemistry and Chemical Biology, Harvard University, Cambridge, Massachusetts, USA.</aff>
    <aff id="A6"><label>6</label>Arthritis Research UK Centre for Genetics and Genomics, Centre for Musculoskeletal Research, Manchester Academic Health Science Centre, The University of Manchester, Manchester, UK.</aff>
    <author-notes>
      <corresp id="CR1"><label>*</label>Correspondence to: Soumya Raychaudhuri, 77 Avenue Louis Pasteur, Harvard New Research Building, Suite 250D, Boston, MA 02446, USA. <email>soumya@broadinstitute.org</email>; 617-525-4484 (tel); 617-525-4488 (fax)</corresp>
      <fn fn-type="con" id="FN1">
        <p id="P1">Author Contributions</p>
        <p id="P2">SR and IK conceived the research. IK led computational work under the guidance of SR, assisted by NM, PL, JF, and KS. All authors participated in interpretation and writing the manuscript.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="nihms-submitted">
      <day>7</day>
      <month>9</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>18</day>
      <month>11</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="ppub">
      <month>12</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>18</day>
      <month>5</month>
      <year>2020</year>
    </pub-date>
    <volume>16</volume>
    <issue>12</issue>
    <fpage>1289</fpage>
    <lpage>1296</lpage>
    <!--elocation-id from pubmed: 10.1038/s41592-019-0619-0-->
    <permissions>
      <license>
        <license-p>Users may view, print, copy, and download text and data-mine the content in such documents, for the purposes of academic research, subject always to the full Conditions of use:<uri xlink:type="simple" xlink:href="http://www.nature.com/authors/editorial_policies/license.html#terms">http://www.nature.com/authors/editorial_policies/license.html#terms</uri></license-p>
      </license>
    </permissions>
    <abstract id="ABS1">
      <p id="P3">The emerging diversity of single cell RNAseq datasets allows for the full transcriptional characterization of cell types across a wide variety of biological and clinical conditions. However, it is challenging to analyze them together, particularly when datasets are assayed with different technologies. Here, real biological differences are interspersed with technical differences. We present Harmony, an algorithm that projects cells into a shared embedding in which cells group by cell type rather than dataset-specific conditions. Harmony simultaneously accounts for multiple experimental and biological factors. In six analyses, we demonstrate the superior performance of Harmony to previously published algorithms. We show that Harmony requires dramatically fewer computational resources. It is the only currently available algorithm that makes the integration of ~10<sup>6</sup> cells feasible on a personal computer. We apply Harmony to PBMCs from datasets with large experimental differences, 5 studies of pancreatic islet cells, mouse embryogenesis datasets, and cross-modality spatial integration.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <p id="P4">Recent technological advances<sup><xref rid="R1" ref-type="bibr">1</xref></sup> enable unbiased single cell transcriptional profiling of thousands of cells in one experiment. Projects such as Human Cell Atlas<sup><xref rid="R2" ref-type="bibr">2</xref></sup> (HCA) and Accelerating Medicines Partnership<sup><xref rid="R3" ref-type="bibr">3</xref>-<xref rid="R5" ref-type="bibr">5</xref></sup> exemplify the growing body of reference datasets of primary human tissues. While individual experiments incrementally expand our understanding of cell types, a comprehensive catalogue of healthy and diseased cells will require the ability to integrate multiple datasets across donors, studies, and technological platforms. Moreover, in translational research, joint analyses across tissues and clinical conditions will be essential to identify disease-expanded populations. Since meaningful biological variation in single cell RNA-seq datasets from different studies is often hopelessly confounded by data source<sup><xref rid="R6" ref-type="bibr">6</xref></sup>, investigators have developed unsupervised multi-dataset integration algorithms<sup><xref rid="R7" ref-type="bibr">7</xref>-<xref rid="R10" ref-type="bibr">10</xref></sup>. These methods embed cells from diverse experimental conditions and biological contexts into a common reduced dimensional embedding to enable shared cell type identification across datasets.</p>
  <p id="P5">Here we introduce Harmony, an algorithm for robust, scalable, and flexible multi-dataset integration to meet four key challenges of unsupervised scRNAseq joint embedding: scaling to large datasets, identification of both broad populations and fine-grained subpopulations, flexibility to accommodate complex experimental design, and the power to integrate across modalities. We apply Harmony to a diverse range of examples, including cell lines, PBMCs assayed with different technologies, a meta-analysis of pancreatic islet cells from multiple donors and studies, longitudinal samples from mouse embryogenesis, and cross modality integration of dissociated with spatially resolved expression datasets. Harmony is available as an R package on github (<ext-link ext-link-type="uri" xlink:href="https://github.com/immunogenomics/harmony">https://github.com/immunogenomics/harmony</ext-link>), with functions for standalone and Seurat<sup><xref rid="R7" ref-type="bibr">7</xref></sup> pipeline analyses.</p>
  <sec id="S1">
    <title>Results</title>
    <sec id="S2">
      <title>Harmony Iteratively Learns a Cell-Specific Linear Correction Function</title>
      <p id="P6">Harmony, described in detail in <xref rid="SD5" ref-type="supplementary-material">Supplementary Note 1</xref>, begins with a low dimensional embedding of cells, such as Principal Components Analysis (PCA), that meets 3 key criteria (<xref rid="S10" ref-type="sec">online methods</xref>). Using this embedding, Harmony first groups cells into multi-dataset clusters (<xref rid="F1" ref-type="fig">Figure 1A</xref>). We use soft clustering to assign cells to potentially multiple clusters, to account for smooth transitions between cell states. These clusters serve as surrogate variables, rather than actual discrete cell-types. We developed a novel soft k-means clustering algorithm that favors clusters with cells from multiple datasets (<xref rid="S10" ref-type="sec">online methods</xref>). Clusters disproportionately containing cells from a small subset of datasets are penalized by an information theoretic metric. Harmony allows for multiple different penalties to accommodate multiple technical or biological factors, such as different batches and different technology platforms. Soft clustering preserves discrete and continuous topologies while avoiding local minima that might result from too quickly maximizing representation across multiple datasets. After clustering, each dataset has a cluster-specific centroid (<xref rid="F1" ref-type="fig">Figure 1B</xref>) that is used to compute cluster-specific linear correction factors (<xref rid="F1" ref-type="fig">Figure 1C</xref>). Since clusters correspond to cell types and states, cluster-specific correction factors correspond to individual cell-type and cell-state specific correction factors. In this way, Harmony learns a simple linear adjustment function that is sensitive to intrinsic cellular phenotypes. Finally, each cell is assigned a cluster-weighted average of these terms and corrected by its cell-specific linear factor (<xref rid="F1" ref-type="fig">Figure 1D</xref>). Since each cell may be in multiple clusters, each cell has a potentially unique correction factor. Harmony iterates these four steps until convergence, until cell cluster assignments are stable.</p>
    </sec>
    <sec id="S3">
      <title>Quantifying Performance in Cell Line Data</title>
      <p id="P7">We first assessed Harmony using three carefully controlled datasets, in order to evaluate performance on both integration (mixing of datasets) and accuracy (no mixing of cell types). Perfect integration can be achieved by mixing all cells, regardless of cellular identity. Similarly, high accuracy can be achieved by partitioning cells into broad clusters without mixing datasets in small neighborhoods. In this situation, broad cellular states are defined, but fine-grained cellular substates and subtypes are confounded by the originating dataset. In order to quantify integration and accuracy of this embedding we defined an objective metric: the Local Inverse Simpson's Index (LISI, <xref rid="S10" ref-type="sec">online methods</xref>) in the local neighborhood of each cell. To assess integration, we employ “integration LISI” (iLISI, <xref rid="F2" ref-type="fig">Figure 2A</xref>), which defines the effective number of datasets in a neighborhood. Neighborhoods represented by only a single dataset get an iLISI of 1, while neighborhoods with an equal number of cells from 2 datasets get an iLISI of 2. Note that even under ideal mixing, if the datasets have different numbers of cells, iLISI would be less than 2. To assess accuracy, we use “cell-type LISI” (cLISI, <xref rid="F2" ref-type="fig">Figure 2B</xref>), the same mathematical measure, but applied to cell-type instead of dataset labels. Accurate integration should maintain a cLISI of 1, reflecting a separation of unique cell types throughout the embedding. An erroneous embedding would include neighborhoods with a cLISI of 2, indicating that neighbors have 2 different types of cells.</p>
      <p id="P8">We begin with three datasets from two cells lines: (1) pure Jurkat, (2) pure 293T and (3) a 50:50 mix<sup><xref rid="R11" ref-type="bibr">11</xref></sup>. These datasets are ideal for illustration and for assessment, as each cell can be unambiguously labeled Jurkat or 293T (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 1A</xref>). A thorough integration would mix the 1799 Jurkat cells from the mixture dataset with 3255 cells from the pure Jurkat dataset and the 1565 293T cells from the mixture dataset with the 2859 from the pure 293T dataset. Thus, we expect the average iLISI to range from 1, reflecting no integration, to 1.8(=1/[(1799/(1799+2859))<sup>2</sup>+(3255/(1799+3255))<sup>2</sup>]) for Jurkat cells and 1.5(=1/[(1565/(1565+2859))<sup>2</sup>+(2859/(1565+2859))<sup>2</sup>]) for 293T cells, reflecting maximal accurate integration. Application of a standard PCA pipeline followed by UMAP embedding demonstrates that the cells group broadly by dataset and cell type. This is both visually apparent and quantified (<xref rid="F2" ref-type="fig">Figure 2C</xref>,<xref rid="F2" ref-type="fig">D</xref>) with high accuracy reflected by a low cLISI (median iLISI 1.00, 95% [1.00, 1.00]). However the iLISI (median iLISI 1.01, 95% [1.00, 1.61]) is also low, reflecting imperfect integration, and ample structure within each cell-type reflecting the data set of origin. After Harmony, cells from the 50:50 dataset are appropriately mixed into the pure datasets (<xref rid="F2" ref-type="fig">Figure 2E</xref>). The increased iLISI (median iLISI 1.59, 95% [1.27, 1.97]) reflects the mixing of datasets, while the low cLISI (<xref rid="F2" ref-type="fig">Figure 2F</xref>, median iLISI 1.00, 95% [1.00, 1.02]) reflects the accurate separation of Jurkat from 293T cells. iLISI and cLISI provide a quantitative way to compare the integration and accuracy of multiple algorithms. We repeated the integration and LISI analyses with MNN Correct, BBKNN, MultiCCA, and Scanorama and showed that they produced embeddings with statistically inferior integration (<xref rid="SD3" ref-type="supplementary-material">Supplementary Results</xref>, <xref rid="SD4" ref-type="supplementary-material">Fig. 1B</xref>, <xref rid="SD8" ref-type="supplementary-material">Table 1</xref>).</p>
      <p id="P9">This benchmark demonstrates the two key metrics for assessing mixing and accuracy and shows that Harmony performs well on both metrics in a well-controlled analysis of cell-line datasets. A potential pitfall of LISI is that it is sensitive to datasets of vastly different sizes. In such a situation, most neighborhoods can be dominated by a single dataset and LISI values become difficult to interpret (<xref rid="SD6" ref-type="supplementary-material">Supplementary Note 2</xref>).</p>
    </sec>
    <sec id="S4">
      <title>Harmony Scales to Large Data</title>
      <p id="P10">We evaluated Harmony’s computational performance, measuring both total runtime and maximum memory usage. To demonstrate Harmony’s scalability versus other methods, we downsampled HCA data<sup><xref rid="R12" ref-type="bibr">12</xref></sup> (528,688 cells from 16 donors and 2 tissues) to create 5 benchmark datasets with 500,000, 250,000, 125,000, 60,000, and 30,000 cells. We reported the runtime and memory (<xref rid="SD8" ref-type="supplementary-material">Supplementary Tables 2</xref>,<xref rid="SD8" ref-type="supplementary-material">3</xref>) for all benchmarks. Harmony runtime scaled well for all datasets (<xref rid="F3" ref-type="fig">Figure 3A</xref>), ranging from 4 minutes on 30,000 cells to 68 minutes on 500,000 cells, 30 to 200 times faster than MultiCCA and MNN Correct. The runtimes for Harmony, BBKNN, and Scanorama were comparable for datasets with up to 125,000 cells. Harmony required dramatically less memory (<xref rid="F3" ref-type="fig">Figure 3B</xref>) compared to other algorithms, only 0.9GB on 30,000 cells and 7.2GB on 500,000 cells. At 125,000 cells, Harmony required 30 to 50 times less memory than Scanorama, MNN Correct and Seurat MultiCCA; these other methods could not scale beyond 125,000 cells. Importantly, Harmony returned substantially more integrated embeddings (<xref rid="F3" ref-type="fig">Figure 3C</xref>) than did other competing algorithms (<xref rid="SD3" ref-type="supplementary-material">Supplementary Results</xref>), allowing for the identification of shared cell types (<xref rid="F3" ref-type="fig">Figure 3D</xref>) across tissues and donors. These results demonstrate that Harmony is computationally efficient and capable of analyzing even large datasets (10<sup>5</sup>-10<sup>6</sup> cells) on personal computers.</p>
    </sec>
    <sec id="S5">
      <title>Identification of Broad and Fine-Grained PBMCs Subpopulations</title>
      <p id="P11">To assess how Harmony might perform under more challenging scenarios, we gathered three datasets of human PBMCs, each assayed on the Chromium 10X platform but prepared with different protocols: 3-prime end v1 (3pV1), 3-prime end v2 (3pV2), and 5-prime (5p) end chemistries. After pooling all the cells together, we performed a joint analysis. Before integration, cells group primarily by dataset (<xref rid="F4" ref-type="fig">Figure 4A</xref>, median iLISI 1.00, 95% [1.00, 1.00]).</p>
      <p id="P12">Harmony clustered the cells into biologically coherent groups (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 6A</xref>) and removed dataset-specific variation within each cluster. In the final integrated space, the datasets are well mixed (<xref rid="F4" ref-type="fig">Figure 4B</xref>, median iLISI 1.96, 95% [1.36, 2.56]), more so than with other methods (<xref rid="F4" ref-type="fig">Figure 4C</xref>). We confirmed that &gt;83% of cells had a significantly (FDR&lt;5%) higher iLISI value in Harmony than with any other algorithm (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 6B</xref>,<xref rid="SD4" ref-type="supplementary-material">C</xref>). To assess accuracy, within each dataset, we separately annotated (<xref rid="S10" ref-type="sec">online methods</xref>) broad cell clusters with canonical markers of major expected populations (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 6D</xref>): monocytes (<italic>CD14</italic>+ or <italic>CD16</italic>+), dendritic cells (<italic>FCER1A</italic>+), B cells (<italic>CD20</italic>+), T cells (<italic>CD3</italic>+), Megakaryocytes (<italic>PPBP</italic>+), and NK cells (<italic>CD3</italic>−/<italic>GNLY</italic>+) before clustering. We observed that Harmony retained differences among cell types (<xref rid="F4" ref-type="fig">Figure 4D</xref> median cLISI 1.00, 95% [1.00, 1.02]). The greater dataset integration, compared to other algorithms, affords a unique opportunity to identify fine-grained cell subtypes (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 6E</xref>). Using canonical markers (<xref rid="F4" ref-type="fig">Figure 4E</xref>), we identified shared subpopulations of cells (<xref rid="F4" ref-type="fig">Figure 4F</xref>) including naive CD4 T (<italic>CD4</italic>+/<italic>CCR7</italic>+), effector memory CD4 T (<italic>CD4</italic>+/<italic>CCR7</italic>−), Treg (<italic>CD4</italic>+/<italic>FOXP3</italic>+), memory CD8 (<italic>CD8</italic>+/<italic>GZMK</italic>−), effector CD8 T (<italic>CD8</italic>+/<italic>GZMK</italic>+), naive B (<italic>CD20</italic>+/<italic>CD27</italic>−), and memory B cells (<italic>CD20</italic>+/<italic>CD27</italic>+). In the embeddings produced by other algorithms, the median iLISI failed to exceed 1.1 (<xref rid="SD8" ref-type="supplementary-material">Supplementary Table 5</xref>). Accordingly, the subtypes identified above reside in dataset-specific, rather than dataset-mixed clusters (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 7</xref>). Importantly, we were able to maintain high quality results even as we downsampled whole populations of cells to create imbalanced datasets with non-overlapping cell types (<xref rid="SD3" ref-type="supplementary-material">Supplementary Results</xref>, <xref rid="SD4" ref-type="supplementary-material">Figs. 8</xref>-<xref rid="SD4" ref-type="supplementary-material">10</xref>). In both the full and downsampled PBMC datasets, Harmony was robust to the choice of parameters, particularly the diversity penalty (<xref rid="SD3" ref-type="supplementary-material">Supplementary Results</xref>, <xref rid="SD4" ref-type="supplementary-material">Fig. 11</xref>). These results show that Harmony successfully accounts for technical variation among different protocols and integrates many different cell types while preserving large-scale and fine-grained structures in the data, even with non-overlapping populations among datasets.</p>
    </sec>
    <sec id="S6">
      <title>Simultaneous Integration Across Donors and Technologies Identifies Rare Pancreas Islet Subtypes</title>
      <p id="P13">We considered a more complex experimental design, in which integration must be performed simultaneously over more than one source of variation. We gathered human pancreatic islet cells from five independent studies<sup><xref rid="R13" ref-type="bibr">13</xref>-<xref rid="R17" ref-type="bibr">17</xref></sup>, each generated with a different technological platform. Integration across these platforms is particularly challenging because of the large spread in number of cells per dataset and number of unique genes measured in each cell (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 12</xref>). Moreover, within two of the datasets<sup><xref rid="R13" ref-type="bibr">13</xref>-<xref rid="R14" ref-type="bibr">14</xref></sup>, the authors noted significant donor-specific effects. A successful integration of these studies must account for the effects of both different technologies and the 36 donors used in these studies. These effects may impact cell types in different ways. Harmony is the only currently available integration algorithm specifically designed for single cell data that is able to explicitly integrate over more than one variable.</p>
      <p id="P14">As before, we assess cell type accuracy cLISI with canonical cell types identified independently within each dataset (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 13A</xref>): alpha (<italic>GCG</italic>+), beta (<italic>MAFA</italic>+), gamma (<italic>PPY</italic>+), delta (<italic>SST</italic>+), acinar (<italic>PRSS1</italic>+), ductal (<italic>KRT19</italic>+), endothelial (<italic>CDH5</italic>+), stellate (<italic>COL1A2</italic>+), and immune (<italic>PTPRC</italic>+). Since there are two integration variables, we asses both donor iLISI and technology iLISI. Prior to integration, PCA separates cells by technology (<xref rid="F5" ref-type="fig">Figure 5A</xref>, median iLISI 1.00 95% [1.00, 1.06]), donor (<xref rid="F5" ref-type="fig">Figure 5B</xref>, median iLISI 1.42 95% [1.00, 5.50]), and cell type (median cLISI 1.00 95% [1.00, 1.48]). The wide range of donor-iLISI reflects that in the CEL-seq, CEL-seq2, and Fluidigm C1 datasets, many donors were well mixed prior to integration. Harmony integrates cells (<xref rid="SD4" ref-type="supplementary-material">Supplementary Figure 13B</xref>) by both technology (<xref rid="F5" ref-type="fig">Figure 5C</xref>, median iLISI 2.17 95% [1.02, 3.91]) and donor (<xref rid="F5" ref-type="fig">Figure 5D</xref>, median iLISI 5.05 95% [1.24, 10.05]), while merging cells correctly according to previously defined types (accuracy&gt;98%, <xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 13C</xref>). We also benchmarked these data with BBKNN, Scanorama, MNN and MultiCCA, as well with limma<sup><xref rid="R18" ref-type="bibr">18</xref></sup>, which can correct over multiple levels. Only Harmony was able to mix both the donors and technologies substantially (<xref rid="SD3" ref-type="supplementary-material">Supplementary Results</xref>, <xref rid="SD4" ref-type="supplementary-material">Fig. 14</xref>).</p>
      <p id="P15">Harmony was able to discern rare (&lt;2%) cell subtypes (<xref rid="F5" ref-type="fig">Figure 5E</xref>) across the 5 datasets (<xref rid="F5" ref-type="fig">Figure 5F</xref>). We labeled previously described subtypes using canonical markers: activated stellate cells (<italic>PDGFRA</italic>+), quiescent stellate cells (<italic>RGS5</italic>+), mast cells (<italic>BTK</italic>+), macrophages (<italic>C1QC</italic>+), and beta cells under endoplasmic reticulum (ER) stress (<xref rid="F5" ref-type="fig">Figure 5G</xref>). Beta ER stress cells may represent a dysfunctional population. This cluster has significantly lower expression of genes key to beta cell identity<sup><xref rid="R19" ref-type="bibr">19</xref></sup> and function:<sup><xref rid="R20" ref-type="bibr">20</xref></sup>
<italic>PDX1</italic>, <italic>MAFA</italic>, <italic>INSM1</italic>, <italic>NEUROD1</italic> (<xref rid="F5" ref-type="fig">Figure 5H</xref>). Further, Sachdeva et al<sup><xref rid="R21" ref-type="bibr">21</xref></sup> suggest that <italic>PDX1</italic> deficiency makes beta cells less functional and exposes them to ER stress induced apoptosis.</p>
      <p id="P16">Intriguingly, we also observed an alpha cell subset that to our knowledge, has not been previously described. This cluster was also enriched with genes involved in ER stress (<xref rid="F5" ref-type="fig">Figure 5I</xref>, <italic>DDIT3</italic>, <italic>ATF3</italic>, <italic>ATF4</italic>, and <italic>HSPA5</italic>). Similar to the beta ER stress population, these alpha cells also expressed significantly lower levels of genes necessary for proper function:<sup><xref rid="R22" ref-type="bibr">22</xref>,<xref rid="R23" ref-type="bibr">23</xref></sup>
<italic>GCG</italic>, <italic>ISL1</italic>, <italic>ARX</italic>, and <italic>MAFB</italic> (<xref rid="F5" ref-type="fig">Figure 5J</xref>). A recent study<sup><xref rid="R24" ref-type="bibr">24</xref></sup> reported ER stress in alpha cells in mice and linked the stress to dysfunctional glucagon secretion. Moreover, we found that the proportions of alpha and beta ER stress cells are significantly correlated (spearman r=0.46, p=0.004, <xref rid="F5" ref-type="fig">Figure 5K</xref>) across donors in all datasets. These results suggest alpha cell injury might parallel beta cell dysfunction in humans during diabetes.<sup><xref rid="R25" ref-type="bibr">25</xref></sup> Importantly, this rare population was nearly impossible to identify in the original studies, because they were either too rare or obscured by donor-specific variation (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 15</xref>).</p>
    </sec>
    <sec id="S7">
      <title>Harmony Integrates Time Course Developmental Trajectories</title>
      <p id="P17">We next evaluated Harmony’s ability to integrate datasets with smooth trajectories, rather than discrete cell types. We analyzed 15,875 cells from 8 time points of mouse haematopoiesis,<sup><xref rid="R26" ref-type="bibr">26</xref></sup> from E6.75 to E8.5, and mixed gastrulation. This dataset presents a new challenge to Harmony: each sample was taken at a different developmental time point. Thus, no sample has all cell types represented (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 16A</xref>). Unsurprisingly, cells initially grouped by sample ID rather than by cell type (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 16B</xref>). After Harmony integration, samples are well mixed and group largely by previously defined cell type (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 16C</xref>). Encouragingly, Harmony preserved the continuous structure of the developmental cells rather than erroneously clustering cells into discrete groups. Harmony's soft clustering was critical to preserve the smoothness: it assigned cells from transitional populations to more clusters and cells in more terminal populations to fewer clusters (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 16D</xref>). With corrected Harmony embeddings, we performed trajectory analysis with DDRTree (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 16E</xref>). We recovered a branching trajectory structure that correctly captures the progression from common mesoderm and haematoendothelial progenitor populations to differentiated endothelial and erythroid populations. Interestingly, Harmony preserved the separation between the two blood progenitor populations but not in the three erythroid populations (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 16E</xref>). This suggests that these distinct erythroid populations may be an artifact of batch rather than biology. Benchmarking this analysis, (<xref rid="SD3" ref-type="supplementary-material">Supplementary Results</xref>), we found that except for MNN Correct, other algorithms failed to maintain smoothness or incorrectly mixed distinct progenitor populations (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 17</xref>).</p>
    </sec>
    <sec id="S8">
      <title>Harmony Integrates Dissociated scRNAseq with Spatially Resolved Datasets</title>
      <p id="P18">Now we consider the integration of cells measured with different modalities, measuring different aspects of a cell's biology. This type of integration is especially powerful, in that it allows inference of features measured in one modality but not the other. Harmony integrates a spatially resolved fluorescence in situ hybridization (FISH) dataset with a dissociated scRNAseq dataset from the mouse hypothalamic preoptic region (Bregma +0.5 to −0.6mm), using 154 shared genes (<xref rid="F6" ref-type="fig">Figure 6A</xref>). From the embedding, we infer the spatial localization of unmeasured genes to identify previously unreported spatial patterns in neuronal transcription factors. We downloaded two datasets published by Moffit et al:<sup><xref rid="R27" ref-type="bibr">27</xref>,<xref rid="R28" ref-type="bibr">28</xref></sup> 30,370 cells from 6 mice measured with dissociated scRNAseq (10X) and 64,373 cells from one mouse measured with multiplexed error robust FISH (MERFISH). The spatially resolved dataset is a combination of 135 genes assayed with MERFISH and 20 assayed with two-color single molecule (smFISH). The dissociated 10X data gives information about the full transcriptome (22,067 genes post QC) but without any spatial information. In contrast, MERFISH was applied in this dataset to only a targeted number of genes. The primary challenge in this analysis is the limited number of overlapping features. Successful integration will merge similar cell types and allow inference of spatial patterns of the remaining 21,913 genes.</p>
      <p id="P19">Before Harmony, cells group primarily by modality (median iLISI 1.00, 95% CI [1.00, 1.04], <xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 18A</xref>). Harmony mixes the two modalities, 10X and MERFISH (median iLISI 1.15, 95% CI [1.00, 1.99], <xref rid="F6" ref-type="fig">Figure 6B</xref>, <xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 18B</xref>) and merges cells based on their previous cell type labels covering 12 major neuronal and glial populations (93.7% prediction accuracy after integration vs 94% before integration, <xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 18C</xref>). As an independent validation, we show that the Harmony embedding agrees with the fine-grained cluster analysis in the original manuscript (<xref rid="SD3" ref-type="supplementary-material">Supplementary Results</xref>, <xref rid="SD4" ref-type="supplementary-material">Figs. 18D</xref>,<xref rid="SD4" ref-type="supplementary-material">E</xref>).</p>
      <p id="P20">We next used kernel kNN regression to predict gene expression in MERFISH dataset cells, based on their nearest 10X dataset neighbors (<xref rid="S10" ref-type="sec">online methods</xref>). We used five-fold cross validation to evaluate performance and found that we predicted 150 of 154 genes accurately, performing consistently better on highly expressed genes (<xref rid="SD3" ref-type="supplementary-material">Supplementary Results</xref>, <xref rid="SD4" ref-type="supplementary-material">Fig. 18F</xref>). The original manuscript identified key transcription factors that distinguished spatially distributed neuronal subtypes. After applying Harmony, we can easily identify spatially autocorrelated transcription factors. We measured the spatial autocorrelation (Moran's I) of all known vertebrate transcription factors documented in JASPAR<sup><xref rid="R29" ref-type="bibr">29</xref></sup> (<xref rid="SD8" ref-type="supplementary-material">Supplementary Tables 6</xref>,<xref rid="SD8" ref-type="supplementary-material">7</xref>). As expected, all factors associated with a neuronal subtype were significantly (FDR&lt;5%) spatially autocorrelated. In addition, we found 50 transcription factors significantly (FDR&lt;5%, Moran's I &gt; 0.1) autocorrelated in excitatory neurons and 37 in inhibitory neurons. We confirmed that these new factors were positive markers for at least one neuronal subtype. In fact, spatial correlation was significantly correlated (spearman r=0.71, p=2.6×10<sup>−62</sup>) with the AUC of that gene's best subtype (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 18G</xref>).</p>
      <p id="P21">We next followed up on <italic>Satb1</italic>, a chromatin organizer linked with survival of mouse cortical interneurons,<sup><xref rid="R30" ref-type="bibr">30</xref></sup> as it was strongly auto-correlated in inhibitory neurons (Moran's I=0.44). The predicted Satb1 expression was localized to anterior slices (<xref rid="F6" ref-type="fig">Figure 6C</xref>). To validate this localization, we compared predicted expression to matched images of <italic>Satb1</italic> expression from the Allen Brain Atlas.<sup><xref rid="R31" ref-type="bibr">31</xref></sup> These images were chosen for similar anterior-posterior position (between Bregma +0.8 to −0.2mm) and ventricular morphology (in green). The measured <italic>Satb1</italic> expression follows qualitatively similar patterns of predicted expression (<xref rid="F6" ref-type="fig">Figure 6D</xref>).</p>
      <p id="P22">These 154 genes were carefully selected by the authors to be biologically relevant to cell types in the hypothalamic preoptic region. Using correlation informed downsampling, we were able to achieve similar results with only 60 representative anchor genes (<xref rid="SD3" ref-type="supplementary-material">Supplementary Results</xref>, <xref rid="SD4" ref-type="supplementary-material">Figs. 18H</xref>,<xref rid="SD4" ref-type="supplementary-material">I</xref>).</p>
    </sec>
  </sec>
  <sec id="S9">
    <title>Discussion:</title>
    <p id="P23">Integration across multiple data sets is an essential component to conduct large scale inference with single cell data sets. We showed that Harmony addresses the four key challenges we laid out for single cell integration analyses: scaling to large datasets, identification of both broad populations and fine-grained subpopulations, flexibility to accommodate complex experimental design, and the power to integrate across modalities. In addition, Harmony is efficient, requiring only 7.2GB to integrate 500,000 cells; it is currently the only algorithm that enables integration of large datasets on personal computers. It can also be effective in identifying rare populations. In our meta-analysis of pancreatic islet cells, we identified a previously undescribed rare subpopulation of alpha ER stress cells. Experimental follow up on this alpha subtype and its relation to beta ER stress cells may yield insight into diabetes.</p>
    <p id="P24">Harmony accepts a matrix of cells and covariate labels for each cell as input. Its output is a matrix of adjusted coordinates with the same dimensions as the input matrix. Hence, Harmony should be applied first before a full analysis pipeline is employed. Downstream analyses, such as clustering, trajectory analysis, and visualization, can then use integrated Harmony adjusted. Harmony does not alter the expression values of individual genes to account for dataset-specific differences. We recommend using a batch-aware approach, such as a mixed effects linear models, for differential expression analysis.</p>
    <p id="P25">Harmony uses clusters to partition the large non-linear embeddings in which cells sit into smaller linear regions. With discrete clustering, it is possible to over-discretize the space and lose smooth transitions between populations (for examples see <xref rid="SD7" ref-type="supplementary-material">Supplementary Note 3</xref>). Harmony avoids over-discretization by using soft clustering. With this strategy, in the mouse embryogenesis dataset, Harmony effectively modeled both terminal populations and transition states, retaining smooth transitions and bifurcation events from a common progenitor into endothelial and hematopoietic lineages.</p>
    <p id="P26">With the advent of high throughput single cell technologies, it is now possible to assay different interacting facets of a cells' biology. Effective synthesis of datasets across multiple modalities may help reveal such interactions. Harmony embedded spatially resolved MERFISH cells with dissociated 10X cells, despite limited overlap of genes and dramatically different capture efficiencies between these technologies. Consequently, we were able to analyze spatial patterns of gene expression on genes that were never measured with MERFISH. The ability of Harmony to integrate 10X and MERFISH and impute unmeasured gene expression relies on the quality of the overlapping set of anchor genes. Selecting the optimal anchor genes is an important open question. From our cross validation and minimal geneset analyses, we found two trends that may help guide spatial probeset design. First, we can remove correlated genes from the anchors with minimal loss in integration quality. Second, less abundant genes are more difficult to predict. Thus, a spatial probeset containing genes with lower abundance that are also maximally non-redundant should enable imputation of a large number of genes through Harmony with an appropriate scRNAseq dataset.</p>
    <p id="P27">It is common practice to apply batch-sensitive gene preprocessing steps before application of single-cell integration algorithms. In particular, some investigators scale gene expression values within datasets separately, before pooling cells into a single matrix. While this strategy may make it easier to integrate certain datasets (<xref rid="SD3" ref-type="supplementary-material">Supplementary Results</xref>, <xref rid="SD4" ref-type="supplementary-material">Figs. 19A</xref>,<xref rid="SD4" ref-type="supplementary-material">B</xref>) in which all cell populations are present across all datasets, it may increase error when datasets consist of overlapping but not identical populations (<xref rid="SD4" ref-type="supplementary-material">Supplementary Fig. 19C</xref>). Hence, we do not use this scaling strategy in this manuscript. In our analysis pipelines, we avoid all batch-sensitive preprocessing steps. We simply concatenate the data and perform PCA on the combined data set.</p>
    <p id="P28">Harmony models and removes the effects of known sources of variation. However, unwanted variation may also arise from unknown sources. Methods such as SVA<sup><xref rid="R32" ref-type="bibr">32</xref></sup> and PEER<sup><xref rid="R33" ref-type="bibr">33</xref></sup> infer and remove latent sources of variation with linear models in bulk transcriptomics. In future work, we plan to extend Harmony to identify and remove unwanted latent effects.</p>
    <p id="P29">With the rise of automated classification algorithms, it is feasible that a user may be able to assign information about cell types prior to integration. For example, in the past, our group has used a classifier to define soft or hard identities to assign probabilistic classifications to single cells with linear discriminant analysis.<sup><xref rid="R3" ref-type="bibr">3</xref>,<xref rid="R34" ref-type="bibr">34</xref></sup> Harmony has an advanced option to initialize soft cluster assignments using such probabilistic cell type assignments (See ?HarmonyMatrix). If the prior assignments are helpful, Harmony will converge to an accurate solution faster. If the prior assignments are inaccurate, Harmony can reassign cells appropriately during the clustering steps.</p>
    <p id="P30">The Harmony framework lays the groundwork for several exciting future application. First, it can be extended to accurately model gene counts. This will allow users to apply Harmony preprocessing for methods which require full gene expression profiles, rather than low dimensional cell embeddings, such as RNA velocity<sup><xref rid="R35" ref-type="bibr">35</xref></sup>. Next, we envision specializing Harmony to quickly map cells to a multi-billion cell reference that covers a comprehensive set of tissues, organisms, and clinical conditions. This application will enable rapid comparison of cells from a single experiment against a larger reference, and in the process annotate known and novel cell types and states in seconds.</p>
  </sec>
  <sec id="S10">
    <title>Online Methods</title>
    <sec id="S11">
      <label>1</label>
      <title>Harmony</title>
      <sec id="S12">
        <label>1.1</label>
        <title>Overview</title>
        <p id="P31">The Harmony algorithm inputs a PCA embedding (Z) of cells, along with their batch assignments (ϕ), and returns a batch corrected embedding (<inline-formula><mml:math display="inline" id="M1" overflow="scroll"><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula>). This algorithm, summarized as <xref rid="T1" ref-type="table">Algorithm 1</xref> below, iterates between two complementary stages: maximum diversity clustering (<xref rid="T2" ref-type="table">Algorithm 2</xref>) and a mixture model based linear batch correction (<xref rid="T3" ref-type="table">Algorithm 3</xref>). The clustering step uses the batch corrected embedding <inline-formula><mml:math display="inline" id="M2" overflow="scroll"><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> to compute a soft assignment of cells to clusters, encoded in the matrix R. The correction step uses these soft clusters to compute a new corrected embedding from the original one. Efficient implementations of Harmony, including the clustering and correction subroutines, are available as part of an R package at <ext-link ext-link-type="uri" xlink:href="https://github.com/immunogenomics/harmony">https://github.com/immunogenomics/harmony</ext-link>.</p>
        <p id="P32">Note that the correction procedure uses Z, not <inline-formula><mml:math display="inline" id="M3" overflow="scroll"><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> to regress out confounder effects. In this way, we restrict correction to a linear model of the original embedding. An alternative approach would use the output <inline-formula><mml:math display="inline" id="M4" overflow="scroll"><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> of the last iteration as input to the correction procedure. Thus, the final <inline-formula><mml:math display="inline" id="M5" overflow="scroll"><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> would be the result of a series of linear corrections of the original embedding. While this allows for more expressive transformations, we found that in practice, this can over correct the data. Our choice to limit the transformation reflects the notion in the introduction. Namely, if we had perfect knowledge of the cell types before correction, we would linearly regress out batch within each cell type.</p>
      </sec>
      <sec id="S13">
        <label>1.2</label>
        <title>Algorithm</title>
        <table-wrap id="T1" position="anchor" orientation="portrait">
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th align="left" valign="top" rowspan="1" colspan="1">Algorithm 1 Harmony</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">
                  <disp-formula id="FD44">
                    <mml:math display="block" id="M6" overflow="scroll">
                      <mml:mtable>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mi mathvariant="bold">function</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mtext>HARMONIZE</mml:mtext>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi>Z</mml:mi>
                              <mml:mo>,</mml:mo>
                              <mml:mi>ϕ</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mover accent="true">
                                <mml:mi>Z</mml:mi>
                                <mml:mo>^</mml:mo>
                              </mml:mover>
                              <mml:mo>←</mml:mo>
                              <mml:mi>Z</mml:mi>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mi mathvariant="bold">repeat</mml:mi>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mi>R</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mtext>CLUSTER</mml:mtext>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mover accent="true">
                                <mml:mi>Z</mml:mi>
                                <mml:mo>^</mml:mo>
                              </mml:mover>
                              <mml:mo>,</mml:mo>
                              <mml:mi>ϕ</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mover accent="true">
                                <mml:mi>Z</mml:mi>
                                <mml:mo>^</mml:mo>
                              </mml:mover>
                              <mml:mo>←</mml:mo>
                              <mml:mtext>CORRECT</mml:mtext>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi>Z</mml:mi>
                              <mml:mo>,</mml:mo>
                              <mml:mi>R</mml:mi>
                              <mml:mo>,</mml:mo>
                              <mml:mi>ϕ</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mi mathvariant="bold">until</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mtext>convergence</mml:mtext>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mi mathvariant="bold">return</mml:mi>
                              <mml:mover accent="true">
                                <mml:mi>Z</mml:mi>
                                <mml:mo>^</mml:mo>
                              </mml:mover>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                      </mml:mtable>
                    </mml:math>
                  </disp-formula>
                </td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
      <sec id="S14">
        <label>1.3</label>
        <title>Glossary</title>
        <p id="P33">For reference, we define all data structures used in all Harmony functions. For each one, we define its dimensions and possible values, as well as an intuitive description of what it means in context. The dimensions are stated in terms of <bold>d</bold>: the dimensionality of the embedding (e.g. number of PCs), <bold>B</bold>: the number of batcsssshes, <bold>N</bold>: the number of samples, <bold>N</bold><sub><bold>b</bold></sub>: the number of samples in batch <bold>b</bold>, and <bold>K</bold>: the number of clusters.</p>
        <p id="P34"><inline-formula><mml:math display="inline" id="M7" overflow="scroll"><mml:mrow><mml:mi>Z</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> The input embedding, to be corrected in Harmony. This is often PCA embeddings of cells.</p>
        <p id="P35"><inline-formula><mml:math display="inline" id="M8" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> The integrated embedding, output by Harmony.</p>
        <p id="P36"><italic>R</italic> ∈ [0,1]<sup><italic>KxN</italic></sup> The soft cluster assignment matrix of cells (columns) to clusters (rows). Each column is a probability distribution and thus sums to 1.</p>
        <p id="P37"><italic>ϕ</italic> ∈ {0,1}<sup><italic>BxN</italic></sup> One-hot assignment matrix of cells (columns) to batches (rows).</p>
        <p id="P38"><italic>Pr<sub>b</sub></italic> ∈ [0,1]<sup><italic>B</italic></sup> Frequency of batches.</p>
        <p id="P39"><italic>O</italic> ∈ [0,1]<sup><italic>KxB</italic></sup> The observed co-occurence matrix of cells in clusters (rows) and batches (columns).</p>
        <p id="P40"><italic>E</italic> ∈ [0,1]<sup><italic>KxN</italic></sup> The expected co-occurence matrix of cells in clusters and batches, under the assumption of independence between cluster and batch assignment.</p>
        <p id="P41"><italic>Y</italic> ∈ [0,1]<sup><italic>dxK</italic></sup> Cluster centroid locations in the kmeans clustering algorithm.</p>
      </sec>
      <sec id="S15">
        <label>1.4</label>
        <title>Assumptions about input data</title>
        <p id="P42">In this manuscript, we always use Harmony on a low dimensional embedding of the cells. To be clear about the properties of this low dimensional space, we explicitly state three assumptions:</p>
        <list list-type="order" id="L2">
          <list-item>
            <p id="P43">Cells are embedded into a low dimensional space as the result of PCA. The PCA embedding captures the variation of gene expression in a compact orthonormal space. For this reason, the default input to Harmony is now a matrix of gene expression data, normalized for library size. We then perform PCA on this high-dimensional matrix and use the eigenvalue-scaled eigenvectors as the low dimensional embedding input to Harmony.</p>
          </list-item>
          <list-item>
            <p id="P44">Gene expression has been normalized for library size. In RNAseq, each cell will be sequenced to a different depth, which results in different library sizes for each cell. It is best practice to account for this source of technical variation before performing PCA. In this manuscript, we use the standard transformation akin to log CPM, described in the <xref rid="S10" ref-type="sec">online methods</xref>. As a result of this depth transformation, expression values are turned into relative frequencies inside each cell. Thus, it is impossible for every gene to be upregulated in one group of cells.</p>
          </list-item>
          <list-item>
            <p id="P45">The low dimensional nearest neighbor structure induced by Euclidean distance should be preserved with common similarity metrics such as cosine similarity and correlation. This can be easily checked by computing sparse nearest neighbor graphs and comparing the adjacency matrices. Cells with less than 20% overlapping neighbors can be removed as outliers. A common way to violate this assumption is to simulate cells around the origin (i.e. all embeddings equal 0). We do not find this to be the case in real scRNAseq data. This assumption is common to integration methods that use cosine distance to compare cells, such as MNN Correct and Scanorama.</p>
          </list-item>
        </list>
      </sec>
    </sec>
    <sec id="S16">
      <label>2</label>
      <title>Maximum Diversity Clustering</title>
      <p id="P46">We developed a clustering algorithm to maximize the diversity among batches within clusters. We present this method as follows. First, we review a previously published objective function for soft k-means clustering. We then add a diversity maximizing regularization term to this objective function, and derive this regularization term as the penalty on statistical dependence between two random variables: batch membership and cluster assignment. We then derive and present pseudocode for an algorithm to optimize the objective function. Finally, we explain key details of the implementation.</p>
      <sec id="S17">
        <label>2.1</label>
        <title>Background: Entropy regularization for Soft K-means</title>
        <p id="P47">The basic objective function for classical K means clustering, in which each cell belongs to exactly one cluster, is defined by the distance from cells to their assigned centroids.</p>
        <disp-formula id="FD1">
          <label>(1)</label>
          <mml:math display="block" id="M10" overflow="scroll">
            <mml:mrow>
              <mml:munder>
                <mml:mi>min</mml:mi>
                <mml:mrow>
                  <mml:mi>R</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>Y</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo stretchy="false">‖</mml:mo>
              <mml:msub>
                <mml:mi>Z</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo>−</mml:mo>
              <mml:msub>
                <mml:mi>Y</mml:mi>
                <mml:mi>k</mml:mi>
              </mml:msub>
              <mml:msup>
                <mml:mo stretchy="false">‖</mml:mo>
                <mml:mn>2</mml:mn>
              </mml:msup>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD2">
          <mml:math display="block" id="M11" overflow="scroll">
            <mml:mrow>
              <mml:mi>s</mml:mi>
              <mml:mo>.</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>.</mml:mo>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>k</mml:mi>
              </mml:msub>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">{</mml:mo>
              <mml:mn>0</mml:mn>
              <mml:mo>,</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo stretchy="false">}</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p id="P48">Above, Z is some feature space of the data, shared by centroids Y. R<sub>k,i</sub> can takes values 0 or 1, denoting membership of cell i in cluster k. In order to transform this into a soft clustering objective, we follow the direction of<sup><xref rid="R36" ref-type="bibr">36</xref></sup> and add an entropy regularization term over R, weighted by a hyperparameter σ. Now, R<sub>ki</sub> can take values between 0 and 1, so long as for a given cell i, the sum over cluster memberships Σ<sub>k</sub> R<sub>ki</sub> equals 1. That is, R<sub>i</sub>. must be a proper probability distribution with support [1,K].</p>
        <disp-formula id="FD3">
          <label>(2)</label>
          <mml:math display="block" id="M12" overflow="scroll">
            <mml:mrow>
              <mml:munder>
                <mml:mi>min</mml:mi>
                <mml:mrow>
                  <mml:mi>R</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>Y</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo stretchy="false">‖</mml:mo>
              <mml:msub>
                <mml:mi>Z</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo>−</mml:mo>
              <mml:msub>
                <mml:mi>Y</mml:mi>
                <mml:mi>k</mml:mi>
              </mml:msub>
              <mml:msup>
                <mml:mo stretchy="false">‖</mml:mo>
                <mml:mn>2</mml:mn>
              </mml:msup>
              <mml:mo>+</mml:mo>
              <mml:mi>σ</mml:mi>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mspace width="thinmathspace"/>
              <mml:mi>log</mml:mi>
              <mml:mspace width="thinmathspace"/>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD4">
          <mml:math display="block" id="M13" overflow="scroll">
            <mml:mrow>
              <mml:mi>s</mml:mi>
              <mml:mo>.</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>.</mml:mo>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>k</mml:mi>
              </mml:msub>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>&gt;</mml:mo>
              <mml:mn>0</mml:mn>
              <mml:mo>,</mml:mo>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>K</mml:mi>
              </mml:munderover>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mn>1</mml:mn>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p id="P49">As σ approaches 0, this penalty approaches hard clustering. As σ approaches infinity, the entropy of R outweighs the data-centroid distances. In this case, each data point is assigned equally to all clusters.</p>
      </sec>
      <sec id="S18">
        <label>2.2</label>
        <title>Objective Function for Maximum Diversity Clustering</title>
        <p id="P50">The full objective function for Harmony's clustering builds on the previous section. In addition to soft assignment regularization, the function below penalizes clusters with low batch-diversity, for all defined batch variables. This penalty, derived in the following section, depends on the cluster and batch identities Ω(R, <italic>ϕ</italic><sub>i</sub>) = Σ<sub>i,k</sub> R<sub>ki</sub> log(O<sub>ki</sub>/E<sub>ki</sub>)ϕ<sub>i</sub>.</p>
        <disp-formula id="FD5">
          <label>(3)</label>
          <mml:math display="block" id="M14" overflow="scroll">
            <mml:mrow>
              <mml:munder>
                <mml:mi>min</mml:mi>
                <mml:mrow>
                  <mml:mi>R</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>Y</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo stretchy="false">‖</mml:mo>
              <mml:msub>
                <mml:mi>Z</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo>−</mml:mo>
              <mml:msub>
                <mml:mi>Y</mml:mi>
                <mml:mi>k</mml:mi>
              </mml:msub>
              <mml:msup>
                <mml:mo stretchy="false">‖</mml:mo>
                <mml:mn>2</mml:mn>
              </mml:msup>
              <mml:mo>+</mml:mo>
              <mml:mi>σ</mml:mi>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mspace width="thinmathspace"/>
              <mml:mi>log</mml:mi>
              <mml:mspace width="thinmathspace"/>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>+</mml:mo>
              <mml:mi>σ</mml:mi>
              <mml:mi>θ</mml:mi>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mspace width="thinmathspace"/>
              <mml:mi>log</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>O</mml:mi>
                    <mml:mrow>
                      <mml:mi>k</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>E</mml:mi>
                    <mml:mrow>
                      <mml:mi>k</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:msub>
                <mml:mi>ϕ</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD6">
          <mml:math display="block" id="M15" overflow="scroll">
            <mml:mrow>
              <mml:mi>s</mml:mi>
              <mml:mo>.</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>.</mml:mo>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>k</mml:mi>
              </mml:msub>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>&gt;</mml:mo>
              <mml:mn>0</mml:mn>
              <mml:mo>,</mml:mo>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>K</mml:mi>
              </mml:munderover>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mn>1</mml:mn>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p id="P51">For each batch variable, we add a new parameter θ. θ decides the degree of penalty for dependence between batch membership and cluster assignment. When ∀<sub>f</sub>θ=0, the problem reverts back to <xref rid="FD3" ref-type="disp-formula">(2)</xref>, with no penalty on dependence. As θ increases, the objective function favors more independence between batch f and cluster assignment. As θ approaches infinity, it will yield a degenerate solution. In this case, each cluster has an equivalent distribution across batch f. However, the distances between cells and centroids may be large. Finally, σ is added to this term for notational convenience in the gradient calculations.</p>
        <p id="P52">We found that this clustering works best when we compute the cosine, rather than Euclidean distance, between Z and Y. Haghverdi et al<sup><xref rid="R8" ref-type="bibr">8</xref></sup> showed that the squared Euclidean distance is equivalent to cosine distance when the vectors are L<sub>2</sub> normalized. Therefore, assuming that all Z<sub>i</sub> and Y<sub>k</sub> have a unity L<sub>2</sub> norm, the squared Euclidean distance above can be re-written as a dot product.</p>
        <disp-formula id="FD7">
          <label>(4)</label>
          <mml:math display="block" id="M16" overflow="scroll">
            <mml:mrow>
              <mml:munder>
                <mml:mi>min</mml:mi>
                <mml:mrow>
                  <mml:mi>R</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>Y</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mn>2</mml:mn>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:msubsup>
                <mml:mi>Y</mml:mi>
                <mml:mi>k</mml:mi>
                <mml:mi>T</mml:mi>
              </mml:msubsup>
              <mml:msub>
                <mml:mi>Z</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>+</mml:mo>
              <mml:mi>σ</mml:mi>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mspace width="thinmathspace"/>
              <mml:mi>log</mml:mi>
              <mml:mspace width="thinmathspace"/>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>+</mml:mo>
              <mml:mi>σ</mml:mi>
              <mml:mi>θ</mml:mi>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mspace width="thinmathspace"/>
              <mml:mi>log</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>O</mml:mi>
                    <mml:mrow>
                      <mml:mi>k</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>E</mml:mi>
                    <mml:mrow>
                      <mml:mi>k</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:msub>
                <mml:mi>ϕ</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD8">
          <mml:math display="block" id="M17" overflow="scroll">
            <mml:mrow>
              <mml:mi>s</mml:mi>
              <mml:mo>.</mml:mo>
              <mml:mi>t</mml:mi>
              <mml:mo>.</mml:mo>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>k</mml:mi>
              </mml:msub>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>&gt;</mml:mo>
              <mml:mn>0</mml:mn>
              <mml:mo>,</mml:mo>
              <mml:msub>
                <mml:mo>∀</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>K</mml:mi>
              </mml:munderover>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mn>1</mml:mn>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </sec>
      <sec id="S19">
        <label>2.3</label>
        <title>Cluster Diversity Score</title>
        <p id="P53">Here, we discuss and derive the diversity penalty term Ω(.), defined in the previous section. For simplicity, we discuss diversity with respect to a single batch variable, as the multiple batch penalty terms are additive in the objective function. The goal of Ω(.) is to penalize statistical dependence between batch identity and cluster assignment. In statistics, dependence between two discrete random variables is typically measured with the <italic>χ</italic><sup>2</sup> statistic. This test considers the frequencies with which different values of the two random variables are observed together. The observed co-occurrence counts (O) are compared to the counts expected under independence (E). For practical reasons, we do not use the <italic>χ</italic><sup>2</sup> statistic directly. Instead, we use the Kullback Leibler Divergence (D<sub>KL</sub>), an information theoretic distance between two distributions. In this section, we define the O and E distributions, as well the D<sub>KL</sub> penalty, in the context of the probabilistic cluster assignment matrix R.</p>
        <disp-formula id="FD9">
          <mml:math display="block" id="M18" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>O</mml:mi>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mi>N</mml:mi>
              <mml:mspace width="thinmathspace"/>
              <mml:mi>P</mml:mi>
              <mml:mi>r</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>k</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD10">
          <mml:math display="block" id="M19" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>O</mml:mi>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mi>N</mml:mi>
              <mml:mspace width="thinmathspace"/>
              <mml:mi>P</mml:mi>
              <mml:mi>r</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>k</mml:mi>
              <mml:mo stretchy="false">∣</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mtext>Pr</mml:mtext>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD11">
          <mml:math display="block" id="M20" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>O</mml:mi>
                <mml:mi mathvariant="italic">bk</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mi>N</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:munder>
              <mml:msub>
                <mml:mn>1</mml:mn>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>R</mml:mi>
                    <mml:mrow>
                      <mml:mi>k</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>N</mml:mi>
                    <mml:mi>b</mml:mi>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>N</mml:mi>
                    <mml:mi>b</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mi>N</mml:mi>
              </mml:mfrac>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD12">
          <label>(5)</label>
          <mml:math display="block" id="M21" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>O</mml:mi>
                <mml:mi mathvariant="italic">bk</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:munder>
              <mml:msub>
                <mml:mn>1</mml:mn>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD13">
          <mml:math display="block" id="M22" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>E</mml:mi>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mi>N</mml:mi>
              <mml:mspace width="thinmathspace"/>
              <mml:mi mathvariant="italic">Pr</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>k</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD14">
          <mml:math display="block" id="M23" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>E</mml:mi>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mi>N</mml:mi>
              <mml:mspace width="thinmathspace"/>
              <mml:mi mathvariant="italic">Pr</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>k</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mtext>Pr</mml:mtext>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD15">
          <mml:math display="block" id="M24" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>E</mml:mi>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mi>N</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:munder>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>R</mml:mi>
                    <mml:mrow>
                      <mml:mi>k</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>N</mml:mi>
                    <mml:mi>b</mml:mi>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>N</mml:mi>
                    <mml:mi>b</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mi>N</mml:mi>
              </mml:mfrac>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD16">
          <label>(6)</label>
          <mml:math display="block" id="M25" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>E</mml:mi>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>N</mml:mi>
                    <mml:mi>b</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mi>N</mml:mi>
              </mml:mfrac>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mi>i</mml:mi>
              </mml:munder>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p id="P54">Next, we define the KL divergence in terms of R. Note that both O and E depend on R. However, in the derivation below, we expand one of the O terms. This serves a functional purpose in the optimization procedure, described later. Intuitively, in the update step of R for a single cell, we compute O and E on all the other cells. In this way, we decide how to assign the single cell to clusters given the current distribution of batches amongst clusters.</p>
        <disp-formula id="FD17">
          <mml:math display="block" id="M26" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>D</mml:mi>
                <mml:mi mathvariant="italic">KL</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>E</mml:mi>
              <mml:mo stretchy="false">‖</mml:mo>
              <mml:mi>O</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>B</mml:mi>
              </mml:munderover>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>K</mml:mi>
              </mml:munderover>
              <mml:msub>
                <mml:mi>O</mml:mi>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>k</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mspace width="thinmathspace"/>
              <mml:mi>log</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>O</mml:mi>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>E</mml:mi>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo stretchy="false">)</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD18">
          <mml:math display="block" id="M27" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>D</mml:mi>
                <mml:mi mathvariant="italic">KL</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>E</mml:mi>
              <mml:mo stretchy="false">‖</mml:mo>
              <mml:mi>O</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>B</mml:mi>
              </mml:munderover>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>K</mml:mi>
              </mml:munderover>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>N</mml:mi>
              </mml:munderover>
              <mml:msub>
                <mml:mn>1</mml:mn>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo stretchy="false">]</mml:mo>
              <mml:mi>log</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>O</mml:mi>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>E</mml:mi>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo stretchy="false">)</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD19">
          <mml:math display="block" id="M28" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>D</mml:mi>
                <mml:mi mathvariant="italic">KL</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>E</mml:mi>
              <mml:mo stretchy="false">‖</mml:mo>
              <mml:mi>O</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>N</mml:mi>
              </mml:munderover>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>K</mml:mi>
              </mml:munderover>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>B</mml:mi>
              </mml:munderover>
              <mml:msub>
                <mml:mn>1</mml:mn>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mspace width="thinmathspace"/>
              <mml:mi>log</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>O</mml:mi>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>E</mml:mi>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo stretchy="false">)</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="FD20">
          <label>(7)</label>
          <mml:math display="block" id="M29" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>D</mml:mi>
                <mml:mi mathvariant="italic">KL</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>E</mml:mi>
              <mml:mo stretchy="false">‖</mml:mo>
              <mml:mi>O</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>N</mml:mi>
              </mml:munderover>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>K</mml:mi>
              </mml:munderover>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mspace width="thinmathspace"/>
              <mml:mi>log</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>O</mml:mi>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>E</mml:mi>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:msub>
                <mml:mi>ϕ</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </sec>
      <sec id="S20">
        <label>2.4</label>
        <title>Optimization</title>
        <p id="P55">Optimization of <xref rid="FD7" ref-type="disp-formula">(4)</xref> admits an Expectation-Maximization framework, iterating between cluster assignment (R) and centroid (Y) estimation.</p>
        <sec id="S21">
          <label>2.4.1</label>
          <title>Cluster assignment <italic>R</italic></title>
          <p id="P56">Using the same strategy as<sup><xref rid="R36" ref-type="bibr">36</xref></sup>, we solve for the optimal assignment R<sub>i</sub> for each cell i. First we set up the Lagrangian with dual parameter λ and solve for the partial derivative wrt each cluster k.</p>
          <disp-formula id="FD21">
            <mml:math display="block" id="M30" overflow="scroll">
              <mml:mrow>
                <mml:mi>L</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mi>R</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:msub>
                <mml:mo>,</mml:mo>
                <mml:mi>λ</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:munderover>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mi>K</mml:mi>
                </mml:munderover>
                <mml:msub>
                  <mml:mi>R</mml:mi>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mn>2</mml:mn>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>−</mml:mo>
                <mml:msubsup>
                  <mml:mi>Y</mml:mi>
                  <mml:mi>k</mml:mi>
                  <mml:mi>T</mml:mi>
                </mml:msubsup>
                <mml:msub>
                  <mml:mi>Z</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>+</mml:mo>
                <mml:mi>σ</mml:mi>
                <mml:msub>
                  <mml:mi>R</mml:mi>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mspace width="thinmathspace"/>
                <mml:mi>log</mml:mi>
                <mml:mspace width="thinmathspace"/>
                <mml:msub>
                  <mml:mi>R</mml:mi>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>+</mml:mo>
                <mml:mi>σ</mml:mi>
                <mml:mi>θ</mml:mi>
                <mml:msub>
                  <mml:mi>R</mml:mi>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mspace width="thinmathspace"/>
                <mml:mi>log</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>O</mml:mi>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>R</mml:mi>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
                <mml:mo>+</mml:mo>
                <mml:mi>λ</mml:mi>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:munderover>
                      <mml:mo>∑</mml:mo>
                      <mml:mrow>
                        <mml:mi>k</mml:mi>
                        <mml:mo>=</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mi>K</mml:mi>
                    </mml:munderover>
                    <mml:msub>
                      <mml:mi>R</mml:mi>
                      <mml:mrow>
                        <mml:mi>k</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false">]</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
          <disp-formula id="FD22">
            <mml:math display="block" id="M31" overflow="scroll">
              <mml:mrow>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>δ</mml:mi>
                    <mml:mi>L</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mi>R</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:mi>λ</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>δ</mml:mi>
                    <mml:msub>
                      <mml:mi>R</mml:mi>
                      <mml:mrow>
                        <mml:mi>k</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mfrac>
                <mml:mo>=</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>=</mml:mo>
                <mml:mn>2</mml:mn>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>−</mml:mo>
                <mml:msubsup>
                  <mml:mi>Y</mml:mi>
                  <mml:mi>k</mml:mi>
                  <mml:mi>T</mml:mi>
                </mml:msubsup>
                <mml:msub>
                  <mml:mi>Z</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>+</mml:mo>
                <mml:mi>σ</mml:mi>
                <mml:mo>+</mml:mo>
                <mml:mi>σ</mml:mi>
                <mml:mspace width="thinmathspace"/>
                <mml:mi>log</mml:mi>
                <mml:mspace width="thinmathspace"/>
                <mml:msub>
                  <mml:mi>R</mml:mi>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>+</mml:mo>
                <mml:mi>σ</mml:mi>
                <mml:mi>θ</mml:mi>
                <mml:mspace width="thinmathspace"/>
                <mml:mi>log</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>O</mml:mi>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>E</mml:mi>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
                <mml:mo>+</mml:mo>
                <mml:mi>λ</mml:mi>
              </mml:mrow>
            </mml:math>
          </disp-formula>
          <disp-formula id="FD23">
            <mml:math display="block" id="M32" overflow="scroll">
              <mml:mrow>
                <mml:mi>log</mml:mi>
                <mml:mspace width="thinmathspace"/>
                <mml:msub>
                  <mml:mi>R</mml:mi>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mo>−</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>−</mml:mo>
                    <mml:msubsup>
                      <mml:mi>Y</mml:mi>
                      <mml:mi>k</mml:mi>
                      <mml:mi>T</mml:mi>
                    </mml:msubsup>
                    <mml:msub>
                      <mml:mi>Z</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mi>σ</mml:mi>
                </mml:mfrac>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>−</mml:mo>
                <mml:mi>θ</mml:mi>
                <mml:mi>log</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>O</mml:mi>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>E</mml:mi>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
                <mml:mo>−</mml:mo>
                <mml:mfrac>
                  <mml:mi>λ</mml:mi>
                  <mml:mi>σ</mml:mi>
                </mml:mfrac>
              </mml:mrow>
            </mml:math>
          </disp-formula>
          <disp-formula id="FD24">
            <mml:math display="block" id="M33" overflow="scroll">
              <mml:mrow>
                <mml:msub>
                  <mml:mi>R</mml:mi>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mo stretchy="true">(</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>O</mml:mi>
                          <mml:mrow>
                            <mml:mi>k</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>E</mml:mi>
                          <mml:mrow>
                            <mml:mi>k</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mfrac>
                    <mml:mo stretchy="true">)</mml:mo>
                  </mml:mrow>
                  <mml:mi>θ</mml:mi>
                </mml:msup>
                <mml:mtext>exp</mml:mtext>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:msubsup>
                          <mml:mi>Y</mml:mi>
                          <mml:mi>k</mml:mi>
                          <mml:mi>T</mml:mi>
                        </mml:msubsup>
                        <mml:msub>
                          <mml:mi>Z</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mi>σ</mml:mi>
                    </mml:mfrac>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
                <mml:mo>⋅</mml:mo>
                <mml:mtext>exp</mml:mtext>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mo>−</mml:mo>
                <mml:mfrac>
                  <mml:mi>λ</mml:mi>
                  <mml:mi>σ</mml:mi>
                </mml:mfrac>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
          <p id="P57">Next, we use the probability constraint <inline-formula><mml:math display="inline" id="M34" overflow="scroll"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to solve for <inline-formula><mml:math display="inline" id="M35" overflow="scroll"><mml:mrow><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mmultiscripts><mml:mo stretchy="false">∕</mml:mo><mml:mi>σ</mml:mi><mml:none/><mml:mprescripts/><mml:none/><mml:mi>λ</mml:mi></mml:mmultiscripts><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
          <disp-formula id="FD25">
            <mml:math display="block" id="M36" overflow="scroll">
              <mml:mrow>
                <mml:mn>1</mml:mn>
                <mml:mo>=</mml:mo>
                <mml:munderover>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mi>K</mml:mi>
                </mml:munderover>
                <mml:msub>
                  <mml:mi>R</mml:mi>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
            </mml:math>
          </disp-formula>
          <disp-formula id="FD26">
            <mml:math display="block" id="M37" overflow="scroll">
              <mml:mrow>
                <mml:mn>1</mml:mn>
                <mml:mo>=</mml:mo>
                <mml:munderover>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mi>K</mml:mi>
                </mml:munderover>
                <mml:msup>
                  <mml:mrow>
                    <mml:mo stretchy="true">(</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>O</mml:mi>
                          <mml:mrow>
                            <mml:mi>k</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>E</mml:mi>
                          <mml:mrow>
                            <mml:mi>k</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mfrac>
                    <mml:mo stretchy="true">)</mml:mo>
                  </mml:mrow>
                  <mml:mi>θ</mml:mi>
                </mml:msup>
                <mml:mtext>exp</mml:mtext>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:msubsup>
                          <mml:mi>Y</mml:mi>
                          <mml:mi>k</mml:mi>
                          <mml:mi>T</mml:mi>
                        </mml:msubsup>
                        <mml:msub>
                          <mml:mi>Z</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mi>σ</mml:mi>
                    </mml:mfrac>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
                <mml:mo>⋅</mml:mo>
                <mml:mtext>exp</mml:mtext>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mo>−</mml:mo>
                <mml:mfrac>
                  <mml:mi>λ</mml:mi>
                  <mml:mi>σ</mml:mi>
                </mml:mfrac>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
          <disp-formula id="FD27">
            <mml:math display="block" id="M38" overflow="scroll">
              <mml:mrow>
                <mml:mtext>exp</mml:mtext>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mfrac>
                      <mml:mi>λ</mml:mi>
                      <mml:mi>σ</mml:mi>
                    </mml:mfrac>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mn>1</mml:mn>
                  <mml:mrow>
                    <mml:munderover>
                      <mml:mo>∑</mml:mo>
                      <mml:mrow>
                        <mml:mi>k</mml:mi>
                        <mml:mo>=</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mi>K</mml:mi>
                    </mml:munderover>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mo stretchy="true">(</mml:mo>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>O</mml:mi>
                              <mml:mrow>
                                <mml:mi>k</mml:mi>
                                <mml:mi>i</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>E</mml:mi>
                              <mml:mrow>
                                <mml:mi>k</mml:mi>
                                <mml:mi>i</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mfrac>
                        <mml:mo stretchy="true">)</mml:mo>
                      </mml:mrow>
                      <mml:mi>θ</mml:mi>
                    </mml:msup>
                    <mml:mtext>exp</mml:mtext>
                    <mml:mrow>
                      <mml:mo stretchy="true">(</mml:mo>
                      <mml:mrow>
                        <mml:mo>−</mml:mo>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>−</mml:mo>
                            <mml:msubsup>
                              <mml:mi>Y</mml:mi>
                              <mml:mi>k</mml:mi>
                              <mml:mi>T</mml:mi>
                            </mml:msubsup>
                            <mml:msub>
                              <mml:mi>Z</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:msub>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                          <mml:mi>σ</mml:mi>
                        </mml:mfrac>
                      </mml:mrow>
                      <mml:mo stretchy="true">)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
            </mml:math>
          </disp-formula>
          <p id="P58">Finally, we substitute <inline-formula><mml:math display="inline" id="M39" overflow="scroll"><mml:mrow><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mmultiscripts><mml:mo stretchy="false">∕</mml:mo><mml:mi>σ</mml:mi><mml:none/><mml:mprescripts/><mml:none/><mml:mi>λ</mml:mi></mml:mmultiscripts><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to remove the dependency of R<sub>ki</sub> on the dual parameter λ.</p>
          <disp-formula id="FD28">
            <label>(8)</label>
            <mml:math display="block" id="M40" overflow="scroll">
              <mml:mrow>
                <mml:msub>
                  <mml:mi>R</mml:mi>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mo stretchy="true">(</mml:mo>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>O</mml:mi>
                              <mml:mrow>
                                <mml:mi>k</mml:mi>
                                <mml:mi>i</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>E</mml:mi>
                              <mml:mrow>
                                <mml:mi>k</mml:mi>
                                <mml:mi>i</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mfrac>
                        <mml:mo stretchy="true">)</mml:mo>
                      </mml:mrow>
                      <mml:mn>2</mml:mn>
                    </mml:msup>
                    <mml:mtext>exp</mml:mtext>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mo>−</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:msubsup>
                          <mml:mi>Y</mml:mi>
                          <mml:mi>k</mml:mi>
                          <mml:mi>T</mml:mi>
                        </mml:msubsup>
                        <mml:msub>
                          <mml:mi>Z</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mi>σ</mml:mi>
                    </mml:mfrac>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:munderover>
                      <mml:mo>∑</mml:mo>
                      <mml:mrow>
                        <mml:mover accent="true">
                          <mml:mi>k</mml:mi>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                        <mml:mo>=</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mi>K</mml:mi>
                    </mml:munderover>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mo stretchy="true">(</mml:mo>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>O</mml:mi>
                              <mml:mrow>
                                <mml:mover accent="true">
                                  <mml:mi>k</mml:mi>
                                  <mml:mo>^</mml:mo>
                                </mml:mover>
                                <mml:mi>i</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>E</mml:mi>
                              <mml:mrow>
                                <mml:mover accent="true">
                                  <mml:mi>k</mml:mi>
                                  <mml:mo>^</mml:mo>
                                </mml:mover>
                                <mml:mi>i</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mfrac>
                        <mml:mo stretchy="true">)</mml:mo>
                      </mml:mrow>
                      <mml:mn>2</mml:mn>
                    </mml:msup>
                    <mml:mtext>exp</mml:mtext>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mo>−</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:msubsup>
                          <mml:mi>Y</mml:mi>
                          <mml:mover accent="true">
                            <mml:mi>k</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                          <mml:mi>T</mml:mi>
                        </mml:msubsup>
                        <mml:msub>
                          <mml:mi>Z</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mi>σ</mml:mi>
                    </mml:mfrac>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
            </mml:math>
          </disp-formula>
          <p id="P59">The denominator term above makes sure that R<sub>i</sub> sums to one. In practice (alg 2), we compute the numerator and divide by the sum.</p>
        </sec>
        <sec id="S22">
          <label>2.4.2</label>
          <title>Centroid Estimation <italic>Y</italic></title>
          <p id="P60">Our clustering algorithm uses cosine distance instead of Euclidean distance. In the context of kmeans clustering, this approach was pioneered by Dhillon et al<sup><xref rid="R37" ref-type="bibr">37</xref></sup>. We adopt their centroid estimation procedure for our algorithm. Instead of just computing the mean position of all cells that belong in cluster k, this approach then L<sub>2</sub> normalizes each centroid vector to make it unit length. Note that normalizing the sum over cells is equivalent to normalizing the mean of the cells. In the soft clustering case, this summation is an expected value of the cell positions, under the distribution defined by R. That is, re-normalizing R<sub>.k</sub> for cluster k gives the probability of each cell belonging to cluster k. Again, this re-normalization is a scalar factor that is irrelevant once we L<sub>2</sub> normalize the centroids. Thus, the unnormalized expectation of centroid position for cluster k would be <inline-formula><mml:math display="inline" id="M41" overflow="scroll"><mml:mrow><mml:mstyle mathvariant="normal"><mml:msub><mml:mi>Y</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mstyle><mml:mo>=</mml:mo><mml:msub><mml:mi mathvariant="double-struck">E</mml:mi><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mo>.</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mi mathvariant="normal">Z</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi mathvariant="normal">Σ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mstyle mathvariant="normal"><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mstyle><mml:mstyle mathvariant="normal"><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mstyle></mml:mrow></mml:math></inline-formula>. In vector form, for all centroids, this is Y=ZR<sup>T</sup>. The final position of the cluster centroids is given by this summation followed by L<sub>2</sub> normalization of each centroid. This procedure is implemented in <xref rid="T2" ref-type="table">algorithm 2</xref> in the section {<italic>Compute Cluster Centroids</italic>}.</p>
        </sec>
      </sec>
      <sec id="S23">
        <label>2.5</label>
        <title>Algorithm</title>
        <table-wrap id="T2" position="anchor" orientation="portrait">
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th align="left" valign="middle" rowspan="1" colspan="1"><bold>Algorithm 2</bold> Maximum Diversity Clustering</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">
                  <disp-formula id="FD45">
                    <mml:math display="block" id="M42" overflow="scroll">
                      <mml:mtable>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mi mathvariant="bold">function</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mtext>CLUSTER</mml:mtext>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mover accent="true">
                                <mml:mi>Z</mml:mi>
                                <mml:mo>^</mml:mo>
                              </mml:mover>
                              <mml:mo>,</mml:mo>
                              <mml:mi>ϕ</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mo stretchy="false">{</mml:mo>
                              <mml:mstyle mathvariant="italic">
                                <mml:mi>Initialize</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>Cluster</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>Centroids</mml:mi>
                              </mml:mstyle>
                              <mml:mo stretchy="false">}</mml:mo>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi>Y</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mi mathvariant="italic">kmeans</mml:mi>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mover accent="true">
                                <mml:mi>Z</mml:mi>
                                <mml:mo>^</mml:mo>
                              </mml:mover>
                              <mml:mo>,</mml:mo>
                              <mml:mi>K</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi mathvariant="bold">for</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mi>i</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mn>1</mml:mn>
                              <mml:mi>…</mml:mi>
                              <mml:mi>N</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mi mathvariant="bold">do</mml:mi>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="5em"/>
                              <mml:mi>▷</mml:mi>
                              <mml:msub>
                                <mml:mi>L</mml:mi>
                                <mml:mn>2</mml:mn>
                              </mml:msub>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mtext>Normalization</mml:mtext>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:msub>
                                <mml:mi>Y</mml:mi>
                                <mml:mrow>
                                  <mml:mo>⋅</mml:mo>
                                  <mml:mo>,</mml:mo>
                                  <mml:mi>i</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo>←</mml:mo>
                              <mml:msub>
                                <mml:mi>Y</mml:mi>
                                <mml:mrow>
                                  <mml:mo>⋅</mml:mo>
                                  <mml:mo>,</mml:mo>
                                  <mml:mi>i</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo stretchy="false">∕</mml:mo>
                              <mml:mo stretchy="false">‖</mml:mo>
                              <mml:msub>
                                <mml:mi>Y</mml:mi>
                                <mml:mrow>
                                  <mml:mo>⋅</mml:mo>
                                  <mml:mo>,</mml:mo>
                                  <mml:mi>i</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:msub>
                                <mml:mo stretchy="false">‖</mml:mo>
                                <mml:mn>2</mml:mn>
                              </mml:msub>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:msub>
                                <mml:mover accent="true">
                                  <mml:mi>Z</mml:mi>
                                  <mml:mo>^</mml:mo>
                                </mml:mover>
                                <mml:mrow>
                                  <mml:mo>⋅</mml:mo>
                                  <mml:mo>,</mml:mo>
                                  <mml:mi>i</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo>←</mml:mo>
                              <mml:msub>
                                <mml:mover accent="true">
                                  <mml:mi>Z</mml:mi>
                                  <mml:mo>^</mml:mo>
                                </mml:mover>
                                <mml:mrow>
                                  <mml:mo>⋅</mml:mo>
                                  <mml:mo>,</mml:mo>
                                  <mml:mi>i</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo stretchy="false">∕</mml:mo>
                              <mml:mo stretchy="false">‖</mml:mo>
                              <mml:msub>
                                <mml:mover accent="true">
                                  <mml:mi>Z</mml:mi>
                                  <mml:mo>^</mml:mo>
                                </mml:mover>
                                <mml:mrow>
                                  <mml:mo>⋅</mml:mo>
                                  <mml:mo>,</mml:mo>
                                  <mml:mi>i</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:msub>
                                <mml:mo stretchy="false">‖</mml:mo>
                                <mml:mn>2</mml:mn>
                              </mml:msub>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi>E</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mi>R</mml:mi>
                              <mml:mstyle mathvariant="bold">
                                <mml:mn>1</mml:mn>
                              </mml:mstyle>
                              <mml:msubsup>
                                <mml:mi mathvariant="italic">Pr</mml:mi>
                                <mml:mi>b</mml:mi>
                                <mml:mi>T</mml:mi>
                              </mml:msubsup>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi>O</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mi>R</mml:mi>
                              <mml:msup>
                                <mml:mi>ϕ</mml:mi>
                                <mml:mi>T</mml:mi>
                              </mml:msup>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi mathvariant="bold">repeat</mml:mi>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mstyle mathvariant="bold">
                                <mml:mi>for</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>all</mml:mi>
                              </mml:mstyle>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mtext>Update Blocks</mml:mtext>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mi mathvariant="bold">do</mml:mi>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi mathvariant="italic">in</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mtext>cells to update in block</mml:mtext>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mo stretchy="false">{</mml:mo>
                              <mml:mstyle mathvariant="italic">
                                <mml:mi>Compute</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>O</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>and</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>E</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>on</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>left</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>out</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>data</mml:mi>
                                <mml:mo stretchy="false">}</mml:mo>
                              </mml:mstyle>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi>E</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mi>E</mml:mi>
                              <mml:mo>−</mml:mo>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mstyle mathvariant="bold">
                                <mml:mn>1</mml:mn>
                              </mml:mstyle>
                              <mml:msubsup>
                                <mml:mi mathvariant="italic">Pr</mml:mi>
                                <mml:mi>b</mml:mi>
                                <mml:mi>T</mml:mi>
                              </mml:msubsup>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi>O</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mi>O</mml:mi>
                              <mml:mo>−</mml:mo>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:msubsup>
                                <mml:mi>ϕ</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                                <mml:mi>T</mml:mi>
                              </mml:msubsup>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow/>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mo stretchy="false">{</mml:mo>
                              <mml:mstyle mathvariant="italic">
                                <mml:mi>Update</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>and</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>Normalize</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>R</mml:mi>
                                <mml:mo stretchy="false">}</mml:mo>
                              </mml:mstyle>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mi mathvariant="italic">in</mml:mi>
                              </mml:msub>
                              <mml:mo>←</mml:mo>
                              <mml:mtext>exp</mml:mtext>
                              <mml:mrow>
                                <mml:mo stretchy="true">(</mml:mo>
                                <mml:mrow>
                                  <mml:mo>−</mml:mo>
                                  <mml:mfrac>
                                    <mml:mrow>
                                      <mml:mn>2</mml:mn>
                                      <mml:mo stretchy="false">(</mml:mo>
                                      <mml:mn>1</mml:mn>
                                      <mml:mo>−</mml:mo>
                                      <mml:msup>
                                        <mml:mi>Y</mml:mi>
                                        <mml:mi>T</mml:mi>
                                      </mml:msup>
                                      <mml:msub>
                                        <mml:mover accent="true">
                                          <mml:mi>Z</mml:mi>
                                          <mml:mo>^</mml:mo>
                                        </mml:mover>
                                        <mml:mrow>
                                          <mml:mi>i</mml:mi>
                                          <mml:mi>n</mml:mi>
                                        </mml:mrow>
                                      </mml:msub>
                                      <mml:mo stretchy="false">)</mml:mo>
                                    </mml:mrow>
                                    <mml:mi>σ</mml:mi>
                                  </mml:mfrac>
                                </mml:mrow>
                                <mml:mo stretchy="true">)</mml:mo>
                              </mml:mrow>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi mathvariant="normal">Ω</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi>E</mml:mi>
                              <mml:mo>+</mml:mo>
                              <mml:mn>1</mml:mn>
                              <mml:mo stretchy="false">∕</mml:mo>
                              <mml:mi>O</mml:mi>
                              <mml:mo>+</mml:mo>
                              <mml:mn>1</mml:mn>
                              <mml:msup>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mi>θ</mml:mi>
                              </mml:msup>
                              <mml:msub>
                                <mml:mi>ϕ</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo>←</mml:mo>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo>∘</mml:mo>
                              <mml:mi mathvariant="normal">Ω</mml:mi>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo>←</mml:mo>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo>⋅</mml:mo>
                              <mml:mi mathvariant="italic">diag</mml:mi>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:msup>
                                <mml:mstyle mathvariant="bold">
                                  <mml:mn>1</mml:mn>
                                </mml:mstyle>
                                <mml:mi>T</mml:mi>
                              </mml:msup>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:msup>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mrow>
                                  <mml:mo>−</mml:mo>
                                  <mml:mn>1</mml:mn>
                                </mml:mrow>
                              </mml:msup>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi>▷</mml:mi>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mi>i</mml:mi>
                              </mml:msub>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mtext>sum to one</mml:mtext>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow/>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mo stretchy="false">{</mml:mo>
                              <mml:mstyle mathvariant="italic">
                                <mml:mi>Compute</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>O</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>and</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>E</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>with</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>full</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>data</mml:mi>
                                <mml:mo stretchy="false">}</mml:mo>
                              </mml:mstyle>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi>E</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mi>E</mml:mi>
                              <mml:mo>+</mml:mo>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mstyle mathvariant="bold">
                                <mml:mn>1</mml:mn>
                              </mml:mstyle>
                              <mml:msubsup>
                                <mml:mi mathvariant="italic">Pr</mml:mi>
                                <mml:mi>b</mml:mi>
                                <mml:mi>T</mml:mi>
                              </mml:msubsup>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi>O</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mi>O</mml:mi>
                              <mml:mo>+</mml:mo>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:msubsup>
                                <mml:mi>ϕ</mml:mi>
                                <mml:mrow>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>n</mml:mi>
                                </mml:mrow>
                                <mml:mi>T</mml:mi>
                              </mml:msubsup>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow/>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mo stretchy="false">{</mml:mo>
                              <mml:mstyle mathvariant="italic">
                                <mml:mi>Compute</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>Cluster</mml:mi>
                                <mml:mspace width="thinmathspace"/>
                                <mml:mi>Centroids</mml:mi>
                              </mml:mstyle>
                              <mml:mo stretchy="false">}</mml:mo>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mi>Y</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mi>Z</mml:mi>
                              <mml:msup>
                                <mml:mi>R</mml:mi>
                                <mml:mi>T</mml:mi>
                              </mml:msup>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mi mathvariant="bold">for</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mi>i</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mn>1</mml:mn>
                              <mml:mi>…</mml:mi>
                              <mml:mi>N</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mi mathvariant="bold">do</mml:mi>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="4em"/>
                              <mml:mi>▷</mml:mi>
                              <mml:msub>
                                <mml:mi>L</mml:mi>
                                <mml:mn>2</mml:mn>
                              </mml:msub>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mtext>Normalization</mml:mtext>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:msub>
                                <mml:mi>Y</mml:mi>
                                <mml:mrow>
                                  <mml:mo>⋅</mml:mo>
                                  <mml:mo>,</mml:mo>
                                  <mml:mi>i</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo>←</mml:mo>
                              <mml:msub>
                                <mml:mi>Y</mml:mi>
                                <mml:mrow>
                                  <mml:mo>⋅</mml:mo>
                                  <mml:mo>,</mml:mo>
                                  <mml:mi>i</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo stretchy="false">∕</mml:mo>
                              <mml:mo stretchy="false">‖</mml:mo>
                              <mml:msub>
                                <mml:mi>Y</mml:mi>
                                <mml:mrow>
                                  <mml:mo>⋅</mml:mo>
                                  <mml:mo>,</mml:mo>
                                  <mml:mi>i</mml:mi>
                                </mml:mrow>
                              </mml:msub>
                              <mml:msub>
                                <mml:mo stretchy="false">‖</mml:mo>
                                <mml:mn>2</mml:mn>
                              </mml:msub>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi mathvariant="bold">until</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mtext>convergence</mml:mtext>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mi mathvariant="bold">return</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mi>R</mml:mi>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                      </mml:mtable>
                    </mml:math>
                  </disp-formula>
                </td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
      <sec id="S24">
        <label>2.6</label>
        <title>Implementation Details</title>
        <p id="P61">The update steps of R and Y derived above form the core of Maximum Diversity Clustering, outlined as <xref rid="T2" ref-type="table">algorithm 2</xref>. This section explains the other implementation details of this pseudocode. Again, for simplicity, we discuss details related to diversity penalty terms θ, ϕ, O, and E for each single batch variable independently.</p>
        <sec id="S25">
          <label>2.6.1</label>
          <title>Block Updates of <italic>R</italic></title>
          <p id="P62">Unlike in regular kmeans, the optimization procedure above for R cannot be faithfully parallelized, as the values of O and E change with R. The exact solution therefore depends an online procedure. For speed, we can coarse grain this procedure and update R in small blocks (e.g. 5% of the data). Meanwhile, O and E are computed on the held out data. In practice, this approach succeeds in minimizing the objective for sufficiently small block size. In the algorithm, these blocks are included as the Update Blocks in the for loop.</p>
        </sec>
        <sec id="S26">
          <label>2.6.2</label>
          <title>Centroid Initialization</title>
          <p id="P63">We initialize cluster centroids using regular kmeans clustering, implemented in the base R kmeans function. We use 10 random restarts and keep the best one. We then L<sub>2</sub> normalize the centroids to prepare them for spherical kmeans clustering in <xref rid="T2" ref-type="table">Algorithm 2</xref>, Maximum Diversity Clustering.</p>
        </sec>
        <sec id="S27">
          <label>2.6.3</label>
          <title>Regularization for Smoother Penalty</title>
          <p id="P64">The diversity penalty term (E<sub>bk</sub>/O<sub>bk</sub>)<sup>θ</sup> can tend towards infinity if there are no cells from batch b assigned to cluster k. This extreme penalty can erroneously force cells into an inappropriate cluster. To protect against this, we add 1 to O and E to ensure that the fraction is stable: <inline-formula><mml:math display="inline" id="M43" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msub><mml:mi>O</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>θ</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula></p>
        </sec>
        <sec id="S28">
          <label>2.6.4</label>
          <title>θ Discounting</title>
          <p id="P65">The diversity penalty, weighted by θ enforces an even mixing of cells from a batch among all clusters. This assumption is more likely to break for a batch with few cells. The smaller the batch, the more likely it is, through a sampling argument, that some cell types are not represented in the batch. Spreading such a batch across all clusters would result in erroneous clustering. To prevent such a situation, we allot each batch its own θ<sub>b</sub> term, scaled to the number of cells in the batch.</p>
          <disp-formula id="FD29">
            <mml:math display="block" id="M44" overflow="scroll">
              <mml:mrow>
                <mml:msub>
                  <mml:mi>θ</mml:mi>
                  <mml:mi>b</mml:mi>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mi>θ</mml:mi>
                  <mml:mi mathvariant="italic">max</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>−</mml:mo>
                <mml:mtext>exp</mml:mtext>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mo>−</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>N</mml:mi>
                      <mml:mi>b</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>K</mml:mi>
                    <mml:mi>τ</mml:mi>
                  </mml:mrow>
                </mml:mfrac>
                <mml:msup>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mn>2</mml:mn>
                </mml:msup>
                <mml:mo stretchy="false">]</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
          <p id="P66">Above, θ<sub>max</sub> is the non-discounted θ value, for a large enough batch. The multiplicative factor <inline-formula><mml:math display="inline" id="M45" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mmultiscripts><mml:mo stretchy="false">∕</mml:mo><mml:mrow><mml:mi>K</mml:mi><mml:mi>τ</mml:mi></mml:mrow><mml:none/><mml:mprescripts/><mml:none/><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mmultiscripts><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> ranges from 0 to 1. This factor scales exponentially for small values of batch size N<sub>b</sub> and plateaus for sufficiently large N<sub>b</sub>. The hyperparameter τ can be interpreted as the minimum number of cells that should be assigned to each cluster from a single batch. By default, we use values between τ=5 and τ=20.</p>
        </sec>
        <sec id="S29">
          <label>2.6.5</label>
          <title>K, the number of clusters</title>
          <p id="P67">The number of clusters K used in Harmony soft clustering should be set to a value that reflects the size and complexity of the dataset. Too few clusters will not capture the number of biologically distinct cell types and states. Too many clusters will give too much weight to batch-specific outliers and prevent effective integration. As a heuristic, we assume that the datasets have at most 100 distinct cell types and that each cluster should have at least 30 cells. We set the default number of clusters, K, to lie between these two extremes, for N cells.</p>
          <disp-formula id="FD30">
            <mml:math display="block" id="M46" overflow="scroll">
              <mml:mrow>
                <mml:mi>K</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mi>min</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>100</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mfrac>
                  <mml:mi>N</mml:mi>
                  <mml:mn>30</mml:mn>
                </mml:mfrac>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </sec>
      </sec>
    </sec>
    <sec id="S30">
      <label>3</label>
      <title>Linear Mixture Model Correction</title>
      <p id="P68">In this section, we refer to all effects to be integrated out of the original embedding as batch effects. This does not imply that these effects are purely technical. This terminology is only meant for convenience.</p>
      <sec id="S31">
        <label>3.1</label>
        <title>Mixture of Experts model</title>
        <p id="P69">Once we define batch-diverse clusters, we would like to remove batch-specific variation from each cluster. We achieve this with a variation on the original Mixture of Experts (MoE) model from Jordan and Jacobs<sup><xref rid="R38" ref-type="bibr">38</xref></sup>. In the context of Harmony, each cell is probabilistically assigned to a small set of experts. This assignment was computed previously in the clustering step. Conditioned on a cluster/expert, MoE assumes a linear relationship between the response and independent variables. Thus, we condition on cluster/expert k and define a Gaussian probability distribution for the response variables.</p>
        <disp-formula id="FD31">
          <label>(9)</label>
          <mml:math display="block" id="M47" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>Z</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">∣</mml:mo>
              <mml:mo stretchy="false">{</mml:mo>
              <mml:msubsup>
                <mml:mi>ϕ</mml:mi>
                <mml:mi>i</mml:mi>
                <mml:mo>∗</mml:mo>
              </mml:msubsup>
              <mml:mo>,</mml:mo>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mi>k</mml:mi>
              <mml:mo stretchy="false">}</mml:mo>
              <mml:mi>~</mml:mi>
              <mml:mi mathvariant="script">N</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:msub>
                <mml:mi>Z</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">∣</mml:mo>
              <mml:msubsup>
                <mml:mi>W</mml:mi>
                <mml:mi>k</mml:mi>
                <mml:mi>T</mml:mi>
              </mml:msubsup>
              <mml:msubsup>
                <mml:mi>ϕ</mml:mi>
                <mml:mi>i</mml:mi>
                <mml:mo>∗</mml:mo>
              </mml:msubsup>
              <mml:mo>,</mml:mo>
              <mml:msubsup>
                <mml:mi>σ</mml:mi>
                <mml:mi>k</mml:mi>
                <mml:mn>2</mml:mn>
              </mml:msubsup>
              <mml:mi>I</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p id="P70">Here, the mean is a function of the independent variables (μ<sub>k</sub>=W<sub>k</sub><sup>T</sup> ϕ*<sub>i</sub>), while the covariance is not (σ<sub>k</sub><sup>2</sup>I). Note that the design matrix above (ϕ*) is not the same as the one used in the clustering step (ϕ). We augment the original design matrix ϕ to include an intercept term: ϕ* = 1 ∥ ϕ. These intercept terms capture batch-independent (i.e. cell type) variation in each cluster/expert. We can also achieve more complex behavior, like reference mapping (<xref rid="S33" ref-type="sec">section 3.3</xref>) by modifying ϕ*.</p>
        <disp-formula id="FD32">
          <mml:math display="block" id="M48" overflow="scroll">
            <mml:mrow>
              <mml:msup>
                <mml:mi>ϕ</mml:mi>
                <mml:mo>∗</mml:mo>
              </mml:msup>
              <mml:mo>=</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo stretchy="false">‖</mml:mo>
              <mml:mi>ϕ</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mrow>
                <mml:mo stretchy="true">[</mml:mo>
                <mml:mtable>
                  <mml:mtr>
                    <mml:mtd columnalign="left">
                      <mml:mn>1</mml:mn>
                    </mml:mtd>
                    <mml:mtd columnalign="center">
                      <mml:mo>⋯</mml:mo>
                    </mml:mtd>
                    <mml:mtd columnalign="center">
                      <mml:mn>1</mml:mn>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd columnalign="left">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>ϕ</mml:mi>
                          <mml:mn>11</mml:mn>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mtd>
                    <mml:mtd columnalign="center">
                      <mml:mo>⋯</mml:mo>
                    </mml:mtd>
                    <mml:mtd columnalign="center">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>ϕ</mml:mi>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                            <mml:mi>N</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd columnalign="left">
                      <mml:mrow>
                        <mml:mspace width="1em"/>
                        <mml:mo>⋮</mml:mo>
                      </mml:mrow>
                    </mml:mtd>
                    <mml:mtd columnalign="center">
                      <mml:mo>⋱</mml:mo>
                    </mml:mtd>
                    <mml:mtd columnalign="center">
                      <mml:mo>⋮</mml:mo>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd columnalign="left">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>ϕ</mml:mi>
                          <mml:mrow>
                            <mml:mi>B</mml:mi>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mtd>
                    <mml:mtd columnalign="center">
                      <mml:mo>⋯</mml:mo>
                    </mml:mtd>
                    <mml:mtd columnalign="center">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>ϕ</mml:mi>
                          <mml:mrow>
                            <mml:mi>B</mml:mi>
                            <mml:mi>N</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
                <mml:mo stretchy="true">]</mml:mo>
              </mml:mrow>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p id="P71">With this generative formulation, we can solve for the parameters (W<sub>k</sub>) of the linear model for each cluster/expert independently.</p>
        <disp-formula id="FD33">
          <label>(10)</label>
          <mml:math display="block" id="M49" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>W</mml:mi>
                <mml:mi>k</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:msup>
                <mml:mi>ϕ</mml:mi>
                <mml:mo>∗</mml:mo>
              </mml:msup>
              <mml:mi mathvariant="italic">diag</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mi>k</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:msup>
                <mml:mi>ϕ</mml:mi>
                <mml:mrow>
                  <mml:mo>∗</mml:mo>
                  <mml:mi>T</mml:mi>
                </mml:mrow>
              </mml:msup>
              <mml:msup>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mrow>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:msup>
              <mml:msup>
                <mml:mi>ϕ</mml:mi>
                <mml:mo>∗</mml:mo>
              </mml:msup>
              <mml:mspace width="thinmathspace"/>
              <mml:mi mathvariant="italic">diag</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mi>k</mml:mi>
              </mml:msub>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:msup>
                <mml:mi>Z</mml:mi>
                <mml:mi>T</mml:mi>
              </mml:msup>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p id="P72">Above, diag(R<sub>k</sub>) is the diagonal matrix of cluster membership terms for cluster k. Z is the matrix of original PCA embeddings
<disp-formula id="FD34"><mml:math display="block" id="M50" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">diag</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="center"><mml:mo>⋯</mml:mo></mml:mtd><mml:mtd columnalign="center"><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mo>⋮</mml:mo></mml:mtd><mml:mtd columnalign="center"><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd columnalign="center"><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="center"><mml:mo>⋯</mml:mo></mml:mtd><mml:mtd columnalign="center"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true">]</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        <p id="P73">Each column in W<sub>k</sub> corresponds to a PC dimension, from PC<sub>1</sub> to PC<sub>d</sub>. The first row of W<sub>k</sub> corresponds to batch-independent intercept terms. The subsequent rows (1 through B) correspond to one-hot encoded batch assignments from the original design matrix ϕ.</p>
        <p id="P74">To get the cell specific correction values, we take the expectation of W<sub>k</sub> wrt the cluster assignment probability distribution R. In particular, each cell is modeled by a batch independent intercept, represented in the first row of W<sub>k</sub> (W<sub>k[0,.]</sub>), and its batch dependent terms represented by the remaining rows: W<sub>k[1:B,.]</sub>.</p>
        <disp-formula id="FD35">
          <label>(11)</label>
          <mml:math display="block" id="M51" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>Z</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mi>k</mml:mi>
              </mml:munder>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:msub>
                <mml:mi>W</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mn>0</mml:mn>
                  <mml:mo>,</mml:mo>
                  <mml:mo>⋅</mml:mo>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
              </mml:msub>
              <mml:mo>+</mml:mo>
              <mml:msubsup>
                <mml:mi>W</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>:</mml:mo>
                  <mml:mi>B</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mo>⋅</mml:mo>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:msubsup>
              <mml:msubsup>
                <mml:mi>ϕ</mml:mi>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>:</mml:mo>
                  <mml:mi>B</mml:mi>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
                <mml:mo>∗</mml:mo>
              </mml:msubsup>
              <mml:mo stretchy="false">]</mml:mo>
              <mml:mo>+</mml:mo>
              <mml:msub>
                <mml:mi>ϵ</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p id="P75">We split W<sub>k</sub> into two parts because we want to retain the intercept terms and remove the batch-dependent terms. To get the corrected embeddings (<inline-formula><mml:math display="inline" id="M52" overflow="scroll"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>), we subtract the batch specific term (Σ<sub>k</sub> W<sup>T</sup><sub>k[1:B,.]</sub>ϕ<sub>i</sub>) from the original embedding (Z<sub>i</sub>).</p>
        <disp-formula id="FD36">
          <label>(12)</label>
          <mml:math display="block" id="M53" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mover accent="true">
                  <mml:mi>Z</mml:mi>
                  <mml:mo>^</mml:mo>
                </mml:mover>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:msub>
                <mml:mi>Z</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo>−</mml:mo>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mi>k</mml:mi>
              </mml:munder>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:msubsup>
                <mml:mi>W</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>:</mml:mo>
                  <mml:mi>B</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mo>⋅</mml:mo>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:msubsup>
              <mml:msubsup>
                <mml:mi>ϕ</mml:mi>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>:</mml:mo>
                  <mml:mi>B</mml:mi>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
                <mml:mo>∗</mml:mo>
              </mml:msubsup>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p id="P76">What remains is the cell type specific intercept W<sub>k[0,.]</sub> and the cell specific residual ϵ<sub>i</sub>.</p>
        <disp-formula id="FD37">
          <label>(13)</label>
          <mml:math display="block" id="M54" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mover accent="true">
                  <mml:mi>Z</mml:mi>
                  <mml:mo>^</mml:mo>
                </mml:mover>
                <mml:mi>i</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mi>k</mml:mi>
              </mml:munder>
              <mml:msub>
                <mml:mi>R</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:msub>
                <mml:mi>W</mml:mi>
                <mml:mrow>
                  <mml:mi>k</mml:mi>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mn>0</mml:mn>
                  <mml:mo>,</mml:mo>
                  <mml:mo>⋅</mml:mo>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
              </mml:msub>
              <mml:mo>+</mml:mo>
              <mml:msub>
                <mml:mi>ϵ</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:msub>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p id="P77">Unfortunately, for the design matrix ϕ*, the formulation in <xref rid="FD37" ref-type="disp-formula">equation 13</xref> does not have a solution. This is because ϕ* is not full rank and thus ϕ* diag(R<sub>k</sub>) ϕ<sup>*T</sup> is not invertible. This singularity arises from the fact that the sum of a one hot encoded categorical variable is equal to the intercept. To address this colinearity, we penalize non-intercept terms in W<sub>k</sub> with an L<sub>2</sub> norm, akin to ridge regression. This shrinks the W<sub>k</sub> terms to 0. Just like in ridge regression, instead of inverting ϕ* diag(R<sub>k</sub>) ϕ*<sup>T</sup>, we invert ϕ* diag(R<sub>k</sub>) ϕ*<sup>T</sup>+λI, which is not singular. The solution for W<sub>k</sub> now becomes:
<disp-formula id="FD38"><label>(14)</label><mml:math display="block" id="M55" overflow="scroll"><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>∗</mml:mo></mml:msup><mml:mspace width="thinmathspace"/><mml:mi mathvariant="italic">diag</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo>∗</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mi>λ</mml:mi><mml:mi>I</mml:mi><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mi>ϕ</mml:mi><mml:mo>∗</mml:mo></mml:msup><mml:mspace width="thinmathspace"/><mml:mi mathvariant="italic">diag</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mi>Z</mml:mi><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:math></disp-formula>
λ is the ridge penalty hyperparameter. Larger values of λ will shrink W<sub>k</sub> more towards 0. We adopt the strategy to set λ<sub>0</sub>=0, thus not penalizing the batch-independent intercept, and ∀<sub><italic>b</italic>∈[1:<italic>B</italic>]</sub><italic>λ<sub>b</sub></italic> to be small enough to make the solution tractable. In practice, we set ∀<sub><italic>b</italic>∈[1:<italic>B</italic>]</sub><italic>λ<sub>b</sub></italic>. These correction steps are summarized in <xref rid="T3" ref-type="table">algorithm 3</xref>.</p>
      </sec>
      <sec id="S32">
        <label>3.2</label>
        <title>Algorithm</title>
        <table-wrap id="T3" position="anchor" orientation="portrait">
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th align="left" valign="top" rowspan="1" colspan="1"><bold>Algorithm 3</bold> Mixture of Experts Correct</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">
                  <disp-formula id="FD46">
                    <mml:math display="block" id="M56" overflow="scroll">
                      <mml:mtable>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mi mathvariant="bold">function</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mtext>CORRECT</mml:mtext>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi>Z</mml:mi>
                              <mml:mo>,</mml:mo>
                              <mml:mi>R</mml:mi>
                              <mml:mo>,</mml:mo>
                              <mml:mi>ϕ</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mover accent="true">
                                <mml:mi>Z</mml:mi>
                                <mml:mo>^</mml:mo>
                              </mml:mover>
                              <mml:mo>←</mml:mo>
                              <mml:mi>Z</mml:mi>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:msup>
                                <mml:mi>ϕ</mml:mi>
                                <mml:mo>∗</mml:mo>
                              </mml:msup>
                              <mml:mo>←</mml:mo>
                              <mml:mn>1</mml:mn>
                              <mml:mo stretchy="false">‖</mml:mo>
                              <mml:mi>ϕ</mml:mi>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mi mathvariant="bold">for</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mi>k</mml:mi>
                              <mml:mo>←</mml:mo>
                              <mml:mn>1</mml:mn>
                              <mml:mi>…</mml:mi>
                              <mml:mi>K</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mi mathvariant="bold">do</mml:mi>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:msub>
                                <mml:mi>W</mml:mi>
                                <mml:mi>k</mml:mi>
                              </mml:msub>
                              <mml:mo>=</mml:mo>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:msup>
                                <mml:mi>ϕ</mml:mi>
                                <mml:mo>∗</mml:mo>
                              </mml:msup>
                              <mml:mi mathvariant="italic">diag</mml:mi>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mi>k</mml:mi>
                              </mml:msub>
                              <mml:mo stretchy="false">)</mml:mo>
                              <mml:msup>
                                <mml:mi>ϕ</mml:mi>
                                <mml:mrow>
                                  <mml:mo>∗</mml:mo>
                                  <mml:mi>T</mml:mi>
                                </mml:mrow>
                              </mml:msup>
                              <mml:mo>+</mml:mo>
                              <mml:mi>λ</mml:mi>
                              <mml:mi>I</mml:mi>
                              <mml:msup>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mrow>
                                  <mml:mo>−</mml:mo>
                                  <mml:mn>1</mml:mn>
                                </mml:mrow>
                              </mml:msup>
                              <mml:msup>
                                <mml:mi>ϕ</mml:mi>
                                <mml:mo>∗</mml:mo>
                              </mml:msup>
                              <mml:mi mathvariant="italic">diag</mml:mi>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mi>k</mml:mi>
                              </mml:msub>
                              <mml:mo stretchy="false">)</mml:mo>
                              <mml:msup>
                                <mml:mi>Z</mml:mi>
                                <mml:mi>T</mml:mi>
                              </mml:msup>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:msub>
                                <mml:mi>W</mml:mi>
                                <mml:mrow>
                                  <mml:mi>k</mml:mi>
                                  <mml:mo stretchy="false">[</mml:mo>
                                  <mml:mn>0</mml:mn>
                                  <mml:mo>,</mml:mo>
                                  <mml:mo>⋅</mml:mo>
                                  <mml:mo stretchy="false">]</mml:mo>
                                </mml:mrow>
                              </mml:msub>
                              <mml:mo>←</mml:mo>
                              <mml:mn>0</mml:mn>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mover accent="true">
                                <mml:mi>Z</mml:mi>
                                <mml:mo>^</mml:mo>
                              </mml:mover>
                              <mml:mo>=</mml:mo>
                              <mml:mi>Z</mml:mi>
                              <mml:mo>−</mml:mo>
                              <mml:msubsup>
                                <mml:mi>W</mml:mi>
                                <mml:mi>k</mml:mi>
                                <mml:mi>T</mml:mi>
                              </mml:msubsup>
                              <mml:msup>
                                <mml:mi>ϕ</mml:mi>
                                <mml:mo>∗</mml:mo>
                              </mml:msup>
                              <mml:mi mathvariant="italic">diag</mml:mi>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:msub>
                                <mml:mi>R</mml:mi>
                                <mml:mi>k</mml:mi>
                              </mml:msub>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd columnalign="right">
                            <mml:mrow/>
                          </mml:mtd>
                          <mml:mtd columnalign="left">
                            <mml:mrow>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="1em"/>
                              <mml:mspace width="thickmathspace"/>
                              <mml:mi mathvariant="bold">return</mml:mi>
                              <mml:mspace width="thinmathspace"/>
                              <mml:mover accent="true">
                                <mml:mi>Z</mml:mi>
                                <mml:mo>^</mml:mo>
                              </mml:mover>
                            </mml:mrow>
                          </mml:mtd>
                        </mml:mtr>
                      </mml:mtable>
                    </mml:math>
                  </disp-formula>
                </td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
      <sec id="S33">
        <label>3.3</label>
        <title>Reference mapping</title>
        <p id="P79">In <xref rid="SD4" ref-type="supplementary-material">Supplementary Figure 13</xref>, we used Harmony to map 2 query datasets onto a reference dataset. We achieved this by modifying ϕ* so that batch terms for reference cells does not get modeled or corrected. For every cell i in a reference dataset, set ϕ<sub>i</sub>*=[1, 0, … 0]. This makes Harmony explain cell i in terms of an intercept and nothing else. Since intercept terms don't get removed, cell i never changes its embedding (i.e. <inline-formula><mml:math display="inline" id="M57" overflow="scroll"><mml:mrow><mml:mstyle mathvariant="normal"><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mstyle><mml:mo>=</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi mathvariant="normal">i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>).</p>
      </sec>
      <sec id="S34">
        <label>3.4</label>
        <title>Caveat</title>
        <p id="P80">This section assumes the modeled data are orthogonal and each normally distributed. This is not true for the L<sub>2</sub> normalized data used in spherical clustering. Regression in this space requires the estimation and interpolation of rotation matrices, a difficult problem. We instead perform batch correction in the unnormalized space. The corrected data <inline-formula><mml:math display="inline" id="M58" overflow="scroll"><mml:mover accent="true"><mml:mi>Z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> are then L<sub>2</sub>-normalized for the next iteration of clustering.</p>
      </sec>
    </sec>
    <sec id="S35">
      <label>4</label>
      <title>Performance and Benchmarking</title>
      <sec id="S36">
        <label>4.1</label>
        <title>LISI Metric</title>
        <p id="P81">Assessing the degree of mixing during batch correction and dataset integration is an open problem. Several groups have proposed methods to quantify the diversity of batches within local neighborhoods, defined by k nearest neighbor (KNN) graphs, of the embedded space. Buttner et al<sup><xref rid="R39" ref-type="bibr">39</xref></sup> provide a statistical test to evaluate the degree of mixing, while Azizi et al<sup><xref rid="R40" ref-type="bibr">40</xref></sup> report the entropy of these distributions. Our metric for local diversity is related to these approaches, in that we start with a KNN graph. However, our approach considers two problems that these do not.</p>
        <p id="P82">First, the metric should be more sensitive to local distances. For example, a neighborhood of 100 cells can be equally mixed among 4 batches. However, within the neighborhood, the cells may be clustered by batch. The second problem is one of interpretation. kBET provides a statistical test to assess the significance of mixing, but it is not clear whether all neighborhoods should be significantly mixed when the datasets have vastly different cell type proportions. Azizi et al<sup><xref rid="R40" ref-type="bibr">40</xref></sup> et al use entropy as a measure of diversity, but it is not clear how to interpret the number of bits required to encode a neighborhood distribution.</p>
        <p id="P83">Our diversity score, the Local Inverse Simpson's Index (LISI) addresses both points. To be sensitive to local diversity, we build Gaussian kernel based distributions of neighborhoods. This gives distance-based weights to cells in the neighborhood. The current implementation computes these local distributions using a fixed perplexity (default 30), which has been shown to be a smoother function than fixing the number of neighbors. We address the second issue of interpretation using the Inverse Simpson's Index (1/Σ<sub>b=1</sub><sup>B</sup>p(b)). The probabilities here refer to the batch probabilities in the local neighborhood distributions described above. This index is the expected number of cells needed to be sampled before two are drawn from the same batch. If the neighborhood consists of only one batch, then only one draw is needed. If it is an equal mix of two batches, two draws are required on average. Thus, this index reports the effective number of batches in a local neighborhood. Our diversity score, LISI, combines these two features: perplexity based neighborhood construction and the Inverse Simpson's Index. LISI assigns a diversity score to each cell. This score is the effective number of batches in that cell's neighborhood. Code to compute LISI is available as at <ext-link ext-link-type="uri" xlink:href="https://github.com/immunogenomics/LISI">https://github.com/immunogenomics/LISI</ext-link>. The major shortcoming of LISI is in situations with datasets with vastly different sizes. We demonstrate what happens in this situation in <xref rid="SD6" ref-type="supplementary-material">Supplementary Note 2</xref>.</p>
        <sec id="S37">
          <label>4.1.1</label>
          <title>Significance between embeddings</title>
          <p id="P84">In benchmarking against other algorithms, we compared the LISI scores of Harmony to LISI scores of embeddings from other algorithms. We did this with a standard bootstrap estimation framework: first, build an empirical distribution of Harmony LISI values for each cell; then count the frequency with which the observed benchmark LISI is more extreme than bootstrapped LISI values. During the resampling phase, we reran PCA, Harmony, and LISI for every bootstrap sample. For the p-value computation, we used a 2-tailed empirical approach, adding 1 to the observed counts to avoid p=0. This calculation is described in the equation below. Let <inline-formula><mml:math display="inline" id="M59" overflow="scroll"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mtext>LISI</mml:mtext><mml:mo stretchy="true">^</mml:mo></mml:mover><mml:mi mathvariant="normal">i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the observed LISI value for cell i for a benchmarking algorithm. Let LISI<sub>i</sub><sup>b</sup> to be LISI value for the b<sup>th</sup> bootstrap value for cell i. We compute p as:
<disp-formula id="FD39"><mml:math display="block" id="M60" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>B</mml:mi></mml:munderover><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mover accent="true"><mml:mrow><mml:mi>L</mml:mi><mml:mi>I</mml:mi><mml:mi>S</mml:mi><mml:mi>I</mml:mi></mml:mrow><mml:mo stretchy="true">^</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:msubsup><mml:mi mathvariant="italic">LISI</mml:mi><mml:mi>i</mml:mi><mml:mi>b</mml:mi></mml:msubsup></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>B</mml:mi></mml:munderover><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mover accent="true"><mml:mrow><mml:mi>L</mml:mi><mml:mi>I</mml:mi><mml:mi>S</mml:mi><mml:mi>I</mml:mi></mml:mrow><mml:mo stretchy="true">^</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:msubsup><mml:mi mathvariant="italic">LISI</mml:mi><mml:mi>i</mml:mi><mml:mi>b</mml:mi></mml:msubsup></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p>
        </sec>
      </sec>
      <sec id="S38">
        <label>4.2</label>
        <title>Time and Memory</title>
        <p id="P85">We performed execution time and maximum memory usage benchmarks on all analyses. All jobs were run on Linux servers and allotted 6 cores and 120GB of memory. The machines were equipped with Intel Xeon E5-2690 v3 processors. To evaluate execution time and maximal memory usage, we used the Linux time utility (/usr/bin/time on our systems) with the -v flag to record memory usage. Execution time was recorded from the{<italic>Elapsed time</italic>} field. Maximum memory usage was recorded from the {<italic>Maximum resident set size</italic>} field.</p>
      </sec>
      <sec id="S39">
        <label>4.3</label>
        <title>Cell type prediction accuracy</title>
        <p id="P86">In addition to cLISI, we measured the accuracy of an embedding with cell type prediction. Briefly, we predict each cell's type based on its neighboring cells and compute accuracy as the frequency of correct predictions. In detail, we compute the 30 nearest neighbors of a cell, based on cosine distance. We then weigh them with an RBF kernel with σ=0.1 width. Finally, we take the weighted sum over the neighbor's cell types and return the most likely cell type. Formally, for cell i, its 30 nearest cells NN(i), an embedding matrix Z, and cell type labels vector T, compute the most probable cell type label t:
<disp-formula id="FD40"><label>(15)</label><mml:math display="block" id="M61" overflow="scroll"><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mi>argmax</mml:mi><mml:mi>t</mml:mi></mml:munder><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>N</mml:mi><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mtext>exp</mml:mtext><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:mmultiscripts><mml:mo stretchy="false">∕</mml:mo><mml:mrow><mml:mo stretchy="true">∣</mml:mo><mml:mrow><mml:mo stretchy="false">∣</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">∣</mml:mo></mml:mrow><mml:mo stretchy="true">∣</mml:mo></mml:mrow><mml:none/><mml:mprescripts/><mml:none/><mml:mrow><mml:msub><mml:mi>Z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mmultiscripts><mml:mo>−</mml:mo><mml:mmultiscripts><mml:mo stretchy="false">∕</mml:mo><mml:mrow><mml:mo stretchy="true">∣</mml:mo><mml:mrow><mml:mo stretchy="false">∣</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">∣</mml:mo></mml:mrow><mml:mo stretchy="true">∣</mml:mo></mml:mrow><mml:none/><mml:mprescripts/><mml:none/><mml:mrow><mml:msub><mml:mi>Z</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mmultiscripts><mml:msup><mml:mo stretchy="false">‖</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>σ</mml:mi></mml:mfrac></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:msub><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula></p>
      </sec>
      <sec id="S40">
        <label>4.4</label>
        <title>Gene expression prediction</title>
        <p id="P87">We predicted gene expression in the 10X+MERFISH analysis using a similar approach to cell type prediction above. Instead of predicting cell type labels T, we predicted gene expression y<sub>g</sub>. We predict the expression y<sub>gi</sub> take a weighted average of the observed normalized gene expression values of cell i's nearest neighbors.</p>
        <disp-formula id="FD41">
          <label>(16)</label>
          <mml:math display="block" id="M62" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mi>y</mml:mi>
                <mml:mrow>
                  <mml:mi>g</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mi>argmax</mml:mi>
                <mml:mi>t</mml:mi>
              </mml:munder>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mi>N</mml:mi>
                  <mml:mi>N</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>i</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:munder>
              <mml:mtext>exp</mml:mtext>
              <mml:mrow>
                <mml:mo stretchy="true">(</mml:mo>
                <mml:mrow>
                  <mml:mo>−</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mo stretchy="false">‖</mml:mo>
                      <mml:mmultiscripts>
                        <mml:mo stretchy="false">∕</mml:mo>
                        <mml:mrow>
                          <mml:mo stretchy="true">∣</mml:mo>
                          <mml:mrow>
                            <mml:mo stretchy="false">∣</mml:mo>
                            <mml:msub>
                              <mml:mi>Z</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:msub>
                            <mml:mo stretchy="false">∣</mml:mo>
                          </mml:mrow>
                          <mml:mo stretchy="true">∣</mml:mo>
                        </mml:mrow>
                        <mml:none/>
                        <mml:mprescripts/>
                        <mml:none/>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>Z</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mmultiscripts>
                      <mml:mo>−</mml:mo>
                      <mml:mmultiscripts>
                        <mml:mo stretchy="false">∕</mml:mo>
                        <mml:mrow>
                          <mml:mo stretchy="true">∣</mml:mo>
                          <mml:mrow>
                            <mml:mo stretchy="false">∣</mml:mo>
                            <mml:msub>
                              <mml:mi>Z</mml:mi>
                              <mml:mi>j</mml:mi>
                            </mml:msub>
                            <mml:mo stretchy="false">∣</mml:mo>
                          </mml:mrow>
                          <mml:mo stretchy="true">∣</mml:mo>
                        </mml:mrow>
                        <mml:none/>
                        <mml:mprescripts/>
                        <mml:none/>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>Z</mml:mi>
                            <mml:mi>j</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mmultiscripts>
                      <mml:msup>
                        <mml:mo stretchy="false">‖</mml:mo>
                        <mml:mn>2</mml:mn>
                      </mml:msup>
                    </mml:mrow>
                    <mml:mi>σ</mml:mi>
                  </mml:mfrac>
                </mml:mrow>
                <mml:mo stretchy="true">)</mml:mo>
              </mml:mrow>
              <mml:mo>⋅</mml:mo>
              <mml:msub>
                <mml:mi>y</mml:mi>
                <mml:mrow>
                  <mml:mi>g</mml:mi>
                  <mml:mi>j</mml:mi>
                </mml:mrow>
              </mml:msub>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </sec>
      <sec id="S41">
        <label>4.5</label>
        <title>Five fold cross validation</title>
        <p id="P88">In the 10X+MERFISH analysis, we predicted gene expression of the 154 intersecting measured genes with a five fold cross validation framework. In this analysis, we removed a randomly sampled one fifth of the genes from both datasets before normalization. We then performed normalization, scaling, PCA, and Harmony integration from the remaining four fifths of the genes and predicted the expression of the original removed genes. We repeat this procedure for each of the 5 holdout genesets. We then repeat the entire procedure 10 times, selecting a new random partition in each iterations. We consider the mean of these 10 iterations as the predicted value of the gene. We calculated the pearson correlation between the predicted and measured expression of each gene.</p>
      </sec>
      <sec id="S42">
        <label>4.6</label>
        <title>Neuronal subtype correlation</title>
        <p id="P89">To calculate the correlations between the 10X predicted clusters and the MERFISH clusters, we first subsetted the predicted gene expression matrix to the 154 intersecting 10X/MERFISH genes; we then concatenated the predicted 10X neuronal subtypes to the predicted gene expression matrix and the known neuronal subtypes to the MERFISH dataset. In both the predicted gene expression matrix and the MERFISH dataset, we calculated the average expression of the predicted 10X neuronal subtypes and known neuronal subtypes respectively. Finally, we calculated the spearman correlation between the average expression of each predicted 10X inhibitory/excitatory subtype and known MERFISH inhibitory/excitatory subtypes.</p>
      </sec>
    </sec>
    <sec id="S43">
      <label>5</label>
      <title>Analysis Details</title>
      <sec id="S44">
        <label>5.1</label>
        <title>Preprocessing scRNAseq data.</title>
        <p id="P90">We downloaded raw read or UMI matrices for all datasets, from their respective sources. The one exception was the 3pV1 dataset from the PBMC analysis. These data were originally quantified with the hg19 reference, while the other two PBMC datasets were quantified with GRCh38. Thus, we downloaded the fastq files from the 10X website (<xref rid="SD8" ref-type="supplementary-material">Supplementary Table 8</xref>). We quantified gene expression counts using Cell Ranger<sup><xref rid="R11" ref-type="bibr">11</xref>,<xref rid="R41" ref-type="bibr">41</xref></sup> v2.1.0 with GRCh38. From the raw count matrices, we used a standard data normalization procedure, laid out below, for all analyses, unless otherwise specified. Except for the L<sub>2</sub> normalization and within-batch variable gene detection, this procedure follows the standard guidelines of the Seurat single cell analysis platform.</p>
        <p id="P91">We filtered cells with fewer than 500 genes or more than 20% mitochondrial reads. In the pancreas datasets, we filtered cells with the same thresholds used in Butler et al<sup><xref rid="R7" ref-type="bibr">7</xref></sup>: 1750 genes for CelSeq, 2500 genes for CelSeq2, no filter for Fluidigm C1, 2500 genes for SmartSeq2, and 500 genes for inDrop. We then library normalized each cell to 10,000 reads, by multiplicative scaling, then log scaled the normalized data. We then identified the top 1000 variable genes, ranked by coefficient of variation, within in each dataset. We pooled these genes to form the variable gene set of the analysis. Using only the variable genes, we mean centered and variance 1 scaled the genes across the cells. Note that this was done in the aggregate matrix, with all cells, rather than within each dataset separately. With these values, we performed truncated SVD keeping the top 30 eigenvectors. Finally, we multiplied the cell embeddings by the eigenvalues to avoid giving eigenvectors equal variance.</p>
        <sec id="S45">
          <label>5.1.1</label>
          <title>Spatial analysis</title>
          <p id="P92">The raw count 10X and MERFISH datasets were downloaded from their GEO and Dryad repositories respectively. MERFISH metadata was downloaded as a supplementary table from the Moffitt et al. publication<sup><xref rid="R27" ref-type="bibr">27</xref></sup>. Figures were generated using the 6 mice from the 10X dataset and the first naive female mouse in the MERFISH dataset. For purposes of prediction all cells labeled as 'Ambiguous' or 'Unstable' were removed from both datasets, as these represent cells with a low number of unique genes expressed, a low library size, or a non-deterministic clustering. All genes in the 10X dataset that were not expressed in any cells were removed. In the MERFISH dataset, the gene blanks were removed for integration and the <italic>Fos</italic> gene was removed (no numerical values).</p>
          <p id="P93">In the 10X dataset, we normalized the counts by dividing the raw counts within each cell by the total number of transcripts within that cell, scaling these counts by 10,000, offsetting the counts by 1, and log transforming the counts. As the MERFISH dataset counts were already normalized by volume we only performed log transformation on the counts with an offset of 1. We then combined the two datasets by subsetting the 10X dataset to the 154 intersecting genes, concatenating the normalized count matrices, and scaling each gene through z-score transformation.</p>
        </sec>
      </sec>
      <sec id="S46">
        <label>5.2</label>
        <title>Visualization</title>
        <p id="P94">We used the UMAP algorithm<sup><xref rid="R42" ref-type="bibr">42</xref>,<xref rid="R43" ref-type="bibr">43</xref></sup> to visualize cells in a two dimensional space. For all analyses, UMAP was run with the following parameters: k=30 nearest neighbors, correlation based distance, and min_dist=0.1.</p>
      </sec>
      <sec id="S47">
        <label>5.3</label>
        <title>Comparison to other algorithms</title>
        <p id="P95">We used the provided packages or source code provided by the four comparison algorithm publications.</p>
        <sec id="S48">
          <label>5.3.1</label>
          <title>MNN Correct</title>
          <p id="P96">We used the mnn correct function, with default parameters, in the scran R package<sup><xref rid="R44" ref-type="bibr">44</xref></sup>, version 1.9.4. As input, we provided a matrix of PCA embeddings.</p>
        </sec>
        <sec id="S49">
          <label>5.3.2</label>
          <title>Seurat MultiCCA</title>
          <p id="P97">We followed the suggested integration pipeline in the Seurat R package<sup><xref rid="R7" ref-type="bibr">7</xref></sup>, version 2.3.4. This included the RunMultiCCA, MetageneBicorPlot, CalcVarExpRatio, SubsetData (subset.name = "var.ratio.pca", accept.low = 0.5), and AlignSubspace functions. Unless specified, we used all default parameters for these functions. We used the same number of canonical components as the number of PCs used as input to Harmony, MNN Correct, and Scanorama. Unlike the integration examples, we did not scale data within datasets separately, unless otherwise specified. We scaled data on the pooled count matrix instead.</p>
        </sec>
        <sec id="S50">
          <label>5.3.3</label>
          <title>Scanorama</title>
          <p id="P98">We used the assemble function, with precomputed PCs, from the primary github repository (brianhie/scanorama). We set knn=30 and sigma=1, to match the default comparable MNN Correct parameters. All other parameters were kept at default values. We did not use the correct function, as this included both pre-processing and integration of the data. For more equitable comparisons, we tried to use the same pre-processing pipelines for all methods and only compare only the integration steps.</p>
        </sec>
        <sec id="S51">
          <label>5.3.4</label>
          <title>BBKNN</title>
          <p id="P99">We downloaded the BBKNN software from the primary github repository (Teichlab/bbknn) and followed the suggested integration pipelines, using the bbknn and scanpy umap functions. For the bbknn function, we used k=5 and trim=20 for all analyses except for the HCA datasets, in which we used k=10 and trim=30, to accommodate the larger number of cells. All other parameters were kept at default values. Because BBKNN by design constructs a batch-balanced neighborhood graph, LISI should be biased towards these neighbors. On the other hand, BBKNN does not learn a low dimensional embedding aside from UMAP. Therefore, we were forced to use the potentially biased neighborhood graph provided by the method. We felt that this was appropriate because one step of BBKNN is to prune this graph before the UMAP step. Thus, we used the pruned BBKNN graph to compute LISI.</p>
        </sec>
      </sec>
      <sec id="S52">
        <label>5.4</label>
        <title>Harmony Parameters</title>
        <p id="P100">By default, we set the following parameters for Harmony: θ=2, K=100, τ=0, σ=0.1, block_size=0.05, ϵ<sub>cluster</sub>=10<sup>−5</sup>, ϵ<sub>harmony</sub>=10<sup>−4</sup>, max_iter<sub>cluster</sub>=200, max_iter<sub>Harmony</sub>=10, λ=1. For the pancreas analysis, we set τ=5. We set donors to be the primary covariate (θ=2) and technology secondary (θ=4). In the spatial analysis, we used θ=3 and λ=0.05.</p>
      </sec>
      <sec id="S53">
        <label>5.5</label>
        <title>Identification of alpha and beta ER stress subpopulations</title>
        <p id="P101">We identified the alpha and beta ER stress clusters in <xref rid="F5" ref-type="fig">Figure 5</xref> by performing downstream analysis, specified in this section, on the integrated joint embedding produced by Harmony. After Harmony integration, we performed clustering analysis to find novel subtypes. Clustering was done on the trimmed shared nearest neighbor graph with the Louvain algorithm<sup><xref rid="R45" ref-type="bibr">45</xref></sup>, as implemented in the Seurat package BuildSNN and RunModularityClustering functions. We used parameters resolution=0.8, k=30, and nn.eps=0. We identified several clusters within the alpha, beta, and ductal cell populations. For each cluster, we performed differential expression analysis within the defined cell type. That is, we compared alpha clusters to all other alpha cells. For differential expression, we used the R Limma package<sup><xref rid="R18" ref-type="bibr">18</xref></sup> on the normalized data. We included technology and library complexity (log number of unique genes) as covariates in the linear models. We used the top 100 over-expressed genes for each cluster, weighted by the t-statistic, to perform pathway enrichment with the enrichR<sup><xref rid="R46" ref-type="bibr">46</xref>,<xref rid="R47" ref-type="bibr">47</xref></sup> R package, using the three Gene Ontology genesets<sup><xref rid="R48" ref-type="bibr">48</xref>,<xref rid="R49" ref-type="bibr">49</xref></sup>. The ductal subpopulation was enriched for ribosomal genes; we did not follow up on this cluster.</p>
      </sec>
      <sec id="S54">
        <label>5.6</label>
        <title>Labeling cells with canonical markers</title>
        <p id="P102">In the cell-line, PBMC, and Pancreas analyses, we labeled cells within individual datasets using canonical markers. We did this by using the standard pre-processing pipeline for each dataset, clustering (Louvain, as above), and identifying clusters specific for the canonical markers for that analysis. We used a similar strategy to identify fine-grained subpopulations of PBMCs and in the HCA 500,000 cell dataset. In these case, we clustered in the joint embedding produced by Harmony, then looked for clusters that specifically expressed expected canonical markers.</p>
      </sec>
      <sec id="S55">
        <label>5.7</label>
        <title>Identification of spatially autocorrelated transcription factors</title>
        <p id="P103">To identify which of our predicted genes were transcription factors, we downloaded all known vertebrate transcription factors from JASPAR in MEME format<sup><xref rid="R29" ref-type="bibr">29</xref></sup>. We used this list of transcription factors as a reference for our predicted genes list. We assessed the degree of spatial localization of each transcription factor using Moran's I statistic. Due to the large number of cells, we found the calculation of a dense weights matrix of all pairwise distances between cells to be untenable. Therefore, after taking each slice and centering their respective cell's X and Y centroids around 0, we calculated a sparse weights matrix by finding each MERFISH cell's 30 nearest MERFISH neighbors (using centered X-centroids, centered Y-centroids, and slice Z-position as locations for each cell) excluding itself and applying an RBF kernel on the distances of each MERFISH cell's nearest neighbors with bandwidth σ=60. For each set of nearest neighbors, we divided each distance by the sum of the distances to obtain probabilities to use as weights, and input these weights into a sparse matrix. Calculations then proceeded as normal from the equation, using the sparse distance matrix as the weights matrix. Genes with significant spatial autocorrelation were evaluated at FDR 0.05. Formally, for gene g, a nearest neighbor map NN, and a 3D spatial embedding matrix X, the nearest-neighbor formulation of Moran's I is:
<disp-formula id="FD42"><label>(17)</label><mml:math display="block" id="M63" overflow="scroll"><mml:mrow><mml:mi>I</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi>N</mml:mi><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mfrac><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>N</mml:mi><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>g</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>g</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>g</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>g</mml:mi></mml:msub><mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD43"><label>(18)</label><mml:math display="block" id="M64" overflow="scroll"><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">∣</mml:mo><mml:mrow><mml:mo stretchy="true">∣</mml:mo><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">∣</mml:mo></mml:mrow><mml:msup><mml:mo stretchy="false">∣</mml:mo><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>σ</mml:mi></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
      </sec>
      <sec id="S56">
        <label>5.8</label>
        <title>ISH Allen Brain Atlas access</title>
        <p id="P104">To look at the coarse ISH data from Allen Brain Atlas, we utilized the ISH data portal<sup><xref rid="R31" ref-type="bibr">31</xref></sup>. We searched for our gene of interest (<italic>Satb1</italic>) and selected experiment number 79488931, with coronal slices. To estimate the anterior-posterior position of each slice, we used the online tool to map each slice to an Atlas reference slice. Each reference slice has a position from the Bregma, searchable in their online Allen Mouse Brain volumetric atlas 2012: <ext-link ext-link-type="uri" xlink:href="https://scalablebrainatlas.incf.org/mouse/ABA12">https://scalablebrainatlas.incf.org/mouse/ABA12</ext-link>. The representative image in <xref rid="F6" ref-type="fig">Figure 6A</xref> is slice 62 (282) in the volumetric atlas. We also used the Atlas annotations online to estimate the location of anatomical structures (i.e. hypothalamus and ventricles) in each slice. We downloaded 13 to 16 from experiment 79488931 and focused on a 2×2cm region around the hypothalamus.</p>
      </sec>
      <sec id="S57">
        <label>5.9</label>
        <title>Statistics</title>
        <p id="P105">Statistical analysis of LISI score comparisons is described in <xref rid="S37" ref-type="sec">section 4.1.1</xref>. Differential expression tests in the pancreatic islet cell analysis were performed with 2-tailed moderated t-tests, implemented in the LIMMA R package. Correlation analyses in the pancreatic islet cell and MERFISH analyses were performed using Spearman correlation.</p>
      </sec>
    </sec>
    <sec id="S58">
      <label>6</label>
      <title>Reporting Summary</title>
      <p id="P106">Further information on research design is available in the Nature Research Reporting Summary linked to this article.</p>
      <sec sec-type="data-availability" id="S59">
        <title>Data Availability</title>
        <p id="P107">All data analyzed in this manuscript are publicly available through online sources. We included links to all data sources in <xref rid="SD8" ref-type="supplementary-material">Supplementary Table 8</xref>.</p>
      </sec>
      <sec id="S60">
        <title>Code Availability</title>
        <p id="P108">Harmony and LISI are available as R packages on <ext-link ext-link-type="uri" xlink:href="https://github.com/immunogenomics/harmony">https://github.com/immunogenomics/harmony</ext-link> and <ext-link ext-link-type="uri" xlink:href="https://github.com/immunogenomics/lisi">https://github.com/immunogenomics/lisi</ext-link>. Scripts to reproduce results of the primary analyses will be made available on <ext-link ext-link-type="uri" xlink:href="https://github.com/immunogenomics/harmony2019">https://github.com/immunogenomics/harmony2019</ext-link>. Additionally, vignettes are included as supplementary notes. <xref rid="SD5" ref-type="supplementary-material">Supplementary note 1</xref> provides a detailed walkthrough of Harmony, connecting theoretical algorithm components to their code implementations. <xref rid="SD6" ref-type="supplementary-material">Supplementary note 2</xref> demonstrates the LISI metric and how to evaluate its statistical significance. <xref rid="SD5" ref-type="supplementary-material">Supplementary note 1</xref> uses Harmony with simulated datasets.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="supplementary-material" id="SM1">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="SD1">
      <label>1</label>
      <media xlink:href="NIHMS1539299-supplement-1.zip" orientation="portrait" xlink:type="simple" id="d36e7043" position="anchor"/>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="SD2">
      <label>2</label>
      <media xlink:href="NIHMS1539299-supplement-2.zip" orientation="portrait" xlink:type="simple" id="d36e7047" position="anchor"/>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="SD3">
      <label>3</label>
      <media xlink:href="NIHMS1539299-supplement-3.pdf" orientation="portrait" xlink:type="simple" id="d36e7051" position="anchor"/>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="SD4">
      <label>4</label>
      <media xlink:href="NIHMS1539299-supplement-4.pdf" orientation="portrait" xlink:type="simple" id="d36e7055" position="anchor"/>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="SD5">
      <label>5</label>
      <media xlink:href="NIHMS1539299-supplement-5.html" orientation="portrait" xlink:type="simple" id="d36e7059" position="anchor"/>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="SD6">
      <label>6</label>
      <media xlink:href="NIHMS1539299-supplement-6.html" orientation="portrait" xlink:type="simple" id="d36e7063" position="anchor"/>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="SD7">
      <label>7</label>
      <media xlink:href="NIHMS1539299-supplement-7.html" orientation="portrait" xlink:type="simple" id="d36e7067" position="anchor"/>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="SD8">
      <label>8</label>
      <media xlink:href="NIHMS1539299-supplement-8.xlsx" orientation="portrait" xlink:type="simple" id="d36e7071" position="anchor"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="S61">
    <title>Acknowledgements</title>
    <p id="P109">This work was supported in part by funding from the National Institutes of Health (UH2AR067677, U19AI111224, and 1R01AR063759 (to SR)) and T32 AR007530-31 (to IK). We thank members of the Raychaudhuri and Brenner labs for comments and discussion. IK and KW were funded as part of a collaborative research agreement with F. Hoffmann-La Roche Ltd (Basel, Switzerland), to SR and MBB.</p>
  </ack>
  <fn-group>
    <fn id="FN2">
      <p id="P110">Competing Interests Statement</p>
      <p id="P111">IK does paid bioinformatics consulting through Brilyant LLC.</p>
    </fn>
  </fn-group>
  <ref-list>
    <title>References</title>
    <ref id="R1">
      <label>1.</label>
      <mixed-citation publication-type="journal"><name><surname>Svensson</surname><given-names>V</given-names></name>, <name><surname>Vento-Tormo</surname><given-names>R</given-names></name> &amp; <name><surname>Teichmann</surname><given-names>SA</given-names></name>
<article-title>Exponential scaling of single-cell RNA-seq in the past decade</article-title>. <source>Nature Protocols</source>
<volume>13</volume>, <fpage>599</fpage>–<lpage>604</lpage> (<year>2018</year>).<pub-id pub-id-type="pmid">29494575</pub-id></mixed-citation>
    </ref>
    <ref id="R2">
      <label>2.</label>
      <mixed-citation publication-type="journal"><name><surname>Regev</surname><given-names>A</given-names></name><etal/><article-title>The human cell atlas</article-title>. <source>Elife</source><volume>6</volume> (<year>2017</year>).</mixed-citation>
    </ref>
    <ref id="R3">
      <label>3.</label>
      <mixed-citation publication-type="journal"><name><surname>Zhang</surname><given-names>F</given-names></name><etal/><article-title>Defining inflammatory cell states in rheumatoid arthritis joint synovial tissues by integrating single-cell transcriptomics and mass cytometry</article-title>. <source>Nature immunology</source><volume>1</volume> (<year>2019</year>).</mixed-citation>
    </ref>
    <ref id="R4">
      <label>4.</label>
      <mixed-citation publication-type="journal"><name><surname>Arazi</surname><given-names>A</given-names></name><etal/><article-title>The immune cell landscape in kidneys of lupus nephritis patients</article-title>. <source>Nature Immunology</source><volume>20</volume>, <fpage>902</fpage>–<lpage>914</lpage> (<year>2019</year>).<pub-id pub-id-type="pmid">31209404</pub-id></mixed-citation>
    </ref>
    <ref id="R5">
      <label>5.</label>
      <mixed-citation publication-type="journal"><name><surname>Der</surname><given-names>E</given-names></name><etal/><article-title>Tubular cell and keratinocyte single-cell transcriptomics applied to lupus nephritis reveal type I IFN and fibrosis relevant pathways</article-title>. <source>Nature Immunolology</source><volume>20</volume>, <fpage>915</fpage>–<lpage>927</lpage> (<year>2019</year>).</mixed-citation>
    </ref>
    <ref id="R6">
      <label>6.</label>
      <mixed-citation publication-type="journal"><name><surname>Hicks</surname><given-names>SC</given-names></name>, <name><surname>Townes</surname><given-names>FW</given-names></name>, <name><surname>Teng</surname><given-names>M</given-names></name> &amp; <name><surname>Irizarry</surname><given-names>RA</given-names></name>
<article-title>Missing data and technical variability in single-cell RNA-sequencing experiments</article-title>. <source>Biostatistics</source>
<volume>19</volume>, <fpage>562</fpage>–<lpage>578</lpage> (<year>2017</year>).</mixed-citation>
    </ref>
    <ref id="R7">
      <label>7.</label>
      <mixed-citation publication-type="journal"><name><surname>Butler</surname><given-names>A</given-names></name>, <name><surname>Hoffman</surname><given-names>P</given-names></name>, <name><surname>Smibert</surname><given-names>P</given-names></name>, <name><surname>Papalexi</surname><given-names>E</given-names></name> &amp; <name><surname>Satija</surname><given-names>R</given-names></name>
<article-title>Integrating single-cell transcriptomic data across different conditions, technologies, and species</article-title>. <source>Nature. Biotechnology</source>. <volume>36</volume>, <fpage>411</fpage>–<lpage>420</lpage> (<year>2018</year>).</mixed-citation>
    </ref>
    <ref id="R8">
      <label>8.</label>
      <mixed-citation publication-type="journal"><name><surname>Haghverdi</surname><given-names>L</given-names></name>, <name><surname>Lun</surname><given-names>ATL</given-names></name>, <name><surname>Morgan</surname><given-names>MD</given-names></name> &amp; <name><surname>Marioni</surname><given-names>JC</given-names></name>
<article-title>Batch effects in single-cell RNA-sequencing data are corrected by matching mutual nearest neighbors</article-title>. <source>Nature Biotechnology</source>. <volume>36</volume>, <fpage>421</fpage>–<lpage>427</lpage> (<year>2018</year>).</mixed-citation>
    </ref>
    <ref id="R9">
      <label>9.</label>
      <mixed-citation publication-type="journal"><name><surname>Hie</surname><given-names>BL</given-names></name>, <name><surname>Bryson</surname><given-names>B</given-names></name> &amp; <name><surname>Berger</surname><given-names>B</given-names></name>
<article-title>Efficient integration of heterogeneous single-cell transcriptomes using Scanorama</article-title>. <source>Nature Biotechnology</source>
<volume>37</volume>, <fpage>685</fpage>–<lpage>691</lpage> (<year>2018</year>).</mixed-citation>
    </ref>
    <ref id="R10">
      <label>10.</label>
      <mixed-citation publication-type="journal"><name><surname>Polanski</surname><given-names>K</given-names></name>, <name><surname>Park</surname><given-names>JE</given-names></name>, <name><surname>Young</surname><given-names>MD</given-names></name>, <name><surname>Miao</surname><given-names>Z</given-names></name>, <name><surname>Meyer</surname><given-names>KB</given-names></name> &amp; <name><surname>Teichmann</surname><given-names>SA</given-names></name>
<article-title>BBKNN: Fast Batch Alignment of Single Cell Transcriptomes</article-title>. <source>Bioinformatics</source>
<volume>btz625</volume> (<year>2019</year>).</mixed-citation>
    </ref>
    <ref id="R11">
      <label>11.</label>
      <mixed-citation publication-type="journal"><name><surname>Zheng</surname><given-names>GXY</given-names></name><etal/><article-title>Massively parallel digital transcriptional profiling of single cells</article-title>. <source>Nature Communications</source>. <volume>8</volume>, <fpage>14049</fpage> (<year>2017</year>).</mixed-citation>
    </ref>
    <ref id="R12">
      <label>12.</label>
      <mixed-citation publication-type="other"><name><surname>Li</surname><given-names>B</given-names></name><etal/><source>HCA data portal - census of immune cells</source>.</mixed-citation>
    </ref>
    <ref id="R13">
      <label>13.</label>
      <mixed-citation publication-type="journal"><name><surname>Segerstolpe</surname><given-names>A</given-names></name><etal/><article-title>Single-Cell transcriptome profiling of human pancreatic islets in health and type 2 diabetes</article-title>. <source>Cell Metab</source>. <volume>24</volume>, <fpage>593</fpage>–<lpage>607</lpage> (<year>2016</year>).<pub-id pub-id-type="pmid">27667667</pub-id></mixed-citation>
    </ref>
    <ref id="R14">
      <label>14.</label>
      <mixed-citation publication-type="journal"><name><surname>Baron</surname><given-names>M</given-names></name><etal/><article-title>A Single-Cell transcriptomic map of the human and mouse pancreas reveals inter- and intra-cell population structure</article-title>. <source>Cell Systems</source><volume>3</volume>, <fpage>346</fpage>–<lpage>360.e4</lpage> (<year>2016</year>).<pub-id pub-id-type="pmid">27667365</pub-id></mixed-citation>
    </ref>
    <ref id="R15">
      <label>15.</label>
      <mixed-citation publication-type="journal"><name><surname>Lawlor</surname><given-names>N</given-names></name><etal/><article-title>Single-cell transcriptomes identify human islet cell signatures and reveal cell-type-specific expression changes in type 2 diabetes</article-title>. <source>Genome Research</source>. <volume>27</volume>, <fpage>208</fpage>–<lpage>222</lpage> (<year>2017</year>).<pub-id pub-id-type="pmid">27864352</pub-id></mixed-citation>
    </ref>
    <ref id="R16">
      <label>16.</label>
      <mixed-citation publication-type="journal"><name><surname>Grun</surname><given-names>D</given-names></name><etal/><article-title>De novo prediction of stem cell identity using Single-Cell transcriptome data</article-title>. <source>Cell Stem Cell</source><volume>19</volume>, <fpage>266</fpage>–<lpage>277</lpage> (<year>2016</year>).<pub-id pub-id-type="pmid">27345837</pub-id></mixed-citation>
    </ref>
    <ref id="R17">
      <label>17.</label>
      <mixed-citation publication-type="journal"><name><surname>Muraro</surname><given-names>MJ</given-names></name><etal/><article-title>A Single-Cell transcriptome atlas of the human pancreas</article-title>. <source>Cell Systems</source><volume>3</volume>, <fpage>385</fpage>–<lpage>394.e3</lpage> (<year>2016</year>).<pub-id pub-id-type="pmid">27693023</pub-id></mixed-citation>
    </ref>
    <ref id="R18">
      <label>18.</label>
      <mixed-citation publication-type="journal"><name><surname>Ritchie</surname><given-names>ME</given-names></name><etal/><article-title>limma powers differential expression analyses for RNA-sequencing and microarray studies</article-title>. <source>Nucleic Acids Research</source><volume>43</volume>, <fpage>e47</fpage> (<year>2015</year>).<pub-id pub-id-type="pmid">25605792</pub-id></mixed-citation>
    </ref>
    <ref id="R19">
      <label>19.</label>
      <mixed-citation publication-type="journal"><name><surname>Gao</surname><given-names>T</given-names></name><etal/><article-title>Pdx1 maintains β cell identity and function by repressing an α cell program</article-title>. <source>Cell Metabolism</source><volume>19</volume>, <fpage>259</fpage>–<lpage>271</lpage> (<year>2014</year>).<pub-id pub-id-type="pmid">24506867</pub-id></mixed-citation>
    </ref>
    <ref id="R20">
      <label>20.</label>
      <mixed-citation publication-type="journal"><name><surname>Jia</surname><given-names>S</given-names></name><etal/><article-title>Insm1 cooperates with neurod1 and foxa2 to maintain mature pancreatic β-cell function</article-title>. <source>EMBO J</source>. <volume>34</volume>, <fpage>1417</fpage>–<lpage>1433</lpage> (<year>2015</year>).<pub-id pub-id-type="pmid">25828096</pub-id></mixed-citation>
    </ref>
    <ref id="R21">
      <label>21.</label>
      <mixed-citation publication-type="journal"><name><surname>Sachdeva</surname><given-names>MM</given-names></name><etal/><article-title>Pdx1 (MODY4) regulates pancreatic beta cell susceptibility to ER stress</article-title>. <source>Proc. Natl. Acad. Sci. U.S.A</source>. <volume>106</volume>, <fpage>19090</fpage>–<lpage>19095</lpage> (<year>2009</year>).<pub-id pub-id-type="pmid">19855005</pub-id></mixed-citation>
    </ref>
    <ref id="R22">
      <label>22.</label>
      <mixed-citation publication-type="journal"><name><surname>Katoh</surname><given-names>MC</given-names></name><etal/><article-title>MafB is critical for glucagon production and secretion in mouse pancreatic α cells in vivo</article-title>. <source>Mol. Cell. Biol</source>. <volume>38</volume> (<year>2018</year>).</mixed-citation>
    </ref>
    <ref id="R23">
      <label>23.</label>
      <mixed-citation publication-type="journal"><name><surname>Liu</surname><given-names>J</given-names></name><etal/><article-title>Islet-1 regulates arx transcription during pancreatic islet α-Cell development</article-title>. <source>J. Biol. Chem</source>. <volume>286</volume>, <fpage>15352</fpage>–<lpage>15360</lpage> (<year>2011</year>).<pub-id pub-id-type="pmid">21388963</pub-id></mixed-citation>
    </ref>
    <ref id="R24">
      <label>24.</label>
      <mixed-citation publication-type="journal"><name><surname>Akiyama</surname><given-names>M</given-names></name><etal/><article-title>X-box binding protein 1 is essential for insulin regulation of pancreatic α-cell function</article-title>. <source>Diabetes</source><volume>62</volume>, <fpage>2439</fpage>–<lpage>2449</lpage> (<year>2013</year>).<pub-id pub-id-type="pmid">23493568</pub-id></mixed-citation>
    </ref>
    <ref id="R25">
      <label>25.</label>
      <mixed-citation publication-type="journal"><name><surname>Burcelin</surname><given-names>R</given-names></name>, <name><surname>Knauf</surname><given-names>C</given-names></name> &amp; <name><surname>Cani</surname><given-names>PD</given-names></name>
<article-title>Pancreatic alpha-cell dysfunction in diabetes</article-title>. <source>Diabetes Metab</source>. <volume>34</volume>
<issue>Suppl 2</issue>, <fpage>S49</fpage>–<lpage>55</lpage> (<year>2008</year>).<pub-id pub-id-type="pmid">18640586</pub-id></mixed-citation>
    </ref>
    <ref id="R26">
      <label>26.</label>
      <mixed-citation publication-type="journal"><name><surname>Pijuan-Sala</surname><given-names>B</given-names></name><etal/><article-title>A single-cell molecular map of mouse gastrulation and early organogenesis</article-title>. <source>Nature</source><volume>566</volume>, <fpage>490</fpage>–<lpage>495</lpage> (<year>2019</year>).<pub-id pub-id-type="pmid">30787436</pub-id></mixed-citation>
    </ref>
    <ref id="R27">
      <label>27.</label>
      <mixed-citation publication-type="journal"><name><surname>Moffitt</surname><given-names>JR</given-names></name><etal/><article-title>Molecular, spatial, and functional single-cell profiling of the hypothalamic preoptic region</article-title>. <source>Science</source><volume>362</volume> (<year>2018</year>).</mixed-citation>
    </ref>
    <ref id="R28">
      <label>28.</label>
      <mixed-citation publication-type="web"><name><surname>Moffitt</surname><given-names>J</given-names></name><etal/><source>Data from: Molecular, spatial and functional single-cell profiling of the hypothalamic preoptic region</source> (<year>2018</year>). URL <pub-id pub-id-type="doi">10.5061/dryad.8t8s248</pub-id><comment>.</comment></mixed-citation>
    </ref>
    <ref id="R29">
      <label>29.</label>
      <mixed-citation publication-type="journal"><name><surname>Khan</surname><given-names>A</given-names></name><etal/><article-title>JASPAR 2018: update of the open-access database of transcription factor binding profiles and its web framework</article-title>. <source>Nucleic Acids Res</source>. <volume>46</volume>, <fpage>D260</fpage>–<lpage>D266</lpage> (<year>2018</year>).<pub-id pub-id-type="pmid">29140473</pub-id></mixed-citation>
    </ref>
    <ref id="R30">
      <label>30.</label>
      <mixed-citation publication-type="journal"><name><surname>Close</surname><given-names>J</given-names></name><etal/><article-title>Satb1 is an activity-modulated transcription factor required for the terminal differentiation and connectivity of medial ganglionic eminence-derived cortical interneurons</article-title>. <source>J. Neurosci</source>. <volume>32</volume>, <fpage>17690</fpage>–<lpage>17705</lpage> (<year>2012</year>).<pub-id pub-id-type="pmid">23223290</pub-id></mixed-citation>
    </ref>
    <ref id="R31">
      <label>31.</label>
      <mixed-citation publication-type="journal"><name><surname>Lein</surname><given-names>ES</given-names></name><etal/><article-title>Genome-wide atlas of gene expression in the adult mouse brain</article-title>. <source>Nature</source><volume>445</volume>, <fpage>168</fpage>–<lpage>176</lpage> (<year>2007</year>).<pub-id pub-id-type="pmid">17151600</pub-id></mixed-citation>
    </ref>
    <ref id="R32">
      <label>32.</label>
      <mixed-citation publication-type="journal"><name><surname>Leek</surname><given-names>JT</given-names></name> &amp; <name><surname>Storey</surname><given-names>JD</given-names></name>
<article-title>Capturing Heterogeneity in Gene Expression Studies by Surrogate Variable Analysis</article-title>. <source>PloS Genet</source>
<volume>3</volume>(<issue>9</issue>): <fpage>e161</fpage> (<year>2007</year>).</mixed-citation>
    </ref>
    <ref id="R33">
      <label>33.</label>
      <mixed-citation publication-type="journal"><name><surname>Stegle</surname><given-names>O</given-names></name>, <name><surname>Parts</surname><given-names>L</given-names></name>, <name><surname>Piipari</surname><given-names>M</given-names></name>, <name><surname>Winn</surname><given-names>J</given-names></name>, <name><surname>Durbin</surname><given-names>R</given-names></name><article-title>Using probabilistic estimation of expression residuals (PEER) to obtain increased power and interpretability of gene expression analyses</article-title>. <source>Nature Protocols</source><volume>7</volume>, <fpage>500</fpage>–<lpage>507</lpage> (<year>2012</year>).<pub-id pub-id-type="pmid">22343431</pub-id></mixed-citation>
    </ref>
    <ref id="R34">
      <label>34.</label>
      <mixed-citation publication-type="journal"><name><surname>Mizoguchi</surname><given-names>F</given-names></name><etal/><article-title>Functionally distinct disease-associated fibroblast subsets in rheumatoid arthritis</article-title>. <source>Nature communications</source><volume>9</volume>, <fpage>789</fpage> (<year>2018</year>).</mixed-citation>
    </ref>
    <ref id="R35">
      <label>35.</label>
      <mixed-citation publication-type="journal"><name><surname>Manno</surname><given-names>GL</given-names></name><etal/><article-title>RNA velocity of single cells</article-title>. <source>Nature</source><volume>560</volume>, <fpage>494</fpage>–<lpage>498</lpage> (<year>2018</year>).<pub-id pub-id-type="pmid">30089906</pub-id></mixed-citation>
    </ref>
  </ref-list>
  <ref-list>
    <title>Methods-only References</title>
    <ref id="R36">
      <label>36.</label>
      <mixed-citation publication-type="confproc"><name><surname>Mao</surname><given-names>Q</given-names></name>, <name><surname>Wang</surname><given-names>L</given-names></name>, <name><surname>Goodison</surname><given-names>S</given-names></name> &amp; <name><surname>Sun</surname><given-names>Y</given-names></name>
<source>Dimensionality reduction via graph structure learning</source>. In <conf-name>Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, KDD</conf-name> ‘<volume>15</volume>, <fpage>765</fpage>–<lpage>774</lpage> (<publisher-name>ACM</publisher-name>, <publisher-loc>New York, NY, USA</publisher-loc>, <year>2015</year>).</mixed-citation>
    </ref>
    <ref id="R37">
      <label>37.</label>
      <mixed-citation publication-type="journal"><name><surname>Dhillon</surname><given-names>IS</given-names></name> &amp; <name><surname>Modha</surname><given-names>DS</given-names></name>
<article-title>Concept decompositions for large sparse text data using clustering</article-title>. <source>Mach. Learn</source>. <volume>42</volume>,<fpage>143</fpage>–<lpage>175</lpage> (<year>2001</year>).</mixed-citation>
    </ref>
    <ref id="R38">
      <label>38.</label>
      <mixed-citation publication-type="journal"><name><surname>Jordan</surname><given-names>MI</given-names></name> &amp; <name><surname>Jacobs</surname><given-names>RA</given-names></name>
<article-title>Hierarchical mixtures of experts and the EM algorithm</article-title>. <source>Neural Comput</source>. <volume>6</volume>, <fpage>181</fpage>–<lpage>214</lpage> (<year>1994</year>).</mixed-citation>
    </ref>
    <ref id="R39">
      <label>39.</label>
      <mixed-citation publication-type="journal"><name><surname>Buttner</surname><given-names>M</given-names></name>, <name><surname>Miao</surname><given-names>Z</given-names></name>, <name><surname>Wolf</surname><given-names>FA</given-names></name>, <name><surname>Teichmann</surname><given-names>SA</given-names></name> &amp; <name><surname>Theis</surname><given-names>FJ</given-names></name>
<article-title>A test metric for assessing single-cell RNA-seq batch correction</article-title>. <source>Nature Methods</source>
<volume>16</volume>, <fpage>43</fpage>–<lpage>49</lpage> (<year>2019</year>).<pub-id pub-id-type="pmid">30573817</pub-id></mixed-citation>
    </ref>
    <ref id="R40">
      <label>40.</label>
      <mixed-citation publication-type="journal"><name><surname>Azizi</surname><given-names>E</given-names></name><etal/><article-title>Single-Cell map of diverse immune phenotypes in the breast tumor microenvironment</article-title>. <source>Cell</source><volume>174</volume>, <fpage>1293</fpage>–<lpage>1308.e36</lpage> (<year>2018</year>).<pub-id pub-id-type="pmid">29961579</pub-id></mixed-citation>
    </ref>
    <ref id="R41">
      <label>41.</label>
      <mixed-citation publication-type="journal"><name><surname>Dobin</surname><given-names>A</given-names></name><etal/><article-title>STAR: ultrafast universal RNA-seq aligner</article-title>. <source>Bioinformatics</source><volume>29</volume>, <fpage>15</fpage>–<lpage>21</lpage> (<year>2013</year>).<pub-id pub-id-type="pmid">23104886</pub-id></mixed-citation>
    </ref>
    <ref id="R42">
      <label>42.</label>
      <mixed-citation publication-type="journal"><name><surname>McInnes</surname><given-names>L</given-names></name> &amp; <name><surname>Healy</surname><given-names>J</given-names></name>
<article-title>UMAP: Uniform manifold approximation and projection for dimension reduction</article-title>. <source>arXiv</source> (<year>2018</year>). 1802.03426.</mixed-citation>
    </ref>
    <ref id="R43">
      <label>43.</label>
      <mixed-citation publication-type="journal"><name><surname>Becht</surname><given-names>E</given-names></name><etal/><article-title>Dimensionality reduction for visualizing single-cell data using UMAP</article-title>. <source>Nature Biotechnology</source><volume>37</volume>, <fpage>38</fpage>–<lpage>44</lpage> (<year>2019</year>).</mixed-citation>
    </ref>
    <ref id="R44">
      <label>44.</label>
      <mixed-citation publication-type="journal"><name><surname>Lun</surname><given-names>ATL</given-names></name>, <name><surname>McCarthy</surname><given-names>DJ</given-names></name> &amp; <name><surname>Marioni</surname><given-names>JC</given-names></name>
<article-title>A step-by-step workflow for low-level analysis of single-cell rna-seq data with bioconductor</article-title>. <source>F1000Res</source>. <volume>5</volume>, <fpage>2122</fpage> (<year>2016</year>).<pub-id pub-id-type="pmid">27909575</pub-id></mixed-citation>
    </ref>
    <ref id="R45">
      <label>45.</label>
      <mixed-citation publication-type="journal"><name><surname>Blondel</surname><given-names>VD</given-names></name>, <name><surname>Guillaume</surname><given-names>J-L</given-names></name>, <name><surname>Lambiotte</surname><given-names>R</given-names></name> &amp; <name><surname>Lefebvre</surname><given-names>E</given-names></name>
<article-title>Fast unfolding of communities in large networks</article-title>. <source>J. Stat. Mech: Theory Exp</source>. <volume>2008</volume> (<year>2008</year>).</mixed-citation>
    </ref>
    <ref id="R46">
      <label>46.</label>
      <mixed-citation publication-type="journal"><name><surname>Chen</surname><given-names>EY</given-names></name><etal/><article-title>Enrichr: interactive and collaborative HTML5 gene list enrichment analysis tool</article-title>. <source>BMC Bioinformatics</source><volume>14</volume>, <fpage>128</fpage> (<year>2013</year>).<pub-id pub-id-type="pmid">23586463</pub-id></mixed-citation>
    </ref>
    <ref id="R47">
      <label>47.</label>
      <mixed-citation publication-type="journal"><name><surname>Kuleshov</surname><given-names>MV</given-names></name><etal/><article-title>Enrichr: a comprehensive gene set enrichment analysis web server 2016 update</article-title>. <source>Nucleic Acids Res</source>. <volume>44</volume>, <fpage>W90</fpage>–<lpage>7</lpage> (<year>2016</year>).<pub-id pub-id-type="pmid">27141961</pub-id></mixed-citation>
    </ref>
    <ref id="R48">
      <label>48.</label>
      <mixed-citation publication-type="journal"><collab>The Gene Ontology Consortium</collab>. <article-title>Expansion of the gene ontology knowledgebase and resources</article-title>. <source>Nucleic Acids Res</source>. <volume>45</volume>, <fpage>D331</fpage>–<lpage>D338</lpage> (<year>2017</year>).<pub-id pub-id-type="pmid">27899567</pub-id></mixed-citation>
    </ref>
    <ref id="R49">
      <label>49.</label>
      <mixed-citation publication-type="journal"><name><surname>Ashburner</surname><given-names>M</given-names></name><etal/><article-title>Gene ontology: tool for the unification of biology. the gene ontology consortium</article-title>. <source>Nature Genetics</source><volume>25</volume>, <fpage>25</fpage>–<lpage>29</lpage> (<year>2000</year>).<pub-id pub-id-type="pmid">10802651</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<floats-group>
  <fig id="F1" orientation="portrait" position="float">
    <label>Figure 1.</label>
    <caption>
      <p id="P112">Overview of Harmony algorithm. We represent datasets with colors, and different cell types with shapes. Before we apply Harmony, principal components analysis embeds cells into a space with reduced dimensionality. Harmony accepts the cell coordinates in this reduced space and runs an iterative algorithm to adjust for data set specific effects. (A) Harmony uses fuzzy clustering to assign each cell to multiple clusters, while a penalty term ensures that the diversity of datasets within each cluster is maximized. (B) Harmony calculates a global centroid for each cluster, as well as dataset-specific centroids for each cluster. (C) Within each cluster, Harmony calculates a correction factor for each dataset based on the centroids. (D) Finally, Harmony corrects each cell with a cell-specific factor: a linear combination of dataset correction factors weighted by its soft cluster assignments made in step A. Harmony repeats steps A through D until convergence. The dependence between cluster assignment and dataset diminishes with each round.</p>
    </caption>
    <graphic xlink:href="nihms-1539299-f0001"/>
  </fig>
  <fig id="F2" orientation="portrait" position="float">
    <label>Figure 2.</label>
    <caption>
      <p id="P113">Quantitative assessment of dataset mixing and cell-type accuracy with cell line datasets. (A) iLISI measures the degree of mixing among datasets in an embedding, ranging from 1 in an unmixed space to B in a well mixed space. B is the number of datasets in the analysis. (B) cLISI measures integration accuracy using the same formulation but computed on cell-type labels instead. An accurate embedding has a cLISI close to 1 for every neighborhood, reflecting separation of different cell types. Jurkat and HEK293T cells from pure (purple and yellow) and mixed (green) cell-line datasets were analyzed together. Before Harmony integration, cells grouped by dataset (C) and known cell-type (D). (C) iLISI and (D) cLISI were computed for every cell's neighborhood and summarized with quantiles (5, 25, 50, 75, 95). After Harmony integration, cells from the mixture dataset are mixed into the other datasets (E), achieved by mixing Jurkat with Jurkat cells and HEK293T with HEK293T cells (F). (E) iLISI and (F) cLISI were re-computed in the Harmony embedding.</p>
    </caption>
    <graphic xlink:href="nihms-1539299-f0002"/>
  </fig>
  <fig id="F3" orientation="portrait" position="float">
    <label>Figure 3.</label>
    <caption>
      <p id="P114">Computational efficiency benchmarks. We ran Harmony, BBKNN, Scanorama, MNN Correct, and MultiCCA on 5 downsampled HCA datasets of increasing sizes, from 25,000 to 500,000 cells. We recorded the (A) total runtime and (B) maximum memory required to analyze each dataset. Scanorama, MultiCCA, and MNN Correct were terminated for excessive memory requests on the 250,000 and 500,000 cell datasets. The mixing between tissues in the Harmony embedding is visualized in (C). In the Harmony embedding, (D) we clustered cells and labeled populations by canonical markers: pre-T cells, CD4 Naive T cells, CD4 Memory T cells, T-regs, CD8 Naive T cells, CD8 Effector T cells, natural killer cells (NK), pre-B cells, Naive B cells, Memory B cells, plasma cells, plasmacytoid dendritic cells (pDC), conventional dendritic cells (DC), granulocyte macrophage progenitor (GMP), CD16− monocytes (CD14 Mono), CD16+ monocytes (CD16 Mono), a population of monocytes also positive for Megakaryocyte markers (PPBP Mono), Megakaryocytes (Mk), Erythroid progenitors (Eryth), and a cluster of hematopoietic stem cells and multipotent progenitor cells (HSC/MPP).</p>
    </caption>
    <graphic xlink:href="nihms-1539299-f0003"/>
  </fig>
  <fig id="F4" orientation="portrait" position="float">
    <label>Figure 4.</label>
    <caption>
      <p id="P115">Fine-grained subpopulation identification in PBMCs across technologies. Three PBMC datasets were assayed with 10X, using different library construction protocols: 5-prime (orange), 3-prime V1 (purple), and 3-prime V2 (green). Before integration (A), cells group by dataset. After Harmony integration (B), datasets are mixed together. (C) Harmony achieves the most thorough integration among datasets, while preserving (D) cell type differences. Using canonical markers (E), we identified (F) 5 shared subtypes of T cells and 2 shared subtypes of B cells. (G) Other integration algorithms fail to group these cells by subtype.</p>
    </caption>
    <graphic xlink:href="nihms-1539299-f0004"/>
  </fig>
  <fig id="F5" orientation="portrait" position="float">
    <label>Figure 5.</label>
    <caption>
      <p id="P116">Integration of pancreatic islet cells by both donor and technology. Human pancreatic islet cells from 36 donors were assayed on 5 different technologies. Cells initially group by (A) technology, denoted by different colors, and (B) donor, denoted by shades of colors. Harmony integrates cells simultaneously across (C) technology and (D) donor. (E) Clustering in the Harmony embedding identified common and rare cell types, including a previously identified beta population under ER stress. Except for activated stellate cells, all rare cell types were found across the 5 technology datasets (F). The ER stress beta population was enriched for ER stress genes (G) and had decreased expression of key genes necessary for endocrine function (H). We also identified a previously undescribed population of alpha cell, also enriched for ER stress genes (I) with decreased expression of key endocrine genes (J). The abundances of the two ER stress populations were correlated across donors (K).</p>
    </caption>
    <graphic xlink:href="nihms-1539299-f0005"/>
  </fig>
  <fig id="F6" orientation="portrait" position="float">
    <label>Figure 6.</label>
    <caption>
      <p id="P117">Harmony integrates spatially resolved transcriptomic with dissociated scRNAseq datasets. (A) Cells from the hypothalamic preoptic region of mouse brain were assayed in parallel with two technologies. The full transcriptome of dissociated cells was profiled with 10X. 155 genes were profiled in-situ on intact tissue with MERFISH. (B) Harmony integrated cells from the two modalities into a shared embedding, correctly merging the 12 previously identified cell types. (C) Satb1 expression (blue), unmeasured in the MERFISH dataset, was inferred and predicted to be spatially autocorrelated in inhibitory neurons. Satb1 expression was highest in anterior slices and diminished in slices that contained ventricle-lining Ependymal cells (green). (D) Matched images from an independent in-situ hybridization experiment measuring Satb1 expression from the Allen Brain Atlas. Satb1 expression (blue) is co-localized in similar regions of the slices and diminishes with the appearance of ventricle structures (green).</p>
    </caption>
    <graphic xlink:href="nihms-1539299-f0006"/>
  </fig>
</floats-group>
