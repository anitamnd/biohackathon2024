<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8088329</article-id>
    <article-id pub-id-type="pmid">32926128</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btaa779</article-id>
    <article-id pub-id-type="publisher-id">btaa779</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Shark: fishing relevant reads in an RNA-Seq sample</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8786-2276</contrib-id>
        <name>
          <surname>Denti</surname>
          <given-names>Luca</given-names>
        </name>
        <xref rid="btaa779-FM1" ref-type="author-notes"/>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-8479-7592</contrib-id>
        <name>
          <surname>Pirola</surname>
          <given-names>Yuri</given-names>
        </name>
        <xref rid="btaa779-cor1" ref-type="corresp"/>
        <xref rid="btaa779-FM1" ref-type="author-notes"/>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
        <!--yuri.pirola@unimib.it-->
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-3040-9539</contrib-id>
        <name>
          <surname>Previtali</surname>
          <given-names>Marco</given-names>
        </name>
        <xref rid="btaa779-FM1" ref-type="author-notes"/>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ceccato</surname>
          <given-names>Tamara</given-names>
        </name>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-5584-3089</contrib-id>
        <name>
          <surname>Della Vedova</surname>
          <given-names>Gianluca</given-names>
        </name>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Rizzi</surname>
          <given-names>Raffaella</given-names>
        </name>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bonizzoni</surname>
          <given-names>Paola</given-names>
        </name>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Ponty</surname>
          <given-names>Yann</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <fn id="btaa779-FM1">
        <p>The authors wish it to be known that, in their opinion, Luca Denti, Yuri Pirola and Marco Previtali should be regarded as joint First Authors.</p>
      </fn>
      <corresp id="btaa779-cor1">To whom correspondence should be addressed. <email>yuri.pirola@unimib.it</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <day>15</day>
      <month>2</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2020-09-14">
      <day>14</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>14</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <volume>37</volume>
    <issue>4</issue>
    <fpage>464</fpage>
    <lpage>472</lpage>
    <history>
      <date date-type="received">
        <day>01</day>
        <month>4</month>
        <year>2020</year>
      </date>
      <date date-type="rev-recd">
        <day>17</day>
        <month>8</month>
        <year>2020</year>
      </date>
      <date date-type="editorial-decision">
        <day>31</day>
        <month>8</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>02</day>
        <month>9</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2020</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btaa779.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Recent advances in high-throughput RNA-Seq technologies allow to produce massive datasets. When a study focuses only on a handful of genes, most reads are not relevant and degrade the performance of the tools used to analyze the data. Removing irrelevant reads from the input dataset leads to improved efficiency without compromising the results of the study.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We introduce a novel computational problem, called gene assignment and we propose an efficient alignment-free approach to solve it. Given an RNA-Seq sample and a panel of genes, a gene assignment consists in extracting from the sample, the reads that most probably were sequenced from those genes. The problem becomes more complicated when the sample exhibits evidence of novel alternative splicing events. We implemented our approach in a tool called Shark and assessed its effectiveness in speeding up differential splicing analysis pipelines. This evaluation shows that Shark is able to significantly improve the performance of RNA-Seq analysis tools without having any impact on the final results.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The tool is distributed as a stand-alone module and the software is freely available at <ext-link xlink:href="https://github.com/AlgoLab/shark" ext-link-type="uri">https://github.com/AlgoLab/shark</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union’s Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie</institution>
          </institution-wrap>
        </funding-source>
        <award-id>872539</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>RNA-Seq analysis plays an important role in the biological and medical research aimed at deepening our understanding of cellular biological processes and their relationships with pathological conditions. As such, several research initiatives had the objective of producing RNA-Seq data, while a number of tools have been proposed to analyze such datasets and have gained widespread adoption in the community (<xref rid="btaa779-B5" ref-type="bibr">Beretta <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa779-B8" ref-type="bibr">Bray <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btaa779-B11" ref-type="bibr">Denti <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btaa779-B24" ref-type="bibr">Patro <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa779-B25" ref-type="bibr">Sacomoto <italic toggle="yes">et al.</italic>, 2012</xref>; <xref rid="btaa779-B26" ref-type="bibr">Shen <italic toggle="yes">et al.</italic>, 2014</xref>; <xref rid="btaa779-B30" ref-type="bibr">Trincado <italic toggle="yes">et al.</italic>, 2018</xref>). Traditional approaches generally rely on RNA-Seq read mapping to the annotated gene isoforms or on the spliced alignment of reads to the genome. In the second case, spliced aligners, such as STAR (<xref rid="btaa779-B13" ref-type="bibr">Dobin <italic toggle="yes">et al.</italic>, 2013</xref>), employ gene annotations to obtain more accurate results. While gene annotations, especially for humans, are readily available, they are not complete as they are built from healthy individuals. Thus, aberrant isoforms, which play an important role in the development of human diseases (<xref rid="btaa779-B19" ref-type="bibr">Kahles <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btaa779-B29" ref-type="bibr">Tazi <italic toggle="yes">et al.</italic>, 2009</xref>), are usually not annotated. As a consequence, <italic toggle="yes">de novo</italic> (or assembly-first) approaches (<xref rid="btaa779-B17" ref-type="bibr">Haas <italic toggle="yes">et al.</italic>, 2013</xref>; <xref rid="btaa779-B25" ref-type="bibr">Sacomoto <italic toggle="yes">et al.</italic>, 2012</xref>), which potentially detect novel splicing events, have been developed and have gained popularity, even for studying well-annotated organisms (<xref rid="btaa779-B4" ref-type="bibr">Benoit-Pilven <italic toggle="yes">et al.</italic>, 2018</xref>). These approaches are more computationally demanding than traditional annotation-guided ones and pose challenging issues when facing the huge amount of RNA-Seq data that is now available. Furthermore, high-coverage samples are needed for obtaining accurate results with <italic toggle="yes">de novo</italic> approaches, especially for reconstructing low-abundance isoforms.</p>
    <p>When the study is focused on the analysis of a pre-identified set of genes — e.g. those that are known to have a role in tumor progression — a preprocessing step that filters the input RNA-Seq reads, retaining only those likely originated by the genes of interest, could greatly reduce the size of the dataset that must be analyzed (hence speeding up the analysis) without significantly affecting the final results. Existing spliced aligners, such as STAR, could be theoretically adapted to perform the preprocessing step. However, they are aimed at obtaining accurate alignments; hence, they are not fast enough to give a significant speedup of the analysis. For example, if we trivially apply STAR using as a reference the selected gene sequences, the alignment process will take longer than using the full reference genome, since numerous attempts to align the reads sequenced from not-selected genes are performed before discarding it. Other approaches, such as some recently proposed transcript quantification tools (<xref rid="btaa779-B8" ref-type="bibr">Bray <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btaa779-B23" ref-type="bibr">Patro <italic toggle="yes">et al.</italic>, 2014</xref>, <xref rid="btaa779-B24" ref-type="bibr">2017</xref>) or quasi-mappers (<xref rid="btaa779-B27" ref-type="bibr">Srivastava <italic toggle="yes">et al.</italic>, 2016</xref>), are fast enough to be adapted as preprocessing filters but they rely on isoform annotations, hence they might make errors if novel splicing events are supported by the sample, influencing any downstream analysis (<xref rid="btaa779-B9" ref-type="bibr">Conesa <italic toggle="yes">et al.</italic>, 2016</xref>). Other <italic toggle="yes">k</italic>-mer-based approaches are promising (<xref rid="btaa779-B2" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btaa779-B28" ref-type="bibr">Sun <italic toggle="yes">et al.</italic>, 2018</xref>) but they have been designed toward different applications (e.g. indexing and searching large sequencing experiments) hence they achieve a different trade-off between computational efficiency and resulting accuracy.</p>
    <p>For this reason, we propose an alignment-free method that solves the gene-read assignment problem without relying on existing isoform annotations: given a set of genes of interest (gene panel) and a genome-wide RNA-Seq dataset, the goal is to retain only those reads (called <italic toggle="yes">relevant</italic> reads) originating from a gene in the selected set, thus, discarding a potentially huge set of reads not relevant for the downstream analyses. We implemented the method in the tool Shark that, by relying on succinct data structures and multi-threading, is able to quickly analyze huge RNA-Seq datasets on a standard PC. We replicated two studies (<xref rid="btaa779-B4" ref-type="bibr">Benoit-Pilven <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btaa779-B30" ref-type="bibr">Trincado <italic toggle="yes">et al.</italic>, 2018</xref>) aimed at detecting differentially expressed alternative splicing events — one of the most complex and most common tasks in RNA-Seq analysis — and we found that Shark provides a preprocessing step that significantly reduces the running time and/or the memory requirements of computationally intensive downstream analyses, while not negatively impacting their results. We note that, although our method has been specifically designed for RNA-Seq data, it can also be used for genomic reads if, e.g. one is interested in finding variants located on a specific subset of genes.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 The gene assignment problem</title>
      <p>Let Σ be a finite alphabet of size σ and let <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be an ordered sequence of <italic toggle="yes">n</italic> characters drawn from Σ; we say that <italic toggle="yes">s</italic> is a string over Σ of length <italic toggle="yes">n</italic>. From a computational point of view, a <italic toggle="yes">genome</italic>, a <italic toggle="yes">gene locus</italic> and a <italic toggle="yes">transcript</italic> are strings over the alphabet <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi mathvariant="monospace">A</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">C</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">G</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. A gene locus is a substring of the genome, whereas a transcript is a concatenation of pieces (exons) of a gene locus; an RNA-Seq sample is a set of strings (called <italic toggle="yes">reads</italic>) over the same alphabet. A RNA-Seq read is a substring of a transcript, and it is in a 1-to-1 correspondence with a gene locus, referred in the following as the <italic toggle="yes">origin</italic> of the read. Given a string <italic toggle="yes">s</italic> and a positive integer <italic toggle="yes">k</italic>, we say that a substring of <italic toggle="yes">s</italic> of length <italic toggle="yes">k</italic> is a <italic toggle="yes">k</italic>-mer. We denote by <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">KMER</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the multiset of all the <italic toggle="yes">k</italic>-mers of <italic toggle="yes">s</italic> (observe that the same <italic toggle="yes">k</italic>-mer might occur multiple times). As usual (<xref rid="btaa779-B3" ref-type="bibr">Belazzougui <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btaa779-B12" ref-type="bibr">Denti <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btaa779-B20" ref-type="bibr">Kokot <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa779-B22" ref-type="bibr">Marçais and Kingsford, 2011</xref>), to account for the double stranded nature of the human genome, when we refer to a <italic toggle="yes">k</italic>-mer, we implicitly refer to its <italic toggle="yes">canonical form</italic>, that is the lexicographically smaller sequence between the <italic toggle="yes">k</italic>-mer and its reverse-complement. Given a read <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we refer to the pair <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with the term <italic toggle="yes">base</italic>. Note that, the same character appearing at two different positions of <italic toggle="yes">s</italic> are two distinct bases. Moreover, we say that a base <italic toggle="yes">b</italic> of the read <italic toggle="yes">s</italic> is shared with the gene <italic toggle="yes">g</italic> if there exists a <italic toggle="yes">k</italic>-mer of <italic toggle="yes">s</italic> that includes <italic toggle="yes">b</italic> and is equal to a <italic toggle="yes">k</italic>-mer of <italic toggle="yes">g</italic>. We denote by <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the set of the bases of <italic toggle="yes">s</italic> shared by <italic toggle="yes">g</italic>. In other words, <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the set of all the bases of <italic toggle="yes">s</italic> such that there exists a <italic toggle="yes">k</italic>-mer in the intersection between <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">KMER</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">KMER</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that includes the base.</p>
      <p>To assign a read to its origin gene, we adapt the following criterion as a proxy. A gene <italic toggle="yes">g</italic> is the putative origin of a read <italic toggle="yes">s</italic> if and only if the ratio <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is greater or equal than a given threshold τ and for no other gene <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. The rationale behind this criterion is to have a measure of similarity between a read and a gene without aligning them, which takes into account that introns are spliced out from transcripts and therefore from an RNA-Seq read. Observe that by this definition, and due to genome repetitions, a read may have multiple origin genes. We denote as <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ORIGIN</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the set of putative origin genes of a read <italic toggle="yes">s</italic>.</p>
      <p>We now provide a formal definition of the problem, we tackle in this article, namely the <italic toggle="yes">Gene Assignment Problem</italic>.</p>
      <p>Problem 1 (Gene Assignment Problem). Let <italic toggle="yes">S</italic> be a set of RNA-Seq reads sequenced from a set <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> of genes, let <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>⊆</mml:mo><mml:mi mathvariant="script">G</mml:mi></mml:mrow></mml:math></inline-formula> be a gene panel, i.e. a set of genes of interest. The <italic toggle="yes">gene assignment</italic> of <italic toggle="yes">S</italic> with respect to <italic toggle="yes">G</italic> and parameters <italic toggle="yes">k</italic> and τ is a set <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> elements such that <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> is the set of reads that originate from <italic toggle="yes">g<sub>i</sub></italic>, i.e. for each <italic toggle="yes">s</italic> in <italic toggle="yes">S<sub>i</sub></italic> the following conditions hold: (i) <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo>≥</mml:mo><mml:mo>τ</mml:mo></mml:mrow></mml:math></inline-formula>, (ii) for no other gene <italic toggle="yes">g<sub>j</sub></italic>, <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, and the <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> sets have been computed on <italic toggle="yes">k</italic>-mers.</p>
      <p>Note that, a gene assignment is not necessarily a partition of the input sample. Indeed, a read may have more than one origin gene and some read may have no origin gene. For ease of presentation, in the rest of the article, we will refer to this problem as the gene assignment of <italic toggle="yes">S</italic> with respect to <italic toggle="yes">G</italic>, without specifying <italic toggle="yes">k</italic> and τ.</p>
      <p>Note also that the Gene Assignment Problem here defined is robust to sequence polymorphisms. Indeed, from the viewpoint of the definition of the problem, sequence polymorphisms are indistinguishable from sequencing errors, and parameters <italic toggle="yes">k</italic> and τ allow (as we show in Section 3) to tweak the accuracy toward better specificity (allowing less errors) or better sensitivity (allowing more errors).</p>
      <p>The algorithmic approach, we propose to solve this problem uses two well-known data structures that we will now briefly introduce. A <italic toggle="yes">bit vector</italic> is a sequence of binary values that supports rank and select queries in constant time using additional sublinear space. Let <italic toggle="yes">B</italic> be a bit vector and let <italic toggle="yes">i</italic> be a positive integer, <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ran</mml:mi><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the number of values equal to <italic toggle="yes">d</italic> in the portion <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">B</italic>, whereas <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">selec</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the position of the <italic toggle="yes">i</italic>-th value of <italic toggle="yes">B</italic> set to <italic toggle="yes">d</italic>. Clearly, <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ran</mml:mi><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is not defined if <italic toggle="yes">i</italic> is greater than the size of <italic toggle="yes">B</italic> and <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">selec</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is not defined if fewer than <italic toggle="yes">i</italic> values of <italic toggle="yes">B</italic> are set to <italic toggle="yes">d</italic>. A <italic toggle="yes">Bloom filter</italic> (<xref rid="btaa779-B7" ref-type="bibr">Bloom, 1970</xref>) is a probabilistic data structure used to answer membership queries. It consists of a bit vector of fixed size <italic toggle="yes">m</italic> and <italic toggle="yes">z</italic> hash functions, each one mapping an object to a position of the bit vector. Adding an object to a Bloom filter consists in setting to 1 the bits at the positions of the bit vector computed by the hash functions for that object. Testing if an object is in the set consists in checking whether all the bits at the positions computed by the hash functions for that object are set to 1. Due to hash collisions, an element may be reported as present even though it is not in the set, resulting in a false positive. Anyway, a low false positive rate can be achieved via a suitable choice of the bit vector size and the number of hash functions.</p>
    </sec>
    <sec>
      <title>2.2 Algorithm</title>
      <p>In this section, we describe the algorithmic approach, we propose to solve the computational problem introduced in the previous section. The algorithm for computing the gene assignment of an RNA-Seq sample <italic toggle="yes">S</italic> with respect to a set <italic toggle="yes">G</italic> of genes is composed of two steps: first, for each read <italic toggle="yes">s</italic> in the sample, we compute the set <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ORIGIN</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of its origin genes, then, we derive the gene assignment of <italic toggle="yes">S</italic> from those sets by grouping together reads with the same origin gene.</p>
      <p>An efficient solution to this problem essentially requires that we index the gene sequences. A simple procedure stores a dictionary that maps each <italic toggle="yes">k</italic>-mer appearing in at least one gene to the genes in which it occur, and then use it to map the <italic toggle="yes">k</italic>-mers of the reads to the genes, determining the origin genes read by read. Although effective, this approach would require an excessive amount of memory to store the dictionary if we need to track a significant amount of <italic toggle="yes">k</italic>-mers of the genes, especially since we have to store explicitly the <italic toggle="yes">k</italic>-mers sequences. For this reason, we designed a novel data structure that couples efficient access with small space usage, albeit introducing some false positives.</p>
      <p>The data structure we propose to efficiently compute a gene assignment consists of a Bloom filter <italic toggle="yes">BF</italic>, a bit vector <italic toggle="yes">P</italic> and a vector of integers <italic toggle="yes">I</italic>. We use the three components of the data structure as follows: the Bloom filter stores the set of <italic toggle="yes">k</italic>-mers of the genes in <italic toggle="yes">G</italic>, the vector of integers compactly stores the subset of genes in which each <italic toggle="yes">k</italic>-mer appears and the bit vector tags the boundaries of the different subsets in the integer vector.</p>
      <p>To build this data structure, we designed a three-step process, also presented in Algorithm 1. First, we associate to each gene in <italic toggle="yes">G</italic> an incremental ID and store the gene-ID mapping in a dictionary <italic toggle="yes">GENEMAP</italic>, which is then given as argument to Algorithm 1. Notice that, we achieve an important reduction in memory usage by storing only the gene-ID instead of its entire sequence.</p>
      <p>Then, we scan the gene sequences and we store each <italic toggle="yes">k</italic>-mer in <italic toggle="yes">BF</italic> by using a single hash function <italic toggle="yes">H</italic>, mapping each <italic toggle="yes">k</italic>-mer to a specific position in the Bloom filter <italic toggle="yes">BF</italic> (lines 1–5). Once we complete this scan, <italic toggle="yes">BF</italic> stores the set of <italic toggle="yes">k</italic>-mers of all input genes. Since the number of <italic toggle="yes">k</italic>-mers indexed in the Bloom filter is significantly smaller than the size of the Bloom filter, using a single hash function improves efficiency and only slightly degrades accuracy, as shown by various works (<xref rid="btaa779-B12" ref-type="bibr">Denti <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btaa779-B28" ref-type="bibr">Sun <italic toggle="yes">et al.</italic>, 2018</xref>). Efficiency improves in this setting because using multiple hash functions increases the number of random memory accesses, thus increasing the amount of cache misses.</p>
      <p>For each 1 in <italic toggle="yes">BF</italic>, we create an empty list <italic toggle="yes">L<sub>r</sub></italic> (lines 6–7), where <italic toggle="yes">L<sub>r</sub></italic> corresponds to the <italic toggle="yes">r</italic>-th bit stored in the Bloom filter. We will then use <italic toggle="yes">L<sub>r</sub></italic> to store a set of back-references to the genes where each associated <italic toggle="yes">k</italic>-mer appears. At the end of this step, each 1 in <italic toggle="yes">BF</italic> is associated with a subset of genes back-references (represented as a list of IDs) stored in memory. Then, we scan all the <italic toggle="yes">k</italic>-mers in each gene of <italic toggle="yes">G</italic>, we compute the corresponding 1 in <italic toggle="yes">BF</italic> and (via a rank) the corresponding list <italic toggle="yes">L<sub>r</sub></italic> to which the gene-ID must be appended (lines 8–12). Finally all duplicates are removed from the lists <italic toggle="yes">L<sub>r</sub></italic>.</p>
      <p>The third step consists of concatenating the lists <italic toggle="yes">L<sub>r</sub></italic> to obtain the integer vector <italic toggle="yes">I</italic> that contains all back-references. At the same time (lines 15–19), we build the boundary vector <italic toggle="yes">P</italic>, which has a 1 in each position <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>≤</mml:mo><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula> (i.e. the 1s mark the end of each list).</p>
      <p>The example in <xref rid="btaa779-F1" ref-type="fig">Figure 1</xref> describes how this data structure is queried to retrieve the identifiers of the genes associated to a given <italic toggle="yes">k</italic>-mer. First, the hash function <italic toggle="yes">H</italic> maps the 5-mer <italic toggle="yes">gactgg</italic> to position <italic toggle="yes">h</italic>. Since a 1 is at position <italic toggle="yes">h</italic> of <italic toggle="yes">BF</italic>, we suppose that the <italic toggle="yes">k</italic>-mer is in it and we compute how many 1s appear before <italic toggle="yes">h</italic> computing in constant time <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ran</mml:mi><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Then, since the 1 stored in <italic toggle="yes">h</italic> is the <italic toggle="yes">v</italic>-th 1 of <italic toggle="yes">BF</italic>, i.e. the <italic toggle="yes">k</italic>-mer is the <italic toggle="yes">v</italic>-th element according to the order of <italic toggle="yes">k</italic>-mers given by <italic toggle="yes">H</italic>, we retrieve the positions of the <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th and the <italic toggle="yes">v</italic>-th 1 in <italic toggle="yes">P</italic> using <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">selec</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Those positions are the boundaries on <italic toggle="yes">I</italic> of the subset of genes mapped to the <italic toggle="yes">k</italic>-mer.</p>
      <fig position="float" id="btaa779-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Relation between the Bloom filter <italic toggle="yes">BF</italic>, the bit vector <italic toggle="yes">P</italic>, and the vector <italic toggle="yes">I</italic>. To retrieve the identifiers of the genes containing a <italic toggle="yes">k</italic>-mer <italic toggle="yes">e</italic> (gacttg in the figure), we compute its image <italic toggle="yes">h</italic> through <italic toggle="yes">H</italic> and, if <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the <italic toggle="yes">v</italic>-th 1 of <italic toggle="yes">BF</italic>, the positions of the <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th and the <italic toggle="yes">v</italic>-th 1 of <italic toggle="yes">P</italic>, denoted as <italic toggle="yes">p</italic><sub>1</sub> and <italic toggle="yes">p</italic><sub>2</sub>, respectively, can be found via rank and select operations. The interval of <italic toggle="yes">I</italic> from <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <italic toggle="yes">p</italic><sub>2</sub> stores the set <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">GENES</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the indices of the genes containing the <italic toggle="yes">k</italic>-mer <italic toggle="yes">e</italic></p>
        </caption>
        <graphic xlink:href="btaa779f1" position="float"/>
      </fig>
      <p>
        <boxed-text id="btaa779-BOX1" position="float">
          <p>
            <inline-graphic xlink:href="btaa779ilf1.jpg"/>
          </p>
        </boxed-text>
      </p>
      <p>Once we have built the data structure <inline-formula id="IE42"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>, as described above, we iterate over each read of the sample and we query <italic toggle="yes">D</italic>(<italic toggle="yes">G</italic>) to compute the set of its origin genes. For each read <italic toggle="yes">s</italic>, the procedure scans the multiset <inline-formula id="IE43"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">KMER</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">k</italic>-mers of <italic toggle="yes">s</italic> from left to right and maintains, for each gene <italic toggle="yes">g</italic>, the rightmost position <inline-formula id="IE44"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of a base of <italic toggle="yes">s</italic> shared by <italic toggle="yes">g</italic> (or −1 if such a base does not exist) and the variable <inline-formula id="IE45"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">car</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that contains the number of bases of <italic toggle="yes">g</italic> that are shared with some <italic toggle="yes">k</italic>-mers of <italic toggle="yes">s</italic> seen so far — at the end, <inline-formula id="IE46"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">car</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> will be equal to <inline-formula id="IE47"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. Let <italic toggle="yes">e</italic> be the <italic toggle="yes">i</italic>-th leftmost <italic toggle="yes">k</italic>-mer of <italic toggle="yes">s</italic> and let <inline-formula id="IE48"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">GENES</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the set of genes containing <italic toggle="yes">e</italic> [obtained by querying <italic toggle="yes">D</italic>(<italic toggle="yes">G</italic>) as illustrated in <xref rid="btaa779-F1" ref-type="fig">Fig. 1]</xref>. Then, for each gene <italic toggle="yes">g</italic> in <inline-formula id="IE49"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">GENES</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the procedure updates <inline-formula id="IE50"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">car</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> by adding the number of new bases covered by <italic toggle="yes">e</italic> and shared between <italic toggle="yes">s</italic> and <italic toggle="yes">g</italic> (computed as <inline-formula id="IE51"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>), and sets <inline-formula id="IE52"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to the last position in <italic toggle="yes">s</italic> that is in <italic toggle="yes">e</italic>, equal to <italic toggle="yes">i</italic> +<italic toggle="yes"> k</italic>. At the end of the scan, each <inline-formula id="IE53"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">car</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is clearly the cardinality of <inline-formula id="IE54"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and computing the origin gene of the read is trivial.</p>
    </sec>
    <sec>
      <title>2.3 Computational complexity</title>
      <p>Let us assume that <italic toggle="yes">H</italic> is computed in constant time since <italic toggle="yes">k</italic> is fixed and, for practical purposes, it is not &gt;32 (hence each <italic toggle="yes">k</italic>-mer can be represented in a single memory word). Constructing the index data structure <inline-formula id="IE55"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> requires <inline-formula id="IE56"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>g</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time (assuming that <inline-formula id="IE57"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ran</mml:mi><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is computed in constant time) since duplicates (if any) in each list <italic toggle="yes">L<sub>i</sub></italic> are adjacent. Querying <italic toggle="yes">D</italic>(<italic toggle="yes">G</italic>) for the set of origin genes of a single <italic toggle="yes">k</italic>-mer <italic toggle="yes">e</italic> requires <inline-formula id="IE58"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">GENES</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (assuming that also <inline-formula id="IE59"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">selec</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is computed in constant time). Computing the origin gene of a read <italic toggle="yes">s</italic> requires <inline-formula id="IE60"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="italic">KMER</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mi mathvariant="monospace">ENES</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that is trivially upper bounded by <inline-formula id="IE61"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.4 Implementation</title>
      <p>The method described in Section 2.2 has been implemented in C++ and is freely available at <ext-link xlink:href="https://github.com/AlgoLab/shark" ext-link-type="uri">https://github.com/AlgoLab/shark</ext-link> and published on BioConda (<xref rid="btaa779-B16" ref-type="bibr">Grüning <italic toggle="yes">et al.</italic>, 2018</xref>). The program uses the implementation of bit vectors and of the associated rank and select operations provided by sdsl (<xref rid="btaa779-B14" ref-type="bibr">Gog <italic toggle="yes">et al.</italic>, 2014</xref>).</p>
      <p>The tool, called Shark, takes as input a FASTA file containing the set of gene regions of interest and an RNA-Seq sample in FASTQ format. For each read of the sample, the tool computes its set of (putative) origin genes (computing the gene assignment is then trivial). It is possible to tune the computation of the gene assignment by setting the following parameters: the <italic toggle="yes">k</italic>-mer size <italic toggle="yes">k</italic>, the confidence τ and the size <italic toggle="yes">m</italic> of the Bloom filter. The tool also allows to discard <italic toggle="yes">k</italic>-mers spanning bases whose quality is less than a given threshold <italic toggle="yes">q</italic>.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>To assess our method, we performed two different experimental analyses on simulated and real data. A first exploratory analysis on simulated data was performed to test the accuracy and the efficiency of Shark, especially with respect to its input parameters <italic toggle="yes">k</italic>, τ and <italic toggle="yes">q</italic>. Furthermore, we also investigated the influence of read length and gene size on the accuracy of Shark. The goal of the second part of the analysis was to evaluate, on real data, the effectiveness of Shark in speeding up four different pipelines (three mapping-first pipelines, Section 3.2, and an assembly-first pipeline, Section 3.3) for a common task in RNA-Seq data analysis, namely differential analysis of alternative splicing events, without affecting the results on the selected genes. All the experiments were performed on a 64 bit Linux (Kernel 4.4.0) system equipped with four 8-core Intel<sup>®</sup> Xeon 2.30 GHz processors and 256 GB of RAM. Information on how to reproduce the experiments are available at <ext-link xlink:href="https://github.com/AlgoLab/shark_experiments" ext-link-type="uri">https://github.com/AlgoLab/shark_experiments</ext-link> in the form of a Conda environment and several Snakemake workflows (<xref rid="btaa779-B21" ref-type="bibr">Köster and Rahmann, 2012</xref>). To reproduce the assembly-first experiments, we refer the reader to <ext-link xlink:href="http://kissplice.prabi.fr/pipeline_ks_farline/" ext-link-type="uri">http://kissplice.prabi.fr/pipeline_ks_farline/</ext-link>.</p>
    <sec>
      <title>3.1 Simulated data</title>
      <p>We performed an exploratory analysis on simulated data to test the accuracy and the efficiency of our method, especially with respect to its input parameters <italic toggle="yes">k</italic>, τ and <italic toggle="yes">q</italic>. To this aim, we considered the 9403 genes of Human chromosomes 1, 17 and 21 (<italic toggle="yes">Ensembl release 97</italic>) (<xref rid="btaa779-B10" ref-type="bibr">Cunningham <italic toggle="yes">et al.</italic>, 2019</xref>) and we simulated an RNA-Seq sample of 10 million 100 bp-long single-end reads using Flux Simulator (<xref rid="btaa779-B15" ref-type="bibr">Griebel <italic toggle="yes">et al.</italic>, 2012</xref>) (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref> for the simulation parameters). From the full set of genes, we selected 10 random subsets of 100 genes, producing 10 different instances. For each instance, Shark indexed the gene panel, consisting of the 100 considered genes, and then filtered the entire simulated RNA-Seq sample with respect to it. To assess accuracy and efficiency of Shark with respect to input parameters, we ran Shark with any combination of <inline-formula id="IE62"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>13</mml:mn><mml:mo>,</mml:mo><mml:mn>17</mml:mn><mml:mo>,</mml:mo><mml:mn>23</mml:mn><mml:mo>,</mml:mo><mml:mn>27</mml:mn><mml:mo>,</mml:mo><mml:mn>31</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>τ</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.4</mml:mn><mml:mo>,</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>0.8</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE63"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>20</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Furthermore, we tested Shark also by dropping reads that are assigned to more than one origin gene (‘single mode’). In such a mode, Shark completely discards ambiguous assignments (if a read can be assigned to two or more genes, then no association at all is given) and it is useful in these experiments to better understand the accuracy of Shark. The size of the Bloom filter was set to 1 GB (preliminary experiments showed that larger Bloom filters did not improve the accuracy of the prediction). Shark was allowed to use four threads to speed up the computation.</p>
      <p>The accuracy of Shark in computing the gene assignment was measured in terms of <italic toggle="yes">precision</italic> and <italic toggle="yes">recall</italic> as follows. Since the input reads have been simulated, we know the actual origin gene of each read. Let <inline-formula id="IE64"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="script">G</mml:mi></mml:mrow></mml:math></inline-formula> be the subset of genes of interest and <inline-formula id="IE65"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> be the set of genes which the set of reads <italic toggle="yes">S</italic> have been simulated from. Let <inline-formula id="IE66"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the output of Shark on <italic toggle="yes">S</italic> and <italic toggle="yes">G</italic> (we recall that <inline-formula id="IE67"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> is the subset of reads assigned to <italic toggle="yes">G<sub>i</sub></italic> by Shark). Then, each <inline-formula id="IE68"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a <italic toggle="yes">true positive</italic> (<inline-formula id="IE69"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>) if <italic toggle="yes">s</italic> was simulated from <italic toggle="yes">g<sub>i</sub></italic>, and it is a <italic toggle="yes">false positive</italic> (<inline-formula id="IE70"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>) otherwise. Finally, each read <inline-formula id="IE71"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> simulated from gene <italic toggle="yes">g<sub>i</sub></italic> such that <inline-formula id="IE72"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>∈</mml:mo></mml:menclose><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a <italic toggle="yes">false negative</italic> (<inline-formula id="IE73"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>). More intuitively, we consider each read associated to the correct origin gene of interest as a true positive and each read assigned to a gene of interest that was not simulated from that gene as a false positive. We note that with this definition, false positives occur in two slightly different cases: (i) when a read is simulated from a gene of interests and it is assigned to a different gene of the panel and (ii) when a read is simulated from a gene not in the gene panel and it is assigned to any gene in the gene panel. Finally, we consider as false negative each read simulated from a gene in the gene panel that was not assigned to the correct gene. Notice that, when Shark is run in multiple mode a read might be assigned to more than one gene, thus a read with two assignments (one to the correct gene and one to another gene) might induce both a true positive and a false positive. Moreover, when a read is assigned only to a wrong gene, it induces both a false positive (because it was assigned to the wrong gene) and a false negative (because it was not assigned to the right gene). Then, precision is defined as <inline-formula id="IE74"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>, while recall as <inline-formula id="IE75"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. Efficiency was measured in terms of running time and memory peak (using the/usr/bin/time system tool).</p>
      <p><xref rid="btaa779-F2" ref-type="fig">Figure 2</xref> reports the precision/recall curves for the different combinations of parameters (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref> for the entire set of results). The first important observation is that Shark achieves a good accuracy in terms of recall. Indeed, for sensible choices of the parameters, the recall is at least 99%, i.e. on average at most 1% of the reads that originated from the chosen subset of genes was discarded. The second observation is that the choice of the values for the parameters <italic toggle="yes">k</italic> and τ allows to achieve different trade-offs between precision and recall. Indeed, as <italic toggle="yes">k</italic> (or τ) increases, Shark becomes more precise (at the expense of recall).</p>
      <fig position="float" id="btaa779-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>Accuracy results — exploratory analysis. Accuracy is shown in terms of average precision and average recall obtained across the 10 performed runs. Lines connect data points with <inline-formula id="IE76"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.4</mml:mn><mml:mo>,</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>0.8</mml:mn><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula></p>
        </caption>
        <graphic xlink:href="btaa779f2" position="float"/>
      </fig>
      <p>The third observation is that Shark (as expected, since it is a <italic toggle="yes">k</italic>-mer-based approach) is sensitive to sequencing errors. Indeed, if low-quality bases are not filtered out (<italic toggle="yes">q</italic> = 0), the recall rapidly decreases under 98% as τ increases. However, the simple approach of filtering out low-quality bases allows to reduce the loss of recall as the precision sensibly increases. For example, for <italic toggle="yes">q</italic> = 10 (i.e. bases with quality &lt;10 are not considered) and <italic toggle="yes">k</italic> = 17, when τ increases from 0.4 to 0.6, we have that the precision gains 7.13 percentage points (from 21.67% to 28.80%) while the recall only decreases of 0.21% points (from 99.67% to 99.46%). Interestingly, an aggressive low-quality filter (<italic toggle="yes">q</italic> = 20) generally decreases the accuracy of Shark. This is probably due to the fact that, under this setting, the set of <italic toggle="yes">k</italic>-mers extracted from each read is too small for reliably finding its origin gene.</p>
      <p>As explained in Section 2.2, more than one gene can be assigned to a single read. To assess how these ambiguous assignments influence the accuracy, we ran Shark excluding any multiple assignment (‘single mode’). The accuracy of Shark in ‘single mode’ compared with the original ‘multiple mode’ is sensibly higher in terms of precision and slightly lower in terms of recall. For example, for <italic toggle="yes">k</italic> = 17, <inline-formula id="IE77"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.6</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">q</italic> = 10, in multiple mode the precision is 28.8% while in single mode it is 32.2%, whereas the recall is 99.46% and 99.28% in multiple and single mode, respectively. Also in this case, keeping or discarding ambiguous assignments is a user’s choice, depending on the choice between higher recall or higher precision.</p>
      <p>This experiment shows how accuracy is determined by the choice of the parameters. The results suggest that a good trade-off between precision and recall can be achieved with <italic toggle="yes">k</italic> = 17, <inline-formula id="IE78"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.6</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">q</italic> = 10.</p>
      <p>In terms of computational requirements, Shark never required more than 1.5 GB of RAM (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>), that is an amount of memory nowadays available on any desktop or laptop computer. Furthermore, using four threads, it never required more than 1 min to complete and, in particular, it never required more than 40 s for <inline-formula id="IE79"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mn>17</mml:mn></mml:mrow></mml:math></inline-formula> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref>). Albeit this experiment has been performed on a server platform, we expect that the running time will be practically negligible even on standard computers.</p>
      <p>We also investigated the influence of read length and gene size on the accuracy and on the computational requirements of Shark (Supplementary Section S2). We observed that neither the read length nor the gene size affects negatively the overall accuracy of Shark. Furthermore, Shark never required more than 2 min and 5 GB of RAM to complete any analysis.</p>
      <p>We also investigated how the number of genes of interest, i.e. the size of the input gene panel, affects the accuracy and efficiency of Shark. To this aim, we considered the 9403 genes from the 3 chromosomes analyzed in the previous experiments and we created 7 different gene panels of increasing sizes: from 100 genes to 9403 genes. We note that considering the largest gene panel is equivalent to filtering the reads with respect to the entire set of genes they were sequenced from (indeed, in that case, <inline-formula id="IE80"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="script">G</mml:mi></mml:mrow></mml:math></inline-formula>).</p>
      <p>We filtered with Shark, the 10 M single-end read sample simulated with Flux Simulator with respect to each panel and we evaluated the accuracy and efficiency of Shark as done in our previous analysis. We ran Shark with four threads in both single and multiple modes, setting <italic toggle="yes">k</italic> = 17, <inline-formula id="IE81"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.6</mml:mn></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">q</italic> = 10, and the size of the Bloom filter to 1 GB. <xref rid="btaa779-T1" ref-type="table">Table 1</xref> reports the results of this analysis. First of all, we observe that, by increasing the input panel size, Shark behaves differently if ran in single or multiple mode. Indeed, increasing the number of genes of interest allows Shark (ran in multiple mode) to increase its precision as well (from 20% to 69%), while not affecting its recall, which remains really high (<inline-formula id="IE82"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>99</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>). The increase in precision can be explained by the fact that, as the gene panel becomes larger, Shark is able to associate each read to the correct gene, while, if the correct origin gene is not in the panel, Shark associates the read to a different (but similar) gene of the panel. This hypothesis is further confirmed by the data on single mode. Indeed, as the gene panel size increases, Shark (single mode) is able to achieve a high level of precision (<inline-formula id="IE83"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>99</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> with the largest gene panel tested) at the expense of a lower recall that decreases from 99% to 75%. This was expected since the gene panel also contains similar genes (e.g. overlapping genes, albeit on opposite strands), thus associations to those genes become ambiguous and are discarded in single mode. A further analysis of accuracy with respect to the similarity among the genes of interest is presented in the accompanying repository (<ext-link xlink:href="https://github.com/AlgoLab/shark_experiments" ext-link-type="uri">https://github.com/AlgoLab/shark_experiments</ext-link>) but proved to be elusive due to the interplay of relative expression of overlapping genes (among the other factors).</p>
      <table-wrap position="float" id="btaa779-T1">
        <label>Table 1.</label>
        <caption>
          <p>Accuracy and efficiency results — varying gene panel sizes</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="4" rowspan="1">Shark (multiple mode)<hr/></th>
              <th colspan="4" rowspan="1">Shark (single mode)<hr/></th>
              <th colspan="4" rowspan="1">RapMap<hr/></th>
              <th colspan="4" rowspan="1">Puffaligner<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Gene panel size</th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">P</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">R</italic>
              </th>
              <th rowspan="1" colspan="1">Time (s)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">P</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">R</italic>
              </th>
              <th rowspan="1" colspan="1">Time (s)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">P</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">R</italic>
              </th>
              <th rowspan="1" colspan="1">Time (s)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">P</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">R</italic>
              </th>
              <th rowspan="1" colspan="1">Time (s)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">19.6</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">27</td>
              <td rowspan="1" colspan="1">1.41</td>
              <td rowspan="1" colspan="1">21.9</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">33</td>
              <td rowspan="1" colspan="1">1.41</td>
              <td rowspan="1" colspan="1">21.5</td>
              <td rowspan="1" colspan="1">99.1</td>
              <td rowspan="1" colspan="1">51</td>
              <td rowspan="1" colspan="1">0.20</td>
              <td rowspan="1" colspan="1">3.4</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">47</td>
              <td rowspan="1" colspan="1">0.22</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">250</td>
              <td rowspan="1" colspan="1">45.7</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">35</td>
              <td rowspan="1" colspan="1">1.43</td>
              <td rowspan="1" colspan="1">50.3</td>
              <td rowspan="1" colspan="1">99.2</td>
              <td rowspan="1" colspan="1">36</td>
              <td rowspan="1" colspan="1">1.43</td>
              <td rowspan="1" colspan="1">52.1</td>
              <td rowspan="1" colspan="1">99.0</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">0.28</td>
              <td rowspan="1" colspan="1">6.6</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">0.27</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">500</td>
              <td rowspan="1" colspan="1">54.2</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">58</td>
              <td rowspan="1" colspan="1">1.46</td>
              <td rowspan="1" colspan="1">60.4</td>
              <td rowspan="1" colspan="1">98.1</td>
              <td rowspan="1" colspan="1">58</td>
              <td rowspan="1" colspan="1">1.46</td>
              <td rowspan="1" colspan="1">60.8</td>
              <td rowspan="1" colspan="1">99.1</td>
              <td rowspan="1" colspan="1">79</td>
              <td rowspan="1" colspan="1">0.48</td>
              <td rowspan="1" colspan="1">7.1</td>
              <td rowspan="1" colspan="1">99.4</td>
              <td rowspan="1" colspan="1">90</td>
              <td rowspan="1" colspan="1">0.36</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">1000</td>
              <td rowspan="1" colspan="1">58.6</td>
              <td rowspan="1" colspan="1">99.6</td>
              <td rowspan="1" colspan="1">103</td>
              <td rowspan="1" colspan="1">1.57</td>
              <td rowspan="1" colspan="1">66.6</td>
              <td rowspan="1" colspan="1">98.4</td>
              <td rowspan="1" colspan="1">96</td>
              <td rowspan="1" colspan="1">1.57</td>
              <td rowspan="1" colspan="1">65.6</td>
              <td rowspan="1" colspan="1">98.9</td>
              <td rowspan="1" colspan="1">110</td>
              <td rowspan="1" colspan="1">0.87</td>
              <td rowspan="1" colspan="1">9.1</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">120</td>
              <td rowspan="1" colspan="1">0.43</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">2500</td>
              <td rowspan="1" colspan="1">60.7</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">241</td>
              <td rowspan="1" colspan="1">1.86</td>
              <td rowspan="1" colspan="1">73.7</td>
              <td rowspan="1" colspan="1">91.7</td>
              <td rowspan="1" colspan="1">248</td>
              <td rowspan="1" colspan="1">1.86</td>
              <td rowspan="1" colspan="1">66.9</td>
              <td rowspan="1" colspan="1">98.9</td>
              <td rowspan="1" colspan="1">174</td>
              <td rowspan="1" colspan="1">1.81</td>
              <td rowspan="1" colspan="1">13.6</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">184</td>
              <td rowspan="1" colspan="1">0.70</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">5000</td>
              <td rowspan="1" colspan="1">65.2</td>
              <td rowspan="1" colspan="1">99.6</td>
              <td rowspan="1" colspan="1">441</td>
              <td rowspan="1" colspan="1">2.47</td>
              <td rowspan="1" colspan="1">84.7</td>
              <td rowspan="1" colspan="1">85.0</td>
              <td rowspan="1" colspan="1">492</td>
              <td rowspan="1" colspan="1">2.47</td>
              <td rowspan="1" colspan="1">71.9</td>
              <td rowspan="1" colspan="1">98.8</td>
              <td rowspan="1" colspan="1">325</td>
              <td rowspan="1" colspan="1">3.79</td>
              <td rowspan="1" colspan="1">26.2</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">277</td>
              <td rowspan="1" colspan="1">1.00</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">10 000</td>
              <td rowspan="1" colspan="1">68.9</td>
              <td rowspan="1" colspan="1">99.6</td>
              <td rowspan="1" colspan="1">898</td>
              <td rowspan="1" colspan="1">3.38</td>
              <td rowspan="1" colspan="1">99.9</td>
              <td rowspan="1" colspan="1">75.1</td>
              <td rowspan="1" colspan="1">934</td>
              <td rowspan="1" colspan="1">3.38</td>
              <td rowspan="1" colspan="1">75.5</td>
              <td rowspan="1" colspan="1">98.7</td>
              <td rowspan="1" colspan="1">526</td>
              <td rowspan="1" colspan="1">6.37</td>
              <td rowspan="1" colspan="1">64.7</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">431</td>
              <td rowspan="1" colspan="1">1.55</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: Accuracy is shown in terms of precision (<italic toggle="yes">P</italic>) and recall (<italic toggle="yes">R</italic>), while efficiency in terms of running time (Time, in seconds) and peak memory usage (RAM, in GB).</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The experiment confirmed that Shark is efficient: on the largest gene panel, it required ∼15 min and 3 GB of RAM, an amount nowadays available on any PC.</p>
      <p>To better evaluate Shark accuracy and efficiency, we compared it against RapMap (<xref rid="btaa779-B27" ref-type="bibr">Srivastava <italic toggle="yes">et al.</italic>, 2016</xref>), a quasi-mapper, and Puffaligner, an aligner based on compacted colored de Bruijn graphs (<xref rid="btaa779-B1" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2018</xref>). Although these tools are not designed to directly compute a gene assignment and the corresponding partitioning of the input RNA-Seq sample, they can be used to perform very fast read alignment that can be post-processed to extract the corresponding gene assignment. We provided the gene sequences to RapMap whereas we provided both the gene sequences and the gene transcripts to Puffaligner (as suggested in the project documentation). We ran both the tools with four threads. To compute their precision and recall, we adopted the same measures used to evaluate Shark.</p>
      <p><xref rid="btaa779-T1" ref-type="table">Table 1</xref> reports the results of this comparison. First of all, we observe that RapMap and Puffaligner behave more similarly to Shark ran in multiple mode than to Shark ran in single mode. Indeed, both the aligners report primary and secondary alignments and in our analysis, we considered both of them (but only an alignment per gene). Instead, if we consider only the primary alignments (data not shown), we observe a straight drop in the recall of the two tools: most of the correct assignments are indeed derived from secondary alignments. Furthermore, since RapMap and Puffaligner are not able to compute spliced alignments, we relaxed any additional check performed by these tools in order to accept even low-quality alignments (please refer to <ext-link xlink:href="https://github.com/AlgoLab/shark_experiments" ext-link-type="uri">https://github.com/AlgoLab/shark_experiments</ext-link> for the list of parameters that have been used). Otherwise, we would have observed lower levels of recall.</p>
      <p>In this non-standard setting, we were able to let RapMap and Puffaligner achieve a very high recall (<inline-formula id="IE84"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>99</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>). Anyway, Shark is able to achieve even better recall than the other two tools for all panel sizes.</p>
      <p>Surprisingly, precision of Puffaligner is significantly lower than that of Shark and RapMap (<inline-formula id="IE85"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula> times lower) for all panel sizes but the largest one. In our opinion, this result suggests that Puffaligner, in its current form and despite its merits as aligner, is not a suitable choice for computing a gene assignment.</p>
      <p>RapMap is slightly more precise than Shark for all panel sizes but the smallest one, at the expense of a slightly less recall. We remark that, for the specific purpose Shark has been designed, achieving better recall is more important than achieving better precision, since discarding potentially relevant reads may introduce biases in the downstream analysis whereas lower precision will only lead to lower improvements in the running times.</p>
      <p>In terms of memory, all the tools were able to complete the analysis using &lt;4 GB of RAM. The only exception is RapMap on the largest gene panel, which required more than 6 GB of memory (while Shark and Puffaligner used 3.4 and 1.6 GB, respectively). On gene panels composed by at most 1000 genes, Shark, which has been designed for panels whose size is in this range, is slightly faster than the other two tools.</p>
      <p>We remark that RapMap and Puffaligner were run with non-standard settings in order to achieve levels of recall comparable to those of Shark. However, especially for RapMap, this means that alignments of only a rather small portion of the read were accepted. Otherwise, since neither RapMap nor Puffaligner computes spliced alignments, they would not accept reads mapping to a splice junction. For this reason, we argue that, as the read length increases, Shark would be able to assign reads more accurately than the other twos. Indeed, Shark would map all the <italic toggle="yes">k</italic>-mers to the gene sequences, whereas RapMap (and Puffaligner if novel exons are present) would keep only a portion of the read falling inside an exon.</p>
      <p>These results are promising and we believe that Shark can be effectively used to filter an RNA-Seq sample with respect to large gene panels. However, we stress that the main goal of Shark is to filter a set of reads with respect to a limited number of genes of interest in order to speed up their downstream analysis. On this kind of instances, Shark is slightly faster and has consistently higher recall than other approaches. Running Shark on a large gene panel (or even on the entire set of annotated genes), though feasible, may not significantly reduce the size of the input sample, thus not leading to any speedup in the following RNA-Seq analysis, especially if the analysis is based on fast and efficient pipelines.</p>
    </sec>
    <sec>
      <title>3.2 Replication of a mapping-first differential AS analysis</title>
      <p>In the second part of our experimental evaluation, we partially replicate the analysis of a real RNA-Seq dataset performed in <xref rid="btaa779-B30" ref-type="bibr">Trincado <italic toggle="yes">et al.</italic> (2018)</xref> in order to assess the effectiveness of our tool in speeding up state-of-the-art pipelines for differential analysis of alternative splicing.</p>
      <p>We considered the three pipelines based on SplAdder (<xref rid="btaa779-B18" ref-type="bibr">Kahles <italic toggle="yes">et al.</italic>, 2016</xref>), rMATS (<xref rid="btaa779-B26" ref-type="bibr">Shen <italic toggle="yes">et al.</italic>, 2014</xref>) and SUPPA2 (<xref rid="btaa779-B30" ref-type="bibr">Trincado <italic toggle="yes">et al.</italic>, 2018</xref>). The first two tools analyze the RNA-Seq alignments computed by a spliced aligner, while the last one — SUPPA2 — analyzes the transcript quantifications computed by Salmon. In the following, we will refer to the three pipelines only by the name of the tools for the differential analysis, i.e. SplAdder, rMATS and SUPPA2. We remark that the aim of this part is not to evaluate the accuracy of the results of these pipelines, but to verify (i) whether their findings are affected by the preprocessing step performed by Shark and (ii) how much Shark can speed up their analyses. As mentioned in Section 1, pipelines based on STAR cannot be trivially speeded up by restricting the reference to the selected genes, while others — such as SUPPA2 — likely run faster if the reference is restricted. However, since SUPPA2 already uses a modest amount of computing resources, the benefits of restricting the reference (or of using Shark, as we will show) will be less dramatic.</p>
      <p>The dataset used in this evaluation consists of a set of six paired-end RNA-Seq samples (GEO accession number <italic toggle="yes">GSE59335</italic>): three samples obtained before and three obtained after the double knockdown of two splicing regulatory proteins, namely TRA2A and TRA2B (<xref rid="btaa779-B6" ref-type="bibr">Best <italic toggle="yes">et al.</italic>, 2014</xref>). Each sample contains between 22 and 25 million paired-end reads of length 101 bp. We decided to test the tools on this dataset since in the study 83 exon skipping events have been validated experimentally by RT-PCR, thus we can use such events as a ground truth to assess the effect of using Shark as preprocessing step.</p>
      <p>In this analysis, we ran Shark setting <italic toggle="yes">k</italic>=17, τ=0.6, <italic toggle="yes">q</italic>=10 and the Bloom filter size to 1GB. We chose these values since, as proved in the previous analysis, they achieve a good trade-off between precision and recall. All tools were ran with their default parameters (allowing up to four threads), while the spliced alignments required by the first two pipelines were computed by STAR (<xref rid="btaa779-B13" ref-type="bibr">Dobin <italic toggle="yes">et al.</italic>, 2013</xref>) in two-pass mode.</p>
      <p>We initially computed the differentially spliced events with the three aforementioned pipelines considering the original RNA-Seq samples and then we repeated the analysis considering the RNA-Seq samples preprocessed with Shark on the 82 different gene regions involved in the 83 RT-PCR validated events. On average, the filtered samples contain ∼2.3% of the original reads. <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref> reports the differences in terms of number of reads and uncompressed file size between the original samples and the samples filtered by Shark.</p>
      <p>We considered the 83 alternative splicing events validated by RT-PCR and we evaluated if the ability of the three pipelines in detecting such events is affected by the preprocessing step performed by Shark. <xref rid="btaa779-T2" ref-type="table">Table 2</xref> reports the results of this analysis.</p>
      <table-wrap position="float" id="btaa779-T2">
        <label>Table 2.</label>
        <caption>
          <p>Accuracy and efficiency of the three pipelines for differential analysis of alternative splicing on the original samples compared with those obtained on the samples filtered by Shark</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">RT-PCR events<hr/></th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">RAM</th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Pipeline</th>
              <th rowspan="1" colspan="1">All</th>
              <th rowspan="1" colspan="1">
                <inline-formula id="IE86">
                  <mml:math id="IM80" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mo>-</mml:mo>
                      <mml:mtext>value</mml:mtext>
                      <mml:mo>&lt;</mml:mo>
                      <mml:mn>0.05</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </th>
              <th rowspan="1" colspan="1">(min)</th>
              <th rowspan="1" colspan="1">(GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">rMATS</td>
              <td rowspan="1" colspan="1">78</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">328</td>
              <td rowspan="1" colspan="1">33.9</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Shark + rMATS</td>
              <td rowspan="1" colspan="1">78</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">154</td>
              <td rowspan="1" colspan="1">33.9</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">SplAdder</td>
              <td rowspan="1" colspan="1">56</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">915</td>
              <td rowspan="1" colspan="1">33.9</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Shark + SplAdder</td>
              <td rowspan="1" colspan="1">56</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">351</td>
              <td rowspan="1" colspan="1">33.9</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">SUPPA2</td>
              <td rowspan="1" colspan="1">66</td>
              <td rowspan="1" colspan="1">44</td>
              <td rowspan="1" colspan="1">117</td>
              <td rowspan="1" colspan="1">1.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Shark + SUPPA2</td>
              <td rowspan="1" colspan="1">66</td>
              <td rowspan="1" colspan="1">51</td>
              <td rowspan="1" colspan="1">42</td>
              <td rowspan="1" colspan="1">1.7</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic toggle="yes">Note</italic>: Accuracy is evaluated in terms of the number of RT-PCR validated events detected by each pipeline (over a total of 83 RT-PCR validated events). Efficiency is evaluated in terms of running time and maximum memory usage.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The first observation is that all the pipelines detected the same RT-PCR validated events in both the considered scenarios (i.e. on the original samples and on the filtered ones), confirming that the preprocessing step performed with Shark does not affect the accuracy of their differential splicing analysis. More precisely, out of the 83 RT-PCR validated events, rMATS detected 78 differentially spliced events, SUPPA2 detected 66 events, and SplAdder detected 56 events, under both conditions.</p>
      <p>If we restrict our analysis only to events reported as statistically significant by each tool (i.e. the events with <italic toggle="yes">P</italic>-value smaller than 0.05), the results follow the same trend, further confirming that the preprocessing step does not negatively impact the differential analysis. Indeed, rMATS reported the highest number of events (63) followed by SUPPA2. Interestingly, SUPPA2 identified seven additional significant events when considering the samples preprocessed by Shark w.r.t. the 44 events detected on the original samples. A manual inspection of the events in the two scenarios revealed that the differences between the respective <italic toggle="yes">P</italic>-values were rather small. On the other hand, in both scenarios SplAdder reported all the events with a <italic toggle="yes">P</italic>-value close to 1 (hence not significant).</p>
      <p>We also investigated the effect of filtering on the intermediate results of the pipelines. As an example, <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S3</xref> compares the outputs obtained by the transcript quantifier Salmon (one of the steps of the SUPPA2 pipeline) on the full and on the filtered dataset. Albeit the absolute values of the quantification differ in magnitude, the Pearson’s correlation coefficient between all the three pairs of series is high (<inline-formula id="IE87"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0.998</mml:mn></mml:mrow></mml:math></inline-formula>), confirming, as expected, that the outcome of any differential analysis performed on the filtered dataset should not be affected by the filtering process.</p>
      <p>The second important observation is that, as expected, preprocessing the input samples with Shark makes the three pipelines faster. Indeed, Shark (which required &lt;5 min to process each sample) allows all those pipelines to complete their analysis in around half the time. More precisely, rMATS took 2.5 h (saving 3 h), SplAdder completed its analysis in &lt;6 h (saving 9.5 h) and SUPPA2 took only 40 min instead of 2 h. The difference of the running times in the two scenarios is important (especially for rMATS and SplAdder), even on the relatively small dataset, we considered here. Notice that, the running time of Shark is linear in the number of input reads, and we only read once the set of reads. This fact implies that larger datasets (e.g. with more replicates or across several conditions or with higher-coverage samples) should show an even larger (absolute) reduction of running times of the complete analyses. While STAR and Salmon perform an indexing procedure only once, Shark indexes the input gene regions for each sample — hence, a more refined implementation that builds the index of the gene sequences only once could save even more time, especially for a larger number of samples.</p>
      <p>Lastly, this experiment shows that peak memory usage is almost unaffected by Shark. Indeed Shark required &lt;1.5 GB of RAM to process the input samples, which is significantly less than the peak memory usage of rMATS and SplAdder (33.9 GB) and comparable to that of SUPPA2 (1.7 GB). In particular, the peak memory usage for rMATS and SplAdder is reached in the alignment step. In this step, STAR loads the entire genome index in memory, hence its memory usage is largely independent on the input sample size.</p>
      <p>We then investigated how to reduce the memory usage of STAR, that is the most memory intensive step of the pipelines we tested, to allow any pipeline to be run on standard machines typically equipped with &lt;32 GB of RAM. When low memory usage is required, it is possible to reduce the memory usage of STAR by using its option for constructing a sparse index, namely --genomeSAsparseD, at the expense of increasing its running times (according to the tool documentation). However, since, we showed that Shark greatly reduces the input sample size and hence the time required by the alignment step, we expect that the resulting pipeline should be still faster than the classic one on the original samples. To evaluate our claim, we ran the two STAR-based pipelines multiple times on both the original samples and the samples preprocessed with Shark, each time increasing the sparsity of the STAR index. <xref rid="btaa779-T3" ref-type="table">Table 3</xref> reports the results obtained with sparsity equal to 8—the lowest value that allows to keep memory usage under 16 GB, an amount nowadays common on standard PCs.</p>
      <table-wrap position="float" id="btaa779-T3">
        <label>Table 3.</label>
        <caption>
          <p>Accuracy and efficiency of the STAR-based pipelines for differential analysis of alternative splicing on the original samples compared with those obtained on the samples filtered by Shark</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">RT-PCR events<hr/></th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">RAM</th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Pipeline</th>
              <th rowspan="1" colspan="1">All</th>
              <th rowspan="1" colspan="1">
                <inline-formula id="IE88">
                  <mml:math id="IM82" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mo>-</mml:mo>
                      <mml:mtext>value</mml:mtext>
                      <mml:mo>&lt;</mml:mo>
                      <mml:mn>0.05</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </th>
              <th rowspan="1" colspan="1">(min)</th>
              <th rowspan="1" colspan="1">(GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">rMATS</td>
              <td rowspan="1" colspan="1">78</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">632</td>
              <td rowspan="1" colspan="1">15.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Shark + rMATS</td>
              <td rowspan="1" colspan="1">78</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">138</td>
              <td rowspan="1" colspan="1">15.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">SplAdder</td>
              <td rowspan="1" colspan="1">56</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">1220</td>
              <td rowspan="1" colspan="1">15.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Shark + SplAdder</td>
              <td rowspan="1" colspan="1">56</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">326</td>
              <td rowspan="1" colspan="1">15.7</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn3">
            <p><italic toggle="yes">Note</italic>: The results have been obtained with --genomeSAsparseD=8 — a parameter that affects the sparsity of the index built and used by STAR. Accuracy is evaluated in terms of the number of RT-PCR validated events detected by each pipeline (over a total of 83 RT-PCR validated events). Efficiency is evaluated in terms of running time and maximum memory usage.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The first observation is that the sparsity of the index built by STAR does not affect the accuracy of the downstream pipelines for the differential analysis of alternative splicing. Indeed, both rMATS and SplAdder detected the same RT-PCR validated events in all the runs we performed.</p>
      <p>The second observation is that increasing the sparsity of the index allows to reduce the memory usage of each pipeline, from more than 33 GB to &lt;16 GB. Moreover, as expected, the sparsity of the index greatly affects the overall running times of the pipelines when they consider the original RNA-Seq dataset (<inline-formula id="IE89"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mo>+</mml:mo><mml:mn>93</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> for rMATS and <inline-formula id="IE90"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mo>+</mml:mo><mml:mn>33</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> for SplAdder, see <xref rid="btaa779-T3" ref-type="table">Table 3</xref> compared with <xref rid="btaa779-T2" ref-type="table">Table 2</xref>). On the other hand, since the filtered dataset is considerably smaller than the original one, the sparsity of the index does not sensibly affect the running times of the STAR alignment step and, hence, of the pipelines when run on the filtered dataset.</p>
    </sec>
    <sec>
      <title>3.3 Replication of an assembly-first differential as analysis</title>
      <p>In the third part of our experimental evaluation, we focused on the replication of an assembly-first differential alternative splicing analysis. Assembly-first approaches are based on first assembling the RNA-Seq reads depending on their overlaps and then aligning the assembled sequences to the reference genome. <xref rid="btaa779-B4" ref-type="bibr">Benoit-Pilven <italic toggle="yes">et al.</italic> (2018)</xref> show that mapping-first approaches (as those considered in the previous section) and assembly-first approaches (as the one considered in this section) are complementary, in the sense that, while they agree on the vast majority of their findings, each one is able to detect specific cases that the other one is not able to report (lowly-expressed variants for mapping-first approaches and novel variants for assembly-first approaches). We want to point out that assembly-first approaches are, in general, computationally demanding, thus filtering reads using Shark can be highly beneficial in order to speed up such an analysis and reducing the peak memory usage. Furthermore, we highlight that our filtering approach does not perform alignments (or pseudo-alignments) to the transcript sequences. As a consequence, Shark should not filter out reads supporting novel variants, which are mainly detected by assembly-first approaches. Hence, it is reasonable to use it as a preprocessing step of an assembly-first pipeline.</p>
      <p>To this aim, we partially replicated the analysis performed by <xref rid="btaa779-B4" ref-type="bibr">Benoit-Pilven <italic toggle="yes">et al.</italic> (2018)</xref> using the assembly-first KisSplice pipeline on an RNA-Seq dataset of the MCF-7 breast cancer cell line (GEO accession number <italic toggle="yes">GSE94372</italic>). The dataset is composed of two biological replicates on two conditions: a control condition and the depletion of two RNA helicases (DDX5 and DDX17). Each sample contains between 32 and 35 million paired-end reads of length 125 bp.</p>
      <p>Similarly as we did in the previous section, we focused on the subset of 48 genes for which the authors performed an experimental RT-PCR validation of a differential alternative splicing event detected by at least one pipeline of the twos they used in the work.</p>
      <p>As performed in the analysis we replicated, raw reads were preprocessed by trimming and removing the adapters according to standard quality control filters. The resulting dataset was then analyzed using the commands reported at <ext-link xlink:href="http://kissplice.prabi.fr/pipeline_ks_farline/" ext-link-type="uri">http://kissplice.prabi.fr/pipeline_ks_farline/</ext-link> on the full dataset and on the dataset filtered with Shark. Shark was ran setting <italic toggle="yes">k</italic> =17, τ=0.6, <italic toggle="yes">q</italic>=10 and the Bloom filter size to 1 GB.</p>
      <p>We considered all the differentially spliced events occurring in the 48 genes for which an experimental validation has been performed. Notice that, differently from the previous section, we did not consider only the RT-PCR validated events since they were not unambiguously reported, hence it was not possible to focus only on them.</p>
      <p><xref rid="btaa779-F3" ref-type="fig">Figure 3</xref> reports the comparison between the events reported on the full dataset (and then keeping only those mapping to one of the 48 selected genes) and those reported on the filtered dataset. The first important observation is that the predicted events almost perfectly coincide. Indeed, 246 (97.6%) events were reported on both the full dataset and on the filtered dataset. Only four (1.6%) events were predicted exclusively on the full dataset while two (0.8%) events were predicted exclusively on the filtered dataset. If we focus on the events reported as statistically significant (<inline-formula id="IE91"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>-</mml:mo><mml:mtext>value</mml:mtext><mml:mo>&lt;</mml:mo><mml:mn>0.05</mml:mn></mml:mrow></mml:math></inline-formula>), 81 of them were reported on both dataset, a single event was reported as statistically significant on the full dataset but as not statistically significant on the filtered dataset, while 4 were reported as statistically significant on the filtered dataset but as not statistically significant on the full dataset. Manual inspection of the differences revealed that the reported Percent Spliced In ( <inline-formula id="IE92"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mo>Δ</mml:mo><mml:mi mathvariant="italic">PSI</mml:mi></mml:mrow></mml:math></inline-formula>) for these events are highly similar. Interestingly, no event reported as statistically significant on a dataset was missing in the other dataset (albeit it could be reported as not statistically significant).</p>
      <fig position="float" id="btaa779-F3">
        <label>Fig. 3.</label>
        <caption>
          <p>Comparison of differential alternative splicing events mapping to one of the 48 selected genes as predicted by KisSplice on the full dataset (left oval) and on the dataset filtered by Shark (right oval). Inner ovals represent the events predicted with <inline-formula id="IE93"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>-</mml:mo><mml:mtext>value</mml:mtext><mml:mo>&lt;</mml:mo><mml:mn>0.05</mml:mn></mml:mrow></mml:math></inline-formula></p>
        </caption>
        <graphic xlink:href="btaa779f3" position="float"/>
      </fig>
      <p>In terms of running times, Shark allows to achieve a considerable speed up (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S4</xref>). Indeed, the total running time on the full dataset (after trimming) is 26 h and 37 min, while on the filtered dataset the pipeline (including the filtering step) took 3 h and 30 min to complete (<inline-formula id="IE94"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mn>6.1</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> relative speedup).</p>
    </sec>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>In this work, we introduced the novel computational problem of computing the gene assignment of an RNA-Seq sample with respect to a set of genes. We also proposed an algorithmic approach to solve this problem and we also implemented it, resulting in the tool, Shark. To the best of our knowledge, Shark is the first tool specifically designed for computing a gene assignment.</p>
    <p>We performed an experimental analysis on real data where we evaluated the effectiveness of Shark in speeding up state-of-the-art pipelines for the differential analysis of alternative splicing. Overall, Shark proved to be a preprocessing step that preserves valuable information (i.e. reads) of the selected genes and hence does not negatively affect any downstream pipeline for the differential analysis of alternative splicing. On the other hand, it allows to significantly reduce the size of the input samples, hence it speeds up the pipelines, especially those based on read alignment and read assembly. Furthermore, the efficiency of Shark, combined with an appropriate selection of the different parameters that may be used to influence the performance of the downstream analyses (e.g. the sparsity of the index of STAR), allows to bring all those analyses — nowadays performed on servers — to modern desktop computers.</p>
    <p>The accuracy and the efficiency of Shark depend on its parameters <italic toggle="yes">k</italic>, τ and <italic toggle="yes">q</italic> that are the <italic toggle="yes">k</italic>-mer size, the minimum confidence and the base quality threshold, respectively. For this reason, future steps will focus on allowing Shark to automatically estimate the best values of these parameters by exploiting extra information on the read length and the error rate. Furthermore, including also the annotated transcripts in the index or perform a preliminary filtering step using transcript sequences could improve the running times, especially on large gene panels, without affecting accuracy.</p>
    <p>Since Shark can be used as a preliminary step in pipelines for the detection of novel alternative splicing events from samples of RNA-Seq data, future work will be devoted to an in-depth experimental analysis of Shark as a preliminary step of a pipeline that includes computationally demanding tools, such as ASGAL (<xref rid="btaa779-B11" ref-type="bibr">Denti <italic toggle="yes">et al.</italic>, 2018</xref>), that relies on mapping reads against a splicing graph, and Trinity (<xref rid="btaa779-B17" ref-type="bibr">Haas <italic toggle="yes">et al.</italic>, 2013</xref>), that assembles RNA-Seq reads, performs transcript abundance estimation and identifies differentially expressed transcripts across samples.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btaa779_Supplementary_Data</label>
      <media xlink:href="btaa779_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank Murray Patterson and the anonymous reviewers for their insightful comments about the manuscript.</p>
    <sec>
      <title>Funding</title>
      <p>This project has received funding from the European Union’s Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie grant agreement number [872539].</p>
      <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btaa779-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Almodaresi</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>A space and time-efficient index for the compacted colored de Bruijn graph</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>i169</fpage>–<lpage>i177</lpage>.<pub-id pub-id-type="pmid">29949982</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B2">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Almodaresi</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) An efficient, scalable and exact representation of high-dimensional color information enabled via de Bruijn graph search. In: <source>RECOMB</source>. pp. <fpage>1</fpage>–<lpage>18</lpage>. Springer, Cham.</mixed-citation>
    </ref>
    <ref id="btaa779-B3">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Belazzougui</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) Fully dynamic de Bruijn graphs. In: <source>SPIRE</source>. pp. <fpage>145</fpage>–<lpage>152</lpage>. Springer, Cham.</mixed-citation>
    </ref>
    <ref id="btaa779-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Benoit-Pilven</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>Complementarity of assembly-first and mapping-first approaches for alternative splicing annotation and differential analysis from RNAseq data</article-title>. <source>Sci. Rep</source>., <volume>8</volume>, <fpage>1</fpage>–<lpage>13</lpage>.<pub-id pub-id-type="pmid">29311619</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Beretta</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <italic toggle="yes">Mapping RNA-seq Data to a Transcript Graph Via Approximate Pattern Matching to a Hypertext</italic>. In: <person-group person-group-type="editor"><string-name><surname>Figueiredo</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (eds) Lecture Notes in Computer Science. Algorithms for Computational Biology - 4th International Conference, AlCoB 2017, Aveiro, Portugal, June 5–6, 2017, Proceedings. Vol. <volume>10252</volume>, pp. <fpage>49</fpage>–<lpage>61</lpage>, 
<publisher-name>Springer</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btaa779-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Best</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) 
<article-title>Human Tra2 proteins jointly control a CHEK1 splicing switch among alternative and constitutive target exons</article-title>. <source>Nat. Commun</source>., <volume>5</volume>, <fpage>4760</fpage>.<pub-id pub-id-type="pmid">25208576</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bloom</surname><given-names>B.H.</given-names></string-name></person-group> (<year>1970</year>) 
<article-title>Space/time trade-offs in hash coding with allowable errors</article-title>. <source>Commun. ACM</source>, <volume>13</volume>, <fpage>422</fpage>–<lpage>426</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa779-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bray</surname><given-names>N.L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) 
<article-title>Near-optimal probabilistic RNA-seq quantification</article-title>. <source>Nat. Biotechnol</source>., <volume>34</volume>, <fpage>525</fpage>–<lpage>527</lpage>.<pub-id pub-id-type="pmid">27043002</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Conesa</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) 
<article-title>A survey of best practices for RNA-seq data analysis</article-title>. <source>Genome Biol</source>., <volume>17</volume>, <fpage>13</fpage>.<pub-id pub-id-type="pmid">26813401</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cunningham</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) 
<article-title>Ensembl</article-title>. <source>Nucleic Acids Res</source>., <volume>47</volume>, <fpage>D745</fpage>–<lpage>D751</lpage>.<pub-id pub-id-type="pmid">30407521</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Denti</surname><given-names>L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>ASGAL: aligning RNA-Seq data to a splicing graph to detect novel alternative splicing events</article-title>. <source>BMC Bioinformatics</source>, <volume>19</volume>, <fpage>444</fpage>.<pub-id pub-id-type="pmid">30458725</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Denti</surname><given-names>L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) 
<article-title>MALVA: genotyping by mapping-free allele detection of known variants</article-title>. <source>iScience</source>, <volume>18</volume>, <fpage>20</fpage>–<lpage>27</lpage>.<pub-id pub-id-type="pmid">31352182</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dobin</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) 
<article-title>STAR: ultrafast universal RNA-seq aligner</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>15</fpage>–<lpage>21</lpage>.<pub-id pub-id-type="pmid">23104886</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B14">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Gog</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) From theory to practice: plug and play with succinct data structures. In: <source>SEA</source>. pp. <fpage>326</fpage>–<lpage>337</lpage>. Springer, Cham.</mixed-citation>
    </ref>
    <ref id="btaa779-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Griebel</surname><given-names>T.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) 
<article-title>Modelling and simulating generic RNA-Seq experiments with the flux simulator</article-title>. <source>Nucleic Acids Res</source>., <volume>40</volume>, <fpage>10073</fpage>–<lpage>10083</lpage>.<pub-id pub-id-type="pmid">22962361</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Grüning</surname><given-names>B.</given-names></string-name></person-group>  <etal>et al</etal>; The Bioconda Team. (<year>2018</year>) 
<article-title>Bioconda: sustainable and comprehensive software distribution for the life sciences</article-title>. <source>Nat. Methods</source>, <volume>15</volume>, <fpage>475</fpage>–<lpage>476</lpage>.<pub-id pub-id-type="pmid">29967506</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Haas</surname><given-names>B.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) 
<article-title>De novo transcript sequence reconstruction from RNA-Seq: reference generation and analysis with trinity</article-title>. <source>Nat. Protoc</source>., <volume>8</volume>, <fpage>1494</fpage>–<lpage>1512</lpage>.<pub-id pub-id-type="pmid">23845962</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kahles</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) 
<article-title><italic toggle="yes">SplAdder</italic>: identification, quantification and testing of alternative splicing events from RNA-Seq data</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>1840</fpage>–<lpage>1847</lpage>.<pub-id pub-id-type="pmid">26873928</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kahles</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>Comprehensive analysis of alternative splicing across tumors from 8,705 patients</article-title>. <source>Cancer Cell</source>, <volume>34</volume>, <fpage>211</fpage>–<lpage>224</lpage>.<pub-id pub-id-type="pmid">30078747</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kokot</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) 
<article-title>KMC 3: counting and manipulating k-mer statistics</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>2759</fpage>–<lpage>2761</lpage>.<pub-id pub-id-type="pmid">28472236</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Köster</surname><given-names>J.</given-names></string-name>, <string-name><surname>Rahmann</surname><given-names>S.</given-names></string-name></person-group> (<year>2012</year>) 
<article-title>Snakemake–a scalable bioinformatics workflow engine</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>2520</fpage>–<lpage>2522</lpage>.<pub-id pub-id-type="pmid">22908215</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marçais</surname><given-names>G.</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group> (<year>2011</year>) 
<article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>764</fpage>–<lpage>770</lpage>.<pub-id pub-id-type="pmid">21217122</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Patro</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) 
<article-title>Sailfish enables alignment-free isoform quantification from RNA-seq reads using lightweight algorithms</article-title>. <source>Nat. Biotechnol</source>., <volume>32</volume>, <fpage>462</fpage>–<lpage>464</lpage>.<pub-id pub-id-type="pmid">24752080</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Patro</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) 
<article-title>Salmon provides fast and bias-aware quantification of transcript expression</article-title>. <source>Nat. Methods</source>, <volume>14</volume>, <fpage>417</fpage>–<lpage>419</lpage>.<pub-id pub-id-type="pmid">28263959</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sacomoto</surname><given-names>G.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) 
<article-title>KISSPLICE: de-novo calling alternative splicing events from RNA-seq data</article-title>. <source>BMC Bioinformatics</source>, <volume>13</volume>, <fpage>S5</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa779-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shen</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) 
<article-title>rMATS: robust and flexible detection of differential alternative splicing from replicate RNA-Seq data</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>111</volume>, <fpage>E5593</fpage>–<lpage>E5601</lpage>.<pub-id pub-id-type="pmid">25480548</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Srivastava</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) 
<article-title>RapMap: a rapid, sensitive and accurate tool for mapping RNA-seq reads to transcriptomes</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>i192</fpage>–<lpage>i200</lpage>.<pub-id pub-id-type="pmid">27307617</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sun</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>AllSome sequence bloom trees</article-title>. <source>J. Comput. Biol</source>., <volume>25</volume>, <fpage>467</fpage>–<lpage>479</lpage>.<pub-id pub-id-type="pmid">29620920</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tazi</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2009</year>) 
<article-title>Alternative splicing and disease</article-title>. <source>Biochim. Biophys. Acta</source>, <volume>1792</volume>, <fpage>14</fpage>–<lpage>26</lpage>.<pub-id pub-id-type="pmid">18992329</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Trincado</surname><given-names>J.L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>SUPPA2: fast, accurate, and uncertainty-aware differential splicing analysis across multiple conditions</article-title>. <source>Genome Biol</source>., <volume>19</volume>, <fpage>40</fpage>.<pub-id pub-id-type="pmid">29571299</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8088329</article-id>
    <article-id pub-id-type="pmid">32926128</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btaa779</article-id>
    <article-id pub-id-type="publisher-id">btaa779</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Shark: fishing relevant reads in an RNA-Seq sample</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8786-2276</contrib-id>
        <name>
          <surname>Denti</surname>
          <given-names>Luca</given-names>
        </name>
        <xref rid="btaa779-FM1" ref-type="author-notes"/>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-8479-7592</contrib-id>
        <name>
          <surname>Pirola</surname>
          <given-names>Yuri</given-names>
        </name>
        <xref rid="btaa779-cor1" ref-type="corresp"/>
        <xref rid="btaa779-FM1" ref-type="author-notes"/>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
        <!--yuri.pirola@unimib.it-->
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-3040-9539</contrib-id>
        <name>
          <surname>Previtali</surname>
          <given-names>Marco</given-names>
        </name>
        <xref rid="btaa779-FM1" ref-type="author-notes"/>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ceccato</surname>
          <given-names>Tamara</given-names>
        </name>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-5584-3089</contrib-id>
        <name>
          <surname>Della Vedova</surname>
          <given-names>Gianluca</given-names>
        </name>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Rizzi</surname>
          <given-names>Raffaella</given-names>
        </name>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bonizzoni</surname>
          <given-names>Paola</given-names>
        </name>
        <aff><institution>Department of Informatics, Systems and Communication, University of Milano-Bicocca</institution>, Milano 20126, <country country="IT">Italy</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Ponty</surname>
          <given-names>Yann</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <fn id="btaa779-FM1">
        <p>The authors wish it to be known that, in their opinion, Luca Denti, Yuri Pirola and Marco Previtali should be regarded as joint First Authors.</p>
      </fn>
      <corresp id="btaa779-cor1">To whom correspondence should be addressed. <email>yuri.pirola@unimib.it</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <day>15</day>
      <month>2</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2020-09-14">
      <day>14</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>14</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <volume>37</volume>
    <issue>4</issue>
    <fpage>464</fpage>
    <lpage>472</lpage>
    <history>
      <date date-type="received">
        <day>01</day>
        <month>4</month>
        <year>2020</year>
      </date>
      <date date-type="rev-recd">
        <day>17</day>
        <month>8</month>
        <year>2020</year>
      </date>
      <date date-type="editorial-decision">
        <day>31</day>
        <month>8</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>02</day>
        <month>9</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2020</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btaa779.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Recent advances in high-throughput RNA-Seq technologies allow to produce massive datasets. When a study focuses only on a handful of genes, most reads are not relevant and degrade the performance of the tools used to analyze the data. Removing irrelevant reads from the input dataset leads to improved efficiency without compromising the results of the study.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We introduce a novel computational problem, called gene assignment and we propose an efficient alignment-free approach to solve it. Given an RNA-Seq sample and a panel of genes, a gene assignment consists in extracting from the sample, the reads that most probably were sequenced from those genes. The problem becomes more complicated when the sample exhibits evidence of novel alternative splicing events. We implemented our approach in a tool called Shark and assessed its effectiveness in speeding up differential splicing analysis pipelines. This evaluation shows that Shark is able to significantly improve the performance of RNA-Seq analysis tools without having any impact on the final results.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The tool is distributed as a stand-alone module and the software is freely available at <ext-link xlink:href="https://github.com/AlgoLab/shark" ext-link-type="uri">https://github.com/AlgoLab/shark</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union’s Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie</institution>
          </institution-wrap>
        </funding-source>
        <award-id>872539</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>RNA-Seq analysis plays an important role in the biological and medical research aimed at deepening our understanding of cellular biological processes and their relationships with pathological conditions. As such, several research initiatives had the objective of producing RNA-Seq data, while a number of tools have been proposed to analyze such datasets and have gained widespread adoption in the community (<xref rid="btaa779-B5" ref-type="bibr">Beretta <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa779-B8" ref-type="bibr">Bray <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btaa779-B11" ref-type="bibr">Denti <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btaa779-B24" ref-type="bibr">Patro <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa779-B25" ref-type="bibr">Sacomoto <italic toggle="yes">et al.</italic>, 2012</xref>; <xref rid="btaa779-B26" ref-type="bibr">Shen <italic toggle="yes">et al.</italic>, 2014</xref>; <xref rid="btaa779-B30" ref-type="bibr">Trincado <italic toggle="yes">et al.</italic>, 2018</xref>). Traditional approaches generally rely on RNA-Seq read mapping to the annotated gene isoforms or on the spliced alignment of reads to the genome. In the second case, spliced aligners, such as STAR (<xref rid="btaa779-B13" ref-type="bibr">Dobin <italic toggle="yes">et al.</italic>, 2013</xref>), employ gene annotations to obtain more accurate results. While gene annotations, especially for humans, are readily available, they are not complete as they are built from healthy individuals. Thus, aberrant isoforms, which play an important role in the development of human diseases (<xref rid="btaa779-B19" ref-type="bibr">Kahles <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btaa779-B29" ref-type="bibr">Tazi <italic toggle="yes">et al.</italic>, 2009</xref>), are usually not annotated. As a consequence, <italic toggle="yes">de novo</italic> (or assembly-first) approaches (<xref rid="btaa779-B17" ref-type="bibr">Haas <italic toggle="yes">et al.</italic>, 2013</xref>; <xref rid="btaa779-B25" ref-type="bibr">Sacomoto <italic toggle="yes">et al.</italic>, 2012</xref>), which potentially detect novel splicing events, have been developed and have gained popularity, even for studying well-annotated organisms (<xref rid="btaa779-B4" ref-type="bibr">Benoit-Pilven <italic toggle="yes">et al.</italic>, 2018</xref>). These approaches are more computationally demanding than traditional annotation-guided ones and pose challenging issues when facing the huge amount of RNA-Seq data that is now available. Furthermore, high-coverage samples are needed for obtaining accurate results with <italic toggle="yes">de novo</italic> approaches, especially for reconstructing low-abundance isoforms.</p>
    <p>When the study is focused on the analysis of a pre-identified set of genes — e.g. those that are known to have a role in tumor progression — a preprocessing step that filters the input RNA-Seq reads, retaining only those likely originated by the genes of interest, could greatly reduce the size of the dataset that must be analyzed (hence speeding up the analysis) without significantly affecting the final results. Existing spliced aligners, such as STAR, could be theoretically adapted to perform the preprocessing step. However, they are aimed at obtaining accurate alignments; hence, they are not fast enough to give a significant speedup of the analysis. For example, if we trivially apply STAR using as a reference the selected gene sequences, the alignment process will take longer than using the full reference genome, since numerous attempts to align the reads sequenced from not-selected genes are performed before discarding it. Other approaches, such as some recently proposed transcript quantification tools (<xref rid="btaa779-B8" ref-type="bibr">Bray <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btaa779-B23" ref-type="bibr">Patro <italic toggle="yes">et al.</italic>, 2014</xref>, <xref rid="btaa779-B24" ref-type="bibr">2017</xref>) or quasi-mappers (<xref rid="btaa779-B27" ref-type="bibr">Srivastava <italic toggle="yes">et al.</italic>, 2016</xref>), are fast enough to be adapted as preprocessing filters but they rely on isoform annotations, hence they might make errors if novel splicing events are supported by the sample, influencing any downstream analysis (<xref rid="btaa779-B9" ref-type="bibr">Conesa <italic toggle="yes">et al.</italic>, 2016</xref>). Other <italic toggle="yes">k</italic>-mer-based approaches are promising (<xref rid="btaa779-B2" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btaa779-B28" ref-type="bibr">Sun <italic toggle="yes">et al.</italic>, 2018</xref>) but they have been designed toward different applications (e.g. indexing and searching large sequencing experiments) hence they achieve a different trade-off between computational efficiency and resulting accuracy.</p>
    <p>For this reason, we propose an alignment-free method that solves the gene-read assignment problem without relying on existing isoform annotations: given a set of genes of interest (gene panel) and a genome-wide RNA-Seq dataset, the goal is to retain only those reads (called <italic toggle="yes">relevant</italic> reads) originating from a gene in the selected set, thus, discarding a potentially huge set of reads not relevant for the downstream analyses. We implemented the method in the tool Shark that, by relying on succinct data structures and multi-threading, is able to quickly analyze huge RNA-Seq datasets on a standard PC. We replicated two studies (<xref rid="btaa779-B4" ref-type="bibr">Benoit-Pilven <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btaa779-B30" ref-type="bibr">Trincado <italic toggle="yes">et al.</italic>, 2018</xref>) aimed at detecting differentially expressed alternative splicing events — one of the most complex and most common tasks in RNA-Seq analysis — and we found that Shark provides a preprocessing step that significantly reduces the running time and/or the memory requirements of computationally intensive downstream analyses, while not negatively impacting their results. We note that, although our method has been specifically designed for RNA-Seq data, it can also be used for genomic reads if, e.g. one is interested in finding variants located on a specific subset of genes.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 The gene assignment problem</title>
      <p>Let Σ be a finite alphabet of size σ and let <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be an ordered sequence of <italic toggle="yes">n</italic> characters drawn from Σ; we say that <italic toggle="yes">s</italic> is a string over Σ of length <italic toggle="yes">n</italic>. From a computational point of view, a <italic toggle="yes">genome</italic>, a <italic toggle="yes">gene locus</italic> and a <italic toggle="yes">transcript</italic> are strings over the alphabet <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi mathvariant="monospace">A</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">C</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">G</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. A gene locus is a substring of the genome, whereas a transcript is a concatenation of pieces (exons) of a gene locus; an RNA-Seq sample is a set of strings (called <italic toggle="yes">reads</italic>) over the same alphabet. A RNA-Seq read is a substring of a transcript, and it is in a 1-to-1 correspondence with a gene locus, referred in the following as the <italic toggle="yes">origin</italic> of the read. Given a string <italic toggle="yes">s</italic> and a positive integer <italic toggle="yes">k</italic>, we say that a substring of <italic toggle="yes">s</italic> of length <italic toggle="yes">k</italic> is a <italic toggle="yes">k</italic>-mer. We denote by <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">KMER</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the multiset of all the <italic toggle="yes">k</italic>-mers of <italic toggle="yes">s</italic> (observe that the same <italic toggle="yes">k</italic>-mer might occur multiple times). As usual (<xref rid="btaa779-B3" ref-type="bibr">Belazzougui <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btaa779-B12" ref-type="bibr">Denti <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btaa779-B20" ref-type="bibr">Kokot <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa779-B22" ref-type="bibr">Marçais and Kingsford, 2011</xref>), to account for the double stranded nature of the human genome, when we refer to a <italic toggle="yes">k</italic>-mer, we implicitly refer to its <italic toggle="yes">canonical form</italic>, that is the lexicographically smaller sequence between the <italic toggle="yes">k</italic>-mer and its reverse-complement. Given a read <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>⋯</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we refer to the pair <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with the term <italic toggle="yes">base</italic>. Note that, the same character appearing at two different positions of <italic toggle="yes">s</italic> are two distinct bases. Moreover, we say that a base <italic toggle="yes">b</italic> of the read <italic toggle="yes">s</italic> is shared with the gene <italic toggle="yes">g</italic> if there exists a <italic toggle="yes">k</italic>-mer of <italic toggle="yes">s</italic> that includes <italic toggle="yes">b</italic> and is equal to a <italic toggle="yes">k</italic>-mer of <italic toggle="yes">g</italic>. We denote by <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the set of the bases of <italic toggle="yes">s</italic> shared by <italic toggle="yes">g</italic>. In other words, <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the set of all the bases of <italic toggle="yes">s</italic> such that there exists a <italic toggle="yes">k</italic>-mer in the intersection between <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">KMER</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">KMER</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that includes the base.</p>
      <p>To assign a read to its origin gene, we adapt the following criterion as a proxy. A gene <italic toggle="yes">g</italic> is the putative origin of a read <italic toggle="yes">s</italic> if and only if the ratio <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is greater or equal than a given threshold τ and for no other gene <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. The rationale behind this criterion is to have a measure of similarity between a read and a gene without aligning them, which takes into account that introns are spliced out from transcripts and therefore from an RNA-Seq read. Observe that by this definition, and due to genome repetitions, a read may have multiple origin genes. We denote as <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ORIGIN</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the set of putative origin genes of a read <italic toggle="yes">s</italic>.</p>
      <p>We now provide a formal definition of the problem, we tackle in this article, namely the <italic toggle="yes">Gene Assignment Problem</italic>.</p>
      <p>Problem 1 (Gene Assignment Problem). Let <italic toggle="yes">S</italic> be a set of RNA-Seq reads sequenced from a set <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> of genes, let <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>⊆</mml:mo><mml:mi mathvariant="script">G</mml:mi></mml:mrow></mml:math></inline-formula> be a gene panel, i.e. a set of genes of interest. The <italic toggle="yes">gene assignment</italic> of <italic toggle="yes">S</italic> with respect to <italic toggle="yes">G</italic> and parameters <italic toggle="yes">k</italic> and τ is a set <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> elements such that <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> is the set of reads that originate from <italic toggle="yes">g<sub>i</sub></italic>, i.e. for each <italic toggle="yes">s</italic> in <italic toggle="yes">S<sub>i</sub></italic> the following conditions hold: (i) <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo>≥</mml:mo><mml:mo>τ</mml:mo></mml:mrow></mml:math></inline-formula>, (ii) for no other gene <italic toggle="yes">g<sub>j</sub></italic>, <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, and the <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> sets have been computed on <italic toggle="yes">k</italic>-mers.</p>
      <p>Note that, a gene assignment is not necessarily a partition of the input sample. Indeed, a read may have more than one origin gene and some read may have no origin gene. For ease of presentation, in the rest of the article, we will refer to this problem as the gene assignment of <italic toggle="yes">S</italic> with respect to <italic toggle="yes">G</italic>, without specifying <italic toggle="yes">k</italic> and τ.</p>
      <p>Note also that the Gene Assignment Problem here defined is robust to sequence polymorphisms. Indeed, from the viewpoint of the definition of the problem, sequence polymorphisms are indistinguishable from sequencing errors, and parameters <italic toggle="yes">k</italic> and τ allow (as we show in Section 3) to tweak the accuracy toward better specificity (allowing less errors) or better sensitivity (allowing more errors).</p>
      <p>The algorithmic approach, we propose to solve this problem uses two well-known data structures that we will now briefly introduce. A <italic toggle="yes">bit vector</italic> is a sequence of binary values that supports rank and select queries in constant time using additional sublinear space. Let <italic toggle="yes">B</italic> be a bit vector and let <italic toggle="yes">i</italic> be a positive integer, <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ran</mml:mi><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the number of values equal to <italic toggle="yes">d</italic> in the portion <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">B</italic>, whereas <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">selec</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the position of the <italic toggle="yes">i</italic>-th value of <italic toggle="yes">B</italic> set to <italic toggle="yes">d</italic>. Clearly, <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ran</mml:mi><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is not defined if <italic toggle="yes">i</italic> is greater than the size of <italic toggle="yes">B</italic> and <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">selec</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is not defined if fewer than <italic toggle="yes">i</italic> values of <italic toggle="yes">B</italic> are set to <italic toggle="yes">d</italic>. A <italic toggle="yes">Bloom filter</italic> (<xref rid="btaa779-B7" ref-type="bibr">Bloom, 1970</xref>) is a probabilistic data structure used to answer membership queries. It consists of a bit vector of fixed size <italic toggle="yes">m</italic> and <italic toggle="yes">z</italic> hash functions, each one mapping an object to a position of the bit vector. Adding an object to a Bloom filter consists in setting to 1 the bits at the positions of the bit vector computed by the hash functions for that object. Testing if an object is in the set consists in checking whether all the bits at the positions computed by the hash functions for that object are set to 1. Due to hash collisions, an element may be reported as present even though it is not in the set, resulting in a false positive. Anyway, a low false positive rate can be achieved via a suitable choice of the bit vector size and the number of hash functions.</p>
    </sec>
    <sec>
      <title>2.2 Algorithm</title>
      <p>In this section, we describe the algorithmic approach, we propose to solve the computational problem introduced in the previous section. The algorithm for computing the gene assignment of an RNA-Seq sample <italic toggle="yes">S</italic> with respect to a set <italic toggle="yes">G</italic> of genes is composed of two steps: first, for each read <italic toggle="yes">s</italic> in the sample, we compute the set <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ORIGIN</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of its origin genes, then, we derive the gene assignment of <italic toggle="yes">S</italic> from those sets by grouping together reads with the same origin gene.</p>
      <p>An efficient solution to this problem essentially requires that we index the gene sequences. A simple procedure stores a dictionary that maps each <italic toggle="yes">k</italic>-mer appearing in at least one gene to the genes in which it occur, and then use it to map the <italic toggle="yes">k</italic>-mers of the reads to the genes, determining the origin genes read by read. Although effective, this approach would require an excessive amount of memory to store the dictionary if we need to track a significant amount of <italic toggle="yes">k</italic>-mers of the genes, especially since we have to store explicitly the <italic toggle="yes">k</italic>-mers sequences. For this reason, we designed a novel data structure that couples efficient access with small space usage, albeit introducing some false positives.</p>
      <p>The data structure we propose to efficiently compute a gene assignment consists of a Bloom filter <italic toggle="yes">BF</italic>, a bit vector <italic toggle="yes">P</italic> and a vector of integers <italic toggle="yes">I</italic>. We use the three components of the data structure as follows: the Bloom filter stores the set of <italic toggle="yes">k</italic>-mers of the genes in <italic toggle="yes">G</italic>, the vector of integers compactly stores the subset of genes in which each <italic toggle="yes">k</italic>-mer appears and the bit vector tags the boundaries of the different subsets in the integer vector.</p>
      <p>To build this data structure, we designed a three-step process, also presented in Algorithm 1. First, we associate to each gene in <italic toggle="yes">G</italic> an incremental ID and store the gene-ID mapping in a dictionary <italic toggle="yes">GENEMAP</italic>, which is then given as argument to Algorithm 1. Notice that, we achieve an important reduction in memory usage by storing only the gene-ID instead of its entire sequence.</p>
      <p>Then, we scan the gene sequences and we store each <italic toggle="yes">k</italic>-mer in <italic toggle="yes">BF</italic> by using a single hash function <italic toggle="yes">H</italic>, mapping each <italic toggle="yes">k</italic>-mer to a specific position in the Bloom filter <italic toggle="yes">BF</italic> (lines 1–5). Once we complete this scan, <italic toggle="yes">BF</italic> stores the set of <italic toggle="yes">k</italic>-mers of all input genes. Since the number of <italic toggle="yes">k</italic>-mers indexed in the Bloom filter is significantly smaller than the size of the Bloom filter, using a single hash function improves efficiency and only slightly degrades accuracy, as shown by various works (<xref rid="btaa779-B12" ref-type="bibr">Denti <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btaa779-B28" ref-type="bibr">Sun <italic toggle="yes">et al.</italic>, 2018</xref>). Efficiency improves in this setting because using multiple hash functions increases the number of random memory accesses, thus increasing the amount of cache misses.</p>
      <p>For each 1 in <italic toggle="yes">BF</italic>, we create an empty list <italic toggle="yes">L<sub>r</sub></italic> (lines 6–7), where <italic toggle="yes">L<sub>r</sub></italic> corresponds to the <italic toggle="yes">r</italic>-th bit stored in the Bloom filter. We will then use <italic toggle="yes">L<sub>r</sub></italic> to store a set of back-references to the genes where each associated <italic toggle="yes">k</italic>-mer appears. At the end of this step, each 1 in <italic toggle="yes">BF</italic> is associated with a subset of genes back-references (represented as a list of IDs) stored in memory. Then, we scan all the <italic toggle="yes">k</italic>-mers in each gene of <italic toggle="yes">G</italic>, we compute the corresponding 1 in <italic toggle="yes">BF</italic> and (via a rank) the corresponding list <italic toggle="yes">L<sub>r</sub></italic> to which the gene-ID must be appended (lines 8–12). Finally all duplicates are removed from the lists <italic toggle="yes">L<sub>r</sub></italic>.</p>
      <p>The third step consists of concatenating the lists <italic toggle="yes">L<sub>r</sub></italic> to obtain the integer vector <italic toggle="yes">I</italic> that contains all back-references. At the same time (lines 15–19), we build the boundary vector <italic toggle="yes">P</italic>, which has a 1 in each position <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>≤</mml:mo><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula> (i.e. the 1s mark the end of each list).</p>
      <p>The example in <xref rid="btaa779-F1" ref-type="fig">Figure 1</xref> describes how this data structure is queried to retrieve the identifiers of the genes associated to a given <italic toggle="yes">k</italic>-mer. First, the hash function <italic toggle="yes">H</italic> maps the 5-mer <italic toggle="yes">gactgg</italic> to position <italic toggle="yes">h</italic>. Since a 1 is at position <italic toggle="yes">h</italic> of <italic toggle="yes">BF</italic>, we suppose that the <italic toggle="yes">k</italic>-mer is in it and we compute how many 1s appear before <italic toggle="yes">h</italic> computing in constant time <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ran</mml:mi><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Then, since the 1 stored in <italic toggle="yes">h</italic> is the <italic toggle="yes">v</italic>-th 1 of <italic toggle="yes">BF</italic>, i.e. the <italic toggle="yes">k</italic>-mer is the <italic toggle="yes">v</italic>-th element according to the order of <italic toggle="yes">k</italic>-mers given by <italic toggle="yes">H</italic>, we retrieve the positions of the <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th and the <italic toggle="yes">v</italic>-th 1 in <italic toggle="yes">P</italic> using <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">selec</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Those positions are the boundaries on <italic toggle="yes">I</italic> of the subset of genes mapped to the <italic toggle="yes">k</italic>-mer.</p>
      <fig position="float" id="btaa779-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Relation between the Bloom filter <italic toggle="yes">BF</italic>, the bit vector <italic toggle="yes">P</italic>, and the vector <italic toggle="yes">I</italic>. To retrieve the identifiers of the genes containing a <italic toggle="yes">k</italic>-mer <italic toggle="yes">e</italic> (gacttg in the figure), we compute its image <italic toggle="yes">h</italic> through <italic toggle="yes">H</italic> and, if <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the <italic toggle="yes">v</italic>-th 1 of <italic toggle="yes">BF</italic>, the positions of the <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th and the <italic toggle="yes">v</italic>-th 1 of <italic toggle="yes">P</italic>, denoted as <italic toggle="yes">p</italic><sub>1</sub> and <italic toggle="yes">p</italic><sub>2</sub>, respectively, can be found via rank and select operations. The interval of <italic toggle="yes">I</italic> from <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <italic toggle="yes">p</italic><sub>2</sub> stores the set <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">GENES</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the indices of the genes containing the <italic toggle="yes">k</italic>-mer <italic toggle="yes">e</italic></p>
        </caption>
        <graphic xlink:href="btaa779f1" position="float"/>
      </fig>
      <p>
        <boxed-text id="btaa779-BOX1" position="float">
          <p>
            <inline-graphic xlink:href="btaa779ilf1.jpg"/>
          </p>
        </boxed-text>
      </p>
      <p>Once we have built the data structure <inline-formula id="IE42"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>, as described above, we iterate over each read of the sample and we query <italic toggle="yes">D</italic>(<italic toggle="yes">G</italic>) to compute the set of its origin genes. For each read <italic toggle="yes">s</italic>, the procedure scans the multiset <inline-formula id="IE43"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">KMER</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">k</italic>-mers of <italic toggle="yes">s</italic> from left to right and maintains, for each gene <italic toggle="yes">g</italic>, the rightmost position <inline-formula id="IE44"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of a base of <italic toggle="yes">s</italic> shared by <italic toggle="yes">g</italic> (or −1 if such a base does not exist) and the variable <inline-formula id="IE45"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">car</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that contains the number of bases of <italic toggle="yes">g</italic> that are shared with some <italic toggle="yes">k</italic>-mers of <italic toggle="yes">s</italic> seen so far — at the end, <inline-formula id="IE46"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">car</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> will be equal to <inline-formula id="IE47"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. Let <italic toggle="yes">e</italic> be the <italic toggle="yes">i</italic>-th leftmost <italic toggle="yes">k</italic>-mer of <italic toggle="yes">s</italic> and let <inline-formula id="IE48"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">GENES</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the set of genes containing <italic toggle="yes">e</italic> [obtained by querying <italic toggle="yes">D</italic>(<italic toggle="yes">G</italic>) as illustrated in <xref rid="btaa779-F1" ref-type="fig">Fig. 1]</xref>. Then, for each gene <italic toggle="yes">g</italic> in <inline-formula id="IE49"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">GENES</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the procedure updates <inline-formula id="IE50"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">car</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> by adding the number of new bases covered by <italic toggle="yes">e</italic> and shared between <italic toggle="yes">s</italic> and <italic toggle="yes">g</italic> (computed as <inline-formula id="IE51"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>), and sets <inline-formula id="IE52"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to the last position in <italic toggle="yes">s</italic> that is in <italic toggle="yes">e</italic>, equal to <italic toggle="yes">i</italic> +<italic toggle="yes"> k</italic>. At the end of the scan, each <inline-formula id="IE53"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">car</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is clearly the cardinality of <inline-formula id="IE54"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">SHARED</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and computing the origin gene of the read is trivial.</p>
    </sec>
    <sec>
      <title>2.3 Computational complexity</title>
      <p>Let us assume that <italic toggle="yes">H</italic> is computed in constant time since <italic toggle="yes">k</italic> is fixed and, for practical purposes, it is not &gt;32 (hence each <italic toggle="yes">k</italic>-mer can be represented in a single memory word). Constructing the index data structure <inline-formula id="IE55"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> requires <inline-formula id="IE56"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>g</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time (assuming that <inline-formula id="IE57"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">ran</mml:mi><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is computed in constant time) since duplicates (if any) in each list <italic toggle="yes">L<sub>i</sub></italic> are adjacent. Querying <italic toggle="yes">D</italic>(<italic toggle="yes">G</italic>) for the set of origin genes of a single <italic toggle="yes">k</italic>-mer <italic toggle="yes">e</italic> requires <inline-formula id="IE58"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="monospace">GENES</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (assuming that also <inline-formula id="IE59"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">selec</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is computed in constant time). Computing the origin gene of a read <italic toggle="yes">s</italic> requires <inline-formula id="IE60"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="italic">KMER</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mi mathvariant="monospace">ENES</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that is trivially upper bounded by <inline-formula id="IE61"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.4 Implementation</title>
      <p>The method described in Section 2.2 has been implemented in C++ and is freely available at <ext-link xlink:href="https://github.com/AlgoLab/shark" ext-link-type="uri">https://github.com/AlgoLab/shark</ext-link> and published on BioConda (<xref rid="btaa779-B16" ref-type="bibr">Grüning <italic toggle="yes">et al.</italic>, 2018</xref>). The program uses the implementation of bit vectors and of the associated rank and select operations provided by sdsl (<xref rid="btaa779-B14" ref-type="bibr">Gog <italic toggle="yes">et al.</italic>, 2014</xref>).</p>
      <p>The tool, called Shark, takes as input a FASTA file containing the set of gene regions of interest and an RNA-Seq sample in FASTQ format. For each read of the sample, the tool computes its set of (putative) origin genes (computing the gene assignment is then trivial). It is possible to tune the computation of the gene assignment by setting the following parameters: the <italic toggle="yes">k</italic>-mer size <italic toggle="yes">k</italic>, the confidence τ and the size <italic toggle="yes">m</italic> of the Bloom filter. The tool also allows to discard <italic toggle="yes">k</italic>-mers spanning bases whose quality is less than a given threshold <italic toggle="yes">q</italic>.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>To assess our method, we performed two different experimental analyses on simulated and real data. A first exploratory analysis on simulated data was performed to test the accuracy and the efficiency of Shark, especially with respect to its input parameters <italic toggle="yes">k</italic>, τ and <italic toggle="yes">q</italic>. Furthermore, we also investigated the influence of read length and gene size on the accuracy of Shark. The goal of the second part of the analysis was to evaluate, on real data, the effectiveness of Shark in speeding up four different pipelines (three mapping-first pipelines, Section 3.2, and an assembly-first pipeline, Section 3.3) for a common task in RNA-Seq data analysis, namely differential analysis of alternative splicing events, without affecting the results on the selected genes. All the experiments were performed on a 64 bit Linux (Kernel 4.4.0) system equipped with four 8-core Intel<sup>®</sup> Xeon 2.30 GHz processors and 256 GB of RAM. Information on how to reproduce the experiments are available at <ext-link xlink:href="https://github.com/AlgoLab/shark_experiments" ext-link-type="uri">https://github.com/AlgoLab/shark_experiments</ext-link> in the form of a Conda environment and several Snakemake workflows (<xref rid="btaa779-B21" ref-type="bibr">Köster and Rahmann, 2012</xref>). To reproduce the assembly-first experiments, we refer the reader to <ext-link xlink:href="http://kissplice.prabi.fr/pipeline_ks_farline/" ext-link-type="uri">http://kissplice.prabi.fr/pipeline_ks_farline/</ext-link>.</p>
    <sec>
      <title>3.1 Simulated data</title>
      <p>We performed an exploratory analysis on simulated data to test the accuracy and the efficiency of our method, especially with respect to its input parameters <italic toggle="yes">k</italic>, τ and <italic toggle="yes">q</italic>. To this aim, we considered the 9403 genes of Human chromosomes 1, 17 and 21 (<italic toggle="yes">Ensembl release 97</italic>) (<xref rid="btaa779-B10" ref-type="bibr">Cunningham <italic toggle="yes">et al.</italic>, 2019</xref>) and we simulated an RNA-Seq sample of 10 million 100 bp-long single-end reads using Flux Simulator (<xref rid="btaa779-B15" ref-type="bibr">Griebel <italic toggle="yes">et al.</italic>, 2012</xref>) (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref> for the simulation parameters). From the full set of genes, we selected 10 random subsets of 100 genes, producing 10 different instances. For each instance, Shark indexed the gene panel, consisting of the 100 considered genes, and then filtered the entire simulated RNA-Seq sample with respect to it. To assess accuracy and efficiency of Shark with respect to input parameters, we ran Shark with any combination of <inline-formula id="IE62"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>13</mml:mn><mml:mo>,</mml:mo><mml:mn>17</mml:mn><mml:mo>,</mml:mo><mml:mn>23</mml:mn><mml:mo>,</mml:mo><mml:mn>27</mml:mn><mml:mo>,</mml:mo><mml:mn>31</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>τ</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.4</mml:mn><mml:mo>,</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>0.8</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE63"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mn>20</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Furthermore, we tested Shark also by dropping reads that are assigned to more than one origin gene (‘single mode’). In such a mode, Shark completely discards ambiguous assignments (if a read can be assigned to two or more genes, then no association at all is given) and it is useful in these experiments to better understand the accuracy of Shark. The size of the Bloom filter was set to 1 GB (preliminary experiments showed that larger Bloom filters did not improve the accuracy of the prediction). Shark was allowed to use four threads to speed up the computation.</p>
      <p>The accuracy of Shark in computing the gene assignment was measured in terms of <italic toggle="yes">precision</italic> and <italic toggle="yes">recall</italic> as follows. Since the input reads have been simulated, we know the actual origin gene of each read. Let <inline-formula id="IE64"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="script">G</mml:mi></mml:mrow></mml:math></inline-formula> be the subset of genes of interest and <inline-formula id="IE65"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> be the set of genes which the set of reads <italic toggle="yes">S</italic> have been simulated from. Let <inline-formula id="IE66"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the output of Shark on <italic toggle="yes">S</italic> and <italic toggle="yes">G</italic> (we recall that <inline-formula id="IE67"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> is the subset of reads assigned to <italic toggle="yes">G<sub>i</sub></italic> by Shark). Then, each <inline-formula id="IE68"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a <italic toggle="yes">true positive</italic> (<inline-formula id="IE69"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>) if <italic toggle="yes">s</italic> was simulated from <italic toggle="yes">g<sub>i</sub></italic>, and it is a <italic toggle="yes">false positive</italic> (<inline-formula id="IE70"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>) otherwise. Finally, each read <inline-formula id="IE71"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> simulated from gene <italic toggle="yes">g<sub>i</sub></italic> such that <inline-formula id="IE72"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>∈</mml:mo></mml:menclose><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a <italic toggle="yes">false negative</italic> (<inline-formula id="IE73"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>). More intuitively, we consider each read associated to the correct origin gene of interest as a true positive and each read assigned to a gene of interest that was not simulated from that gene as a false positive. We note that with this definition, false positives occur in two slightly different cases: (i) when a read is simulated from a gene of interests and it is assigned to a different gene of the panel and (ii) when a read is simulated from a gene not in the gene panel and it is assigned to any gene in the gene panel. Finally, we consider as false negative each read simulated from a gene in the gene panel that was not assigned to the correct gene. Notice that, when Shark is run in multiple mode a read might be assigned to more than one gene, thus a read with two assignments (one to the correct gene and one to another gene) might induce both a true positive and a false positive. Moreover, when a read is assigned only to a wrong gene, it induces both a false positive (because it was assigned to the wrong gene) and a false negative (because it was not assigned to the right gene). Then, precision is defined as <inline-formula id="IE74"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>, while recall as <inline-formula id="IE75"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>f</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. Efficiency was measured in terms of running time and memory peak (using the/usr/bin/time system tool).</p>
      <p><xref rid="btaa779-F2" ref-type="fig">Figure 2</xref> reports the precision/recall curves for the different combinations of parameters (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref> for the entire set of results). The first important observation is that Shark achieves a good accuracy in terms of recall. Indeed, for sensible choices of the parameters, the recall is at least 99%, i.e. on average at most 1% of the reads that originated from the chosen subset of genes was discarded. The second observation is that the choice of the values for the parameters <italic toggle="yes">k</italic> and τ allows to achieve different trade-offs between precision and recall. Indeed, as <italic toggle="yes">k</italic> (or τ) increases, Shark becomes more precise (at the expense of recall).</p>
      <fig position="float" id="btaa779-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>Accuracy results — exploratory analysis. Accuracy is shown in terms of average precision and average recall obtained across the 10 performed runs. Lines connect data points with <inline-formula id="IE76"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mn>0.2</mml:mn><mml:mo>,</mml:mo><mml:mn>0.4</mml:mn><mml:mo>,</mml:mo><mml:mn>0.6</mml:mn><mml:mo>,</mml:mo><mml:mn>0.8</mml:mn><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula></p>
        </caption>
        <graphic xlink:href="btaa779f2" position="float"/>
      </fig>
      <p>The third observation is that Shark (as expected, since it is a <italic toggle="yes">k</italic>-mer-based approach) is sensitive to sequencing errors. Indeed, if low-quality bases are not filtered out (<italic toggle="yes">q</italic> = 0), the recall rapidly decreases under 98% as τ increases. However, the simple approach of filtering out low-quality bases allows to reduce the loss of recall as the precision sensibly increases. For example, for <italic toggle="yes">q</italic> = 10 (i.e. bases with quality &lt;10 are not considered) and <italic toggle="yes">k</italic> = 17, when τ increases from 0.4 to 0.6, we have that the precision gains 7.13 percentage points (from 21.67% to 28.80%) while the recall only decreases of 0.21% points (from 99.67% to 99.46%). Interestingly, an aggressive low-quality filter (<italic toggle="yes">q</italic> = 20) generally decreases the accuracy of Shark. This is probably due to the fact that, under this setting, the set of <italic toggle="yes">k</italic>-mers extracted from each read is too small for reliably finding its origin gene.</p>
      <p>As explained in Section 2.2, more than one gene can be assigned to a single read. To assess how these ambiguous assignments influence the accuracy, we ran Shark excluding any multiple assignment (‘single mode’). The accuracy of Shark in ‘single mode’ compared with the original ‘multiple mode’ is sensibly higher in terms of precision and slightly lower in terms of recall. For example, for <italic toggle="yes">k</italic> = 17, <inline-formula id="IE77"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.6</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">q</italic> = 10, in multiple mode the precision is 28.8% while in single mode it is 32.2%, whereas the recall is 99.46% and 99.28% in multiple and single mode, respectively. Also in this case, keeping or discarding ambiguous assignments is a user’s choice, depending on the choice between higher recall or higher precision.</p>
      <p>This experiment shows how accuracy is determined by the choice of the parameters. The results suggest that a good trade-off between precision and recall can be achieved with <italic toggle="yes">k</italic> = 17, <inline-formula id="IE78"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.6</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">q</italic> = 10.</p>
      <p>In terms of computational requirements, Shark never required more than 1.5 GB of RAM (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>), that is an amount of memory nowadays available on any desktop or laptop computer. Furthermore, using four threads, it never required more than 1 min to complete and, in particular, it never required more than 40 s for <inline-formula id="IE79"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mn>17</mml:mn></mml:mrow></mml:math></inline-formula> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref>). Albeit this experiment has been performed on a server platform, we expect that the running time will be practically negligible even on standard computers.</p>
      <p>We also investigated the influence of read length and gene size on the accuracy and on the computational requirements of Shark (Supplementary Section S2). We observed that neither the read length nor the gene size affects negatively the overall accuracy of Shark. Furthermore, Shark never required more than 2 min and 5 GB of RAM to complete any analysis.</p>
      <p>We also investigated how the number of genes of interest, i.e. the size of the input gene panel, affects the accuracy and efficiency of Shark. To this aim, we considered the 9403 genes from the 3 chromosomes analyzed in the previous experiments and we created 7 different gene panels of increasing sizes: from 100 genes to 9403 genes. We note that considering the largest gene panel is equivalent to filtering the reads with respect to the entire set of genes they were sequenced from (indeed, in that case, <inline-formula id="IE80"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="script">G</mml:mi></mml:mrow></mml:math></inline-formula>).</p>
      <p>We filtered with Shark, the 10 M single-end read sample simulated with Flux Simulator with respect to each panel and we evaluated the accuracy and efficiency of Shark as done in our previous analysis. We ran Shark with four threads in both single and multiple modes, setting <italic toggle="yes">k</italic> = 17, <inline-formula id="IE81"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mo>τ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.6</mml:mn></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">q</italic> = 10, and the size of the Bloom filter to 1 GB. <xref rid="btaa779-T1" ref-type="table">Table 1</xref> reports the results of this analysis. First of all, we observe that, by increasing the input panel size, Shark behaves differently if ran in single or multiple mode. Indeed, increasing the number of genes of interest allows Shark (ran in multiple mode) to increase its precision as well (from 20% to 69%), while not affecting its recall, which remains really high (<inline-formula id="IE82"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>99</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>). The increase in precision can be explained by the fact that, as the gene panel becomes larger, Shark is able to associate each read to the correct gene, while, if the correct origin gene is not in the panel, Shark associates the read to a different (but similar) gene of the panel. This hypothesis is further confirmed by the data on single mode. Indeed, as the gene panel size increases, Shark (single mode) is able to achieve a high level of precision (<inline-formula id="IE83"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>99</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> with the largest gene panel tested) at the expense of a lower recall that decreases from 99% to 75%. This was expected since the gene panel also contains similar genes (e.g. overlapping genes, albeit on opposite strands), thus associations to those genes become ambiguous and are discarded in single mode. A further analysis of accuracy with respect to the similarity among the genes of interest is presented in the accompanying repository (<ext-link xlink:href="https://github.com/AlgoLab/shark_experiments" ext-link-type="uri">https://github.com/AlgoLab/shark_experiments</ext-link>) but proved to be elusive due to the interplay of relative expression of overlapping genes (among the other factors).</p>
      <table-wrap position="float" id="btaa779-T1">
        <label>Table 1.</label>
        <caption>
          <p>Accuracy and efficiency results — varying gene panel sizes</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="4" rowspan="1">Shark (multiple mode)<hr/></th>
              <th colspan="4" rowspan="1">Shark (single mode)<hr/></th>
              <th colspan="4" rowspan="1">RapMap<hr/></th>
              <th colspan="4" rowspan="1">Puffaligner<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Gene panel size</th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">P</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">R</italic>
              </th>
              <th rowspan="1" colspan="1">Time (s)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">P</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">R</italic>
              </th>
              <th rowspan="1" colspan="1">Time (s)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">P</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">R</italic>
              </th>
              <th rowspan="1" colspan="1">Time (s)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">P</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">R</italic>
              </th>
              <th rowspan="1" colspan="1">Time (s)</th>
              <th rowspan="1" colspan="1">RAM (GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">19.6</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">27</td>
              <td rowspan="1" colspan="1">1.41</td>
              <td rowspan="1" colspan="1">21.9</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">33</td>
              <td rowspan="1" colspan="1">1.41</td>
              <td rowspan="1" colspan="1">21.5</td>
              <td rowspan="1" colspan="1">99.1</td>
              <td rowspan="1" colspan="1">51</td>
              <td rowspan="1" colspan="1">0.20</td>
              <td rowspan="1" colspan="1">3.4</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">47</td>
              <td rowspan="1" colspan="1">0.22</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">250</td>
              <td rowspan="1" colspan="1">45.7</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">35</td>
              <td rowspan="1" colspan="1">1.43</td>
              <td rowspan="1" colspan="1">50.3</td>
              <td rowspan="1" colspan="1">99.2</td>
              <td rowspan="1" colspan="1">36</td>
              <td rowspan="1" colspan="1">1.43</td>
              <td rowspan="1" colspan="1">52.1</td>
              <td rowspan="1" colspan="1">99.0</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">0.28</td>
              <td rowspan="1" colspan="1">6.6</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">0.27</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">500</td>
              <td rowspan="1" colspan="1">54.2</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">58</td>
              <td rowspan="1" colspan="1">1.46</td>
              <td rowspan="1" colspan="1">60.4</td>
              <td rowspan="1" colspan="1">98.1</td>
              <td rowspan="1" colspan="1">58</td>
              <td rowspan="1" colspan="1">1.46</td>
              <td rowspan="1" colspan="1">60.8</td>
              <td rowspan="1" colspan="1">99.1</td>
              <td rowspan="1" colspan="1">79</td>
              <td rowspan="1" colspan="1">0.48</td>
              <td rowspan="1" colspan="1">7.1</td>
              <td rowspan="1" colspan="1">99.4</td>
              <td rowspan="1" colspan="1">90</td>
              <td rowspan="1" colspan="1">0.36</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">1000</td>
              <td rowspan="1" colspan="1">58.6</td>
              <td rowspan="1" colspan="1">99.6</td>
              <td rowspan="1" colspan="1">103</td>
              <td rowspan="1" colspan="1">1.57</td>
              <td rowspan="1" colspan="1">66.6</td>
              <td rowspan="1" colspan="1">98.4</td>
              <td rowspan="1" colspan="1">96</td>
              <td rowspan="1" colspan="1">1.57</td>
              <td rowspan="1" colspan="1">65.6</td>
              <td rowspan="1" colspan="1">98.9</td>
              <td rowspan="1" colspan="1">110</td>
              <td rowspan="1" colspan="1">0.87</td>
              <td rowspan="1" colspan="1">9.1</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">120</td>
              <td rowspan="1" colspan="1">0.43</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">2500</td>
              <td rowspan="1" colspan="1">60.7</td>
              <td rowspan="1" colspan="1">99.7</td>
              <td rowspan="1" colspan="1">241</td>
              <td rowspan="1" colspan="1">1.86</td>
              <td rowspan="1" colspan="1">73.7</td>
              <td rowspan="1" colspan="1">91.7</td>
              <td rowspan="1" colspan="1">248</td>
              <td rowspan="1" colspan="1">1.86</td>
              <td rowspan="1" colspan="1">66.9</td>
              <td rowspan="1" colspan="1">98.9</td>
              <td rowspan="1" colspan="1">174</td>
              <td rowspan="1" colspan="1">1.81</td>
              <td rowspan="1" colspan="1">13.6</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">184</td>
              <td rowspan="1" colspan="1">0.70</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">5000</td>
              <td rowspan="1" colspan="1">65.2</td>
              <td rowspan="1" colspan="1">99.6</td>
              <td rowspan="1" colspan="1">441</td>
              <td rowspan="1" colspan="1">2.47</td>
              <td rowspan="1" colspan="1">84.7</td>
              <td rowspan="1" colspan="1">85.0</td>
              <td rowspan="1" colspan="1">492</td>
              <td rowspan="1" colspan="1">2.47</td>
              <td rowspan="1" colspan="1">71.9</td>
              <td rowspan="1" colspan="1">98.8</td>
              <td rowspan="1" colspan="1">325</td>
              <td rowspan="1" colspan="1">3.79</td>
              <td rowspan="1" colspan="1">26.2</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">277</td>
              <td rowspan="1" colspan="1">1.00</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">10 000</td>
              <td rowspan="1" colspan="1">68.9</td>
              <td rowspan="1" colspan="1">99.6</td>
              <td rowspan="1" colspan="1">898</td>
              <td rowspan="1" colspan="1">3.38</td>
              <td rowspan="1" colspan="1">99.9</td>
              <td rowspan="1" colspan="1">75.1</td>
              <td rowspan="1" colspan="1">934</td>
              <td rowspan="1" colspan="1">3.38</td>
              <td rowspan="1" colspan="1">75.5</td>
              <td rowspan="1" colspan="1">98.7</td>
              <td rowspan="1" colspan="1">526</td>
              <td rowspan="1" colspan="1">6.37</td>
              <td rowspan="1" colspan="1">64.7</td>
              <td rowspan="1" colspan="1">99.3</td>
              <td rowspan="1" colspan="1">431</td>
              <td rowspan="1" colspan="1">1.55</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: Accuracy is shown in terms of precision (<italic toggle="yes">P</italic>) and recall (<italic toggle="yes">R</italic>), while efficiency in terms of running time (Time, in seconds) and peak memory usage (RAM, in GB).</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The experiment confirmed that Shark is efficient: on the largest gene panel, it required ∼15 min and 3 GB of RAM, an amount nowadays available on any PC.</p>
      <p>To better evaluate Shark accuracy and efficiency, we compared it against RapMap (<xref rid="btaa779-B27" ref-type="bibr">Srivastava <italic toggle="yes">et al.</italic>, 2016</xref>), a quasi-mapper, and Puffaligner, an aligner based on compacted colored de Bruijn graphs (<xref rid="btaa779-B1" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2018</xref>). Although these tools are not designed to directly compute a gene assignment and the corresponding partitioning of the input RNA-Seq sample, they can be used to perform very fast read alignment that can be post-processed to extract the corresponding gene assignment. We provided the gene sequences to RapMap whereas we provided both the gene sequences and the gene transcripts to Puffaligner (as suggested in the project documentation). We ran both the tools with four threads. To compute their precision and recall, we adopted the same measures used to evaluate Shark.</p>
      <p><xref rid="btaa779-T1" ref-type="table">Table 1</xref> reports the results of this comparison. First of all, we observe that RapMap and Puffaligner behave more similarly to Shark ran in multiple mode than to Shark ran in single mode. Indeed, both the aligners report primary and secondary alignments and in our analysis, we considered both of them (but only an alignment per gene). Instead, if we consider only the primary alignments (data not shown), we observe a straight drop in the recall of the two tools: most of the correct assignments are indeed derived from secondary alignments. Furthermore, since RapMap and Puffaligner are not able to compute spliced alignments, we relaxed any additional check performed by these tools in order to accept even low-quality alignments (please refer to <ext-link xlink:href="https://github.com/AlgoLab/shark_experiments" ext-link-type="uri">https://github.com/AlgoLab/shark_experiments</ext-link> for the list of parameters that have been used). Otherwise, we would have observed lower levels of recall.</p>
      <p>In this non-standard setting, we were able to let RapMap and Puffaligner achieve a very high recall (<inline-formula id="IE84"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>99</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>). Anyway, Shark is able to achieve even better recall than the other two tools for all panel sizes.</p>
      <p>Surprisingly, precision of Puffaligner is significantly lower than that of Shark and RapMap (<inline-formula id="IE85"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula> times lower) for all panel sizes but the largest one. In our opinion, this result suggests that Puffaligner, in its current form and despite its merits as aligner, is not a suitable choice for computing a gene assignment.</p>
      <p>RapMap is slightly more precise than Shark for all panel sizes but the smallest one, at the expense of a slightly less recall. We remark that, for the specific purpose Shark has been designed, achieving better recall is more important than achieving better precision, since discarding potentially relevant reads may introduce biases in the downstream analysis whereas lower precision will only lead to lower improvements in the running times.</p>
      <p>In terms of memory, all the tools were able to complete the analysis using &lt;4 GB of RAM. The only exception is RapMap on the largest gene panel, which required more than 6 GB of memory (while Shark and Puffaligner used 3.4 and 1.6 GB, respectively). On gene panels composed by at most 1000 genes, Shark, which has been designed for panels whose size is in this range, is slightly faster than the other two tools.</p>
      <p>We remark that RapMap and Puffaligner were run with non-standard settings in order to achieve levels of recall comparable to those of Shark. However, especially for RapMap, this means that alignments of only a rather small portion of the read were accepted. Otherwise, since neither RapMap nor Puffaligner computes spliced alignments, they would not accept reads mapping to a splice junction. For this reason, we argue that, as the read length increases, Shark would be able to assign reads more accurately than the other twos. Indeed, Shark would map all the <italic toggle="yes">k</italic>-mers to the gene sequences, whereas RapMap (and Puffaligner if novel exons are present) would keep only a portion of the read falling inside an exon.</p>
      <p>These results are promising and we believe that Shark can be effectively used to filter an RNA-Seq sample with respect to large gene panels. However, we stress that the main goal of Shark is to filter a set of reads with respect to a limited number of genes of interest in order to speed up their downstream analysis. On this kind of instances, Shark is slightly faster and has consistently higher recall than other approaches. Running Shark on a large gene panel (or even on the entire set of annotated genes), though feasible, may not significantly reduce the size of the input sample, thus not leading to any speedup in the following RNA-Seq analysis, especially if the analysis is based on fast and efficient pipelines.</p>
    </sec>
    <sec>
      <title>3.2 Replication of a mapping-first differential AS analysis</title>
      <p>In the second part of our experimental evaluation, we partially replicate the analysis of a real RNA-Seq dataset performed in <xref rid="btaa779-B30" ref-type="bibr">Trincado <italic toggle="yes">et al.</italic> (2018)</xref> in order to assess the effectiveness of our tool in speeding up state-of-the-art pipelines for differential analysis of alternative splicing.</p>
      <p>We considered the three pipelines based on SplAdder (<xref rid="btaa779-B18" ref-type="bibr">Kahles <italic toggle="yes">et al.</italic>, 2016</xref>), rMATS (<xref rid="btaa779-B26" ref-type="bibr">Shen <italic toggle="yes">et al.</italic>, 2014</xref>) and SUPPA2 (<xref rid="btaa779-B30" ref-type="bibr">Trincado <italic toggle="yes">et al.</italic>, 2018</xref>). The first two tools analyze the RNA-Seq alignments computed by a spliced aligner, while the last one — SUPPA2 — analyzes the transcript quantifications computed by Salmon. In the following, we will refer to the three pipelines only by the name of the tools for the differential analysis, i.e. SplAdder, rMATS and SUPPA2. We remark that the aim of this part is not to evaluate the accuracy of the results of these pipelines, but to verify (i) whether their findings are affected by the preprocessing step performed by Shark and (ii) how much Shark can speed up their analyses. As mentioned in Section 1, pipelines based on STAR cannot be trivially speeded up by restricting the reference to the selected genes, while others — such as SUPPA2 — likely run faster if the reference is restricted. However, since SUPPA2 already uses a modest amount of computing resources, the benefits of restricting the reference (or of using Shark, as we will show) will be less dramatic.</p>
      <p>The dataset used in this evaluation consists of a set of six paired-end RNA-Seq samples (GEO accession number <italic toggle="yes">GSE59335</italic>): three samples obtained before and three obtained after the double knockdown of two splicing regulatory proteins, namely TRA2A and TRA2B (<xref rid="btaa779-B6" ref-type="bibr">Best <italic toggle="yes">et al.</italic>, 2014</xref>). Each sample contains between 22 and 25 million paired-end reads of length 101 bp. We decided to test the tools on this dataset since in the study 83 exon skipping events have been validated experimentally by RT-PCR, thus we can use such events as a ground truth to assess the effect of using Shark as preprocessing step.</p>
      <p>In this analysis, we ran Shark setting <italic toggle="yes">k</italic>=17, τ=0.6, <italic toggle="yes">q</italic>=10 and the Bloom filter size to 1GB. We chose these values since, as proved in the previous analysis, they achieve a good trade-off between precision and recall. All tools were ran with their default parameters (allowing up to four threads), while the spliced alignments required by the first two pipelines were computed by STAR (<xref rid="btaa779-B13" ref-type="bibr">Dobin <italic toggle="yes">et al.</italic>, 2013</xref>) in two-pass mode.</p>
      <p>We initially computed the differentially spliced events with the three aforementioned pipelines considering the original RNA-Seq samples and then we repeated the analysis considering the RNA-Seq samples preprocessed with Shark on the 82 different gene regions involved in the 83 RT-PCR validated events. On average, the filtered samples contain ∼2.3% of the original reads. <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref> reports the differences in terms of number of reads and uncompressed file size between the original samples and the samples filtered by Shark.</p>
      <p>We considered the 83 alternative splicing events validated by RT-PCR and we evaluated if the ability of the three pipelines in detecting such events is affected by the preprocessing step performed by Shark. <xref rid="btaa779-T2" ref-type="table">Table 2</xref> reports the results of this analysis.</p>
      <table-wrap position="float" id="btaa779-T2">
        <label>Table 2.</label>
        <caption>
          <p>Accuracy and efficiency of the three pipelines for differential analysis of alternative splicing on the original samples compared with those obtained on the samples filtered by Shark</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">RT-PCR events<hr/></th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">RAM</th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Pipeline</th>
              <th rowspan="1" colspan="1">All</th>
              <th rowspan="1" colspan="1">
                <inline-formula id="IE86">
                  <mml:math id="IM80" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mo>-</mml:mo>
                      <mml:mtext>value</mml:mtext>
                      <mml:mo>&lt;</mml:mo>
                      <mml:mn>0.05</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </th>
              <th rowspan="1" colspan="1">(min)</th>
              <th rowspan="1" colspan="1">(GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">rMATS</td>
              <td rowspan="1" colspan="1">78</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">328</td>
              <td rowspan="1" colspan="1">33.9</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Shark + rMATS</td>
              <td rowspan="1" colspan="1">78</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">154</td>
              <td rowspan="1" colspan="1">33.9</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">SplAdder</td>
              <td rowspan="1" colspan="1">56</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">915</td>
              <td rowspan="1" colspan="1">33.9</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Shark + SplAdder</td>
              <td rowspan="1" colspan="1">56</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">351</td>
              <td rowspan="1" colspan="1">33.9</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">SUPPA2</td>
              <td rowspan="1" colspan="1">66</td>
              <td rowspan="1" colspan="1">44</td>
              <td rowspan="1" colspan="1">117</td>
              <td rowspan="1" colspan="1">1.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Shark + SUPPA2</td>
              <td rowspan="1" colspan="1">66</td>
              <td rowspan="1" colspan="1">51</td>
              <td rowspan="1" colspan="1">42</td>
              <td rowspan="1" colspan="1">1.7</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic toggle="yes">Note</italic>: Accuracy is evaluated in terms of the number of RT-PCR validated events detected by each pipeline (over a total of 83 RT-PCR validated events). Efficiency is evaluated in terms of running time and maximum memory usage.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The first observation is that all the pipelines detected the same RT-PCR validated events in both the considered scenarios (i.e. on the original samples and on the filtered ones), confirming that the preprocessing step performed with Shark does not affect the accuracy of their differential splicing analysis. More precisely, out of the 83 RT-PCR validated events, rMATS detected 78 differentially spliced events, SUPPA2 detected 66 events, and SplAdder detected 56 events, under both conditions.</p>
      <p>If we restrict our analysis only to events reported as statistically significant by each tool (i.e. the events with <italic toggle="yes">P</italic>-value smaller than 0.05), the results follow the same trend, further confirming that the preprocessing step does not negatively impact the differential analysis. Indeed, rMATS reported the highest number of events (63) followed by SUPPA2. Interestingly, SUPPA2 identified seven additional significant events when considering the samples preprocessed by Shark w.r.t. the 44 events detected on the original samples. A manual inspection of the events in the two scenarios revealed that the differences between the respective <italic toggle="yes">P</italic>-values were rather small. On the other hand, in both scenarios SplAdder reported all the events with a <italic toggle="yes">P</italic>-value close to 1 (hence not significant).</p>
      <p>We also investigated the effect of filtering on the intermediate results of the pipelines. As an example, <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S3</xref> compares the outputs obtained by the transcript quantifier Salmon (one of the steps of the SUPPA2 pipeline) on the full and on the filtered dataset. Albeit the absolute values of the quantification differ in magnitude, the Pearson’s correlation coefficient between all the three pairs of series is high (<inline-formula id="IE87"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0.998</mml:mn></mml:mrow></mml:math></inline-formula>), confirming, as expected, that the outcome of any differential analysis performed on the filtered dataset should not be affected by the filtering process.</p>
      <p>The second important observation is that, as expected, preprocessing the input samples with Shark makes the three pipelines faster. Indeed, Shark (which required &lt;5 min to process each sample) allows all those pipelines to complete their analysis in around half the time. More precisely, rMATS took 2.5 h (saving 3 h), SplAdder completed its analysis in &lt;6 h (saving 9.5 h) and SUPPA2 took only 40 min instead of 2 h. The difference of the running times in the two scenarios is important (especially for rMATS and SplAdder), even on the relatively small dataset, we considered here. Notice that, the running time of Shark is linear in the number of input reads, and we only read once the set of reads. This fact implies that larger datasets (e.g. with more replicates or across several conditions or with higher-coverage samples) should show an even larger (absolute) reduction of running times of the complete analyses. While STAR and Salmon perform an indexing procedure only once, Shark indexes the input gene regions for each sample — hence, a more refined implementation that builds the index of the gene sequences only once could save even more time, especially for a larger number of samples.</p>
      <p>Lastly, this experiment shows that peak memory usage is almost unaffected by Shark. Indeed Shark required &lt;1.5 GB of RAM to process the input samples, which is significantly less than the peak memory usage of rMATS and SplAdder (33.9 GB) and comparable to that of SUPPA2 (1.7 GB). In particular, the peak memory usage for rMATS and SplAdder is reached in the alignment step. In this step, STAR loads the entire genome index in memory, hence its memory usage is largely independent on the input sample size.</p>
      <p>We then investigated how to reduce the memory usage of STAR, that is the most memory intensive step of the pipelines we tested, to allow any pipeline to be run on standard machines typically equipped with &lt;32 GB of RAM. When low memory usage is required, it is possible to reduce the memory usage of STAR by using its option for constructing a sparse index, namely --genomeSAsparseD, at the expense of increasing its running times (according to the tool documentation). However, since, we showed that Shark greatly reduces the input sample size and hence the time required by the alignment step, we expect that the resulting pipeline should be still faster than the classic one on the original samples. To evaluate our claim, we ran the two STAR-based pipelines multiple times on both the original samples and the samples preprocessed with Shark, each time increasing the sparsity of the STAR index. <xref rid="btaa779-T3" ref-type="table">Table 3</xref> reports the results obtained with sparsity equal to 8—the lowest value that allows to keep memory usage under 16 GB, an amount nowadays common on standard PCs.</p>
      <table-wrap position="float" id="btaa779-T3">
        <label>Table 3.</label>
        <caption>
          <p>Accuracy and efficiency of the STAR-based pipelines for differential analysis of alternative splicing on the original samples compared with those obtained on the samples filtered by Shark</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">RT-PCR events<hr/></th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">RAM</th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Pipeline</th>
              <th rowspan="1" colspan="1">All</th>
              <th rowspan="1" colspan="1">
                <inline-formula id="IE88">
                  <mml:math id="IM82" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mo>-</mml:mo>
                      <mml:mtext>value</mml:mtext>
                      <mml:mo>&lt;</mml:mo>
                      <mml:mn>0.05</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </th>
              <th rowspan="1" colspan="1">(min)</th>
              <th rowspan="1" colspan="1">(GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">rMATS</td>
              <td rowspan="1" colspan="1">78</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">632</td>
              <td rowspan="1" colspan="1">15.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Shark + rMATS</td>
              <td rowspan="1" colspan="1">78</td>
              <td rowspan="1" colspan="1">63</td>
              <td rowspan="1" colspan="1">138</td>
              <td rowspan="1" colspan="1">15.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">SplAdder</td>
              <td rowspan="1" colspan="1">56</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">1220</td>
              <td rowspan="1" colspan="1">15.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Shark + SplAdder</td>
              <td rowspan="1" colspan="1">56</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">326</td>
              <td rowspan="1" colspan="1">15.7</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn3">
            <p><italic toggle="yes">Note</italic>: The results have been obtained with --genomeSAsparseD=8 — a parameter that affects the sparsity of the index built and used by STAR. Accuracy is evaluated in terms of the number of RT-PCR validated events detected by each pipeline (over a total of 83 RT-PCR validated events). Efficiency is evaluated in terms of running time and maximum memory usage.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The first observation is that the sparsity of the index built by STAR does not affect the accuracy of the downstream pipelines for the differential analysis of alternative splicing. Indeed, both rMATS and SplAdder detected the same RT-PCR validated events in all the runs we performed.</p>
      <p>The second observation is that increasing the sparsity of the index allows to reduce the memory usage of each pipeline, from more than 33 GB to &lt;16 GB. Moreover, as expected, the sparsity of the index greatly affects the overall running times of the pipelines when they consider the original RNA-Seq dataset (<inline-formula id="IE89"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mo>+</mml:mo><mml:mn>93</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> for rMATS and <inline-formula id="IE90"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mo>+</mml:mo><mml:mn>33</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> for SplAdder, see <xref rid="btaa779-T3" ref-type="table">Table 3</xref> compared with <xref rid="btaa779-T2" ref-type="table">Table 2</xref>). On the other hand, since the filtered dataset is considerably smaller than the original one, the sparsity of the index does not sensibly affect the running times of the STAR alignment step and, hence, of the pipelines when run on the filtered dataset.</p>
    </sec>
    <sec>
      <title>3.3 Replication of an assembly-first differential as analysis</title>
      <p>In the third part of our experimental evaluation, we focused on the replication of an assembly-first differential alternative splicing analysis. Assembly-first approaches are based on first assembling the RNA-Seq reads depending on their overlaps and then aligning the assembled sequences to the reference genome. <xref rid="btaa779-B4" ref-type="bibr">Benoit-Pilven <italic toggle="yes">et al.</italic> (2018)</xref> show that mapping-first approaches (as those considered in the previous section) and assembly-first approaches (as the one considered in this section) are complementary, in the sense that, while they agree on the vast majority of their findings, each one is able to detect specific cases that the other one is not able to report (lowly-expressed variants for mapping-first approaches and novel variants for assembly-first approaches). We want to point out that assembly-first approaches are, in general, computationally demanding, thus filtering reads using Shark can be highly beneficial in order to speed up such an analysis and reducing the peak memory usage. Furthermore, we highlight that our filtering approach does not perform alignments (or pseudo-alignments) to the transcript sequences. As a consequence, Shark should not filter out reads supporting novel variants, which are mainly detected by assembly-first approaches. Hence, it is reasonable to use it as a preprocessing step of an assembly-first pipeline.</p>
      <p>To this aim, we partially replicated the analysis performed by <xref rid="btaa779-B4" ref-type="bibr">Benoit-Pilven <italic toggle="yes">et al.</italic> (2018)</xref> using the assembly-first KisSplice pipeline on an RNA-Seq dataset of the MCF-7 breast cancer cell line (GEO accession number <italic toggle="yes">GSE94372</italic>). The dataset is composed of two biological replicates on two conditions: a control condition and the depletion of two RNA helicases (DDX5 and DDX17). Each sample contains between 32 and 35 million paired-end reads of length 125 bp.</p>
      <p>Similarly as we did in the previous section, we focused on the subset of 48 genes for which the authors performed an experimental RT-PCR validation of a differential alternative splicing event detected by at least one pipeline of the twos they used in the work.</p>
      <p>As performed in the analysis we replicated, raw reads were preprocessed by trimming and removing the adapters according to standard quality control filters. The resulting dataset was then analyzed using the commands reported at <ext-link xlink:href="http://kissplice.prabi.fr/pipeline_ks_farline/" ext-link-type="uri">http://kissplice.prabi.fr/pipeline_ks_farline/</ext-link> on the full dataset and on the dataset filtered with Shark. Shark was ran setting <italic toggle="yes">k</italic> =17, τ=0.6, <italic toggle="yes">q</italic>=10 and the Bloom filter size to 1 GB.</p>
      <p>We considered all the differentially spliced events occurring in the 48 genes for which an experimental validation has been performed. Notice that, differently from the previous section, we did not consider only the RT-PCR validated events since they were not unambiguously reported, hence it was not possible to focus only on them.</p>
      <p><xref rid="btaa779-F3" ref-type="fig">Figure 3</xref> reports the comparison between the events reported on the full dataset (and then keeping only those mapping to one of the 48 selected genes) and those reported on the filtered dataset. The first important observation is that the predicted events almost perfectly coincide. Indeed, 246 (97.6%) events were reported on both the full dataset and on the filtered dataset. Only four (1.6%) events were predicted exclusively on the full dataset while two (0.8%) events were predicted exclusively on the filtered dataset. If we focus on the events reported as statistically significant (<inline-formula id="IE91"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>-</mml:mo><mml:mtext>value</mml:mtext><mml:mo>&lt;</mml:mo><mml:mn>0.05</mml:mn></mml:mrow></mml:math></inline-formula>), 81 of them were reported on both dataset, a single event was reported as statistically significant on the full dataset but as not statistically significant on the filtered dataset, while 4 were reported as statistically significant on the filtered dataset but as not statistically significant on the full dataset. Manual inspection of the differences revealed that the reported Percent Spliced In ( <inline-formula id="IE92"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mo>Δ</mml:mo><mml:mi mathvariant="italic">PSI</mml:mi></mml:mrow></mml:math></inline-formula>) for these events are highly similar. Interestingly, no event reported as statistically significant on a dataset was missing in the other dataset (albeit it could be reported as not statistically significant).</p>
      <fig position="float" id="btaa779-F3">
        <label>Fig. 3.</label>
        <caption>
          <p>Comparison of differential alternative splicing events mapping to one of the 48 selected genes as predicted by KisSplice on the full dataset (left oval) and on the dataset filtered by Shark (right oval). Inner ovals represent the events predicted with <inline-formula id="IE93"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>-</mml:mo><mml:mtext>value</mml:mtext><mml:mo>&lt;</mml:mo><mml:mn>0.05</mml:mn></mml:mrow></mml:math></inline-formula></p>
        </caption>
        <graphic xlink:href="btaa779f3" position="float"/>
      </fig>
      <p>In terms of running times, Shark allows to achieve a considerable speed up (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S4</xref>). Indeed, the total running time on the full dataset (after trimming) is 26 h and 37 min, while on the filtered dataset the pipeline (including the filtering step) took 3 h and 30 min to complete (<inline-formula id="IE94"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mn>6.1</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> relative speedup).</p>
    </sec>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>In this work, we introduced the novel computational problem of computing the gene assignment of an RNA-Seq sample with respect to a set of genes. We also proposed an algorithmic approach to solve this problem and we also implemented it, resulting in the tool, Shark. To the best of our knowledge, Shark is the first tool specifically designed for computing a gene assignment.</p>
    <p>We performed an experimental analysis on real data where we evaluated the effectiveness of Shark in speeding up state-of-the-art pipelines for the differential analysis of alternative splicing. Overall, Shark proved to be a preprocessing step that preserves valuable information (i.e. reads) of the selected genes and hence does not negatively affect any downstream pipeline for the differential analysis of alternative splicing. On the other hand, it allows to significantly reduce the size of the input samples, hence it speeds up the pipelines, especially those based on read alignment and read assembly. Furthermore, the efficiency of Shark, combined with an appropriate selection of the different parameters that may be used to influence the performance of the downstream analyses (e.g. the sparsity of the index of STAR), allows to bring all those analyses — nowadays performed on servers — to modern desktop computers.</p>
    <p>The accuracy and the efficiency of Shark depend on its parameters <italic toggle="yes">k</italic>, τ and <italic toggle="yes">q</italic> that are the <italic toggle="yes">k</italic>-mer size, the minimum confidence and the base quality threshold, respectively. For this reason, future steps will focus on allowing Shark to automatically estimate the best values of these parameters by exploiting extra information on the read length and the error rate. Furthermore, including also the annotated transcripts in the index or perform a preliminary filtering step using transcript sequences could improve the running times, especially on large gene panels, without affecting accuracy.</p>
    <p>Since Shark can be used as a preliminary step in pipelines for the detection of novel alternative splicing events from samples of RNA-Seq data, future work will be devoted to an in-depth experimental analysis of Shark as a preliminary step of a pipeline that includes computationally demanding tools, such as ASGAL (<xref rid="btaa779-B11" ref-type="bibr">Denti <italic toggle="yes">et al.</italic>, 2018</xref>), that relies on mapping reads against a splicing graph, and Trinity (<xref rid="btaa779-B17" ref-type="bibr">Haas <italic toggle="yes">et al.</italic>, 2013</xref>), that assembles RNA-Seq reads, performs transcript abundance estimation and identifies differentially expressed transcripts across samples.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btaa779_Supplementary_Data</label>
      <media xlink:href="btaa779_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank Murray Patterson and the anonymous reviewers for their insightful comments about the manuscript.</p>
    <sec>
      <title>Funding</title>
      <p>This project has received funding from the European Union’s Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie grant agreement number [872539].</p>
      <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btaa779-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Almodaresi</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>A space and time-efficient index for the compacted colored de Bruijn graph</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>i169</fpage>–<lpage>i177</lpage>.<pub-id pub-id-type="pmid">29949982</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B2">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Almodaresi</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) An efficient, scalable and exact representation of high-dimensional color information enabled via de Bruijn graph search. In: <source>RECOMB</source>. pp. <fpage>1</fpage>–<lpage>18</lpage>. Springer, Cham.</mixed-citation>
    </ref>
    <ref id="btaa779-B3">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Belazzougui</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) Fully dynamic de Bruijn graphs. In: <source>SPIRE</source>. pp. <fpage>145</fpage>–<lpage>152</lpage>. Springer, Cham.</mixed-citation>
    </ref>
    <ref id="btaa779-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Benoit-Pilven</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>Complementarity of assembly-first and mapping-first approaches for alternative splicing annotation and differential analysis from RNAseq data</article-title>. <source>Sci. Rep</source>., <volume>8</volume>, <fpage>1</fpage>–<lpage>13</lpage>.<pub-id pub-id-type="pmid">29311619</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Beretta</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <italic toggle="yes">Mapping RNA-seq Data to a Transcript Graph Via Approximate Pattern Matching to a Hypertext</italic>. In: <person-group person-group-type="editor"><string-name><surname>Figueiredo</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (eds) Lecture Notes in Computer Science. Algorithms for Computational Biology - 4th International Conference, AlCoB 2017, Aveiro, Portugal, June 5–6, 2017, Proceedings. Vol. <volume>10252</volume>, pp. <fpage>49</fpage>–<lpage>61</lpage>, 
<publisher-name>Springer</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btaa779-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Best</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) 
<article-title>Human Tra2 proteins jointly control a CHEK1 splicing switch among alternative and constitutive target exons</article-title>. <source>Nat. Commun</source>., <volume>5</volume>, <fpage>4760</fpage>.<pub-id pub-id-type="pmid">25208576</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bloom</surname><given-names>B.H.</given-names></string-name></person-group> (<year>1970</year>) 
<article-title>Space/time trade-offs in hash coding with allowable errors</article-title>. <source>Commun. ACM</source>, <volume>13</volume>, <fpage>422</fpage>–<lpage>426</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa779-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bray</surname><given-names>N.L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) 
<article-title>Near-optimal probabilistic RNA-seq quantification</article-title>. <source>Nat. Biotechnol</source>., <volume>34</volume>, <fpage>525</fpage>–<lpage>527</lpage>.<pub-id pub-id-type="pmid">27043002</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Conesa</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) 
<article-title>A survey of best practices for RNA-seq data analysis</article-title>. <source>Genome Biol</source>., <volume>17</volume>, <fpage>13</fpage>.<pub-id pub-id-type="pmid">26813401</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cunningham</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) 
<article-title>Ensembl</article-title>. <source>Nucleic Acids Res</source>., <volume>47</volume>, <fpage>D745</fpage>–<lpage>D751</lpage>.<pub-id pub-id-type="pmid">30407521</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Denti</surname><given-names>L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>ASGAL: aligning RNA-Seq data to a splicing graph to detect novel alternative splicing events</article-title>. <source>BMC Bioinformatics</source>, <volume>19</volume>, <fpage>444</fpage>.<pub-id pub-id-type="pmid">30458725</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Denti</surname><given-names>L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) 
<article-title>MALVA: genotyping by mapping-free allele detection of known variants</article-title>. <source>iScience</source>, <volume>18</volume>, <fpage>20</fpage>–<lpage>27</lpage>.<pub-id pub-id-type="pmid">31352182</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dobin</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) 
<article-title>STAR: ultrafast universal RNA-seq aligner</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>15</fpage>–<lpage>21</lpage>.<pub-id pub-id-type="pmid">23104886</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B14">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Gog</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) From theory to practice: plug and play with succinct data structures. In: <source>SEA</source>. pp. <fpage>326</fpage>–<lpage>337</lpage>. Springer, Cham.</mixed-citation>
    </ref>
    <ref id="btaa779-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Griebel</surname><given-names>T.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) 
<article-title>Modelling and simulating generic RNA-Seq experiments with the flux simulator</article-title>. <source>Nucleic Acids Res</source>., <volume>40</volume>, <fpage>10073</fpage>–<lpage>10083</lpage>.<pub-id pub-id-type="pmid">22962361</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Grüning</surname><given-names>B.</given-names></string-name></person-group>  <etal>et al</etal>; The Bioconda Team. (<year>2018</year>) 
<article-title>Bioconda: sustainable and comprehensive software distribution for the life sciences</article-title>. <source>Nat. Methods</source>, <volume>15</volume>, <fpage>475</fpage>–<lpage>476</lpage>.<pub-id pub-id-type="pmid">29967506</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Haas</surname><given-names>B.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) 
<article-title>De novo transcript sequence reconstruction from RNA-Seq: reference generation and analysis with trinity</article-title>. <source>Nat. Protoc</source>., <volume>8</volume>, <fpage>1494</fpage>–<lpage>1512</lpage>.<pub-id pub-id-type="pmid">23845962</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kahles</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) 
<article-title><italic toggle="yes">SplAdder</italic>: identification, quantification and testing of alternative splicing events from RNA-Seq data</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>1840</fpage>–<lpage>1847</lpage>.<pub-id pub-id-type="pmid">26873928</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kahles</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>Comprehensive analysis of alternative splicing across tumors from 8,705 patients</article-title>. <source>Cancer Cell</source>, <volume>34</volume>, <fpage>211</fpage>–<lpage>224</lpage>.<pub-id pub-id-type="pmid">30078747</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kokot</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) 
<article-title>KMC 3: counting and manipulating k-mer statistics</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>2759</fpage>–<lpage>2761</lpage>.<pub-id pub-id-type="pmid">28472236</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Köster</surname><given-names>J.</given-names></string-name>, <string-name><surname>Rahmann</surname><given-names>S.</given-names></string-name></person-group> (<year>2012</year>) 
<article-title>Snakemake–a scalable bioinformatics workflow engine</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>2520</fpage>–<lpage>2522</lpage>.<pub-id pub-id-type="pmid">22908215</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marçais</surname><given-names>G.</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group> (<year>2011</year>) 
<article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>764</fpage>–<lpage>770</lpage>.<pub-id pub-id-type="pmid">21217122</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Patro</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) 
<article-title>Sailfish enables alignment-free isoform quantification from RNA-seq reads using lightweight algorithms</article-title>. <source>Nat. Biotechnol</source>., <volume>32</volume>, <fpage>462</fpage>–<lpage>464</lpage>.<pub-id pub-id-type="pmid">24752080</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Patro</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) 
<article-title>Salmon provides fast and bias-aware quantification of transcript expression</article-title>. <source>Nat. Methods</source>, <volume>14</volume>, <fpage>417</fpage>–<lpage>419</lpage>.<pub-id pub-id-type="pmid">28263959</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sacomoto</surname><given-names>G.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) 
<article-title>KISSPLICE: de-novo calling alternative splicing events from RNA-seq data</article-title>. <source>BMC Bioinformatics</source>, <volume>13</volume>, <fpage>S5</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa779-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shen</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) 
<article-title>rMATS: robust and flexible detection of differential alternative splicing from replicate RNA-Seq data</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>111</volume>, <fpage>E5593</fpage>–<lpage>E5601</lpage>.<pub-id pub-id-type="pmid">25480548</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Srivastava</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) 
<article-title>RapMap: a rapid, sensitive and accurate tool for mapping RNA-seq reads to transcriptomes</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>i192</fpage>–<lpage>i200</lpage>.<pub-id pub-id-type="pmid">27307617</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sun</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>AllSome sequence bloom trees</article-title>. <source>J. Comput. Biol</source>., <volume>25</volume>, <fpage>467</fpage>–<lpage>479</lpage>.<pub-id pub-id-type="pmid">29620920</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tazi</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2009</year>) 
<article-title>Alternative splicing and disease</article-title>. <source>Biochim. Biophys. Acta</source>, <volume>1792</volume>, <fpage>14</fpage>–<lpage>26</lpage>.<pub-id pub-id-type="pmid">18992329</pub-id></mixed-citation>
    </ref>
    <ref id="btaa779-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Trincado</surname><given-names>J.L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>SUPPA2: fast, accurate, and uncertainty-aware differential splicing analysis across multiple conditions</article-title>. <source>Genome Biol</source>., <volume>19</volume>, <fpage>40</fpage>.<pub-id pub-id-type="pmid">29571299</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
