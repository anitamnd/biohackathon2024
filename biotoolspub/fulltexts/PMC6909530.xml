<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6909530</article-id>
    <article-id pub-id-type="publisher-id">3299</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-019-3299-y</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>DeepSV: accurate calling of genomic deletions from high-throughput sequencing data using deep convolutional neural network</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Cai</surname>
          <given-names>Lei</given-names>
        </name>
        <address>
          <email>cailei1512@qq.com</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wu</surname>
          <given-names>Yufeng</given-names>
        </name>
        <address>
          <email>yufeng.wu@uconn.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-1270-6257</contrib-id>
        <name>
          <surname>Gao</surname>
          <given-names>Jingyang</given-names>
        </name>
        <address>
          <email>gaojy@mail.buct.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0000 9931 8406</institution-id><institution-id institution-id-type="GRID">grid.48166.3d</institution-id><institution>Department of Information Science and Technology, </institution><institution>Beijing University of Chemical Technology, </institution></institution-wrap>Beijing, People’s Republic of China </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 0860 4915</institution-id><institution-id institution-id-type="GRID">grid.63054.34</institution-id><institution>Department of Computer Science and Engineering, </institution><institution>University of Connecticut, </institution></institution-wrap>Storrs, CT USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>12</day>
      <month>12</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>12</day>
      <month>12</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>665</elocation-id>
    <history>
      <date date-type="received">
        <day>20</day>
        <month>9</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>28</day>
        <month>11</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s). 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">Calling genetic variations from sequence reads is an important problem in genomics. There are many existing methods for calling various types of variations. Recently, Google developed a method for calling single nucleotide polymorphisms (SNPs) based on deep learning. Their method visualizes sequence reads in the forms of images. These images are then used to train a deep neural network model, which is used to call SNPs. This raises a research question: can deep learning be used to call more complex genetic variations such as structural variations (SVs) from sequence data?</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">In this paper, we extend this high-level approach to the problem of calling structural variations. We present DeepSV, an approach based on deep learning for calling long deletions from sequence reads. DeepSV is based on a novel method of visualizing sequence reads. The visualization is designed to capture multiple sources of information in the sequence data that are relevant to long deletions. DeepSV also implements techniques for working with noisy training data. DeepSV trains a model from the visualized sequence reads and calls deletions based on this model. We demonstrate that DeepSV outperforms existing methods in terms of accuracy and efficiency of deletion calling on the data from the 1000 Genomes Project.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">Our work shows that deep learning can potentially lead to effective calling of different types of genetic variations that are complex than SNPs.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Structural variations</kwd>
      <kwd>Deep learning</kwd>
      <kwd>Feature extraction</kwd>
      <kwd>Visualization</kwd>
      <kwd>Genetic variations</kwd>
      <kwd>High-throughput sequencing</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100004826</institution-id>
            <institution>Natural Science Foundation of Beijing Municipality</institution>
          </institution-wrap>
        </funding-source>
        <award-id>5182018</award-id>
        <principal-award-recipient>
          <name>
            <surname>Gao</surname>
            <given-names>Jingyang</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000001</institution-id>
            <institution>National Science Foundation</institution>
          </institution-wrap>
        </funding-source>
        <award-id>III-1526415</award-id>
        <principal-award-recipient>
          <name>
            <surname>Wu</surname>
            <given-names>Yufeng</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>Fundamental Research Funds for the Central Universities &amp; Research projects on biomedical transformation of China-Japan Friendship Hospital</institution>
        </funding-source>
        <award-id>PYBZ1834</award-id>
        <principal-award-recipient>
          <name>
            <surname>Gao</surname>
            <given-names>Jingyang</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Introduction</title>
    <p id="Par13">High-throughput DNA sequencing technologies have generated vast amount of sequence data. These data enable novel approaches for studying many important biological questions. One example is calling genetic variations such as SNPs or SVs from sequence data. There have been many existing computational methods for sequence-based calling of SNPs or SVs. For example, for SNP calling, one popular caller is GATK [<xref ref-type="bibr" rid="CR1">1</xref>]. On the high level, calling genetic variations from sequence data can be viewed as a classification problem in machine learning. That is, given the sequence data at a candidate variant site, we are to classify the site into one of the two categories: variant or wild-type. Among many existing classification approaches, deep learning based on e.g. convolutional neural network (CNN) is becoming increasingly popular. CNN has outperformed existing approaches in a number of important applications. Among these, the most noticeable application of CNN is image processing, where deep learning has significantly improved the state of the art [<xref ref-type="bibr" rid="CR2">2</xref>]. A natural research direction is using CNN for genetic variant calling with sequence data. Recently, Google’s DeepVariant [<xref ref-type="bibr" rid="CR3">3</xref>] was developed to call SNPs and short insertion/deletions (indels) from sequence data. The key idea of DeepVariant is viewing the mapped sequence data as images, and treating variant calling as a special kind of image classification. It is reported that DeepVariant can outperform GATK in SNP calling. This demonstrates the potentials of deep learning in the sequence data processing domain. The DeepVariant approach raises a natural research question: can deep learning be applied to call other types of genetic variations from sequence data that are more complex than SNPs and short indels? In this paper, we provide a positive answer for this question: we show that deep learning can be used for accurately calling structural variations from sequence data.</p>
    <p id="Par14">Structural variation refers to relatively long genomic variation, such as deletion, insertion and inversion. Structural variation will lead to complications of many diseases [<xref ref-type="bibr" rid="CR4">4</xref>], and many cancers are associated with genetic variation [<xref ref-type="bibr" rid="CR5">5</xref>]. To be specific, we focus on calling long deletions (longer than 50 bp) in this paper. For deletion calling, there exists many approaches including Pindel [<xref ref-type="bibr" rid="CR6">6</xref>], BreakDancer [<xref ref-type="bibr" rid="CR7">7</xref>], DELLY [<xref ref-type="bibr" rid="CR8">8</xref>], CNVnator [<xref ref-type="bibr" rid="CR9">9</xref>], Breakseq2 [<xref ref-type="bibr" rid="CR10">10</xref>], Lumpy [<xref ref-type="bibr" rid="CR11">11</xref>], GenomeStrip2 [<xref ref-type="bibr" rid="CR12">12</xref>], and SVseq2 [<xref ref-type="bibr" rid="CR13">13</xref>], among others. Most of these approaches rely on one or multiple information (called signatures) extracted from mapped sequence data: (i) read depth, (ii) discordant read pairs and (iii) split reads. We note that there are also methods performing sequence assembly for deletion calling. While many of the existing methods have been used in large genomics projects such as the 1000 Genomes Project [<xref ref-type="bibr" rid="CR14">14</xref>], there exists no single method that clearly outperforms other approaches.</p>
    <p id="Par15">In this paper, we present DeepSV, a deep learning based method for long deletion calling from sequence data. DeepSV builds on the general approach of DeepVariant by visualizing mapped sequence reads as images. The key technical aspects of DeepSV are the novel visualization techniques for CNN-based deletion calling and how to work with noisy training data. The visualization procedure combines all major aspects of features with regard to deletions: read depth, split read and discordant pairs. This avoids manual selection of features for classification. We demonstrate that DeepSV outperforms existing methods in calling long deletions on real sequence data from the 1000 Genomes Project. Our work extends the findings of DeepVariant by showing that deep learning can be useful for calling structural variations that are more complex than SNPs and short indels.</p>
    <p id="Par16">The rest of the paper is organized as follows. In Section 2, we survey the existing approaches for calling structural variations from sequencing data, and the application of the machine learning in the this subject. In Section 3, we present our deep leanring based SV calling method. In Section4, we present the research results. In the last section, we provide discussions on the DeepSV approach.</p>
  </sec>
  <sec id="Sec2">
    <title>Background</title>
    <p id="Par17">Genomic deletions affect several aspects (called signatures) of the sequence reads mapped onto the given reference genome near the deletion site. (i) Read depth. Mapped read depth within a deletion is likely to be lower than those at wild-type sites. If the deletion is homozygous and the reads are mapped correctly (e.g. not mis-mapped due to repeats), read depth within the deletion should be close to zero. If the deletion is heterozygous, read depth within the deletion should still be lower than expected. Thus, low read depth is a signature of deletions. (ii) Discordant read pair. Consider paired-end reads that are mapped near the deletion with two ends being to the different sides of a deletion. Such read pair is called encompassing pair for the deletion. The mapped insert size (i.e. the outer distance of the two mapped reads of the pair) of an encompassing pair appears to be longer than usual due to the presence of the deletion. This is because the mapped insert size includes the length of the deletion on the reference genome. We say an encompassing read pair is discordant if the difference between its mapped insert size and the known library insert size is at least three times of the standard deviation of the library insert size. Otherwise, we say the read pair is concordant. The longer the deletion is, the more likely an encompassing pair becomes discordant. (iii) Split reads. When a read overlaps the breakpoints of a deletion, the read consists of two parts that are not contiguous on the reference: the part proceeding the left breakpoint and part following the right breakpoint. Such a read is called split read. Here, breakpoint refers to the boundary of the deletion on the reference genome. When a split read is mapped, the read cannot be mapped as a whole. Instead, it is mapped onto two discontinuous regions of the reference. These signatures reveal different aspects of structural variations. A main advantage of using split reads is that split reads can potentially reveal the exact breakpoints of the deletion. In contrast, read depth and discordant pairs cannot lead to exact breakpoints. See Fig. <xref rid="Fig1" ref-type="fig">1</xref> for an illustration.
<fig id="Fig1"><label>Fig. 1</label><caption><p>Above the image is high coverage data, and below is low coverage. The split reads are marked with ① and the discordant reads are marked with ②</p></caption><graphic xlink:href="12859_2019_3299_Fig1_HTML" id="MO1"/></fig></p>
    <p id="Par18">Most existing deletion calling methods utilize the above three types of signatures. Earlier methods often use a single signature. For example, BreakDancer uses only discordant read pairs. The original Pindel only relies on split-reads. A number of methods combine multiple signatures and obtained more accurate results. For example, several methods such as DELLY, MATE-CLEVER [<xref ref-type="bibr" rid="CR15">15</xref>], and SVseq2 combined discordant read pairs and split reads. A main advantage of integrating multiple signatures is better utilizing the information contained in the sequence data. However, it is unclear what is the best way for integrating different signatures for deletion calling. A simple approach is weighting different signatures (e.g. a split read is weighted as 1 and a discordant pair is weighted as 2). Obviously, this leads to the issue of choosing the weights, which is often difficult in practice [<xref ref-type="bibr" rid="CR16">16</xref>]. Indeed, it is known that parameter settings can affect the results of many existing SV callers [<xref ref-type="bibr" rid="CR17">17</xref>].</p>
    <p id="Par19">A useful observation is that SV calling can be viewed as a classification problem. That is, for a candidate SV, we want to classify this candidate site to be either a true deletion (denoted as 1) or a non-deletion (denoted as 0) based on the given sequence data near the candidate site. Classification is an important subject of machine learning and there are many existing machine learning methods for classification. Usually classification involves two steps. First, a model is trained from training data. Second, the trained model is used to classify the test data. A main advantage of using a classification model is that there is no need to manually choosing the parameters; parameters are obtained from the training data. There are existing machine learning based approaches for SV calling, including GINDEL [<xref ref-type="bibr" rid="CR18">18</xref>] and Concod [<xref ref-type="bibr" rid="CR19">19</xref>]. While these machine learning based methods show promises in accurate calling of SVs, there are also difficulties faced by traditional classification methods. One of the most important issues for traditional classification is feature selection. That is, we need to determine what specific quantities to extract from sequence data to be used in classification. Due to the complex nature of structural variations, it is often unclear what are the best features.</p>
    <p id="Par20">Recently, deep learning is becoming increasingly popular. Deep learning approaches (such as convolutional neural network or CNN) have been applied to several important problems (e.g. image processing, computer vision, natural language processing, to name a few) and led to significant improvements in performance over existing methods. A main advantage of deep learning is that it reduces the need of feature engineering and can potentially better utilize the data. On the other hand, a main disadvantage is that deep learning usually needs more complex models that are more difficult to train than those in traditional approaches. Application of deep learning in sequence data analysis is in its infancy. A pioneering work in this area is Google’s DeepVariant. DeepVariant proposes a novel approach for sequence data analysis for the purpose of genetic variant calling: treating mapped sequence data as images and converting genetic variant calling to an image classification problem. As shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>, mapped sequence reads have a natural visualization [<xref ref-type="bibr" rid="CR20">20</xref>]. Mapped sequence reads near a variant (say a short deletion) or wildtype site can be easily recorded as an image.
<fig id="Fig2"><label>Fig. 2</label><caption><p>The red line is the read-depth value, the green line is split-read value and the insert size spaning the deletion region is larger than library value</p></caption><graphic xlink:href="12859_2019_3299_Fig2_HTML" id="MO2"/></fig></p>
    <p id="Par21">This image has different visual appearance at a variant from that from a wildtype. At a short deletion site, the image tends to have a gap. Moreover, read depth tends to be lower than that of the wildtype because short deletion may cause some reads unaligned. DeepVariant relies on the visual difference of images to perform classification for genetic variant calling.</p>
    <p id="Par22">The DeepVariant approach leads to a natural question: can we use deep learning to call more complex genetic variants such as long deletions? SV calling can be somewhat more difficult than SNP or short indel calling. First, SNP calling is more localized: reads relevant to a SNP can be easily fit into a single image. Reads that are relevant for a long deletion can spread out. For example, two ends of a discordant read pair over a long deletion can be mapped to positions that are more than thousands of bases apart. Second, there are more signatures for long deletions than those for SNPs or short indels. For example, discordant read pairs are not associated with SNPs but are important for long deletions. Integrating these diverse set of signatures in visualization needs to be worked out. In this paper, we present DeepSV, a deep learning based method for calling long deletions from sequence reads, which addresses these difficulties.</p>
  </sec>
  <sec id="Sec3">
    <title>Methods</title>
    <sec id="Sec4">
      <title>General description of DeepSV</title>
      <p id="Par23">DeepSV is a deep learning based structural variation calling method. It is based on a new sequence reads visualization approach, which converts mapped sequence reads to images. DeepSV follows the general approach of DeepVariant. Different from DeepVariant, DeepSV aims to calling SVs (especially long deletions that are longer than 50 bp). There are two components in DeepSV: training and variant calling. Both components take mapped reads and the reference genome as input. For model training, DeepSV trains a convolutional neural network (CNN) model from sequence reads with known deletions. Similar to DeepVariant, CNN model training is based on visualizing mapped sequence reads near known deletion sites or at wildtype sites. The key technical aspect of DeepSV is how to train the CNN from sequence images near a deletion. Recall that long deletions have more complex signatures than SNPs or short indels. Note that deletion can be long and different regions of a deletion can be quite different in the visualized reads. For example, near the breakpoint, there is likely a sharp transition from high read depth to low read depth. In the middle of a deletion, there may be no such transition but the read depth can be lower than that near the breakpoint (See Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S1).</p>
      <p id="Par24">In order to accurately call deletions with precise breakpoints, it is important to separate these cases. Moreover, to accommodate various signatures of a deletion, DeepSV implements a visualization procedure that takes advantage of the rich information contained in an image to integrate various signals. In a typical color map, there are 8 bits for red, green and blue and so there can be 256 choices for each color. Therefore, one can use various combinations of the three basic colors to represent the configuration of the mapped reads. For example, a pixel corresponding a base of a mapped read can be affected by multiple factors such as whether the read is split read, the quality of the read, whether there is a discordant read pair and so on. When the CNN model is trained, the model is used to call deletions from the sequence images.</p>
    </sec>
    <sec id="Sec5">
      <title>DeepSV workflow</title>
      <p id="Par25">Figure <xref rid="Fig3" ref-type="fig">3</xref> shows the overall workflow of DeepSV. DeepSV is composed of three parts. In the first part (Fig. <xref rid="Fig3" ref-type="fig">3</xref>a), DeepSV begins by finding candidate deletions in reads aligned to the reference genome using clustering. In the second part (Fig.<xref rid="Fig3" ref-type="fig">3</xref>b), the deep learning model is trained using a pileup image of the reference and reads around each candidate variant. Pileup image refers to the vertical alignment of bases at each site, rather than the horizontal alignment of bases as reads. The difference between pileup image and tiled image is shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S2. In the third part (Fig.<xref rid="Fig3" ref-type="fig">3</xref>c), the model is used to call the variants.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Overview of the DeepSV. DeepSV extracts candidates training set from the original sequence, and then uses a gradient descent algorithm to train CNN network, and finally generates images according to gene sequence for calling deletions. The gradient descent algorithm is an optimization algorithm commonly used in machine learning and artificial intelligence to recursively approximate the minimum deviation model. <bold>a</bold> Finding candidate variants and Encoding pileup images. <bold>b</bold> Training CNN model. <bold>c</bold> Calling deletions</p></caption><graphic xlink:href="12859_2019_3299_Fig3_HTML" id="MO3"/></fig></p>
    </sec>
    <sec id="Sec6">
      <title>DeepSV implementation details</title>
      <p id="Par26">To train a classification model, DeepSV takes the aligned sequence reads in binary sequence alignment (BAM) file and a variant call format (VCF) file which containes the known deletions. From sequence data to mapped image, DeepSV goes through three stages. Figure <xref rid="Fig4" ref-type="fig">4</xref> illustrates the DeepSV approach. In the first stage, DeepSV performs filtering operations because the fluctuation of read depths will affect the clustering results. In the second stage, DeepSV eliminates false positives by clustering and then determines precise breakpoints. In the last stage, DeepSV visualizes mapped sequence reads based on sequence characteristics.
<fig id="Fig4"><label>Fig. 4</label><caption><p>The process of DeepSV. DeepSV processing data is divided into three steps: filtering, clustering and visualization</p></caption><graphic xlink:href="12859_2019_3299_Fig4_HTML" id="MO4"/></fig></p>
      <sec id="Sec7">
        <title>Dealing with noise</title>
        <p id="Par27">Real sequence data tends to have significant noise, which can make the clustering perform poorly. The following lists several such cases.
<list list-type="simple"><list-item><label>(i)</label><p id="Par28">The read depths fluctuate and some positions have read depths that are either too high or too low than expected. For example, read depths at some sites in the non-deletion region can be very low, while read depths of some sites in a deletion can be very high. Read depth near the breakpoints fluctuates significantly.</p></list-item><list-item><label>(ii)</label><p id="Par29">The difference on discordant paired-end reads between a deletion and a non-deletion is not obvious when coverage is low.</p></list-item></list></p>
        <p id="Par30">To address the above two issues, DeepSV uses the following techniques to reduce the effect of noises. First, DeepSV uses a 61 bp long sliding window to filter the read depths. DeepSV uses the following filter formula: <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \frac{\overline{D}}{\sigma}\gamma $$\end{document}</tex-math><mml:math id="M2" display="inline"><mml:mfrac><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mi>σ</mml:mi></mml:mfrac><mml:mi>γ</mml:mi></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq1.gif"/></alternatives></inline-formula>. The mapping read depths within the window are <italic>d</italic><sub>1</sub>, <italic>d</italic><sub>2</sub>, ..., <italic>d</italic><sub>61</sub> (computed by SAMtools [<xref ref-type="bibr" rid="CR20">20</xref>]), and the D¯ is the average of the read depths of the window. σ is the standard deviation of d<sub><italic>i</italic></sub> and γ represents a coefficient. D¯ can indicate the situation where the read depth is high in the non-deletion region or low in the deletion region. σ reflects the fluctuations of depth. The value of γ is chosen to amplify the trend of the depth values in the window. Our experience indicates that this filtering step reduces the effect of the noise in the data, and improves the performance of the clustering. Now we consider discordant reads and split reads. Since the split read count and the discordant read count can be inversely proportional to the read depth near the breakpoints, we use the negation of the discordant read counts and split read counts (instead of the reads counts themselves). This is to ensure that each feature used in the clustering has the same trend for deletions or non-deletions. This improves the performance of the clustering. Figure <xref rid="Fig5" ref-type="fig">5</xref> shows the clustering details. In the Fig. <xref rid="Fig5" ref-type="fig">5</xref>a, the green dots represent the feature points of the deletion regions, and the red and blue colors respectively represent the feature points at upstream and downstream of the deletion region. When there is no filtering, many singular values will appear, and these singular values will be incorrectly assigned to other classes. From Fig. <xref rid="Fig5" ref-type="fig">5</xref>b, we can see many singular values are removed by filtering. Figure <xref rid="Fig5" ref-type="fig">5</xref>c and d show the comparison before and after filtering. DeepSV successfully excludes the eigenvalues of special sites by filtering.
<fig id="Fig5"><label>Fig. 5</label><caption><p><bold>a</bold>, <bold>b</bold> Represent the clustering result of feature points, in which outliers are drawn in circles, and these boundary outliers are easily clustered into other categories. <bold>c</bold>, <bold>d</bold> Show the process of filtering features, where the box is a sliding window</p></caption><graphic xlink:href="12859_2019_3299_Fig5_HTML" id="MO5"/></fig></p>
        <p id="Par31">In order to ensure that the boundary of clustering is as close as possible to the breakpoints and improve the accuracy of called deletions, DeepSV uses a modified Euclidean distance formula for the distance measure between two points used in the clustering. Euclidean formula can better reflect the distance relationship of space vectors. It is a commonly used distance formula in clustering algorithm. Considering that each coordinate in multidimensional vector contributes equally to Euclidean distance and they often have random fluctuations of different sizes, we have improved the formula by adding weight adjustment.
<disp-formula id="Equa"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ Dis\tan ce\left({\mathrm{C}}_{\mathrm{i}},{C}_j\right)=\sqrt{\sum \limits_{k=1}^n\eta {\left(|{C}_{ik}-{C}_{jk}|\right)}^p} $$\end{document}</tex-math><mml:math id="M4" display="block"><mml:mi mathvariant="italic">Dis</mml:mi><mml:mo>tan</mml:mo><mml:mi mathvariant="italic">ce</mml:mi><mml:mfenced close=")" open="(" separators=","><mml:msub><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathvariant="normal">i</mml:mi></mml:msub><mml:msub><mml:mi>C</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mfenced><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mi>η</mml:mi><mml:msup><mml:mfenced close=")" open="(" separators="||"><mml:mrow/><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi mathvariant="italic">ik</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi mathvariant="italic">jk</mml:mi></mml:msub></mml:mrow><mml:mrow/></mml:mfenced><mml:mi>p</mml:mi></mml:msup></mml:mrow></mml:msqrt></mml:math><graphic xlink:href="12859_2019_3299_Article_Equa.gif" position="anchor"/></alternatives></disp-formula></p>
        <p id="Par32"><italic>C</italic><sub><italic>i</italic></sub><italic>andC</italic><sub><italic>j</italic></sub> C<sub>i</sub> and C<sub><italic>j</italic></sub> represent two points of cluster set. C<sub>ik</sub> and C<sub>jk</sub>
<italic>C</italic><sub><italic>ik</italic></sub><italic>andC</italic><sub><italic>jk</italic></sub> are the components of vectors in the form of (normalized read depth, negated split read count, negated discordant read count). When the <italic>C</italic><sub><italic>ik</italic></sub>, <italic>C</italic><sub><italic>jk</italic></sub>, C<sub>jk</sub> values are the normalized depths, η is a fixed number that is greater than one. For discordant read count and split read count, η is set to one. The constant p is a fixed even number.</p>
      </sec>
      <sec id="Sec8">
        <title>Clustering process</title>
        <p id="Par33">After dealing with the origin sequence, the k-means clustering algorithm is used on feature sets. We define each point in the sets as a triple, (read depth, discordant read pair count, split-read count). Therefore, we let k = 3 and run k-means clustering to cluster the positions into three categories. The three clusters are denoted as S<sub>1</sub>, <italic>S</italic><sub>2</sub>,<italic>S</italic><sub>3</sub>
<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>, <italic>S</italic><sub>3</sub> which correspond to the upstream, deletion and downstream regions respectively. Note that at a SV site, read depth tends to decrease while split read count and discordant read count tend to decrease. So we compute a feature value m for each position, where m is equal to the read depth minus split read count and discordant read count. We compute the average feature value of all positions in each of the three clusters S<sub>1</sub>, <italic>S</italic><sub>2</sub>,<italic>S</italic><sub>3</sub>
<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>, <italic>S</italic><sub>3</sub>, which we denote as <inline-formula id="IEq2"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\overline{\mathrm{m}}}_1,{\overline{m}}_2,{\overline{m}}_3 $$\end{document}</tex-math><mml:math id="M6" display="inline"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="normal">m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mn>3</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq2.gif"/></alternatives></inline-formula>
<inline-formula id="IEq3"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\overline{m}}_1,{\overline{m}}_2,{\overline{m}}_3 $$\end{document}</tex-math><mml:math id="M8" display="inline"><mml:msub><mml:mover accent="true"><mml:mi>m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mn>3</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq3.gif"/></alternatives></inline-formula>. We let <inline-formula id="IEq4"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \overline{\mathrm{m}} $$\end{document}</tex-math><mml:math id="M10" display="inline"><mml:mover accent="true"><mml:mi mathvariant="normal">m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq4.gif"/></alternatives></inline-formula>
<inline-formula id="IEq5"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \overline{m} $$\end{document}</tex-math><mml:math id="M12" display="inline"><mml:mover accent="true"><mml:mi>m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq5.gif"/></alternatives></inline-formula> be the minimum of the three mean values. If the positions from the cluster with the minimum mean are largely between the points of the other clusters, then this deletion is considered to be a true deletion. Otherwise, it is a false positive. Figure <xref rid="Fig6" ref-type="fig">6</xref> shows the clustering results. The effect of false positives will be presented in the results section.
<fig id="Fig6"><label>Fig. 6</label><caption><p>shows that DeepSV can filter out the false positives in VCF by clustering the results that do not conform to the deletion characteristics</p></caption><graphic xlink:href="12859_2019_3299_Fig6_HTML" id="MO6"/></fig></p>
        <p id="Par34">Sometimes the given breakpoints are not very accurate. This can lead to wrong labeling of the training images, especially near the boundary of the deletion. To find exact breakpoints, we consider the minimum mean cluster S<sub>2</sub>
<italic>S</italic><sub>2</sub> with mean ¯<sub>2</sub>
<inline-formula id="IEq6"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\overline{m}}_2 $$\end{document}</tex-math><mml:math id="M14" display="inline"><mml:msub><mml:mover accent="true"><mml:mi>m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq6.gif"/></alternatives></inline-formula>. DeepSV sorts the positions of S<sub>2</sub>
<italic>S</italic><sub>2</sub>. The minimum and maximum positions, denoted as <italic>β</italic><sub>1</sub> and <inline-formula id="IEq7"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\beta}_{\begin{array}{l}2\\ {}\end{array}} $$\end{document}</tex-math><mml:math id="M16" display="inline"><mml:msub><mml:mi>β</mml:mi><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd/></mml:mtr></mml:mtable></mml:msub></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq7.gif"/></alternatives></inline-formula>
<italic>β</italic><sub>1</sub><italic>andβ</italic><sub>2</sub>, are treated as initial breakpoints. There are two cases for the interval [<italic>β</italic><sub>1</sub>, <italic>β</italic><sub>2</sub>] [<italic>β</italic><sub>1</sub>, <italic>β</italic><sub>2</sub>].
<list list-type="simple"><list-item><label>(i)</label><p id="Par35">[<italic>β</italic><sub>1</sub>, <italic>β</italic><sub>2</sub>] [<italic>β</italic><sub>1</sub>, <italic>β</italic><sub>2</sub>] is close to the given breakpoints.</p></list-item><list-item><label>(ii)</label><p id="Par36">[<italic>β</italic><sub>1</sub>, <italic>β</italic><sub>2</sub>] [<italic>β</italic><sub>1</sub>, <italic>β</italic><sub>2</sub>] doesn’t include the given breakpoints due to the length of the deletion being too long.</p></list-item></list></p>
        <p id="Par37">We set two pointers <italic>ρ</italic><sub>1</sub> and <italic>ρ</italic><sub>1</sub><italic>andρ</italic><sub>2</sub>
<italic>ρ</italic><sub>2</sub> to <italic>β</italic><sub>1</sub>
<italic>β</italic><sub>1</sub><italic>andβ</italic><sub>2</sub> and <inline-formula id="IEq8"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\beta}_{\begin{array}{l}2\\ {}\end{array}} $$\end{document}</tex-math><mml:math id="M18" display="inline"><mml:msub><mml:mi>β</mml:mi><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd/></mml:mtr></mml:mtable></mml:msub></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq8.gif"/></alternatives></inline-formula> respectively. In the first case if the feature value of <italic>ρ</italic><sub>1</sub>
<italic>ρ</italic><sub>1</sub> is less than ¯<sub>2</sub>
<inline-formula id="IEq9"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\overline{m}}_2 $$\end{document}</tex-math><mml:math id="M20" display="inline"><mml:msub><mml:mover accent="true"><mml:mi>m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq9.gif"/></alternatives></inline-formula>, then <italic>ρ</italic><sub>1</sub>
<italic>ρ</italic><sub>1</sub> is moved to the left by one. Similarly, if the feature value of <italic>ρ</italic><sub>2</sub>
<italic>ρ</italic><sub>1</sub> is less than ¯<sub>2</sub>
<inline-formula id="IEq10"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\overline{m}}_2 $$\end{document}</tex-math><mml:math id="M22" display="inline"><mml:msub><mml:mover accent="true"><mml:mi>m</mml:mi><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mn>2</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq10.gif"/></alternatives></inline-formula>, then <italic>ρ</italic><sub>2</sub>
<italic>ρ</italic><sub>2</sub> is moved to the right by one. In the second case, the two pointers move in the opposite direction. When this process finishes, the two pointers provide the estimate of the two breakpoints of this deletion. Figure <xref rid="Fig7" ref-type="fig">7</xref> shows the breakpoint finding process.
<fig id="Fig7"><label>Fig. 7</label><caption><p><italic>β</italic><sub>1</sub>and <inline-formula id="IEq11"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\beta}_{\begin{array}{l}2\\ {}\end{array}} $$\end{document}</tex-math><mml:math id="M24" display="inline"><mml:msub><mml:mi>β</mml:mi><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd/></mml:mtr></mml:mtable></mml:msub></mml:math><inline-graphic xlink:href="12859_2019_3299_Article_IEq11.gif"/></alternatives></inline-formula> represent the initial breakpoints. <italic>ρ</italic><sub>1</sub> and <italic>ρ</italic><sub>2</sub> show the moving pointer</p></caption><graphic xlink:href="12859_2019_3299_Fig7_HTML" id="MO7"/></fig></p>
      </sec>
      <sec id="Sec9">
        <title>Visualizing mapped sequence reads</title>
        <p id="Par38">Model training needs a set of labeled training samples. For image-based deletion calling, we need two sets of images: images from the deletion regions (labeled as 1) and images from the wild-type regions (labeled as 0). In principle, since the deletions are given in the VCF file, creating training sample is straightforward. Mapped reads have the natural pileup form and can be easily converted to images. 1-labeled images are taken within the known deletions and 0-labeled images are from outside the deletions. We partition the reference genome into consecutive non-overlapping windows of 50 bp. The aligned reads in the pileup format are converted into an image. Once the training data is obtained, one may train a CNN.</p>
        <p id="Par39">So far, we have labeled regions along the reference genome to be either deletion or non-deletion. We now describe how to create images for each region. This is a critical step because real sequence data tends to be complex. If the visualization approach is not chosen properly, the CNN may not capture the underlying information about the deletion from the created images.</p>
        <p id="Par40">Recall that an image is composed of pixels, and each pixel has (R, G, B) three-primary colors. The reason for using (R, G, B) image coding sequence is that the single channel graph can only represent gray level image, and the expression ability is limited, while the sequence information is complex. Especially, the CNN has the advantage of natural image processing. DeepSV takes the following simple approach for visualizing the reads: each nucleotide (i.e. A, T, C, or G respectively) is assigned one of these base colors: red (255,0,0), green (0,255,0), blue (0,0,255) and black (0,0,0) respectively; then the base color is slightly modified to integrate the various signatures on deletions. DeepSV considers all the aligned bases (i.e. a column in the image) at a position of the current region. For population sequence reads, a large percentage (95% or higher) of sites are not polymorphisms and the bases from one site tend to have the same color. This gives the visual appearance of column-based images. See Fig. <xref rid="Fig8" ref-type="fig">8</xref> for an illustration. Our experience shows that such column-based images reveal the key aspects of deletions.
<fig id="Fig8"><label>Fig. 8</label><caption><p>Each base is assigned one base color, and each color is composed of three primary colors. According to the characteristics of alignment, the bases at each site are assigned different colors</p></caption><graphic xlink:href="12859_2019_3299_Fig8_HTML" id="MO8"/></fig></p>
        <p id="Par41">Integration of deletion signatures. Recall that there are various signatures on deletions (i.e. read depth, discordant pair and split read). Read depth is naturally represented by the pileup images. DeepSV integrates the other two types of signatures by slightly modifying the base colors of the mapped bases based on the signatures. Note that such modification is usually mild and does not destroy the column-based appearance of images. Each read contains multiple aspect of information, e.g., whether it belongs to discordant paired-end reads and whether it is split read. DeepSV uses the following combination of features to determine the color of each mapped base. More specifically, the color of a mapped base is determined by the four quantities, which describe the discordant read pair and split read information at the position. These quantities are explained in Table <xref rid="Tab1" ref-type="table">1</xref>. The sum of these four quantities provide the auxiliary components of the coloring. To see how these four quantities are used to decide the color of a mapped base, we consider the following example. Consider a column of aligned bases (which are say all A’s). We first count the number of discordant paired reads (which is say 10), and the number of split reads (which is say 0) that overlap this column. This leads to a color setting (255, 10, 10) for all bases in the column. We then consider each base of the column one by one. For this, we find the four features (is paired, concordant/discordant, mapping quality and map type). Say these features have values (1, 1, 1, 0). This leads to a binary number 13 = 10 + 1 + 1 + 1 + 0.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Visualizing an aligned base. Feature: information carried by the base on deletions</p></caption><table frame="hsides" rules="groups"><thead><tr><th/><th>Feature</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>is-paired/is-not-paired</td><td>Is this read paired (1) or single (0)?</td></tr><tr><td>2</td><td>concordant/discordant paired</td><td>Is this read discordant (value 1) or not (value 0)</td></tr><tr><td>3</td><td>mapping-quality</td><td>Is the mapping quality higher than 20? Value is 0 or 1.</td></tr><tr><td>4</td><td>map-type</td><td>Is this read split (value 1) or not (value 0)?</td></tr></tbody></table></table-wrap></p>
        <p id="Par42">As shown in Table <xref rid="Tab1" ref-type="table">1</xref>, each of the four bases has four binary feature values. This gives total 64 combinations. We show an example (See Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S1) that describes 64 value combinations and color scope. The color range of A base is (255, 0, 0) ~ (255, 235, 235), T base is (0, 255, 0) ~ (235, 255, 235), C base is (0, 0, 255) ~ (235, 235, 255), and the G base is (0, 0, 0) ~ (235, 235, 235).</p>
        <p id="Par43">Because the range of deletion length is from 50 bp to more than 10kbp, a single pileup image cannot cover an entire deletion and discordant pairs may not be contained in a single image. At the same time, because the network requires uniform batch size, we need to use normalized images. DeepSV divides the sequence (including deletion region and non-deletion region) into equal length regions. The length of the region can be customized by users. In this experiment, DeepSV generates the fixed length images in units of 50 bp. Note that the background of each picture is white. This is illustrated in Fig. <xref rid="Fig9" ref-type="fig">9</xref>.
<fig id="Fig9"><label>Fig. 9</label><caption><p>These images contain different features. Each vertical colorful bar represents bases aligned to this site. The length of the vertical bar becomes lower in the deletion region but higher in the non-deletion region. <bold>a</bold> represents the homozygous deletion. <bold>b</bold> represents the heterozygous deletion. <bold>c</bold> shows the non deletion. <bold>d</bold> describes how pictures are sent into a neural network for training and prediction</p></caption><graphic xlink:href="12859_2019_3299_Fig9_HTML" id="MO9"/></fig></p>
      </sec>
      <sec id="Sec10">
        <title>Training and validating model</title>
        <p id="Par44">DeepSV trains the CNN model with real sequence reads and benchmarked deletions. Tensorflow [<xref ref-type="bibr" rid="CR21">21</xref>] is used to construct the convolutional neural network and the batch size is set to 128. All genome data analysis is performed on a Linux server with 1080Ti GPUs [<xref ref-type="bibr" rid="CR22">22</xref>] and a platform of Digits [<xref ref-type="bibr" rid="CR23">23</xref>]. The parameters setting of model on deletion calling are given in the Additional file <xref rid="MOESM1" ref-type="media">1</xref> (section 3: The parameters setting of model on deletion calling).</p>
        <p id="Par45">Picture labeling and normalization. The nucleotide sequence of the entire region is divided into 50 bp regions. DeepSV generates images of 256 by 256 for these 50 bp and labels each image as 0 or 1. We use all the labeled images in CNN training and use the trained model to call the deletion of the test data. The labeled images are shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S4. The deletion calling process is shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S5.</p>
      </sec>
    </sec>
  </sec>
  <sec id="Sec11">
    <title>Results</title>
    <p id="Par46">We now validate the performance of DeepSV using real data from the 1000 Genomes Project. The called deletions released by the 1000 Genomes Project (phase three) are used as the ground truth for benchmark. The data we use in this paper consist of 40 BAM (binary sequence alignment/map format) files with 20 individuals on chromosomes 1~22. The average insert length is 456 bp, and the standard deviation is between 57 bp~ 78 bp. The average coverage is 10X and 60X. These individuals from three different populations including Yoruba in Ibadan, Nigeria (YRI), Han Chinese in Beijing, China (CHB), and Utah Residents with Northern and Western European Ancestry (CEU). DeepSV needs training data. We use about half of data for the purpose of training, and use the remaining data for testing. The training data set and the test data set are divided according to the following two criteria: (i) ensuring that the training data is sufficient for the model to converge. (ii) ensuring that the test data is sufficient to cover various targets to be detected.</p>
    <p id="Par47">Under the premise of satisfying the above two criteria, the ratio of the training set and the test set can be adjusted according to the actual situation. In this experiment, the training set and the test set are each 50%. For training, we use the data from chromosomes 1 to 11 of these 20 individuals. For testing, we use the data from the chromosomes 12 to 22. Data used in the experiments is given in the Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S3.</p>
    <p id="Par48">We compare DeepSV with other eight tools including Pindel, BreakDancer, Delly, CNVnator, Breakseq2, Lumpy, GenomeStrip2, and SVseq2. To show the advantage of deep learning, we also compare with an existing machine learning based method, Concod. We examine various aspects of deletion calling by DeepSV and other tools, including the accuracy of calling deletions of different sizes, breakpoint accuracy, impact of sequence data coverage, and the effect of model’s activation on precision and loss.</p>
    <sec id="Sec12">
      <title>Calling deletions of different sizes</title>
      <p id="Par49">We first evaluate the performance of DeepSV for calling deletions of various sizes. We use the deletions on chromosomes 12 to 22 from 20 individuals from the 1000 Genomes Project as the benchmark. Figure <xref rid="Fig10" ref-type="fig">10</xref> shows the deletion distribution of these benchmarked deletions. We divide the lengths of deletions into five categories. The deletion length roughly follows a normal distribution.
<fig id="Fig10"><label>Fig. 10</label><caption><p>Deletion length distribution for deletions in the chromosomes 12 to 22. The deletion length obeys the normal distribution</p></caption><graphic xlink:href="12859_2019_3299_Fig10_HTML" id="MO10"/></fig></p>
      <p id="Par50">We compare the accuracy of deletion calling of different deletion sizes on DeepSV and other calling tools with low or high coverage data. To measure the performance of deletion calling, we use the following statistics: precision, sensitivity, and the F-score. The results on low coverage are shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S4. The results on high coverage are shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S5.</p>
      <sec id="Sec13">
        <title>DeepSV for long deletions: the effect of complex SV</title>
        <p id="Par51">We now take a closer look at the performance of DeepSV on calling long deletions. Deletion can be classified into homozygous and heterozygous deletion. Moreover, there can exist other types of structural variations (e.g. insertion, translocation and inversion) near the deletion region. This type of structural variation is called complex SV. The importance of complex SV has been recently noticed in the literature [<xref ref-type="bibr" rid="CR24">24</xref>]. A deletion of longer size is more likely to be a complex SV than shorter deletions. When a deletion is complex, the images created by DeepSV tends to be less clear cut than those from a simple deletion. To evaluate the performance of DeepSV on calling different types of deletions, we study how DeepSV’s performance changes when the number of other types of structural variations (e.g. insertions, translocations and inversions) increases. The results are shown in Fig. <xref rid="Fig11" ref-type="fig">11</xref>. Our results show that the accuracy of calling homozygous deletions is not affected by the presence of other types of SVs in general. The same roughly holds for heterozygous deletions. For complex deletions, the presence of other SVs reduces the calling accuracy significantly.
<fig id="Fig11"><label>Fig. 11</label><caption><p>Accuracy of calling deletions for different type. Horizontal axis: number of other types of SVs (e.g. insertion/translocation/inversion) near the deletions. Vertical axis: deletion calling accuracy (part d)</p></caption><graphic xlink:href="12859_2019_3299_Fig11_HTML" id="MO11"/></fig></p>
      </sec>
    </sec>
    <sec id="Sec14">
      <title>Breakpoint accuracy</title>
      <p id="Par52">In this section, we compare the performance of DeepSV with other tools on breakpoint accuracy. Figure <xref rid="Fig12" ref-type="fig">12</xref> shows the distance between the detected and true breakpoints on the all genome data. Once again, breakpoint predictions given by DeepSV are closest to the true breakpoint positions. In many cases, the predicted breakpoint positions of DeepSV are only up to a few base pairs away from the true breakpoint positions. Predictions from other tools are usually further away from the true breakpoint positions. Among them, SVseq2, CNVnator, Lumpy, and BreakSeq2 appear to have the lower breakpoint accuracy than other tools. GenomeStrip2 has the highest resolution in the tools we compared. Our results suggest that DeepSV appears to capture the key characteristics of breakpoints from the images.
<fig id="Fig12"><label>Fig. 12</label><caption><p>Breakpoint accuracy on different detecting tools. The y-axis represents the distance between detected breakpoints and true breakpoints</p></caption><graphic xlink:href="12859_2019_3299_Fig12_HTML" id="MO12"/></fig></p>
    </sec>
    <sec id="Sec15">
      <title>Impact of reads coverage</title>
      <p id="Par53">Sequence reads coverage can have a large effect on deletion calling. Reads coverage also affects the performance of DeepSV in both training and testing. In order to evaluate the performance of DeepSV on datasets with different coverage, we perform down sampling for the original high coverage data. SAMtools with option “view -s” is used for down sampling, and four datasets are generated with average coverage 48 ×, 36 ×, 24 ×, 12 × respectively. Table <xref rid="Tab2" ref-type="table">2</xref> shows the precision, sensitivity of DeepSV and the other eight tools on the genome data. In the table, we can see DeepSV has the highest precision compared with all other tools at various coverage. The sensitivity of DeepSV is overall comparable with the best of the other tools.
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Precision, sensitivity of multiple tools on different coverage data. P indicates precision. S indicates sensitivity</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">Tool</th><th colspan="2">12×</th><th colspan="2">24×</th><th colspan="2">36×</th><th colspan="2">48×</th></tr><tr><th>P</th><th>S</th><th>P</th><th>S</th><th>P</th><th>S</th><th>P</th><th>S</th></tr></thead><tbody><tr><td>Pindel</td><td>0.18</td><td>0.80</td><td>0.45</td><td>0.50</td><td>0.33</td><td>0.60</td><td>0.40</td><td>0.48</td></tr><tr><td>BreakDancer</td><td>0.50</td><td>0.86</td><td>0.39</td><td>0.51</td><td>0.68</td><td>0.63</td><td>0.70</td><td>0.46</td></tr><tr><td>Delly</td><td>0.30</td><td>0.83</td><td>0.43</td><td>0.57</td><td>0.69</td><td>0.51</td><td>0.76</td><td>0.38</td></tr><tr><td>CNVnator</td><td>0.17</td><td>0.18</td><td>0.36</td><td>0.20</td><td>0.61</td><td>0.59</td><td>0.75</td><td>0.74</td></tr><tr><td>Breakseq2</td><td>0.69</td><td>0.71</td><td>0.71</td><td>0.75</td><td>0.80</td><td>0.79</td><td>0.86</td><td>0.85</td></tr><tr><td>Lumpy</td><td>0.13</td><td>0.87</td><td>0.21</td><td>0.93</td><td>0.32</td><td>0.82</td><td>0.42</td><td>0.73</td></tr><tr><td>GenomeStrip2</td><td>0.36</td><td>0.42</td><td>0.82</td><td>0.69</td><td>0.86</td><td>0.78</td><td>0.75</td><td>0.60</td></tr><tr><td>SVseq2</td><td>0.57</td><td>0.28</td><td>0.43</td><td>0.22</td><td>0.30</td><td>0.33</td><td>0.23</td><td>0.36</td></tr><tr><td>DeepSV</td><td>0.72</td><td>0.81</td><td>0.85</td><td>0.89</td><td>0.91</td><td>0.92</td><td>0.93</td><td>0.90</td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec id="Sec16">
      <title>Deletion calling for various frequencies</title>
      <p id="Par54">To see whether DeepSV performs consistently on different population deletion frequencies, we now show the results of DeepSV on various deletion frequencies within the population and compare with the other eight tools. Note that, the precision cannot be calculated because the deletion frequency for the false positive deletions called out by each tool is unknown. Therefore, we only list the sensitivity here. Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S6 shows the performance of each tool on different deletion frequencies. The results show that DeepSV outperforms the other eight tools for different deletion frequencies. The sensitivity of most tools increases as deletion frequencies increase. GenomeStrp2 has the better sensitivity for medium deletion frequency of 6–10. CNVnator has the lowest sensitivity for medium deletion frequency of 1–5.</p>
    </sec>
    <sec id="Sec17">
      <title>Deletion calling for an individual not in training</title>
      <p id="Par55">So far, we use data from 20 individuals where half chromosomes are used for training and the other half for testing. Since training and testing are on different chromosomes, testing is considered to be independent from training. To further validate our method, we now show deletion calling performance for an individual (NA12891) that is not used in the training. The results for this individual with various coverage are shown in Fig. <xref rid="Fig13" ref-type="fig">13</xref>. We can see that DeepSV performs well for this new individual with performance similar with those from other individuals.
<fig id="Fig13"><label>Fig. 13</label><caption><p>Performance of deletion calling for NA12891. To verify the DeepSV’s validity, we test the individual of NA12891 that is independent from traning and testing</p></caption><graphic xlink:href="12859_2019_3299_Fig13_HTML" id="MO13"/></fig></p>
    </sec>
    <sec id="Sec18">
      <title>Machine learning and deletion calling</title>
      <p id="Par56">There are existing methods that use other types of machine learning approaches for deletion calling. Concod is one such example. Concod is based on manual feature selection. It performs the consensus-based calling with a support vector machine (SVM) model. We now compare DeepSV with Concod in deletion calling. Both methods need model training. We compare the model training accuracy and loss, as well as the running time of the two methods. Here, model training loss is the model misclassification error on the training data on a trained model. That is, we first use training data to train the model. Then we treat the training data as the test data to see if the model classifies the training data correctly. Note that there is an overfitting issue: a model classifies training data well may not generalize to test data. Nonetheless, a good machine learning model should have small training loss. The results are shown in Fig. <xref rid="Fig14" ref-type="fig">14</xref>a, b.
<fig id="Fig14"><label>Fig. 14</label><caption><p>Compared to traditional machine learning method (e.g., Concod), DeepSV shows a more stable state. The training loss of Concord (<bold>a</bold>) and DeepSV (<bold>b</bold>). The training accuracy of Concod (<bold>c</bold>) and DeepSV(<bold>d</bold>)</p></caption><graphic xlink:href="12859_2019_3299_Fig14_HTML" id="MO14"/></fig></p>
      <p id="Par57">As shown in Fig. <xref rid="Fig14" ref-type="fig">14</xref>c, d, DeepSV outperforms Concod in training accuracy. This suggests that DeepSV is better in deletion calling than Concod. For running time, Concod has smaller training time when the number of training samples is small. When the number of training samples is large, Concod takes longer time than DeepSV in training. The results are shown in Fig. <xref rid="Fig15" ref-type="fig">15</xref>.
<fig id="Fig15"><label>Fig. 15</label><caption><p>The relationship between training time and sample size about Concod and DeepSV</p></caption><graphic xlink:href="12859_2019_3299_Fig15_HTML" id="MO15"/></fig></p>
    </sec>
    <sec id="Sec19">
      <title>Eliminate false positives</title>
      <p id="Par58">After the data is pre-processed, we can eliminate the false positive deletion in VCF by our clustering appproach. In Table <xref rid="Tab3" ref-type="table">3</xref>, we show the number of false positives detected by DeepSV. Our results show that a significant number of false positives are removed by the clustering approach. We also compare the impact of model training on the removal of false positives and the presence of false positives in the Fig. <xref rid="Fig16" ref-type="fig">16</xref>. We can see that removing false positives in training significantly improves the training accuracy of the model.
<table-wrap id="Tab3"><label>Table 3</label><caption><p>Number of false positives are removed by DeepSV</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Sample</th><th>VCF Count</th><th>False Positives</th><th>Reserved Quantity by DeepSV</th></tr></thead><tbody><tr><td>NA12878</td><td>676</td><td>98</td><td>578</td></tr><tr><td>NA18511</td><td>802</td><td>63</td><td>739</td></tr><tr><td>NA18525</td><td>652</td><td>91</td><td>561</td></tr><tr><td>NA18631</td><td>687</td><td>78</td><td>609</td></tr><tr><td>NA18643</td><td>633</td><td>90</td><td>543</td></tr><tr><td>NA19017</td><td>836</td><td>78</td><td>758</td></tr><tr><td>NA19238</td><td>769</td><td>67</td><td>702</td></tr><tr><td>NA19239</td><td>722</td><td>81</td><td>641</td></tr><tr><td>NA19240</td><td>705</td><td>84</td><td>621</td></tr><tr><td>NA19625</td><td>809</td><td>92</td><td>717</td></tr></tbody></table></table-wrap>
<fig id="Fig16"><label>Fig. 16</label><caption><p><bold>a</bold> Shows the accuracy of the DeepSV training. The blue line represents the training accuracy when the false positive is not removed, and the orange line represents the training accuracy after the false positive is removed. The corresponding (<bold>b</bold>) shows the training loss</p></caption><graphic xlink:href="12859_2019_3299_Fig16_HTML" id="MO16"/></fig></p>
    </sec>
  </sec>
  <sec id="Sec20">
    <title>Discussion</title>
    <p id="Par59">On the high level, calling genetic variations from sequence reads is a process of extracting information in the reads that are relevant to the variations. Google’s DeepVariant approach shows that such information can be effectively extracted from color images constructed from the reads. A main advantage for this visualization based approach is that it offers an intuitive way to convert variation calling to image classification. This naturally leads to deep learning, which is currently the leading approach for image classification. Our DeepSV method extends this high-level approach to the case of structural variations. In particular, our results show that the visualization approach can be used for more complex genetic variations. Our results show that the overhead for visualizing sequence reads is low. The images contain useful information on structural variations. Deep learning can outperform other traditional machine learning since it doesn’t depend on manual selection of features. This may allow deep learning based methods to better utilize the data.</p>
    <p id="Par60">Usually deletion calling performance is affected by the type of data (e.g. sequence coverage and deletion lengths). A method can perform well for some type of data (say high coverage on short deletions) but doesn’t perform well for other types (say low coverage on long deletions). Our results show that DeepSV performs well in almost all the settings. This indicates that DeepSV integrates and effectively uses various sources of information in the sequence data in our simulation.</p>
    <p id="Par61">Similar to other supervised machine learning methods, DeepSV needs labeled training data. The more accurate the training data is, the better DeepSV performs for deletion calling. With large-scale genomics projects such as the 1000 Genomes Project, high-quality training data is becoming available. Most existing methods for SV calling don’t use the known genetic variations. This may indicate a potential loss of information and missed chances. DeepSV offers a natural way for using these benchmarked SVs for accurate calling of novel SVs.</p>
    <p id="Par62">This paper focuses on deletion calling. We note that there are other types of structural variations such as long insertions, inversions and copy number variations. A natural research direction is developing methods for calling these types of SVs with deep learning. This will need more thoughts on methodologies. For example, long insertions are different from deletions in that the inserted sequences are not present in the reference genome. This makes the reads visualization more difficult since DeepSV currently visualizes reads on the reference. Such issues need to be resolved in order to apply deep learning to these types of SVs.</p>
  </sec>
  <sec id="Sec21">
    <title>Conclusions</title>
    <p id="Par63">We demonstrate a novel method of variation detection, which breaks through the traditional sequence detection method. At the same time, our work shows that deep learning can potentially lead to effective calling of different types of genetic variations that are complex than SNPs.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary information</title>
    <sec id="Sec22">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="12859_2019_3299_MOESM1_ESM.doc">
            <caption>
              <p><bold>Additional file 1.</bold> More specific details about DeepSV.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>BAM</term>
        <def>
          <p id="Par4">Binary sequence alignment</p>
        </def>
      </def-item>
      <def-item>
        <term>CEU</term>
        <def>
          <p id="Par5">Utah Residents with Northern and Western European Ancestry</p>
        </def>
      </def-item>
      <def-item>
        <term>CHB</term>
        <def>
          <p id="Par6">Han Chinese in Beijing, China</p>
        </def>
      </def-item>
      <def-item>
        <term>CNN</term>
        <def>
          <p id="Par7">Convolutional neural network</p>
        </def>
      </def-item>
      <def-item>
        <term>SNPs</term>
        <def>
          <p id="Par8">Single nucleotide polymorphisms</p>
        </def>
      </def-item>
      <def-item>
        <term>SVM</term>
        <def>
          <p id="Par9">Support vector machine</p>
        </def>
      </def-item>
      <def-item>
        <term>SVs</term>
        <def>
          <p id="Par10">Structural variations</p>
        </def>
      </def-item>
      <def-item>
        <term>VCF</term>
        <def>
          <p id="Par11">Variant call format</p>
        </def>
      </def-item>
      <def-item>
        <term>YRI</term>
        <def>
          <p id="Par12">Yoruba in Ibadan, Nigeria</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Supplementary information</title>
    <p><bold>Supplementary information</bold> accompanies this paper at 10.1186/s12859-019-3299-y.</p>
  </sec>
  <ack>
    <title>Acknowledgements</title>
    <p>We would like to thank Kai Ye for useful discussions.</p>
    <sec id="FPar1">
      <title>Availability and implementation</title>
      <p id="Par64">DeepSV’s source code and sample result as part of this project are readily available from GitHub at <ext-link ext-link-type="uri" xlink:href="https://github.com/CSuperlei/DeepSV/">https://github.com/CSuperlei/DeepSV/</ext-link>.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>Conceived and designed the experiments: YW, JG, LC. Performed the experiments: LC. Analyzed the data: LC. Contributed reagents/materials/analysis tools: YW, LC. Wrote the paper: LC, YW, JG. All of authors have read and approved the manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>Project supported by Beijing Natural Science Foundation (5182018) and the Fundamental Research Funds for the Central Universities &amp; Research projects on biomedical transformation of China-Japan Friendship Hospital (PYBZ1834); YW is partly supported by a grant from US National Science Foundation (III-1526415). The funding bodies did not play any role in the design or development of this study, the analysis and interpretation of data, or in the writing of this manuscript.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>We use the real data from the phase three of the 1000 Genomes Project. The data are downloaded from: <ext-link ext-link-type="uri" xlink:href="ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase3/data/">ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase3/data/</ext-link>. The software and sample result as part of this project are readily available from GitHub at <ext-link ext-link-type="uri" xlink:href="https://github.com/CSuperlei/DeepSV">https://github.com/CSuperlei/DeepSV</ext-link>.</p>
  </notes>
  <notes>
    <title>Ethics approval and consent to participate</title>
    <p id="Par65">Not applicable.</p>
  </notes>
  <notes>
    <title>Consent for publication</title>
    <p id="Par66">Not applicable.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p id="Par67">The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McKenna</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Hanna</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Banks</surname>
            <given-names>E</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The genome analysis toolkit: a MapReduce framework for analyzing next-generation DAN sequencing data</article-title>
        <source>Genome Res</source>
        <year>2010</year>
        <volume>20</volume>
        <fpage>1297</fpage>
        <lpage>1303</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.107524.110</pub-id>
        <pub-id pub-id-type="pmid">20644199</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Silver</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Maddison</surname>
            <given-names>CJ</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mastering the game of go with deep neural networks and tree search</article-title>
        <source>Nature.</source>
        <year>2016</year>
        <volume>529</volume>
        <fpage>484</fpage>
        <lpage>489</lpage>
        <pub-id pub-id-type="doi">10.1038/nature16961</pub-id>
        <pub-id pub-id-type="pmid">26819042</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <mixed-citation publication-type="other">Poplin R, Dan N, Dijamco J, et al. Creating a universal SNP and small indel variant caller with deep neural networks. bioRvix. 2016;092890.</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ye</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jayasinghe</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Systematic discovery of complex indels in human cancers</article-title>
        <source>Nat Med</source>
        <year>2016</year>
        <volume>22</volume>
        <issue>1</issue>
        <fpage>97</fpage>
        <lpage>104</lpage>
        <pub-id pub-id-type="doi">10.1038/nm.4002</pub-id>
        <pub-id pub-id-type="pmid">26657142</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <mixed-citation publication-type="other">Charles Lu, Mingchao Xie, Michael Wendl, Jiayin Wang, Michael McLellan, Mark Leiserson, et al, Patterns and functional implications of rare germline variants across 12 cancer types, Nature Communications 6, Article number: 10086, December 2015.</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ye</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Schulz</surname>
            <given-names>MH</given-names>
          </name>
          <name>
            <surname>Long</surname>
            <given-names>Q</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Pindel: a pattern growth approach to detect break points of large deletions and medium sized insertions from paired-end short reads</article-title>
        <source>Bioinformatics.</source>
        <year>2016</year>
        <volume>25</volume>
        <fpage>2865</fpage>
        <lpage>2871</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp394</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Wallis</surname>
            <given-names>JW</given-names>
          </name>
          <name>
            <surname>McLellan</surname>
            <given-names>MD</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>BreakDancer: an algorithm for high-resolution mapping of genomic structural variation</article-title>
        <source>Nat Methods</source>
        <year>2009</year>
        <volume>6</volume>
        <fpage>677</fpage>
        <lpage>681</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1363</pub-id>
        <pub-id pub-id-type="pmid">19668202</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rausch</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Zichner</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Schlattl</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>DELLY: structural variant discovery by integrated paired-end and split-read analysis</article-title>
        <source>Bioinformatics.</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>i333</fpage>
        <lpage>i339</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts378</pub-id>
        <pub-id pub-id-type="pmid">22962449</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abyzov</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Urban</surname>
            <given-names>AE</given-names>
          </name>
          <name>
            <surname>Snyder</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>CNVnator: an approach to discover, genotype, and characterize typical and atypical CNVs from family and population genome sequencing</article-title>
        <source>Genome Res</source>
        <year>2011</year>
        <volume>21</volume>
        <fpage>974</fpage>
        <lpage>984</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.114876.110</pub-id>
        <pub-id pub-id-type="pmid">21324876</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lam</surname>
            <given-names>HYK</given-names>
          </name>
          <name>
            <surname>Mu</surname>
            <given-names>XJ</given-names>
          </name>
          <name>
            <surname>Adrian</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Nucleotide-resolution analysis of structural variants using Breakseq and a breakpoint library</article-title>
        <source>Nat Biotechnol</source>
        <year>2010</year>
        <volume>28</volume>
        <fpage>47</fpage>
        <lpage>55</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.1600</pub-id>
        <pub-id pub-id-type="pmid">20037582</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Layer</surname>
            <given-names>RM</given-names>
          </name>
          <name>
            <surname>Chiang</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Quinlan</surname>
            <given-names>AR</given-names>
          </name>
          <name>
            <surname>Hall</surname>
            <given-names>IM</given-names>
          </name>
        </person-group>
        <article-title>Lumpy: a probabilistic framework for structural variant discovery</article-title>
        <source>Genome Biol</source>
        <year>2014</year>
        <volume>15</volume>
        <fpage>R84</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2014-15-6-r84</pub-id>
        <pub-id pub-id-type="pmid">24970577</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Handsaker</surname>
            <given-names>RE</given-names>
          </name>
          <name>
            <surname>Van Doren</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Berman</surname>
            <given-names>JR</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Large multiallelic copy number variations in humans</article-title>
        <source>Nat Genet</source>
        <year>2015</year>
        <volume>47</volume>
        <fpage>296</fpage>
        <lpage>303</lpage>
        <pub-id pub-id-type="doi">10.1038/ng.3200</pub-id>
        <pub-id pub-id-type="pmid">25621458</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Yufeng</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>An improved approach for accurate and efficient calling of structural variations with low-coverage sequence data</article-title>
        <source>BMC Bioinformatics</source>
        <year>2012</year>
        <volume>13</volume>
        <fpage>S6</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-13-S6-S6</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <collab>1000 Genomes Project Consortium</collab>
        </person-group>
        <article-title>A map of human genome variation from population-scale sequencing</article-title>
        <source>Nature.</source>
        <year>2010</year>
        <volume>467</volume>
        <fpage>1061</fpage>
        <lpage>1073</lpage>
        <pub-id pub-id-type="doi">10.1038/nature09534</pub-id>
        <pub-id pub-id-type="pmid">20981092</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Marschall</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Hajirasouliha</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Schönhuth</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>MATE-CLEVER: Mendelian-inheritance-aware discovery and genotyping of midsize and long indels</article-title>
        <source>Bioinformatics.</source>
        <year>2013</year>
        <volume>29</volume>
        <fpage>3143</fpage>
        <lpage>3150</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btt556</pub-id>
        <pub-id pub-id-type="pmid">24072733</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhao</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>Q</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Computational tools for copy number variation (CNV) detection using next-generation sequencing data: features and perspectives</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>14</volume>
        <fpage>S1</fpage>
        <?supplied-pmid 24564169?>
        <pub-id pub-id-type="pmid">24564169</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <mixed-citation publication-type="other">Guan P, Sung WK. Structural variation detection using next-generation sequencing data: a comparative technical review. Methods. 2016;102:36–49.</mixed-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chu</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>GINDEL: accurate genotype calling of insertions and deletions from low coverage population sequence reads</article-title>
        <source>PLoS One</source>
        <year>2014</year>
        <volume>9</volume>
        <fpage>e113324</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0113324</pub-id>
        <pub-id pub-id-type="pmid">25423315</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cai</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Gao</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Concod: an effective integration framework of consensus-based calling deletions from next-generation sequencing data</article-title>
        <source>Int J Data Min Bioinform</source>
        <year>2018</year>
        <volume>17</volume>
        <fpage>152</fpage>
        <lpage>172</lpage>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Handsaker</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Wysoker</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The sequence alignment/map format and SAMtools</article-title>
        <source>Bioinformatics.</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>2078</fpage>
        <lpage>2079</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp352</pub-id>
        <pub-id pub-id-type="pmid">19505943</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <mixed-citation publication-type="other">TensorFlow is an open source software library for numerical computation using data flow graphs. 2018. <ext-link ext-link-type="uri" xlink:href="https://www.github.com/tensorflow/tensorflow">https://github.com/tensorflow/tensorflow</ext-link></mixed-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <mixed-citation publication-type="other">T. Dettmers. Which GPU(s) to get for deep learning: my experience and advice for using GPUs in deep learning. 2018; <ext-link ext-link-type="uri" xlink:href="https://www.timdettmers.com/2014/08/14/which-gpu-for-deep-learning">https://timdettmers.com/2014/08/14/which-gpu-for-deep-learning</ext-link></mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <mixed-citation publication-type="other">The NVIDIA Deep Learning GPU Training System (DIGITS). 2018. <ext-link ext-link-type="uri" xlink:href="https://www.developer.nvidia.com/digits">https://developer.nvidia.com/digits</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ye</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jayasinghe</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Systematic discovery of complex insertions and deletions in human cancers</article-title>
        <source>Nat Med</source>
        <year>2016</year>
        <volume>22</volume>
        <fpage>97</fpage>
        <lpage>104</lpage>
        <pub-id pub-id-type="doi">10.1038/nm.4002</pub-id>
        <pub-id pub-id-type="pmid">26657142</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Robinson</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Thorvaldsdóttir</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Winckler</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Guttman</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Lander</surname>
            <given-names>ES</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Integrative genomics viewer: high-performance genomics data visualization and exploration</article-title>
        <source>Nat Biotechnol</source>
        <year>2011</year>
        <volume>29</volume>
        <fpage>24</fpage>
        <lpage>26</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.1754</pub-id>
        <pub-id pub-id-type="pmid">21221095</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
