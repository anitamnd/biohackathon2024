<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10044409</article-id>
    <article-id pub-id-type="publisher-id">5240</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-023-05240-0</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>GVC: efficient random access compression for gene sequence variations</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Adhisantoso</surname>
          <given-names>Yeremia Gunawan</given-names>
        </name>
        <address>
          <email>adhisant@tnt.uni-hannover.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Voges</surname>
          <given-names>Jan</given-names>
        </name>
        <address>
          <email>voges@tnt.uni-hannover.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Rohlfing</surname>
          <given-names>Christian</given-names>
        </name>
        <address>
          <email>rohlfing@ient.rwth-aachen.de</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tunev</surname>
          <given-names>Viktor</given-names>
        </name>
        <address>
          <email>viktor.tunev@rwth-aachen.de</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ohm</surname>
          <given-names>Jens-Rainer</given-names>
        </name>
        <address>
          <email>ohm@ient.rwth-aachen.de</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ostermann</surname>
          <given-names>Jörn</given-names>
        </name>
        <address>
          <email>office@tnt.uni-hannover.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="GRID">grid.9122.8</institution-id><institution-id institution-id-type="ISNI">0000 0001 2163 2777</institution-id><institution>Institut für Informationsverarbeitung and L3S Research Center, </institution><institution>Leibniz University Hannover, </institution></institution-wrap>Hannover, Germany </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="GRID">grid.1957.a</institution-id><institution-id institution-id-type="ISNI">0000 0001 0728 696X</institution-id><institution>Institut für Nachrichtentechnik, </institution><institution>RWTH Aachen University, </institution></institution-wrap>Aachen, Germany </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>28</day>
      <month>3</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>28</day>
      <month>3</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2023</year>
    </pub-date>
    <volume>24</volume>
    <elocation-id>121</elocation-id>
    <history>
      <date date-type="received">
        <day>16</day>
        <month>11</month>
        <year>2022</year>
      </date>
      <date date-type="accepted">
        <day>20</day>
        <month>3</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023</copyright-statement>
      <license>
        <ali:license_ref specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p><bold>Open Access</bold>This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article's Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article's Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated in a credit line to the data.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">In recent years, advances in high-throughput sequencing technologies have enabled the use of genomic information in many fields, such as precision medicine, oncology, and food quality control. The amount of genomic data being generated is growing rapidly and is expected to soon surpass the amount of video data. The majority of sequencing experiments, such as genome-wide association studies, have the goal of identifying variations in the gene sequence to better understand phenotypic variations. We present a novel approach for compressing gene sequence variations with random access capability: the Genomic Variant Codec (GVC). We use techniques such as binarization, joint row- and column-wise sorting of blocks of variations, as well as the image compression standard JBIG for efficient entropy coding.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">Our results show that GVC provides the best trade-off between compression and random access compared to the state of the art: it reduces the genotype information size from 758 GiB down to 890 MiB on the publicly available 1000 Genomes Project (phase 3) data, which is 21% less than the state of the art in random-access capable methods.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">By providing the best results in terms of combined random access and compression, GVC facilitates the efficient storage of large collections of gene sequence variations. In particular, the random access capability of GVC enables seamless remote data access and application integration. The software is open source and available at <ext-link ext-link-type="uri" xlink:href="https://github.com/sXperfect/gvc/">https://github.com/sXperfect/gvc/</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Variants</kwd>
      <kwd>VCF</kwd>
      <kwd>Compression</kwd>
      <kwd>Random access</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100004115</institution-id>
            <institution>Gottfried Wilhelm Leibniz Universität Hannover</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100004115</institution-id>
            <institution>Gottfried Wilhelm Leibniz Universität Hannover</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>L3S Research Center</institution>
        </funding-source>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>L3S Research Center</institution>
        </funding-source>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>L3S Research Center</institution>
        </funding-source>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>RWTH Aachen University</institution>
        </funding-source>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>RWTH Aachen University</institution>
        </funding-source>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>RWTH Aachen University</institution>
        </funding-source>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>Gottfried Wilhelm Leibniz Universität Hannover (1038)</institution>
        </funding-source>
      </award-group>
      <open-access>
        <p>Open Access funding enabled and organized by Projekt DEAL.</p>
      </open-access>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2023</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Introduction</title>
    <p id="Par10">In the course of the last decades, the cost of genome sequencing has dropped significantly, to less than USD 1000, enabling the use of genomic information in many fields, such as precision medicine, oncology, and food quality control. This led to an explosion in data generation, with the volume of data generated annually soon surpassing that of other big data domains such as video and astronomy [<xref ref-type="bibr" rid="CR1">1</xref>].</p>
    <p id="Par11">A major focus of genetic research is the analysis of gene sequence variations. In fact, the discovery of gene sequence variations among large populations of related samples is one of the main applications of next- and third-generation sequencing technologies. Genetic variations can be classified into: (i) single-nucleotide polymorphisms (SNPs); (ii) insertions and deletions (indels); (iii) (large) structural variants (SV). Such gene sequence variations (or “variants”) are commonly stored in the text-based variant call format (VCF) [<xref ref-type="bibr" rid="CR2">2</xref>].</p>
    <p id="Par12">A VCF file consists of two main parts: the header and the actual variant records. Each variant record is stored on a single line and separated into multiple annotations, which can be either site-level or sample-level.</p>
    <p id="Par13">Regarding the site-level annotations, the first eight columns (CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO) represent the properties observed at the variant site. When multiple samples are represented in a VCF file, some of the site-level annotations represent a summary or average of the values obtained for that site from different samples. The following site-level annotations are relevant in the scope of our work: CHROM—the contig (usually a chromosome) on which the variant occurs; POS—the 1-based genomic coordinate on the contig of the variant (note that for deletions the position given is the base preceding the event); REF—the reference allele; ALT—the alternative allele(s) observed in a sample, or a set of samples (note that REF and ALT are given on the forward strand, for insertions, the ALT allele includes the inserted sequence as well as the base preceding the insertion, for deletions, the ALT allele is the base before the deletion). Sample-level annotations are contained in the 9th column (FORMAT) and in the sample columns (10th and beyond). Sample-level annotations are tag-value pairs. The tags are recorded in the FORMAT field. The values are recorded in the corresponding order in each sample column.</p>
    <p id="Par14">Our work focuses on the sample-level annotation with the GT tag. Its value indicates the genotype of a sample at a variant site. For a diploid organism, the value indicates the two alleles carried by the sample, encoded by a 0 for the REF allele, 1 for the first ALT allele, 2 for the second ALT allele, and so on. In addition, phasing information is incorporated to each genotype value: “/” for unphased genotype and “|” for phased genotype. For example, if there is a single ALT allele (which is by far the most common case), the value will be either: 0/0—the sample is homozygous reference; 0/1—the sample is heterozygous, carrying one copy each of the REF and ALT alleles; 1/1—the sample is homozygous alternate.</p>
    <p id="Par15">For non-diploids, the same pattern applies; in the haploid case, there will be just a single number; for polyploids, there will be more, e.g., 4 numbers for a tetraploid organism.</p>
    <p id="Par16">In summary, VCF files contain the actual variant information together with a considerable amount of metadata pertaining to the variant calling process. The metadata is primarily used to filter out irrelevant variants. Once the variants are filtered, the genotype and phasing information associated with each sample generally becomes the primary information for further downstream analyses.</p>
    <p id="Par17">In this paper, we introduce a novel approach for compressing gene sequence variations with random access capability: the Genomic Variant Codec (GVC). We compare our approach with three existing approaches: GTRAC [<xref ref-type="bibr" rid="CR3">3</xref>], GTC [<xref ref-type="bibr" rid="CR4">4</xref>], and GTShark [<xref ref-type="bibr" rid="CR5">5</xref>]. GTRAC, introduced in 2016, is based on a customized Lempel-Ziv compressor [<xref ref-type="bibr" rid="CR6">6</xref>]. In 2018, Danek et al. introduced column-wise sorting (i.e., a permutation of haplotypes) in GTC to minimize the number of differences between adjacent samples. They use a combination of techniques such as run-length encoding, Lempel-Ziv representation, and Huffman coding for compression. Both GTRAC and GTC offer random access capability. GTShark, proposed by Deorowicz et al. in 2019, achieves higher compression using a combination of generalized version of positional Burrows-Wheeler transform (PBWT) [<xref ref-type="bibr" rid="CR7">7</xref>] called gPBWT [<xref ref-type="bibr" rid="CR8">8</xref>] and a range coder [<xref ref-type="bibr" rid="CR9">9</xref>] with special contextual modeling. The Burrow-Wheeler transform (BWT) rearranges the symbols by permuting the order of the characters based on their lexicographic order. This results in runs of similar characters. In comparison, both PBWT and gPBWT permute the rows based on the previous rows. This maximizes the compression efficiency because the genotypes of adjacent locations or positions tend to be highly correlated. Range coding is an entropy coding method that works by dividing a large range of integers, representing an interval [0, 1). The range is divided into sub-ranges whose sizes are proportional to the probability of the symbol they represent. The input symbol is then mapped to an interval, in which the corresponding probability lies.</p>
    <p id="Par18">Since the goal of GTShark is to maximize compression, the intermediate sample permutations are not stored and thus random access is not supported. However, in principle, the concept of GTShark does not prohibit implementing random access.</p>
  </sec>
  <sec id="Sec2">
    <title>Methods</title>
    <p id="Par19">We propose a new tool called Genomic Variant Codec (GVC) for the compression of gene sequence variations. GVC comprises transformations and entropy coding steps depicted in Fig. <xref rid="Fig1" ref-type="fig">1</xref>.</p>
    <p id="Par20">In our proposed approach, the genotypes are extracted from a VCF file and divided into blocks. Each block <inline-formula id="IEq3"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {G}$$\end{document}</tex-math><mml:math id="M2"><mml:mi mathvariant="script">G</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq3.gif"/></alternatives></inline-formula> represents genotypes of all samples in a certain range of loci in a chromosome (or across multiple chromosomes). Splitting into blocks allows for non-sequential access and parallel processing. Each block is then further divided into two different matrices: the allele matrix <inline-formula id="IEq4"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M4"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq4.gif"/></alternatives></inline-formula> and the phasing matrix <inline-formula id="IEq5"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {P}$$\end{document}</tex-math><mml:math id="M6"><mml:mi mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq5.gif"/></alternatives></inline-formula>. The phasing matrix is a binary matrix while the allele matrix is an integer matrix.</p>
    <p id="Par21">We propose two alternative binarization approaches to decompose the allele matrix into a binary representation: bit plane binarization and row binarization. These steps allow for variable bit-lengths for integer values. The choice between bit plane binarization and row binarization depends on the properties of the data. Bit plane binarization yields bit planes <inline-formula id="IEq6"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {B}_q$$\end{document}</tex-math><mml:math id="M8"><mml:msub><mml:mi mathvariant="script">B</mml:mi><mml:mi>q</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq6.gif"/></alternatives></inline-formula> that can be concatenated into a single binary matrix <inline-formula id="IEq7"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {C}$$\end{document}</tex-math><mml:math id="M10"><mml:mi mathvariant="script">C</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq7.gif"/></alternatives></inline-formula>. Alternatively, row binarization yields only a single binary matrix.</p>
    <p id="Par22">Subsequently, optionally, the row- and column-wise sorting is applied to binary matrices. The motivation behind the sorting process is to maximize the average run-length of zeros and ones in both directions, which then facilitates more efficient entropy coding. We use the Hamming distance to measure the similarity between adjacent rows and columns. At the end of the process, each binary matrix is entropy-encoded. In our experiments, we used an implementation of the JBIG standard, which specifies bi-level image compression [<xref ref-type="bibr" rid="CR10">10</xref>]. Note that, in principle, any other entropy codec could be used for this purpose. In the following sections, we explain the four stages of GVC—splitting, binarization, sorting, and entropy coding—in more detail.<fig id="Fig1"><label>Fig. 1</label><caption><p>Block diagram of the proposed encoding process. The genotype matrix <inline-formula id="IEq8"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {G}$$\end{document}</tex-math><mml:math id="M12"><mml:mi mathvariant="script">G</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq8.gif"/></alternatives></inline-formula> is processed by a series of transformations: splitting, binarization, and optionally sorting. At the end of the process, entropy coding is applied</p></caption><graphic xlink:href="12859_2023_5240_Fig1_HTML" id="MO1"/></fig></p>
    <sec id="Sec3">
      <title>Splitting</title>
      <p id="Par23">In the first step, the genotypes are extracted from a VCF file and divided into blocks. We also refer to each block as a genotype matrix <inline-formula id="IEq9"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {G}$$\end{document}</tex-math><mml:math id="M14"><mml:mi mathvariant="script">G</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq9.gif"/></alternatives></inline-formula>. The genotype matrix is then further decomposed into an allele matrix and a phasing matrix as shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>a. Given <italic>m</italic> variant records, each containing GT annotations for <italic>n</italic>
<italic>p</italic>-ploid samples, the allele matrix <inline-formula id="IEq10"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M16"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq10.gif"/></alternatives></inline-formula> can be formulated as follows:<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \mathcal {A} {:}{=}\begin{pmatrix} a_{0,0,0}, \dots , a_{0,0,(p-1)} &amp;{} \dots &amp;{} a_{0,(n-1),0}, \dots , a_{0,(n-1),(p-1)} \\ \vdots &amp;{} \ddots &amp;{} \vdots \\ a_{(m-1),0,0}, \dots , a_{(m-1),0,(p-1)} &amp;{} \dots &amp;{} a_{(m-1),(n-1),0}, \dots , a_{(m-1),(n-1),(p-1)} \end{pmatrix}\text {,} \end{aligned}$$\end{document}</tex-math><mml:math id="M18" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="script">A</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>⋯</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⋯</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>⋯</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⋮</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⋱</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⋮</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>⋯</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⋯</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>⋯</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mtext>,</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2023_5240_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula>with <inline-formula id="IEq11"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$a_{i,j,k} \in \mathbb {N} \cup \{0\}$$\end{document}</tex-math><mml:math id="M20"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi><mml:mo>∪</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq11.gif"/></alternatives></inline-formula>. Phasing information such as unphased (“/”) and phased (“|”) is stored in the phasing matrix <inline-formula id="IEq12"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {P}$$\end{document}</tex-math><mml:math id="M22"><mml:mi mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq12.gif"/></alternatives></inline-formula> as values 0 and 1, respectively. The phasing matrix <inline-formula id="IEq13"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {P}$$\end{document}</tex-math><mml:math id="M24"><mml:mi mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq13.gif"/></alternatives></inline-formula> can be formulated as follows:<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \mathcal {P} {:}{=}\begin{pmatrix} p_{0,0} &amp;{} \dots &amp;{} p_{0,(n-1)} \\ \vdots &amp;{} \ddots &amp;{} \vdots \\ p_{(m-1),0} &amp;{} \dots &amp;{} p_{(m-1),(n-1)} \end{pmatrix} \end{aligned}$$\end{document}</tex-math><mml:math id="M26" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="script">P</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⋯</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⋮</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⋱</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⋮</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mo>⋯</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2023_5240_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula>with <inline-formula id="IEq14"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$p_{i,j}\in \{0,1\}$$\end{document}</tex-math><mml:math id="M28"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq14.gif"/></alternatives></inline-formula>.</p>
      <p id="Par24">Below are <inline-formula id="IEq15"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$m=2$$\end{document}</tex-math><mml:math id="M30"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq15.gif"/></alternatives></inline-formula> example variant records, each containing GT annotations for <inline-formula id="IEq16"><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$n=2$$\end{document}</tex-math><mml:math id="M32"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq16.gif"/></alternatives></inline-formula> samples named S1 and S2:<disp-formula id="Equ4"><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \begin{array}{lllllll} \text {CHROM} \quad \quad &amp;{} \text {POS} \quad \quad &amp;{} \text {REF} \quad \quad &amp;{} \text {ALT} \quad \quad &amp;{} \text {FORMAT} \quad \quad &amp;{} \text {S1} \quad \quad &amp;{} \text {S2}\\ \text {1} \quad \quad &amp;{} \text {1} \quad \quad &amp;{} \text {A} \quad \quad &amp;{} \text {G} \quad \quad &amp;{} \text {GT} \quad \quad &amp;{} \text {0}\vert \text {2} \quad \quad &amp;{} \text {2/0}\\ \text {1} \quad \quad &amp;{} \text {10} \quad \quad &amp;{} \text {C} \quad \quad &amp;{} \text {A} \quad \quad &amp;{} \text {GT} \quad \quad &amp;{} \text {1/0} \quad \quad &amp;{} \text {0}\vert \text {0}.\end{array} \end{aligned}$$\end{document}</tex-math><mml:math id="M34" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mtext>CHROM</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>POS</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>REF</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>ALT</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>FORMAT</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>S1</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>S2</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>1</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>1</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>A</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>G</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>GT</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>0</mml:mtext><mml:mo stretchy="false">|</mml:mo><mml:mtext>2</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>2/0</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>1</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>10</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>C</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>A</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>GT</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>1/0</mml:mtext><mml:mspace width="1em"/><mml:mspace width="1em"/></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mtext>0</mml:mtext><mml:mo stretchy="false">|</mml:mo><mml:mtext>0</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2023_5240_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula>The corresponding <inline-formula id="IEq17"><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$m\times n$$\end{document}</tex-math><mml:math id="M36"><mml:mrow><mml:mi>m</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq17.gif"/></alternatives></inline-formula> genotype matrix <inline-formula id="IEq18"><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {G}$$\end{document}</tex-math><mml:math id="M38"><mml:mi mathvariant="script">G</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq18.gif"/></alternatives></inline-formula> is then split into allele matrix <inline-formula id="IEq19"><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M40"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq19.gif"/></alternatives></inline-formula> and phasing matrix <inline-formula id="IEq20"><alternatives><tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {B}$$\end{document}</tex-math><mml:math id="M42"><mml:mi mathvariant="script">B</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq20.gif"/></alternatives></inline-formula> as follows:<disp-formula id="Equ5"><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \mathcal {G} = \begin{pmatrix} 0|2 &amp;{} 2/0\\ 1/0 &amp;{} 0|0 \end{pmatrix} \;\xrightarrow []{\text {split}}\; \mathcal {A} = \begin{pmatrix} 0 &amp;{} 2 &amp;{} 2 &amp;{} 0\\ 1 &amp;{} 0 &amp;{} 0 &amp;{} 0 \end{pmatrix} ,\;\; \mathcal {P} = \begin{pmatrix} 0 &amp;{} 1\\ 1 &amp;{} 0 \end{pmatrix}\text {.} \end{aligned}$$\end{document}</tex-math><mml:math id="M44" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="script">G</mml:mi><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mn>0</mml:mn><mml:mo stretchy="false">|</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>2</mml:mn><mml:mo stretchy="false">/</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:mn>1</mml:mn><mml:mo stretchy="false">/</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>0</mml:mn><mml:mo stretchy="false">|</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mspace width="0.277778em"/><mml:mover><mml:mo stretchy="false">→</mml:mo><mml:mtext>split</mml:mtext></mml:mover><mml:mspace width="0.277778em"/><mml:mi mathvariant="script">A</mml:mi><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>2</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>2</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>0</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>0</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mspace width="0.277778em"/><mml:mspace width="0.277778em"/><mml:mi mathvariant="script">P</mml:mi><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mtext>.</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2023_5240_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula>In the special case that all genotypes are either phased or unphased, it is not necessary to encode and transmit the phasing matrix <inline-formula id="IEq21"><alternatives><tex-math id="M45">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {P}$$\end{document}</tex-math><mml:math id="M46"><mml:mi mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq21.gif"/></alternatives></inline-formula>. Instead, the information (that all genotypes are (un)phased) can be signaled with a flag. In some cases, allele values may be missing, indicated by a dot (“.”) in the VCF file, or the ploidy may vary along the rows. To handle missing values, we replace the dots with a special integer value. If the ploidy varies within a block, the genotypes are padded with another special integer value so that the ploidy is uniform within a block.<fig id="Fig2"><label>Fig. 2</label><caption><p>Example for <inline-formula id="IEq22"><alternatives><tex-math id="M47">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathcal {G}} = \begin{array}{ll} 0\mid 2 &amp;{} 2/0 \\ 1/0 &amp;{} 0 \mid 0 \end{array}$$\end{document}</tex-math><mml:math id="M48"><mml:mrow><mml:mi mathvariant="script">G</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mn>0</mml:mn><mml:mo>∣</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mn>2</mml:mn><mml:mo stretchy="false">/</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mn>1</mml:mn><mml:mo stretchy="false">/</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mrow/><mml:mn>0</mml:mn><mml:mo>∣</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq22.gif"/></alternatives></inline-formula>. Bit plane binarization yields two bit planes representing the most significant bit and the less significant bit of <inline-formula id="IEq23"><alternatives><tex-math id="M49">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M50"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq23.gif"/></alternatives></inline-formula>. Row binarization generates only three binary rows because the first row of <inline-formula id="IEq24"><alternatives><tex-math id="M51">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M52"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq24.gif"/></alternatives></inline-formula> requires two bits and the second row of <inline-formula id="IEq25"><alternatives><tex-math id="M53">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M54"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq25.gif"/></alternatives></inline-formula> requires only one bit</p></caption><graphic xlink:href="12859_2023_5240_Fig2_HTML" id="MO6"/></fig></p>
    </sec>
    <sec id="Sec4">
      <title>Binarization</title>
      <p id="Par25">In the next step, the allele matrix <inline-formula id="IEq26"><alternatives><tex-math id="M55">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M56"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq26.gif"/></alternatives></inline-formula> is binarized. We propose two alternative binarization approaches: bit plane binarization (an example is shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>b) and a binarization using a technique we call “row binarization” (an example is shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>c).</p>
      <p id="Par26">In the bit plane binarization, each value <inline-formula id="IEq27"><alternatives><tex-math id="M57">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$a_{i,j,k}$$\end{document}</tex-math><mml:math id="M58"><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq27.gif"/></alternatives></inline-formula> of the allele matrix <inline-formula id="IEq28"><alternatives><tex-math id="M59">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M60"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq28.gif"/></alternatives></inline-formula> is expressed as a set of binary numbers. All <italic>q</italic>-th significant bits are then aggregated as a bit plane <inline-formula id="IEq29"><alternatives><tex-math id="M61">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {B}_q$$\end{document}</tex-math><mml:math id="M62"><mml:msub><mml:mi mathvariant="script">B</mml:mi><mml:mi>q</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq29.gif"/></alternatives></inline-formula>. The number of bit planes <italic>Q</italic> is computed based on the maximum value in the allele matrix <inline-formula id="IEq30"><alternatives><tex-math id="M63">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M64"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq30.gif"/></alternatives></inline-formula>:<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M65">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$Q = \left\lceil {\log _{2} \left( {\max _{{\forall i,j,k}} \left\{ {a_{{i,j,k}} } \right\} + 1} \right)} \right\rceil.$$\end{document}</tex-math><mml:math id="M66" display="block"><mml:mrow><mml:mi>Q</mml:mi><mml:mo>=</mml:mo><mml:mfenced close="⌉" open="⌈"><mml:mrow><mml:msub><mml:mo>log</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mfenced close=")" open="("><mml:mrow><mml:munder><mml:mo movablelimits="true">max</mml:mo><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mfenced close="}" open="{"><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mfenced><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>.</mml:mo></mml:mrow></mml:math><graphic xlink:href="12859_2023_5240_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula>The allele values <inline-formula id="IEq31"><alternatives><tex-math id="M67">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$a_{i,j,k}$$\end{document}</tex-math><mml:math id="M68"><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq31.gif"/></alternatives></inline-formula> are expressed as binary numbers using exactly <italic>Q</italic> bits per value and the bit plane binarization yields <italic>Q</italic> bit planes. The <italic>q</italic>-th bit plane <inline-formula id="IEq32"><alternatives><tex-math id="M69">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {B}_q$$\end{document}</tex-math><mml:math id="M70"><mml:msub><mml:mi mathvariant="script">B</mml:mi><mml:mi>q</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq32.gif"/></alternatives></inline-formula> is the concatenation of the <italic>q</italic>-th least significant bit of each allele value, with <inline-formula id="IEq33"><alternatives><tex-math id="M71">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$q\in \{0,\cdots ,(Q-1)\}$$\end{document}</tex-math><mml:math id="M72"><mml:mrow><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>⋯</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq33.gif"/></alternatives></inline-formula>. Optionally, bit planes can be concatenated either row-wise or column-wise.</p>
      <p id="Par27">In the row binarization, each row is decomposed into multiple binary rows as follows. Each row <italic>i</italic> contains allele values <inline-formula id="IEq34"><alternatives><tex-math id="M73">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$a_{i,j,k}$$\end{document}</tex-math><mml:math id="M74"><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq34.gif"/></alternatives></inline-formula> with the corresponding maximum allele value being denoted as <inline-formula id="IEq35"><alternatives><tex-math id="M75">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$a_{i}^{\text {max}}$$\end{document}</tex-math><mml:math id="M76"><mml:msubsup><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mtext>max</mml:mtext></mml:msubsup></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq35.gif"/></alternatives></inline-formula>. Given a maximum allele value <inline-formula id="IEq36"><alternatives><tex-math id="M77">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$a_{i}^{\text {max}}$$\end{document}</tex-math><mml:math id="M78"><mml:msubsup><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mtext>max</mml:mtext></mml:msubsup></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq36.gif"/></alternatives></inline-formula>, we can compute the number of bits required to represent the row (using a naïve binary encoding) as <inline-formula id="IEq37"><alternatives><tex-math id="M79">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$R=\left\lceil\log _2\left( a_{i}^{\text {max}}+1\right) \right\rceil$$\end{document}</tex-math><mml:math id="M80"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mfenced close="⌉" open="⌈"><mml:msub><mml:mo>log</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mfenced close=")" open="("><mml:msubsup><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mtext>max</mml:mtext></mml:msubsup><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mfenced></mml:mfenced></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq37.gif"/></alternatives></inline-formula>. The number of required bits <italic>R</italic> is equal to the number of resulting binary rows. The <italic>r</italic>-th binary row contains the <italic>r</italic>-th least significant bit of allele values of the respective row. At the end of the process, all of the resulting binary rows are concatenated row-wise, which yields a single binary matrix. Note that the reconstruction of the allele matrix <inline-formula id="IEq38"><alternatives><tex-math id="M81">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M82"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq38.gif"/></alternatives></inline-formula> from this binary matrix is possible because the maximum allele value <inline-formula id="IEq39"><alternatives><tex-math id="M83">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$a_{i}^{\text {max}}$$\end{document}</tex-math><mml:math id="M84"><mml:msubsup><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mtext>max</mml:mtext></mml:msubsup></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq39.gif"/></alternatives></inline-formula> can be computed based on the number of alleles in the ALT column of the original VCF file. Within GVC, this information is communicated to the decoder as side information.</p>
      <p id="Par28">Both bit plane and row binarization have their own advantages and disadvantages. The binarization can be chosen based on the number of alternate alleles of each row within a block. Bit plane binarization is most advantageous when the number of alternate alleles is constant. In such a case, row binarization generates a larger matrix because the number of bits of each row must be preserved, even if the number of alternate alleles is constant. In contrast, row binarization is advantageous when the number of alternate alleles within a block is not constant. For real-world data, we recommend row binarization over bit plane binarization as the default binarization because of the variable number of alternate alleles.</p>
    </sec>
    <sec id="Sec5">
      <title>Sorting</title>
      <p id="Par29">In previous works such as GTC [<xref ref-type="bibr" rid="CR4">4</xref>], the sorting of haplotype matrix columns was proposed to improve the performance of subsequent entropy coding schemes. In addition to column-wise sorting, here we propose row-wise sorting. Preliminary experiments showed that subsequent entropy coding schemes yield smaller bitstreams when rows are sorted in particular ways. One possible reason lies in the fact that if some samples belong to a group of similar individuals, then the variants found on these samples are expected to be similar. By sorting in both directions, run lengths can be maximized, which presumably also facilitates a more efficient entropy coding. Note that sort indices must be transmitted to reconstruct the original row order.</p>
      <p id="Par30">As an example, consider the following allele matrix <inline-formula id="IEq40"><alternatives><tex-math id="M85">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M86"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq40.gif"/></alternatives></inline-formula>:<disp-formula id="Equ6"><alternatives><tex-math id="M87">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \mathcal {A} = \begin{pmatrix} 0\ 2 &amp;{} 2\ 0\\ 1\ 0 &amp;{} 0\ 0 \end{pmatrix}. \end{aligned}$$\end{document}</tex-math><mml:math id="M88" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="script">A</mml:mi><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mn>0</mml:mn><mml:mspace width="4pt"/><mml:mn>2</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>2</mml:mn><mml:mspace width="4pt"/><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:mn>1</mml:mn><mml:mspace width="4pt"/><mml:mn>0</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>0</mml:mn><mml:mspace width="4pt"/><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2023_5240_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula>Let us assume that swapping the rows lets a subsequent entropy coding scheme yield a smaller bitstream. The sorted allele matrix <inline-formula id="IEq41"><alternatives><tex-math id="M89">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\tilde{\mathcal {A}}$$\end{document}</tex-math><mml:math id="M90"><mml:mover accent="true"><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq41.gif"/></alternatives></inline-formula> is then as follows:<disp-formula id="Equ7"><alternatives><tex-math id="M91">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \tilde{\mathcal {A}} = \begin{pmatrix} 1\ 0 &amp;{} 0\ 0\\ 0\ 2 &amp;{} 2\ 0 \end{pmatrix}. \end{aligned}$$\end{document}</tex-math><mml:math id="M92" display="block"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script">A</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mspace width="4pt"/><mml:mn>0</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>0</mml:mn><mml:mspace width="4pt"/><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow/><mml:mn>0</mml:mn><mml:mspace width="4pt"/><mml:mn>2</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow/><mml:mn>2</mml:mn><mml:mspace width="4pt"/><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2023_5240_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula>To reconstruct the allele matrix <inline-formula id="IEq42"><alternatives><tex-math id="M93">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M94"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq42.gif"/></alternatives></inline-formula> at the decoder, the sort row indices <inline-formula id="IEq43"><alternatives><tex-math id="M95">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\tilde{a}} = (1\;0)^T$$\end{document}</tex-math><mml:math id="M96"><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.277778em"/><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq43.gif"/></alternatives></inline-formula> must be transmitted.</p>
      <p id="Par31">Before the sorting process, a cost matrix <italic>C</italic> based on the Hamming distance [<xref ref-type="bibr" rid="CR11">11</xref>] is computed for each pair of rows or columns depending on the sorting direction. The Hamming distance of a pair of rows or columns is the number of positions where the corresponding values differ. The entry of the cost matrix <inline-formula id="IEq44"><alternatives><tex-math id="M97">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$c_{ij}$$\end{document}</tex-math><mml:math id="M98"><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mi mathvariant="italic">ij</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq44.gif"/></alternatives></inline-formula> at row <italic>i</italic> and column <italic>j</italic> describes the Hamming distance between the <italic>i</italic>-th and <italic>j</italic>-th rows for row sorting and <italic>i</italic>-th and <italic>j</italic>-th columns for column sorting. The main diagonal of the cost matrix is zero.</p>
      <p id="Par32">The time complexity of computing the cost matrix is quadratic with regard to the block size and the number of samples. To alleviate this limitation, we can also split the genotypes into blocks in the column direction. This reduces the sorting cost and the decoding time. However, this comes at the expense of compression performance.</p>
      <p id="Par33">Note that any other suitable cost function could be used instead (of course, it should ideally be chosen to match the chosen entropy coding method). At the end of the sorting process, the order of rows and/or columns, respectively, which provides the lowest total cost, is selected. This selection process can be regarded as equivalent to solving the traveling salesman problem, which we solve using a nearest neighbor heuristic. Other methods of solving this problem, such as the Lin-Kernighan heuristic [<xref ref-type="bibr" rid="CR12">12</xref>], could be employed to achieve a potentially better compression at the expense of encoding time.</p>
    </sec>
    <sec id="Sec6">
      <title>Entropy coding</title>
      <p id="Par34">The results of the transformations, i.e., binarizations and sorting procedures, are binary matrices <inline-formula id="IEq45"><alternatives><tex-math id="M99">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {B}_q$$\end{document}</tex-math><mml:math id="M100"><mml:msub><mml:mi mathvariant="script">B</mml:mi><mml:mi>q</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq45.gif"/></alternatives></inline-formula>, <inline-formula id="IEq46"><alternatives><tex-math id="M101">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {C}$$\end{document}</tex-math><mml:math id="M102"><mml:mi mathvariant="script">C</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq46.gif"/></alternatives></inline-formula>, <inline-formula id="IEq47"><alternatives><tex-math id="M103">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {P}$$\end{document}</tex-math><mml:math id="M104"><mml:mi mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq47.gif"/></alternatives></inline-formula> which we interpret as binary images. Any method that can efficiently encode binary images losslessly can be utilized for entropy coding, such as binary arithmetic coding. Even better compression performance can be achieved by estimating the source statistics, e.g. using context modeling, which estimates the probability of a current symbol depending on previous symbols. For GVC, we choose an encoder compliant to the JBIG standard (ISO/IEC 11544 [<xref ref-type="bibr" rid="CR10">10</xref>]). JBIG specifies the lossless compression of bi-level images.<xref ref-type="fn" rid="Fn1">1</xref> It takes advantage of the spatial correlation of bi-level pixels for efficient compression. The length of the context model in JBIG varies between in total of 10 to 12 neighboring values in both row and column directions, depending on the selected context mode. In combination with the sorting, we maximize the similarity between the adjacent columns or rows of the binary matrices. This generally enables JBIG to infer better context models, thus increasing the overall compression efficiency.</p>
    </sec>
  </sec>
  <sec id="Sec7">
    <title>Results</title>
    <p id="Par35">For our simulations, we used data from phase 3 of the 1000 Genomes Project [<xref ref-type="bibr" rid="CR14">14</xref>]. The data set consists of 22 VCF files with a total size of 770 GiB. The genotype information occupies the largest share of 758 GiB.</p>
    <p id="Par36">We can configure GVC with several parameters: the binarization can be either bit plane binarization or row binarization; the sorting can be disabled, configured for rows or columns only, or enabled for both rows and columns. We set the block size to 2504 variant records based on empirical experiment. Since we sort both rows and columns, we seek a well-balanced trade-off between the compression improved by the sorting and the overhead induced by transmitting sorting indices. Thus, by assuming that at each variant site there are roughly three alternate alleles, we compute the block size of 2504 by multiplying the number of samples (2504) by the ploidy (2) divided by the average number of bits required to represent each value (2). Also, we fixed the following encoder parameters: the sorting algorithm (nearest neighbor), the sorting metric (Hamming distance), and the compressor (JBIG). In total we ended up with 12 configurations for GVC: <inline-formula id="IEq48"><alternatives><tex-math id="M105">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$2+1$$\end{document}</tex-math><mml:math id="M106"><mml:mrow><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq48.gif"/></alternatives></inline-formula> binarizations (bit plane with and without concatenation, and row binarization) <inline-formula id="IEq49"><alternatives><tex-math id="M107">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\times$$\end{document}</tex-math><mml:math id="M108"><mml:mo>×</mml:mo></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq49.gif"/></alternatives></inline-formula> 4 sorting schemes (none, col, row, both). These configurations and their corresponding identifiers are listed in Table <xref rid="Tab1" ref-type="table">1</xref>.<table-wrap id="Tab1"><label>Table 1</label><caption><p>GVC configurations</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">ID</th><th align="left">Binarization</th><th align="left">Sorting</th><th align="left">ID</th><th align="left">Binarization</th><th align="left">Sorting</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">Bit plane (concat.)</td><td align="left">None</td><td char="." align="char">6</td><td align="left">Bit plane</td><td align="left">Row</td></tr><tr><td align="left">1</td><td align="left">Bit plane (concat.)</td><td align="left">Col</td><td char="." align="char">7</td><td align="left">Bit plane</td><td align="left">Both</td></tr><tr><td align="left">2</td><td align="left">Bit plane (concat.)</td><td align="left">Row</td><td char="." align="char">8</td><td align="left">Row</td><td align="left">None</td></tr><tr><td align="left">3</td><td align="left">Bit plane (concat.)</td><td align="left">Both</td><td char="." align="char">9</td><td align="left">Row</td><td align="left">Col</td></tr><tr><td align="left">4</td><td align="left">Bit plane</td><td align="left">None</td><td char="." align="char">10</td><td align="left">Row</td><td align="left">Row</td></tr><tr><td align="left">5</td><td align="left">Bit plane</td><td align="left">Col</td><td char="." align="char">11</td><td align="left">Row</td><td align="left">Both</td></tr></tbody></table></table-wrap></p>
    <p id="Par37">
      <fig id="Fig3">
        <label>Fig. 3</label>
        <caption>
          <p>Average compression ratio (averaged over all chromosomes) achieved by each GVC configuration. The colors indicate the employed binarization: orange—bit plane binarization (concatenated), blue—bit plane binarization, green—row binarization. The patterns indicate the employed sorting: no pattern—no sorting, vertical lines—column sorting, horizontal lines—row sorting, both horizontal and vertical lines—sorting in both directions</p>
        </caption>
        <graphic xlink:href="12859_2023_5240_Fig3_HTML" id="MO10"/>
      </fig>
    </p>
    <p id="Par38">To evaluate the impact of both the binarization and sorting methods on the overall compression performance of GVC, we compute the average compression ratio, which is computed by dividing the original file size by the compressed file size. We compute the average over all chromosomes for each GVC configuration. Figure <xref rid="Fig3" ref-type="fig">3</xref> shows the corresponding results.</p>
    <p id="Par39">Configuration 11 (row binarization in combination with sorting of both columns and rows) outperforms all other configurations. Note that the average compression ratio is greatly improved by enabling sorting. Especially in the case of row binarization, enabling sorting both row- and column-wise yields the best results. Without concatenation, the bit plane transformation yields multiple bit planes that are sorted independently. This results in a larger overhead due to storing the corresponding sort indices.</p>
    <p id="Par40">When bit plane binarization is selected as the binarization scheme, sorting columns performs slightly better than sorting both columns and rows. This is because bit plane binarization creates a new bit plane even if only one row (corresponding to a single variant site) requires additional bits to correctly represent the allele value. In such case, the number of rows becomes greater than the number of columns; this renders the row sorting inefficient as the overhead induced by sorting indices overcomes the increase in compression. For the row binarization, the number of generated binary rows is less compared to the rows generated by the bit plane binarization. The resulting binary matrix will have a greater number of columns compared to the number of rows. Thus, sorting in column direction induces a greater overhead, resulting in a worse compression ratio.</p>
    <p id="Par41">We also evaluated the effect of the block size on the compression performance of GVC. We compressed the chromosome 22 file with all the configurations that are listed in Table <xref rid="Tab1" ref-type="table">1</xref> and five different block sizes: 512, 1024, 1536, 2048, and 2504. The result is shown in Fig. <xref rid="Fig4" ref-type="fig">4</xref>. As expected, increasing the block size increases the compression ratio. There are however two expections: for configuration IDs 2 and 10, increasing the block size beyond 2048 leads to a degradation in compression ratio. This is because in these cases the larger number of row sort indices generates an overhead that is not remedied by the gains achieved through the larger block size.<fig id="Fig4"><label>Fig. 4</label><caption><p>Compression ratio achieved by each GVC configuration with different block sizes. For all configurations with the sorting enabled, increasing the block size increases the compression ratio</p></caption><graphic xlink:href="12859_2023_5240_Fig4_HTML" id="MO11"/></fig></p>
    <p id="Par42">Finally, we compare GVC to its competitors GTRAC, GTC, and GTShark. All simulations were performed on a Linux platform with an Intel<inline-formula id="IEq50"><alternatives><tex-math id="M109">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$^\mathrm{(R)}$$\end{document}</tex-math><mml:math id="M110"><mml:msup><mml:mrow/><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq50.gif"/></alternatives></inline-formula> Core<inline-formula id="IEq51"><alternatives><tex-math id="M111">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$^\mathrm{(TM)}$$\end{document}</tex-math><mml:math id="M112"><mml:msup><mml:mrow/><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">TM</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq51.gif"/></alternatives></inline-formula> i9-9900K CPU, running at 5 GHz, and a solid state drive. For GTRAC, GTC, and GTShark, we used their default parameters; for GVC we used configuration 11 because it yields the best compression ratio. Figure <xref rid="Fig5" ref-type="fig">5</xref> shows the compressed size in MiB for each chromosome for GVC, GTRAC, and GTC.<fig id="Fig5"><label>Fig. 5</label><caption><p>Comparison of GVC to the state-of-the-art methods GTC [<xref ref-type="bibr" rid="CR4">4</xref>], GTRAC [<xref ref-type="bibr" rid="CR3">3</xref>], and GTShark [<xref ref-type="bibr" rid="CR5">5</xref>] with respect to compressed size</p></caption><graphic xlink:href="12859_2023_5240_Fig5_HTML" id="MO12"/></fig><fig id="Fig6"><label>Fig. 6</label><caption><p>Comparison of random access time between GTC [<xref ref-type="bibr" rid="CR4">4</xref>] and GVC with respect to the range size</p></caption><graphic xlink:href="12859_2023_5240_Fig6_HTML" id="MO13"/></fig><fig id="Fig7"><label>Fig. 7</label><caption><p>Comparison of random access time between GTC [<xref ref-type="bibr" rid="CR4">4</xref>] and GVC with respect to the number of samples</p></caption><graphic xlink:href="12859_2023_5240_Fig7_HTML" id="MO14"/></fig></p>
    <p id="Par43">With respect to random access, we only compare GVC to GTRAC and GTC, since GTShark does not provide random access functionality. In the case of GTRAC, we were unable to query, i.e., decode, the tested dataset. We refer to the random access time, or query time, as the total time it takes a method to access arbitrary elements in the compressed data. This is done by partially decoding and inverse-transforming the payloads given a query. We analyze the time complexity by varying the number of samples and the number of variants.</p>
    <p id="Par44">First, we compare the query time on all samples and different range sizes of the random access. We refer to this type of query as a range query. For a range query, we decode the genotypes of all samples in a region. Three values specify a region: a chromosome, a start position, and an end position. We refer to the difference between the start and end positions as the range size. Because variants do not occur at every locus, the number of variant sites (i.e., rows) is always smaller or equal than the range size. As presented in Fig. <xref rid="Fig6" ref-type="fig">6</xref>, GTC performs about 10x and 2x faster than GVC for smaller and larger range sizes, respectively.</p>
    <p id="Par45">Figure <xref rid="Fig7" ref-type="fig">7</xref> shows the result of the second experiment, where we queried variant sites within a range of <inline-formula id="IEq52"><alternatives><tex-math id="M113">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$1\textrm{e}{7}$$\end{document}</tex-math><mml:math id="M114"><mml:mrow><mml:mn>1</mml:mn><mml:mtext>e</mml:mtext><mml:mn>7</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq52.gif"/></alternatives></inline-formula> bp while varying the number of samples. GVC’s JBIG-based decoder decodes whole blocks even if the query requires one variant site or sample, but the inverse transformation is performed only on the queried variant sites or samples. This results in a higher run time overhead for smaller range sizes. For larger range sizes, the complexity of the entropy decoder and the transformation dominate the run time.<fig id="Fig8"><label>Fig. 8</label><caption><p>An example of a random access process on compressed genotypes where the number of alternate alleles is one and the blocks are transformed using bit plane binarization and sorted in row direction. A user needs the genotypes of all samples on chromosome 2 at loci 1000 through 1100, represented by “chr2:1000-1100”. First, GVC finds the blocks containing the required genotype information using a block lookup process. The bitstreams of the selected block, in this case the block with ID 1, are then decoded, yielding the sort indices <inline-formula id="IEq53"><alternatives><tex-math id="M115">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\tilde{a}}$$\end{document}</tex-math><mml:math id="M116"><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq53.gif"/></alternatives></inline-formula> and the binary matrix <inline-formula id="IEq54"><alternatives><tex-math id="M117">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {B}$$\end{document}</tex-math><mml:math id="M118"><mml:mi mathvariant="script">B</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq54.gif"/></alternatives></inline-formula>. Using the position information of each variant site, GVC selects certain rows or columns of the binary matrix <inline-formula id="IEq55"><alternatives><tex-math id="M119">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {B}$$\end{document}</tex-math><mml:math id="M120"><mml:mi mathvariant="script">B</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq55.gif"/></alternatives></inline-formula> and based on the sort index <inline-formula id="IEq56"><alternatives><tex-math id="M121">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\tilde{a}}$$\end{document}</tex-math><mml:math id="M122"><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo stretchy="false">~</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq56.gif"/></alternatives></inline-formula>. Finally, the selected rows and columns of the binary matrix <inline-formula id="IEq57"><alternatives><tex-math id="M123">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {B}$$\end{document}</tex-math><mml:math id="M124"><mml:mi mathvariant="script">B</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq57.gif"/></alternatives></inline-formula> are then inverse transformed to return the genotypes of all samples at loci 1000 through 1100</p></caption><graphic xlink:href="12859_2023_5240_Fig8_HTML" id="MO15"/></fig></p>
    <p id="Par46">To better explain this, suppose we have a genotype matrix <inline-formula id="IEq62"><alternatives><tex-math id="M125">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathcal {A}$$\end{document}</tex-math><mml:math id="M126"><mml:mi mathvariant="script">A</mml:mi></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq62.gif"/></alternatives></inline-formula> where the number of alternate alleles is one. The matrix is then transformed using bit plane binarization and sorted in the row direction. The bit plane binarization yields only one binary matrix because the largest value of the genotype matrix is one. A user requests genotype information for all samples on chromosome 2 at loci 1000–1100. GVC then performs the random access process shown in Fig. <xref rid="Fig8" ref-type="fig">8</xref>. An entire block needs to be entropy decoded (the one with block ID 1), although only a small range (chr2:1000–1100) was requested, and although it even only contains a single variant site (1038).</p>
    <p id="Par47">We believe that random access times below 0.5 s are not noticeable. Note that GVC is mostly written in Python (except for JBIG and the transformation steps which are written in C), whereas GTC is written entirely in C, introducing some overhead to GVC with regard to the run time. This is a subject for further improvements in the future.</p>
    <p id="Par48">Finally, to summarize the results, Table <xref rid="Tab2" ref-type="table">2</xref> shows the compressed sizes and random access times. The absolute compressed size is given for each method as the sum of the results obtained for each chromosome, as shown in Fig. <xref rid="Fig5" ref-type="fig">5</xref>. To evaluate the random access capability, we calculated the area under the curve shown in Fig. <xref rid="Fig7" ref-type="fig">7</xref>. In summary, GVC offers a very good trade-off between GTShark and GTC: GVC achieves slightly worse compression results than GTShark while providing random access functionality. GVC outperforms GTC in terms of compression, but gives similar random access times for range-based access and slightly worse for sample-based access.<table-wrap id="Tab2"><label>Table 2</label><caption><p>Summary of the state-of-the-art comparison with respect to both compressed size and random access time</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Method</th><th align="left">Compressed size [MiB]</th><th align="left">Random access area [Mbp s]</th></tr></thead><tbody><tr><td align="left">GVC</td><td char="." align="char">897</td><td align="left">311</td></tr><tr><td align="left">GTC</td><td char="." align="char">1136</td><td align="left">256</td></tr><tr><td align="left">GTRAC</td><td char="." align="char">2986</td><td align="left">N/A<inline-formula id="IEq58"><alternatives><tex-math id="M127">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${}^\dag$$\end{document}</tex-math><mml:math id="M128"><mml:msup><mml:mrow/><mml:mo>†</mml:mo></mml:msup></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq58.gif"/></alternatives></inline-formula></td></tr><tr><td align="left">GTShark</td><td char="." align="char">587</td><td align="left">N/A<inline-formula id="IEq59"><alternatives><tex-math id="M129">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${}^*$$\end{document}</tex-math><mml:math id="M130"><mml:msup><mml:mrow/><mml:mo>∗</mml:mo></mml:msup></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq59.gif"/></alternatives></inline-formula></td></tr></tbody></table><table-wrap-foot><p><inline-formula id="IEq60"><alternatives><tex-math id="M131">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${}^*$$\end{document}</tex-math><mml:math id="M132"><mml:msup><mml:mrow/><mml:mo>∗</mml:mo></mml:msup></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq60.gif"/></alternatives></inline-formula> Random access is not implemented. <inline-formula id="IEq61"><alternatives><tex-math id="M133">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${}^\dag$$\end{document}</tex-math><mml:math id="M134"><mml:msup><mml:mrow/><mml:mo>†</mml:mo></mml:msup></mml:math><inline-graphic xlink:href="12859_2023_5240_Article_IEq61.gif"/></alternatives></inline-formula> Similar to what the authors of GTC report, we were not able to evaluate GTRAC on the present dataset</p></table-wrap-foot></table-wrap></p>
  </sec>
  <sec id="Sec8">
    <title>Conclusion</title>
    <p id="Par49">We present a novel approach for compressing gene sequence variations: the Genomic Variant Codec (GVC). Better compression is achieved by using techniques such as joint row- and column-wise sorting of blocks of variations and by using the existing image compression standard JBIG for efficient entropy coding. At the same time, GVC allows non-sequential data retrieval by splitting the data into blocks. To find row and column orders that are beneficial in terms of entropy coding, we solved a problem analogous to the traveling salesman problem by using the nearest neighbor algorithm. Other solvers such as the Lin-Kernighan heuristic [<xref ref-type="bibr" rid="CR12">12</xref>] could be employed to achieve a potentially better compression at the expense of encoding time.</p>
    <p id="Par50">GVC meets the state of the art in terms of compression ratio: our results show that GVC reduces the genotype information size from 758 GiB down to 897 MiB on the publicly available 1000 Genomes Project (phase 3) data, outperforming its competitor GTC, which is only able to reduce the raw data size to 1136 MiB. Note, however, that GTC offers slightly faster random access. With respect to GTShark, GVC does not match its compression performance, but provides, in contrast, random access capability that makes GVC applicable in real-world scenarios. In summary, GVC provides a new solution in the compression-feature space by offering excellent compression combined with random access functionality. GVC could be adapted for other integral sample-level annotations such as the per-allele read depth, alternate allele counts, or quality metrics.</p>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>SNP</term>
        <def>
          <p id="Par4">Single-nucleotide polymorphism</p>
        </def>
      </def-item>
      <def-item>
        <term>indels</term>
        <def>
          <p id="Par5">Insertions and deletions</p>
        </def>
      </def-item>
      <def-item>
        <term>VCF</term>
        <def>
          <p id="Par6">Variant call format</p>
        </def>
      </def-item>
      <def-item>
        <term>GTRAC</term>
        <def>
          <p id="Par7">GenoType Random Access Compressor</p>
        </def>
      </def-item>
      <def-item>
        <term>GTC</term>
        <def>
          <p id="Par8">GenoType Compressor</p>
        </def>
      </def-item>
      <def-item>
        <term>GVC</term>
        <def>
          <p id="Par9">Genomic variant codec</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn id="Fn1">
      <label>1</label>
      <p id="Par54">Please note that we did not favor JBIG’s successor, JBIG2 (ISO/IEC 14492 [<xref ref-type="bibr" rid="CR13">13</xref>]), since it does not noticeably increase the performance of lossless compression for this kind of data.</p>
    </fn>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>Not applicable.</p>
  </ack>
  <notes notes-type="author-contribution">
    <title>Author contributions</title>
    <p>YGA: developed the bit plane binarization, introduced JBIG as the entropy codec. JV: initiated the study, proposed the row-wise sorting. CR and VT: developed the row binarization. JRO and JO: supervised the project. All authors read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>Open Access funding enabled and organized by Projekt DEAL. This work is supported by Leibniz University Hannover, L3S Research Center, and RWTH Aachen University.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>The 1000 genome project dataset is available at <ext-link ext-link-type="uri" xlink:href="http://www.internationalgenome.org/data/">www.internationalgenome.org/data/</ext-link> or <ext-link ext-link-type="uri" xlink:href="http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/">http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/</ext-link>.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Code availability</title>
    <p>GVC is open source and available at <ext-link ext-link-type="uri" xlink:href="https://github.com/sXperfect/gvc/">https://github.com/sXperfect/gvc/</ext-link>.</p>
  </notes>
  <notes>
    <title>Declarations</title>
    <notes id="FPar2">
      <title>Ethics approval and consent to participate</title>
      <p id="Par51">Not applicable.</p>
    </notes>
    <notes id="FPar4">
      <title>Consent for publication</title>
      <p id="Par52">Not applicable.</p>
    </notes>
    <notes id="FPar3" notes-type="COI-statement">
      <title>Competing interests</title>
      <p id="Par53">JV, CR, VT, YGA, and JO have filed the patent application DE102021100199A1, which covers parts of the methods presented in the manuscript.</p>
    </notes>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stephens</surname>
            <given-names>ZD</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>SY</given-names>
          </name>
          <name>
            <surname>Faghri</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Campbell</surname>
            <given-names>RH</given-names>
          </name>
          <name>
            <surname>Zhai</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Efron</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Iyer</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Schatz</surname>
            <given-names>MC</given-names>
          </name>
          <name>
            <surname>Sinha</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Robinson</surname>
            <given-names>GE</given-names>
          </name>
        </person-group>
        <article-title>Big data: astronomical or genomical?</article-title>
        <source>PLoS Biol</source>
        <year>2015</year>
        <volume>13</volume>
        <issue>7</issue>
        <fpage>1002195</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pbio.1002195</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Danecek</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Auton</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Abecasis</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Albers</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Banks</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>DePristo</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Handsaker</surname>
            <given-names>RE</given-names>
          </name>
          <name>
            <surname>Lunter</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Marth</surname>
            <given-names>GT</given-names>
          </name>
          <name>
            <surname>Sherry</surname>
            <given-names>ST</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The variant call format and VCFtools</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>15</issue>
        <fpage>2156</fpage>
        <lpage>2158</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr330</pub-id>
        <?supplied-pmid 21653522?>
        <pub-id pub-id-type="pmid">21653522</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tatwawadi</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Hernaez</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Ochoa</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Weissman</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>GTRAC: fast retrieval from compressed collections of genomic variants</article-title>
        <source>Bioinformatics</source>
        <year>2016</year>
        <volume>32</volume>
        <issue>17</issue>
        <fpage>479</fpage>
        <lpage>486</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btw437</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Danek</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>GTC: how to maintain huge genotype collections in a compressed form</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>34</volume>
        <issue>11</issue>
        <fpage>1834</fpage>
        <lpage>1840</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty023</pub-id>
        <?supplied-pmid 29351600?>
        <pub-id pub-id-type="pmid">29351600</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Danek</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Gtshark: genotype compression in large projects</article-title>
        <source>Bioinformatics</source>
        <year>2019</year>
        <volume>35</volume>
        <issue>22</issue>
        <fpage>4791</fpage>
        <lpage>4793</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btz508</pub-id>
        <?supplied-pmid 31225861?>
        <pub-id pub-id-type="pmid">31225861</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ziv</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Lempel</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>A universal algorithm for sequential data compression</article-title>
        <source>IEEE Trans Inf Theory</source>
        <year>1977</year>
        <volume>23</volume>
        <issue>3</issue>
        <fpage>337</fpage>
        <lpage>343</lpage>
        <pub-id pub-id-type="doi">10.1109/TIT.1977.1055714</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Efficient haplotype matching and storage using the positional burrows-wheeler transform (pbwt)</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <issue>9</issue>
        <fpage>1266</fpage>
        <lpage>1272</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu014</pub-id>
        <?supplied-pmid 24413527?>
        <pub-id pub-id-type="pmid">24413527</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Walczyszyn</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Debudaj-Grabysz</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Comsa: compression of protein multiple sequence alignment files</article-title>
        <source>Bioinformatics</source>
        <year>2019</year>
        <volume>35</volume>
        <issue>2</issue>
        <fpage>227</fpage>
        <lpage>234</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty619</pub-id>
        <?supplied-pmid 30010777?>
        <pub-id pub-id-type="pmid">30010777</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <mixed-citation publication-type="other">Martin GNN. Range encoding: an algorithm for removing redundancy from a digitised message. In: Proceedings of institution of electronic and radio engineers international conference on video and data recording, vol. 2. 1979.</mixed-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <mixed-citation publication-type="other">Information technology-Coded representation of picture and audio information-Progressive bi-level image compression. Standard. Geneva, CH: International Organization for Standardization; 1993.</mixed-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hamming</surname>
            <given-names>RW</given-names>
          </name>
        </person-group>
        <article-title>Error detecting and error correcting codes</article-title>
        <source>Bell Syst Tech J</source>
        <year>1950</year>
        <volume>29</volume>
        <issue>2</issue>
        <fpage>147</fpage>
        <lpage>160</lpage>
        <pub-id pub-id-type="doi">10.1002/j.1538-7305.1950.tb00463.x</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Helsgaun</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>An effective implementation of the Lin-Kernighan traveling salesman heuristic</article-title>
        <source>Eur J Oper Res</source>
        <year>2000</year>
        <volume>126</volume>
        <issue>1</issue>
        <fpage>106</fpage>
        <lpage>130</lpage>
        <pub-id pub-id-type="doi">10.1016/S0377-2217(99)00284-2</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <mixed-citation publication-type="other">Information technology-Lossy/lossless coding of bi-level images. Standard. Geneva, CH: International Organization for Standardization; 2019.</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <collab>The 1000 Genomes Project Consortium</collab>
        </person-group>
        <article-title>A map of human genome variation from population scale sequencing</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>467</volume>
        <issue>7319</issue>
        <fpage>1061</fpage>
        <lpage>1073</lpage>
        <pub-id pub-id-type="doi">10.1038/nature09534</pub-id>
        <pub-id pub-id-type="pmid">20981092</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
