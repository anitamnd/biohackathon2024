<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Nat Commun</journal-id>
    <journal-id journal-id-type="iso-abbrev">Nat Commun</journal-id>
    <journal-title-group>
      <journal-title>Nature Communications</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2041-1723</issn>
    <publisher>
      <publisher-name>Nature Publishing Group UK</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7728760</article-id>
    <article-id pub-id-type="publisher-id">19777</article-id>
    <article-id pub-id-type="doi">10.1038/s41467-020-19777-8</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Scalable multiple whole-genome alignment and locally collinear block construction with SibeliaZ</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-0807-347X</contrib-id>
        <name>
          <surname>Minkin</surname>
          <given-names>Ilia</given-names>
        </name>
        <address>
          <email>ivminkin@gmail.com</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-3143-594X</contrib-id>
        <name>
          <surname>Medvedev</surname>
          <given-names>Paul</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
        <xref ref-type="aff" rid="Aff2">2</xref>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="GRID">grid.29857.31</institution-id><institution-id institution-id-type="ISNI">0000 0001 2097 4281</institution-id><institution>Department of Computer Science and Engineering, The Pennsylvania State University, </institution></institution-wrap>506 Wartik Lab University Park, University Park, PA 16802 USA </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="GRID">grid.29857.31</institution-id><institution-id institution-id-type="ISNI">0000 0001 2097 4281</institution-id><institution>Department of Biochemistry and Molecular Biology, The Pennsylvania State University, </institution></institution-wrap>506 Wartik Lab University Park, University Park, PA 16802 USA </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="GRID">grid.29857.31</institution-id><institution-id institution-id-type="ISNI">0000 0001 2097 4281</institution-id><institution>Center for Computational Biology and Bioinformatics, The Pennsylvania State University, </institution></institution-wrap>506 Wartik Lab University Park, University Park, PA 16802 USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>10</day>
      <month>12</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>10</day>
      <month>12</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>11</volume>
    <elocation-id>6327</elocation-id>
    <history>
      <date date-type="received">
        <day>28</day>
        <month>9</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>29</day>
        <month>10</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The images or other third party material in this article are included in the article’s Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the article’s Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this license, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p id="Par1">Multiple whole-genome alignment is a challenging problem in bioinformatics. Despite many successes, current methods are not able to keep up with the growing number, length, and complexity of assembled genomes, especially when computational resources are limited. Approaches based on compacted de Bruijn graphs to identify and extend anchors into locally collinear blocks have potential for scalability, but current methods do not scale to mammalian genomes. We present an algorithm, SibeliaZ-LCB, for identifying collinear blocks in closely related genomes based on analysis of the de Bruijn graph. We further incorporate this into a multiple whole-genome alignment pipeline called SibeliaZ. SibeliaZ shows run-time improvements over other methods while maintaining accuracy. On sixteen recently-assembled strains of mice, SibeliaZ runs in under 16 hours on a single machine, while other tools did not run to completion for eight mice within a week. SibeliaZ makes a significant step towards improving scalability of multiple whole-genome alignment and collinear block reconstruction algorithms on a single machine.</p>
    </abstract>
    <abstract id="Abs2" abstract-type="web-summary">
      <p id="Par2">Multiple whole-genome alignment is a challenging problem in bioinformatics, especially when computational resources are limited. Here the authors present SibeliaZ, an algorithm and software based on analysis of de Bruijn graphs, which provides improved computational efficiency and scalability.</p>
    </abstract>
    <kwd-group kwd-group-type="npg-subject">
      <title>Subject terms</title>
      <kwd>Comparative genomics</kwd>
      <kwd>Computational biology and bioinformatics</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">https://doi.org/10.13039/100000001</institution-id>
            <institution>National Science Foundation (NSF)</institution>
          </institution-wrap>
        </funding-source>
        <award-id>CCF-1439057</award-id>
        <award-id>IIS-1453527</award-id>
        <award-id>DBI-1356529</award-id>
        <award-id>IIS-1421908</award-id>
        <principal-award-recipient>
          <name>
            <surname>Medvedev</surname>
            <given-names>Paul</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">https://doi.org/10.13039/100000057</institution-id>
            <institution>U.S. Department of Health &amp; Human Services | NIH | National Institute of General Medical Sciences (NIGMS)</institution>
          </institution-wrap>
        </funding-source>
        <award-id>R01GM130691</award-id>
        <principal-award-recipient>
          <name>
            <surname>Medvedev</surname>
            <given-names>Paul</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1" sec-type="introduction">
    <title>Introduction</title>
    <p id="Par3">Multiple whole-genome alignments are the problem of identifying all the high-quality multiple local alignments within a collection of assembled genome sequences. It is a fundamental problem in bioinformatics and forms the starting point for most comparative genomics studies, such as rearrangement analysis, phylogeny reconstruction, and the investigation of evolutionary processes. Unfortunately, the presence of high-copy repeats and the sheer size of the input make multiple whole-genome alignment extremely difficult. While current approaches have been successfully applied in many studies, they are not able to keep up with the growing number and size of assembled genomes<sup><xref ref-type="bibr" rid="CR1">1</xref></sup>. The multiple whole-genome alignment problem is also closely related to the synteny reconstruction problem and to the questions of how to best represent pan-genomes.</p>
    <p id="Par4">There are two common strategies to tackle the whole-genome alignment problem<sup><xref ref-type="bibr" rid="CR2">2</xref></sup>. The first one is based on finding pairwise local alignments<sup><xref ref-type="bibr" rid="CR3">3</xref>–<xref ref-type="bibr" rid="CR7">7</xref></sup> and then extending them into multiple local alignments<sup><xref ref-type="bibr" rid="CR8">8</xref>–<xref ref-type="bibr" rid="CR11">11</xref></sup>. While this strategy is known for its high accuracy, a competitive assessment of multiple whole-genome alignment methods<sup><xref ref-type="bibr" rid="CR1">1</xref></sup> highlighted several limitations. First, many algorithms either do not handle repeats by design or scale poorly in their presence, since the number of pairwise local alignments grows quadratically as a function of a repeat’s copy number. In addition, many algorithms use a repeat database to mask high-frequency repeats. However, these databases are usually incomplete and even a small amount of unmasked repeats may severely degrade alignment performance. Second, the number of pairwise alignments is quadratic in the number of genomes, and only a few existing approaches could handle more than ten fruit fly genomes<sup><xref ref-type="bibr" rid="CR1">1</xref></sup>. Therefore, these approaches are ill-suited for large numbers of long and complex genomes, such as mammalian genomes in general and the recently assembled 16 strains of mice<sup><xref ref-type="bibr" rid="CR12">12</xref></sup> in particular.</p>
    <p id="Par5">Alternatively, anchor-based strategies can be applied to decompose genomes into locally collinear blocks<sup><xref ref-type="bibr" rid="CR13">13</xref></sup>. These are blocks that are free from nonlinear rearrangements, such as inversions or transpositions. Once such blocks are identified, they can independently be global aligned<sup><xref ref-type="bibr" rid="CR13">13</xref>–<xref ref-type="bibr" rid="CR17">17</xref></sup>. The problem of constructing blocks from anchors is known as the chaining problem which had been extensively studied in the past<sup><xref ref-type="bibr" rid="CR18">18</xref>–<xref ref-type="bibr" rid="CR20">20</xref></sup>. All of the methods applicable to datasets consisting of multiple genomes are heuristic since the exact algorithms depend exponentially on the number of genomes. Such strategies are generally better at scaling to handle repeats and multiple genomes since they do not rely on the computationally expensive pairwise alignment.</p>
    <p id="Par6">A promising strategy to find collinear blocks is based on the compacted de Bruijn graph<sup><xref ref-type="bibr" rid="CR21">21</xref>–<xref ref-type="bibr" rid="CR23">23</xref></sup> widely used in genome assembly. Though these approaches do not work well for divergent genomes, they remain fairly accurate for closely related genomes. For example, Sibelia<sup><xref ref-type="bibr" rid="CR23">23</xref></sup> can handle repeats and works for many bacterial genomes; unfortunately, it does not scale to longer genomes. However, the last three years has seen a breakthrough in the efficiency of de Bruijn graph construction algorithms<sup><xref ref-type="bibr" rid="CR24">24</xref>–<xref ref-type="bibr" rid="CR27">27</xref></sup>. The latest methods can construct the graph for tens of mammalian genomes in minutes rather than weeks. We therefore believe the de Bruijn graph approach holds the most potential for enabling scalable multiple whole-genome alignments of closely related genomes.</p>
    <p id="Par7">In this paper, we describe an algorithm SibeliaZ-LCB for identifying collinear blocks in closely related genomes. SibeliaZ-LCB is suitable for detecting homologous sequences that have an evolutionary distance to the most recent common ancestor (MRCA) of at most 0.09 substitutions per site. SibeliaZ-LCB is based on the analysis of the compacted de Bruijn graph and uses a graph model of collinear blocks similar to the "most frequent paths” introduced by<sup><xref ref-type="bibr" rid="CR28">28</xref></sup>. This allows it to maintain a simple, static, data structure, which scales easily and allows simple parallelization. Thus, SibeliaZ-LCB overcomes a bottleneck of previous state-of-the-art de Bruijn graph-based approaches<sup><xref ref-type="bibr" rid="CR17">17</xref>,<xref ref-type="bibr" rid="CR22">22</xref></sup>, which relied on a dynamic data structure which was expensive to update. Further, we extend SibeliaZ-LCB into a multiple whole-genome aligners called SibeliaZ. SibeliaZ works by first constructing the compacted de Bruijn graph using our previously published TwoPaCo tool<sup><xref ref-type="bibr" rid="CR27">27</xref></sup>, then finding locally collinear blocks using SibeliaZ-LCB, and finally, running a multiple-sequence aligner spoa<sup><xref ref-type="bibr" rid="CR29">29</xref></sup> on each of the foundation blocks. To demonstrate the scalability and accuracy of our method, we compute the multiple whole-genome alignment for a collection of recently assembled strains of mice. We also test how our method works under different conditions, including various levels of divergence between genomes and different parameter settings. Our software is freely available at <ext-link ext-link-type="uri" xlink:href="https://github.com/medvedevgroup/SibeliaZ/">https://github.com/medvedevgroup/SibeliaZ/</ext-link>.</p>
  </sec>
  <sec id="Sec2" sec-type="results">
    <title>Results</title>
    <sec id="Sec3">
      <title>Algorithm overview</title>
      <p id="Par8">As described in the introduction, the major algorithmic innovation of this paper is the SibeliaZ-LCB algorithm. SibeliaZ-LCB takes as input a de Bruijn graph built on a collection of assembled genomes. An assembled genome is itself a set of contig sequences. SibeliaZ-LCB identifies and outputs all nonoverlapping blocks of homologous subsequences of the input genomes. A block can be composed of two or more sequences from one or more genomes. In this subsection, we will give a high level overview of SibeliaZ-LCB, leaving the more formal and detailed version for the “Methods”.</p>
      <p id="Par9">SibeliaZ-LCB relies heavily on the de Bruijn graph of the genomes. In this graph, the vertices correspond to the <italic>k</italic>-mers (substrings of fixed length <italic>k</italic>) of the input. A <italic>k</italic>-mer that appears multiple times in the input is represented using just one node. Then, <italic>k</italic>-mers that appear consecutively in some input sequence are connected by an edge from the left one to the right one (see Fig. <xref rid="Fig1" ref-type="fig">1</xref>a for an example). This way, each genome corresponds to a path in the graph that hops from <italic>k</italic>-mer to <italic>k</italic>-mer using the edges.<fig id="Fig1"><label>Fig. 1</label><caption><title>The de Bruijn graph and an example of a collinear block.</title><p><bold>a</bold> The graph built from strings “GCACGTCC” and “GCACTTCC”, with <italic>k</italic> = 2. The two strings are reflected by the blue and magenta walks, respectively. This is an example of a collinear block from two walks. There are four bubbles. The bubble formed by vertices “AC” and “TC” describes a substitution within the block, while three other bubbles are formed by parallel edges. The blue and magenta walk form a chain of four consecutive bubbles. <bold>b</bold> An example of a more complex block, where we have added a third sequence “CACGTTCC” (turquoise) to the input. We can no longer describe the block as a chain of bubbles, as they overlap to form tangled structures. Instead, we consider the path in the graph (dashed black) that shares many vertices with the three collinear walks. This carrying path shares many vertices with the three extant walks, and each walk forms its own chain with it. The task of finding good collinear blocks can then be framed as finding carrying paths that form good chains with the genomic walks.</p></caption><graphic xlink:href="41467_2020_19777_Fig1_HTML" id="d30e439"/></fig></p>
      <p id="Par10">In this graph, two homologous sequences form what is called a chain: an interleaving sequence of parallel edges, which correspond to identical sequences, and “bubbles”, which correspond to small variations like single nucleotide variants or indels. However, the concept of a chain is difficult to extend to more than two homologous sequences because the tangled pattern in the graph is difficult to precisely define (see Fig. <xref rid="Fig1" ref-type="fig">1</xref>b for an example).</p>
      <p id="Par11">To address this challenge, we introduce the idea that each block has a “carrying path” in the de Bruijn graph that holds the block together. The basic idea is that the homologous sequences forming the block have a lot of shared <italic>k</italic>-mers and their corresponding genomic paths go through nearly the same vertices. A carrying path is then a path that goes through the most frequently visited vertices, loosely similar to the notion of a consensus sequence from alignment. Each genomic path from the block then forms a chain with this carrying path (see Fig. <xref rid="Fig1" ref-type="fig">1</xref>b for an example).</p>
      <p id="Par12">We do not know the carrying paths in advance but we can use them as a guiding mechanism to find blocks. We start with an arbitrary edge <italic>e</italic> in the graph and all other genomic paths that form bubbles with <italic>e</italic>. We make <italic>e</italic> the starting point of a carrying path and use it along with the other genomic paths to initiate the collection of sequences making up the block corresponding to this carrying path. To extend the carrying path, we look at the edges extending the genomic paths in the current block and take the most common one. The data structures maintaining the genomic paths in the block and the carrying path are then updated and the extension procedure repeats. Figure <xref rid="Fig2" ref-type="fig">2</xref> shows an example of running this algorithm.<fig id="Fig2"><label>Fig. 2</label><caption><title>An example of running Algorithm Find-collinear-blocks (Box <xref rid="Sec15" ref-type="sec">1</xref>) on the graph from Fig. <xref rid="Fig1" ref-type="fig">1</xref>b, starting from edge GC  →  CC as the seed.</title><p>Each subfigure shows the content of the collinear block <italic>P</italic> and the carrying path. The collinear walks are solid, the carrying path is dashed, and the rest of the graph is dotted. Subfigure <bold>a</bold> shows the state of these variables after the initialization; subfigures <bold>b</bold>–<bold>d</bold> show the state after the completion of each phase.</p></caption><graphic xlink:href="41467_2020_19777_Fig2_HTML" id="d30e495"/></fig></p>
      <p id="Par13">We continue this process until the scoring function that describes how well a carrying path holds the block together falls below zero. At that point, we consider the possibility that we may have overextended the block and should have instead ended it earlier. To do this, we look at all the intermediate blocks we had created during the extension process and output the one that has the highest score. Once a block is an output, we output all its constituent edges as used so that they are not chosen as part of a future block.</p>
      <p id="Par14">In this way, SibeliaZ-LCB finds a single block. Afterwards, we try to find another block by starting from another arbitrary edge. This process continues until all the edges in the graph are either used or had been tried as potential starters for a carrying path.</p>
    </sec>
    <sec id="Sec4">
      <title>Datasets, tools, and evaluation metrics</title>
      <p id="Par15">Evaluation of multiple whole-genome aligners is a challenging problem in its own right and we, therefore, chose to use the practices outlined in the Alignathon<sup><xref ref-type="bibr" rid="CR1">1</xref></sup> competition as a starting point. They present several approaches to assess the quality of a multiple whole-genome alignments. Ideally, it is best to compare an alignment against a manually curated gold standard; unfortunately, such a gold standard does not exist. We, therefore, chose to focus our evaluation on real data.</p>
      <p id="Par16">We evaluated the ability of SibeliaZ to align real genomes by running it on several datasets consisting of a varying numbers of mice genomes. We retrieved 16 mice genomes available at GenBank<sup><xref ref-type="bibr" rid="CR30">30</xref></sup> and labeled as having a “chromosome” level of assembly. They consist of the mouse reference genome and 15 different strains assembled as part of a recent study<sup><xref ref-type="bibr" rid="CR12">12</xref></sup> (Supplementary Table <xref rid="MOESM1" ref-type="media">1</xref>). The genomes vary in size from 2.6 to 2.8 Gbp and the number of scaffolds (between 2977 and 7154, except for the reference, which has 377). Their GenBank accession numbers are listed in Table <xref rid="Tab1" ref-type="table">1</xref>. We constructed four datasets of increasing size to test the scalability of the pipelines with respect to the number of input genomes. The datasets contain genomes 1–2, 1–4, 1–8, and 1–16 from Supplementary Table <xref rid="MOESM1" ref-type="media">1</xref>, with genome 1 being the reference genome.<table-wrap id="Tab1"><label>Table 1</label><caption><p>Accession numbers of the assembled mice genomes available at GenBank.</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Strain</th><th>Accession number</th></tr></thead><tbody><tr><td>C57BL/6J</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_000001635.8">GCA_000001635.8</ext-link></td></tr><tr><td>129S1/SvImJ</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624185.1">GCA_001624185.1</ext-link></td></tr><tr><td>A/J</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624215.1">GCA_001624215.1</ext-link></td></tr><tr><td>AKR/J</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624295.1">GCA_001624295.1</ext-link></td></tr><tr><td>CAST/EiJ</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624445.1">GCA_001624445.1</ext-link></td></tr><tr><td>CBA/J</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624475.1">GCA_001624475.1</ext-link></td></tr><tr><td>DBA/2J</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624505.1">GCA_001624505.1</ext-link></td></tr><tr><td>FVB/NJ</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624535.1">GCA_001624535.1</ext-link></td></tr><tr><td>NOD/ShiLtJ</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624675.1">GCA_001624675.1</ext-link></td></tr><tr><td>NZO/HiLtJ</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624745.1">GCA_001624745.1</ext-link></td></tr><tr><td>PWK/PhJ</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624775.1">GCA_001624775.1</ext-link></td></tr><tr><td>WSB/EiJ</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001624835.1">GCA_001624835.1</ext-link></td></tr><tr><td>BALB/cJ</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001632525.1">GCA_001632525.1</ext-link></td></tr><tr><td>C57BL/6NJ</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001632555.1">GCA_001632555.1</ext-link></td></tr><tr><td>C3H/HeJ</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001632575.1">GCA_001632575.1</ext-link></td></tr><tr><td>LP/J</td><td><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/assembly/GCA_001632615.1">GCA_001632615.1</ext-link></td></tr></tbody></table></table-wrap></p>
      <p id="Par17">To measure accuracy, we used several ground-truth alignments (to be described) and employed the metrics of precision and recall used in the Alignathon and implemented by the mafTools package<sup><xref ref-type="bibr" rid="CR1">1</xref></sup>. For these metrics, alignment is viewed as an equivalence relation. We say that two positions in the input genomes are equivalent if they originate from the same position in the genome of their recent common ancestor. We denote by <italic>H</italic> the set of all equivalent position pairs, participating in the “true” alignment. Let <italic>A</italic> denote the relation produced by an alignment algorithm. The accuracy of the alignment is then given by recall(<italic>A</italic>) = 1 − ∣<italic>H</italic>⧹<italic>A</italic>∣/∣<italic>H</italic>∣ and precision(<italic>A</italic>) = 1 − ∣<italic>A</italic>⧹<italic>H</italic>∣/∣<italic>A</italic>∣, where ⧹ denotes set difference.</p>
      <p id="Par18">To evaluate recall, we compared our results against annotations of protein-coding genes. We retrieved all pairs of homologous protein-coding gene sequences from Ensembl and then computed pairwise global alignments between them using LAGAN<sup><xref ref-type="bibr" rid="CR31">31</xref></sup>. The alignment contains both orthologous and paralogous genes, though most of the paralogous pairs come from the well-annotated mouse reference genome. We removed any pairs of paralogous genes with overlapping coordinates, as these were likely mis-annotations, as confirmed by Ensembl helpdesk<sup><xref ref-type="bibr" rid="CR32">32</xref></sup>. We made these filtered alignments as well as the alignments produced by SibeliaZ available for public download from our GitHub repository (see Section “Data availability” for the links).</p>
      <p id="Par19">We define the nucleotide identity of an alignment as the number of matched nucleotides divided by the length of an alignment, including gaps. The distribution of nucleotide identities, as well as the coverage of the annotation, is shown in Supplementary Fig. <xref rid="MOESM1" ref-type="media">1</xref>. In our analysis, we binned pairs of genes according to their nucleotide identity.</p>
      <p id="Par20">Since protein-coding genes only compromise a small portion of the genome, we also computed all-against-all pairwise local alignments between chromosomes 1 of genomes 1–2 and 1–4 using LASTZ<sup><xref ref-type="bibr" rid="CR6">6</xref></sup>, a reliable local aligner known for its accuracy. We only computed alignments between chromosomes of different genomes, i.e., did not include self-alignments, which excludes duplications such as paralogous genes from the alignment. We used default settings of LASTZ except that we made it output alignments of nucleotide identity at least 90%. We then evaluated the recall and precision of our alignments but restricted our alignments to the sequences of chromosome 1. We then treated the LASTZ alignments as the ground truth. The LASTZ alignments are available for download from our repository’s supplemental data section. Note that because the alignment is represented as a set of positions pairs, it is possible to evaluate a multiple whole-genome alignments using pairwise local alignments.</p>
      <p id="Par21">To measure precision, we use the LASTZ alignments on chromosome 1. However, it is computationally prohibitive to compute such alignments with LASTZ for the whole genome. We therefore also use an indirect way to assess precision for the whole genome. For each column in the alignment, we calculate the average number of nucleotide differences<sup><xref ref-type="bibr" rid="CR33">33</xref></sup>. In an alignment of highly similar genomes that has high precision, we expect these numbers to below (close to 0) for most of the columns in the alignment. Otherwise, it would suggest the presence of unreliable poorly aligned blocks in the alignment. Formally, given a column <italic>c</italic> of a multiple whole-genome alignments with <italic>c</italic><sub><italic>i</italic></sub> being its <italic>i</italic>th element, average number of nucleotide differences is given by <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\pi (c)={\sum }_{1\le i\le | c| }{\sum }_{i\,{&lt;}\,j\le | c| }I[{c}_{i}{\,}\ne{\,} {c}_{j}]/\Big(\begin{array}{l}| c| \\ 2\end{array}\Big)$$\end{document}</tex-math><mml:math id="M2"><mml:mi>π</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mo>∣</mml:mo><mml:mi>c</mml:mi><mml:mo>∣</mml:mo></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mspace width="0.25em"/><mml:mo>&lt;</mml:mo><mml:mspace width="0.25em"/><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mo>∣</mml:mo><mml:mi>c</mml:mi><mml:mo>∣</mml:mo></mml:mrow></mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mo>≠</mml:mo><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mstyle mathsize="1.61em"><mml:mfenced open="("><mml:mrow/></mml:mfenced></mml:mstyle><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mo>∣</mml:mo><mml:mi>c</mml:mi><mml:mo>∣</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mstyle mathsize="1.61em"><mml:mfenced open=")"><mml:mrow/></mml:mfenced></mml:mstyle></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq1.gif"/></alternatives></inline-formula>. The variable <italic>I</italic>[<italic>c</italic><sub><italic>i</italic></sub> ≠ <italic>c</italic><sub><italic>j</italic></sub>] is equal to 1 if both <italic>c</italic><sub><italic>i</italic></sub> and <italic>c</italic><sub><italic>j</italic></sub> are different valid DNA characters and 0 otherwise; ∣<italic>c</italic>∣ is the number of rows in column <italic>c</italic>.</p>
      <p id="Par22">We benchmarked the performance of SibeliaZ against Progressive Cactus<sup><xref ref-type="bibr" rid="CR34">34</xref></sup>, an aligner based on analysis of the Cactus graphs<sup><xref ref-type="bibr" rid="CR35">35</xref></sup> built from pairwise alignments. We also attempted to run Sibelia<sup><xref ref-type="bibr" rid="CR23">23</xref></sup> (a predecessor of SibeliaZ) and MultiZ + TBA<sup><xref ref-type="bibr" rid="CR8">8</xref></sup>, but these could run to completion within a week on even a single mouse genome. Other multiple aligners<sup><xref ref-type="bibr" rid="CR9">9</xref>,<xref ref-type="bibr" rid="CR10">10</xref>,<xref ref-type="bibr" rid="CR16">16</xref></sup> benchmarked in the Alignathon could not handle a dataset of 20 flies and hence are unlikely to scale to a mammalian dataset. We also chose to not run Mercator<sup><xref ref-type="bibr" rid="CR14">14</xref></sup> since it requires a set of gene exons as input and hence solves a different problem: in this paper we focus on computing the whole-genome alignment directly from the nucleotide sequences without using external information. Further details about parameters, versions, and hardware are in Supplementary Note <xref rid="MOESM1" ref-type="media">1</xref> and Supplementary Table <xref rid="MOESM1" ref-type="media">4</xref>.</p>
    </sec>
    <sec id="Sec5">
      <title>Running time and memory</title>
      <p id="Par23">The running times of SibeliaZ and Cactus are shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref> (Supplementary Table <xref rid="MOESM1" ref-type="media">2</xref> contains the raw values). On the dataset consisting of 2 mice, SibeliaZ is more than 10 times faster than Cactus, while on 4 mice SibeliaZ is more than 20 times faster. On the datasets with 8 and 16 mice, SibeliaZ completed in under 7 and 16 h, respectively, while Cactus did not finish (we terminated it after a week). For SibeliaZ, we note that the global alignment with spoa takes 44–73% of the running time, and, for some applications (e.g., rearrangement analysis), this step may be further omitted to save time. Memory is shown in Supplementary Table <xref rid="MOESM1" ref-type="media">2</xref>. When it is able to complete, Cactus has better memory performance than SibeliaZ; however, both tools require memory that is well within the range of most modern servers but outside the range of personal computers.<fig id="Fig3"><label>Fig. 3</label><caption><title>Running times of the different pipelines on the mice datasets (on a log scale).</title><p>Each bar corresponds to a pipeline. The bar of SibeliaZ is split according to its components: spoa (hatch fill), TwoPaCo (solid fill), and SibeliaZ-LCB (empty fill). Cactus is not shown on datasets 1–8 and 1–16 because it did not complete. We used 32 threads for each experiment.</p></caption><graphic xlink:href="41467_2020_19777_Fig3_HTML" id="d30e990"/></fig></p>
    </sec>
    <sec id="Sec6">
      <title>Accuracy</title>
      <p id="Par24">In Tables <xref rid="Tab2" ref-type="table">2</xref> and <xref rid="Tab3" ref-type="table">3</xref>, we show the properties of the alignments found by SibeliaZ and Cactus. To compute recall, we only used nucleotides from gene pairs having at least 90% identity in the annotation. For the datasets where Cactus was able to complete, SibeliaZ had and similar recall on orthologous pairs. We did not evaluate the results on paralogs by Cactus since it heuristically filters out paralogous alignments<sup><xref ref-type="bibr" rid="CR34">34</xref></sup> as a part of its pipeline. SibeliaZ’s recall decreases only slightly going up to the whole 16 mice dataset, indicating that the recall scales with the number of genomes.<table-wrap id="Tab2"><label>Table 2</label><caption><p>Number of blocks and coverage by the multiple whole-genome alignments computed by SibeliaZ and Cactus from the mice datasets.</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Dataset</th><th>No. of blocks, SibeliaZ</th><th>No. of blocks, Cactus</th><th>Coverage, SibeliaZ</th><th>Coverage, Cactus</th></tr></thead><tbody><tr><td>1–2</td><td>2,083,258</td><td>4,228,063</td><td>0.88</td><td>0.85</td></tr><tr><td>1–4</td><td>2,739,821</td><td>6,133,662</td><td>0.86</td><td>0.84</td></tr><tr><td>1–8</td><td>3,179,619</td><td>–</td><td>0.89</td><td>–</td></tr><tr><td>1–16</td><td>4,507,109</td><td>–</td><td>0.88</td><td>–</td></tr></tbody></table></table-wrap><table-wrap id="Tab3"><label>Table 3</label><caption><p>Recall of the orthologous and paralogous basepairs by the multiple whole-genome alignments computed by SibeliaZ and Cactus from the mice datasets, using Ensembl gene annotation as the ground truth. Recall of paralogs by Cactus is not included (see text).</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Dataset</th><th>Ort. nt. pairs, SibeliaZ</th><th>Ort. nt. pairs, Cactus</th><th>Par. nt. pairs, SibeliaZ</th></tr></thead><tbody><tr><td>1–2</td><td>0.99</td><td>0.99</td><td>0.89</td></tr><tr><td>1–4</td><td>0.98</td><td>0.98</td><td>0.89</td></tr><tr><td>1–8</td><td>0.98</td><td>–</td><td>0.84</td></tr><tr><td>1–16</td><td>0.98</td><td>–</td><td>0.83</td></tr></tbody></table></table-wrap></p>
      <p id="Par25">We also measured coverage, which is the percent of the genome sequence that is included in the alignment. The coverage of both tools is roughly the same, but SibeliaZ has only about half the blocks. The different amounts of blocks produced by the tools are likely to be a result of the different approaches to the formatting of the output. Representation of multiple whole-genome alignments is ambiguous and the same alignment can be formatted in different but mathematically equivalent forms varying by the number blocks.</p>
      <p id="Par26">We further investigate how the recall behaved as a function of nucleotide identity, for the two- and four-mice dataset (Fig. <xref rid="Fig4" ref-type="fig">4</xref>). As expected, recall decreases with nucleotide identity, though SibeliaZ’s recall remains above 90% for nucleotides from similar (80–100% identity) orthologous genes. Cactus has a slightly better recall in orthologous genes of lower identity on the two-mice dataset. We note that the gene annotation was constructed<sup><xref ref-type="bibr" rid="CR12">12</xref></sup> using an alignment produced by Cactus which was further processed by annotation software CAT<sup><xref ref-type="bibr" rid="CR36">36</xref></sup>. This fact might give Cactus a slight advantage in this comparison and explain why Cactus has a slightly better recall. Recall on orthologous gene pairs remains consistent in both two- and four-mice datasets for both datasets.<fig id="Fig4"><label>Fig. 4</label><caption><title>Recall of nucleotide pairs from homologous genes on the 1-2 and 1-4 mouse datasets.</title><p>Panels show recall of orthologous (<bold>a</bold>) and paralogous (<bold>b</bold>) nucleotide pairs binned according to the nucleotide identity of their respective genes in the annotation. Recall of paralogs by Cactus is not shown (see text).</p></caption><graphic xlink:href="41467_2020_19777_Fig4_HTML" id="d30e1211"/></fig></p>
      <p id="Par27">At the same time, we observed a much less consistent picture for paralogous pairs of genes. For example, SibeliaZ was able to recover nearly 90% of the paralogous basepairs belonging to gene pairs of nucleotide identity of 90% but found less than 45% of the base pairs of gene pairs of 80% identity.</p>
      <p id="Par28">The results of the precision and recall measured with respect to LASTZ alignments are shown in Supplementary Table <xref rid="MOESM1" ref-type="media">3</xref>. On the dataset consisting of two genomes, Cactus had a slightly higher recall of 0.97 vs. 0.95 of SibeliaZ. On the other hand, SibeliaZ had better precision: 0.93 against 0.89 of Cactus. With the four genomes, SibeliaZ maintained its recall of 0.95 while the recall of Cactus dropped to 0.92. On this dataset SibeliaZ also had higher precision: 0.96 and 0.90, respectively. Overall, these numbers show that the alignment accuracy of SibeliaZ and Cactus is similar.</p>
      <p id="Par29">Finally, since we could not evaluate genome-wide precision, we use the proxy of the average number of nucleotide differences for the alignment columns (Supplementary Fig. <xref rid="MOESM1" ref-type="media">2</xref>). SibeliaZ’s alignment has a high degree of similarity: more than 95% of the alignment columns have <italic>π</italic>(<italic>c</italic>) ≤ 0.1, which is what we would expect from aligning closely related genomes. Cactus has a slightly lower percentage of highly similar columns, which may simply indicate that it finds more blocks with higher divergence.</p>
      <p id="Par30">We note that the results in this Section evaluate the accuracy of SibeliaZ-LCB and spoa simultaneously; however, since SibeliaZ is targeted at closely related genomes, we expect the global alignment procedure to have a negligible effect on accuracy. This is due to the fact that the global alignment of similar sequences is likely to be unambiguous at homologous nucleotides and robust with respect to different algorithms and their parameters.</p>
    </sec>
    <sec id="Sec7">
      <title>Results on simulated data</title>
      <p id="Par31">In addition to the real data, we measured the performance of different whole-genome aligners on a larger simulated dataset with small genomic divergence, called “primates” in ref. <sup><xref ref-type="bibr" rid="CR1">1</xref></sup>. In this dataset, the distance from the root to the leaves in the phylogenetic tree is equal to 0.02 substitutions per site. The dataset has four genomes, with four chromosomes each, and each genome is approximately 185 Mbp in size. We did not use the other simulated dataset in ref. <sup><xref ref-type="bibr" rid="CR1">1</xref></sup> since its divergence of around 0.4 substitutions per site is outside of the target range of SibeliaZ.</p>
      <p id="Par32">On this dataset, SibeliaZ pipeline was 20 times faster than Cactus and consumed 2.5 times less memory: SibeliaZ finished in 18 min using 7 GBs of memory, while Cactus took 363 min to finish and used 18 GBs of memory. Sibelia and MultiZ could not finish on the “primates” dataset in a week. Table <xref rid="Tab4" ref-type="table">4</xref> demonstrate the recall and precision values for the alignments produced by SibeliaZ and Cactus on this dataset. SibeliaZ showed a recall of 95% and a precision of 92%, while Cactus had 98% recall and 95% precision. We note that according to ref. <sup><xref ref-type="bibr" rid="CR1">1</xref></sup>, the precision values calculated using this dataset can be considered lower bounds due to the features of the simulation process. Particularly, the ground truth for this dataset is likely to miss some repetitive alignments, hence we believe that the lower precision values of SibeliaZ may be due to this reason.<table-wrap id="Tab4"><label>Table 4</label><caption><p>Recall and precision of the alignments computed by Cactus and SibeliaZ on the “primates” dataset from the Alignathon.</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Program</th><th>Recall</th><th>Precision</th></tr></thead><tbody><tr><td>SibeliaZ</td><td>0.95</td><td>0.92</td></tr><tr><td>Cactus</td><td>0.98</td><td>0.95</td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec id="Sec8">
      <title>Gene families</title>
      <p id="Par33">We wanted to further understand SibeliaZ’s ability to recall homologous nucleotides from large gene families. Aligning genes having many copies is a challenging task since they generate a tangled de Bruijn graph. To investigate, we took each pair of genes in the two-mice dataset that have greater than 90% nucleotide identity. We then identify any other homologous genes that had a nucleotide identity of at least 90% to one of the genes in the pair. We refer to the number of such genes as the inferred family size of the gene pair, which roughly corresponds to the gene family size in the biological sense. Supplementary Fig. <xref rid="MOESM1" ref-type="media">3</xref> then shows the recall of nucleotide pairs with respect to the inferred family size of their respective genes. The recall shows a lot of variance with respect to the inferred family size but does exhibit a general trend of decreasing with increasing family size. The largest bin (with an inferred family size of 58) corresponds to a single large gene family on the Y chromosome (<italic>PTHR19368</italic>) and actually has a relatively high recall.</p>
      <p id="Par34">This experiment shows that finding all copies of even very similar homologous sequences within long genomes can be a challenging task. Moreover, the high variance we observe indicates that this challenge cannot be reduced to a single factor like family size. A manual inspection of false negatives suggests that the drop in recall may be due to complex substructures of unannotated repeats forming tangled graph structures.</p>
    </sec>
    <sec id="Sec9">
      <title>Effect of parameters and sequence divergence</title>
      <p id="Par35">SibeliaZ-LCB has four primary parameters that affect its performance. The most critical dependence is on the size of a <italic>k</italic>-mer (i.e., <italic>k</italic>) and the maximum allowed length of a bubble <italic>b</italic>. For a given sequence divergence, the distance between shared <italic>k</italic>-mers forming bubbles in homologous regions increases with <italic>k</italic>. At the same time, the maximum allowed length of a bubble is <italic>b</italic>. If the distance exceeds <italic>b</italic>, then SibeliaZ may fail to uncover such regions and result in a lower recall. To avoid this situation, we can either decrease <italic>k</italic> or increase <italic>b</italic>. Decreasing <italic>k</italic> is desirable up to a point, but when <italic>k</italic> becomes too low, the de Bruijn graph becomes convoluted and our algorithm becomes more time and memory consuming. Increasing <italic>b</italic> can also be done but simultaneously increases the allowable gap length, leading to decreased precision.</p>
      <p id="Par36">Over-alignment is the problem of combining nonhomologous sequences in a single block, which is closely related to low precision<sup><xref ref-type="bibr" rid="CR37">37</xref></sup>. In our case, one can control over-alignment by looking at the <italic>π</italic>(<italic>c</italic>) scores, as we have done in our analysis (Supplementary Fig. <xref rid="MOESM1" ref-type="media">2</xref>). A higher score indicates that more divergent sequences are included in a block. If the divergence is deemed too high by the user, it is recommended to reduce <italic>b</italic>.</p>
      <p id="Par37">To investigate this complex interplay between <italic>k</italic> and <italic>b</italic> and its relationship to sequence divergence, we used simulations (Supplementary Note <xref rid="MOESM1" ref-type="media">2</xref>) to measure recall (Supplementary Fig. <xref rid="MOESM1" ref-type="media">4</xref>) and precision (Supplementary Fig. <xref rid="MOESM1" ref-type="media">5</xref>) under various combinations. As predicted, recall increases with decreasing <italic>k</italic> and with increasing <italic>b</italic>, and precision decreases with increasing <italic>b</italic>. We note though that the precision varies only a little and remains high. Based on these analyses, we recommend two values of <italic>k</italic> for practical usage. For less complex organisms (e.g., bacteria), we recommend <italic>k</italic> = 15, since it yields the highest recall. This value is impractical for complex organisms (e.g., mammals) due to runtime, so we recommend setting <italic>k</italic> = 25 in those cases as it provides a reasonable trade-off between accuracy and required computational resources (we used this for our mice datasets). For the value of <italic>b</italic>, we observed that increasing <italic>b</italic> lowers the precision at only higher values. Hence, we recommend <italic>b</italic> = 200 as the default in all cases, as it led to high recall across all tested ranges of <italic>k</italic> on our simulated data without lowering precision.</p>
      <p id="Par38">To test the level of divergence which SibeliaZ-LCB can tolerate, we took the default values of <italic>k</italic> = 15 or 25 and <italic>b</italic> = 200 and plotted the precision vs. recall curve as a function of the root-to-leaf divergence of the dataset (Supplementary Fig. <xref rid="MOESM1" ref-type="media">6</xref>). We see that for <italic>k</italic> = 25 the recall deteriorates significantly for datasets having a root-to-leaf evolutionary distance of more than 0.09 substitutions per site. Based on this, we recommend that for large datasets SibeliaZ-LCB be only used for detecting homologs with an evolutionary distance to the MRCA of at most 0.09 substitutions per site.</p>
      <p id="Par39">The other two parameters that can affect SibeliaZ-LCB’s performance are the minimum size of a locally collinear block <italic>m</italic> and the abundance pruning parameter <italic>a</italic>. These parameters should be set according to the type of data and its intended use. The parameter <italic>m</italic> controls the fragmentation of the alignment and the coverage—higher <italic>m</italic> results in longer blocks spanning less of the genomes, since short blocks are not reported. We recommend the parameter <italic>m</italic> to be set to the length of the shortest homologous sequence of interest to the downstream analysis. We set <italic>m</italic> = 50 as a default, since this is smaller than 93.1% of the known mice exons<sup><xref ref-type="bibr" rid="CR38">38</xref></sup> and, more generally, we do not expect most applications to be interested in much blocks shorter than 50 nt. In the case that a user is interested in larger homologous units, they can increase <italic>m</italic> together with <italic>b</italic>. Alternatively, they can use either synteny block generation or alignment chaining algorithms for post-processing the alignments produced by SibeliaZ (see Supplementary Note <xref rid="MOESM1" ref-type="media">3</xref> for relevant references).</p>
      <p id="Par40">The abundance pruning parameter <italic>a</italic> is a filtering parameter for <italic>k</italic>-mers whose abundance is above <italic>a</italic>. Such <italic>k</italic>-mers are still considered by SibeliaZ-LCB, but to a smaller extent, resulting in reduced recall in regions with such <italic>k</italic>-mers. We recommend setting <italic>a</italic> as high as the compute resources allow, keeping in mind that homologous blocks with multiplicity higher than <italic>a</italic> are possibly not going to be captured. For the mice dataset, we used <italic>a</italic> = 150.</p>
    </sec>
  </sec>
  <sec id="Sec10" sec-type="discussion">
    <title>Discussion</title>
    <p id="Par41">In this paper, we presented a whole-genome alignment pipeline SibeliaZ based on an algorithm for identifying locally collinear blocks. The algorithm analyses the compacted de Bruijn graph and jointly reconstructs the path corresponding to a collinear block and identifies the induced collinear walks. We assume that the collinear walks share many vertices with this carrying path and form chains of bubbles. Each carrying path and the induced block is found greedily, using a scoring function that measures how close it is to all the sequences in the block. We then globally align the collinear blocks to generate the whole-genome alignment.</p>
    <p id="Par42">SibeliaZ builds on the ideas laid down in DRIMM-Synteny<sup><xref ref-type="bibr" rid="CR22">22</xref></sup> and Sibelia<sup><xref ref-type="bibr" rid="CR23">23</xref></sup> that used variants of the de Bruijn graphs for finding synteny blocks (we elaborate on the connection between the whole genome alignment and synteny reconstruction in Supplementary Note <xref rid="MOESM1" ref-type="media">3</xref>). Sibelia did not scale beyond bacterial genomes due to its slow graph construction algorithm and the fact that it continuously had to modify the graph. TwoPaCo<sup><xref ref-type="bibr" rid="CR27">27</xref></sup> addressed the former issue and we use it as a standalone module in SibeliaZ. The latter issue was addressed in this paper by SibeliaZ-LCB, which achieves its speed in part because it keeps the underlying graph static.</p>
    <p id="Par43">The main strength of our approach is speed—we achieve drastic speedups compared to the state-of-the-art Progressive Cactus aligner<sup><xref ref-type="bibr" rid="CR34">34</xref></sup> while retaining comparable accuracy. Using a single machine, on 16 mice genomes, SibeliaZ runs in under 16 h, while Progressive Cactus is not able to complete for even 8 mice genomes, within seven days. We note that it is possible for Cactus to construct larger alignments by utilizing a distributed computer cluster<sup><xref ref-type="bibr" rid="CR34">34</xref></sup>. In our study, we concentrated on improving the scalability of the whole-genome alignment when only a single machine is available. In the future, we hope to develop a version of SibeliaZ that will work in the distributed setting as well. Overall, SibeliaZ is the only tool available that can scale to many long, closely related genomes on a single machine.</p>
    <p id="Par44">The biggest limitation of our approach is the limited tolerance to the divergence of input sequences. As suggested by the results on simulated bacterial data, SibeliaZ works best for aligning genomes having an evolutionary distance to the MRCA of at most 0.09 substitutions per site. Aligning more divergent genomes with SibeliaZ is still possible but it will result in the smaller recall; for such datasets, Cactus remains a better option. In the future, we hope to address this limitation by employing techniques like postprocessing of the output with more sensitive homology finders.</p>
    <p id="Par45">If the alignments themselves are not needed, SibeliaZ-LCB can be run alone (without spoa) to construct the collinear blocks. This is most useful in applications stemming from studies of genome rearrangements, which can be applied to study breakpoint reuse<sup><xref ref-type="bibr" rid="CR39">39</xref></sup>, ancestral genome reconstruction<sup><xref ref-type="bibr" rid="CR40">40</xref></sup> and phylogenies<sup><xref ref-type="bibr" rid="CR41">41</xref></sup>. Locally collinear blocks are also a required input for scaffolding tools using multiple references genomes<sup><xref ref-type="bibr" rid="CR42">42</xref>–<xref ref-type="bibr" rid="CR46">46</xref></sup>. For such applications, the output of SibeliaZ-LCB can be used either directly or after postprocessing by a synteny block generator<sup><xref ref-type="bibr" rid="CR22">22</xref>,<xref ref-type="bibr" rid="CR47">47</xref></sup>.</p>
    <p id="Par46">There are several remaining open questions of interest. A formal analysis of SibeliaZ-LCB’s runtime is relevant, but doing it in a useful way is a challenge. The worst-case running time does not reflect the actual one; moreover, we observed that the actual one depends on multi-thread synchronization, which is challenging to model. However, it would be interesting if such a time analysis can be performed parametrized by the crucial properties of the structure of the input. We also did not investigate how close to an optimal solution our greedy heuristic gets. One way to do this would be to find an optimal carrying path using exhaustive enumeration, but the search space even for a small realistic example is too big. We suspect that a polynomial time-optimal solution is not possible, but the computational complexity of our problem is open.</p>
    <p id="Par47">SibeliaZ is the first multiple whole-genome aligners that can run on a single machine in a reasonable time on a dataset such as the 16 mouse genomes analyzed in this paper. With ongoing initiatives like the Vertebrate Genomes Project and the insect5k, thousands of species will soon have a reference genome available, and the sequencing and assembly of various subspecies and strains will be the next logical step for many comparative genomics studies. For example<sup><xref ref-type="bibr" rid="CR48">48</xref></sup>, currently holds 18 assembled maize genomes, with more to come in the recent future. Similarly, the Solanaceae Genomics Network has recently released the genomes of 13 diverse tomato accessions (<ext-link ext-link-type="uri" xlink:href="https://solgenomics.net/projects/tomato13/">https://solgenomics.net/projects/tomato13/</ext-link>). Analysis of such datasets is likely to be carried out in single-lab settings with limited compute resources, rather than at large computing centers like EMBL or NCBI. SibeliaZ makes a significant leap toward enabling such studies.</p>
  </sec>
  <sec id="Sec11">
    <title>Methods</title>
    <sec id="Sec12">
      <title>Preliminaries</title>
      <p id="Par48">First, we will define the de Bruijn graph and related objects. Given a positive integer <italic>k</italic> and a string <italic>s</italic>, we define a multigraph <italic>G</italic>(<italic>s</italic>, <italic>k</italic>) as the <italic>de Bruijn graph</italic> of <italic>s</italic>. The vertex set consists of all substrings of <italic>s</italic> of length <italic>k</italic>, called <italic>k</italic>-mers. For each substring <italic>x</italic> of length <italic>k</italic> + 1 in <italic>s</italic>, we add a directed edge from <italic>u</italic> to <italic>v</italic>, where <italic>u</italic> is the prefix of <italic>x</italic> of length <italic>k</italic> and <italic>v</italic> the suffix of <italic>x</italic> of length <italic>k</italic>.</p>
      <p id="Par49">Each occurrence of a (<italic>k</italic> + 1)-mer yields a unique edge, and every edge corresponds to a unique location in the input. Two edges are <italic>parallel</italic> if they are oriented in the same direction and have the same endpoints. Note that two edges are parallel if and only if they were generated by the same (<italic>k</italic> + 1)-mer. This way, we use the notion of parallel edges to refer to a set of identical (<italic>k</italic> + 1)-mers in the input strings. Parallel edges are not considered identical. The de Bruijn graph can also be constructed from a set of sequences <italic>S</italic> = {<italic>s</italic><sub>1</sub>, …, <italic>s</italic><sub><italic>n</italic></sub>}. This graph is the union of the graphs constructed from the individual strings: <italic>G</italic>(<italic>S</italic>, <italic>k</italic>) = ⋃<sub>1≤<italic>i</italic>≤<italic>n</italic></sub><italic>G</italic>(<italic>s</italic><sub><italic>i</italic></sub>, <italic>k</italic>). See Fig. <xref rid="Fig1" ref-type="fig">1</xref> for an example.</p>
      <p id="Par50">The set of all edges in a graph <italic>G</italic> is denoted by <italic>E</italic>(<italic>G</italic>). We write (<italic>u</italic>, <italic>v</italic>) to denote an edge from vertex <italic>u</italic> to <italic>v</italic>. A <italic>walk</italic><italic>p</italic> is a sequence of edges ((<italic>v</italic><sub>1</sub>, <italic>v</italic><sub>2</sub>), (<italic>v</italic><sub>2</sub>, <italic>v</italic><sub>3</sub>), …, (<italic>v</italic><sub>∣<italic>p</italic>∣−1</sub>, <italic>v</italic><sub>∣<italic>p</italic>∣</sub>)) where each edge (<italic>v</italic><sub><italic>i</italic></sub>, <italic>v</italic><sub><italic>i</italic>+1</sub>) belongs to <italic>E</italic>(<italic>G</italic>). The length of the walk <italic>p</italic>, denoted by ∣<italic>p</italic>∣, is the number of edges it contains. The last edge of a walk <italic>p</italic> is denoted by the end(<italic>p</italic>). A <italic>path</italic> is a walk that visits each vertex at most once.</p>
      <p id="Par51">In a de Bruijn graph, a given edge <italic>x</italic> was generated by a (<italic>k</italic> + 1)-mer starting at some position <italic>j</italic> of some string <italic>s</italic><sub><italic>i</italic></sub>. To retrieve the position <italic>j</italic> of the (<italic>k</italic> + 1)-mer that generated edge <italic>x</italic>, we define function pos(<italic>x</italic>) = <italic>j</italic>. We use the function pos to map edges of the graph back to positions of the <italic>k</italic>-mers that generated them. For an edge <italic>x</italic>, its successor, denoted by next(<italic>x</italic>), is an edge <italic>y</italic> such that both <italic>x</italic> and <italic>y</italic> are generated by the same string and pos(<italic>y</italic>) = pos(<italic>x</italic>) + 1. Note that a successor does not always exist.</p>
      <p id="Par52">A walk <italic>p</italic> = (<italic>x</italic><sub>1</sub>, …, <italic>x</italic><sub>∣<italic>p</italic>∣</sub>) is <italic>genomic</italic> if nex<italic>t</italic>(<italic>x</italic><sub><italic>i</italic></sub>) = <italic>x</italic><sub><italic>i</italic>+1</sub> for 1 ≤ <italic>i</italic> ≤ ∣<italic>p</italic>∣ − 1. In other words, a walk is genomic if it was generated by a substring in the input. The <italic>b</italic>-extension of a genomic walk <italic>p</italic> is the longest genomic walk <italic>q</italic> = (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub>∣<italic>q</italic>∣</sub>) such that <italic>y</italic><sub>1</sub> = next(end(<italic>p</italic>)) and ∣<italic>q</italic>∣ ≤ <italic>b</italic>. The <italic>b</italic>-extension of a walk <italic>p</italic> is uniquely defined and usually has length <italic>b</italic>, unless <italic>p</italic> was generated by a substring close to an end of an input string. Intuitively, <italic>b</italic>-extension defines edges lying ahead of a walk. As our algorithm works in the seed-and-extend manner, we later use <italic>b</italic>-extensions to find the most appropriate extension of the current block. The concatenation of two walks <italic>x</italic> and <italic>y</italic> is a walk (if it exists) <italic>x</italic><italic>y</italic> consisting of edges of <italic>x</italic> followed by edges of <italic>y</italic>. We use the concatenation operation to extend the genomic walks constituting locally collinear blocks using appropriate <italic>b</italic>-extensions.</p>
    </sec>
    <sec id="Sec13">
      <title>Problem formulation</title>
      <p id="Par53">In this section, we will define the collinear block reconstruction problem in de Bruijn graphs. A <italic>collinear block</italic> is a set of edge-disjoint genomic walks with length at least <italic>m</italic>, where <italic>m</italic> is a parameter. We call walks constituting a collinear block <italic>collinear walks</italic>. In order to quantify how well collinear walks correspond to homologous sequences, we will define a <italic>collinearity score</italic> of a collinear block. Our problem will then be to find a set of collinear blocks that are pairwise edge-disjoint and have the largest score.</p>
      <p id="Par54">We capture the pattern of two homologous collinear walks through the concept of chains and bubbles. A <italic>bubble</italic> is a subgraph corresponding to a possible mutation flanked by equal sequences. Formally, a pair of walks <italic>x</italic> and <italic>y</italic> form a bubble (<italic>x</italic>, <italic>y</italic>) if all of the following holds: (1) <italic>x</italic> and <italic>y</italic> have common starting and ending vertices; (2) <italic>x</italic> and <italic>y</italic> have no common vertices except the starting and ending ones; and (3) ∣<italic>x</italic>∣ ≤ <italic>b</italic> and ∣<italic>y</italic>∣ ≤ <italic>b</italic>, where <italic>b</italic> is a parameter. A <italic>chain</italic>
<italic>c</italic> = ((<italic>x</italic><sub>1</sub>, <italic>y</italic><sub>1</sub>), (<italic>x</italic><sub>2</sub>, <italic>y</italic><sub>2</sub>), …, (<italic>x</italic><sub><italic>n</italic></sub>, <italic>y</italic><sub><italic>n</italic></sub>)) is a sequence of bubbles such that <italic>x</italic> = <italic>x</italic><sub>1</sub><italic>x</italic><sub>2</sub>…<italic>x</italic><sub><italic>n</italic></sub> and <italic>y</italic> = <italic>y</italic><sub>1</sub><italic>y</italic><sub>2</sub>…<italic>y</italic><sub><italic>n</italic></sub> are walks in a de Bruijn graph. In other words, a chain is a series of bubbles where each bubble is a proper continuation of the previous one. Note that two parallel edges form a bubble and a chain arising from equal sequences corresponds to a series of such bubbles. This way, a chain models a pair of sequences that potentially have point mutations and indels. For an example of a bubble and a chain, see Fig. <xref rid="Fig1" ref-type="fig">1</xref>.</p>
      <p id="Par55">The subgraph resulting from more than two collinear walks can be complex, and there are several ways of capturing it. We note that there are previous studies generalizing the idea of bubbles, see<sup><xref ref-type="bibr" rid="CR49">49</xref>–<xref ref-type="bibr" rid="CR53">53</xref></sup>, mostly in the context of analyzing assembly graphs. We decided to follow a different approach designed specifically for capturing locally collinear blocks.</p>
      <p id="Par56">Our approach is to give a definition that naturally leads itself to an algorithm. As homologous sequences all originate from some common ancestral sequence <italic>s</italic><sub>a</sub>, they should have many common <italic>k</italic>-mers and there should be a path <italic>p</italic><sub>a</sub> = <italic>G</italic>(<italic>s</italic><sub>a</sub>, <italic>k</italic>) through the graph forming a long chain with each walk <italic>p</italic> in the collinear block. We call such a path a <italic>carrying</italic> one. We require the chains to be longer than <italic>m</italic> to avoid confusing spuriously similar sequences with true homologs. At the same time, a collinear walk may only partially form a chain with the carrying path, leaving hanging ends at the ends of the carrying path, which is undesirable since it implies that these graphs originate from dissimilar sequences. We note that compared to the previous work on chaining anchors<sup><xref ref-type="bibr" rid="CR18">18</xref>–<xref ref-type="bibr" rid="CR20">20</xref></sup> our definition of the block will be more relaxed. Namely, we will not require common <italic>k</italic>-mers to be present in all copies of a block. In addition, many alignment methods use phylogenetic information for scoring purposes. We decided to not use it since our method targets closely related sequences, such as strains of the same species, where the phylogeny is often unknown.</p>
      <p id="Par57">We formalize this intuition by introducing a scoring function quantifying how well a carrying path describes a collection of the collinear walks. The function rewards long chains formed by the carrying path and a collinear walk and penalizes the hanging ends. Given a carrying path <italic>p</italic><sub>a</sub> and a genomic walk <italic>p</italic>, let <italic>q</italic><sub>2</sub> be the longest subpath of <italic>p</italic><sub>a</sub> that forms a chain with <italic>p</italic>. Then, we can write <italic>p</italic><sub>a</sub> = <italic>q</italic><sub>1</sub><italic>q</italic><sub>2</sub><italic>q</italic><sub>3</sub>. Recall that <italic>m</italic> is the parameter denoting the minimum length of a collinear block, and <italic>b</italic> is the maximum bubble size We define the score <italic>f</italic>(<italic>p</italic><sub>a</sub>, <italic>p</italic>) as<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$f({p}_{{\rm{a}}},p)=\left\{\begin{array}{ll}0,&amp;\,{\text{if}}\,\,| p| {\,}&lt; {\,}m\\ | p| -{(| {q}_{1}| +| {q}_{3}|)}^{2},&amp;\,{\text{if}}\,\,| p| \, \ge \, m\,{\text{and}}\,| {q}_{1}| ,| {q}_{3}| \, \le \, b\\ -\infty ,&amp;\,{\text{if}}\,\,| p| \, \ge \, m\,{\text{and}}\,(| {q}_{1}| \, &gt; \,b\,{\text{or}}\,| {q}_{3}| \, &gt; \, b)\end{array}\right..$$\end{document}</tex-math><mml:math id="M4"><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">a</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfenced open="{"><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">if</mml:mi><mml:mspace width="0.25em"/><mml:mspace width="0.25em"/><mml:mo>∣</mml:mo><mml:mi>p</mml:mi><mml:mo>∣</mml:mo><mml:mspace width="0.25em"/><mml:mo>&lt;</mml:mo><mml:mspace width="0.25em"/><mml:mi>m</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mo>∣</mml:mo><mml:mi>p</mml:mi><mml:mo>∣</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>∣</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>∣</mml:mo><mml:mo>+</mml:mo><mml:mo>∣</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>∣</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">if</mml:mi><mml:mspace width="0.25em"/><mml:mspace width="0.25em"/><mml:mo>∣</mml:mo><mml:mi>p</mml:mi><mml:mo>∣</mml:mo><mml:mspace width="0.25em"/><mml:mo>≥</mml:mo><mml:mspace width="0.25em"/><mml:mi>m</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">and</mml:mi><mml:mspace width="0.25em"/><mml:mo>∣</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>∣</mml:mo><mml:mo>,</mml:mo><mml:mo>∣</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>∣</mml:mo><mml:mspace width="0.25em"/><mml:mo>≤</mml:mo><mml:mspace width="0.25em"/><mml:mi>b</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mo>−</mml:mo><mml:mi>∞</mml:mi><mml:mo>,</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">if</mml:mi><mml:mspace width="0.25em"/><mml:mspace width="0.25em"/><mml:mo>∣</mml:mo><mml:mi>p</mml:mi><mml:mo>∣</mml:mo><mml:mspace width="0.25em"/><mml:mo>≥</mml:mo><mml:mspace width="0.25em"/><mml:mi>m</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">and</mml:mi><mml:mspace width="0.25em"/><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>∣</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>∣</mml:mo><mml:mspace width="0.25em"/><mml:mo>&gt;</mml:mo><mml:mspace width="0.25em"/><mml:mi>b</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">or</mml:mi><mml:mspace width="0.25em"/><mml:mo>∣</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>∣</mml:mo><mml:mspace width="0.25em"/><mml:mo>&gt;</mml:mo><mml:mspace width="0.25em"/><mml:mi>b</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>.</mml:mo></mml:math><graphic xlink:href="41467_2020_19777_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula>The third case forbids walks (i.e., gives them a score of  −<italic>∞</italic>) where the hanging ends are too long, and the first case ignores walks (i.e., gives them a score of 0) that weave through <italic>p</italic><sub>a</sub> but are too short. The second case gives a score that is proportional to the length of the part of <italic>p</italic><sub>a</sub> that forms a chain with <italic>p</italic>. At the same time, it reduces the score if the collinear walks leave hanging ends <italic>q</italic><sub>1</sub> and <italic>q</italic><sub>3</sub>—the parts of <italic>p</italic><sub>a</sub> not participating in the chain. The penalty induced by these ends is squared to remove spuriously similar sequences from from the collinear block. This form of scoring function was chosen because it performed well during the initial stages of development. We do not penalize for the discrepancy between <italic>p</italic> and <italic>q</italic><sub>2</sub> for the sake of simplicity of the scoring function and avoiding extra computation needed to calculate it. Figure <xref rid="Fig5" ref-type="fig">5</xref> shows an example of computing the score.<fig id="Fig5"><label>Fig. 5</label><caption><title>An example of computing the score of a walk <italic>p</italic> (solid) relative to a carrying path <italic>p</italic><sub>a</sub> = <italic>q</italic><sub>1</sub><italic>q</italic><sub>2</sub><italic>q</italic><sub>3</sub> (dashed).</title><p>The path <italic>p</italic> forms a chain with the subpath <italic>q</italic><sub>2</sub> of <italic>p</italic><sub><italic>a</italic></sub>, while subpaths <italic>q</italic><sub>1</sub> and <italic>q</italic><sub>3</sub> form hanging ends. We count the length of <italic>p</italic> and subtract lengths of the hanging ends. Thus, the score <italic>f</italic>(<italic>p</italic><sub>a</sub>, <italic>p</italic>) = 4 − (1 + 1)<sup>2</sup> = 0.</p></caption><graphic xlink:href="41467_2020_19777_Fig5_HTML" id="d30e2607"/></fig></p>
      <p id="Par58">The <italic>collinearity score</italic> of a collinear block is given by<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$f(P)=\mathop{\max }\limits_{{p}_{{\rm{a}}}}\sum _{p\in P}f({p}_{{\rm{a}}},p),$$\end{document}</tex-math><mml:math id="M6"><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:munder><mml:mrow><mml:mo mathsize="big"> ∑</mml:mo></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:munder><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">a</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math><graphic xlink:href="41467_2020_19777_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula>where <italic>p</italic><sub>a</sub> can be any path (not necessarily genomic). In other words, we are looking for a path forming longest chains with the collinear walks and thus maximizes the score. The collinear blocks reconstruction problem is to find a set of collinear blocks <inline-formula id="IEq2"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathcal{P}}$$\end{document}</tex-math><mml:math id="M8"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq2.gif"/></alternatives></inline-formula> such that <inline-formula id="IEq3"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\sum }_{P\in {\mathcal{P}}}f(P)$$\end{document}</tex-math><mml:math id="M10"><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:mo>∈</mml:mo><mml:mi class="MJX-tex-caligraphic" mathvariant="script">P</mml:mi></mml:mrow></mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq3.gif"/></alternatives></inline-formula> is maximum and no two walks in <inline-formula id="IEq4"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathcal{P}}$$\end{document}</tex-math><mml:math id="M12"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq4.gif"/></alternatives></inline-formula> share an edge. Note that the number of collinear blocks is not known in advance. For an example of a complex collinear block in the de Bruijn graph and a carrying path capturing it, refer to Fig. <xref rid="Fig1" ref-type="fig">1</xref>b.</p>
    </sec>
    <sec id="Sec14">
      <title>The collinear blocks reconstruction algorithm</title>
      <p id="Par59">Our algorithm’s main pseudocode is shown in Box <xref rid="Sec15" ref-type="sec">1</xref> and its helper function in Box <xref rid="Sec16" ref-type="sec">2</xref>. First, we describe the high-level strategy. The main algorithm is greedy and works in the seed-and-extend fashion. It starts with an arbitrary edge in the graph and tries to extend it into a carrying path that induces a collinear block with the highest possible collinearity score <italic>P</italic><sub>best</sub>. If the block has a positive score, then <italic>P</italic><sub>best</sub> is added to our collection of collinear blocks <inline-formula id="IEq5"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathcal{P}}$$\end{document}</tex-math><mml:math id="M14"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq5.gif"/></alternatives></inline-formula>. The algorithm then repeats, attempting to build a collinear block from a different edge seed. New collinear blocks cannot use edges belonging to previously discovered collinear blocks. This process continues until all possible edges are considered as seeds. The algorithm is greedy in the sense that once a block is found and added to <inline-formula id="IEq6"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathcal{P}}$$\end{document}</tex-math><mml:math id="M16"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq6.gif"/></alternatives></inline-formula>, it cannot be later changed to form a more optimal global solution.</p>
      <p id="Par60">To extend a seed into a collinear block <italic>P</italic>, we first initialize the collinear block with a walk for each unused edge parallel to the seed (including the seed) (lines 7 and 8). These parallel edges represent the different occurrences of the seed string in the input and, hence, form the initial collinear block. We then proceed in phases, where each phase is an iteration of the while loop (lines 9–19). During each phase, the carrying path <italic>p</italic><sub>a</sub> is extended using a walk <italic>r</italic> of length at most <italic>b</italic> (lines 10–14). Next, we try to extend each of the collinear walks in a way that forms chains with the extended <italic>p</italic><sub>a</sub> (lines 15–19). The extension of a seed into a collinear block is also a greedy process since we only change <italic>p</italic><sub>a</sub> and the walks in <italic>P</italic> by extending them and never by changing any edges. Finally, we check that the collinearity score for our extended block is still positive—if it is, we iterate to extend it further, otherwise, we abandon our attempts at further extending the block. We then recall the highest-scoring block that was achieved for this seed and save it into our final result <inline-formula id="IEq7"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathcal{P}}$$\end{document}</tex-math><mml:math id="M18"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq7.gif"/></alternatives></inline-formula> (lines 20–22).</p>
      <p id="Par61">To pick the walk <italic>r</italic> by which to extend <italic>p</italic><sub>a</sub>, we use a greedy heuristic (lines 10–14). First, we pick the vertex <italic>t</italic> which we want to extend to reach (lines 10–12). We limit our search to those vertices that can be reached by a genomic walk from the end of <italic>p</italic><sub>a</sub> and greedily chose the one that is most often visited by the <italic>b</italic>-extensions of the collinear walks in <italic>P</italic>. Intuitively, we hope to maximize the number of collinear walks that will form longer chains with <italic>p</italic><sub>a</sub> after its extension and thereby boost the collinearity score. We then extend <italic>p</italic><sub>a</sub> using the shortest <italic>b</italic>-extension of the walks in <italic>P</italic> to reach <italic>t</italic>. We chose this particular heuristic because it showed superior performance compared to other possible strategies.</p>
      <p id="Par62">Once we have selected the genomic walk <italic>r</italic> by which to extend <italic>p</italic><sub>a</sub>, we must select the extensions to our collinear walks <italic>P</italic> that will form chains with <italic>p</italic><sub>a</sub><italic>r</italic>. This is done by the function Update-collinear-blocks (Box <xref rid="Sec16" ref-type="sec">2</xref>). We extend the walks to match <italic>r</italic> by considering the vertices of <italic>r</italic> consecutively, one at a time. To extend to a vertex <italic>w</italic>, we consider all the different locations of <italic>w</italic> in the input (each such location is represented by an edge <italic>x</italic> ending at <italic>w</italic>). For each location, we check if it can be reached by a <italic>b</italic>-extension from an existing <italic>p</italic> ∈ <italic>P</italic>. If yes, then we extend <italic>p</italic>, so as to lengthen the chain that it forms with <italic>p</italic><sub>a</sub>. If there are multiple collinear walks that reach <italic>w</italic>, we take the nearest one. If no, then we start a new collinear walk using just <italic>x</italic>. Figure <xref rid="Fig6" ref-type="fig">6</xref> shows an example of updating a collinear walk and Fig. <xref rid="Fig2" ref-type="fig">2</xref> shows a full run of the algorithm for a single seed.<fig id="Fig6"><label>Fig. 6</label><caption><title>Illustration for Algorithm Update-collinear-walks (Box <xref rid="Sec16" ref-type="sec">2</xref>).</title><p>A collinear walk <italic>p</italic> (solid) requires an update after the carrying path <italic>p</italic><sub>a</sub> is extended with the dashed edge (<italic>w</italic><sub>0</sub>, <italic>w</italic>). The path <italic>p</italic><sub>a</sub> now ends at the vertex <italic>w</italic>, which has another incoming edge <italic>x</italic>. Since <italic>x</italic> is a part of the <italic>b</italic>-extension of <italic>p</italic> (denoted by <italic>q</italic>), <italic>p</italic> can be appended with <italic>q</italic> to form a longer chain and boost the collinearity score.</p></caption><graphic xlink:href="41467_2020_19777_Fig6_HTML" id="d30e2997"/></fig></p>
      <p id="Par63">Our description here only considers extending the initial seed to the right, i.e., using out-going edges in the graph. However, we also run the procedure to extend the initial seed to the left, using the incoming edges. The case is symmetric and we, therefore, omit the details.</p>
    </sec>
    <sec id="Sec15">
      <boxed-text>
        <label>Box 1 Algorithm Find-collinear-blocks</label>
        <p id="Par64">Input: strings <italic>S</italic>, integers <italic>k</italic>, <italic>b</italic> and <italic>m</italic></p>
        <p id="Par65">Output: a set of edge-disjoint subgraphs of <italic>G</italic>(<italic>S</italic>, <italic>k</italic>) representing collinear blocks</p>
        <p id="Par66">1: <inline-formula id="IEq8"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathcal{P}}\leftarrow {{\emptyset}}$$\end{document}</tex-math><mml:math id="M20"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">P</mml:mi><mml:mo>←</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq8.gif"/></alternatives></inline-formula> ⊳ Collinear blocks</p>
        <p id="Par67">2: <italic>G</italic> ← <italic>G</italic>(<italic>S</italic>, <italic>k</italic>)         ⊳ Construct the multigraph</p>
        <p id="Par68">3: <bold>for</bold> all distinct pairs (<italic>u</italic>, <italic>v</italic>) ∈ <italic>E</italic>(<italic>G</italic>) <bold>do</bold>        ⊳ Check possible seeds</p>
        <p id="Par69">4:     Initialize the current-carrying path <italic>p</italic><sub>a</sub> with (<italic>u</italic>, <italic>v</italic>)</p>
        <p id="Par70">5:     <inline-formula id="IEq9"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$P\leftarrow {{\emptyset}}$$\end{document}</tex-math><mml:math id="M22"><mml:mi>P</mml:mi><mml:mo>←</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq9.gif"/></alternatives></inline-formula> ⊳ Sorted set of collinear walks forming chains with <italic>p</italic><sub>a</sub></p>
        <p id="Par71">6:     <inline-formula id="IEq10"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${P}_{{\rm{best}}}\leftarrow {{\emptyset}}$$\end{document}</tex-math><mml:math id="M24"><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">best</mml:mi></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mi mathvariant="normal">∅</mml:mi></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq10.gif"/></alternatives></inline-formula> ⊳ Highest-scoring collinear block induced by <italic>p</italic><sub>a</sub></p>
        <p id="Par72">7:     <bold>for</bold> edges <italic>x</italic> ∈ <italic>E</italic>(<italic>G</italic>) parallel to (<italic>u</italic>, <italic>v</italic>) not marked as used <bold>do</bold></p>
        <p id="Par73">8:        Add to <italic>P</italic> a new collinear walk consisting of <italic>x</italic></p>
        <p id="Par74">9:     <bold>while</bold> <italic>f</italic>(<italic>P</italic>) ≥ 0 <bold>do</bold>        ⊳ Extend the carrying path as far as possible</p>
        <p id="Par75">10:        <italic>Q</italic> ← {<italic>q</italic> ∣ <italic>q</italic> is the <italic>b</italic> − extension of a <italic>p</italic> ∈ <italic>P</italic>}</p>
        <p id="Par76">11:        <italic>w</italic><sub>0</sub> ← last vertex in <italic>p</italic><sub>a</sub></p>
        <p id="Par77">12:        <italic>t</italic> ← a vertex, reachable from <italic>w</italic><sub>0</sub> via a genomic walk, that is visited by the most walks of <italic>Q</italic>.</p>
        <p id="Par78">13:        Let <italic>r</italic> ∈ <italic>Q</italic> be the shortest walk from <italic>w</italic><sub>0</sub> to <italic>t</italic></p>
        <p id="Par79">14:        Denote the vertices of <italic>r</italic> as <italic>w</italic><sub>0</sub>, <italic>w</italic><sub>1</sub>, …, <italic>w</italic><sub>∣<italic>r</italic>∣</sub>, with <italic>w</italic><sub>∣<italic>r</italic>∣</sub> = <italic>t</italic></p>
        <p id="Par80">15:        <bold>for</bold>
<italic>i</italic> ← 1 to ∣<italic>r</italic>∣ <bold>do</bold></p>
        <p id="Par81">16: Append (<italic>w</italic><sub><italic>i</italic>−1</sub>, <italic>w</italic><sub><italic>i</italic></sub>) to the carrying path <italic>p</italic><sub>a</sub></p>
        <p id="Par82">17: <italic>P</italic> ← Update-collinear-walks(<italic>P</italic>, <italic>w</italic><sub><italic>i</italic></sub>)</p>
        <p id="Par83">18: <bold>if</bold> <italic>f</italic>(<italic>P</italic>) &gt; <italic>f</italic>(<italic>P</italic><sub>best</sub>) <bold>then</bold></p>
        <p id="Par84">19: <italic>P</italic><sub>best</sub> ← <italic>P</italic></p>
        <p id="Par85">20:     <bold>if</bold> <italic>f</italic>(<italic>P</italic><sub>best</sub>) &gt; 0 <bold>then</bold></p>
        <p id="Par86">21:        <inline-formula id="IEq11"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathcal{P}}\leftarrow {\mathcal{P}}\cup \{{P}_{{\rm{best}}}\}$$\end{document}</tex-math><mml:math id="M26"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">P</mml:mi><mml:mo>←</mml:mo><mml:mi class="MJX-tex-caligraphic" mathvariant="script">P</mml:mi><mml:mo>∪</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">best</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq11.gif"/></alternatives></inline-formula></p>
        <p id="Par87">22:        Mark edges visited by walks of <italic>P</italic><sub>best</sub> as used</p>
        <p id="Par88">23: <bold>return</bold> <inline-formula id="IEq12"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathcal{P}}$$\end{document}</tex-math><mml:math id="M28"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">P</mml:mi></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq12.gif"/></alternatives></inline-formula></p>
      </boxed-text>
    </sec>
    <sec id="Sec16">
      <boxed-text>
        <label>Box 2 Update-collinear-walks</label>
        <p id="Par89">Input: A sorted set of collinear walks <italic>P</italic>, a vertex <italic>w</italic></p>
        <p id="Par90">Output: Updated set <italic>P</italic></p>
        <p id="Par91">1: <bold>for</bold> edges <italic>x</italic> ∈ <italic>E</italic>(<italic>G</italic>) ending at <italic>w</italic> not marked as used <bold>do</bold></p>
        <p id="Par92">2:      Let <italic>p</italic> ∈ <italic>P</italic> be a walk such that its <italic>b</italic>-extension <italic>q</italic> contains <italic>x</italic> and pos(end(<italic>p</italic>)) is maximized         ⊳ Find a walk extendable with <italic>x</italic></p>
        <p id="Par93">3:      <bold>if</bold> such <italic>p</italic> exists <bold>then</bold></p>
        <p id="Par94">4:         Truncate <italic>q</italic> so that end(<italic>q</italic>) = <italic>x</italic></p>
        <p id="Par95">5:         Append <italic>p</italic> with <italic>q</italic>         ⊳ Lengthen the chain that <italic>p</italic> forms with <italic>p</italic><sub>a</sub></p>
        <p id="Par96">6:     <bold>else</bold></p>
        <p id="Par97">7:        Add a new walk consisting of the edge <italic>x</italic> to <italic>P</italic></p>
        <p id="Par98">8: <bold>return</bold> <italic>P</italic></p>
      </boxed-text>
    </sec>
    <sec id="Sec17">
      <title>Other considerations</title>
      <p id="Par99">For simplicity of presentation, we have described the algorithm in terms of the ordinary de Bruijn graph; however, it is crucial for running time and memory usage that the graph is compacted first. Informally, the compacted de Bruijn graph replaces each non-branching path with a single edge. Formally, the vertex set of the compacted graph consists of vertices of the regular de Bruijn graph that have at least two outgoing (or ingoing) edges pointing at (incoming from) different vertices. Such vertices are called junctions. Let <italic>ℓ</italic> = <italic>v</italic><sub>1</sub>, …, <italic>v</italic><sub><italic>n</italic></sub> be the list of <italic>k</italic>-mers corresponding to junctions, in the order, they appear in the underlying string <italic>s</italic>. The edge set of the compacted graph consists of edges {<italic>v</italic><sub>1</sub> → <italic>v</italic><sub>2</sub>, <italic>v</italic><sub>2</sub> → <italic>v</italic><sub>3</sub>, …, <italic>v</italic><sub><italic>n</italic>−1</sub> → <italic>v</italic><sub><italic>n</italic></sub>}. We efficiently construct the compacted graph using our previously published algorithm TwoPaCo<sup><xref ref-type="bibr" rid="CR27">27</xref></sup>.</p>
      <p id="Par100">This transformation maintains all the information while greatly reducing the number of edges and vertices in the graph. This makes the data structures smaller and allows the algorithm to fast-forward through non-branching paths, instead of considering each (<italic>k</italic> + 1)-mer one by one. Our previous description of the algorithm remains valid, except that the data structures operate with vertices and edges from the compacted graph instead of the ordinary one. The only necessary change is that when we look for an edge <italic>y</italic> parallel to <italic>x</italic>, we must also check that <italic>y</italic> and <italic>x</italic> spell the same sequence. This is always true in an ordinary graph but not necessarily in a compacted graph.</p>
      <p id="Par101">An important challenge of mammalian genomes is that they contain high-frequency (<italic>k</italic> + 1)-mers, which can clog up our data structures. To handle this, we modify the algorithm by skipping over any junctions that correspond to <italic>k</italic>-mers occurring more than <italic>a</italic> times; we call <italic>a</italic> the abundance pruning parameter. Specifically, prior to constructing the edge set of the compacted de Bruijn graph, we remove all high abundance junctions from the vertex set. The edge set is constructed as before, but using this restricted list of junctions as the starting point. This strategy offers a way to handle high-frequency repeats at the expense of limiting our ability to detect homologous blocks that occur more than <italic>a</italic> times.</p>
      <p id="Par102">The organization of our data in memory is instrumental to achieving high performance. To represent the graph, we use a standard adjacency list representation, annotated with position information, and other relevant data. We also maintain a list of the junctions in the paragraph above in the order they appear in the input sequences, thereby supporting next() queries. The walks in the collinear block <italic>P</italic> are stored as a dynamic sorted set, implemented as a binary search tree. The search key is the genome/position for the end of each walk. This allows performing a binary search in line 2 of Algorithm Update-collinear-walks.</p>
      <p id="Par103">Another aspect that we have ignored up until now is that DNA is double-stranded and collinear walks can be reverse-complements of each other. If <italic>s</italic> is a string, then let <inline-formula id="IEq13"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\overline{s}$$\end{document}</tex-math><mml:math id="M30"><mml:mover accent="true"><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq13.gif"/></alternatives></inline-formula> be its reverse complement. We handle double strandedness in a natural way by using the comprehensive de Bruijn graph, which is defined as <inline-formula id="IEq14"><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${G}_{{\rm{comp}}}(s,k)=G(s,k)\cup G(\overline{s},k)$$\end{document}</tex-math><mml:math id="M32"><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">comp</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∪</mml:mo><mml:mi>G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq14.gif"/></alternatives></inline-formula><sup><xref ref-type="bibr" rid="CR27">27</xref></sup>. Our algorithm and corresponding data structures can be modified to work with the comprehensive graph with a few minor changes which we omit here.</p>
      <p id="Par104">Our implementation is parallelized by exploring multiple seeds simultaneously, i.e., parallelizing the for a loop at line 3 of Algorithm Find-collinear-blocks. This loop is not embarrassingly parallelizable, since two threads can start exploring two seeds belonging to the same carrying path. In such a case, there will be a collision on the data structure used to store used marks. To address this issue, we process the seeds in batches of fixed size. All the seeds within a batch are explored in parallel and the results are saved without modifying the “used” marks. Once the batch is processed, a single arbiter thread checks if there is any overlap in the used marks of the different threads. If there is, it identifies the sources of the conflict and reruns the algorithm at the conflicting seeds serially. Since most seeds do not yield valid carrying paths, such conflicts are rare. Once there is no conflict, the arbiter updates the used main data structures with the results of the batch. This design allows the computation result to be deterministic and independent of the number of threads used.</p>
    </sec>
    <sec id="Sec18">
      <title>Reporting summary</title>
      <p id="Par105">Further information on research design is available in the <xref rid="MOESM2" ref-type="media">Nature Research Reporting Summary</xref> linked to this article.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary information</title>
    <sec id="Sec19">
      <supplementary-material content-type="local-data" id="MOESM1">
        <media xlink:href="41467_2020_19777_MOESM1_ESM.pdf">
          <caption>
            <p>Supplementary Information</p>
          </caption>
        </media>
      </supplementary-material>
      <supplementary-material content-type="local-data" id="MOESM2">
        <media xlink:href="41467_2020_19777_MOESM2_ESM.pdf">
          <caption>
            <p>Reporting Summary</p>
          </caption>
        </media>
      </supplementary-material>
    </sec>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p><bold>Peer review information</bold> <italic>Nature Communications</italic> thanks the anonymous reviewers for their contribution to the peer review of this work.</p>
    </fn>
    <fn>
      <p><bold>Publisher’s note</bold> Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Supplementary information</title>
    <p><bold>Supplementary information</bold> is available for this paper at 10.1038/s41467-020-19777-8.</p>
  </sec>
  <ack>
    <title>Acknowledgements</title>
    <p>We would like to thank Mikhail Kolmogorov for useful suggestions on the empirical evaluation of our algorithm; Robert Harris for his help with running MultiZ; Son Pham for introducing us to the problem; and the Ensembl support team for helping us with retrieving the gene annotations.</p>
    <p>This work has been supported in part by NSF awards DBI-1356529, CCF-1439057, IIS-1453527, and IIS-1421908 to P.M. The research reported in this publication was supported by the National Institute Of General Medical Sciences of the National Institutes of Health under Award No. R01GM130691. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institutes of Health.</p>
  </ack>
  <notes notes-type="author-contribution">
    <title>Author contributions</title>
    <p>Conceptualization: I.M., Methodology: I.M. and P.M., Software: I.M., Validation: I.M. and P.M., Writing—original draft: I.M. and P.M., Writing—review and editing: I.M. and P.M., and Funding acquisition: P.M.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Data availability</title>
    <p>Table <xref rid="Tab1" ref-type="table">1</xref> contains the list of GenBank accession numbers of the mice genomes we used in our experiments (Figs. <xref rid="Fig3" ref-type="fig">3</xref> and <xref rid="Fig4" ref-type="fig">4</xref>, Supplementary Figs. <xref rid="MOESM1" ref-type="media">1</xref>–<xref rid="MOESM1" ref-type="media">3</xref>). The nine simulated datasets we generated (Supplementary Figs. <xref rid="MOESM1" ref-type="media">4</xref>–<xref rid="MOESM1" ref-type="media">6</xref>), ground-truth alignments for the mouse data (Fig. <xref rid="Fig4" ref-type="fig">4</xref>, Supplementary Figs. <xref rid="MOESM1" ref-type="media">1</xref>–<xref rid="MOESM1" ref-type="media">3</xref>), and alignments produced by SibeliaZ and Progressive Cactus (Fig. <xref rid="Fig4" ref-type="fig">4</xref>, Supplementary Figs. <xref rid="MOESM1" ref-type="media">2</xref> and <xref rid="MOESM1" ref-type="media">3</xref>) are available for download at <ext-link ext-link-type="uri" xlink:href="https://github.com/medvedevgroup/SibeliaZ/blob/master/DATA.txt">https://github.com/medvedevgroup/SibeliaZ/blob/master/DATA.txt</ext-link>.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Code availability</title>
    <p>Our tool is open source and freely available at <ext-link ext-link-type="uri" xlink:href="https://github.com/medvedevgroup/SibeliaZ">https://github.com/medvedevgroup/SibeliaZ</ext-link>.</p>
  </notes>
  <notes id="FPar1" notes-type="COI-statement">
    <title>Competing interests</title>
    <p id="Par106">The authors declare no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Earl</surname>
            <given-names>D</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Alignathon: a competitive assessment of whole-genome alignment methods</article-title>
        <source>Genome Res.</source>
        <year>2014</year>
        <volume>24</volume>
        <fpage>2077</fpage>
        <lpage>2089</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.174920.114</pub-id>
        <pub-id pub-id-type="pmid">25273068</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dewey</surname>
            <given-names>CN</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Evolution at the nucleotide level: the problem of multiple whole-genome alignment</article-title>
        <source>Hum. Mol. Genet.</source>
        <year>2006</year>
        <volume>15</volume>
        <fpage>R51</fpage>
        <lpage>R56</lpage>
        <pub-id pub-id-type="doi">10.1093/hmg/ddl056</pub-id>
        <pub-id pub-id-type="pmid">16651369</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>J. Mol. Biol.</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="doi">10.1016/S0022-2836(05)80360-2</pub-id>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Gapped blast and psi-blast: a new generation of protein database search programs</article-title>
        <source>Nucleic Acids Res.</source>
        <year>1997</year>
        <volume>25</volume>
        <fpage>3389</fpage>
        <lpage>3402</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/25.17.3389</pub-id>
        <pub-id pub-id-type="pmid">9254694</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schwartz</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Human–mouse alignments with blastz</article-title>
        <source>Genome Res.</source>
        <year>2003</year>
        <volume>13</volume>
        <fpage>103</fpage>
        <lpage>107</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.809403</pub-id>
        <pub-id pub-id-type="pmid">12529312</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <mixed-citation publication-type="other">Harris, R. S. <italic>Improved Pairwise Alignment of Genomic DNA.</italic> (The Pennsylvania State University, 2007).</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kent</surname>
            <given-names>WJ</given-names>
          </name>
        </person-group>
        <article-title>Blat—the blast-like alignment tool</article-title>
        <source>Genome Res.</source>
        <year>2002</year>
        <volume>12</volume>
        <fpage>656</fpage>
        <lpage>664</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.229202</pub-id>
        <pub-id pub-id-type="pmid">11932250</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Blanchette</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Aligning multiple genomic sequences with the threaded blockset aligner</article-title>
        <source>Genome Res.</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>708</fpage>
        <lpage>715</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.1933104</pub-id>
        <pub-id pub-id-type="pmid">15060014</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dubchak</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Poliakov</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Kislyuk</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Multiple whole-genome alignments without a reference organism</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>682</fpage>
        <lpage>689</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.081778.108</pub-id>
        <pub-id pub-id-type="pmid">19176791</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Angiuoli</surname>
            <given-names>SV</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Mugsy: fast multiple alignment of closely related whole genomes</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>334</fpage>
        <lpage>342</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq665</pub-id>
        <pub-id pub-id-type="pmid">21148543</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Paten</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Cactus: algorithms for genome multiple sequence alignment</article-title>
        <source>Genome Res.</source>
        <year>2011</year>
        <volume>21</volume>
        <fpage>1512</fpage>
        <lpage>1528</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.123356.111</pub-id>
        <pub-id pub-id-type="pmid">21665927</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lilue</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Sixteen diverse laboratory mouse reference genomes define strain-specific haplotypes and novel functional loci</article-title>
        <source>Nat. Genet.</source>
        <year>2018</year>
        <volume>50</volume>
        <fpage>1574</fpage>
        <pub-id pub-id-type="doi">10.1038/s41588-018-0223-8</pub-id>
        <pub-id pub-id-type="pmid">30275530</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Darling</surname>
            <given-names>AC</given-names>
          </name>
          <name>
            <surname>Mau</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Blattner</surname>
            <given-names>FR</given-names>
          </name>
          <name>
            <surname>Perna</surname>
            <given-names>NT</given-names>
          </name>
        </person-group>
        <article-title>Mauve: multiple alignment of conserved genomic sequence with rearrangements</article-title>
        <source>Genome Res.</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>1394</fpage>
        <lpage>1403</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.2289704</pub-id>
        <pub-id pub-id-type="pmid">15231754</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <mixed-citation publication-type="other">Dewey, C. N. <italic>Aligning Multiple Whole Genomes with Mercator and MAVID</italic>. 221–235 (Humana Press, Totowa, NJ, 2008).</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Paten</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Herrero</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Beal</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Fitzgerald</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Enredo and pecan: genome-wide mammalian consistency-based multiple alignment with paralogs</article-title>
        <source>Genome Res.</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>1814</fpage>
        <lpage>1828</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.076554.108</pub-id>
        <pub-id pub-id-type="pmid">18849524</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Darling</surname>
            <given-names>AE</given-names>
          </name>
          <name>
            <surname>Mau</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Perna</surname>
            <given-names>NT</given-names>
          </name>
        </person-group>
        <article-title>Progressivemauve: multiple genome alignment with gene gain, loss and rearrangement</article-title>
        <source>PloS ONE</source>
        <year>2010</year>
        <volume>5</volume>
        <fpage>e11147</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0011147</pub-id>
        <pub-id pub-id-type="pmid">20593022</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <mixed-citation publication-type="other">Minkin, I., Pham, H., Starostina, E., Vyahhi, N. &amp; Pham, S. C-sibelia: an easy-to-use and highly accurate tool for bacterial genome comparison. <italic>F1000Research</italic><ext-link ext-link-type="uri" xlink:href="https://f1000research.com/articles/2-258">https://f1000research.com/articles/2-258</ext-link> (2013).</mixed-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <mixed-citation publication-type="other">Myers, G. &amp; Miller, W. Chaining multiple-alignment fragments in sub-quadratic time. in <italic>Proceedings of the Sixth Annual ACM-SIAM Symposium on Discrete Algorithms</italic>, SODA ’95, 38–47 (Society for Industrial and Applied Mathematics, USA, 1995).</mixed-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abouelhoda</surname>
            <given-names>MI</given-names>
          </name>
          <name>
            <surname>Ohlebusch</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Chaining algorithms for multiple genome comparison</article-title>
        <source>J. Discret. Algorithms</source>
        <year>2005</year>
        <volume>3</volume>
        <fpage>321</fpage>
        <lpage>341</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jda.2004.08.011</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <mixed-citation publication-type="other">Ohlebusch, E. &amp; Abouelhoda, M. I. <italic>Chaining Algorithms and Applications in Comparative Genomics</italic>. (Handbook of Computational Molecular Biology, 2006).</mixed-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Raphael</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Zhi</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>A novel method for multiple alignment of sequences with repeated and shuffled elements</article-title>
        <source>Genome Res.</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>2336</fpage>
        <lpage>2346</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.2657504</pub-id>
        <pub-id pub-id-type="pmid">15520295</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pham</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Drimm-synteny: decomposing genomes into evolutionary conserved segments</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>2509</fpage>
        <lpage>2516</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq465</pub-id>
        <pub-id pub-id-type="pmid">20736338</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <mixed-citation publication-type="other">Minkin, I., Patel, A., Kolmogorov, M., Vyahhi, N. &amp; Pham, S. Sibelia: A scalable and comprehensive synteny block generation tool for closely related microbial genomes. in (eds Darling, A. &amp; Stoye, J.) <italic>Algorithms in Bioinformatics</italic>. 215–229 (Springer Berlin Heidelberg, Berlin, Heidelberg, 2013).</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Marcus</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Schatz</surname>
            <given-names>MC</given-names>
          </name>
        </person-group>
        <article-title>Splitmem: a graphical algorithm for pan-genome analysis with suffix skips</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>3476</fpage>
        <lpage>3483</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu756</pub-id>
        <pub-id pub-id-type="pmid">25398610</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Limasset</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Medvedev</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Compacting de bruijn graphs from sequencing data quickly and in low memory</article-title>
        <source>Bioinformatics</source>
        <year>2016</year>
        <volume>32</volume>
        <fpage>i201</fpage>
        <lpage>i208</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btw279</pub-id>
        <pub-id pub-id-type="pmid">27307618</pub-id>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Baier</surname>
            <given-names>U</given-names>
          </name>
          <name>
            <surname>Beller</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Ohlebusch</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Graphical pan-genome analysis with compressed suffix trees and the burrows-wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2016</year>
        <volume>32</volume>
        <fpage>497</fpage>
        <lpage>504</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv603</pub-id>
        <pub-id pub-id-type="pmid">26504144</pub-id>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Minkin</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Pham</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Medvedev</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Twopaco: an efficient algorithm to build the compacted de bruijn graph from many complete genomes</article-title>
        <source>Bioinformatics</source>
        <year>2017</year>
        <volume>33</volume>
        <fpage>4024</fpage>
        <lpage>4032</lpage>
        <?supplied-pmid 27659452?>
        <pub-id pub-id-type="pmid">27659452</pub-id>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28.</label>
      <mixed-citation publication-type="other">Cleary, A., Kahanda, I., Mumey, B., Mudge, J. &amp; Ramaraj, T. Exploring frequented regions in pan-genomic graphs. in <italic>Proceedings of the 8th ACM International Conference on Bioinformatics, Computational Biology, and Health Informatics</italic>, 89–97 (Association for Computing Machinery, New York, NY, USA, 2017).</mixed-citation>
    </ref>
    <ref id="CR29">
      <label>29.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Vaser</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Sović</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Nagarajan</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Šikić</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate de novo genome assembly from long uncorrected reads</article-title>
        <source>Genome Res.</source>
        <year>2017</year>
        <volume>27</volume>
        <fpage>737</fpage>
        <lpage>746</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.214270.116</pub-id>
        <pub-id pub-id-type="pmid">28100585</pub-id>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sayers</surname>
            <given-names>EW</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>GenBank</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2019</year>
        <volume>48</volume>
        <fpage>D84</fpage>
        <lpage>D86</lpage>
      </element-citation>
    </ref>
    <ref id="CR31">
      <label>31.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Lagan and multi-lagan: efficient tools for large-scale multiple alignment of genomic dna</article-title>
        <source>Genome Res.</source>
        <year>2003</year>
        <volume>13</volume>
        <fpage>721</fpage>
        <lpage>731</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.926603</pub-id>
        <pub-id pub-id-type="pmid">12654723</pub-id>
      </element-citation>
    </ref>
    <ref id="CR32">
      <label>32.</label>
      <mixed-citation publication-type="other">Perry, E. Personal communication (2018).</mixed-citation>
    </ref>
    <ref id="CR33">
      <label>33.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tajima</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Statistical method for testing the neutral mutation hypothesis by dna polymorphism</article-title>
        <source>Genetics</source>
        <year>1989</year>
        <volume>123</volume>
        <fpage>585</fpage>
        <lpage>595</lpage>
        <?supplied-pmid 1203831?>
        <pub-id pub-id-type="pmid">2513255</pub-id>
      </element-citation>
    </ref>
    <ref id="CR34">
      <label>34.</label>
      <mixed-citation publication-type="other">Armstrong, J. et al. Progressive alignment with cactus: a multiple-genome aligner for the thousand-genome era. Preprint at <ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/early/2019/10/15/730531">https://www.biorxiv.org/content/early/2019/10/15/730531</ext-link> (2019).</mixed-citation>
    </ref>
    <ref id="CR35">
      <label>35.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Paten</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Cactus graphs for genome comparisons</article-title>
        <source>J. Comput. Biol.</source>
        <year>2011</year>
        <volume>18</volume>
        <fpage>469</fpage>
        <lpage>481</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2010.0252</pub-id>
        <pub-id pub-id-type="pmid">21385048</pub-id>
      </element-citation>
    </ref>
    <ref id="CR36">
      <label>36.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Fiddes</surname>
            <given-names>IT</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Comparative annotation toolkit (cat)-simultaneous clade and personal genome annotation</article-title>
        <source>Genome Res.</source>
        <year>2018</year>
        <volume>28</volume>
        <fpage>1029</fpage>
        <lpage>1038</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.233460.117</pub-id>
        <pub-id pub-id-type="pmid">29884752</pub-id>
      </element-citation>
    </ref>
    <ref id="CR37">
      <label>37.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schwartz</surname>
            <given-names>AS</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Multiple alignment by sequence annealing</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <fpage>e24</fpage>
        <lpage>e29</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl311</pub-id>
        <pub-id pub-id-type="pmid">17237099</pub-id>
      </element-citation>
    </ref>
    <ref id="CR38">
      <label>38.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sakharkar</surname>
            <given-names>MK</given-names>
          </name>
          <name>
            <surname>Perumal</surname>
            <given-names>BS</given-names>
          </name>
          <name>
            <surname>Sakharkar</surname>
            <given-names>KR</given-names>
          </name>
          <name>
            <surname>Kangueane</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>An analysis on gene architecture in human and mouse genomes</article-title>
        <source>Silico Biol.</source>
        <year>2005</year>
        <volume>5</volume>
        <fpage>347</fpage>
        <lpage>365</lpage>
      </element-citation>
    </ref>
    <ref id="CR39">
      <label>39.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pevzner</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Human and mouse genomic sequences reveal extensive breakpoint reuse in mammalian evolution</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2003</year>
        <volume>100</volume>
        <fpage>7672</fpage>
        <lpage>7677</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.1330369100</pub-id>
        <pub-id pub-id-type="pmid">12810957</pub-id>
      </element-citation>
    </ref>
    <ref id="CR40">
      <label>40.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Reconstruction and evolutionary history of eutherian chromosomes</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2017</year>
        <volume>114</volume>
        <fpage>E5379</fpage>
        <lpage>E5388</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.1702012114</pub-id>
        <pub-id pub-id-type="pmid">28630326</pub-id>
      </element-citation>
    </ref>
    <ref id="CR41">
      <label>41.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Luo</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Phylogenetic analysis of genome rearrangements among five mammalian orders</article-title>
        <source>Mol. Phylogenet. Evolut.</source>
        <year>2012</year>
        <volume>65</volume>
        <fpage>871</fpage>
        <lpage>882</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ympev.2012.08.008</pub-id>
      </element-citation>
    </ref>
    <ref id="CR42">
      <label>42.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kolmogorov</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Chromosome assembly of large and complex genomes using multiple references</article-title>
        <source>Genome Res.</source>
        <year>2018</year>
        <volume>28</volume>
        <fpage>1720</fpage>
        <lpage>1732</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.236273.118</pub-id>
        <pub-id pub-id-type="pmid">30341161</pub-id>
      </element-citation>
    </ref>
    <ref id="CR43">
      <label>43.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Reference-assisted chromosome assembly</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2013</year>
        <volume>110</volume>
        <fpage>1785</fpage>
        <lpage>1790</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.1220349110</pub-id>
        <pub-id pub-id-type="pmid">23307812</pub-id>
      </element-citation>
    </ref>
    <ref id="CR44">
      <label>44.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kolmogorov</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Raney</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Paten</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Pham</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Ragout—a reference-assisted assembly tool for bacterial genomes</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>i302</fpage>
        <lpage>i309</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu280</pub-id>
        <pub-id pub-id-type="pmid">24931998</pub-id>
      </element-citation>
    </ref>
    <ref id="CR45">
      <label>45.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>K-T</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Multi-car: a tool of contig scaffolding using multiple references</article-title>
        <source>BMC Bioinform.</source>
        <year>2016</year>
        <volume>17</volume>
        <fpage>469</fpage>
        <pub-id pub-id-type="doi">10.1186/s12859-016-1328-7</pub-id>
      </element-citation>
    </ref>
    <ref id="CR46">
      <label>46.</label>
      <mixed-citation publication-type="other">Aganezov, S. &amp; Alekseyev, M. A. Multi-genome scaffold co-assembly based on the analysis of gene orders and genomic repeats. in (eds Bourgeois, A., Skums, P., Wan, X. &amp; Zelikovsky, A.) <italic>Bioinformatics Research and Applications.</italic> 237–249 (Springer International Publishing, Cham, 2016).</mixed-citation>
    </ref>
    <ref id="CR47">
      <label>47.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Proost</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>i-adhore 3.0—fast and sensitive detection of genomic homology in extremely large data sets</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2011</year>
        <volume>40</volume>
        <fpage>e11</fpage>
        <lpage>e11</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkr955</pub-id>
        <pub-id pub-id-type="pmid">22102584</pub-id>
      </element-citation>
    </ref>
    <ref id="CR48">
      <label>48.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Portwood</surname>
            <given-names>JL</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Maizegdb 2018: the maize multi-genome genetics and genomics database</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2018</year>
        <volume>47</volume>
        <fpage>D1146</fpage>
        <lpage>D1154</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gky1046</pub-id>
      </element-citation>
    </ref>
    <ref id="CR49">
      <label>49.</label>
      <mixed-citation publication-type="other">Onodera, T., Sadakane, K. &amp; Shibuya, T. Detecting superbubbles in assembly graphs. in (eds Darling, A. &amp; Stoye, J.) <italic>Algorithms in Bioinformatics</italic>. 338–348 (Springer Berlin Heidelberg, Berlin, Heidelberg, 2013).</mixed-citation>
    </ref>
    <ref id="CR50">
      <label>50.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sung</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Sadakane</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Shibuya</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Belorkar</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Pyrogova</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <article-title>An <inline-formula id="IEq15"><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathcal{O}}(m\mathrm{log}\,m)$$\end{document}</tex-math><mml:math id="M34"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mspace width="0.25em"/><mml:mi>m</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2020_19777_Article_IEq15.gif"/></alternatives></inline-formula>-time algorithm for detecting superbubbles</article-title>
        <source>IEEE/ACM Trans. Comput. Biol. Bioinform.</source>
        <year>2015</year>
        <volume>12</volume>
        <fpage>770</fpage>
        <lpage>777</lpage>
        <pub-id pub-id-type="doi">10.1109/TCBB.2014.2385696</pub-id>
        <pub-id pub-id-type="pmid">26357315</pub-id>
      </element-citation>
    </ref>
    <ref id="CR51">
      <label>51.</label>
      <mixed-citation publication-type="other">Iliopoulos, C. S., Kundu, R., Mohamed, M. &amp; Vayani, F. Popping superbubbles and discovering clumps: Recent developments in biological sequence analysis. in (eds Kaykobad, M. &amp; Petreschi, R.) <italic>WALCOM: Algorithms and Computation</italic>. 3–14 (Springer International Publishing, Cham, 2016).</mixed-citation>
    </ref>
    <ref id="CR52">
      <label>52.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brankovic</surname>
            <given-names>L</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Linear-time superbubble identification algorithm for genome assembly</article-title>
        <source>Theor. Comput. Sci.</source>
        <year>2016</year>
        <volume>609</volume>
        <fpage>374</fpage>
        <lpage>383</lpage>
        <pub-id pub-id-type="doi">10.1016/j.tcs.2015.10.021</pub-id>
      </element-citation>
    </ref>
    <ref id="CR53">
      <label>53.</label>
      <mixed-citation publication-type="other">Paten, B., Novak, A. M., Garrison, E. &amp; Hickey, G. Superbubbles, ultrabubbles and cacti. in (ed Sahinalp, S. C.) <italic>Research in Computational Molecular Biology</italic>. 173–189 (Springer International Publishing, Cham, 2017).</mixed-citation>
    </ref>
  </ref-list>
</back>
