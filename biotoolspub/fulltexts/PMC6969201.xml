<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Sci Rep</journal-id>
    <journal-id journal-id-type="iso-abbrev">Sci Rep</journal-id>
    <journal-title-group>
      <journal-title>Scientific Reports</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2045-2322</issn>
    <publisher>
      <publisher-name>Nature Publishing Group UK</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6969201</article-id>
    <article-id pub-id-type="pmid">31953467</article-id>
    <article-id pub-id-type="publisher-id">57452</article-id>
    <article-id pub-id-type="doi">10.1038/s41598-020-57452-6</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>FQSqueezer: <italic>k</italic>-mer-based compression of sequencing data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-9496-733X</contrib-id>
        <name>
          <surname>Deorowicz</surname>
          <given-names>Sebastian</given-names>
        </name>
        <address>
          <email>sebastian.deorowicz@polsl.pl</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2335 3149</institution-id><institution-id institution-id-type="GRID">grid.6979.1</institution-id><institution>Faculty of Automatic Control, Electronics and Computer Science, Silesian University of Technology, </institution></institution-wrap>Akademicka 16, 44-100 Gliwice, Poland </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>17</day>
      <month>1</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>17</day>
      <month>1</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>10</volume>
    <elocation-id>578</elocation-id>
    <history>
      <date date-type="received">
        <day>7</day>
        <month>6</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>19</day>
        <month>12</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The images or other third party material in this article are included in the article’s Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the article’s Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this license, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p id="Par1">The amount of data produced by modern sequencing instruments that needs to be stored is huge. Therefore it is not surprising that a lot of work has been done in the field of specialized data compression of FASTQ files. The existing algorithms are, however, still imperfect and the best tools produce quite large archives. We present FQSqueezer, a novel compression algorithm for sequencing data able to process single- and paired-end reads of variable lengths. It is based on the ideas from the famous prediction by partial matching and dynamic Markov coder algorithms known from the general-purpose-compressors world. The compression ratios are often tens of percent better than offered by the state-of-the-art tools. The drawbacks of the proposed method are large memory and time requirements.</p>
    </abstract>
    <kwd-group kwd-group-type="npg-subject">
      <title>Subject terms</title>
      <kwd>Data processing</kwd>
      <kwd>Software</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">https://doi.org/10.13039/501100004281</institution-id>
            <institution>Narodowe Centrum Nauki (National Science Centre)</institution>
          </institution-wrap>
        </funding-source>
        <award-id>DEC-2015/17/B/ST6/01890</award-id>
        <principal-award-recipient>
          <name>
            <surname>Deorowicz</surname>
            <given-names>Sebastian</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">https://doi.org/10.13039/501100005632</institution-id>
            <institution>Ministry of Science and Higher Education | Narodowe Centrum Badań i Rozwoju (National Centre for Research and Development)</institution>
          </institution-wrap>
        </funding-source>
        <award-id>POIG.02.03.01-24-099/13</award-id>
        <principal-award-recipient>
          <name>
            <surname>Deorowicz</surname>
            <given-names>Sebastian</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1" sec-type="introduction">
    <title>Introduction</title>
    <p id="Par2">In the recent years, genome sequencing has became a mature technology with numerous applications in the medicine. The instruments by Illumina (encountered to the 2nd generation of sequencers) produce majority of available data for little money (e.g., about one thousand of U.S. dollars for whole human genome sequencing). The sequenced reads are relatively short (up to a few hundreds of bases) but are of high quality. The 3rd generation instruments by PacBio or Oxford Nanopore can deliver much longer reads but unfortunately of much worse quality and at much lower throughput.</p>
    <p id="Par3">The estimations of the amount of genomic data and the related costs can be found in the studies like<sup><xref ref-type="bibr" rid="CR1">1</xref>,<xref ref-type="bibr" rid="CR2">2</xref></sup>. The presented huge numbers directly lead to the conclusion that in the near future just a storage and transfer of sequenced (and mapped) reads will consume a lot of money and could be a dominant factor in total costs related to sequencing. Therefore, it is not surprising that a lot of research was made to overcome this problem. The obvious first step was application of gzip, a general-purpose compressor. The about 3-fold reduction of files was remarkable, but the data deluge asked for more. The main problem of gzip is that it was designed mainly for textual data, or more precisely, for data with textual-like redundancy types. Unfortunately things like repetitions of parts of data at short distances are uncommon in read collections.</p>
    <p id="Par4">The next step was an invention of specialized algorithms taking into account types of redundancies specific for FASTQ files<sup><xref ref-type="bibr" rid="CR3">3</xref></sup>. Some of the most important early results were presented in<sup><xref ref-type="bibr" rid="CR4">4</xref>–<xref ref-type="bibr" rid="CR7">7</xref></sup>. The details of the proposed algorithms were different, but in general the authors tried (with some exceptions) to compress the reads locally, i.e., not looking for the large-scale relations between the reads. The reason was rather simple and practical: the amounts of memory necessary to construct a dictionary data structure allowing to find overlaps between reads could be a few times larger than the input file size, e.g., hundreds of GB for human genomes. The improvement over gzip was, however, limited. For example, the best algorithms were able to reduce the space necessary for DNA bases about 5 times. This value should be compared to 4-fold reduction by simple spending 2 bits to distinguish among 4 valid bases. Moreover, it appeared that the compression of quality values was even more problematic.</p>
    <p id="Par5">This situation motivated researchers to look for alternatives. At the beginning, they focused just on the compression of bases. The key idea was to reorder the data to gather reads originating from close regions of genomes. This could seem as a loss of information, but as the original ordering of reads in a FASTQ file is usually more or less random one can argue that it is hard to say which of two random orderings is better (and even how we can define what “better” means here). The first notable attempt into this direction was described in<sup><xref ref-type="bibr" rid="CR8">8</xref></sup>. The authors introduced a variant of the Burrows–Wheeler transform to find overlaps between reads. For human reads with 40-fold coverage they were able to spend about 0.5 bits per base, which was a significant improvement.</p>
    <p id="Par6">In the following years, other researchers explored the concept of using minimizers<sup><xref ref-type="bibr" rid="CR9">9</xref></sup>, i.e., short, lexicographically smallest, substrings of sequences, to find reads from close regions. The key observation was that if two reads originate from the close regions of a genome their minimizers are usually the same. Thus, the reads can be grouped by their minimizers. In the first work following this idea<sup><xref ref-type="bibr" rid="CR10">10</xref></sup>, for the mentioned human dataset it was sufficient to use about 0.3 bits per base. A similar result was obtained later in<sup><xref ref-type="bibr" rid="CR11">11</xref></sup>. The possible gains were, however, limited by the fact that the reads identified to originate from the same genome region could span no more than two read lengths.</p>
    <p id="Par7">In<sup><xref ref-type="bibr" rid="CR12">12</xref></sup>, it was shown how to group reads from a bit larger genome regions. Significantly better results were, however, obtained in three recent articles presenting HARC<sup><xref ref-type="bibr" rid="CR13">13</xref></sup>, Spring<sup><xref ref-type="bibr" rid="CR14">14</xref></sup>, and Minicom<sup><xref ref-type="bibr" rid="CR15">15</xref></sup>. The attempts differ in details, but are based on similar ideas. The overlaps are found for much larger genome regions (in theory up to chromosome size) thanks to dictionary structures storing minimizers of parts of reads. What is also worth to mention, FaStore<sup><xref ref-type="bibr" rid="CR12">12</xref></sup> and Spring<sup><xref ref-type="bibr" rid="CR14">14</xref></sup> do not focus just on DNA bases and they can compress also the complete FASTQ files.</p>
    <p id="Par8">Together with improving the compression ratio for DNA symbols, the quality scores became responsible for a dominant part of the compressed archives. Therefore a number of works focused on this problem. One of the simplest strategies was to reduce the resolution of quality scores. Illumina in their HiSeq sequencers restricted the quality scores to eight values, and then in the NovaSeq instruments to just four values. The rational for these decisions was that the quality of sequencing is currently very good and the prices of sequencing are low. Therefore, if necessary, it is easier (and cheaper) to perform sequencing with a bit larger coverage than store high-resolution quality scores. The recent experiments suggest that reduction of quality score resolution has very little (if any) impact on the quality of variant calling. For example, in<sup><xref ref-type="bibr" rid="CR12">12</xref></sup> it was shown that even more aggressive reduction to just two quality values can be justified, at least in some situations. Moreover, there are several algorithms like QVZ<sup><xref ref-type="bibr" rid="CR16">16</xref>,<xref ref-type="bibr" rid="CR17">17</xref></sup> and Crumble<sup><xref ref-type="bibr" rid="CR18">18</xref></sup> that perform advanced analysis of quality scores to preserve only the most important information.</p>
    <p id="Par9">In this article, we propose a novel compression algorithm for FASTQ files. The main novelty is in the compression of DNA bases, as for quality scores and read identifiers we follow similar strategies as in the state-of-the-art tools. Our algorithm, FQSqueezer, make use of the ideas from the prediction by partial matching (PPM)<sup><xref ref-type="bibr" rid="CR19">19</xref>,<xref ref-type="bibr" rid="CR20">20</xref></sup> and dynamic Markov coder (DMC)<sup><xref ref-type="bibr" rid="CR21">21</xref></sup> general-purpose methods. A direct adaptation of the PPM-like strategy to sequencing reads would be, however, very hard and likely unsuccessful. There are at least four main reasons for that. First, in the ideal case, the PPM algorithm should construct a dictionary of all already seen strings of length up to some threshold, significantly larger than log<sub>4</sub> (<italic>genome</italic>_<italic>size</italic>), which for human genomes seems to be unimplementable on workstations and even medium-sized servers. Second, the PPM algorithms often need many accesses to the main memory to compress a single symbol. For huge dictionaries this could result in a very slow processing (due to cache-misses). Third, sequenced data contain errors that should be corrected to refrain from expansion of the dictionary structures. Fourth, the PPM algorithms usually learn slowly, which is a good strategy for texts, but seems to be bad for genomic data.</p>
    <p id="Par10">To overcome these problems we designed a few fixed-<italic>k</italic> dictionaries for <italic>k</italic>-mers (<italic>k</italic>-symbol long substrings) found in the reads. Moreover, the dictionaries are organized in a way reducing the number of cache misses. We also estimate the probability of symbols occurrence much more aggressively, which results in significantly better compression (compared to classical PPM-like estimation). Finally, for the storage of <italic>k</italic>-mers in the dictionaries we perform some kind of error correction.</p>
    <p id="Par11">The proposed ideas has some similarity to earlier works. For example, some correction of bases was employed in AssembleTrie<sup><xref ref-type="bibr" rid="CR22">22</xref></sup>. The authors used it, however, just to “synchronize” reads from both strands (forward and reverse). Formerly, in GeCo<sup><xref ref-type="bibr" rid="CR23">23</xref></sup> a similar correction was used to improve context determination in the field of genomic (complete genomes, chromosomes, contigs) data compression. The estimation of the probability of appearance of the current symbol based on <italic>k</italic>-mers of some size (much smaller than in our solution due to huge memory requirements of the picked dictionary implementation) was used in Fqzcomp<sup><xref ref-type="bibr" rid="CR4">4</xref></sup>. Modeling the genomic data (genomes, chromosomes, contigs) as a Markov source was studied by Pinho <italic>et al</italic>.<sup><xref ref-type="bibr" rid="CR24">24</xref>,<xref ref-type="bibr" rid="CR25">25</xref></sup>. It is, however, worth to emphasis the differences between compression of sequencing reads and collections of longer genomic fragments, e.g., contigs, chromosomes, genomes. The longer (assembled) fragments are of much better quality than reads, so small differences between very similar fragments are usually due to variations between organisms and they are expected. In sequencing datasets, we usually work with reads originating from a single genome and the differences between very similar fragments are in majority due to sequencing errors. Some of them (minority) are also due to diploid structure of some genomes. Even in case of metagenomic studies, when the reads are from many genomes, a significant part of the differences are due to sequencing errors. Therefore, a compressor of sequencing data should be designed in a different way than a compressor of assembled genomes or its parts. They also should not be compared directly in practice as they were designed for solving different tasks.</p>
    <p id="Par12">In the present article, we significantly improved the mentioned ideas, as well as, proposed other techniques. The most important ones are: the organization of the huge dictionaries, design of the PPM-like estimation of probabilities, use of a custom DMC as the stage following the PPM, the technique for prediction and correction of sequencing errors, technique of ordering the reads and making use of shared prefixes. What is also important, we developed the complete FASTQ compressors.</p>
    <p id="Par13">The main asset of FQSqueezer is its compression ratio, usually much better than of the state-of-the-art competitors, i.e., FaStore<sup><xref ref-type="bibr" rid="CR12">12</xref></sup>, Spring<sup><xref ref-type="bibr" rid="CR14">14</xref></sup>, and Minicom<sup><xref ref-type="bibr" rid="CR15">15</xref></sup>. Our tool has, however, also some drawbacks in terms of speed and memory usage. Namely, it is a few times slower than the mentioned competitors in compression and much slower in decompression.</p>
  </sec>
  <sec id="Sec2" sec-type="results">
    <title>Results</title>
    <sec id="Sec3">
      <title>Tools and datasets</title>
      <p id="Par14">For the evaluation we used the state-of-the-art competitors, i.e., FaStore<sup><xref ref-type="bibr" rid="CR12">12</xref></sup>, Spring<sup><xref ref-type="bibr" rid="CR14">14</xref></sup>, and Minicom<sup><xref ref-type="bibr" rid="CR15">15</xref></sup>. We resigned from testing some other good compressors like BEETL<sup><xref ref-type="bibr" rid="CR8">8</xref></sup>, Orcom<sup><xref ref-type="bibr" rid="CR10">10</xref></sup>, AssembleTrie<sup><xref ref-type="bibr" rid="CR22">22</xref></sup>, and HARC<sup><xref ref-type="bibr" rid="CR13">13</xref></sup> as the previous works demonstrated that they perform worse than the picked tools. The older utilities are not competitive in terms of compression ratio, as was demonstrated in the recent papers<sup><xref ref-type="bibr" rid="CR12">12</xref>,<xref ref-type="bibr" rid="CR14">14</xref></sup> (see also Table <xref rid="Tab1" ref-type="table">1</xref> for experiments with one of our datasets). Some of them are very fast, e.g., DSRC 2<sup><xref ref-type="bibr" rid="CR7">7</xref></sup>. Nevertheless, in this article we focus mainly on the compression ratio.<table-wrap id="Tab1"><label>Table 1</label><caption><p>Comparison of compression ratios and running times of selected general-purpose compressors and FASTQ-specialized compressors.</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Compressor</th><th>Comp. size [MB]</th><th>Comp. time [s]</th><th>RAM in comp. [MB]</th><th>Decomp. time [s]</th><th>RAM in decomp. [MB]</th></tr></thead><tbody><tr><td>pigz</td><td>3,392</td><td>128</td><td><bold>10</bold></td><td>54</td><td><bold>2</bold></td></tr><tr><td>7z</td><td>2,710</td><td>2,438</td><td>5,592</td><td>220</td><td>71</td></tr><tr><td>zstd</td><td>3,335</td><td>828</td><td>48</td><td>35</td><td>4</td></tr><tr><td>brotli</td><td>3,186</td><td>6,214</td><td>100</td><td>78</td><td>4</td></tr><tr><td>DSRC 2</td><td>2,273</td><td><bold>55</bold></td><td>3,997</td><td>56</td><td>2,739</td></tr><tr><td>FQZcomp</td><td>1,990</td><td>287</td><td>283</td><td>385</td><td>581</td></tr><tr><td>NAF<sup><xref ref-type="bibr" rid="CR27">27</xref></sup></td><td>2,173</td><td>12,885</td><td>4,620</td><td>60</td><td>3,799</td></tr><tr><td>Spring</td><td>1,650</td><td>159</td><td>1,735</td><td><bold>24</bold></td><td>975</td></tr><tr><td>FQSqueezer</td><td><bold>1,511</bold></td><td>1,409</td><td>19,489</td><td>1,501</td><td>19,467</td></tr></tbody></table><table-wrap-foot><p>The dataset ERR532393_1 (complete FASTQ file) of size 9.64GB was used. The original ordering of reads were preserved.</p></table-wrap-foot></table-wrap></p>
      <p id="Par15">The datasets for experiments were taken from the previous studies. They are characterized in Supplementary Table <xref rid="MOESM1" ref-type="media">1</xref>. In the main part of the article, we used 9 datasets but more results can be found in the Supplementary Worksheet. Unfortunately, some compressors do not support all the examined modes, which is a reason of lack of their results in some tables.</p>
      <p id="Par16">All experiments were run at workstation equipped with two Intel Xeon E5-2670 v3 CPUs (2 × 12 double-threaded 2.3 GHz cores), 256 GB of RAM, and six 1 TB HDDs in RAID-5. If not stated explicitly the programs were run with 12 threads.</p>
    </sec>
    <sec id="Sec4">
      <title>Compression of the bases</title>
      <p id="Par17">The most important part of the present work is the compression of bases. Therefore, in the first experiment we evaluated the tools in this scenario. The results for the single-end (SE) reads are given in Table <xref rid="Tab2" ref-type="table">2</xref>. The ratios are in output bits per input base. As it is easy to observe, in the majority of cases FQSqueezer outperforms the competitors. For some datasets the gain is large. Nevertheless, for two datasets FQSqueezer loses to Minicom in the original-order-preserving (OO) mode. We investigated this situation a bit closer by checking whether the compression ratio will depend on the initial ordering of the reads. When we shuffled the reads prior to compression, the compression ratios for SRR1265495_1 and SRR1265496_1 changed significantly for all the examined compressors, i.e., 0.632 → 0.531 and 0.646 → 0.527 (Spring), 0.448 → 0.539 and 0.484 → 0.568 (Minicom), 0.506 → 0.472 and 0.517 → 0.487 (FQSqueezer). This shows that the initial ordering of the reads in these datasets is far from random and Minicom can benefit from this. In the mode allowing reordering of the reads (REO), FQSqueezer always wins. Moreover, the compression ratios are roughly twice better than in the OO mode for all the examined methods.<table-wrap id="Tab2"><label>Table 2</label><caption><p>Compression ratios for single-end reads.</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">Dataset</th><th rowspan="2">Size [Gbp]</th><th colspan="4">Original ordering</th><th colspan="5">Reordered</th></tr><tr><th>Spring</th><th>Minicom</th><th>FQSqueezer</th><th>Gain</th><th>FaStore</th><th>Spring</th><th>Minicom</th><th>FQSqueezer</th><th>Gain</th></tr></thead><tbody><tr><td>ERR174310_1</td><td>20.97</td><td>0.696</td><td>0.857</td><td><bold>0.649</bold></td><td>7.4</td><td>0.593</td><td>0.408</td><td>0.589</td><td><bold>0.396</bold></td><td>3.1</td></tr><tr><td>ERR532393_1</td><td>3.58</td><td>0.667</td><td>0.647</td><td><bold>0.528</bold></td><td>22.5</td><td>0.482</td><td>0.433</td><td>0.410</td><td><bold>0.294</bold></td><td>39.3</td></tr><tr><td>SRR327342_1</td><td>0.95</td><td>0.524</td><td>0.538</td><td><bold>0.488</bold></td><td>7.4</td><td>0.267</td><td>0.158</td><td>0.166</td><td><bold>0.142</bold></td><td>11.3</td></tr><tr><td>SRR554369_1</td><td>0.17</td><td>0.441</td><td>0.509</td><td><bold>0.414</bold></td><td>6.6</td><td>0.494</td><td>0.240</td><td>0.307</td><td><bold>0.227</bold></td><td>5.6</td></tr><tr><td>SRR635193_1</td><td>1.47</td><td>0.697</td><td>0.702</td><td><bold>0.633</bold></td><td>10.0</td><td>0.333</td><td>0.267</td><td>0.289</td><td><bold>0.216</bold></td><td>23.9</td></tr><tr><td>SRR689233_1</td><td>1.48</td><td>0.449</td><td>0.442</td><td><bold>0.400</bold></td><td>10.6</td><td>0.248</td><td>0.193</td><td>0.187</td><td><bold>0.149</bold></td><td>25.5</td></tr><tr><td>SRR870667_1</td><td>7.48</td><td>1.460</td><td>1.364</td><td><bold>0.721</bold></td><td>89.3</td><td>0.722</td><td>1.292</td><td>1.212</td><td><bold>0.506</bold></td><td>42.6</td></tr><tr><td>SRR1265495_1</td><td>1.70</td><td>0.632</td><td><bold>0.448</bold></td><td>0.506</td><td>−11.4</td><td>0.368</td><td>0.500</td><td>0.319</td><td><bold>0.246</bold></td><td>29.7</td></tr><tr><td>SRR1265496_1</td><td>1.48</td><td>0.646</td><td><bold>0.484</bold></td><td>0.517</td><td>−6.4</td><td>0.391</td><td>0.507</td><td>0.352</td><td><bold>0.264</bold></td><td>33.4</td></tr></tbody></table><table-wrap-foot><p>Compression ratios are in output bits per base [bpb]. Best results are in bold. ‘Gain’ (expressed in %) is defined as: best competitor ratio divided by FQSqueezer ratio subtracted by 1. FaStore does not offer original ordering preserving.</p></table-wrap-foot></table-wrap></p>
      <p id="Par18">The results for the paired-end (PE) reads can be found in Table <xref rid="Tab3" ref-type="table">3</xref>. In the OO mode, FQSqueezer usually outperforms Spring significantly. Nevertheless, for the largest dataset it loses slightly. It is hard to say what is the reason. The situation for the REO mode is similar, but the gains are usually even larger than in the OO mode.<table-wrap id="Tab3"><label>Table 3</label><caption><p>Compression ratios for paired-end reads.</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">Dataset</th><th rowspan="2">Size [Gbp]</th><th colspan="3">Orginal ordering</th><th colspan="5">Reordered</th></tr><tr><th>Spring</th><th>FQSqueezer</th><th>Gain</th><th>FaStore</th><th>Spring</th><th>Minicom</th><th>FQSqueezer</th><th>Gain</th></tr></thead><tbody><tr><td>ERR174310</td><td>41.93</td><td><bold>0.463</bold></td><td>0.474</td><td>−2.3</td><td>0.844</td><td><bold>0.317</bold></td><td>0.481</td><td>0.346</td><td>−8.3</td></tr><tr><td>ERR532393</td><td>7.15</td><td>0.623</td><td><bold>0.462</bold></td><td>34.7</td><td>0.694</td><td>0.505</td><td>0.471</td><td><bold>0.347</bold></td><td>35.8</td></tr><tr><td>SRR327342</td><td>2.08</td><td>0.490</td><td><bold>0.355</bold></td><td>38.0</td><td>—</td><td>0.307</td><td>—</td><td><bold>0.197</bold></td><td>55.7</td></tr><tr><td>SRR554369</td><td>0.33</td><td>0.322</td><td><bold>0.299</bold></td><td>7.7</td><td>0.652</td><td>0.222</td><td>0.293</td><td><bold>0.205</bold></td><td>8.4</td></tr><tr><td>SRR635193</td><td>2.94</td><td>0.562</td><td><bold>0.501</bold></td><td>12.2</td><td>0.500</td><td>0.339</td><td>0.419</td><td><bold>0.292</bold></td><td>16.0</td></tr><tr><td>SRR689233</td><td>2.96</td><td>0.367</td><td><bold>0.309</bold></td><td>18.8</td><td>0.350</td><td>0.239</td><td>0.257</td><td><bold>0.184</bold></td><td>30.2</td></tr><tr><td>SRR870667</td><td>12.60</td><td>1.070</td><td><bold>0.553</bold></td><td>93.3</td><td>—</td><td>0.928</td><td>—</td><td><bold>0.424</bold></td><td>119.0</td></tr><tr><td>SRR1265495</td><td>3.40</td><td>0.484</td><td><bold>0.373</bold></td><td>29.7</td><td>0.437</td><td>0.436</td><td>0.316</td><td><bold>0.228</bold></td><td>38.2</td></tr><tr><td>SRR1265496</td><td>2.96</td><td>0.500</td><td><bold>0.389</bold></td><td>28.4</td><td>0.479</td><td>0.449</td><td>0.344</td><td><bold>0.247</bold></td><td>39.0</td></tr></tbody></table><table-wrap-foot><p>Compression ratios are in output bits per base [bpb]. Best results are in bold. ‘Gain’ (expressed in %) is defined as: best competitor ratio divided by FQSqueezer ratio subtracted by 1. FaStore and Minicom do not support original ordering preserving. For two datasets (REO mode) we were unable to run FaStore and Minicom.</p></table-wrap-foot></table-wrap></p>
      <p id="Par19">The most important drawbacks of FQSqueezer are, however, its time and space requirements (Table <xref rid="Tab4" ref-type="table">4</xref> and Supplementary Worksheet). In the compression, it is a few times slower than the competitors, but in the decompression the difference is larger. The reason is simple. FaStore, Spring, and Minicom need time to find overlapping reads that likely origin ate from close genome positions. Nevertheless, decoding of the matches between the overlapping reads is very fast. FQSqueezer can be classified as a PPM algorithm. In the decompression, the algorithms from this family essentially mimic the same work made in the compression, so the differences in compression and decompression times are negligible.<table-wrap id="Tab4"><label>Table 4</label><caption><p>Time and memory requirements for compression of SE reads in the reordering mode.</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">Dataset</th><th rowspan="2">Size [Gbp]</th><th colspan="4">FaStore</th><th colspan="4">Spring</th><th colspan="4">Minicom</th><th colspan="4">FQSqueezer</th></tr><tr><th>c-t</th><th>d-t</th><th>c-m</th><th>d-m</th><th>c-t</th><th>d-t</th><th>c-m</th><th>d-m</th><th>c-t</th><th>d-t</th><th>c-m</th><th>d-m</th><th>c-t</th><th>d-t</th><th>c-m</th><th>d-m</th></tr></thead><tbody><tr><td>ERR174310_1</td><td>20.97</td><td>4,595</td><td>109</td><td><bold>6.4</bold></td><td>4.2</td><td><bold>1,815</bold></td><td><bold>103</bold></td><td>11.0</td><td>4.7</td><td>19,417</td><td>105</td><td>67.7</td><td><bold>4.0</bold></td><td>12,728</td><td>13,100</td><td>91.6</td><td>90.6</td></tr><tr><td>ERR532393_1</td><td>3.58</td><td>379</td><td>18</td><td>5.9</td><td>0.9</td><td><bold>150</bold></td><td>18</td><td><bold>3.0</bold></td><td>1.9</td><td>609</td><td><bold>17</bold></td><td>10.1</td><td><bold>0.7</bold></td><td>1,344</td><td>1,452</td><td>16.4</td><td>16.4</td></tr><tr><td>SRR327342_1</td><td>0.95</td><td>192</td><td>5</td><td>4.4</td><td><bold>0.3</bold></td><td><bold>35</bold></td><td>5</td><td><bold>1.4</bold></td><td>0.6</td><td>67</td><td><bold>3</bold></td><td>4.6</td><td>0.7</td><td>144</td><td>145</td><td>6.7</td><td>6.6</td></tr><tr><td>SRR554369_1</td><td>0.17</td><td>93</td><td><bold>1</bold></td><td>0.9</td><td>0.1</td><td><bold>7</bold></td><td><bold>1</bold></td><td><bold>0.8</bold></td><td>0.3</td><td>30</td><td><bold>1</bold></td><td>1.7</td><td><bold>0.0</bold></td><td>68</td><td>70</td><td>6.2</td><td>6.2</td></tr><tr><td>SRR635193_1</td><td>1.47</td><td>291</td><td>12</td><td>5.9</td><td>0.9</td><td><bold>77</bold></td><td><bold>10</bold></td><td>11.2</td><td>0.8</td><td>347</td><td>11</td><td><bold>5.4</bold></td><td><bold>0.3</bold></td><td>456</td><td>462</td><td>12.1</td><td>12.1</td></tr><tr><td>SRR689233_1</td><td>1.48</td><td>196</td><td>7</td><td>5.5</td><td>0.7</td><td><bold>64</bold></td><td>9</td><td><bold>1.6</bold></td><td>0.8</td><td>127</td><td><bold>5</bold></td><td>4.5</td><td><bold>0.3</bold></td><td>406</td><td>413</td><td>11.7</td><td>11.6</td></tr><tr><td>SRR870667_1</td><td>7.48</td><td>2,185</td><td><bold>64</bold></td><td><bold>5.8</bold></td><td><bold>3.0</bold></td><td><bold>757</bold></td><td>81</td><td>7.3</td><td><bold>3.0</bold></td><td>3,030</td><td>70</td><td>27.1</td><td>3.9</td><td>4,127</td><td>4,432</td><td>36.4</td><td>36.1</td></tr><tr><td>SRR1265495_1</td><td>1.70</td><td>483</td><td><bold>7</bold></td><td>5.7</td><td>0.6</td><td><bold>82</bold></td><td>12</td><td><bold>1.9</bold></td><td>1.6</td><td>203</td><td><bold>7</bold></td><td>5.1</td><td><bold>0.2</bold></td><td>658</td><td>685</td><td>13.2</td><td>13.1</td></tr><tr><td>SRR1265496_1</td><td>1.48</td><td>170</td><td><bold>6</bold></td><td>5.1</td><td>0.6</td><td><bold>81</bold></td><td>11</td><td><bold>1.8</bold></td><td>1.6</td><td>194</td><td>7</td><td>4.6</td><td><bold>0.2</bold></td><td>609</td><td>652</td><td>13.0</td><td>13.0</td></tr></tbody></table><table-wrap-foot><p>Column abbreviations: ‘c-t’ — compression time (in seconds), ‘c-m’ — RAM usage in compression (in GB), ‘d-t’ —decompression time (in seconds), ‘d-m’— RAM usage in decompression (in GB). Best results are in bold.</p></table-wrap-foot></table-wrap></p>
      <p id="Par20">The case of memory usage is similar. The same dictionaries must be maintained by FQSqueezer in the decompression that are necessary in the compression. Moreover, to predict the successive symbols a lot of statistics must be collected. Nevertheless, without the applied correction mechanisms the occupied memory would likely be doubled.</p>
      <p id="Par21">The dictionaries are updated only at the synchronization points, i.e., after processing each FASTQ block of size 16 MB, so the number of threads has some impact on the compression ratio. The results in Table <xref rid="Tab5" ref-type="table">5</xref> show that reducing the number of threads from 12 to 1 we can gain 1–2% in ratio, but the processing would be significantly slower.<table-wrap id="Tab5"><label>Table 5</label><caption><p>Multithreding scalability of FQSqueezer for SRR327342_1 dataset.</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">No. threads</th><th colspan="2">Original ordering</th><th colspan="2">Reordered</th></tr><tr><th>Compression time [s]</th><th>Ratio [bpb]</th><th>Compression time [s]</th><th>Ratio [bpb]</th></tr></thead><tbody><tr><td>1</td><td>1034.76</td><td>0.484</td><td>547.72</td><td>0.139</td></tr><tr><td>2</td><td>619.97</td><td>0.485</td><td>378.87</td><td>0.140</td></tr><tr><td>3</td><td>453.10</td><td>0.485</td><td>315.44</td><td>0.140</td></tr><tr><td>4</td><td>356.98</td><td>0.486</td><td>263.28</td><td>0.141</td></tr><tr><td>6</td><td>265.40</td><td>0.487</td><td>202.04</td><td>0.141</td></tr><tr><td>8</td><td>221.37</td><td>0.487</td><td>168.96</td><td>0.142</td></tr><tr><td>12</td><td>169.56</td><td>0.488</td><td>140.31</td><td>0.142</td></tr><tr><td>16</td><td>143.78</td><td>0.489</td><td>131.10</td><td>0.143</td></tr><tr><td>24</td><td>116.33</td><td>0.490</td><td>122.69</td><td>0.144</td></tr></tbody></table></table-wrap></p>
      <p id="Par22">One of the parameters of FQSqueezer is the assumed genome size, which should be comparable to the true genome size in the sequencing experiment. The genome size is used to set the lengths of the <italic>k</italic>-mers stored in the dictionaries. In the last experiment in this part, we checked the impact of this parameter. The results presented in Table <xref rid="Tab6" ref-type="table">6</xref> show that declaring improper genome size deteriorates the compression ratio, but the differences are not large (In Supplementary Section <xref rid="MOESM1" ref-type="media">1.1</xref> one can find some suggestion how to set this parameter).<table-wrap id="Tab6"><label>Table 6</label><caption><p>Impact of FQSqueezer declared genome size for SRR870667_1 dataset.</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">Declared genome size</th><th colspan="3">Original ordering</th><th colspan="3">Reordered</th></tr><tr><th>Time [s]</th><th>RAM [GB]</th><th>Ratio [bpb]</th><th>Time [s]</th><th>RAM [GB]</th><th>Ratio [bpb]</th></tr></thead><tbody><tr><td>2</td><td>3,130</td><td>23.4</td><td>0.761</td><td>2,815</td><td>23.4</td><td>0,548</td></tr><tr><td>10</td><td>3,124</td><td>23.8</td><td>0.744</td><td>2,847</td><td>23.8</td><td>0.533</td></tr><tr><td>50</td><td>3,203</td><td>25.1</td><td>0.730</td><td>3,172</td><td>25.0</td><td>0.515</td></tr><tr><td>200</td><td>3,717</td><td>30.0</td><td>0.725</td><td>3,647</td><td>29.9</td><td>0.507</td></tr><tr><td>500</td><td>4,569</td><td>36.6</td><td>0.721</td><td>4,090</td><td>36.4</td><td>0.502</td></tr><tr><td>2000</td><td>4,867</td><td>68.0</td><td>0.722</td><td>4,958</td><td>67.8</td><td>0.500</td></tr></tbody></table><table-wrap-foot><p>Reference genome for this organism is of size 430 Mbp.</p></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="Sec5">
      <title>Full FASTQ compressors</title>
      <p id="Par23">FQSqueezer is a FASTQ compressor, so we ran it for a few datasets to verify its performance in such scenario. There were only two competitors: FaStore and Spring as Minicom was designed just for bases. The results in Table <xref rid="Tab7" ref-type="table">7</xref> are for three modes. In the <italic>lossless</italic> mode, all data were preserved. In the <italic>reduced</italic> mode, the IDs were truncated to just the instrument name and the quality values were down-sampled to 8 levels (i.e., Illumina 8-level binning). In the <italic>bases only</italic> mode, only the bases are stored. The table presents only the sizes of the compressed archives, but the timings and memory occupation can be found in Supplementary Worksheet.<table-wrap id="Tab7"><label>Table 7</label><caption><p>Compression of complete FASTQ files.</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">Dataset</th><th rowspan="2">Input</th><th colspan="2">Original ordering</th><th colspan="3">Reordered</th></tr><tr><th>Spring</th><th>FQSqueezer</th><th>FaStore</th><th>Spring</th><th>FQSqueezer</th></tr></thead><tbody><tr><td colspan="7"><bold>Lossless</bold></td></tr><tr><td>ERR532393_1</td><td>9,642</td><td>1,649.6</td><td><bold>1,510.8</bold></td><td>1,840.4</td><td>1,738.9</td><td><bold>1,634.9</bold></td></tr><tr><td>SRR327342_1</td><td>2,813</td><td>435.4</td><td><bold>428.2</bold></td><td>504.1</td><td>471.5</td><td><bold>468.0</bold></td></tr><tr><td>SRR870667_1</td><td>18,555</td><td>3,913.6</td><td><bold>3,091.2</bold></td><td>3,683.6</td><td>4,067.2</td><td><bold>3,342.5</bold></td></tr><tr><td>ERR532393</td><td>19,284</td><td>3,200.6</td><td><bold>2,903.6</bold></td><td>3,602.1</td><td>3,299.3</td><td><bold>3,032.0</bold></td></tr><tr><td>SRR327342</td><td>5,986</td><td>954.6</td><td><bold>904.1</bold></td><td>—</td><td>987.2</td><td><bold>944.3</bold></td></tr><tr><td>SRR870667</td><td>32,402</td><td>6,060.6</td><td><bold>5,093.6</bold></td><td>—</td><td>6,201.6</td><td><bold>5,345.0</bold></td></tr><tr><td colspan="7"><bold>Reduced</bold></td></tr><tr><td>ERR532393_1</td><td>9,642</td><td>917.5</td><td><bold>827.8</bold></td><td>978.4</td><td>814.4</td><td><bold>723.5</bold></td></tr><tr><td>SRR327342_1</td><td>2,813</td><td>178.7</td><td><bold>172.1</bold></td><td>208.2</td><td>135.5</td><td><bold>131.2</bold></td></tr><tr><td>SRR870667_1</td><td>18,555</td><td>2,583.7</td><td><bold>1,824.0</bold></td><td>2,151.7</td><td>2,444.0</td><td><bold>1,620.3</bold></td></tr><tr><td>ERR532393</td><td>19,284</td><td>1,814.9</td><td><bold>1,616.5</bold></td><td>2,058.3</td><td>1,729.8</td><td><bold>1,515.9</bold></td></tr><tr><td>SRR327342</td><td>5,986</td><td>413.4</td><td><bold>368.9</bold></td><td>—</td><td>366.6</td><td><bold>328.4</bold></td></tr><tr><td>SRR870667</td><td>32,402</td><td>3,914.7</td><td><bold>2,994.2</bold></td><td>—</td><td>3,698.5</td><td><bold>2,790.2</bold></td></tr><tr><td colspan="7"><bold>Bases only</bold></td></tr><tr><td>ERR532393_1</td><td>9,642</td><td>298.0</td><td><bold>236.7</bold></td><td>215.5</td><td>193.3</td><td><bold>132.1</bold></td></tr><tr><td>SRR327342_1</td><td>2,813</td><td>62.1</td><td><bold>59.2</bold></td><td>31.6</td><td>18.8</td><td><bold>17.0</bold></td></tr><tr><td>SRR870667_1</td><td>18,555</td><td>1,364.2</td><td><bold>673.6</bold></td><td>674.8</td><td>1,207.5</td><td><bold>473.2</bold></td></tr><tr><td>ERR532393</td><td>19,284</td><td>556.6</td><td><bold>416.5</bold></td><td>620.6</td><td>451.5</td><td><bold>313.5</bold></td></tr><tr><td>SRR327342</td><td>5,986</td><td>127.1</td><td><bold>97.8</bold></td><td>—</td><td>79.7</td><td><bold>52.7</bold></td></tr><tr><td>SRR870667</td><td>32,402</td><td>1,684.5</td><td><bold>871.6</bold></td><td>—</td><td>1,461.0</td><td><bold>667.2</bold></td></tr></tbody></table><table-wrap-foot><p>The dataset names suffixed “_1” denote SE data. The remaining are PE files. All numbers are sizes in MBs. The best results are in bold.</p></table-wrap-foot></table-wrap></p>
      <p id="Par24">The experiment confirmed the advantage of FQSqueezer in terms of compression ratio. Nevertheless, our compressor is slower and needs more memory than the competitors. It is interesting to note that in the lossless modes both Spring and FQSqueezer give smaller archives when they do not permute the reads. This is caused by the large cost of compression of IDs that are not so similar for subsequent reordered reads. In the remaining modes, the cost of ID storage is negligible, so the reordering modes win.</p>
    </sec>
  </sec>
  <sec id="Sec6" sec-type="discussion">
    <title>Discussion</title>
    <p id="Par25">In the article, we presented a novel compression algorithm for FASTQ files. Its architecture was motivated by the PPM and DMC general-purpose compressors. Nevertheless, significant amount of work was necessary to make it possible to adapt these two approaches for genomic data. First, it was crucial to prepare specialized data structures for statistics gathering, with care of fast memory accesses (i.e., reduction of cache misses). Second, some dedicated correction of bases was implemented for better prediction and reduction of memory usage. Third, a special approach was necessary to efficiently store paired reads. Fourth, the DMC-like mechanism for aggressive estimation of symbol occurrence probabilities was proposed.</p>
    <p id="Par26">The experiments show advantage of FQSqueezer in terms of compression ratio for the majority of datasets. The differences between our tool and the state-of-the-art competitors were sometimes quite large. Nevertheless, for the largest paired-end dataset we perform slightly worse than Spring. This phenomenon deserves further investigation.</p>
    <p id="Par27">The most important drawbacks of FQSqueezer are slow processing and large memory consumption. These features are typical for PPM-based algorithms. Nevertheless, some work to reduce these drawbacks is probably possible. For example, the two most important components responsible for slow processing are looking for approximate matches and queries for incomplete <italic>k</italic>-mers. In the future work, it should be possible to attack at least these two problems, e.g., try to minimize the number of queries to the dictionary data structures without deterioration of the compression ratios.</p>
    <p id="Par28">For those, who would find the memory and time requirements prohibitive for application of the proposed tool in real pipelines, FQSqueezer could be seen as an attempt into better estimation of the entropy present in sequencing data. It should also be possible to implement some of the concepts present in FQSqueezer in the more practical FASTQ compressors to improve their compression ratios.</p>
  </sec>
  <sec id="Sec7">
    <title>Methods</title>
    <sec id="Sec8">
      <title>Basic definitions</title>
      <p id="Par29">For clarity of description of the algorithm let us assume that DNA sequences <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$x={x}_{1}{x}_{2}\ldots {x}_{r}$$\end{document}</tex-math><mml:math id="M2"><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>…</mml:mi><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2020_57452_Article_IEq1.gif"/></alternatives></inline-formula> contain symbols from alphabet {A,C,G,T,N}. The <italic>length</italic> (<italic>size</italic>) of a sequence is the number of elements it is composed of. A <italic>substring</italic> can be obtained from a sequence by removing (possibly 0) symbols from the beginning and the end. The notation <italic>x</italic><sub><italic>i,j</italic></sub> means a substring <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${x}_{i}{x}_{i+1}\ldots {x}_{j}$$\end{document}</tex-math><mml:math id="M4"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>…</mml:mi><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2020_57452_Article_IEq2.gif"/></alternatives></inline-formula>. A <italic>k-mer</italic> is a sequence of length <italic>k</italic>. A <italic>canonical k</italic>-mer is lexicographically smaller of a <italic>k</italic>-mer and its reverse complement.</p>
    </sec>
    <sec id="Sec9">
      <title>Basic description of the algorithm</title>
      <p id="Par30">FQSqueezer is a multi-threaded algorithm, but for simplicity of presentation we will start from a single-threaded variant. Our tool accepts both single-end (SE) and paired-end (PE) reads. The reads can be stored in the original ordering (OO) or can be reordered (REO). In the reordering mode, the reads are initially sorted according to the DNA sequence (first read of a pair in the PE mode).</p>
      <p id="Par31">The input FASTQ files (or sorted files in the REO mode) are loaded in blocks of size 16 MB. The reads from a single block (pair of blocks in the PE mode) are compressed one by one (or pair by pair). The read ID and quality values are compressed using rather standard means (similarly like in the top existing FASTQ compressors). The details are described at the end of this section. Below, we will focus just on the DNA symbols.</p>
    </sec>
    <sec id="Sec10">
      <title>Compression of bases</title>
      <p id="Par32">In the compression of a SE read (or first read of a pair), we process the bases from the beginning of a read position by position. For each base we determine the statistics of occurrences of <italic>k</italic>-mers ending at this base in the already processed part of the input data. To this end, we maintain a few dictionaries: <italic>D</italic><sub>e</sub>, <italic>D</italic><sub>p</sub>, <italic>D</italic><sub>s</sub>, and <italic>D</italic><sub>b</sub> that store numbers of occurrences of: <italic>e</italic>-mers, <italic>p</italic>-mers, <italic>s</italic>-mers, and <italic>b</italic>-mers, respectively, where <inline-formula id="IEq3"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$e &lt; p &lt; s &lt; b$$\end{document}</tex-math><mml:math id="M6"><mml:mi>e</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>p</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>s</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>b</mml:mi></mml:math><inline-graphic xlink:href="41598_2020_57452_Article_IEq3.gif"/></alternatives></inline-formula>. The details of the organization of the dictionaries are given in Supplementary Section <xref rid="MOESM1" ref-type="media">1.1</xref>.</p>
      <p id="Par33">At the beginning we will discuss the OO-SE mode. In general, the longest possible, but no longer than <italic>b</italic>–1 symbols, context (substring preceding the current symbol in a read) is taken to predict the current symbol. Then, the symbol is encoded using these predictions (as well as some other properties of a read and the current position) with a use of a range coder.</p>
      <p id="Par34">Let us follow the example given in Fig. <xref rid="Fig1" ref-type="fig">1</xref> assuming the sizes of <italic>k</italic>-mers: <italic>e</italic> = 4, <italic>p</italic> = 6, <italic>s</italic> = 9, <italic>b</italic> = 12. The subfigures (a)–(c) show how the probabilities of appearance of each symbol from the alphabet {A,C,G,T,N} are estimated for some symbols of a read. In Fig. <xref rid="Fig1" ref-type="fig">1a</xref>, the 6th symbol (orange cell in the figure) is encoded. We consult the <italic>D</italic><sub>p</sub> dictionary (as there are too few already-processed-read symbols to use <italic>D</italic><sub>s</sub> or <italic>D</italic><sub>b</sub>) for statistics of appearance of all <italic>p</italic>-mers ATACC*, where “*” represents any symbol. The answer (blue font in the figure) is that: ATACC<bold>A</bold> appeared 31 times, ATACC<bold>C</bold>—10 times, ATACC<bold>G</bold>—454 times, ATACC<bold>T</bold>—5 times. Then, we reorder the alphabet symbols according to this statistics (for simplicity let us assume that for equal counters the symbols are ordered lexicographically): G (rank 0), A (rank 1), C (rank 2), T (rank 3), N (rank 4). In the next step, we check in the <italic>Model</italic> dictionary how many times for such ordered counters, at the 6th position, when the statistics are from the <italic>D</italic><sub>p</sub> dictionary the current symbol was the one with rank 0, 1,…. (In fact we use more items that define the query to the <italic>Model</italic> dictionary, but for simplicity of presentation we omit them here. More details are given in Supplementary Section <xref rid="MOESM1" ref-type="media">1.2</xref>.) The answer is that 1204 times the symbol of rank 0 was encoded, 15 times the symbol of rank 1, and so on. The frequencies 1204, 15, 8, 8, 2 are then used by the range coder to encode the current symbol.<fig id="Fig1"><label>Figure 1</label><caption><p>Illustration of compression of a single read in a single-end, original ordering mode. The subfigures (<bold>a</bold>–<bold>c</bold>) show how the estimation of probabilities for entropy coding is performed for some symbols.</p></caption><graphic xlink:href="41598_2020_57452_Fig1_HTML" id="d29e3250"/></fig></p>
      <p id="Par35">The situation presented in Fig. <xref rid="Fig1" ref-type="fig">1b</xref> is a bit different. Here we are at the 8th position in a read so we are able to look for statistics in <italic>D</italic><sub>s</sub> dictionary. Nevertheless, this dictionary stores statistics for 9-mers and we can construct only 8-mers from the already processed symbols. Therefore, the dictionary is asked for *ATACCGT* 9-mers, where “*” represents any symbol. The answer is that: *ATACCGT<bold>A</bold> appeared 2 times, *ATACCGT<bold>C</bold>—155 times, *ATACCGT<bold>G</bold>—54 times, *ATACCGT<bold>T</bold>—12 times. Then, we ask the <italic>Model</italic> dictionary and obtain estimates: 350 for rank-0 symbol (C in this situation), 100 for rank-1 symbol (G), 14 for rank-2 symbol (T), 4 for rank-3 symbol (A), 3 for rank-4 symbol (N). These estimates are used for encoding the current symbol using the range coder.</p>
      <p id="Par36">In Fig. <xref rid="Fig1" ref-type="fig">1c</xref>, we show the processing of the 14th symbol. Now, the number of processed symbols is sufficient to use <italic>D</italic><sub>b</sub> dictionary for statistics of occurrence of 12-mers ACCGTCAGGTA*. Unfortunately, the answer is that no such 12-mer has been seen so far. Therefore, we use the <italic>D</italic><sub>s</sub> dictionary for GTCAGGTA* and obtain statistics: 15 for A, 0 for C, 15 for G, 0 for T. Then we use the <italic>Model</italic> dictionary and see that the estimates for the current symbol are: 102 for rank-0 symbol (A), 104 for rank-1 symbol (G), 7 for rank-2 symbol (C), 5 for rank-3 symbol (T), 1 for rank-4 symbol (N). As previously, these values can be used to encode the current symbol by the range coder.</p>
      <p id="Par37">When a symbol is encoded, it is checked whether it looks like a sequencing error. Let us assume that the statistics from the <italic>D</italic><sub>b</sub> dictionary are <inline-formula id="IEq4"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$C=[{0}_{{\rm{A}}},{5}_{{\rm{C}}},{0}_{{\rm{G}}},{0}_{{\rm{T}}}]$$\end{document}</tex-math><mml:math id="M8"><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="normal">A</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mn>5</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="normal">C</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="normal">G</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:math><inline-graphic xlink:href="41598_2020_57452_Article_IEq4.gif"/></alternatives></inline-formula> and the current symbol is A. The dominance of C symbols suggests that A is a sequencing error. Therefore, we encode A at this position but replace A by C in the read, which has impact on the processing of the next symbols in the read. To assume that we have a sequencing error the most frequent symbol should have counter at least 3 and the current symbol should have counter 0.</p>
      <p id="Par38">In the REO mode, the prefix of size <italic>p</italic> of a SE read (or first read of a pair in the PE mode) is encoded in a different way. Roughly speaking, we treat it as a 2<italic>p</italic>-bit unsigned integer and encode the difference between it and the integer representing the prefix of the previous read. Using the same read as in the above example, we pick the 6-mer ATACCG and convert it to 12-bit integer using mapping: 00<sub>2</sub> for A, 01<sub>2</sub> for C, 10<sub>2</sub> for G, 11<sub>2</sub> for T. Therefore the read prefix is represented as <inline-formula id="IEq5"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${001100010110}_{2}={790}_{10}$$\end{document}</tex-math><mml:math id="M10"><mml:msub><mml:mrow><mml:mn>001100010110</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mn>790</mml:mn></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2020_57452_Article_IEq5.gif"/></alternatives></inline-formula>. Let us also assume the previous read prefix was ATACAT, which translates to <inline-formula id="IEq6"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${001100010011}_{2}={787}_{10}$$\end{document}</tex-math><mml:math id="M12"><mml:msub><mml:mrow><mml:mn>001100010011</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mn>787</mml:mn></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2020_57452_Article_IEq6.gif"/></alternatives></inline-formula>. Therefore the current read prefix is encoded as a difference <inline-formula id="IEq7"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$790-787=3$$\end{document}</tex-math><mml:math id="M14"><mml:mn>790</mml:mn><mml:mo>−</mml:mo><mml:mn>787</mml:mn><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:math><inline-graphic xlink:href="41598_2020_57452_Article_IEq7.gif"/></alternatives></inline-formula>. The differences are usually small numbers which can be encoded efficiently using a range coder. The suffix is compressed in the same way as in the OO mode.</p>
      <p id="Par39">In the PE modes, the first read of a pair is compressed exactly in the same way as in the SE mode. The processing of the second read is a bit more complex, but it is the same in the OO and REO modes. Initially we try to predict some <italic>b</italic>-mer of the second read. To this end, we use a dictionary <italic>M</italic><sub>b</sub> that stores pairs of minimizers of read pairs seen so far. Quite often this allows to encode the <italic>b</italic>-mer of the second read in an efficient way. Then, we store the substrings of the read following and preceding this <italic>b</italic>-mer. If we were unable to predict the minimizer of the second read, we store the read in the same way as a SE read in the OO mode.</p>
      <p id="Par40">Figure <xref rid="Fig2" ref-type="fig">2</xref> shows an example how the pair of minimizers are used to predict some of the second read <italic>b</italic>-mer. At the beginning a minimizer, <inline-formula id="IEq8"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${m}_{1}={\rm{ACCGAGGTAG}}$$\end{document}</tex-math><mml:math id="M16"><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">ACCGAGGTAG</mml:mi></mml:math><inline-graphic xlink:href="41598_2020_57452_Article_IEq8.gif"/></alternatives></inline-formula>, in the first read is found (green cells). Then, we look in the <italic>M</italic><sub>b</sub> dictionary which minimizers in the second read appeared together with <italic>m</italic><sub>1</sub> in the past. We obtain four candidates ordered by the number of appearances. Then for each of the candidates we check whether it appears in the second read. In our example, we found AAGATGTCCAGT (orange cells). Thus, we encode just the rank of the candidate in the ordered list of candidates, i.e., 2 (we count from 0) and the position of the candidate in the second read, i.e., 10.<fig id="Fig2"><label>Figure 2</label><caption><p>Example of prediction of some <italic>b</italic>-mer of the paired read from the statistics of occurrences of pairs of minimizers in PE reads.</p></caption><graphic xlink:href="41598_2020_57452_Fig2_HTML" id="d29e3504"/></fig></p>
      <p id="Par41">After processing a read the dictionaries <italic>D</italic><sub>e</sub>, <italic>D</italic><sub>p</sub>, <italic>D</italic><sub>s</sub>, <italic>D</italic><sub>b</sub>, and <italic>M</italic><sub>b</sub> for a case of PE reads, are updated.</p>
      <p id="Par42">For clarity of presentation, the above description of bases compression is a bit simplified. For example, in practice we work on canonical <italic>k</italic>-mers, a second correction mechanism (rarely used) is also employed, more than a single pair of minimizers is stored in <italic>M</italic><sub>b</sub> dictionary, the <italic>Model</italic> dictionary is indexed with a use of some function of the mentioned (and other) properties of the current position in a read, a dynamic Markov coder-like mechanism is used in the <italic>Model</italic> dictionary to provide estimated probabilities. A discussion of all of this can be found in Supplementary Section <xref rid="MOESM1" ref-type="media">1.2</xref>.</p>
    </sec>
    <sec id="Sec11">
      <title>Compression of IDs</title>
      <p id="Par43">In the lossless mode, IDs are compressed similarly as in the state-of-the-art compressors, like Spring or FaStore. The ID of each read is tokenized (the separators are non-alphanumerical characters). Then the tokens are compared with the tokens of the previous read. If the tokens at corresponding positions contain numerical values, the difference between the integers is calculated and stored. Otherwise the corresponding tokens are compared as strings. If they are equal we just store a flag. In the opposite case, we store a mismatch flag and compare the tokens character by character storing the result of comparison and (if necessary) the letter from the current read. It can also happen that the list of tokens differ significantly, i.e., they are of different length or the corresponding tokens are of different type. In this situation, the ID is stored character by character.</p>
      <p id="Par44">FQSqueezer offers also two lossy modes. In the first one, it preserves just the instrument name (first part of the ID). These names are organized in a move-to-front list<sup><xref ref-type="bibr" rid="CR26">26</xref></sup> and the position of the current ID at the list is encoded. If the current instrument name is absent form the list, it is encoded explicitly. In the last possible mode, IDs are discarded.</p>
    </sec>
    <sec id="Sec12">
      <title>Compression of quality scores</title>
      <p id="Par45">The quality scores can be compressed in five modes allowing different number of values: 96, 8, 4, 2, none. If the input FASTQ file has already reduced resolution of quality scores (e.g., 4 for Illumina NovaSeq sequencers), no conversion is necessary. Otherwise, in the lossy mode the necessary resolution reduction is made by the compressor. The encoding is made using contexts containing the position in a read and 2 (96-value alphabet), 6 (8-value alphabet), 9 (4-value alphabet), or 10 (binary alphabet) previous scores.</p>
    </sec>
    <sec id="Sec13">
      <title>Implementation details</title>
      <p id="Par46">The implementation is in the C++14 programming language. Most of the dictionaries are implemented as hash tables with linear probing for collision handling. To reduce delays caused by cache misses we make use of software prefetching. The multithreading is implemented using the native C++ threads. The FASTQ blocks of size 16 MB are split into as many parts as the number of threads. Each thread processes its part independently and the global dictionaries are available only for querying. At the synchronization points the threads update the global dictionaries. Nevertheless, the threads update different parts of the dictionaries so they can operate in parallel.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary information</title>
    <sec id="Sec14">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="41598_2020_57452_MOESM1_ESM.pdf">
            <caption>
              <p>Supplementary info.</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM2">
          <media xlink:href="41598_2020_57452_MOESM2_ESM.xlsx">
            <caption>
              <p>Supplementary info2.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p><bold>Publisher’s note</bold> Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
    <fn>
      <p>
        <bold>Change history</bold>
      </p>
      <p>2/21/2020</p>
      <p>An amendment to this paper has been published and can be accessed via a link at the top of the paper.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Supplementary information</title>
    <p>is available for this paper at 10.1038/s41598-020-57452-6.</p>
  </sec>
  <ack>
    <title>Acknowledgements</title>
    <p>This work was supported by National Science Centre, Poland under projects DEC-2015/17/B/ST6/01890 and DEC-2017/25/B/ST6/01525. The infrastructure was supported by POIG.02.03.01-24-099/13 grant: “GeCONiI—Upper Silesian Center for Computational Science and Engineering”.</p>
  </ack>
  <notes notes-type="author-contribution">
    <title>Author contributions</title>
    <p>All the work was made by S.D.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Data availability</title>
    <p>The source code of the application is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/refresh-bio/fqsqueezer">https://github.com/refresh-bio/fqsqueezer</ext-link>.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p id="Par47">The author declares no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Grabowski</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Data compression for sequencing data</article-title>
        <source>Algorithms for Molecular Biology</source>
        <year>2013</year>
        <volume>8</volume>
        <fpage>25</fpage>
        <pub-id pub-id-type="doi">10.1186/1748-7188-8-25</pub-id>
        <pub-id pub-id-type="pmid">24252160</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stephens</surname>
            <given-names>ZD</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Big Data: astronomical or genomical</article-title>
        <source>PLoS Biol.</source>
        <year>2015</year>
        <volume>13</volume>
        <fpage>e1002195</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pbio.1002195</pub-id>
        <pub-id pub-id-type="pmid">26151137</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cock</surname>
            <given-names>PJ</given-names>
          </name>
          <name>
            <surname>Fields</surname>
            <given-names>CJ</given-names>
          </name>
          <name>
            <surname>Goto</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Heuer</surname>
            <given-names>ML</given-names>
          </name>
          <name>
            <surname>Rice</surname>
            <given-names>PM</given-names>
          </name>
        </person-group>
        <article-title>The Sanger FASTQ file format for sequences with quality scores, and the Solexa/Illumina FASTQ variants</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2010</year>
        <volume>38</volume>
        <fpage>1767</fpage>
        <lpage>1771</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkp1137</pub-id>
        <pub-id pub-id-type="pmid">20015970</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bonfield</surname>
            <given-names>JK</given-names>
          </name>
          <name>
            <surname>Mahoney</surname>
            <given-names>MV</given-names>
          </name>
        </person-group>
        <article-title>Compression of FASTQ and SAM format sequencing data</article-title>
        <source>PLoS One</source>
        <year>2013</year>
        <volume>8</volume>
        <fpage>e59190</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0059190</pub-id>
        <pub-id pub-id-type="pmid">23533605</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Grabowski</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Compression of DNA sequence reads in FASTQ format</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>860</fpage>
        <lpage>862</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr014</pub-id>
        <pub-id pub-id-type="pmid">21252073</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hach</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Numanagi´c</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Alkan</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Sahinalp</surname>
            <given-names>SC</given-names>
          </name>
        </person-group>
        <article-title>SCALCE: boosting sequence compression algorithms using locally consistent encoding</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>3051</fpage>
        <lpage>3057</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts593</pub-id>
        <pub-id pub-id-type="pmid">23047557</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roguski</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>DSRC 2—Industry-oriented compression of FASTQ files</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>2213</fpage>
        <lpage>2215</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu208</pub-id>
        <pub-id pub-id-type="pmid">24747219</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cox</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Bauer</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Jakobi</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Large-scale compression of genomic sequence databases with the Burrows–Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>1415</fpage>
        <lpage>1419</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts173</pub-id>
        <pub-id pub-id-type="pmid">22556365</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roberts</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hayes</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Hunt</surname>
            <given-names>BR</given-names>
          </name>
          <name>
            <surname>Mount</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Yorke</surname>
            <given-names>JA</given-names>
          </name>
        </person-group>
        <article-title>Reducing storage requirements for biological sequence comparison</article-title>
        <source>Bioinformatics</source>
        <year>2004</year>
        <volume>20</volume>
        <fpage>3363</fpage>
        <lpage>3369</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bth408</pub-id>
        <pub-id pub-id-type="pmid">15256412</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Grabowski</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Roguski</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Disk-based compression of data from genome sequencing</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <fpage>1389</fpage>
        <lpage>1395</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu844</pub-id>
        <pub-id pub-id-type="pmid">25536966</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Patro</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Kingsford</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Data-dependent bucketing improves reference-free compression of sequencing reads</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <fpage>2770</fpage>
        <lpage>2777</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv248</pub-id>
        <pub-id pub-id-type="pmid">25910696</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roguski</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Ochoa</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Hernaez</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>FaStore: a space-saving solution for raw sequencing data</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>34</volume>
        <fpage>2748</fpage>
        <lpage>2756</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty205</pub-id>
        <pub-id pub-id-type="pmid">29617939</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chandak</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Tatwawadi</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Weissman</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Compression of genomic sequencing reads via hash-based reordering: algorithm and analysis</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>34</volume>
        <fpage>558</fpage>
        <lpage>567</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btx639</pub-id>
        <pub-id pub-id-type="pmid">29444237</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chandak</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Tatwawadi</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Ochoa</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Hernaez</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Weissman</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>SPRING: A next-generation compressor for FASTQ data</article-title>
        <source>Bioinformatics</source>
        <year>2019</year>
        <volume>35</volume>
        <fpage>2674</fpage>
        <lpage>2676</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty1015</pub-id>
        <pub-id pub-id-type="pmid">30535063</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Yu.</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Dinger</surname>
            <given-names>ME</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Index suffix-prefix overlaps by (w; k)-minimizer to generate long contigs for reads compression</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>35</volume>
        <fpage>2066</fpage>
        <lpage>2074</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty936</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <mixed-citation publication-type="other">Hernaez, M., Ochoa, I. &amp; Weissman, T. A cluster-based approach to compression of quality scores. In: Bilgin, A. <italic>et al</italic>. (ed.), Proc. of Data Compression Conference. IEEE Computer Society, Los Alamitos, CA, pp. 261–270 (2016).</mixed-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Malysa</surname>
            <given-names>G</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>QVZ: lossy compression of quality scores</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <fpage>3122</fpage>
        <lpage>3129</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv330</pub-id>
        <pub-id pub-id-type="pmid">26026138</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bonfield</surname>
            <given-names>JK</given-names>
          </name>
          <name>
            <surname>McCarthy</surname>
            <given-names>SA</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Crumble: reference free lossy compression of sequence quality values</article-title>
        <source>Bioinformatics</source>
        <year>2019</year>
        <volume>35</volume>
        <fpage>337</fpage>
        <lpage>339</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty608</pub-id>
        <pub-id pub-id-type="pmid">29992288</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cleary</surname>
            <given-names>JG</given-names>
          </name>
          <name>
            <surname>Witten</surname>
            <given-names>IH</given-names>
          </name>
        </person-group>
        <article-title>Data compression using adaptive coding and partial string matching</article-title>
        <source>IEEE Trans. on Communications</source>
        <year>1984</year>
        <volume>COM-32</volume>
        <fpage>396</fpage>
        <lpage>402</lpage>
        <pub-id pub-id-type="doi">10.1109/TCOM.1984.1096090</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Moffat</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Implementing the PPM data compression scheme</article-title>
        <source>IEEE Trans. on Communications</source>
        <year>1990</year>
        <volume>COM-38</volume>
        <fpage>1917</fpage>
        <lpage>1921</lpage>
        <pub-id pub-id-type="doi">10.1109/26.61469</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cormack</surname>
            <given-names>GV</given-names>
          </name>
          <name>
            <surname>Horspool</surname>
            <given-names>RNS</given-names>
          </name>
        </person-group>
        <article-title>Data compression using dynamic Markov modelling</article-title>
        <source>The Computer Journal</source>
        <year>1987</year>
        <volume>30</volume>
        <fpage>541</fpage>
        <lpage>550</lpage>
        <pub-id pub-id-type="doi">10.1093/comjnl/30.6.541</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ginart</surname>
            <given-names>AA</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Optimal compressed representation of high throughput sequence data via light assembly</article-title>
        <source>Nat. Commun.</source>
        <year>2018</year>
        <volume>9</volume>
        <fpage>566</fpage>
        <pub-id pub-id-type="doi">10.1038/s41467-017-02480-6</pub-id>
        <pub-id pub-id-type="pmid">29422526</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <mixed-citation publication-type="other">Pratas, D., Pinho, A. J. &amp; Ferreira, P. J. S. G. Efficient compression of genomic sequences. Proc. of Data Compression Conference. IEEE Computer Society, Los Alamitos, CA, pp. 231–240 (2016).</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pinho</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Pratas</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>MFCompress: a compression tool for FASTA and multi-FASTA data</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>117</fpage>
        <lpage>118</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btt594</pub-id>
        <pub-id pub-id-type="pmid">24132931</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pinho</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Ferreira</surname>
            <given-names>PJSG</given-names>
          </name>
          <name>
            <surname>Neves</surname>
            <given-names>AJR</given-names>
          </name>
          <name>
            <surname>Bastos</surname>
            <given-names>CAC</given-names>
          </name>
        </person-group>
        <article-title>On the Representability of Complete Genomes by Multiple Competing Finite-Context (Markov) Models</article-title>
        <source>PLoS ONE</source>
        <year>2011</year>
        <volume>6</volume>
        <fpage>e21588</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0021588</pub-id>
        <pub-id pub-id-type="pmid">21738720</pub-id>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McCabe</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>On serial files with relocatable records</article-title>
        <source>Operations Res.</source>
        <year>1965</year>
        <volume>12</volume>
        <fpage>609</fpage>
        <lpage>618</lpage>
        <pub-id pub-id-type="doi">10.1287/opre.13.4.609</pub-id>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kryukov</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Ueda</surname>
            <given-names>MT</given-names>
          </name>
          <name>
            <surname>Imanishi</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Nucleotide Archival Format (NAF) enables efficient lossless reference-free compression of DNA sequences</article-title>
        <source>Bioinformatics</source>
        <year>2019</year>
        <volume>35</volume>
        <fpage>3826</fpage>
        <lpage>3828</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btz144</pub-id>
        <pub-id pub-id-type="pmid">30799504</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
