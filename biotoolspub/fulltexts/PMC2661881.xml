<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Algorithms Mol Biol</journal-id>
    <journal-title>Algorithms for Molecular Biology : AMB</journal-title>
    <issn pub-type="epub">1748-7188</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2661881</article-id>
    <article-id pub-id-type="publisher-id">1748-7188-4-3</article-id>
    <article-id pub-id-type="pmid">19183438</article-id>
    <article-id pub-id-type="doi">10.1186/1748-7188-4-3</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Lossless filter for multiple repeats with bounded edit distance</article-title>
    </title-group>
    <contrib-group>
      <contrib id="A1" corresp="yes" contrib-type="author">
        <name>
          <surname>Peterlongo</surname>
          <given-names>Pierre</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>pierre.peterlongo@irisa.fr</email>
      </contrib>
      <contrib id="A2" contrib-type="author">
        <name>
          <surname>Sacomoto</surname>
          <given-names>Gustavo Akio Tominaga</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>sacomoto@gmail.com</email>
      </contrib>
      <contrib id="A3" contrib-type="author">
        <name>
          <surname>do Lago</surname>
          <given-names>Alair Pereira</given-names>
        </name>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>alair@ime.usp.br</email>
      </contrib>
      <contrib id="A4" contrib-type="author">
        <name>
          <surname>Pisanti</surname>
          <given-names>Nadia</given-names>
        </name>
        <xref ref-type="aff" rid="I4">4</xref>
        <email>pisanti@di.unipi.it</email>
      </contrib>
      <contrib id="A5" contrib-type="author">
        <name>
          <surname>Sagot</surname>
          <given-names>Marie-France</given-names>
        </name>
        <xref ref-type="aff" rid="I5">5</xref>
        <xref ref-type="aff" rid="I6">6</xref>
        <email>Marie-France.Sagot@inria.fr</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Équipe-projet Symbiose, IRISA/CNRS, Campus de Beaulieu, Rennes, France</aff>
    <aff id="I2"><label>2</label>Curso Experimental de Ciências Moleculares da Universidade de São Paulo, Brazil</aff>
    <aff id="I3"><label>3</label>Instituto de Matemática e Estatística da Universidade de São Paulo, Brazil</aff>
    <aff id="I4"><label>4</label>Dipartimento di Informatica, Università di Pisa, Italy</aff>
    <aff id="I5"><label>5</label>Équipe BAOBAB, Laboratoire de Biométrie et Biologie Evolutive (UMR 5558); CNRS; Univ. Lyon 1, Villeurbanne Cedex, France and Équipe-Projet BAMBOO, INRIA Rhône-Alpes, France</aff>
    <aff id="I6"><label>6</label>King's College, London, UK</aff>
    <pub-date pub-type="collection">
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>30</day>
      <month>1</month>
      <year>2009</year>
    </pub-date>
    <volume>4</volume>
    <fpage>3</fpage>
    <lpage>3</lpage>
    <ext-link ext-link-type="uri" xlink:href="http://www.almob.org/content/4/1/3"/>
    <history>
      <date date-type="received">
        <day>14</day>
        <month>9</month>
        <year>2008</year>
      </date>
      <date date-type="accepted">
        <day>30</day>
        <month>1</month>
        <year>2009</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2009 Peterlongo et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2009</copyright-year>
      <copyright-holder>Peterlongo et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        <!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Peterlongo
               Pierre
               
               pierre.peterlongo@irisa.fr
            </dc:author><dc:title>
            Lossless filter for multiple repeats with bounded edit distance
         </dc:title><dc:date>2009</dc:date><dcterms:bibliographicCitation>Algorithms for Molecular Biology 4(1): 3-. (2009)</dcterms:bibliographicCitation><dc:identifier type="sici">1748-7188(2009)4:1&#x0003c;3&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1748-7188</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>-->
      </license>
    </permissions>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Identifying local similarity between two or more sequences, or identifying repeats occurring at least twice in a sequence, is an essential part in the analysis of biological sequences and of their phylogenetic relationship. Finding such fragments while allowing for a certain number of insertions, deletions, and substitutions, is however known to be a computationally expensive task, and consequently exact methods can usually not be applied in practice.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>The filter <sc>TUIUIU</sc> that we introduce in this paper provides a possible solution to this problem. It can be used as a preprocessing step to any multiple alignment or repeats inference method, eliminating a possibly large fraction of the input that is guaranteed not to contain any approximate repeat. It consists in the verification of several strong necessary conditions that can be checked in a fast way. We implemented three versions of the filter. The first is simply a straightforward extension to the case of multiple sequences of an application of conditions already existing in the literature. The second uses a stronger condition which, as our results show, enable to filter sensibly more with negligible (if any) additional time. The third version uses an additional condition and pushes the sensibility of the filter even further with a non negligible additional time in many circumstances; our experiments show that it is particularly useful with large error rates. The latter version was applied as a preprocessing of a multiple alignment tool, obtaining an overall time (filter plus alignment) on average 63 and at best 530 times smaller than before (direct alignment), with in most cases a better quality alignment.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>To the best of our knowledge, <sc>TUIUIU</sc> is the first filter designed for multiple repeats and for dealing with error rates greater than 10% of the repeats length.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Repeats in genomes come under many forms, such as satellites that are approximate repeats of a pattern of up to a few hundred base pairs appearing in tandem (consecutively) along a genome, segmental duplications that are defined as the duplications of a DNA segment longer than 1 kb, and transposable elements that are sequences of DNA that can move to different positions within a genome in a process known as transposition, or retrotransposition if the element was first copied and the copy then moved. The last two are repeats dispersed along a genome. Most such repeats appear in intergenic regions and were for long believed to be "junk" DNA, that is DNA that has no specific function although the proportion of repeated segments in a genome can be huge. Transposable elements alone cover up to, for example, 45% of the human and 80% of the maize genomes. This view of repeats as "junk" is changing though.</p>
    <p>It is believed that transposable elements for instance may have been co-opted by the vertebrate immune system as a means of producing antibody diversity. Transposable elements are also thought to participate in gene regulation. This role had been suggested in the early 1950s by the discoverer of transposable elements herself, Barbara McClintock (she called such elements "mobile"), but she gave up publishing data supporting this idea in view of the strong opposition she was meeting from the academic world. The idea however stubbornly resisted denial or indifference and was resurrected much later. The paper of Lowe <italic>et al</italic>. [<xref ref-type="bibr" rid="B1">1</xref>] is just one of the last arguments in favour of a possible role for transposable elements in gene regulation. Indeed, by doing a genome-wide survey of 10402 characterised transposable elements, the authors found that these are most often located in regions of the human genome that contain very few genes, and show a strong preference for residing closest to genes involved in development and transcription regulation.</p>
    <p>The relation between satellites and recombination, and therefore between satellites and certain types of rearrangements, seems also clear. Less clear is the relation, direct or indirect, that satellites may have with gene regulation although it is increasingly more suspected that such exists, for instance mediated by the chromatin [<xref ref-type="bibr" rid="B2">2</xref>]. Indeed, satellites represent one of a number of features characterising the chromatin whose different levels of packaging help define whether genes are available for expression (in regions called the euchromatin), or generally silenced (in regions called the heterochromatin). Other types of repeats continue also to be discovered. Among the more recent ones are the so-called "pyknons" [<xref ref-type="bibr" rid="B3">3</xref>]. These are apparently non random patterns of repeated elements that have been found more frequently in the 3' UTR region of genes than in other parts of the human genome. Cross-genome comparisons have revealed that many of the pyknons identified in human have instances in the 3' UTRs of genes from other vertebrates and invertebrates where they also appear over-represented. Although it is unclear how pyknons might have arisen, it is thus possible that they are involved in a new form of gene regulation.</p>
    <p>The quantity of DNA in repeated sequences, the frequency of the repeat (that is, the number of times a given sequence is present per genome), and its conservation, show great variability across species. Frequencies from 100 to 1,000,000 have been observed, and the quantities of DNA involved range from 15 to 80 percent of a whole genome. Families of repeated sequences exhibit a degree of similarity among their members varying from perfect matching to matching of only two-thirds of the nucleotides. All these characteristics, plus the fact that in order to identify such repeats, it is necessary to work with whole genomes, that is with very long "texts", makes the identification of repeated elements a very hard computational problem.</p>
    <p>In this paper, we focus on the problem of finding long multiple repeats that may appear dispersed along one whole genome or chromosome, or are common to different genomes/chromosomes. More precisely, since we are working with very long texts, we focus on the problem of filtering one or more sequences prior to a full identification of the multiple repeats that it may contain. Informally put, the idea is to eliminate from the input sequence(s) as many regions as possible that are sure not to contain any repeats of the type and characteristics specified. In some cases, the filter may be efficient enough that it eliminates all regions except those precisely corresponding to the repeats.</p>
    <p>In the last few years, there has been an increasing number of papers on the topic of filtering sequences prior to further processing them. The motivations are varied, and include pattern matching [<xref ref-type="bibr" rid="B4">4</xref>-<xref ref-type="bibr" rid="B8">8</xref>], performing a local [<xref ref-type="bibr" rid="B9">9</xref>] or a global alignment [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B11">11</xref>], identifying repeats [<xref ref-type="bibr" rid="B12">12</xref>] or obtaining a multiple alignment [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B14">14</xref>].</p>
    <p>This trend has been motivated by the fact that the problem of aligning sequences has scaled up considerably with the increasing number of genomes, notably of eukaryotes, that are being entirely sequenced and annotated. We say that a filter is <italic>lossless </italic>if it guarantees not to discard any fragment that may be part of a repeat. Filters, lossless or not, have been devised for comparing one sequence with itself [<xref ref-type="bibr" rid="B12">12</xref>] or two sequences pairwise [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B13">13</xref>]. Most filters rest on the idea that sequences that are reasonably similar contain patterns that match exactly. This is our case also.</p>
    <p>To the best of our knowledge, filters for multiple repeats that take a multiple alignment condition into consideration have been addressed only in [<xref ref-type="bibr" rid="B15">15</xref>,<xref ref-type="bibr" rid="B16">16</xref>]. However, the authors in [<xref ref-type="bibr" rid="B15">15</xref>,<xref ref-type="bibr" rid="B16">16</xref>] allowed only for substituted basepairs between the different copies of a repeat, not indels. The method used in [<xref ref-type="bibr" rid="B15">15</xref>,<xref ref-type="bibr" rid="B16">16</xref>] is as a consequence quite different from the one in this paper. That method was based on a formula designed to characterise multiple repetitions without insertions nor deletions, and adopted a novel data structure employed to check the associated property. In the current paper, the conditions used are especially designed for edit distance and would not apply to Hamming distance. We therefore propose in this paper a filter, called <sc>TUIUIU</sc>, that: 1. is specifically taylored for multiple repeats, and 2. allows for a bounded edit distance among the different copies of a repeat, that is for deleted or inserted basepairs besides substitutions.</p>
    <p>Since we do not know any other work that is a filter for multiple repeats, in particular with the same type of outcomes, we do not consider other methods to compare directly with <sc>TUIUIU</sc>, but we try instead to reproduce as much as possible the filtering conditions used by other filtering approaches. In this sense, the closest method we compare <sc>TUIUIU</sc> to is <sc>SWIFT</sc>[<xref ref-type="bibr" rid="B6">6</xref>].</p>
    <p>The weakest of the filtering conditions we use corresponds to the filter used by <sc>SWIFT</sc>[<xref ref-type="bibr" rid="B6">6</xref>] for different purposes. Indeed, <sc>SWIFT</sc> was not developed with the same application in mind as <sc>TUIUIU</sc>. In particular, <sc>SWIFT</sc> is not a filter for multiple repeats, but a blast-like tool where the seeds are similarity regions with an error rate typically of at most 5%. Using <sc>TUIUIU</sc> as in <sc>SWIFT</sc> for pairwise comparison, we were able to improve the filtering power of <sc>SWIFT</sc> by applying two new conditions. <sc>TUIUIU</sc> is also able to deal with larger error levels, as high as 12%–14%. This implies however that bigger running times are also unavoidable. <sc>TUIUIU</sc> may be applied for finding two kinds of repeats: either repeats occurring in different sequences (like <sc>SWIFT</sc>) or repeats having multiple occurrences in a single sequence (something <sc>SWIFT</sc> cannot do). In both cases, the minimum number of occurrences, their length, and the minimum similarity degree between any pair of them, are user defined parameters.</p>
    <p>We tested <sc>TUIUIU</sc> on random synthetic sequences with planted (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeats using a very wide range of parameters. We also tested it on three sets of real data, the bacterium <italic>Neisseria meningitidis </italic>strain <italic>MC58</italic>, the human chromosome 22, and the dataset used in [<xref ref-type="bibr" rid="B13">13</xref>] denoted by <italic>CFTR </italic>(for Cystic Fibrosis Transmembrane conductance Regulator), adopting a similarly wide range of parameter sets. We found that our first additional filtration condition clearly leads to better results with negligible extra time, for all kinds of data and almost all parameter sets, with respect to the conditions previously used in the literature. Moreover, we also found that our second additional filtration condition considerably improves the selectiveness, with some time overhead, and becomes clearly advantageous mostly for large error rates.</p>
    <p>Our method may also be used to find anchors for global multiple aligners. We thus expect that our filter could serve as a preprocessing step to a local multiple alignment tool. To this purpose, <sc>TUIUIU</sc> was applied as a preprocessing step of a multiple alignment application, leading to an overall execution time (filter plus alignment) on average 63 and at best 530 times smaller than before (direct alignment) and also, in some cases, to a qualitative improvement of the alignment obtained.</p>
    <p>The rest of the paper is organised as follows. In the next section, we introduce formal definitions and the filtering conditions used in <sc>TUIUIU</sc>. In Section "Description of the algorithm", we first present the general structure of the algorithm, and we then specify the differences between the two versions of the algorithm (application to a single sequence or to a set of sequences). In Section "Complexity analysis", we provide a complexity analysis of both versions of the algorithm. In Section "Results and Discussion", we detail the experimental results obtained on biological DNA sequences, comparing different algorithmic strategies for filtering, including strategies used in other tools like <sc>SWIFT</sc>[<xref ref-type="bibr" rid="B6">6</xref>].</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Preliminary definitions</title>
      <p>A <italic>sequence </italic>is a concatenation of zero or more symbols from an alphabet Σ. In this work, we consider a sequence <italic>s </italic>of length <italic>n </italic>and we adopt the term <italic>word </italic>to denote a contiguous segment of <italic>s</italic>. We also consider an integer <italic>m </italic>≥ 2 and a set of sequences <italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>,...,<italic>s</italic><sub><italic>m </italic></sub>and in this case the term word is applied to a contiguous segment of one of the sequences <italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>,...,<italic>s</italic><sub><italic>m</italic></sub>. The sequence <italic>s </italic>of length <italic>n </italic>on Σ is represented by <italic>s</italic>[0]<italic>s</italic>[1]...<italic>s</italic>[<italic>n </italic>- 1], where <italic>s</italic>[<italic>i</italic>] ∈ Σ for 0 ≤ <italic>i </italic>&lt;<italic>n</italic>. We denote by <italic>s</italic>[<italic>i</italic>, <italic>j</italic>] the word <italic>s</italic>[<italic>i</italic>]<italic>s</italic>[<italic>i </italic>+ 1]...<italic>s</italic>[<italic>j</italic>] of <italic>s</italic>. In this case, we say that the word <italic>w </italic>= <italic>s</italic>[<italic>i</italic>, <italic>j</italic>] <italic>occurs at position i in s </italic>or that <italic>w starts at position i in s</italic>. We say that two words <italic>w </italic>= <italic>s</italic>[<italic>i</italic>, <italic>j</italic>] and <italic>w' </italic>= <italic>s</italic>[<italic>i'</italic>, <italic>j'</italic>] (corresponding to occurrences <italic>i </italic>and <italic>i'</italic>) <italic>overlap </italic>if the intersection of the intervals [<italic>i</italic>, <italic>j</italic>] and [<italic>i'</italic>, <italic>j'</italic>] is non-empty.</p>
      <p>We define a <italic>q-gram </italic>as a word of length <italic>q</italic>. The length of a word <italic>w </italic>is denoted by |<italic>w</italic>|. We recall that the edit distance between two given words is defined as the minimum number of edit operations that transform one into the other, where the considered <italic>edit operations </italic>are: symbol deletion, insertion or substitution.</p>
      <p><bold>Definition 1 </bold>((<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)<bold>-repeat</bold>) <italic>Given a sequence s and integers L </italic>&gt; 0, 0 ≤ <italic>d </italic>&lt;<italic>L and r </italic>≤ 2, <italic>an </italic>(<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeat <italic>is a set of r words in s not necessarily distinct but occurring at distinct positions, having length in the range </italic>[<italic>L </italic>- <italic>d</italic>, <italic>L </italic>+ <italic>d</italic>], <italic>being pairwise non overlapping, and such that the edit distance between any pair of them is at most d</italic>.</p>
      <p>Figure <xref ref-type="fig" rid="F1">1</xref> shows an example of an (<italic>L</italic>, <italic>d</italic>, 2)-repeat with <italic>L </italic>= 11 and <italic>d </italic>= 2.</p>
      <fig position="float" id="F1">
        <label>Figure 1</label>
        <caption>
          <p><bold>A (<italic>L</italic>, <italic>d</italic>, 2)-repeat and a parallelogram</bold>. An example a (<italic>L</italic>, <italic>d</italic>, 2)-repeat with <italic>L </italic>= 11, <italic>d </italic>= 2. Diagonals 30, 31, and 32 are shown. Among them, 30 and 32 have distance 2, while 30 and 31 (as well as 31 and 32) are consecutive. Assuming that <italic>q </italic>= 2, a <italic>q</italic>-hit is represented by a thicker diagonal of length 2 plus a small black circle representing its pair of coordinates. The <italic>q</italic>-hit (19, 49) refers to the <italic>q</italic>-gram <italic>TA</italic>, and 19 (resp. 49) is its first (resp. second) projection. The <italic>q</italic>-hit (17, 49) refers to the same <italic>q</italic>-gram <italic>TA </italic>but has a different first projection. The words inside the grey boxes are two distinct fragments of the same sequence <italic>s</italic>, namely <italic>s</italic>[10, 20] and s [42, 52]; they have length 11, and their edit distance is 2. We obtain one word from the other by deleting <italic>s</italic>[13] – hence no <italic>q</italic>-hits in positions 12, 13 – and by inserting s [48] – no <italic>q</italic>-hits in positions 47, 48. We have <italic>p </italic>= 6 and the set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> of 7 <italic>q</italic>-hits in diagonals 31 and 32 satisfies the properties (1), (2), (3), (4) and (5). If we add the <italic>q</italic>-hit in diagonal 30 in order to obtain a new set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1748-7188-4-3-i2" overflow="scroll"><mml:semantics><mml:msup><mml:mi mathvariant="script">S</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:semantics></mml:math></inline-formula>, properties (1), (2) still hold, but properties (3), (4) and (5) are no longer satisfied.</p>
        </caption>
        <graphic xlink:href="1748-7188-4-3-1"/>
      </fig>
      <p>Searching for multiple repeats means inferring all (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeats of the input sequence(s), with parameters <italic>L</italic>, <italic>d </italic>and <italic>r </italic>given by the user. Since these are computationally hard to find, we propose a preprocessing step to mask out from the input sequences as many positions as possible that cannot belong to a word of length <italic>L </italic>that is part of an (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeat. Since this condition is difficult to be quickly verified, we apply filtering conditions that are based on properties of the <italic>q</italic>-grams that simultaneously occur in two words of an (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeat, as we shall see from now on. Some of the techniques presented here have being used since 1985 by Ukkonen [<xref ref-type="bibr" rid="B7">7</xref>] and many other authors, but we follow more closely the definitions, techniques and properties given by Rasmussen et al. [<xref ref-type="bibr" rid="B6">6</xref>].</p>
      <p><bold>Definition 2 </bold><italic>Given a sequence s, a q</italic>-hit <italic>h is defined as a pair </italic>(<italic>i</italic>, <italic>j</italic>) <italic>such that at positions i and j of s we have the same q-gram, that is s</italic>[<italic>i</italic>, <italic>i </italic>+ <italic>q </italic>- 1] = <italic>w </italic>= <italic>s</italic>[<italic>j</italic>, <italic>j </italic>+ <italic>q </italic>- 1]. <italic>We also say that the word w is the q</italic>-gram of <italic>h</italic>. <italic>For any pair h </italic>= (<italic>i</italic>, <italic>j</italic>), <italic>i </italic>(<italic>resp</italic>. <italic>j</italic>) <italic>is </italic>the first projection (<italic>resp</italic>. second projection) <italic>of h</italic>.</p>
      <p><bold>Definition 3 </bold><italic>Given a q-hit h </italic>= (<italic>i</italic>, <italic>j</italic>), <italic>we say that the </italic>diagonal of <italic>h is </italic>diag(<italic>h</italic>) = {<italic>h' </italic>= (<italic>i'</italic>, <italic>j'</italic>)|<italic>j' </italic>- <italic>i' </italic>= <italic>j </italic>- <italic>i</italic>}, <italic>the set of all possible pairs of positions h' </italic>= (<italic>i'</italic>, <italic>j'</italic>) <italic>with the same difference of projections j </italic>- <italic>i</italic>. <italic>For convenience, we also say that this is </italic>the diagonal <italic>j </italic>- <italic>i </italic>(<italic>note that this number may be negative</italic>). <italic>We define the </italic>difference of the diagonals of <italic>h </italic>= (<italic>i</italic>, <italic>j</italic>) and of <italic>h' </italic>= (<italic>i'</italic>, <italic>j'</italic>), <italic>in this order</italic>, <italic>to be the difference </italic>(<italic>j </italic>- <italic>i</italic>) - (<italic>j'</italic>- <italic>i'</italic>). <italic>We say that two diagonals are </italic>consecutive <italic>if their difference is </italic>1 <italic>or </italic>-1.</p>
      <p>Figure <xref ref-type="fig" rid="F1">1</xref> shows an example of diagonals and <italic>q</italic>-hits.</p>
      <p>Let us consider a word <italic>w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] of length <italic>L </italic>and another word <italic>w' </italic>= <italic>s</italic>[<italic>a'</italic>, <italic>a' </italic>+ <italic>L </italic>- 1]. One can notice that if we had an edit distance 0 between <italic>w </italic>and <italic>w'</italic>, then all the <italic>L </italic>- <italic>q </italic>+ 1 pairs (<italic>a</italic>, <italic>a'</italic>),...,(<italic>a </italic>+ <italic>L </italic>- <italic>q</italic>, <italic>a' </italic>+ <italic>L </italic>- <italic>q</italic>) would be <italic>q</italic>-hits (there could be more if the same <italic>q</italic>-gram occurs at more than one position of <italic>s</italic>). Roughly speaking, notice that any edit operation applied to one of the sequences will shift the diagonal of a <italic>q</italic>-hit by at most 1 and possibly remove at most <italic>q q</italic>-hits. Hence, if <italic>w </italic>and <italic>w' </italic>are distant by at most <italic>d </italic>edit operations, then there must be at least <italic>p </italic>= (<italic>L </italic>- <italic>q </italic>+ 1) - <italic>qd q</italic>-hits. The <sc>TUIUIU</sc> filter verifies this property (first introduced in the proof of Theorem 5.1 of [<xref ref-type="bibr" rid="B7">7</xref>]), that is:</p>
      <p>
        <disp-formula id="bmcM1">
          <label>(1)</label>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1748-7188-4-3-i3" overflow="scroll">
            <mml:semantics>
              <mml:mrow>
                <mml:mtext>there exists for </mml:mtext>
                <mml:mi>w</mml:mi>
                <mml:mtext> and </mml:mtext>
                <mml:msup>
                  <mml:mi>w</mml:mi>
                  <mml:mo>′</mml:mo>
                </mml:msup>
                <mml:mtext> a set </mml:mtext>
                <mml:mi mathvariant="script">S</mml:mi>
                <mml:mtext> of </mml:mtext>
                <mml:mi>q</mml:mi>
                <mml:mtext>-hits of size at least </mml:mtext>
                <mml:mi>p</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>L</mml:mi>
                <mml:mo>−</mml:mo>
                <mml:mi>q</mml:mi>
                <mml:mo>+</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>−</mml:mo>
                <mml:mi>q</mml:mi>
                <mml:mi>d</mml:mi>
                <mml:mo>.</mml:mo>
              </mml:mrow>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>Moreover, in order to make the filtering condition more stringent, we also require that the set above is such that for any pair of <italic>q</italic>-hits <italic>h </italic>= (<italic>i</italic>, <italic>j</italic>) and <italic>h' </italic>= (<italic>i'</italic>, <italic>j'</italic>) in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula>, the following properties hold:</p>
      <p>
        <disp-formula id="bmcM2"><label>(2)</label>|diag(<italic>h</italic>) - diag(<italic>h'</italic>)| ≤ <italic>d</italic></disp-formula>
      </p>
      <p>
        <disp-formula id="bmcM3"><label>(3)</label><italic>i </italic>≠ <italic>i'</italic></disp-formula>
      </p>
      <p>
        <disp-formula id="bmcM4"><label>(4)</label><italic>j </italic>≠ <italic>j'</italic></disp-formula>
      </p>
      <p>
        <disp-formula id="bmcM5"><label>(5)</label><italic>i </italic>&lt;<italic>i' </italic>if and only if <italic>j </italic>&lt;<italic>j'</italic></disp-formula>
      </p>
      <p>In Figure <xref ref-type="fig" rid="F1">1</xref> we can see examples for these properties that we motivate as follows. As mentioned above, an edit operation shifts the diagonal of a <italic>q</italic>-hit by at most one position. Thus, <italic>d </italic>edit operations can shift this diagonal by at most <italic>d </italic>positions, which explains property 2 (already used by the filter in [<xref ref-type="bibr" rid="B6">6</xref>]). We now prove that properties 3, 4 and 5 are also necessary conditions. These, to the best of our knowledge, were not used in previous filters while they will be considered in <sc>TUIUIU</sc>.</p>
      <p><bold>Theorem 1 </bold><italic>if w </italic>= <italic>s </italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] <italic>and w' </italic>= <italic>s </italic>[<italic>a'</italic>, <italic>a' </italic>+ <italic>L </italic>- 1] <italic>are distant by at most d edit operations, then there are at least p </italic>= (<italic>L </italic>- <italic>q </italic>+ 1) - <italic>qd q-hits that pairwise verify properties 3, 4 and 5</italic>.</p>
      <p><italic>Proof</italic>. Let <italic>W </italic>and <italic>W' </italic>be sequences on the alphabet Σ ∪ {-} where '-' ∉ Σ such that:</p>
      <p>• there is no <italic>i </italic>∈ [0, |<italic>W</italic>| - 1] with both <italic>W</italic>[<italic>i</italic>] and <italic>W'</italic>[<italic>i</italic>] equal to '-';</p>
      <p>• <italic>L </italic>≤ |<italic>W</italic>| = |<italic>W'</italic>| ≤ <italic>L </italic>+ <italic>d</italic>;</p>
      <p>• the sequence obtained from <italic>W </italic>(resp. <italic>W'</italic>) by deleting all characters '-' is equal to <italic>w </italic>(resp. <italic>w'</italic>);</p>
      <p>• <italic>W </italic>and <italic>W' </italic>are a representation of an optimal alignment between <italic>w </italic>and <italic>w' </italic>where the symbol '-' represents a gap and with cost function corresponding to the edit distance (0 for a match, 1 for any other edit operation).</p>
      <p>Let now <italic>X </italic>be a sequence over the alphabet {M, D} such that:</p>
      <p>• |<italic>X</italic>| = |<italic>W</italic>| = |<italic>W'</italic>|;</p>
      <p>for all <italic>i </italic>from 1 to |<italic>X</italic>|, <italic>X</italic>[<italic>i</italic>] = <italic>M </italic>if <italic>W</italic>[<italic>i</italic>] = <italic>W'</italic>[<italic>i</italic>], else <italic>X</italic>[<italic>i</italic>] = <italic>D</italic>.</p>
      <p>We now prove the following lemma.</p>
      <p><bold>Lemma 1 </bold><italic>There are at least p </italic>= (<italic>L </italic>- <italic>q </italic>+ 1) - <italic>qd distinct positions i such that for all j </italic>∈ [0, <italic>q </italic>- 1], <italic>X </italic>[<italic>i </italic>+ <italic>j</italic>] = <italic>M</italic>, <italic>that is, at least p </italic>= (<italic>L </italic>- <italic>q </italic>+ 1) - <italic>qd positions i where a run of Ms of size at least q begins</italic>.</p>
      <p><italic>Proof</italic>. Obviously, there can be at most |<italic>X</italic>| - <italic>q </italic>+ 1 runs of <italic>M</italic>s of size at least <italic>q </italic>in <italic>X</italic>. Furthermore, each character <italic>D </italic>in <italic>X </italic>destroys at most <italic>qd </italic>runs of <italic>M</italic>s since there can be at most <italic>d D</italic>s in <italic>X</italic>. If <italic>N </italic>is the number of runs of <italic>M</italic>s of size at least <italic>q </italic>in <italic>X</italic>, we thus have:</p>
      <p>
        <disp-formula><italic>N </italic>≥ (|<italic>X</italic>| - <italic>q </italic>+ 1) - <italic>qd </italic>≥ (<italic>L </italic>- <italic>q </italic>+ 1) - <italic>qd</italic></disp-formula>
      </p>
      <p>runs of <italic>M</italic>s of size at least <italic>q </italic>in <italic>X</italic>.   □</p>
      <p>By the way <italic>X </italic>was built and from Lemma 1, there are at least (<italic>L </italic>- <italic>q </italic>+ 1) - <italic>qd </italic>runs of <italic>q M</italic>s. Each pair of such runs corresponds to two <italic>q</italic>-hits themselves corresponding to two distinct <italic>q</italic>-grams in <italic>w </italic>(at positions <italic>i </italic>and <italic>i'</italic>) and in <italic>w' </italic>(at positions <italic>j </italic>and <italic>j'</italic>), proving conditions 3 and 4. Obviously, if the <italic>q</italic>-hit (<italic>i</italic>, <italic>j</italic>) (resp. (<italic>i'</italic>, <italic>j'</italic>)) occurs first, then <italic>i </italic>&gt; <italic>i' </italic>and <italic>j </italic>&gt; <italic>j' </italic>(resp. <italic>i' </italic>&gt; <italic>i </italic>and <italic>j' </italic>&gt; <italic>j</italic>), proving condition 5.   □</p>
      <p>Observe that the above proof follows a reasoning somewhat similar to the one in [<xref ref-type="bibr" rid="B7">7</xref>]. In the remaining of this section, we introduce some terminology that we use to explain the actual steps performed by <sc>TUIUIU</sc> in order to verify the properties listed above.</p>
      <p>For any word <italic>w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1], we want to check whether it belongs to an (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeat. Suppose this is the case, that is, there exists words <italic>w</italic><sub><italic>k</italic></sub>, for <italic>k </italic>= 1, 2,...,<italic>r </italic>- 1 such that <italic>w </italic>and <italic>w</italic><sub><italic>k </italic></sub>have edit distance no more than <italic>d</italic>. For each pair of words <italic>w </italic>and <italic>w</italic><sub><italic>k</italic></sub>, the computation of the edit distance would take as much as <italic>θ</italic>(<italic>dL</italic>) time for the best algorithm. Instead, we count the <italic>q</italic>-hits of these two words and we verify whether they are at least <italic>p</italic>, because there must be for <italic>w </italic>and <italic>w</italic><sub><italic>k </italic></sub>a set of <italic>q</italic>-hits <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> that satisfies property (1). The <italic>q</italic>-hits could theoretically be as many as (<italic>L </italic>- <italic>q </italic>+ 1) × (<italic>L </italic>+ <italic>d </italic>- <italic>q </italic>+ 1). Nevertheless, if we also consider that property (2) must be satisfied by any pair of <italic>q</italic>-hits in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula>, then we can count <italic>q</italic>-hits only within the limited region of <italic>d </italic>+ 1 consecutive diagonals (like the diagonals 30, 31 and 32 in Figure <xref ref-type="fig" rid="F1">1</xref>) which includes no more than (<italic>d </italic>+ 1) × (<italic>L </italic>- <italic>q </italic>+ 1) possible <italic>q</italic>-hits. This shows us the convenience of sorting the <italic>q</italic>-hits by diagonals. Let us formalise this idea by introducing the notion of a <italic>parallelogram</italic>, that is found in [<xref ref-type="bibr" rid="B6">6</xref>].</p>
      <p><bold>Definition 4 (parallelogram) </bold><italic>Given a word w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] <italic>of length L, and the set of d </italic>+ 1 <italic>consecutive diagonals </italic>[<italic>c</italic>, <italic>c </italic>+ <italic>d</italic>], <italic>with d </italic>&lt;<italic>L</italic>, <italic>we define the respective parallelogram as the set of all pairs</italic>:</p>
      <p>
        <disp-formula>Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) = {(<italic>i</italic>, <italic>j</italic>)|<italic>i </italic>∈ [<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- <italic>q</italic>], <italic>j </italic>- <italic>i </italic>∈ [<italic>c</italic>, <italic>c </italic>+ <italic>d</italic>]}.</disp-formula>
      </p>
      <p>In Figure <xref ref-type="fig" rid="F1">1</xref>, the grey highlighted parallelogram represents the parallelogram Parall(10, 11, 30, 2). Notice that the <italic>q</italic>-hits (19, 49) and (19, 51) (are pairs that) <italic>do </italic>belong to Parall(10, 11, 30, 2), according to the definition.</p>
      <p>A few observations can be made. The first is that <italic>a </italic>and <italic>c </italic>are such that the top left position of the parallelogram is (<italic>a</italic>, <italic>a </italic>+ <italic>c</italic>). Indeed, <italic>a </italic>and <italic>a </italic>+ <italic>c </italic>are the starting positions of the two words delimiting the parallelogram that contains the <italic>q</italic>-hits. Second, <italic>a </italic>+ <italic>L </italic>- <italic>q </italic>is the greatest position <italic>i </italic>such that the <italic>q</italic>-gram <italic>s</italic>[<italic>i</italic>, <italic>i </italic>+ <italic>q </italic>- 1] is a word of <italic>w </italic>= <italic>s </italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1]. The third observation is that the parallelogram Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) has (<italic>L </italic>- <italic>q </italic>+ 1) × (<italic>d </italic>+ 1) pairs and this is its <italic>size</italic>. Finally, a pair <italic>h </italic>= (<italic>i</italic>, <italic>j</italic>) ∈ Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) may or may not be a <italic>q</italic>-hit, depending on whether or not <italic>w </italic>[<italic>i</italic>, <italic>i </italic>+ <italic>q </italic>- 1] = <italic>w </italic>[<italic>j</italic>, <italic>j </italic>+ <italic>q </italic>- 1].</p>
      <p>Given a word <italic>w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1], the parallelogram Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) is used to check properties (1) and (2) for <italic>w </italic>against a word <italic>w</italic><sub><italic>k </italic></sub>that is candidate to be one of the <italic>r </italic>- 1 words which, together with <italic>w</italic>, are part of an (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeat. This is done in the following way. Let <italic>w </italic>and <italic>w</italic><sub><italic>k </italic></sub>= <italic>s</italic>[<italic>u</italic>, <italic>v</italic>] be an (<italic>L</italic>, <italic>d</italic>, 2)-repeat, and consider an optimal alignment of these two words. The pairs of matched positions described in this alignment belong to no more than <italic>d </italic>+ 1 consecutive diagonals. In particular, there is a diagonal <italic>c </italic>with <italic>c </italic>such that <italic>u </italic>∈ [<italic>c </italic>+ <italic>a</italic>, <italic>c </italic>+ <italic>d </italic>+ <italic>a</italic>] and <italic>v </italic>∈ [<italic>c </italic>+ <italic>a </italic>+ <italic>L </italic>- 1, <italic>c </italic>+ <italic>d </italic>+ <italic>a </italic>+ <italic>L </italic>- 1] where the matched positions belong to the union of the diagonals <italic>c</italic>, <italic>c </italic>+ 1,...,<italic>c </italic>+ <italic>d</italic>. In this case, we say that the parallelogram Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) <italic>detects </italic>this (<italic>L</italic>, <italic>d</italic>, 2)-repeat. This is why we can limit the search of the <italic>q</italic>-hits of <italic>w </italic>and <italic>w</italic><sub><italic>k </italic></sub>to within the parallelogram.</p>
      <p>Consider now the word <italic>x </italic>= <italic>s</italic>[<italic>c </italic>+ <italic>d </italic>+ <italic>a</italic>, <italic>c </italic>+ <italic>a </italic>+ <italic>L </italic>- 1] of length <italic>L </italic>- <italic>d </italic>that is contained in <italic>w</italic><sub><italic>k</italic></sub>, which in turn is contained in the word <italic>z </italic>= <italic>s</italic>[<italic>c </italic>+ <italic>a</italic>, <italic>c </italic>+ <italic>d </italic>+ <italic>a </italic>+ <italic>L </italic>- 1], having length <italic>L </italic>+ <italic>d</italic>. Both <italic>x </italic>and <italic>z </italic>are shown in Figure <xref ref-type="fig" rid="F2">2</xref> for the darkest of the two parallelograms.</p>
      <fig position="float" id="F2">
        <label>Figure 2</label>
        <caption>
          <p><bold>Detection of (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeats and two overlapping parallelograms</bold>. Two parallelograms that overlap. The dark grey parallelogram in the figure detects <italic>q</italic>-hits between <italic>w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] and any word <italic>w</italic><sub><italic>k </italic></sub>= <italic>s</italic>[<italic>i</italic>, <italic>j</italic>] with <italic>i </italic>∈ [<italic>c </italic>+ <italic>a</italic>, <italic>c </italic>+ <italic>d </italic>+ <italic>a</italic>] and <italic>j </italic>∈ [<italic>c </italic>+ <italic>a </italic>+ <italic>L </italic>- 1, <italic>c </italic>+ <italic>d </italic>+ <italic>a </italic>+ <italic>L </italic>- 1]. The word <italic>z </italic>= <italic>s</italic>[<italic>c </italic>+ <italic>a</italic>, <italic>c </italic>+ <italic>d </italic>+ <italic>a </italic>+ <italic>L </italic>- 1] of length <italic>L </italic>+ <italic>d </italic>contains the word <italic>w</italic><sub><italic>k </italic></sub>which in turn contains the word <italic>x </italic>= <italic>s</italic>[<italic>c </italic>+ <italic>d </italic>+ <italic>a</italic>, <italic>c </italic>+ <italic>a </italic>+ <italic>L </italic>- 1] of length <italic>L </italic>- <italic>d</italic>. Analogously for the light gray parallelogram, the word <italic>z' </italic>= <italic>s</italic>[<italic>c' </italic>+ <italic>a</italic>, <italic>c' </italic>+ <italic>d </italic>+ <italic>a </italic>+ <italic>L </italic>- 1] of length <italic>L </italic>+ <italic>d </italic>contains a word <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1748-7188-4-3-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>w</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> which in turn contains the word <italic>x' </italic>= <italic>s</italic>[<italic>c' </italic>+ <italic>d </italic>+ <italic>a</italic>, <italic>c' </italic>+ <italic>a </italic>+ <italic>L </italic>- 1] of length <italic>L </italic>- <italic>d</italic>. The words <italic>w</italic><sub><italic>k </italic></sub>and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1748-7188-4-3-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>w</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> are not shown because their length is variable. They necessarily overlap because they both contain the word <italic>p </italic>= <italic>s</italic>[<italic>c' </italic>+ <italic>d </italic>+ <italic>a</italic>, <italic>c </italic>+ <italic>a </italic>+ <italic>L </italic>- 1], that is the overlap between <italic>x </italic>and <italic>x'</italic>.</p>
        </caption>
        <graphic xlink:href="1748-7188-4-3-2"/>
      </fig>
      <p>Notice that, since <italic>d </italic>&lt;<italic>L</italic>, <italic>x </italic>is well defined because <italic>c </italic>+ <italic>d </italic>+ <italic>a </italic>≤ <italic>c </italic>+ <italic>a </italic>+ <italic>L </italic>- 1. Therefore, we have that any other (<italic>L</italic>, <italic>d</italic>, 2)-repeat {<italic>w</italic>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1748-7188-4-3-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>w</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>} detected by the same parallelogram would be such that <italic>w</italic><sub><italic>k </italic></sub>and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1748-7188-4-3-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>w</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> overlap because they both contain <italic>x</italic>. This ensures that, for a word <italic>w</italic>, no two non-overlapping repeats could be detected by the same parallelogram.</p>
      <p>We say that two parallelograms Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) and Parall(<italic>a</italic>, <italic>L</italic>, <italic>c'</italic>, <italic>d</italic>) <italic>overlap </italic>if the words <italic>x </italic>= <italic>s</italic>[<italic>c </italic>+ <italic>d </italic>+ <italic>a</italic>, <italic>c </italic>+ <italic>a </italic>+ <italic>L </italic>- 1] and <italic>x' </italic>= <italic>s</italic>[<italic>c' </italic>+ <italic>d </italic>+ <italic>a</italic>, <italic>c' </italic>+ <italic>a </italic>+ <italic>L </italic>- 1] overlap. If <italic>c </italic>&lt;<italic>c'</italic>, this happens if <italic>c </italic>+ <italic>a </italic>+ <italic>L </italic>- 1 ≥ <italic>c' </italic>+ <italic>d </italic>+ <italic>a</italic>. In other words, parallelograms Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) and Parall(<italic>a</italic>, <italic>L</italic>, <italic>c'</italic>, <italic>d</italic>) overlap if and only if</p>
      <p>
        <disp-formula>|<italic>c' </italic>- <italic>c</italic>| &lt;<italic>L </italic>- <italic>d</italic>.</disp-formula>
      </p>
      <p>In Figure <xref ref-type="fig" rid="F2">2</xref> we can see two parallelograms that overlap, where the overlap <italic>p </italic>= <italic>s</italic>[<italic>c' </italic>+ <italic>d </italic>+ <italic>a</italic>, <italic>c </italic>+ <italic>a </italic>+ <italic>L </italic>- 1] between <italic>x </italic>and <italic>x' </italic>is highlighted.</p>
      <p>In general, if Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) detects the (<italic>L</italic>, <italic>d</italic>, 2)-repeat <italic>w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] and <italic>w</italic><sub><italic>k </italic></sub>= <italic>s</italic>[<italic>u</italic>, <italic>v</italic>], and Parall(<italic>a</italic>, <italic>L</italic>, <italic>c'</italic>, <italic>d</italic>) detects the (<italic>L</italic>, <italic>d</italic>, 2)-repeat <italic>w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1748-7188-4-3-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>w</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> = <italic>s</italic>[<italic>u'</italic>, <italic>v'</italic>], and if the two parallelograms overlap, then the words <italic>w</italic><sub><italic>k </italic></sub>= <italic>s</italic>[<italic>u</italic>, <italic>v</italic>] and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1748-7188-4-3-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:msup><mml:mi>w</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> = <italic>s</italic>[<italic>u'</italic>, <italic>v'</italic>] also overlap. We say that a set of parallelograms is <italic>non-overlapping </italic>if no two of them overlap.</p>
      <p>Since <italic>w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] and <italic>w</italic><sub><italic>k </italic></sub>= <italic>s</italic>[<italic>u</italic>, <italic>u </italic>+ <italic>L' </italic>- 1] are two words with edit distance no more than <italic>d</italic>, the existence of a set of <italic>q</italic>-hits <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> that satisfies properties (1) and (2) implies that there are at least <italic>p q</italic>-hits inside a parallelogram Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) with <italic>c </italic>such that <italic>a </italic>+ <italic>c </italic>≤ <italic>u </italic>≤ <italic>a </italic>+ <italic>c </italic>+ <italic>d</italic>.</p>
      <p>We say that a parallelogram is <italic>fine </italic>if there are at least <italic>p q</italic>-hits inside the parallelogram. For example, the parallelogram highlighted in Figure <xref ref-type="fig" rid="F1">1</xref> is fine, with a set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1748-7188-4-3-i2" overflow="scroll"><mml:semantics><mml:msup><mml:mi mathvariant="script">S</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:semantics></mml:math></inline-formula> of 8 <italic>q</italic>-hits inside. This leads us to our first filtering condition, that is easy to be efficiently checked:</p>
      <p><italic>for any word w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1], <italic>we keep the positions in the interval </italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] <italic>if there exist at least r </italic>fine <italic>non-overlapping parallelograms </italic>Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic><sub><italic>i</italic></sub>, <italic>d</italic>), <italic>with c</italic><sub><italic>i </italic></sub>∈ {<italic>c</italic><sub>1</sub>,...,<italic>c</italic><sub><italic>r</italic></sub>}.</p>
      <p>It is worth noticing that <italic>w </italic>itself generates a fine parallelogram, which explains why we check the existence of <italic>r fine </italic>non-overlapping parallelograms instead of <italic>r </italic>- 1.</p>
      <p>We are now going to see two more stringent filtering conditions leading to the additional conditions actually applied by <sc>TUIUIU</sc>.</p>
      <p>First, we require that the set of <italic>q</italic>-hits inside the parallelogram satisfy property (3). This property simply ensures that two distinct <italic>q</italic>-hits of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> do not share a first projection. We say that a parallelogram is <italic>good </italic>if and only if there are at least <italic>p q</italic>-hits inside the parallelogram such that no two of these <italic>q</italic>-hits have the same first projection. In Figure <xref ref-type="fig" rid="F1">1</xref>, the set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> contains 7 <italic>q</italic>-hits that pairwise satisfy property (3), and hence the highlighted parallelogram is good. This leads us to our second filtering condition that is also easy to be efficiently checked:</p>
      <p><italic>for any word w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1], <italic>we keep the positions in the interval </italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] <italic>if there exist at least r </italic>good <italic>non-overlapping parallelograms </italic>Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic><sub><italic>i</italic></sub>, <italic>d</italic>), <italic>with c</italic><sub><italic>i </italic></sub>∈ {<italic>c</italic><sub>1</sub>,...,<italic>c</italic><sub><italic>r</italic></sub>}.</p>
      <p>Second, we can further require that the set of <italic>q</italic>-hits <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> inside Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) satisfies also property (5). We say that a good parallelogram is <italic>excellent </italic>if and only if there are at least <italic>p q</italic>-hits inside the parallelogram such that any two of them satisfy property (5). Given that <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> contains distinct <italic>q</italic>-hits, we have that, if property (5) holds for all pairs of <italic>q</italic>-hits in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula>, then properties (3) and (4) also do. Therefore, requiring property (5) for <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> guarantees that properties (3) and (4) hold as well. In Figure <xref ref-type="fig" rid="F1">1</xref>, the set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M21" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> of 7 <italic>q</italic>-hits satisfies property (5) and, indeed, also satisfies property (3) and property (4). In fact, the highlighted parallelogram is excellent. This leads us to our third and last filtering condition that can be expected to be efficiently checked for general cases:</p>
      <p><italic>for any word w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1], <italic>we keep the positions in the interval </italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] <italic>if there exist at least r </italic>excellent <italic>non-overlapping parallelograms </italic>Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic><sub><italic>i</italic></sub>, <italic>d</italic>), <italic>with c</italic><sub><italic>i </italic></sub>∈ {<italic>c</italic><sub>1</sub>,...,<italic>c</italic><sub><italic>r</italic></sub>}.</p>
    </sec>
    <sec>
      <title>Necessary condition applied by <sc>TUIUIU</sc></title>
      <p>Given a sequence <italic>s </italic>and the parameters <italic>L</italic>, <italic>d</italic>, <italic>r </italic>described above, <sc>TUIUIU</sc> tries to keep only those positions of <italic>s </italic>inside an interval [<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] such that the word <italic>w </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1] of length <italic>L </italic>belongs to an (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeat. Since this condition is hard to be efficiently verified, only necessary conditions are checked:</p>
      <p><italic>for any interval </italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1], <sc>TUIUIU</sc><italic> keeps these positions if there exists at least r </italic>excellent (<italic>or </italic>fine <italic>or </italic>good <italic>if the user so prefers</italic>) <italic>non-overlapping parallelograms </italic>Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic><sub><italic>i</italic></sub>, <italic>d</italic>), <italic>with c</italic><sub><italic>i </italic></sub>∈ {<italic>c</italic><sub>1</sub>,...,<italic>c</italic><sub><italic>r</italic></sub>}.</p>
    </sec>
    <sec>
      <title>Description of the algorithm</title>
      <p>We now give an overview of the algorithm applied by <sc>TUIUIU</sc> whose pseudocode is provided in Appendix 1.</p>
      <p>For any possible <italic>q</italic>-gram, we build the list of all its occurrences in <italic>s</italic>. The sum of the sizes of the |Σ|<sup><italic>q </italic></sup>occurrences lists is <italic>n </italic>- <italic>q </italic>+ 1. They are concatenated and stored in an array of <italic>n </italic>- <italic>q </italic>+ 1 positions and are accessed through |Σ|<sup><italic>q </italic></sup>pointers, one for each possible <italic>q</italic>-gram (line 1).</p>
      <p>We move a sliding window <italic>w </italic>= <italic>s</italic>[<italic>i</italic>, <italic>i </italic>+ <italic>L </italic>- 1] of length <italic>L </italic>along <italic>s </italic>and only <italic>q</italic>-hits relative to this sliding window are considered. For each position <italic>i</italic>, we have to consider all possible parallelograms, i.e. Parall(<italic>i</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) for <italic>c </italic>∈ [-<italic>i</italic>, <italic>n </italic>- <italic>i </italic>- <italic>d </italic>+ 1].</p>
      <p>Thus, in order to quickly verify which parallelograms are fine, we associate a <italic>q</italic>-hit counter to every parallelogram. First, counters are initialised for the position zero of the sliding window (lines 1 and 1). This initialisation is straightforward: for all <italic>q</italic>-grams occurring in [0, <italic>L </italic>- <italic>q</italic>], we check whether they create at least one <italic>q</italic>-hit in each parallelogram. If this is the case, the corresponding parallelogram counters are increased by one. Once the window is slided from position <italic>i </italic>- 1 to position <italic>i</italic>, the <italic>q</italic>-hits involving the <italic>q</italic>-gram that occurs at position <italic>i </italic>- 1 are not considered anymore, while those involving the "new" <italic>q</italic>-gram at position <italic>i </italic>+ <italic>L </italic>- <italic>q </italic>have to be taken into account. In terms of parallelograms, this corresponds to observing that the parallelograms Parall(<italic>i </italic>- 1, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) and Parall(<italic>i</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) differ only by the pairs (<italic>i </italic>- 1, <italic>j</italic>) and (<italic>i </italic>+ <italic>L </italic>- <italic>q</italic>, <italic>j</italic>) for <italic>j </italic>∈ [<italic>c</italic>, <italic>c </italic>+ <italic>d</italic>]. Therefore, in order to obtain the number of <italic>q</italic>-hits in Parall(<italic>i</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>), we only need to subtract from the number of <italic>q</italic>-hits in Parall(<italic>i </italic>- 1, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>), the number of <italic>q</italic>-hits of the form (<italic>i </italic>- 1, <italic>j</italic>) for <italic>j </italic>∈ [<italic>c</italic>, <italic>c </italic>+ <italic>d</italic>], and we have to add the number of <italic>q</italic>-hits of the form (<italic>i </italic>+ <italic>L </italic>- <italic>q</italic>, <italic>j</italic>) for j ∈ [<italic>c</italic>, <italic>c </italic>+ <italic>d</italic>]. Thus, when sliding the window in <italic>s </italic>from position <italic>i </italic>- 1 to <italic>i</italic>, we just have to consider all occurrences of the <italic>q</italic>-grams <italic>s</italic>[<italic>i </italic>- 1, <italic>i </italic>+ <italic>q </italic>- 2] (that are leaving) and those of <italic>s</italic>[<italic>i </italic>+ <italic>L </italic>- <italic>q</italic>, <italic>i </italic>+ <italic>L </italic>- 1] (that are entering) and do the following (lines 1 and 1 of algorithm 1). For any occurrence <italic>j </italic>of the entering <italic>q</italic>-gram, we have a <italic>q</italic>-hit (<italic>i </italic>+ <italic>L </italic>- <italic>q</italic>, <italic>j</italic>) and we increment the counters (line 1) of all parallelograms to which this <italic>q</italic>-hit belongs to. Conversely, for any occurrence <italic>j </italic>of the leaving <italic>q</italic>-gram, we have a <italic>q</italic>-hit (<italic>i </italic>- 1, <italic>j</italic>) that no longer involves the word of the current sliding window, and hence we decrement the counters (line 1) of all the parallelograms it belongs.</p>
      <p>Observe that each <italic>q</italic>-hit would belong to <italic>d </italic>+ 1 consecutive parallelograms, for example the <italic>q</italic>-hit (<italic>i</italic>, <italic>j</italic>) belongs to the parallelograms Parall(<italic>i</italic>, <italic>L</italic>, (<italic>i </italic>- <italic>j</italic>) - <italic>k</italic>, <italic>d</italic>) for <italic>k </italic>∈ [0, <italic>d</italic>]. As a result, for each <italic>q</italic>-hit, we should update <italic>d </italic>+ 1 counters. In order to reduce this number, we apply a strategy that was already used both in <sc>SWIFT</sc>[<xref ref-type="bibr" rid="B6">6</xref>] and in <sc>QUASAR</sc>[<xref ref-type="bibr" rid="B4">4</xref>]. We enlarge the parallelogram from <italic>d </italic>+ 1 diagonals to <italic>d </italic>+ <italic>b </italic>diagonals (<sc>SWIFT</sc> actually uses <italic>d </italic>+ <italic>b </italic>+ 1 diagonals.) where <italic>b </italic>≥ 1. Recall that to avoid the possible presence of two non overlapping occurrences of a repeat in the same parallelogram, we must have that the width of the parallelogram should not exceed <italic>L</italic>, and hence <italic>b </italic>must be such that <italic>d </italic>+ <italic>b </italic>&lt;<italic>L</italic>.</p>
      <p>In this way, the parallelograms Parall(<italic>i</italic>, <italic>L</italic>, <italic>k</italic>, <italic>d</italic>) for <italic>k </italic>∈ [<italic>c</italic>, <italic>c </italic>+ <italic>b </italic>- 1] are joined in the <italic>enlarged </italic>parallelogram Parall(<italic>i</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d </italic>+ <italic>b </italic>- 1). In practice, this means setting a unique counter for all Parall(<italic>i</italic>, <italic>L</italic>, <italic>k</italic>, <italic>d</italic>) with <italic>k </italic>∈ [<italic>c</italic>, <italic>c </italic>+ <italic>b </italic>- 1]. Therefore, in order to search for repeats in the whole input sequence, instead of considering all Parall(<italic>i</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) for <italic>c </italic>∈ [-<italic>i</italic>, <italic>n </italic>- <italic>i </italic>- <italic>d </italic>+ 1], it is enough to check for Parall(<italic>i</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d </italic>+ <italic>b </italic>- 1) with <italic>c </italic>= <italic>k'b</italic>, for <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M22" name="1748-7188-4-3-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mo>−</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mfrac><mml:mi>i</mml:mi><mml:mi>b</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>b</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>, because every parallelogram Parall(<italic>i</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>) is contained in one of these enlarged parallelograms (see Figure <xref ref-type="fig" rid="F3">3</xref> for an example). The reason for this modification is that now a <italic>q</italic>-hit can only be shared by <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M23" name="1748-7188-4-3-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> parallelograms. Thus, from <italic>d </italic>+ 1 updates per <italic>q</italic>-hit, we reduce to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M24" name="1748-7188-4-3-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> updates per <italic>q</italic>-hit. This means 2 updates per <italic>q</italic>-hit if as default value. For <italic>b </italic>we adopt the smallest power of 2 (speeding up the divisions by <italic>b</italic>) greater than <italic>d</italic>, like in [<xref ref-type="bibr" rid="B6">6</xref>]. Since <italic>b </italic>parallelograms will be combined into one enlarged parallelogram, the probability that one enlarged parallelogram is judged to be fine/good/excellent increases. As concerns the filtering conditions, we just replace parallelograms that deal with <italic>d </italic>+ 1 diagonals with parallelograms that deal with <italic>d </italic>+ <italic>b </italic>diagonals. The filter remains lossless, but this enlargement of the parallelograms implies that it may not be as selective as it could be. On the other hand, this enlargement makes the filter much faster.</p>
      <fig position="float" id="F3">
        <label>Figure 3</label>
        <caption>
          <p><bold>Enlarging parallelograms from <italic>d </italic>+ 1 to <italic>d </italic>+ <italic>b </italic>diagonals</bold>. Four parallelograms with <italic>b </italic>+ <italic>d </italic>diagonals, starting in diagonals <italic>kb</italic>, for any integer <italic>k</italic>. Example with <italic>d </italic>= 3, <italic>b </italic>= 4. Notice that two consecutive enlarged parallelograms of this form share <italic>d </italic>common diagonals and that any parallelogram with <italic>d </italic>+ 1 diagonals is contained in one such enlarged parallelogram with <italic>b </italic>+ <italic>d </italic>diagonals.</p>
        </caption>
        <graphic xlink:href="1748-7188-4-3-3"/>
      </fig>
      <p>Back to the pseudocode shown in Algorithm 1, for each value of <italic>j</italic>, line 1 now updates up to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M25" name="1748-7188-4-3-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> counters. When a counter reaches <italic>p</italic>, then the corresponding parallelogram is fine. Since we can also easily check what was the last updated counter, and since the occurrences lists are ordered, we can also only update counters that were not yet updated by the current occurrences list (line 1). This allows us to easily count first projections of <italic>q</italic>-hits instead of simply counting <italic>q</italic>-hits. Doing this, when the counter of <italic>q</italic>-hit projections reaches <italic>p</italic>, then we directly detect that the corresponding parallelogram is good (line 1).</p>
      <p>For a given sliding window <italic>w </italic>= <italic>s</italic>[<italic>i</italic>, <italic>i </italic>+ <italic>L </italic>- 1], we search for excellent parallelograms (line 1) only if at least <italic>r </italic>good parallelograms are detected (line 1). If at least <italic>r </italic>excellent parallelograms are detected among the good parallelograms, all the positions [<italic>i</italic>, <italic>i </italic>+ <italic>L </italic>- 1] corresponding to this sliding window <italic>w </italic>are kept by the filter (line 1). We are now going to see how we check whether a good parallelogram is excellent.</p>
      <p>Consider two words <italic>w </italic>and <italic>w' </italic>and also a set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M26" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> of <italic>q</italic>-hits, relative to these words, that satisfy property (5). In order to check this property, one has to detect if at least <italic>p q</italic>-grams occur in the same order in <italic>w </italic>and <italic>w'</italic>. To this purpose, we consider the length of the longest common ordered subset of <italic>q</italic>-grams occurring both in <italic>w </italic>and <italic>w'</italic>.</p>
      <p>In practice, we define a new alphabet <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M27" name="1748-7188-4-3-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Σ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> in such a way that every possible <italic>q</italic>-gram (any sequence of <italic>q </italic>letters in Σ) corresponds to a symbol <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M28" name="1748-7188-4-3-i8" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M29" name="1748-7188-4-3-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Σ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>, thus |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M30" name="1748-7188-4-3-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Σ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula>| = |Σ|<sup><italic>q</italic></sup>. Given a sequence <italic>s </italic>on Σ, we transform it into a sequence <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M31" name="1748-7188-4-3-i9" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> on <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M32" name="1748-7188-4-3-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Σ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> replacing from left to right the letter <italic>s</italic>[<italic>i</italic>] ∈ Σ by the symbol in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M33" name="1748-7188-4-3-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Σ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> corresponding to the <italic>q</italic>-gram starting at position <italic>i </italic>of <italic>s</italic>. Note that |<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M34" name="1748-7188-4-3-i9" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>| = |<italic>s</italic>| - <italic>q </italic>+ 1. On the <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M35" name="1748-7188-4-3-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Σ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> alphabet, the longest common ordered subset of <italic>q</italic>-grams occurring both in <italic>w </italic>and <italic>w' </italic>is a common subsequence of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M36" name="1748-7188-4-3-i10" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>w</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M37" name="1748-7188-4-3-i11" overflow="scroll"><mml:semantics><mml:msup><mml:mover accent="true"><mml:mi>w</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>′</mml:mo></mml:msup></mml:semantics></mml:math></inline-formula>. In particular, if we were interested in looking for the largest set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M38" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> of <italic>q</italic>-hits that satisfies property (5), it would be enough to compute the LCS of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M39" name="1748-7188-4-3-i10" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>w</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M40" name="1748-7188-4-3-i11" overflow="scroll"><mml:semantics><mml:msup><mml:mover accent="true"><mml:mi>w</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>′</mml:mo></mml:msup></mml:semantics></mml:math></inline-formula>, which is a very well studied problem. Given that our third filtering condition, where we must test whether a parallelogram is excellent or not, also requires that all <italic>q</italic>-hits of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M41" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> belong to a parallelogram, then we define the following problem:</p>
      <p><bold>Definition 5 (Parallelogram <italic>q</italic>-hits Chaining Problem) </bold><italic>Given a word w </italic>= <italic>s</italic>[<italic>a </italic>+ <italic>L </italic>- 1] <italic>and a parallelogram </italic>Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d</italic>), <italic>we want to exhibit a set </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M42" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula><italic>of q-hits inside this parallelogram with largest size that satisfies property (5)</italic>.</p>
      <p>Hence, in order to check at line 1 of Algorithm 1 if a good parallelogram is excellent, we solve the Parallelogram <italic>q</italic>-hits Chaining Problem for this parallelogram and check if the size of the obtained set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M43" name="1748-7188-4-3-i1" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">S</mml:mi></mml:semantics></mml:math></inline-formula> is at least <italic>p</italic>. In order to solve the Parallelogram <italic>q</italic>-hits Chaining Problem, many strategies could be used, ranging from a simple dynamic programming approach within the parallelogram (<italic>strategy PDP </italic>for Parallelogram Dynamic Programming) to a sparse dynamic programming approach that takes advantage from the fact that few <italic>q</italic>-hits are expected on average. For the sparse solution, we used a reimplementation of Hunt and Szymanski's [<xref ref-type="bibr" rid="B17">17</xref>] algorithm that was presented by Gusfield in [<xref ref-type="bibr" rid="B18">18</xref>] using the computation of a LIS (Longest Increasing Subsequence). In this reimplementation, for each <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M44" name="1748-7188-4-3-i8" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> ∈ <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M45" name="1748-7188-4-3-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>Σ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> from the first word, we should provide the occurrence list of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M46" name="1748-7188-4-3-i8" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> in the second word. In our modified algorithm, only occurrences relative to <italic>q</italic>-hits inside the parallelogram are considered. In order to provide this set of truncated occurrences lists, we perform <italic>L </italic>- <italic>q </italic>+ 1 binary searches in the occurrences lists. We call this the <italic>strategy PHS </italic>(for Parallelogram Hunt Szymanski). As an alternative, a chaining [<xref ref-type="bibr" rid="B18">18</xref>] algorithm applied to the set of <italic>q</italic>-hits inside the parallelogram could also be used, but no theoretical improvement could be expected against strategy PHS.</p>
      <p>Moreover, we have designed an optimisation that uses some simple incremental information from the test for the sliding window <italic>w </italic>= <italic>s</italic>[<italic>i</italic>, <italic>i </italic>+ <italic>L </italic>- 1] in order to possibly avoid such test for the next sliding windows. This works as follows. Consider a parallelogram <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M47" name="1748-7188-4-3-i12" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">P</mml:mi></mml:semantics></mml:math></inline-formula> for the sliding window <italic>w </italic>= <italic>s</italic>[<italic>a </italic>- 1, <italic>a </italic>+ <italic>L </italic>- 2] for which the solution of the Parallelogram <italic>q</italic>-hits Chaining Problem resulted in a set of ℓ <italic>q</italic>-hits. After sliding the window from <italic>w </italic>to <italic>w' </italic>= <italic>s</italic>[<italic>a</italic>, <italic>a </italic>+ <italic>L </italic>- 1], and sliding <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M48" name="1748-7188-4-3-i12" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">P</mml:mi></mml:semantics></mml:math></inline-formula> consequently, solving the Parallelogram <italic>q</italic>-hits Chaining Problem results in either ℓ - 1, or ℓ, or ℓ + 1 chaining <italic>q</italic>-hits. Hence, only parallelograms <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M49" name="1748-7188-4-3-i12" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">P</mml:mi></mml:semantics></mml:math></inline-formula> whose value for ℓ was equal to either <italic>p </italic>- 1, <italic>p </italic>or <italic>p </italic>+ 1 for position <italic>a </italic>- 1 (word <italic>w</italic>) have a chance to become or stay excellent parallelograms for position <italic>a </italic>(word <italic>w'</italic>) as well. This motivates the following optimisation: we address the Parallelogram <italic>q</italic>-hits Chaining Problem only for parallelograms whose previous solution for it was <italic>p </italic>- 1, <italic>p </italic>or <italic>p </italic>+ 1. Done on top of <italic>strategy </italic>PHS, this is what we call <italic>strategy PQCP </italic>because it is our actual solution for the Parallelogram <italic>q</italic>-hits Chaining Problem as we motivate later with experimental results.</p>
      <p>In order to check for non-overlapping repeats only, given a set of good/excellent parallelograms, both at lines 1 and 1, we look for a subset of non-overlapping parallelograms with maximal cardinality. This can easily be done by applying the following greedy strategy to the sequence of parallelograms ordered by increasing starting diagonals. Let Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d </italic>+ <italic>b </italic>- 1) and Parall(<italic>a</italic>, <italic>L</italic>, <italic>c'</italic>, <italic>d </italic>+ <italic>b </italic>- 1) be two consecutive parallelograms, in this order, each one with <italic>d </italic>+ <italic>b </italic>diagonals, and let Parall(<italic>a</italic>, <italic>L</italic>, <italic>c"</italic>, <italic>d </italic>+ <italic>b </italic>- 1) be the next one. If the first two parallelograms overlap (which means that <italic>c' </italic>- <italic>c </italic>&lt;<italic>L </italic>- (<italic>d </italic>+ <italic>b </italic>- 1)), then we can remove the second one from the sequence and repeat the process for the two consecutive parallelograms Parall(<italic>a</italic>, <italic>L</italic>, <italic>c</italic>, <italic>d </italic>+ <italic>b </italic>- 1) and Parall(<italic>a</italic>, <italic>L</italic>, <italic>c"</italic>, <italic>d </italic>+ <italic>b </italic>- 1) in the remaining sequence. If they do not overlap, then we can keep the first one in the set and repeat the process with the next two consecutive parallelograms in the sequence: Parall(<italic>a</italic>, <italic>L</italic>, <italic>c'</italic>, <italic>d </italic>+ <italic>b </italic>- 1) and Parall(<italic>a</italic>, <italic>L</italic>, <italic>c"</italic>, <italic>d </italic>+ <italic>b </italic>- 1). This procedure runs in linear time. As mentioned in the introduction, and as the names suggest, the version of <sc>TUIUIU</sc> that checks for fine parallelograms is named <sc>FINE</sc>, while the version that checks for good (resp. excellent) parallelograms is named <sc>GOOD</sc> (resp. <sc>EXCELLENT</sc>).</p>
    </sec>
    <sec>
      <title>Looking for repeats across multiple sequences with <sc>TUIUIU</sc>*</title>
      <p>In this section, we describe what is done in order to look for repeats across multiple sequences, modifying <sc>TUIUIU</sc> into <sc>TUIUIU</sc>*. Consider an integer <italic>m </italic>≥ 2 and a set of sequences <italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>,...,<italic>s</italic><sub><italic>m</italic></sub>. In the set of sequences <italic>s</italic><sub>1</sub>, s<sub>2</sub>,...,<italic>s</italic><sub><italic>m</italic></sub>, an (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeat is defined as a set of <italic>r </italic>≤ <italic>m </italic>words such that given any pair of them, their edit distance is at most <italic>d </italic>and they occur in distinct sequences (recall that, in this context, we use the term word for a contiguous segment of one of the sequences <italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>,...,<italic>s</italic><sub><italic>m</italic></sub>).</p>
      <p>Simple modifications of the algorithms <sc>FINE</sc>, <sc>GOOD</sc> and <sc>EXCELLENT</sc> are done in order to deal with these new requirements, generating the corresponding algorithms <sc>FINE</sc>*, <sc>GOOD</sc>* and <sc>EXCELLENT</sc>* that are then applied to the concatenation <italic>s </italic>of <italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>,...,<italic>s</italic><sub><italic>m</italic></sub>. While sliding the window on the word <italic>w </italic>along a sequence, say <italic>s</italic><sub><italic>i</italic></sub>, we look for fine/good/excellent parallelograms in all other sequences as shown in Figure <xref ref-type="fig" rid="F4">4</xref>. If fine/good/excellent parallelograms are detected in at least <italic>r </italic>- 1 other sequences (different from <italic>s</italic><sub><italic>i</italic></sub>), then we keep the word <italic>w</italic>. Indeed, when testing a word <italic>w </italic>from a sequence <italic>s</italic><sub><italic>i</italic></sub>, we test parallelograms from sequence <italic>s</italic><sub><italic>j </italic></sub>for <italic>j </italic>≠ <italic>i</italic>, in order to avoid to compare <italic>s</italic><sub><italic>i </italic></sub>against itself. All counter updates are done as in <sc>TUIUIU</sc> but as soon as a desired excellent parallelogram is detected in a sequence <italic>s</italic><sub><italic>j</italic></sub>, we skip the remaining of <italic>s</italic><sub><italic>j </italic></sub>and go to the next sequence. Finally, if already <italic>r </italic>excellent parallelograms are detected, we keep <italic>w </italic>and try the next position. No overlap checking is done, since all obtained parallelograms detect repeated words, other than <italic>w</italic>, from different sequences.</p>
      <fig position="float" id="F4">
        <label>Figure 4</label>
        <caption>
          <p><bold>Application to multiple sequences</bold>. Application of <sc>TUIUIU</sc>* to multiple sequences. For a sliding window <italic>w </italic>on a sequence <italic>s</italic><sub><italic>i</italic></sub>, parallelograms are tested on all other sequences. In this example, we assumed we found three fine/good/excellent parallelograms among four sequences.</p>
        </caption>
        <graphic xlink:href="1748-7188-4-3-4"/>
      </fig>
    </sec>
    <sec>
      <title>Complexity analysis</title>
      <p>In the <sc>TUIUIU</sc>* framework, we consider <italic>n </italic>as the sum of the sequences length, while in the <sc>TUIUIU</sc> framework <italic>n </italic>is the length of this sequence. Hence, the input size is in both cases <italic>n</italic>. In this way, the complexity analysis is actually the same for <sc>TUIUIU</sc> and <sc>TUIUIU</sc>*.</p>
      <p>We present a complexity analysis for <sc>EXCELLENT</sc> (which holds for <sc>EXCELLENT</sc>* too), whose pseudocode is presented in Algorithm 1. At the end, we also consider the complexity analysis of <sc>FINE</sc> (which holds also for <sc>FINE</sc>*), and of <sc>GOOD</sc> (that is the same as <sc>GOOD</sc>*). Observe that no complexity comparison is done with any other <italic>q</italic>-gram based filtering tool as <sc>TUIUIU</sc> is the first tool for filtering multiple repeats with edit distance.</p>
      <p>In order to have better parameters for the complexity analysis, besides the length <italic>n </italic>of sequence <italic>s</italic>, we consider also <italic>h </italic>to be the number of <italic>q</italic>-hits and <italic>c </italic>the number of non-avoided computations of the Parallelogram <italic>q</italic>-hits Chaining Problem at line 1. For an average analysis, we consider the average number based on a random uniform distribution of <italic>n </italic>characters from Σ.</p>
      <p>Concerning space usage, as described in Section "Description of the algorithm", the main data structure, the <italic>q</italic>-gram index built in line 1, uses an array with <italic>n </italic>- <italic>q </italic>+ 1 integers and another with |Σ|<sup><italic>q </italic></sup>pointers/integers. Its construction is done by applying a simple counting sort on the sequence of <italic>q</italic>-grams <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M50" name="1748-7188-4-3-i9" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula>. This takes time <italic>O</italic>(<italic>n </italic>+ |Σ|<sup><italic>q</italic></sup>), that is <italic>O</italic>(<italic>n</italic>) if we can suppose that <italic>q </italic>≤ log<sub>|Σ|</sub><italic>n</italic>. All other data structures also require <italic>O</italic>(<italic>n</italic>) memory: we have <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M51" name="1748-7188-4-3-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>b</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> counters for all current parallelograms and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M52" name="1748-7188-4-3-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>b</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> skip positions (in order to avoid computations of the Parallelogram <italic>q</italic>-hits Chaining Problem, as we described the difference between strategies PQCP and PHS).</p>
      <p>Concerning time, a critical parameter is the number <italic>h </italic>of <italic>q</italic>-hits. With the loops at lines 1 and 1, for each <italic>q</italic>-hit, we update up to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M53" name="1748-7188-4-3-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> counters at lines 1 and 1. At line 1, we execute all the <italic>c </italic>computations of the Parallelogram <italic>q</italic>-hits Chaining Problem. Using the strategy PQCP (or PHS), each Parallelogram <italic>q</italic>-hits Chaining Problem is solved in <italic>O</italic>(<italic>L </italic>log <italic>k </italic>+ <italic>y </italic>log <italic>L</italic>), where <italic>k </italic>is the size of the <italic>q</italic>-gram occurrence list and <italic>y </italic>is the number of <italic>q</italic>-hits inside the parallelogram. Therefore, each Parallelogram <italic>q</italic>-hits Chaining Problem is solved in <italic>O</italic>(<italic>L </italic>log <italic>n </italic>+ <italic>L</italic>(<italic>b </italic>+ <italic>d</italic>) log <italic>L</italic>) time in the worst case and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M54" name="1748-7188-4-3-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mfrac><mml:mi>n</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>Σ</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mi>q</mml:mi></mml:msup></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mi>L</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> on average, assuming that the <italic>q</italic>-hits are sparse (as we observed in practical tests). As a result, time complexity is <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M55" name="1748-7188-4-3-i15" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:mfrac><mml:mi>h</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> in the worst case, and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M56" name="1748-7188-4-3-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:mfrac><mml:mi>h</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>L</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>Σ</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mi>q</mml:mi></mml:msup></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> on average.</p>
      <p>Let us now estimate the values for <italic>h </italic>and <italic>c</italic>. In the worst case (<italic>s </italic>= <italic>a</italic><sup><italic>n</italic></sup>), <italic>h </italic>= <italic>n</italic><sup>2</sup>, but on average, <italic>h </italic>= <italic>n</italic><sup>2</sup>|Σ|<sup>-<italic>q</italic></sup>. As concerns <italic>c</italic>, there are at most <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M57" name="1748-7188-4-3-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>b</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula> good parallelograms for each position of the sliding window, thus in the worst case we have <italic>c </italic>= <italic>n </italic><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M58" name="1748-7188-4-3-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mfrac><mml:mi>n</mml:mi><mml:mi>b</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula>. As a first approximation, we are assuming a slightly stronger hypothesis about the sequence, a random uniform <italic>q</italic>-gram distribution. We can expect the probability that a parallelogram is fine (good) to be <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M59" name="1748-7188-4-3-i17" overflow="scroll"><mml:semantics><mml:mrow><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>x</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>i</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>Σ</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msup></mml:mrow></mml:mstyle></mml:mrow></mml:semantics></mml:math></inline-formula>, where <italic>x </italic>= (<italic>L </italic>- <italic>q </italic>+ 1)(<italic>d </italic>+ <italic>b</italic>) is the size of a parallelogram and <italic>p </italic>= (<italic>L </italic>- <italic>q </italic>+ 1) - <italic>qd</italic>. Using Stirling's formula and the fact that for typical values <italic>x</italic>|Σ|<sup>-<italic>q</italic></sup><italic>e </italic>&lt;<italic>p</italic>, we have</p>
      <p>
        <disp-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M60" name="1748-7188-4-3-i18" overflow="scroll">
            <mml:semantics>
              <mml:mrow>
                <mml:mstyle displaystyle="true">
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mi>p</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>L</mml:mi>
                      <mml:mo>−</mml:mo>
                      <mml:mi>q</mml:mi>
                    </mml:mrow>
                  </mml:munderover>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mtable>
                          <mml:mtr>
                            <mml:mtd>
                              <mml:mi>x</mml:mi>
                            </mml:mtd>
                          </mml:mtr>
                          <mml:mtr>
                            <mml:mtd>
                              <mml:mi>i</mml:mi>
                            </mml:mtd>
                          </mml:mtr>
                        </mml:mtable>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mstyle>
                <mml:msup>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo>|</mml:mo>
                      <mml:mi>Σ</mml:mi>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mi>q</mml:mi>
                  </mml:mrow>
                </mml:msup>
                <mml:mo>=</mml:mo>
                <mml:mi>O</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mi>x</mml:mi>
                        <mml:mi>e</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo>|</mml:mo>
                              <mml:mi>Σ</mml:mi>
                              <mml:mo>|</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mi>q</mml:mi>
                        </mml:msup>
                      </mml:mrow>
                    </mml:mfrac>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mi>p</mml:mi>
                </mml:msup>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>.</mml:mo>
              </mml:mrow>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>Therefore, the expected number of fine (good) parallelograms is</p>
      <p>
        <disp-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M61" name="1748-7188-4-3-i19" overflow="scroll">
            <mml:semantics>
              <mml:mrow>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mi>n</mml:mi>
                      <mml:mn>2</mml:mn>
                    </mml:msup>
                  </mml:mrow>
                  <mml:mi>b</mml:mi>
                </mml:mfrac>
                <mml:msup>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mi>x</mml:mi>
                            <mml:mi>e</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>p</mml:mi>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mo>|</mml:mo>
                                  <mml:mi>Σ</mml:mi>
                                  <mml:mo>|</mml:mo>
                                </mml:mrow>
                              </mml:mrow>
                              <mml:mi>q</mml:mi>
                            </mml:msup>
                          </mml:mrow>
                        </mml:mfrac>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>p</mml:mi>
                </mml:msup>
              </mml:mrow>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M62" name="1748-7188-4-3-i20" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>c</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>b</mml:mi></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>x</mml:mi><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>Σ</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mi>q</mml:mi></mml:msup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>p</mml:mi></mml:msup></mml:mrow></mml:semantics></mml:math></inline-formula>, for any <italic>r</italic>.</p>
      <p>The worst case time complexity is then</p>
      <p>
        <disp-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M63" name="1748-7188-4-3-i21" overflow="scroll">
            <mml:semantics>
              <mml:mrow>
                <mml:mi>O</mml:mi>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mi>b</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mi>d</mml:mi>
                      </mml:mrow>
                      <mml:mi>b</mml:mi>
                    </mml:mfrac>
                    <mml:msup>
                      <mml:mi>n</mml:mi>
                      <mml:mn>2</mml:mn>
                    </mml:msup>
                    <mml:mo>+</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mi>n</mml:mi>
                          <mml:mn>2</mml:mn>
                        </mml:msup>
                      </mml:mrow>
                      <mml:mi>b</mml:mi>
                    </mml:mfrac>
                    <mml:mi>L</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>log</mml:mi>
                    <mml:mo>⁡</mml:mo>
                    <mml:mi>n</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>b</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mi>d</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mi>log</mml:mi>
                    <mml:mo>⁡</mml:mo>
                    <mml:mi>L</mml:mi>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mi>O</mml:mi>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mi>n</mml:mi>
                          <mml:mn>2</mml:mn>
                        </mml:msup>
                      </mml:mrow>
                      <mml:mi>b</mml:mi>
                    </mml:mfrac>
                    <mml:mi>L</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>log</mml:mi>
                    <mml:mo>⁡</mml:mo>
                    <mml:mi>n</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>b</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mi>d</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mi>L</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mo>,</mml:mo>
              </mml:mrow>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>and the average complexity is</p>
      <p>
        <disp-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M64" name="1748-7188-4-3-i22" overflow="scroll">
            <mml:semantics>
              <mml:mrow>
                <mml:mi>O</mml:mi>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mi>b</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mi>d</mml:mi>
                      </mml:mrow>
                      <mml:mi>b</mml:mi>
                    </mml:mfrac>
                    <mml:msup>
                      <mml:mi>n</mml:mi>
                      <mml:mn>2</mml:mn>
                    </mml:msup>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo>|</mml:mo>
                          <mml:mi>Σ</mml:mi>
                          <mml:mo>|</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>−</mml:mo>
                        <mml:mi>q</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>+</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mi>n</mml:mi>
                          <mml:mn>2</mml:mn>
                        </mml:msup>
                      </mml:mrow>
                      <mml:mi>b</mml:mi>
                    </mml:mfrac>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo>(</mml:mo>
                          <mml:mrow>
                            <mml:mfrac>
                              <mml:mrow>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>L</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>q</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mn>1</mml:mn>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>d</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mi>b</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mi>e</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>p</mml:mi>
                                <mml:msup>
                                  <mml:mrow>
                                    <mml:mrow>
                                      <mml:mo>|</mml:mo>
                                      <mml:mi>Σ</mml:mi>
                                      <mml:mo>|</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>
                                  <mml:mi>q</mml:mi>
                                </mml:msup>
                              </mml:mrow>
                            </mml:mfrac>
                          </mml:mrow>
                          <mml:mo>)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mi>p</mml:mi>
                    </mml:msup>
                    <mml:mi>L</mml:mi>
                    <mml:mi>log</mml:mi>
                    <mml:mo>⁡</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mi>n</mml:mi>
                        <mml:mi>L</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo>|</mml:mo>
                              <mml:mi>Σ</mml:mi>
                              <mml:mo>|</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mi>q</mml:mi>
                        </mml:msup>
                      </mml:mrow>
                    </mml:mfrac>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mo>.</mml:mo>
              </mml:mrow>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>Notice that the second part in the sum decreases as <italic>p </italic>increases. For <italic>p </italic>large enough, the average time complexity is</p>
      <p>
        <disp-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M65" name="1748-7188-4-3-i23" overflow="scroll">
            <mml:semantics>
              <mml:mrow>
                <mml:mi>O</mml:mi>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mi>b</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mi>d</mml:mi>
                      </mml:mrow>
                      <mml:mi>b</mml:mi>
                    </mml:mfrac>
                    <mml:msup>
                      <mml:mi>n</mml:mi>
                      <mml:mn>2</mml:mn>
                    </mml:msup>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo>|</mml:mo>
                          <mml:mi>Σ</mml:mi>
                          <mml:mo>|</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>−</mml:mo>
                        <mml:mi>q</mml:mi>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mo>.</mml:mo>
              </mml:mrow>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>Finally, the complexity of <sc>FINE</sc> and <sc>GOOD</sc> are obtained by simply setting <italic>c </italic>= 0.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <p>We now report a battery of experimental tests that were applied to <sc>TUIUIU</sc> with different filtering conditions (<sc>FINE</sc>, <sc>GOOD</sc> and <sc>EXCELLENT</sc>) and strategies for solving the Parallelogram <italic>q</italic>-hits Chaining Problem. As input, <sc>TUIUIU</sc> receives a sequence <italic>s </italic>and a set of parameters <italic>L</italic>, <italic>d</italic>, <italic>r</italic>, and <italic>q</italic>. For parameter <italic>b</italic>, <sc>TUIUIU</sc> takes as default value the same as adopted in [<xref ref-type="bibr" rid="B6">6</xref>]: the smallest power of 2 greater than <italic>d</italic>. Moreover, we give the user flexibility for the choice of which filtering condition to apply. As output, the user obtains a sequence where every position that does not satisfy the conditions is masked by <sc>TUIUIU</sc>. Since we do not know any other work that is a filter for multiple repeats, in particular with the same kind of output, we do not compare <sc>TUIUIU</sc> directly to other methods, but try instead to reproduce as much as possible the filtering conditions used by such approaches. In this sense, the closest method we compare <sc>TUIUIU</sc> to is <sc>SWIFT</sc>. Even though we did not report it here, we also found that the strategy of counting <italic>q</italic>-hits inside parallelograms used in <sc>SWIFT</sc> performs better than the strategy of counting <italic>q</italic>-hits inside rectangles (as is done in <sc>QUASAR</sc>[<xref ref-type="bibr" rid="B4">4</xref>], for instance), as it was already reported in [<xref ref-type="bibr" rid="B6">6</xref>]. Roughly speaking, <sc>SWIFT</sc> is a <sc>BLAST</sc>-like tool where the seeds for similarity expansions are provided not by exact matches of length W as <sc>BLAST</sc> does, but by an (<italic>L</italic>, <italic>d</italic>, 2)-repeat found by using a filter that is at the core of the <sc>SWIFT</sc> algorithm. Improving on speed seems to have been an important issue in the development of <sc>SWIFT</sc>, which also implies that we did not see reported in the paper error levels above 5%. <sc>TUIUIU</sc> can deal with bigger error levels, for instance up to 14% of the size of the repeat sought. This implies that a smaller value should be used for parameter <italic>q</italic>, and hence, that longer running times are unavoidable.</p>
    <p>We start by giving a few definitions of the values that we used to evaluate the results obtained. The quality of the filtered output is measured by the ratio between the total length of the non-filtered sequence and its original length. We call this the <italic>selectiveness </italic>of the filter. The smaller the selectiveness, the better. On the other hand, the main resource consumed by the algoritm is the <italic>running time </italic>that <sc>TUIUIU</sc> takes. If we compare methods A and B, in this order, the <italic>selectiveness improvement </italic>(<italic>SI</italic>) is the quotient between the selectiveness of B and the selectiveness of A. Accordingly, we define the <italic>speedup factor </italic>(<italic>SU</italic>) of the algorithm to be the quotient between the running time spent by A and the running time spent by B. We also define the <italic>slowdown factor </italic>(<italic>SD</italic>) to be the inverse of the speedup factor. For convenience, we quite often refer to a SI/SU/SD of <italic>x</italic>% if the SI/SU/SD factor is 1 + <italic>x</italic>/100. For instance, a speedup factor 1.02 may be reported as a speedup of 2%. The experiments were run on an AMD Athlon(tm) 64 Processor 3500+ machine with 4 Gigabytes and running Linux for amd64.</p>
    <sec>
      <title>Time and selectiveness on randomly generated sequences</title>
      <p>We first present some tests performed on short randomly generated sequences. Each dataset is composed of five sequences of length 300 kb each, generated using a Bernoulli model (each nucleotide occurring with frequency <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M66" name="1748-7188-4-3-i24" overflow="scroll"><mml:semantics><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>4</mml:mn></mml:mfrac></mml:mrow></mml:semantics></mml:math></inline-formula>). Every sequence contains exactly one occurrence of a repetition of length 1 kb, the occurrences being distant from each other by at most <italic>X </italic>edit operations, with <italic>X </italic>ranging from 0 to 300 (that is, from 0 to 30% of the repeats length). The datasets were filtered using the methods <sc>FINE</sc>, <sc>GOOD</sc> and <sc>EXCELLENT</sc>, with parameters <italic>L </italic>= 1000, <italic>d </italic>= 100, <italic>r </italic>= 5 and <italic>q </italic>= 6 (looking for repetitions of length 1000 allowing for up to 10% differences). The results are shown in Figure <xref ref-type="fig" rid="F5">5</xref>. One can see that the computation time is only slightly influenced by the nature of the repeat, and that in this case approximately 16 seconds are required for filtering the 1.5 Mb dataset. The ideal selectiveness (in the case of absence of false positives), would be 0.33% for <italic>X </italic>from 0 to 100, and 0 for bigger values of <italic>X</italic>. As expected, one observes that the selectiveness results are better for <sc>EXCELLENT</sc> than for <sc>GOOD</sc>, which themselves are better than for <sc>FINE</sc>.</p>
      <fig position="float" id="F5">
        <label>Figure 5</label>
        <caption>
          <p><bold>Tests on random generated sequences</bold>. Application of the three versions of <sc>TUIUIU</sc> with parameters (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>) = (1000, 100, 5) on five random sequences of a total size of 1.5 Mb, each containing approximate occurrences of a planted repeat of length 1 kb. We planted repeats whose occurrences have a pairwise maximum distance that ranges from 0 to 300 (each test has the same value for all pairs). Each test was performed 20 times: the average result is reported.</p>
        </caption>
        <graphic xlink:href="1748-7188-4-3-5"/>
      </fig>
    </sec>
    <sec>
      <title>Extensive tests with Neisseria meningitidis strain MC58</title>
      <p>In order to compare the different variants of <sc>TUIUIU</sc> (depending on which filtering technique is used and which strategy for solving the Parallelogram <italic>q</italic>-hits Chaining Problem), we used a wide collection of parameter sets, applied to the DNA sequence of the <italic>Neisseria meningitidis </italic>strain MC58. <italic>Neisseria </italic>genomes are known for the abundance and diversity of their repetitive DNA in terms of size and structure [<xref ref-type="bibr" rid="B19">19</xref>]. The size of the repeated elements range from 10 bases to more than 2000 bases, and their number, depending on the type of the repeated element, may reach more than 200 copies. This fact explains why the <italic>N. meningitidis MC58 </italic>genomic sequence, with 2.3 Mb, has already been used as a test case for programs identifying repeats like in [<xref ref-type="bibr" rid="B12">12</xref>].</p>
      <sec>
        <title>The best strategy for solving the Parallelogram <italic>q</italic>-hits Chaining Problem</title>
        <p>In order to solve the Parallelogram <italic>q</italic>-hits Chaining Problem, we tested the three possible strategies described in the "Description of Algorithm 1" section. For any instance of this problem, the PDP strategy has running time proportional to the size of the parallelogram, which is (<italic>L </italic>- <italic>q </italic>+ 1) × (<italic>d </italic>+ <italic>b</italic>). On the other hand, the PHS strategy is expected to take time proportional to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M67" name="1748-7188-4-3-i25" overflow="scroll"><mml:semantics><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mfrac><mml:mi>n</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>Σ</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mi>q</mml:mi></mml:msup></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mi>y</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula>, where <italic>y </italic>is the number of <italic>q</italic>-hits inside the parallelogram. Notice that <italic>y </italic>has a strong dependence on <italic>q</italic>. Increasing <italic>q</italic>, we decrease the probability of a <italic>q</italic>-hit and consequently we decrease <italic>y</italic>. We may expect that <italic>y </italic>= <italic>O</italic>(<italic>L</italic>) on average, for not too small <italic>q</italic>. Indeed, multiplying the expected probability Σ<sup>-<italic>q </italic></sup>of a <italic>q</italic>-hit by the size (<italic>L </italic>- <italic>q </italic>+ 1)(<italic>d </italic>+ <italic>b</italic>) of a parallelogram, we may expect that <italic>y </italic>= <italic>O</italic>(Σ<sup>-<italic>q</italic></sup><italic>dL</italic>) on average, or simply <italic>y </italic>= <italic>O</italic>(<italic>L</italic>) for not too small values of <italic>q</italic>. Therefore, we expect PHS to be faster than PDP.</p>
        <p>As concerns the PQCP strategy, it is very difficult to predict how many computations of the Parallelogram <italic>q</italic>-hits Chaining Problem are avoided with the optimisation it realises. The same complexity as PHS certainly holds, but we definitely expect it to be faster. The reason is that <sc>EXCELLENT</sc> parallelograms tend to be clustered together, or in other terms, parallelograms that fulfill the conditions (2), (3), (4) and (5) are usually not isolated. This happens because the probability of two adjacent parallelograms to be <sc>EXCELLENT</sc> is not independent: parallelograms close to an <sc>EXCELLENT</sc> one have an increased probability to be <sc>EXCELLENT</sc> too. To sum up, from a theoretical point of view, PQCP should be faster than PHS, which in turn should be faster than PDP.</p>
        <p>In practice, these expectations were confirmed in the 72 tests we made with different sets of parameters on MC58. In all cases except one, the running time for the PHS strategy did not get worse in comparison to the simple PDP. In fact, the overall observed running time improvement from PDP to PHS was 1.57. In all tests, PQCP performed faster than PHS and the overall observed running time improvement from PHS to PQCP was 1.88. Hence, in all tests PQCP performed faster than the simple PDP and the overall observed running time improvement from PDP to PQCP was 3.22. Since all three strategies provide the same selectiveness, but for some cases PDP was 18 times slower than PQCP, we discarded strategies PDP and PHS from the subsequent systematic comparisons when we have to solve the Parallelogram <italic>q</italic>-hits Chaining Problem.</p>
      </sec>
      <sec>
        <title>The <sc>FINE</sc>, <sc>GOOD</sc>, <sc>EXCELLENT</sc> variants of <sc>TUIUIU</sc></title>
        <p>In the Section "Methods", we saw three possible filtering conditions, depending on what kind of non-overlapping parallelograms we would like to find: fine, good, or excellent. All three filters ensure that all (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeats are kept, so they are all lossless. In Section "Description of the algorithm", we saw the description of Algorithm 1, that implements a filter (<sc>EXCELLENT</sc>) for the third filter condition. If we remove lines from 1 to 1, we have a filter (<sc>GOOD</sc>) for the second filter condition. Moreover, if we also update all parallelogram counters (line 1) instead of only new ones as described in Section "Description of the algorithm", we have a filter (<sc>FINE</sc>) for the first filter condition. It should be said that <sc>SWIFT</sc>[<xref ref-type="bibr" rid="B6">6</xref>] identifies a parallelogram as a similarity region (for <italic>r </italic>= 2) if the parallelogram is <sc>FINE</sc>. In other words, the comparison to <sc>FINE</sc> is in some sense a comparison to the conditions applied by <sc>SWIFT</sc> for finding (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeats for <italic>r </italic>= 2.</p>
        <p>As concerns the parameter sets we used for the three algorithms when applied to MC58, we selected all combinations such that:</p>
        <p>
          <disp-formula>
            <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M68" name="1748-7188-4-3-i26" overflow="scroll">
              <mml:semantics>
                <mml:mrow>
                  <mml:mtable columnalign="left">
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mi>L</mml:mi>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mo>=</mml:mo>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mn>50</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>100</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>200</mml:mn>
                          <mml:mo>;</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mo>/</mml:mo>
                          <mml:mi>L</mml:mi>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mo>=</mml:mo>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mn>4</mml:mn>
                          <mml:mi>%</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:mn>10</mml:mn>
                          <mml:mi>%</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:mn>12</mml:mn>
                          <mml:mi>%</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:mn>14</mml:mn>
                          <mml:mi>%</mml:mi>
                          <mml:mo>;</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mi>r</mml:mi>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mo>=</mml:mo>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mn>5</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>8</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>13</mml:mn>
                          <mml:mo>;</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mi>q</mml:mi>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mo>=</mml:mo>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mn>14</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>13</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>12</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>11</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>10</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>9</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>8</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>7</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>6</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>5</mml:mn>
                          <mml:mo>,</mml:mo>
                          <mml:mn>4</mml:mn>
                          <mml:mo>;</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mrow>
              </mml:semantics>
            </mml:math>
          </disp-formula>
        </p>
        <p>and such that the restriction</p>
        <p>
          <disp-formula><italic>p </italic>= (<italic>L </italic>- <italic>q </italic>+ 1) - <italic>qd </italic>≥ <italic>τL</italic>,</disp-formula>
        </p>
        <p>for <italic>τ </italic>= 0.08, was satisfied. This restriction was adopted because if the threshold <italic>p </italic>is too small, the selectiveness for any method gets bad – as one should expect – as does the running time, in particular for <sc>EXCELLENT</sc>. For instance, for <italic>L</italic>, <italic>d</italic>, <italic>r</italic>, <italic>q </italic>= 100, 14, 5, 6 (<italic>p </italic>= 11) we obtain a selectiveness of 99.992%, 99.957% and 99.835% for the methods <sc>FINE</sc>, <sc>GOOD</sc> and <sc>EXCELLENT</sc>, respectively. In this case, <sc>EXCELLENT</sc> is 9.36 times slower than <sc>GOOD</sc>. For this reason, in order not to spend too much running time on testing cases that would never be used anyway since the selectiveness is bad, we empirically chose a <italic>threshold factor τ </italic>= 0.08 for <italic>p</italic>/<italic>L</italic>. This resulted in 198 combinations for <italic>q </italic>ranging from 4 to 14. The combinations are split in 99 low error cases (<italic>d</italic>/<italic>L </italic>= 4%) and 99 large error cases (<italic>d</italic>/<italic>L </italic>= 10%, 12%, 14%). We are now going to comment the results reported in Table <xref ref-type="table" rid="T1">1</xref>.</p>
        <table-wrap position="float" id="T1">
          <label>Table 1</label>
          <caption>
            <p><sc>FINE</sc>/<sc>GOOD</sc>/<sc>EXCELLENT</sc> systematic comparison on MC58 sequence</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <td align="center">
                  <sc>RESTRICTION</sc>
                </td>
                <td align="center">
                  <sc>NB. TESTS</sc>
                </td>
                <td align="center">
                  <sc>EXCEL. SEL.</sc>
                </td>
                <td align="center" colspan="2"><sc>GOOD</sc>/<sc>FINE</sc></td>
                <td align="center" colspan="2"><sc>EXCEL</sc>./<sc>GOOD</sc></td>
                <td align="center" colspan="2"><sc>EXCEL</sc>./<sc>FINE</sc></td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td/>
                <td/>
                <td/>
                <td align="center">SI</td>
                <td align="center">SD</td>
                <td align="center">SI</td>
                <td align="center">SD</td>
                <td align="center">SI</td>
                <td align="center">SD</td>
              </tr>
              <tr>
                <td colspan="9">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center">overall</td>
                <td align="center">198</td>
                <td align="center">11.19</td>
                <td align="center">1.685</td>
                <td align="center">1.032</td>
                <td align="center">1.307</td>
                <td align="center">1.752</td>
                <td align="center">2.309</td>
                <td align="center">1.811</td>
              </tr>
              <tr>
                <td colspan="9">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center"><italic>d</italic>/<italic>L </italic>≥ 10%</td>
                <td align="center">99</td>
                <td align="center">18.45</td>
                <td align="center">2.302</td>
                <td align="center">1.043</td>
                <td align="center">1.508</td>
                <td align="center">2.062</td>
                <td align="center">3.428</td>
                <td align="center">2.166</td>
              </tr>
              <tr>
                <td align="center"><italic>d</italic>/<italic>L </italic>= 4%</td>
                <td align="center">99</td>
                <td align="center">3.93</td>
                <td align="center">1.067</td>
                <td align="center">1.021</td>
                <td align="center">1.107</td>
                <td align="center">1.441</td>
                <td align="center">1.191</td>
                <td align="center">1.467</td>
              </tr>
              <tr>
                <td colspan="9">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>&lt; 7</td>
                <td align="center">105</td>
                <td align="center">14.41</td>
                <td align="center">2.274</td>
                <td align="center">1.043</td>
                <td align="center">1.506</td>
                <td align="center">1.533</td>
                <td align="center">3.377</td>
                <td align="center">1.236</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>≥ 7</td>
                <td align="center">93</td>
                <td align="center">7.56</td>
                <td align="center">1.019</td>
                <td align="center">1.019</td>
                <td align="center">1.082</td>
                <td align="center">1.998</td>
                <td align="center">1.104</td>
                <td align="center">2.039</td>
              </tr>
              <tr>
                <td colspan="9">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center"><italic>p</italic>/<italic>L </italic>≥ 25%</td>
                <td align="center">159</td>
                <td align="center">5.90</td>
                <td align="center">1.820</td>
                <td align="center">1.033</td>
                <td align="center">1.347</td>
                <td align="center">1.321</td>
                <td align="center">2.546</td>
                <td align="center">1.236</td>
              </tr>
              <tr>
                <td align="center"><italic>p</italic>/<italic>L </italic>&lt; 25%</td>
                <td align="center">39</td>
                <td align="center">32.77</td>
                <td align="center">1.135</td>
                <td align="center">1.027</td>
                <td align="center">1.146</td>
                <td align="center">3.506</td>
                <td align="center">1.347</td>
                <td align="center">3.614</td>
              </tr>
              <tr>
                <td colspan="9">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center"><italic>p</italic>/<italic>L </italic>&gt; 14%</td>
                <td align="center">183</td>
                <td align="center">8.99</td>
                <td align="center">1.720</td>
                <td align="center">1.031</td>
                <td align="center">1.312</td>
                <td align="center">1.415</td>
                <td align="center">2.363</td>
                <td align="center">1.457</td>
              </tr>
              <tr>
                <td align="center"><italic>p</italic>/<italic>L </italic>≤ 14%</td>
                <td align="center">15</td>
                <td align="center">38.07</td>
                <td align="center">1.246</td>
                <td align="center">1.038</td>
                <td align="center">1.244</td>
                <td align="center">5.854</td>
                <td align="center">1.653</td>
                <td align="center">6.067</td>
              </tr>
              <tr>
                <td colspan="9">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center"><italic>L </italic>= 200</td>
                <td align="center">69</td>
                <td align="center">6.42</td>
                <td align="center">1.958</td>
                <td align="center">1.044</td>
                <td align="center">1.456</td>
                <td align="center">1.744</td>
                <td align="center">2.829</td>
                <td align="center">1.835</td>
              </tr>
              <tr>
                <td align="center"><italic>L </italic>= 100</td>
                <td align="center">69</td>
                <td align="center">12.35</td>
                <td align="center">1.611</td>
                <td align="center">1.032</td>
                <td align="center">1.172</td>
                <td align="center">2.018</td>
                <td align="center">2.113</td>
                <td align="center">2.077</td>
              </tr>
              <tr>
                <td align="center"><italic>L </italic>= 50</td>
                <td align="center">60</td>
                <td align="center">15.35</td>
                <td align="center">1.454</td>
                <td align="center">1.019</td>
                <td align="center">1.292</td>
                <td align="center">1.454</td>
                <td align="center">1.938</td>
                <td align="center">1.479</td>
              </tr>
              <tr>
                <td colspan="9">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center"><italic>r </italic>= 13</td>
                <td align="center">66</td>
                <td align="center">8.44</td>
                <td align="center">1.745</td>
                <td align="center">1.033</td>
                <td align="center">1.323</td>
                <td align="center">1.729</td>
                <td align="center">2.45</td>
                <td align="center">1.791</td>
              </tr>
              <tr>
                <td align="center"><italic>r </italic>= 8</td>
                <td align="center">66</td>
                <td align="center">11.11</td>
                <td align="center">1.677</td>
                <td align="center">1.032</td>
                <td align="center">1.302</td>
                <td align="center">1.756</td>
                <td align="center">2.280</td>
                <td align="center">1.817</td>
              </tr>
              <tr>
                <td align="center"><italic>r </italic>= 5</td>
                <td align="center">66</td>
                <td align="center">14.03</td>
                <td align="center">1.632</td>
                <td align="center">1.030</td>
                <td align="center">1.297</td>
                <td align="center">1.770</td>
                <td align="center">2.196</td>
                <td align="center">1.825</td>
              </tr>
              <tr>
                <td colspan="9">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center"><italic>d</italic>/<italic>L </italic>≥ 10%, <italic>p</italic>/<italic>L </italic>≥ 25%</td>
                <td align="center">66</td>
                <td align="center">8.79</td>
                <td align="center">2.874</td>
                <td align="center">1.049</td>
                <td align="center">1.689</td>
                <td align="center">1.205</td>
                <td align="center">4.451</td>
                <td align="center">1.236</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>&lt; 7, <italic>d</italic>/<italic>L </italic>≥ 10%</td>
                <td align="center">78</td>
                <td align="center">18.42</td>
                <td align="center">2.631</td>
                <td align="center">1.047</td>
                <td align="center">1.626</td>
                <td align="center">1.710</td>
                <td align="center">4.038</td>
                <td align="center">1.800</td>
              </tr>
              <tr>
                <td align="center"><italic>q </italic>&lt; 7, <italic>d</italic>/<italic>L </italic>≥ 25%</td>
                <td align="center">90</td>
                <td align="center">6.99</td>
                <td align="center">2.446</td>
                <td align="center">1.045</td>
                <td align="center">1.554</td>
                <td align="center">1.138</td>
                <td align="center">3.670</td>
                <td align="center">1.181</td>
              </tr>
              <tr>
                <td colspan="9">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="center"><italic>d</italic>/<italic>L </italic>≥ 10%, <italic>p</italic>/<italic>L </italic>≥ 25%, <italic>q </italic>&lt; 7</td>
                <td align="center">63</td>
                <td align="center">8.78</td>
                <td align="center">2.962</td>
                <td align="center">1.050</td>
                <td align="center">1.722</td>
                <td align="center">1.188</td>
                <td align="center">4.614</td>
                <td align="center">1.237</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Systematic comparison of <sc>FINE</sc>, <sc>GOOD</sc> and <sc>EXCELLENT</sc> on the MC58 data. Column <italic>nb. tests </italic>shows the number of set of parameters respecting the <italic>restriction </italic>context. Column <italic>Excel. sel</italic>. shows the absolute selectivity obtain thanks to method <sc>EXCELLENT</sc>. Using <sc>GOOD</sc> rather than <sc>FINE</sc>, we obtained an overall selectiveness improvement (SI) of plus 68% with a slowdown (SD) of only plus 3.2%. Using <sc>EXCELLENT</sc> rather than <sc>GOOD</sc>, for the cases with large errors (<italic>d</italic>/<italic>L </italic>≥ 10%) and not too small threshold <italic>p </italic>(<italic>p</italic>/<italic>L </italic>≥ 25%), the selectiveness improvement is of 69%, for a running time only 20.5% larger.</p>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec>
        <title>Variants <sc>GOOD</sc> versus <sc>FINE</sc></title>
        <p>We start with the comparison between <sc>FINE</sc> and <sc>GOOD</sc>. The methods are quite similar, except for an extra verification depending on whether the counter of a parallelogram to which a <italic>q</italic>-hit belongs was already updated or not for the current occurrences list. This extra checking introduces a small slowdown: an almost uniform slowdown of 3.2% is indeed observed in 195 out of 198 cases. In the three cases where <italic>L </italic>= 200, <italic>d </italic>= 28, <italic>r </italic>= 5, 8, 13, <italic>q </italic>= 4 – the 3 cases where the ratio between <italic>p </italic>and the expected number of <italic>q</italic>-hits in the parallelogram is smaller (85/46.2 = 1.8) – <sc>FINE</sc> was 78% slower than <sc>GOOD</sc>. These 3 degenerated cases are discarded from the subsequent running time analysis, but not discarded from the analysis of selectiveness. On the other hand, the selectiveness for <sc>GOOD</sc> is always better. Overall, in contrast to a running time slowdown of 3.2%, we observe 68.5% of selectiveness improvement on average. In Table <xref ref-type="table" rid="T1">1</xref>, we see comparisons of <sc>GOOD</sc> against <sc>FINE</sc> restricted to the cases where certain constraints are satisfied. In this way, we can see the influence of several parameters on how much improvement we can expect from <sc>GOOD</sc>. Only in cases where <italic>q </italic>is bigger (<italic>q </italic>&gt;= 7), no clear advantage from <sc>FINE</sc> to <sc>GOOD</sc> is observed; in fact, little difference can be observed in these cases, since the ratios are very close to 1. The advantage of <sc>GOOD</sc> over <sc>FINE</sc> is clearer for the following cases: large error rates (<italic>d</italic>/<italic>L </italic>≥ 10%), smaller <italic>q </italic>(<italic>q </italic>&lt; 7), larger <italic>p</italic>, longer <italic>L</italic>, and larger <italic>r</italic>. Combinations of these restrictions improve even more the selectiveness. We have thus verified that looking for good parallelograms (as in <sc>GOOD</sc> and as <sc>TUIUIU</sc> allows the user to do) is clearly better than looking for <sc>FINE</sc> parallelograms (as <sc>FINE</sc> and <sc>SWIFT</sc> do) for smaller values of <italic>q</italic>, that are also required if we want to deal with larger error rates as we have done here.</p>
      </sec>
      <sec>
        <title>Variants <sc>EXCELLENT</sc> versus <sc>GOOD</sc></title>
        <p>We now compare <sc>GOOD</sc> and <sc>EXCELLENT</sc>. If on one hand, the algorithmic differences between <sc>FINE</sc> and <sc>GOOD</sc> are quite small, the differences between <sc>GOOD</sc> and <sc>EXCELLENT</sc> are more complex mainly due to the solutions of the Parallelogram <italic>q</italic>-hits Chaining Problem required at line 1 of Algorithm 1. When property (5) was conceived in the design of <sc>TUIUIU</sc>, we understood that this could be a good strategy for larger rather than for smaller errors. If the parallelogram is "narrow", it is more likely that any pair of <italic>q</italic>-hits does already satisfy property (5). We further supposed that the extra cost of solving the Parallelogram <italic>q</italic>-hits Chaining Problem would be smaller for higher values of threshold <italic>p</italic>. What Table <xref ref-type="table" rid="T1">1</xref> shows us is in agreement with these expectations, since for the cases in which <italic>d</italic>/<italic>L </italic>≥ 10% and <italic>p</italic>/<italic>L </italic>≥ 25%, we obtain a selectiveness improvement of 69% in contrast to a time slowdown of 20%. Moreover, we could verify that the cases where the time slowdown is higher are those where <italic>p</italic>/<italic>L </italic>is lower. For instance, we observed that the 15 cases with time slowdown higher than 4 (ranging from 4.28 to 9.36, with average 5.85) are exactly the 15 cases where <italic>p</italic>/<italic>L </italic>≤ 14%, and we can still verify a selectiveness improvement of 55% in contrast to a time slowdown of 38% for large error cases (<italic>d</italic>/<italic>L </italic>≥ 10%) with <italic>p</italic>/<italic>L </italic>&gt; 14% (not shown on Table <xref ref-type="table" rid="T1">1</xref>).</p>
        <p>On one hand, <sc>EXCELLENT</sc> always has better selectiveness than <sc>GOOD</sc> (at least equal). On the other hand, the time slowdown may not be worth it. In particular, deciding whether the time slowdown is worthwhile or not depends very much on the application the filtered sequence will be submitted to. For instance, if we have a selectiveness improvement of 30% against a slowdown of 75% (like the general average numbers for all 198 cases), it may still be worth it if the algorithm we are going to submit the filtered sequence to is, for instance, cubic, since 1.3<sup>3 </sup>&gt; 1.75. Anyway, any slowdown above 4 means that we should also consider decreasing <italic>q </italic>by 1, instead of changing the algorithm from <sc>GOOD</sc> to <sc>EXCELLENT</sc>, since this is the expected slowdown for this decrease. Unfortunatelly, this does not guarantee that selectiveness will improve. Moreover, inspecting the cases where <italic>q </italic>≥ 7 and <italic>p</italic>/<italic>L </italic>≥ 25%, one may expect the slowdown to increase if <italic>q </italic>also increases.</p>
      </sec>
      <sec>
        <title>Variants <sc>EXCELLENT</sc> versus <sc>FINE</sc></title>
        <p>In order to complete these comparisons based on MC58, we proceed with the comparison between <sc>FINE</sc> and <sc>EXCELLENT</sc>. Here, like in the previous comparison, but now with even more striking numbers, it is clear that <sc>EXCELLENT</sc> performs better than <sc>FINE</sc>, bringing a selectiveness improvement of 4.45 against a time slowdown of only 25% for error cases larger than <italic>p</italic>/<italic>L </italic>≥ 25%. Overall, except for three degenerated cases where <sc>EXCELLENT</sc> got 23% faster than <sc>FINE</sc>, we obtained an average slowdown of 81% with a selectiveness improvement of 130%.</p>
      </sec>
    </sec>
    <sec>
      <title>Extra tests on Human Chromosome 22</title>
      <p>Unfortunately, thresholds such as those present in expressions like <italic>p</italic>/<italic>L </italic>&gt;= 0.08, 14%, 25%, <italic>q </italic>&lt; 7, <italic>d</italic>/<italic>L </italic>≥ 10, depend very much on the parameters <italic>L</italic>, <italic>r</italic>, <italic>d </italic>and on the sequence <italic>s </italic>that is processed. If the sequence <italic>s </italic>is known to have abundant repeats, it is expected that <sc>TUIUIU</sc> will not be able to provide selectiveness better than what is imposed by the repeats present in the sequence. For instance, the human genome has a high level of ALU repeats. There is an unpublished report of a fragment of ALU Y of length 266 that repeats more than 280 times on the human cromossome 22. We decided to apply <sc>TUIUIU</sc> on this data (last assembly from University Santa Cruz, California, total length 50 Mbases, 15 Mbases of which are unknown and replaced by "N"), with parameters: <italic>L</italic>, <italic>d</italic>, <italic>r </italic>= 260, 13, 280 and <italic>q </italic>= 14, 13, 12, 11, 10, 9. Results are reported in Table <xref ref-type="table" rid="T2">2</xref>. We observe that in all these cases <sc>GOOD</sc> is faster than <sc>FINE</sc> (24% faster on average), as in what we called degenerated cases in the MC58 analysis.</p>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p><sc>FINE</sc>/<sc>GOOD</sc>/<sc>EXCELLENT</sc> comparison on Human Chromosome 22</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">
                <italic>q</italic>
              </td>
              <td align="center">
                <italic>p</italic>
              </td>
              <td align="center">selectiveness<break/><sc>FINE</sc>/<sc>GOOD</sc>/<sc>EXCEL</sc></td>
              <td align="center">running time<break/><sc>FINE</sc>/<sc>GOOD</sc>/<sc>EXCEL</sc></td>
              <td align="center" colspan="2"><sc>GOOD</sc>/<sc>FINE</sc></td>
              <td align="center" colspan="2"><sc>EXCEL</sc>./<sc>GOOD</sc></td>
              <td align="center" colspan="2">excel./<sc>FINE</sc></td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td/>
              <td/>
              <td align="center">SU</td>
              <td align="center">SI</td>
              <td align="center">SD</td>
              <td align="center">SI</td>
              <td align="center">SD</td>
              <td align="center">SI</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td/>
              <td/>
              <td align="center">6.92%</td>
              <td align="center">501.28</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="center">14</td>
              <td align="center">65</td>
              <td align="center">1.63%</td>
              <td align="center">375.59</td>
              <td align="center">1.335</td>
              <td align="center">4.253</td>
              <td align="center">3.198</td>
              <td align="center">1.056</td>
              <td align="center">2.396</td>
              <td align="center">4.490</td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">1.54%</td>
              <td align="center">1201.00+</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td colspan="10">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">6.71%</td>
              <td align="center">598.08</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="center">13</td>
              <td align="center">79</td>
              <td align="center">0.88%</td>
              <td align="center">451.20</td>
              <td align="center">1.326</td>
              <td align="center">7.637</td>
              <td align="center">1.795</td>
              <td align="center">1.062</td>
              <td align="center">1.354</td>
              <td align="center">8.114</td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">0.83%</td>
              <td align="center">810.02</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td colspan="10">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">6.93%</td>
              <td align="center">761.29</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="center">12</td>
              <td align="center">93</td>
              <td align="center">0.51%</td>
              <td align="center">596.23</td>
              <td align="center">1.277</td>
              <td align="center">13.653</td>
              <td align="center">1.289</td>
              <td align="center">1.075</td>
              <td align="center">1.009</td>
              <td align="center">14.684</td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">0.47%</td>
              <td align="center">768.50</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td colspan="10">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">7.24%</td>
              <td align="center">1067.52</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="center">11</td>
              <td align="center">107</td>
              <td align="center">0.27%</td>
              <td align="center">862.29</td>
              <td align="center">1.238</td>
              <td align="center">26.321</td>
              <td align="center">1.099</td>
              <td align="center">1.136</td>
              <td align="center">0.887</td>
              <td align="center">33.684</td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">0.24%</td>
              <td align="center">947.25</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td colspan="10">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">7.88%</td>
              <td align="center">1647.85</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="center">10</td>
              <td align="center">121</td>
              <td align="center">0.14%</td>
              <td align="center">1417.72</td>
              <td align="center">1.162</td>
              <td align="right">57.805</td>
              <td align="center">1.027</td>
              <td align="center">1.093</td>
              <td align="center">0.883</td>
              <td align="center">71.543</td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">0.12%</td>
              <td align="center">1455.64</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td colspan="10">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">8.47%</td>
              <td align="center">3047.66</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td align="center">9</td>
              <td align="center">135</td>
              <td align="center">0.07%</td>
              <td align="center">2769.05</td>
              <td align="center">1.101</td>
              <td align="center">120.000</td>
              <td align="center">1.002</td>
              <td align="center">1.124</td>
              <td align="center">0.910</td>
              <td align="center">148.254</td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center">0.06%</td>
              <td align="center">2773.61</td>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
            </tr>
            <tr>
              <td colspan="10">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">mean</td>
              <td/>
              <td align="center">2.83%</td>
              <td align="center">1225.10</td>
              <td align="center">1.240</td>
              <td align="center">38.278</td>
              <td align="center">1.568</td>
              <td align="center">1.091</td>
              <td align="center">1.240</td>
              <td align="center">42.550</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Some tests for Human Chromosome 22 with parameters (L, d, r) = (260,13,280) and <italic>q </italic>ranging from 14 down to 9. The selectiveness improvement of <sc>EXCELLENT</sc> compensates for its slowdown over <sc>GOOD</sc> for <italic>q </italic>&lt; 12. The selectiveness improvement of <sc>EXCELLENT</sc> or <sc>GOOD</sc> over <sc>FINE</sc> is always very large and increases as <italic>q </italic>decreases. Recall that SD, SU and SI stand for <italic>speedup</italic>, <italic>slowdown </italic>and <italic>selectviness improvement </italic>respectively. Running times are given in seconds.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>Selectiveness was even better, with an average improvement of 38.3%. In these cases, we can also observe that the selectiveness improvement from <sc>EXCELLENT</sc> over <sc>GOOD</sc>, even if small, seems to compensate for the slowdown when <italic>q </italic>&lt; 12, as Table <xref ref-type="table" rid="T2">2</xref> shows.</p>
      <p>Notice also that <sc>EXCELLENT</sc> always improved selectiveness over <sc>GOOD</sc> (9% on average, with a minimum of 5.5%). Moreover, the running times for <sc>EXCELLENT</sc> show that increasing <italic>q </italic>may not lead to a faster execution of <sc>EXCELLENT</sc>, since the fastest execution was obtained for <italic>q </italic>= 12. This U-type curve is illustrated by Figure <xref ref-type="fig" rid="F6">6</xref>.</p>
      <fig position="float" id="F6">
        <label>Figure 6</label>
        <caption>
          <p><bold>Influence of <italic>q</italic>-gram size <italic>q </italic>over selectiveness and running time</bold>. Influence of <italic>q</italic>-gram size <italic>q </italic>over selectiveness and running time for Human Chromosome 22 with parameters (L, d, r) = (260,13,280). Variant <sc>EXCELLENT</sc> gets slower and less selective if we increase <italic>q </italic>from <italic>q </italic>= 12 on.</p>
        </caption>
        <graphic xlink:href="1748-7188-4-3-6"/>
      </fig>
      <p>In order to show the behaviour of <sc>TUIUIU</sc> when parameter <italic>r </italic>is changed, we refer to Figure <xref ref-type="fig" rid="F7">7</xref>, where <italic>r </italic>changes in a log scale from 9 to 3200. Notice that the running time of <sc>EXCELLENT</sc> decreases and selectiveness of all variants increases, as <italic>r </italic>increases. The running times of <sc>GOOD</sc> and <sc>FINE</sc> do not change. As we saw in Figure <xref ref-type="fig" rid="F6">6</xref> and in Table <xref ref-type="table" rid="T2">2</xref>, this parameter set with <italic>q </italic>= 14 is a bad choice for <sc>EXCELLENT</sc> as compared to <sc>GOOD</sc> in terms of both selectiveness and running times.</p>
      <fig position="float" id="F7">
        <label>Figure 7</label>
        <caption>
          <p><bold>Influence of number of repeats <italic>r </italic>over selectiveness and running time</bold>. Influence of number of repeats <italic>r </italic>over selectiveness and running time. Human Chromosome 22 with parameters (L, d, r) = (260, 13, r) with <italic>q </italic>= 14. The selectiveness of 0 obtained for methods <sc>GOOD</sc> and <sc>EXCELLENT</sc> are not drawn on the log scale. As <italic>r </italic>grows, the selectiveness decreases because more frequent repeats are rarer than the less frequent ones. Also, variant <sc>FINE</sc> gets less selective as <italic>r </italic>increases. Moreover, this illustrates a case in which <sc>EXCELLENT</sc> is time consuming while not bringing an improvement on the selectiveness with respect to <sc>GOOD</sc> as we could see also in Figure 5 and Table 2.</p>
        </caption>
        <graphic xlink:href="1748-7188-4-3-7"/>
      </fig>
    </sec>
    <sec>
      <title>Looking for multiple repeats across different species</title>
      <p>In the tests described from now on, we look for multiple repeats across different species. We apply for this <sc>TUIUIU</sc>* to a dataset from orthologous regions of the cystic fibrosis transmembrane conductance regulator gene in humans (denoted by CFTR) used in [<xref ref-type="bibr" rid="B13">13</xref>]. From this dataset, we chose the five sequences that had no 'N': human, mouse, cow, chicken, tetra. This adds up to 5.5 Mb.</p>
      <p>Like with MC58, we chose the same set of parameters, up to the fact that now we fix <italic>L </italic>= 100 and <italic>r </italic>= 5. Moreover, we added also the extreme cases where <italic>q </italic>= 3 and <italic>d </italic>= 12, 14 for the algorithms <sc>GOOD</sc>* and <sc>EXCELLENT</sc>*. In order to favour the comparisons to the MC58 cases, we discard the cases in which <italic>q </italic>= 3 in the average statistics. We now comment the results, shown in Table <xref ref-type="table" rid="T3">3</xref> and in Figures <xref ref-type="fig" rid="F8">8</xref> and <xref ref-type="fig" rid="F9">9</xref>. position to <sc>GOOD</sc>* and <sc>EXCELLENT</sc>* that register only (<italic>d </italic>+ <italic>b </italic>- <italic>q </italic>+ 1).</p>
      <table-wrap position="float" id="T3">
        <label>Table 3</label>
        <caption>
          <p><sc>FINE</sc>/<sc>GOOD</sc>/<sc>EXCELLENT</sc> comparison on CFTR dataset</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center">
                <italic>d</italic>
              </td>
              <td align="center">
                <italic>q</italic>
              </td>
              <td align="center">
                <italic>p</italic>
              </td>
              <td align="center" colspan="3">selectiveness (%)</td>
              <td align="center" colspan="3">running time(s)</td>
              <td align="center" colspan="2"><sc>Good</sc>-<sc>Fine</sc></td>
              <td align="center" colspan="2"><sc>Excellent</sc>-<sc>Good</sc></td>
              <td align="center" colspan="2"><sc>Excellent</sc>-<sc>Fine</sc></td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td/>
              <td align="center">
                <sc>Fine</sc>
              </td>
              <td align="center">
                <sc>Good</sc>
              </td>
              <td align="center">Excel</td>
              <td align="center">
                <sc>FINE</sc>
              </td>
              <td align="center">
                <sc>GOOD</sc>
              </td>
              <td align="center">Excel</td>
              <td align="center">SU</td>
              <td align="right">SI</td>
              <td align="center">SD</td>
              <td align="right">SI</td>
              <td align="center">SD</td>
              <td align="right">SI</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td/>
              <td align="center">8</td>
              <td align="center">13</td>
              <td align="center">13.84</td>
              <td align="center">5.10</td>
              <td align="center">1.36</td>
              <td align="center">123</td>
              <td align="center">116</td>
              <td align="center">131</td>
              <td align="center">1.055</td>
              <td align="right">2.71</td>
              <td align="center">1.129</td>
              <td align="right">3.76</td>
              <td align="center">1.070</td>
              <td align="right">10.21</td>
            </tr>
            <tr>
              <td/>
              <td align="center">7</td>
              <td align="center">24</td>
              <td align="center">12.85</td>
              <td align="center">1.91</td>
              <td align="center">0.05</td>
              <td align="center">371</td>
              <td align="center">370</td>
              <td align="center">385</td>
              <td align="center">1.003</td>
              <td align="right">6.71</td>
              <td align="center">1.041</td>
              <td align="right">41.90</td>
              <td align="center">1.037</td>
              <td align="right">281.28</td>
            </tr>
            <tr>
              <td align="center">10</td>
              <td align="center">6</td>
              <td align="center">35</td>
              <td align="center">14.28</td>
              <td align="center">0.89</td>
              <td align="center">0.01</td>
              <td align="center">1286</td>
              <td align="center">1292</td>
              <td align="center">1326</td>
              <td align="center">0.995</td>
              <td align="right">16.05</td>
              <td align="center">1.026</td>
              <td align="right">81.23</td>
              <td align="center">1.031</td>
              <td align="right">1304.19</td>
            </tr>
            <tr>
              <td/>
              <td align="center">5</td>
              <td align="center">46</td>
              <td align="center">21.92</td>
              <td align="center">0.65</td>
              <td align="center">0.00</td>
              <td align="center">5080</td>
              <td align="center">5138</td>
              <td align="center">5183</td>
              <td align="center">0.989</td>
              <td align="right">33.95</td>
              <td align="center">1.009</td>
              <td align="right">235.94</td>
              <td align="center">1.020</td>
              <td align="right">8011.07</td>
            </tr>
            <tr>
              <td/>
              <td align="center">4</td>
              <td align="center">57</td>
              <td align="center">57.96</td>
              <td align="center">1.02</td>
              <td align="center">0.00</td>
              <td align="center">13441</td>
              <td align="center">13362</td>
              <td align="center">13564</td>
              <td align="center">1.006</td>
              <td align="right">56.77</td>
              <td align="center">1.015</td>
              <td align="right">391.15</td>
              <td align="center">1.009</td>
              <td align="right">22208.66</td>
            </tr>
            <tr>
              <td colspan="15">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td align="center">7</td>
              <td align="center">10</td>
              <td align="center">50.85</td>
              <td align="center">24.51</td>
              <td align="center">13.50</td>
              <td align="center">405</td>
              <td align="center">382</td>
              <td align="center">468</td>
              <td align="center">1.059</td>
              <td align="right">2.07</td>
              <td align="center">1.223</td>
              <td align="right">1.81</td>
              <td align="center">1.155</td>
              <td align="right">3.76</td>
            </tr>
            <tr>
              <td align="center">12</td>
              <td align="center">6</td>
              <td align="center">23</td>
              <td align="center">28.09</td>
              <td align="center">3.99</td>
              <td align="center">0.13</td>
              <td align="center">1274</td>
              <td align="center">1262</td>
              <td align="center">1338</td>
              <td align="center">1.009</td>
              <td align="right">7.04</td>
              <td align="center">1.060</td>
              <td align="right">30.37</td>
              <td align="center">1.051</td>
              <td align="right">214.04</td>
            </tr>
            <tr>
              <td/>
              <td align="center">5</td>
              <td align="center">36</td>
              <td align="center">36.84</td>
              <td align="center">2.30</td>
              <td align="center">0.04</td>
              <td align="center">4972</td>
              <td align="center">4952</td>
              <td align="center">5055</td>
              <td align="center">1.004</td>
              <td align="right">16.02</td>
              <td align="center">1.021</td>
              <td align="right">53.37</td>
              <td align="center">1.017</td>
              <td align="right">855.33</td>
            </tr>
            <tr>
              <td/>
              <td align="center">4</td>
              <td align="center">49</td>
              <td align="center">85.10</td>
              <td align="center">3.53</td>
              <td align="center">0.02</td>
              <td align="center">13834</td>
              <td align="center">13612</td>
              <td align="center">13676</td>
              <td align="center">1.016</td>
              <td align="right">24.08</td>
              <td align="center">1.004</td>
              <td align="right">162.60</td>
              <td align="center">0.988</td>
              <td align="right">3916.57</td>
            </tr>
            <tr>
              <td colspan="15">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td align="center">6</td>
              <td align="center">11</td>
              <td align="center">99.63</td>
              <td align="center">96.79</td>
              <td align="center">85.71</td>
              <td align="center">1609</td>
              <td align="center">1405</td>
              <td align="center">2159</td>
              <td align="center">1.145</td>
              <td align="right">1.02</td>
              <td align="center">1.536</td>
              <td align="right">1.12</td>
              <td align="center">1.342</td>
              <td align="right">1.16</td>
            </tr>
            <tr>
              <td align="center">14</td>
              <td align="center">5</td>
              <td align="center">26</td>
              <td align="center">75.19</td>
              <td align="center">12.46</td>
              <td align="center">0.35</td>
              <td align="center">5017</td>
              <td align="center">4794</td>
              <td align="center">5080</td>
              <td align="center">1.047</td>
              <td align="right">6.03</td>
              <td align="center">1.060</td>
              <td align="right">35.70</td>
              <td align="center">1.013</td>
              <td align="right">215.46</td>
            </tr>
            <tr>
              <td/>
              <td align="center">4</td>
              <td align="center">41</td>
              <td align="center">99.68</td>
              <td align="center">25.08</td>
              <td align="center">0.08</td>
              <td align="center">14290</td>
              <td align="center">13969</td>
              <td align="center">14112</td>
              <td align="center">1.023</td>
              <td align="right">3.97</td>
              <td align="center">1.010</td>
              <td align="right">299.49</td>
              <td align="center">0.988</td>
              <td align="right">1190.06</td>
            </tr>
            <tr>
              <td colspan="15">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td/>
              <td align="center">mean</td>
              <td align="center">1.029</td>
              <td align="right">14.70</td>
              <td align="center">1.094</td>
              <td align="right">111.54</td>
              <td align="center">1.060</td>
              <td align="right">3184.32</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Measures for <sc>FINE</sc>/<sc>GOOD</sc>/<sc>EXCELLENT</sc> on the CFTR dataset with different parameters sets (L, r = 100,5) with large errors <italic>d </italic>and different values of <italic>q</italic>. Recall that SD, SU and SI stand for <italic>speed-up</italic>, <italic>slowdown </italic>and <italic>selectiveness improvement </italic>respectively.</p>
        </table-wrap-foot>
      </table-wrap>
      <fig position="float" id="F8">
        <label>Figure 8</label>
        <caption>
          <p><bold>Influence of q-gram size <italic>q </italic>over selectiveness and running time</bold>. Influence of q-gram size <italic>q </italic>over selectiveness and running time for CFTR dataset with parameters (L, d, r) = (100, 12, 5). This test shows that <sc>EXCELLENT</sc> is essential when using a small <italic>q</italic>, which enables to filter for a high error rate such as 12%. For instance, with <italic>q </italic>= 3, <sc>EXCELLENT</sc> reduces the selectiveness of 100% observed for both <sc>FINE</sc> and <sc>GOOD</sc> to 0.01%.</p>
        </caption>
        <graphic xlink:href="1748-7188-4-3-8"/>
      </fig>
      <fig position="float" id="F9">
        <label>Figure 9</label>
        <caption>
          <p><bold>Influence of maximal error <italic>d </italic>over selectiveness and running time</bold>. Influence of maximal error <italic>d </italic>over selectiveness and running time for CFTR dataset with parameters (L, d, r) = (100, d, 5) with <italic>q </italic>= 6. A selectiveness of 0 is not drawn because of the log scale.</p>
        </caption>
        <graphic xlink:href="1748-7188-4-3-9"/>
      </fig>
      <p>Figure <xref ref-type="fig" rid="F9">9</xref> shows the influence of the parameter <italic>d </italic>on selectiveness and running time for the CFTR dataset with <italic>L </italic>= 100, <italic>r </italic>= 5 and <italic>q </italic>= 6. The running times of <sc>FINE</sc>*, <sc>GOOD</sc>*, and <sc>EXCELLENT</sc>* are comparable: they slightly differ only for <italic>d </italic>&gt; 10. For low values of <italic>d</italic>, the selectiveness of <sc>GOOD</sc>* and <sc>EXCELLENT</sc>* is 0 (and indeed does not even appear in the figure because of the log scale). The reason is that the divergence of these sequences is bigger than 4%, since they belong to different species. The <sc>FINE</sc>* filter shows its limits concerning selectiveness since it does keep something (all false positives) also for these low maximal error rates.</p>
      <p>We thus focus our attention on large maximal error rates <italic>d</italic>. Table <xref ref-type="table" rid="T3">3</xref> shows 12 parameter sets with errors <italic>d </italic>= 10 (<italic>q </italic>= 4, 5, 6, 7, 8), <italic>d </italic>= 12 (<italic>q </italic>= 4, 5, 6, 7), <italic>d </italic>= 14 (<italic>q </italic>= 4, 5, 6). In all cases we have <italic>L </italic>= 100 and <italic>r </italic>= 5. Comparing <sc>GOOD</sc>* to <sc>FINE</sc>*, <sc>GOOD</sc>* always improved the selectiveness (14.7% on average) as we can see in Table <xref ref-type="table" rid="T3">3</xref>. Except in two cases, <sc>GOOD</sc>* was faster than <sc>FINE</sc>* (2.9% on average). Clearly on this data, <sc>GOOD</sc>* is the choice over <sc>FINE</sc>* even for larger values of <italic>q</italic>. Comparing <sc>EXCELLENT</sc>* to <sc>GOOD</sc>*, <sc>EXCELLENT</sc>* always improved the selectiveness (by 111.5% on average). As expected, in all cases, <sc>EXCELLENT</sc>* introduced a time overhead (9.4% on average). Only for the case <italic>d </italic>= 14 and <italic>q </italic>= 6, where the selectiveness was bad (even for <sc>EXCELLENT</sc>* with 85%), the selectiveness improvement was smaller than the observed slowdown (13% against 54%). Using the data of Table <xref ref-type="table" rid="T3">3</xref> in Figure <xref ref-type="fig" rid="F8">8</xref>, we can see the behaviour of algorithms <sc>FINE</sc>*, <sc>GOOD</sc>*, and <sc>EXCELLENT</sc>* when <italic>q </italic>changes. On one hand, <sc>EXCELLENT</sc>* always improves selectiveness as <italic>q </italic>is decreased – this behaviour is typical for <sc>EXCELLENT</sc>* and it is convenient since we can always improve selectiveness if we are willing to pay the extra running time associated with a decreasing of <italic>q</italic>. On the other hand, both <sc>FINE</sc>* and <sc>GOOD</sc>* have a U-like selectiveness curve with a minimal selectiveness (<sc>FINE</sc>* reached his minimal for <italic>q </italic>= 6 and <sc>GOOD</sc>* reached his minimal for <italic>q </italic>= 5) – this behaviour is also very typical for these methods. Since the running times of the three methods are basically comparable, due to its much better performances in terms of selectiveness, <sc>EXCELLENT</sc>* is clearly to be preferred for this data set instead of <sc>FINE</sc>* and <sc>GOOD</sc>*.</p>
    </sec>
    <sec>
      <title>Applying the filtered sequences to a local multiple aligner</title>
      <p>Finally, we discuss the application of <sc>TUIUIU</sc>* as a preprocessing tool to a local multiple alignment program, using the CFTR data we described earlier. Exact local multiple aligners of <italic>k </italic>sequences each of length <italic>n </italic>take time proportional to 2<sup><italic>k</italic>-1 </sup><italic>n</italic><sup><italic>k </italic></sup>using dynamic programming. For this reason, existing multiple aligners provide only a suboptimal solution. The algorithms will still provide a suboptimal solution even when a filter is applied upstream. This is important to observe for what will follow. It means that although <sc>TUIUIU</sc>* is a lossless filter, the end result may not correspond to the optimal alignment if the aligner itself is a heuristic, or if it is designed to optimise a scoring function different from the one the filter is made for. It may even in some cases lead to a worse alignment score than the one obtained without filtering. Indeed, this is not the best use of a lossless filter, but filters, lossless or not, remain important devices for improving the efficiency and quality of multiple aligners, independent from whether the latter are exact or heuristic, as we shall see in the tests described in this section.</p>
      <p>To our purposes, a local as opposed to a multiple aligner was also a preferable choice to illustrate the use of <sc>TUIUIU</sc>*. This limited the options, most multiple aligners being global. We decided to use <sc>GLAM</sc>2 <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.org.au/glam2/doc/"/> which is an evolution of <sc>GLAM</sc> (gapless local alignment of multiple sequences, [<xref ref-type="bibr" rid="B20">20</xref>]) that was made for multiple alignments without gaps. Differently from its predecessor, <sc>GLAM</sc>2 allows for gaps and hence indels. Since the size of the searching space of <sc>GLAM</sc>2 is <italic>n</italic><sup><italic>k</italic></sup>, <sc>GLAM</sc>2 samples such space using a Gibbs Sampling method for multiple alignment with simulated annealing for the optimisation step.</p>
      <p>We first applied <sc>GLAM</sc>2 directly on the unfiltered CFTR dataset. It took 34 hours and 55 minutes to run it in order to find the best multiple alignment of the CFTR data. <sc>GLAM</sc>2 may in fact provide not just one best alignment but the ten best scoring alignments. The top scoring alignment had a score in bits of 262.977. The tests were run on an Intel(R) Core(TM)2 Duo processor with frequence of 2.40 GHz and 2 Gb of memory. We used the <sc>GLAM</sc>2 parameter that forces the alignment to involve all input sequences. Needless to say that this running time is not satisfactory.</p>
      <p>On the same unfiltered CFTR dataset, we then applied <sc>TUIUIU</sc>*, (using the filtering conditions <sc>FINE</sc>*, <sc>GOOD</sc>* and <sc>EXCELLENT</sc>*) with <italic>L </italic>= 100 and <italic>r </italic>= 5 (the dataset contains indeed five mammalian sequences), and for <italic>d </italic>= 7, 12, 14, 15 (with respectively <italic>q </italic>= 11, 6, 5, 5). Our purpose was to then run again <sc>GLAM</sc>2 using the same parameters as above, but feeding it this time with the filtered sequences as input. In this way, we expected to reduce the searching space of <sc>GLAM</sc>2, and hence its running time. This is in fact what we can observe in the results shown in Table <xref ref-type="table" rid="T4">4</xref>.</p>
      <table-wrap position="float" id="T4">
        <label>Table 4</label>
        <caption>
          <p>Improvements on <sc><sc>GLAM</sc></sc>2 's speed and results quality after filtering by <sc>TUIUIU</sc></p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td/>
              <td/>
              <td/>
              <td align="center" colspan="2">
                <sc>TUIUIU</sc>
              </td>
              <td align="center" colspan="2"><sc>GLAM</sc>2</td>
              <td/>
            </tr>
            <tr>
              <td align="center">
                <italic>q</italic>
              </td>
              <td align="center">
                <italic>d</italic>
              </td>
              <td align="center">filter</td>
              <td align="center">time(s)</td>
              <td align="center">length</td>
              <td align="center">time(s)</td>
              <td align="center">scrbits</td>
              <td align="center">total time (s)</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td/>
              <td/>
              <td align="center">
                <italic>no filter</italic>
              </td>
              <td align="center">
                <italic>0.00</italic>
              </td>
              <td align="center">
                <italic>5518041</italic>
              </td>
              <td align="center">
                <italic>125667</italic>
              </td>
              <td align="center">
                <italic>262.977</italic>
              </td>
              <td align="center">
                <italic>125667</italic>
              </td>
            </tr>
            <tr>
              <td colspan="8">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center"><sc>FINE</sc>*</td>
              <td align="center">9.26</td>
              <td align="center">264368</td>
              <td align="center">4732</td>
              <td align="center">244.794</td>
              <td align="center">4741</td>
            </tr>
            <tr>
              <td align="center">11</td>
              <td align="center">7</td>
              <td align="center"><sc>GOOD</sc>*</td>
              <td align="center">7.27</td>
              <td align="center">109244</td>
              <td align="center">2364</td>
              <td align="center">303.747</td>
              <td align="center">2371</td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center"><sc>EXCELLENT</sc>*</td>
              <td align="center">
                <bold>9.76</bold>
              </td>
              <td align="center">
                <bold>10256</bold>
              </td>
              <td align="center">
                <bold>228</bold>
              </td>
              <td align="center">
                <bold>283.022</bold>
              </td>
              <td align="center">
                <bold>238</bold>
              </td>
            </tr>
            <tr>
              <td colspan="8">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center"><sc>FINE</sc>*</td>
              <td align="center">456.55</td>
              <td align="center">1556839</td>
              <td align="center">36357</td>
              <td align="center">287.102</td>
              <td align="center">36814</td>
            </tr>
            <tr>
              <td align="center">6</td>
              <td align="center">12</td>
              <td align="center"><sc>GOOD</sc>*</td>
              <td align="center">422.53</td>
              <td align="center">221127</td>
              <td align="center">5705</td>
              <td align="center">356.874</td>
              <td align="center">6128</td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center"><sc>EXCELLENT</sc>*</td>
              <td align="center">
                <bold>439.48</bold>
              </td>
              <td align="center">
                <bold>7289</bold>
              </td>
              <td align="center">
                <bold>135</bold>
              </td>
              <td align="center">
                <bold>469.664</bold>
              </td>
              <td align="center">
                <bold>575</bold>
              </td>
            </tr>
            <tr>
              <td colspan="8">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center"><sc>FINE</sc>*</td>
              <td align="center">1439.12</td>
              <td align="center">4159686</td>
              <td align="center">83055</td>
              <td align="center">262.977</td>
              <td align="center">84494</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="center">14</td>
              <td align="center"><sc>GOOD</sc>*</td>
              <td align="center">1387.27</td>
              <td align="center">691442</td>
              <td align="center">14545</td>
              <td align="center">262.977</td>
              <td align="center">15932</td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center"><sc>EXCELLENT</sc>*</td>
              <td align="center">
                <bold>1499.74</bold>
              </td>
              <td align="center">
                <bold>19393</bold>
              </td>
              <td align="center">
                <bold>395</bold>
              </td>
              <td align="center">
                <bold>406.321</bold>
              </td>
              <td align="center">
                <bold>1895</bold>
              </td>
            </tr>
            <tr>
              <td colspan="8">
                <hr/>
              </td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center"><sc>FINE</sc>*</td>
              <td align="center">1640.49</td>
              <td align="center">5437974</td>
              <td align="center">107908</td>
              <td align="center">287.295</td>
              <td align="center">109548</td>
            </tr>
            <tr>
              <td align="center">5</td>
              <td align="center">15</td>
              <td align="center"><sc>GOOD</sc>*</td>
              <td align="center">1446.02</td>
              <td align="center">3267656</td>
              <td align="center">71303</td>
              <td align="center">256.076</td>
              <td align="center">72749</td>
            </tr>
            <tr>
              <td/>
              <td/>
              <td align="center"><sc>EXCELLENT</sc>*</td>
              <td align="center">
                <bold>1814.78</bold>
              </td>
              <td align="center">
                <bold>375805</bold>
              </td>
              <td align="center">
                <bold>7242</bold>
              </td>
              <td align="center">
                <bold>268.878</bold>
              </td>
              <td align="center">
                <bold>9057</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Improvements on <sc>GLAM</sc>2's speed and alignment quality after filtering the CFTR dataset with <sc>TUIUIU</sc>*. Filtration time and final length are provided for the three versions of <sc>TUIUIU</sc>* with <italic>L </italic>= 100 and <italic>r </italic>= 5. Running time, score bits of best multiple alignment found on filtered data is provided for <sc><sc>GLAM</sc></sc>2. Tests are done for <italic>d </italic>= 7, 12, 14, 15 (with respectively <italic>q </italic>= 11, 6, 5, 5). The last column sums the two time columns, providing the total time (filtering plus alignment).</p>
        </table-wrap-foot>
      </table-wrap>
      <p>In Table <xref ref-type="table" rid="T4">4</xref>, we can see a first line with data involving the execution of <sc>GLAM</sc>2 on the unfiltered sequences: input length, time, and score. Then, for each pair of parameters (<italic>q</italic>, <italic>d</italic>), we show:</p>
      <p>• For <sc>TUIUIU</sc>*, the time taken by the three versions of the filter and the length of the resulting filtered sequences.</p>
      <p>• For <sc>GLAM</sc>2, in each case we show the time it takes to find the best alignment on the filtered data (to be consistent in the way the experiments are done and not introduce any possibly human-related bias, only the alignment at the top of the list is considered each time, as was the case for <sc>GLAM</sc>2 without filter), and the score of such alignment.</p>
      <p>• The last column shows the sum of the time taken by the filter and that taken by the alignment on the filtered data.</p>
      <p>It turns out that the best performances are obtained by <sc>EXCELLENT</sc>*, which lead to the fastest overall computation: the little extra time required for filtering is indeed highly compensated by the filtering power and hence by the faster alignment. Moreover, in all cases <sc>EXCELLENT</sc>* also allows <sc>GLAM</sc>2 to improve the quality of the alignment. We can explain this unpredicted behaviour by the fact that reducing the searching space allows the probabilistic searching strategy of <sc>GLAM</sc>2 to find, with much higher probability, a multiple alignment that is closer to the optimal solution.</p>
      <p>For instance, applying <sc>EXCELLENT</sc>* with parameters (<italic>q</italic>, <italic>d</italic>) = (11, 7) decreases the running time of <sc>GLAM</sc>2 from 125667 seconds (34<italic>h</italic>55') to only 238 seconds (3<italic>'</italic>48"), that is, <sc>GLAM</sc>2 with filter runs 551 times faster than <sc>GLAM</sc>2 alone. Even adding the 10 seconds of the filtering time, we get an overall execution that is 530 times faster. Moreover, in this case the score of the best alignment also improves, going from 262.997 to 283.022. A much higher quality improvement is obtained for (<italic>q</italic>, <italic>d</italic>) = (6, 12) with a score of 469, in which case the overall time (filtering plus alignment) is also 218 times faster than without filtering (direct alignment).</p>
      <p>In two cases ((<italic>q</italic>, <italic>d</italic>) = (11, 7) using <sc>FINE</sc>* and (<italic>q</italic>, <italic>d</italic>) = (5, 15) using <sc>GOOD</sc>*), the score obtained after filtering is smaller (the score of 262.977 became respectively 244.794 and 256.076) than the one without the filter. Besides the problem mentioned above, another reason for this behaviour is that the score function used by <sc>GLAM</sc>2 aims at optimising the score of the alignment whatever the length. The final length obtained may thus be greater than <italic>L</italic>. The best alignment may also contain very long gaps, and this indeed is what happens with some of the conditions and parameter sets used ((<italic>q</italic>, <italic>d</italic>) = (11, 7) using <sc>GOOD</sc>* or <sc>EXCELLENT</sc>*, and (<italic>q</italic>, <italic>d</italic>) = (6, 12) using <sc>FINE</sc>*). This is not the same objective as finding (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeats. In the two cases were the score was smaller after filtering, the part removed by <sc>TUIUIU</sc>* apparently participated in a better local alignment <italic>under the score function used by </italic><sc>GLAM</sc>2. However, our goal with these tests was to speed up the computation of the optimal alignment, and <sc>TUIUIU</sc>* clearly succeeds in that, with in most cases an improvement in the score.</p>
      <p>As shown in Table <xref ref-type="table" rid="T4">4</xref>, it is possible to increase <italic>d </italic>to 14 or even 15. In such a case, we must reduce <italic>q </italic>from 6 to 5 in order to keep a strong filtering condition. For <italic>d </italic>= 14, we can obtain an alignment with a score quite better than without the filter (406 rather than 263), with an overall execution that is 66 times faster. Finally, for <italic>d </italic>= 15, we can obtain an alignment with a score slightly better than without the filter, while still being 14 times faster.</p>
    </sec>
  </sec>
  <sec>
    <title>Conclusion</title>
    <p>To the best of our knowledge, <sc>TUIUIU</sc> is the first filter for multiple repeats based on the edit distance that takes a multiple alignment task into account. Its closest ancestor, designed with a different goal, looking for (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeats with <italic>r </italic>= 2 and small values for <italic>d</italic>, is <sc>SWIFT</sc>[<xref ref-type="bibr" rid="B6">6</xref>], and its filtering condition was reproduced in the variant <sc>FINE</sc> of <sc>TUIUIU</sc>. We were also able to find two improvements that led to two new filtering conditions, implemented respectively in the two variants <sc>GOOD</sc> and <sc>EXCELLENT</sc>. We tested the correctness of <sc>TUIUIU</sc> with simulated data containing planted (<italic>L</italic>, <italic>d</italic>, <italic>r</italic>)-repeats inserted in random data, using a very wide range of parameters sets, to check the sensibility to all parameters for all the versions. We also applied <sc>TUIUIU</sc> on three kinds of real data, the bacteria MC58, the Human Chromosome XXII, and the CFTR dataset, again using a wide range of parameter sets. <sc>GOOD</sc> was clearly better than <sc>FINE</sc>, for all kinds of data and almost all parameter sets. <sc>EXCELLENT</sc> improved considerably the selectiveness, with some overhead, and became clearly advantageous for large error rates and not too small threshold <italic>p</italic>. This happened in all datasets, with clearer effect on the MC58 and CFTR datasets. More tests, with wider ranges of parameter sets, are expected in a future work for Human Chromosome XXII, but the abundance of repeats with large error rates associated with the long lengths involved is certainly an intrinsic difficulty with this dataset. <sc>TUIUIU</sc> was applied as a preprocessing step of a local multiple alignment tool, leading to an an overall execution time (filter plus alignment) on average 63 and at best 530 times smaller than before (direct alignment) (from 34 hours and 55 minutes down to less than 4 minutes). Moreover, in this shorter time, the multiple alignment tool was often able to find a better scoring alignement. Indeed, the strong reduction in the searching space that was obtained due to the application of <sc>TUIUIU</sc>, and the ability of our filter to deal with large error rates, allowed the tool to perform better also at the qualitative level due to the removal of sequences that were not candidates for best local multiple alignment with bounded edit distance.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>MFS, NP and PP initiated the work, while all authors contributed to the conceptual and algorithmic choices. GS developed the prototype. Tests were mainly designed and performed by AP. All authors participated in the analysis of the results, and in editing the manuscript that was first drafted by PP.</p>
  </sec>
  <sec>
    <title>Appendix</title>
    <sec>
      <title>Appendix 1 – Algorithm: overview of <sc>TUIUIU</sc></title>
      <p><bold>Require: </bold>sequence <italic>s </italic>of length <italic>n</italic>, parameters <italic>L</italic>, <italic>d</italic>, <italic>r</italic>, <italic>q </italic>and <italic>b</italic></p>
      <p><bold>Ensure: </bold>set of positions of <italic>s </italic>that respect the third filtering condition</p>
      <p>1: <italic>p </italic>= (<italic>L </italic>- <italic>q </italic>+ 1) - <italic>qd</italic></p>
      <p>2: Create <italic>q</italic>-gram index</p>
      <p>3: Initialise with 0 all counters associated with the parallelograms</p>
      <p>4: Initialise counter with respect to <italic>q</italic>-grams occurring in [0, <italic>L </italic>- <italic>q</italic>]</p>
      <p>5: <bold>for </bold>every sliding window [<italic>i</italic>, <italic>i </italic>+ <italic>L </italic>- 1] ⊆ [0, <italic>n </italic>- 1] <bold>do</bold></p>
      <p>6:    <bold>for </bold>every occurrence <italic>j </italic>of <italic>s</italic>[<italic>i </italic>+ <italic>L </italic>- <italic>q</italic>, <italic>i </italic>+ <italic>L </italic>- 1] in <italic>s </italic><bold>do</bold></p>
      <p>7:       Update the counters whose parallelograms the <italic>q</italic>-hit (<italic>i </italic>+ <italic>L </italic>- <italic>q</italic>, <italic>j</italic>) belong to</p>
      <p>8:       <bold>for </bold>the updated counters that become <italic>p </italic><bold>do</bold></p>
      <p>9:          Insert the parallelogram into the set of good parallelograms</p>
      <p>10:       <bold>end for</bold></p>
      <p>11:    <bold>end for</bold></p>
      <p>12:    <bold>for </bold>every occurrence <italic>j </italic>of <italic>s</italic>[<italic>i </italic>- 1, <italic>i </italic>+ <italic>q </italic>- 2] in <italic>s </italic><bold>do</bold></p>
      <p>13:       Unset the counters whose parallelograms the <italic>q</italic>-hit (<italic>i </italic>- 1, <italic>j</italic>) belong to</p>
      <p>14:       <bold>for </bold>the updated counters that becomes <italic>p </italic>- 1 <bold>do</bold></p>
      <p>15:          Remove the parallelogram from the set of good parallelograms</p>
      <p>16:       <bold>end for</bold></p>
      <p>17:    <bold>end for</bold></p>
      <p>18:    <bold>if </bold>number of good non-overlapping parallelograms ≥ <italic>r </italic>then</p>
      <p>19:       <bold>for </bold>all good parallelograms <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M69" name="1748-7188-4-3-i12" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">P</mml:mi></mml:semantics></mml:math></inline-formula><bold>do</bold></p>
      <p>20:          Test whether <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M70" name="1748-7188-4-3-i12" overflow="scroll"><mml:semantics><mml:mi mathvariant="script">P</mml:mi></mml:semantics></mml:math></inline-formula> is an excellent parallelogram or not</p>
      <p>21:       <bold>end for</bold></p>
      <p>22:       <bold>if </bold>number of excellent non-overlapping parallelogram ≥ <italic>r </italic>then</p>
      <p>23:          Conserve positions [<italic>i</italic>, <italic>i </italic>+ <italic>L </italic>- 1]</p>
      <p>24:       <bold>end if</bold></p>
      <p>25:    <bold>end if</bold></p>
      <p>26: <bold>end for</bold></p>
    </sec>
  </sec>
</body>
<back>
  <ref-list>
    <ref id="B1">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lowe</surname>
            <given-names>CB</given-names>
          </name>
          <name>
            <surname>Bejerano</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Haussler</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Thousands of human mobile element fragments undergo strong purifying selection near developmental genes</article-title>
        <source>National Academy of Sciences</source>
        <year>2007</year>
        <volume>104</volume>
        <fpage>8005</fpage>
        <lpage>8010</lpage>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ugarkovic</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Functional elements residing within satellite DNA</article-title>
        <source>EMBO reports</source>
        <year>2005</year>
        <volume>6</volume>
        <fpage>1035</fpage>
        <lpage>1039</lpage>
        <pub-id pub-id-type="pmid">16264428</pub-id>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rigoutsos</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Huynh</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Miranda</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Tsirigos</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>McHardy</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Platt</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Short blocks from the noncoding parts of the human genome have instances within nearly all known genes and relate to biological processes</article-title>
        <source>National Academy of Science</source>
        <year>2006</year>
        <volume>103</volume>
        <fpage>6605</fpage>
        <lpage>6610</lpage>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Burkhardt</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Crauser</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ferragina</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Lenhof</surname>
            <given-names>HP</given-names>
          </name>
          <name>
            <surname>Vingron</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title><italic>q</italic>-Gram Based Database Searching Using a Suffix Array (QUASAR)</article-title>
        <source>Proceedings of the third annual international conference on Computational molecular biology (Recomb 99)</source>
        <year>1999</year>
        <publisher-name>ACM Press</publisher-name>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pevzner</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Multiple Filtration and Approximate Pattern Matching</article-title>
        <source>Algorithmica</source>
        <year>1995</year>
        <volume>13</volume>
        <fpage>135</fpage>
        <lpage>154</lpage>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rasmussen</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Stoye</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Efficient q-gram Filters for finding all epsilon-matches over a given length</article-title>
        <source>Journal of Computational Biology</source>
        <year>2006</year>
        <volume>13</volume>
        <fpage>296</fpage>
        <lpage>308</lpage>
        <pub-id pub-id-type="pmid">16597241</pub-id>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Approximate String-Matching with <italic>q</italic>-Grams and Maximal Matches</article-title>
        <source>Theoretical Computer Science</source>
        <year>1992</year>
        <volume>92</volume>
        <fpage>191</fpage>
        <lpage>211</lpage>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Finding approximate patterns in strings</article-title>
        <source>Journal of Algorithms</source>
        <year>1985</year>
        <volume>6</volume>
        <fpage>132</fpage>
        <lpage>137</lpage>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Ma</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>PatternHunter II: Highly Sensitive and Fast Homology Search</article-title>
        <source>Genome Informatics</source>
        <year>2003</year>
        <volume>14</volume>
        <fpage>164</fpage>
        <lpage>175</lpage>
        <pub-id pub-id-type="pmid">15706531</pub-id>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kucherov</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Noé</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Roytberg</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Multiseed Lossless Filtration</article-title>
        <source>IEEE/ACM Transactions on Computational Biology and Bioinformatics</source>
        <year>2005</year>
        <volume>02</volume>
        <fpage>51</fpage>
        <lpage>61</lpage>
        <pub-id pub-id-type="pmid">17044164</pub-id>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sun</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Buhler</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Choosing the Best Heuristic for Seeded Alignment of DNA Sequences</article-title>
        <source>BMC Bioinformatics</source>
        <year>2006</year>
        <volume>7</volume>
        <fpage>133</fpage>
        <pub-id pub-id-type="pmid">16533404</pub-id>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kolpakov</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Bana</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Kucherov</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>MREPS: Efficient and Flexible Detection of Tandem Repeats in DNA</article-title>
        <source>Nucleic Acid Research</source>
        <year>2003</year>
        <volume>31</volume>
        <fpage>3672</fpage>
        <lpage>3678</lpage>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Do</surname>
            <given-names>CB</given-names>
          </name>
          <name>
            <surname>Cooper</surname>
            <given-names>GM</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Davydov</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Green</surname>
            <given-names>ED</given-names>
          </name>
          <name>
            <surname>Sidow</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Batzoglou</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>LAGAN and Multi-LAGAN: Efficient Tools for Large-Scale Multiple Alignment of Genomic DNA</article-title>
        <source>Genome Research</source>
        <year>2003</year>
        <volume>13</volume>
        <fpage>721</fpage>
        <lpage>731</lpage>
        <pub-id pub-id-type="pmid">12654723</pub-id>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Chapman</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Göttgens</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Batzoglou</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Morgenstern</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Fast and Sensitive Multiple Alignment of Large Genomic Sequences</article-title>
        <source>BMC Bioinformatics</source>
        <year>2003</year>
        <volume>4</volume>
        <fpage>66</fpage>
        <pub-id pub-id-type="pmid">14693042</pub-id>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Peterlongo</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Pisanti</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Boyer</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Sagot</surname>
            <given-names>MF</given-names>
          </name>
        </person-group>
        <article-title>Lossless Filter for Finding Long Multiple Approximate Repetitions Using a New Data Structure, the Bi-factor Array</article-title>
        <source>String Processing and Information Retrieval (SPIRE 2005) 3772 of LNCS</source>
        <year>2005</year>
        <fpage>179</fpage>
        <lpage>190</lpage>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Peterlongo</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Pisanti</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Boyer</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>do Lago</surname>
            <given-names>AP</given-names>
          </name>
          <name>
            <surname>Sagot</surname>
            <given-names>MF</given-names>
          </name>
        </person-group>
        <article-title>Lossless filter for multiple repetitions with Hamming distance</article-title>
        <source>Journal of Discrete Algorithms</source>
        <year>2008</year>
        <volume>6</volume>
        <fpage>497</fpage>
        <lpage>509</lpage>
      </citation>
    </ref>
    <ref id="B17">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hunt</surname>
            <given-names>JW</given-names>
          </name>
          <name>
            <surname>Szymanski</surname>
            <given-names>TG</given-names>
          </name>
        </person-group>
        <article-title>A Fast Algorithm for Computing Longest Common Subsequences</article-title>
        <source>CACM</source>
        <year>1977</year>
        <volume>20</volume>
        <fpage>350</fpage>
        <lpage>353</lpage>
      </citation>
    </ref>
    <ref id="B18">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Gusfield</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <source>Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology</source>
        <year>1997</year>
        <publisher-name>Cambridge University Press</publisher-name>
      </citation>
    </ref>
    <ref id="B19">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tettelin</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Complete Genome Sequence of Neisseria Meningitidis Serogroup B Strain MC58</article-title>
        <source>Science</source>
        <year>2000</year>
        <volume>287</volume>
        <fpage>1809</fpage>
        <lpage>1815</lpage>
        <pub-id pub-id-type="pmid">10710307</pub-id>
      </citation>
    </ref>
    <ref id="B20">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Frith</surname>
            <given-names>MC</given-names>
          </name>
          <name>
            <surname>Hansen</surname>
            <given-names>U</given-names>
          </name>
          <name>
            <surname>Spouge</surname>
            <given-names>JL</given-names>
          </name>
          <name>
            <surname>Weng</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>Finding functional sequence elements by multiple local alignment</article-title>
        <source>Nucleic Acids Research</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>189</fpage>
        <lpage>200</lpage>
        <pub-id pub-id-type="pmid">14704356</pub-id>
      </citation>
    </ref>
  </ref-list>
</back>
