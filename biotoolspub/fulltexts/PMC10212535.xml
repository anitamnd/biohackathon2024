<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10212535</article-id>
    <article-id pub-id-type="pmid">37195454</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad305</article-id>
    <article-id pub-id-type="publisher-id">btad305</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Data and Text Mining</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title><monospace>fimpera</monospace>: drastic improvement of Approximate Membership Query data-structures with counts</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Robidou</surname>
          <given-names>Lucas</given-names>
        </name>
        <aff><institution>Univ. Rennes, Inria, CNRS, IRISA</institution>, Rennes, F-35000, <country country="FR">France</country></aff>
        <xref rid="btad305-cor1" ref-type="corresp"/>
        <!--lucas.robidou@inria.fr-->
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-0776-6407</contrib-id>
        <name>
          <surname>Peterlongo</surname>
          <given-names>Pierre</given-names>
        </name>
        <aff><institution>Univ. Rennes, Inria, CNRS, IRISA</institution>, Rennes, F-35000, <country country="FR">France</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Wren</surname>
          <given-names>Jonathan</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad305-cor1">Corresponding author. Université Rennes, Inria, CNRS, IRISA, Rennes, France. E-mail: <email>lucas.robidou@inria.fr</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>5</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-05-17">
      <day>17</day>
      <month>5</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>17</day>
      <month>5</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>5</issue>
    <elocation-id>btad305</elocation-id>
    <history>
      <date date-type="received">
        <day>30</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>13</day>
        <month>4</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>24</day>
        <month>4</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>25</day>
        <month>5</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad305.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>High throughput sequencing technologies generate massive amounts of biological sequence datasets as costs fall. One of the current algorithmic challenges for exploiting these data on a global scale consists in providing efficient query engines on these petabyte-scale datasets. Most methods indexing those datasets rely on indexing words of fixed length <italic toggle="yes">k</italic>, called <italic toggle="yes">k</italic>-mers. Many applications, such as metagenomics, require the abundance of indexed <italic toggle="yes">k</italic>-mers as well as their simple presence or absence, but no method scales up to petabyte-scaled datasets. This deficiency is primarily because storing abundance requires explicit storage of the <italic toggle="yes">k</italic>-mers in order to associate them with their counts. Using counting Approximate Membership Queries (cAMQ) data structures, such as counting Bloom filters, provides a way to index large amounts of <italic toggle="yes">k</italic>-mers with their abundance, but at the expense of a sensible false positive rate.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We propose a novel algorithm, called <monospace>fimpera</monospace>, that enables the improvement of any cAMQ performance. Applied to counting Bloom filters, our proposed algorithm reduces the false positive rate by two orders of magnitude and it improves the precision of the reported abundances. Alternatively, <monospace>fimpera</monospace> allows for the reduction of the size of a counting Bloom filter by two orders of magnitude while maintaining the same precision. <monospace>fimpera</monospace> does not introduce any memory overhead and may even reduces the query time.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p><ext-link xlink:href="https://github.com/lrobidou/fimpera" ext-link-type="uri">https://github.com/lrobidou/fimpera</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>ANR SeqDigger</institution>
          </institution-wrap>
        </funding-source>
        <award-id>ANR-19-CE45-0008</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Public data banks providing sequencing data or assembled genome sequences are growing at an exponential rate (<xref rid="btad305-B7" ref-type="bibr">Cummins et al. 2022</xref>), and faster than computational power. Searching for a sequence of interest among datasets is a fundamental need that enables for instance a better understanding of genetic changes in tumors, offering precious information about the diagnosis and treatment of cancer (<xref rid="btad305-B25" ref-type="bibr">Tomczak et al. 2015</xref>), or enabling to study at a large scale the distribution and adaptation of life in oceans (<xref rid="btad305-B24" ref-type="bibr">Sunagawa et al. 2020</xref>). However, no method scales to the dozens of petabytes of data already available today. Thus, new computational methods are required to perform a search against datasets.</p>
    <p>Querying datasets can be done precisely by aligning genome sequences [e.g. using Blast-like (<xref rid="btad305-B2" ref-type="bibr">Altschul et al. 1990</xref>) algorithms]. However aligning sequences is computational-resources intensive and cannot be applied efficiently when datasets are raw sequencing data. Thus, queries on large-scale datasets are usually done through <italic toggle="yes">k</italic>-mers presence/absence: each dataset is represented by its set of <italic toggle="yes">k</italic>-mers, and a query is represented by its sequence of <italic toggle="yes">k</italic>-mers. The ratio of the <italic toggle="yes">k</italic>-mers in the query and in the dataset over all the <italic toggle="yes">k</italic>-mers in the query approximates the similarity between the query and the dataset.</p>
    <p>The challenge is to index hundreds of billions of distinct <italic toggle="yes">k</italic>-mers across thousands of datasets. Methodological developments have thus been made to index every <italic toggle="yes">k</italic>-mer of a dataset. Some methods use Approximate Membership Query (AMQ) data structures, e.g. Bloom filters, to store the presence/absence of <italic toggle="yes">k</italic>-mers, as for instance SBT (<xref rid="btad305-B23" ref-type="bibr">Solomon and Kingsford 2016</xref>) or HowDeSBT (<xref rid="btad305-B10" ref-type="bibr">Harris and Medvedev 2020</xref>); see <xref rid="btad305-B14" ref-type="bibr">Marchet et al. (2021)</xref> and <xref rid="btad305-B6" ref-type="bibr">Chikhi et al. (2022)</xref> for a survey of the approaches. However, very few methods tackle the issue of recording the abundance of the indexed <italic toggle="yes">k</italic>-mers. The information about the abundance is however crucial for many biological applications such as in transcriptomics, metagenomics, or metatranscriptomics analyses. We can distinguish three strategies for indexing <italic toggle="yes">k</italic>-mer abundances:</p>
    <list list-type="bullet">
      <list-item>
        <p>Explicitly storing couples (<italic toggle="yes">k</italic>-mer, abundances). This may be done simply using hash tables with <italic toggle="yes">k</italic>-mers as keys and their abundances as values. However, this approach cannot scale to dozens or billions of distinct <italic toggle="yes">k</italic>-mers. More compact solutions reduce the <italic toggle="yes">k</italic>-mer set size using assemblies such as compact de Bruijn graph representation [see <xref rid="btad305-B4" ref-type="bibr">Bowe et al. (2012)</xref> or <xref rid="btad305-B1" ref-type="bibr">Alanko et al. (2022)</xref>] or a spectrum-preserving string set (SPSS) (<xref rid="btad305-B19" ref-type="bibr">Rahman and Medvedev 2020</xref>). However, these approaches still require the explicit association of each represented <italic toggle="yes">k</italic>-mer to its set of abundances in each indexed dataset. Additionally, computing the de Bruijn graph or the SPSS of a set of reads requires intensive computational resources. As such, while being effective on, e.g. full genomes, it becomes inefficient when representing highly complex and diverse datasets such as metagenomic seawater for instance. Note that once the set of <italic toggle="yes">k</italic>-mer is computed, the memory cost of adding counts is not the bottleneck [see <xref rid="btad305-B16" ref-type="bibr">Pibiri (2022a)</xref>, in which the storage of abundances requires only a fraction of the total memory usage]. Moreover, counts can be stored as an approximation [see <xref rid="btad305-B21" ref-type="bibr">Shibuya et al. (2022a)</xref>] or exactly, as described below.</p>
      </list-item>
      <list-item>
        <p>Using a minimal perfect hash function (MPHF) such as <xref rid="btad305-B12" ref-type="bibr">Limasset et al. (2017)</xref>, or more recently <xref rid="btad305-B18" ref-type="bibr">Pibiri and Trani (2021)</xref>. MPHFs enable the association of an indexed key to a specific and unique value. They provide an efficient way to associate a key to any piece of information. In our context, a <italic toggle="yes">k</italic>-mer can be associated with its abundance in various datasets. Not talking about their construction computation time, these MPHFs do not enable the detection of whether a queried <italic toggle="yes">k</italic>-mer belongs to the original indexed set. Hence, they provide erroneous information for any non-indexed <italic toggle="yes">k</italic>-mer, limiting their usage in this context.</p>
        <p>To circumvent this problem, certain MHPFs rely on an explicit representation of the indexed <italic toggle="yes">k</italic>-mer set and hence also fall into the previous strategy. This is for instance the case of Blight (<xref rid="btad305-B13" ref-type="bibr">Marchet et al. 2019</xref>) and SSHash (<xref rid="btad305-B17" ref-type="bibr">Pibiri 2022b</xref>). However, for the same reasons as previously mentioned, these approaches cannot be applied to highly complex and diverse datasets.</p>
      </list-item>
      <list-item>
        <p>Use an AMQ, adding the abundance information instead of only the presence/absence of each <italic toggle="yes">k</italic>-mer, in this case, we call this AMQ a “counting AMQ”. Using a counting AMQ, the count information cannot be stored using a distinct structure in which the redundant count information between <italic toggle="yes">k</italic>-mers could be compressed, as proposed in <xref rid="btad305-B22" ref-type="bibr">Shibuya et al. (2022b)</xref>. Instead, in a counting AMQ, the abundance of each stored <italic toggle="yes">k</italic>-mer is explicitly represented and thus is not space-efficient. Adding abundance information in an AMQ at fixed memory usage increases its false positive rate. For example, BIGSI (<xref rid="btad305-B5" ref-type="bibr">Bradley et al. 2019</xref>) relies on Bloom filters with a high false positive rate, e.g. 25% false positive rate per <italic toggle="yes">k</italic>-mer query. At constant memory usage, adding the information of abundance using, e.g. five bits per cell would yield an extremely high false positive rate that could reach up to 70%, which is not tolerable.</p>
      </list-item>
    </list>
    <p>In this paper, we propose a wrapper to improve any existing counting AMQ. The method we introduce is called <monospace>fimpera</monospace>. It generalises a previous contribution called <monospace>findere</monospace> (<xref rid="btad305-B20" ref-type="bibr">Robidou and Peterlongo 2021</xref>). In short, <monospace>fimpera</monospace> splits every <italic toggle="yes">k</italic>-mer into <italic toggle="yes">s</italic>-mers (with <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mi>s</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>) and then associates the abundance of a <italic toggle="yes">k</italic>-mer with its constituent <italic toggle="yes">s</italic>-mers in a counting AMQ. This allows us to retrieve the abundance of a <italic toggle="yes">k</italic>-mer at query time via its <italic toggle="yes">s</italic>-mers count. We show that, when compared to the original counting AMQ indexing of kmers, <monospace>fimpera</monospace> improves abundance correctness while lowering the false positive rate by an order of magnitude without generating false-negative calls or underestimating the abundance of a kmer and without requiring additional time for query execution. Alternatively, for a fixed false positive rate value, the <monospace>fimpera</monospace> strategy allows reducing the size of the <monospace>cAMQ</monospace> by two orders of magnitude.</p>
    <p>The <monospace>fimpera</monospace> algorithm can be used on top of any query made using any kind of counting AMQ. However, our implementation and tests are proposed on top of a counting Bloom Filter (<monospace>cBF</monospace>) that uses a unique hash function. This choice is motivated by the fact that <monospace>cBFs</monospace> are the simplest and are widespread data structures for dealing with billions of elements, and by the fact that state-of-the-art indexing tools based on counting AMQ [Cobs (<xref rid="btad305-B3" ref-type="bibr">Bingmann et al. 2019</xref>), HowDeSBT (<xref rid="btad305-B10" ref-type="bibr">Harris and Medvedev 2020</xref>)] impose the usage of a unique hash function.</p>
    <p>Additionally, the <monospace>fimpera</monospace> algorithmic needs led us to propose a novel algorithm for computing the sliding window minima (resp. maxima): the minimal (resp. maximums) values of all sub-arrays of a fixed size over an array of <italic toggle="yes">x</italic> values. This algorithm runs in <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and requires no dynamic memory allocation. This contribution may be useful outside the <monospace>fimpera</monospace> context. Its novelty is that being in place, it uses no additional memory, while other approaches use memory, i.e. linear with the size of the intervals. This makes it the fastest known algorithm to perform this task. It is available at <ext-link xlink:href="https://github.com/lrobidou/sliding-minimum-windows" ext-link-type="uri">https://github.com/lrobidou/sliding-minimum-windows</ext-link> along with a benchmark comparing it to other solutions.</p>
    <p>The <monospace>fimpera</monospace> contribution is publicly available at <ext-link xlink:href="https://github.com/lrobidou/fimpera" ext-link-type="uri">https://github.com/lrobidou/fimpera</ext-link>.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Background</title>
      <p>A <italic toggle="yes">k</italic>-mer is a word of length <italic toggle="yes">k</italic> over an alphabet Σ. Given a sequence <italic toggle="yes">S</italic>, <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> denotes the length of <italic toggle="yes">S</italic>. In the current framework, we consider a dataset to be composed of a multiset of sequences. Given a dataset <italic toggle="yes">D</italic>, <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denotes the multiset of <italic toggle="yes">k</italic>-mers extracted from <italic toggle="yes">D</italic>.</p>
      <p>The abundance of a <italic toggle="yes">k</italic>-mer <italic toggle="yes">d</italic> (the number of times <italic toggle="yes">d</italic> appears) in <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is represented by <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mtext>abundance</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We consider that a <italic toggle="yes">k</italic>-mer is “present” in <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:math></inline-formula> if <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mtext>abundance</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, else (<inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mtext>abundance</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>) the <italic toggle="yes">k</italic>-mer is “absent”.</p>
      <p>A counting AMQ data structure represents a multiset of elements <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. It can be queried with any element <italic toggle="yes">d</italic>; the query’s response on a counting AMQ, denoted by <italic toggle="yes">n</italic>, is always either correct or overestimated, i.e. <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>≥</mml:mo><mml:mtext>abundance</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. If <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mtext>abundance</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the counting AMQ reports the correct abundance, otherwise it reports an overestimation. Note that underestimation is not possible.</p>
      <p>In particular, if <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mtext>abundance</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">n </italic>&gt;<italic toggle="yes"> </italic>0, then <italic toggle="yes">d</italic> is found in the counting AMQ even if it is absent from <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:math></inline-formula>. This particular case is a false positive call. The false positive rate of a counting AMQ, denoted by FPR<sub>cAMQ</sub>, is defined by <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>FPR</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>cAMQ</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>#</mml:mo><mml:mtext>FP</mml:mtext></mml:mrow><mml:mrow><mml:mo>#</mml:mo><mml:mtext>FP</mml:mtext><mml:mo> </mml:mo><mml:mo>+</mml:mo><mml:mo> </mml:mo><mml:mo>#</mml:mo><mml:mtext>TN</mml:mtext></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> with #FP and #TN denoting respectively the number of false positive calls and the number of true negative calls (<italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>0). FPR<sub>cAMQ</sub> depends on the used counting AMQ strategy and on the amount of space used by this counting AMQ.</p>
      <p>There exist several models and implementations of counting AMQ. The simplest being the counting Bloom Filter (<xref rid="btad305-B9" ref-type="bibr">Fan et al. 2000</xref>) (<monospace>cBF</monospace> for short) using a unique hash function, of which a toy example is given in <xref rid="btad305-F1" ref-type="fig">Fig. 1</xref>. In a <monospace>cBF</monospace>, each element is hashed to get a position in a bit vector, at which position its abundance is stored. This requires a few bits per entry for storing this abundance. Collisions are allowed: should a collision occur, the abundance stored is the maximum of the colliding elements. This leads to a non-null probability of overestimation. A <monospace>cBF</monospace> is a generalisation of Bloom filters, in which each element is allocated only one bit, recording its presence/absence. Hence, a <monospace>cBF</monospace> requires more memory than a Bloom filter to achieve the same false positive rate. Equivalently, a <monospace>cBF</monospace> has a higher false positive rate than a simple Bloom filter with constant memory.</p>
      <fig position="float" id="btad305-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Toy example of a counting Bloom Filter using a unique hash function, with <italic toggle="yes">k</italic>-mers of length <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>5, and <italic toggle="yes">b </italic>=<italic toggle="yes"> </italic>4 bits per element. <italic toggle="yes">Top, indexing</italic>: each indexed element (<italic toggle="yes">k</italic>-mer) is hashed to a slot, and its abundance is stored in that slot. <italic toggle="yes">Bottom, querying</italic>: queried elements are hashed, and the value of the corresponding slot is returned. Three situations may occur: <bold>1/</bold>true positive (e.g. “ACTGA”), <bold>2/</bold>false positive (e.g. “CTGAC”) or <bold>3/</bold>true negative (“TGACA”). A true positive is always either correct or overestimated (in case of a hash collision between two elements with different abundances).</p>
        </caption>
        <graphic xlink:href="btad305f1" position="float"/>
      </fig>
      <p>It should be noted that other <monospace>cAMQ</monospace> exist, such as the counting quotient filters (<xref rid="btad305-B15" ref-type="bibr">Pandey et al. 2017</xref>). Despite the fact that the method we propose is applicable to any <monospace>cAMQ</monospace>, the description presented here, as well as the associated implemented tool, are based on the counting Bloom Filter using a unique hash function.</p>
    </sec>
    <sec>
      <title>2.2 Overview of <monospace>fimpera</monospace></title>
      <sec>
        <title>2.2.1 Core principle</title>
        <p><monospace>fimpera’</monospace>s objectives are to reduce FPR<sub>cAMQ</sub> and to improve the precision of the reported abundance of true positive calls. This is achieved using a method based on splitting <italic toggle="yes">k</italic>-mers into smaller words called <italic toggle="yes">s</italic>-mers. The <italic toggle="yes">s</italic>-mers are the elements indexed in the counting AMQ at indexation time. At query time, a <italic toggle="yes">k</italic>-mer is reported as found if and only if every one of its <italic toggle="yes">s</italic>-mers is found in the counting AMQ. Thus, a false positive (resp. overestimation) on a <italic toggle="yes">k</italic>-mer requires <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> false positives (resp. overestimations) on its <italic toggle="yes">s</italic>-mers.</p>
        <p>Alternatively, for a fixed FPR<sub>cAMQ</sub>, the <monospace>fimpera</monospace> strategy reduces the memory needed by the <monospace>cAMQ</monospace> up to several orders of magnitudes.</p>
        <p>Splitting <italic toggle="yes">k</italic>-mers into <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>-mers and associating each <italic toggle="yes">s</italic>-mer with a hash value as done in <monospace>fimpera</monospace> may be seen as a similar strategy as using <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mi>z</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> hash functions per <italic toggle="yes">k</italic>-mer with a bloom filter. There are three obvious observations to be made here:</p>
        <list list-type="bullet">
          <list-item>
            <p>Canonical indexing methods such as HowDeSBT (<xref rid="btad305-B10" ref-type="bibr">Harris and Medvedev 2020</xref>) or Cobs (<xref rid="btad305-B3" ref-type="bibr">Bingmann et al. 2019</xref>) for instance rely on bloom filters using a unique hash function. These state-of-the-art approaches can thus directly benefit from our proposal, with no modification.</p>
          </list-item>
          <list-item>
            <p>Indexing and query time grow linearly with the number of independent hash functions used, while <monospace>fimpera</monospace> takes advantage of the <italic toggle="yes">s</italic>-mers shared between consecutive <italic toggle="yes">k</italic>-mers. Even if it is not restricted to this framework, <monospace>fimpera</monospace> is meant for querying streams of <italic toggle="yes">k</italic>-mers. In this situation, when streaming all successive <italic toggle="yes">k</italic>-mers from a sequence, a <italic toggle="yes">k</italic>-mer shares <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi><mml:mo> </mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>-mers with its predecessor. Only one unique new <italic toggle="yes">s</italic>-mer has to be inserted or queried for all <italic toggle="yes">k</italic>-mers except the first one. Thus, with fimpera, the computation time does not grow with the <italic toggle="yes">z</italic> value. Notably, as shown in <xref rid="btad305-T2" ref-type="table">Table 2</xref>, it even slightly decreases at query time, as once a <italic toggle="yes">s</italic>-mer is detected as absent, all <italic toggle="yes">k</italic>-mers that span this <italic toggle="yes">s</italic>-mer can be skipped.</p>
          </list-item>
          <list-item>
            <p>Regarding the effect on memory, in a Bloom filter with <italic toggle="yes">H</italic> &gt; 1 distinct hash functions, the <italic toggle="yes">H</italic> value is limited to an optimal as using too many hash functions saturates the filter load factor, leading either to an increase of the false positive rate or to the need of increasing the filter size. This is not the case when using the <monospace>fimpera</monospace> approach.</p>
          </list-item>
        </list>
        <table-wrap position="float" id="btad305-T1">
          <label>Table 1.</label>
          <caption>
            <p>Computation example of the <italic toggle="yes">r</italic> vector, with a window of size 3.<xref rid="tblfn2" ref-type="table-fn"><sup>a</sup></xref></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">
                  <italic toggle="yes">i</italic>
                </td>
                <td rowspan="1" colspan="1">0</td>
                <td rowspan="1" colspan="1">1</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1">3</td>
                <td rowspan="1" colspan="1">4</td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">6</td>
                <td rowspan="1" colspan="1">7</td>
                <td rowspan="1" colspan="1">8</td>
                <td rowspan="1" colspan="1">9</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <italic toggle="yes">v</italic>
                </td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">3</td>
                <td rowspan="1" colspan="1">7</td>
                <td rowspan="1" colspan="1">1</td>
                <td rowspan="1" colspan="1">4</td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">3</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1">3</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <italic toggle="yes">j</italic>
                </td>
                <td rowspan="1" colspan="1">0</td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">1</td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">3</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <inline-formula id="IE47">
                    <mml:math id="IM47" display="inline" overflow="scroll">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mtext>min</mml:mtext>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mi>L</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:math>
                  </inline-formula>
                </td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">3</td>
                <td rowspan="1" colspan="1">3</td>
                <td rowspan="1" colspan="1">
                  <underline>1</underline>
                </td>
                <td rowspan="1" colspan="1">1</td>
                <td rowspan="1" colspan="1">1</td>
                <td rowspan="1" colspan="1">3</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1">3</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <inline-formula id="IE48">
                    <mml:math id="IM48" display="inline" overflow="scroll">
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mtext>min</mml:mtext>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mi>R</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:math>
                  </inline-formula>
                </td>
                <td rowspan="1" colspan="1">3</td>
                <td rowspan="1" colspan="1">
                  <underline>3</underline>
                </td>
                <td rowspan="1" colspan="1">7</td>
                <td rowspan="1" colspan="1">1</td>
                <td rowspan="1" colspan="1">4</td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1">3</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <inline-formula id="IE49">
                    <mml:math id="IM49" display="inline" overflow="scroll">
                      <mml:mi>r</mml:mi>
                    </mml:math>
                  </inline-formula>
                </td>
                <td rowspan="1" colspan="1">3</td>
                <td rowspan="1" colspan="1">
                  <bold>
                    <underline>1</underline>
                  </bold>
                </td>
                <td rowspan="1" colspan="1">1</td>
                <td rowspan="1" colspan="1">1</td>
                <td rowspan="1" colspan="1">3</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1">2</td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1"/>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn1">
              <label>a</label>
              <p>Tables min<sub><italic toggle="yes">L</italic></sub> and min<sub><italic toggle="yes">R</italic></sub> are represented for helping comprehension but are not implicitly created in practice. The <italic toggle="yes">j</italic> row indicates the starting positions of each fixed windows. As an example, the minimal value of the sliding window of size 3 starting position <italic toggle="yes">i </italic>=<italic toggle="yes"> </italic>1 is <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> (bold underlined value), being equal to <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>L</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (underlined values).</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <table-wrap position="float" id="btad305-T2">
          <label>Table 2.</label>
          <caption>
            <p>Influence of the <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mi>z</mml:mi></mml:math></inline-formula> parameter on the quality of the results and on the computation time when indexing and querying 31-mers through their <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mi>s</mml:mi></mml:math></inline-formula>-mers.<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
              <col valign="top" align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1">z</th>
                <th rowspan="1" colspan="1">0</th>
                <th rowspan="1" colspan="1">3</th>
                <th rowspan="1" colspan="1">5</th>
                <th rowspan="1" colspan="1">7</th>
                <th rowspan="1" colspan="1">9</th>
                <th rowspan="1" colspan="1">20</th>
              </tr>
              <tr>
                <th rowspan="1" colspan="1">(indexed <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mi>s</mml:mi></mml:math></inline-formula>-mer size <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>31</mml:mn><mml:mo>−</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>)</th>
                <th rowspan="1" colspan="1">31</th>
                <th rowspan="1" colspan="1">28</th>
                <th rowspan="1" colspan="1">26</th>
                <th rowspan="1" colspan="1">24</th>
                <th rowspan="1" colspan="1">22</th>
                <th rowspan="1" colspan="1">11</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">False positive rate (%)</td>
                <td rowspan="1" colspan="1">25.00</td>
                <td rowspan="1" colspan="1">0.56</td>
                <td rowspan="1" colspan="1">0.08</td>
                <td rowspan="1" colspan="1">0.02</td>
                <td rowspan="1" colspan="1">0.03</td>
                <td rowspan="1" colspan="1">99.70</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"> Of which: construction FP (%)</td>
                <td rowspan="1" colspan="1">0</td>
                <td rowspan="1" colspan="1">0.49</td>
                <td rowspan="1" colspan="1">9.64</td>
                <td rowspan="1" colspan="1">46.32</td>
                <td rowspan="1" colspan="1">67.26</td>
                <td rowspan="1" colspan="1">99.99</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Incorrect abundance calls (%)</td>
                <td rowspan="1" colspan="1">1.55</td>
                <td rowspan="1" colspan="1">1.33</td>
                <td rowspan="1" colspan="1">1.93</td>
                <td rowspan="1" colspan="1">2.99</td>
                <td rowspan="1" colspan="1">4.27</td>
                <td rowspan="1" colspan="1">42.73</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"> Of which: constr. overest. (%)</td>
                <td rowspan="1" colspan="1">0</td>
                <td rowspan="1" colspan="1">83.02</td>
                <td rowspan="1" colspan="1">88.65</td>
                <td rowspan="1" colspan="1">94.24</td>
                <td rowspan="1" colspan="1">94.34</td>
                <td rowspan="1" colspan="1">99.85</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Query time (s)</td>
                <td rowspan="1" colspan="1">557</td>
                <td rowspan="1" colspan="1">514</td>
                <td rowspan="1" colspan="1">498</td>
                <td rowspan="1" colspan="1">491</td>
                <td rowspan="1" colspan="1">493</td>
                <td rowspan="1" colspan="1">528</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn2">
              <label>a</label>
              <p>“<italic toggle="yes">constr.</italic>” stands for “<italic toggle="yes">construction</italic>” and “<italic toggle="yes">overest.</italic>” stands for “<italic toggle="yes">overestimation</italic>”. Results with <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> are equivalent to those obtained with the original <monospace>cBF</monospace> results. The Incorrect abundance calls are computed over true positive calls only.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec>
        <title>2.2.2 Indexation overview</title>
        <p>At indexation time, <monospace>fimpera</monospace> takes as input a file of counted <italic toggle="yes">k</italic>-mers, as provided for instance by KMC (<xref rid="btad305-B11" ref-type="bibr">Kokot et al. 2017</xref>). <monospace>fimpera</monospace> splits each <italic toggle="yes">k</italic>-mer into its <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> constituent <italic toggle="yes">s</italic>-mers (<inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>). Each <italic toggle="yes">s</italic>-mer is then stored in a <monospace>cAMQ</monospace> along with its s-abundance, denoted as <italic toggle="yes">s</italic><sub>ab</sub>. The <italic toggle="yes">s</italic><sub>ab</sub> of a <italic toggle="yes">s</italic>-mer is formally defined as the maximum of the abundance of the <italic toggle="yes">k</italic>-mers containing this <italic toggle="yes">s</italic>-mer. We explain the choice on relying on <italic toggle="yes">s</italic><sub>ab</sub> instead of the abundance of <italic toggle="yes">s</italic>-mers and describe its outcomes in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S3.3</xref>. Using both the <italic toggle="yes">s</italic><sub>ab</sub> and the abundance of <italic toggle="yes">s</italic>-mers is supported in the implementation.</p>
        <p>In the following, we set <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>, hence <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <title>2.2.3 Query overview</title>
        <p>For each queried sequence <italic toggle="yes">S</italic>, <monospace>fimpera</monospace> extracts its sequence of <italic toggle="yes">s</italic>-mers, which is then queried against the <monospace>cAMQ</monospace>, and the abundance of any <italic toggle="yes">k</italic>-mer of <italic toggle="yes">S</italic> is computed as the minimum of <italic toggle="yes">s</italic><sub>ab</sub> of its <italic toggle="yes">s</italic>-mers. By default, <monospace>fimpera</monospace> prints each input sequence along with the abundance of every of its consecutive <italic toggle="yes">k</italic>-mer. In practice, the input query file is a fasta or a fastq file, possibly gzipped.</p>
      </sec>
      <sec>
        <title>2.2.4 False positive calls</title>
        <p>Let’s consider a <italic toggle="yes">k</italic>-mer <italic toggle="yes">d</italic> with an abundance of 0 and each of its <italic toggle="yes">s</italic>-mer has an <italic toggle="yes">s</italic><sub>ab</sub> of 0 as well. With <monospace>fimpera</monospace>, wrongly reporting <italic toggle="yes">d</italic> as present requires that <italic toggle="yes">every s</italic>-mer of that <italic toggle="yes">k</italic>-mer are wrongly found as present in the counting AMQ. The probability of such an event is approximately <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>F</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>PR</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>cAMQ</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>z</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, leading to a dramatic decrease in the occurrences of false positive calls with respect to <italic toggle="yes">z</italic>. For instance, with <italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>3 (which is a recommended and the default value) and a counting AMQ having a false positive rate of 25%, the false positive rate with <monospace>fimpera</monospace> for that setting is <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>0.4</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>The <monospace>fimpera</monospace> approach may generate a novel kind of false positive. A queried <italic toggle="yes">k</italic>-mer, absent from the indexed dataset, may be composed of <italic toggle="yes">s</italic>-mers existing in this indexed set. Querying such a <italic toggle="yes">k</italic>-mer with <monospace>fimpera</monospace> returns a non-zero abundance, so generating a false positive, which we call a “construction false positive”. These false positives are created by <monospace>fimpera</monospace>, <italic toggle="yes">independently of the underlying <monospace>cAMQ</monospace></italic>. This event is non-null but it is in practice negligible when using usual <italic toggle="yes">k</italic> and <italic toggle="yes">z</italic> values, as shown in the results.</p>
      </sec>
      <sec>
        <title>2.2.5 Overestimations</title>
        <p>To overestimate the abundance of a queried <italic toggle="yes">k</italic>-mer with <monospace>fimpera</monospace>, overestimations are required to happen on the abundance of <bold>every</bold> <italic toggle="yes">s</italic>-mer of that <italic toggle="yes">k</italic>-mer that has the minimal <italic toggle="yes">s</italic><sub>ab</sub>. The more <italic toggle="yes">s</italic>-mer per <italic toggle="yes">k</italic>-mer, the more <italic toggle="yes">s</italic>-mer abundance overestimations need to happen to overestimate a <italic toggle="yes">k</italic>-mer abundance. <italic toggle="yes">s</italic>-mer abundance overestimations can come from two sources:</p>
        <list list-type="bullet">
          <list-item>
            <p>a collision occurs in the counting Bloom Filter, leading to the overestimation of the less abundant colliding <italic toggle="yes">s</italic>-mer; and/or:</p>
          </list-item>
          <list-item>
            <p>a <italic toggle="yes">s</italic>-mer is shared among two different <italic toggle="yes">k</italic>-mers having different abundances. This overestimates the abundance of this <italic toggle="yes">s</italic>-mer from the least abundant <italic toggle="yes">k</italic>-mer. This happens no matter the false positive rate of the counting Bloom Filter. We call those overestimations “construction overestimation”. This new kind of overestimation is specific to <monospace>fimpera</monospace>.</p>
          </list-item>
        </list>
        <p>Observe a case of interest: consider two <italic toggle="yes">k</italic>-mers <italic toggle="yes">d</italic><sub>0</sub> and <italic toggle="yes">d</italic><sub>1</sub> overlapping over <italic toggle="yes">k –</italic> 1 characters. If <italic toggle="yes">d</italic><sub>1</sub> has an abundance greater than <italic toggle="yes">d</italic><sub>0</sub>, then the correct abundance of <italic toggle="yes">d</italic><sub>0</sub> is retrievable through a unique <italic toggle="yes">s</italic>-mer (the unique <italic toggle="yes">s</italic>-mer of <italic toggle="yes">d</italic><sub>0</sub> that does not appear in the <italic toggle="yes">k</italic>-mer <italic toggle="yes">d</italic><sub>1</sub>). In such case, <italic toggle="yes">d</italic><sub>0</sub> is more likely to be overestimated than <italic toggle="yes">d</italic><sub>1</sub>.</p>
        <p>Consequently, <monospace>fimpera’</monospace>s overestimations are not uniformly distributed random events. Overestimations are more likely to occur close to a change in abundance along queried sequences than in a random <italic toggle="yes">k</italic>-mer. In such cases, those overestimations are limited to the abundance of their neighbor <italic toggle="yes">k</italic>-mers, mitigating their impact. Indeed, in the result section (Section 3), we show that the erroneous abundance calls are closer to the ground truth with <monospace>fimpera</monospace> compared to those obtained with the original <monospace>cBF</monospace>.</p>
        <p>We now describe in more detail both the indexing step and the querying step of <monospace>fimpera</monospace>, as well as one optimisation, allowing a query time independent from the <italic toggle="yes">z</italic> value.</p>
        <p>Another optimisation enables <monospace>fimpera</monospace> to perform queries slightly faster than using the original underlying <monospace>cAMQ</monospace>. This optimisation is described in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S2.2</xref>.</p>
      </sec>
    </sec>
    <sec>
      <title>2.3 Querying with <monospace>fimpera</monospace></title>
      <p><monospace>fimpera’</monospace>s query consists in querying all consecutive, overlapping <italic toggle="yes">k</italic>-mers from a sequence of size greater than or equal to <italic toggle="yes">k</italic> through their constituent <italic toggle="yes">s</italic>-mers. <monospace>fimpera’</monospace>s query is a two-step process:</p>
      <list list-type="bullet">
        <list-item>
          <p>for every position in the query except the last <italic toggle="yes">s—</italic>1 ones, <italic toggle="yes">s</italic>-mers starting at these positions are queried in the counting AMQ and are stored in an array of integers <italic toggle="yes">s</italic><sub>ab</sub>;</p>
        </list-item>
        <list-item>
          <p>the abundance of any <italic toggle="yes">k</italic>-mer starting position <italic toggle="yes">p</italic> is the minimum value of the sub-array of length (<italic toggle="yes">z</italic> + 1) starting at the position <italic toggle="yes">p</italic>: <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mtext>ab</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo>;</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
      </list>
      <p>A non-optimised version of the <monospace>fimpera’</monospace>s query algorithm is shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>.</p>
      <p>The first step is improved by avoiding recomputing the minimal value of windows of length <italic toggle="yes">z </italic>+<italic toggle="yes"> </italic>1 starting at each position <italic toggle="yes">p</italic> of an array. This optimisation is described in the following section.</p>
    </sec>
    <sec>
      <title>2.4 Optimisation: sliding window minimum algorithm</title>
      <p>The problem, independent of <monospace>fimpera</monospace>, is as follows: given a vector of values (integers or floats) <italic toggle="yes">v</italic> and an integer <italic toggle="yes">W</italic> (denoting the size of a sliding window, with <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>W</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi>v</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, give an array <italic toggle="yes">r</italic> such that <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mi>v</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mi>W</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mtext>min</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>W</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This is a particular case of a more general problem, the “range minimum query” (RMQ). Given a vector <italic toggle="yes">v</italic> of element drawn from a totally ordered set and two integers <italic toggle="yes">i</italic>, <italic toggle="yes">j</italic> (<inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mo>|</mml:mo><mml:mi>v</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>), the RMQ consists in finding <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mtext>min</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Answering RMQ generally relies on some pre-computation beforehand [e.g. pre-computing the whole set of possible queries, but less resource-intensive solutions can be found, such as <xref rid="btad305-B8" ref-type="bibr">Durocher and Singh (2019)</xref>].</p>
      <p>The sliding window minimum problem studied here is a particular case of an RMQ (<italic toggle="yes">j – i</italic> is fixed and queries consist in every window of that size). Thus, its solutions do not require taking into account other window sizes, effectively allowing to skip pre-computation. The naive approach to solving the sliding minimum problem is to simply search for the minimal value in each window. This algorithm is in <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>W</mml:mi><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mi>v</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. Some straightforward faster solutions can be built on top of dynamic heaps. Here, we propose a solution (named “fixed window”) that does not rely on any heap allocation (which is slow for most systems). This solution without any dynamic memory allocation is an order of magnitude faster than other <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>v</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> solutions as shown <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S3.1</xref> in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Materials</xref>.</p>
      <p>The main idea of the proposed “fixed window” approach is to split the input vector of values in fixed, non-overlapping windows of size <italic toggle="yes">W</italic>. Then, for each so-called “fixed window”, compute two vectors:</p>
      <list list-type="bullet">
        <list-item>
          <p><inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>L</mml:mi></mml:msub><mml:mo>_</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>: <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>L</mml:mi></mml:msub><mml:mo>_</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>%</mml:mo><mml:mi>W</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> contains the minimum value encountered in the <italic toggle="yes">j</italic>th fixed window up to the position <italic toggle="yes">i</italic>;(<inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>×</mml:mo><mml:mi>W</mml:mi><mml:mo>×</mml:mo><mml:mi>j</mml:mi><mml:mo>;</mml:mo><mml:mi>i</mml:mi><mml:mo>×</mml:mo><mml:mi>W</mml:mi><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
        </list-item>
        <list-item>
          <p><inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>R</mml:mi></mml:msub><mml:mo>_</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>: <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>R</mml:mi></mml:msub><mml:mo>_</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>%</mml:mo><mml:mi>W</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> contains the minimum value from the position <italic toggle="yes">i</italic> up to the end of the <italic toggle="yes">j</italic>th fixed window.</p>
        </list-item>
      </list>
      <p>All <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>L</mml:mi></mml:msub><mml:mo>_</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>R</mml:mi></mml:msub><mml:mo>_</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> vectors are then concatenated into two vectors (min<sub><italic toggle="yes">L</italic></sub> and min<sub><italic toggle="yes">R</italic></sub>). The minimum of a <italic toggle="yes">sliding</italic> window starting at position <italic toggle="yes">i</italic>, denoted by <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, is thereupon the minimum between:</p>
      <list list-type="bullet">
        <list-item>
          <p><inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>L</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>W</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (the minimum of the left part of the next fixed window)</p>
        </list-item>
        <list-item>
          <p><inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (the minimum of the right part of the current fixed window)</p>
        </list-item>
      </list>
      <p>An example is provided in <xref rid="btad305-T1" ref-type="table">Table 1</xref>.</p>
      <p>Note that, as described previously, this approach would require allocating memory for two vectors per call. This memory need may appear negligible in theory as those vectors are limited by the query size which is a few hundred to few thousand. However, in practice, allocating memory for these vectors is time-consuming, and may increase significantly the practical running time. We overcame this memory need thanks to these three following tricks. <bold>1/</bold>we compute <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>L</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> on the fly (if <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>%</mml:mo><mml:mi>W</mml:mi><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> then <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>L</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mtext>min</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>L</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, else <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>L</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>). <bold>2/</bold>min<sub><italic toggle="yes">R</italic></sub> is computed <italic toggle="yes">directly in the queried vector</italic>. This does not impact the correctness of the algorithm, as <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. <bold>3/</bold>the response (minimal value per sliding window) can be stored directly in the input queried vector as well. At the price of modifying the input vector, this allows the algorithm to be run in <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mtext>size</mml:mtext><mml:mo>_</mml:mo><mml:mtext>query</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time while avoiding any time-consuming heap allocation.</p>
      <p>A complete description of the optimised solution is provided in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S2.1</xref>, <xref rid="sup1" ref-type="supplementary-material">Supplementary Algorithm S2</xref>, along with a benchmark <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S3.1</xref>, <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref>.</p>
      <p>This algorithm offers a generic solution for computing the minimal value of a sliding window in constant memory and linear time. Its usefulness is not limited to <monospace>fimpera</monospace>. As so, we propose an independent implementation <ext-link xlink:href="https://github.com/lrobidou/sliding-minimum-windows" ext-link-type="uri">https://github.com/lrobidou/sliding-minimum-windows</ext-link>. Note also that it can be straightforwardly modified for computing the maximal value instead of the minimal value of each window.</p>
    </sec>
    <sec>
      <title>2.5 Implementation of <monospace>fimpera</monospace></title>
      <p>An implementation of <monospace>fimpera</monospace> is available at <ext-link xlink:href="https://github.com/lrobidou/fimpera" ext-link-type="uri">https://github.com/lrobidou/fimpera</ext-link>. This implementation is specialised for genomic data (i.e. with an alphabet consisting of A, T, C, G) and uses a counting Bloom Filter with a unique hash function as <monospace>cAMQ</monospace>. A template mechanism allows the use of any other <monospace>cAMQ</monospace> provided by the user. Queries consist of fasta or fastq files (gzipped or not), and an option is provided to index and query canonical <italic toggle="yes">k</italic>-mers only, i.e. the lexicographic minimum between each <italic toggle="yes">k</italic>-mer and its reverse complements. Indexing options include the <italic toggle="yes">k</italic> and <italic toggle="yes">z</italic> values, the size of the filter, and <italic toggle="yes">b</italic>, the number of bits per element used to store its abundance. As <italic toggle="yes">b</italic> has a major impact on the final size of the data structure, it is recommended to use low <italic toggle="yes">b</italic> values (say <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>≤</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>). This limits the maximal stored abundance value to <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mi>b</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> (to prevent overflow, the abundance is capped at <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mi>b</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>).</p>
      <p>In order to encode large abundance values with few bits per <italic toggle="yes">k</italic>-mer, instead of storing the first possible <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mi>b</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> distinct abundance values, we propose to discretize any abundance value to user-defined interval ranges. In practice, <monospace>fimpera</monospace> can use any surjective function
</p>
      <disp-formula id="E1">
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>f</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>x</mml:mi>
            <mml:mo>∈</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mn>1</mml:mn>
            <mml:mo>,</mml:mo>
            <mml:mo>∞</mml:mo>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>→</mml:mo>
            <mml:mi>y</mml:mi>
            <mml:mo>∈</mml:mo>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mn>0</mml:mn>
            <mml:mo>,</mml:mo>
            <mml:msup>
              <mml:mrow>
                <mml:mn>2</mml:mn>
              </mml:mrow>
              <mml:mi>b</mml:mi>
            </mml:msup>
            <mml:mo>−</mml:mo>
            <mml:mn>1</mml:mn>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>supplied by the user. This can be for instance any intervals. The proposed implementation proposes the usage of <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mi>b</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, or <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mi>b</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Changing the default output (e.g. storing results instead of printing them, computing average abundance per sequence, or printing only sequences whose average <italic toggle="yes">k</italic>-mer abundances is above a user-defined threshold) is possible.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Experimental setup</title>
      <p>To the best of our knowledge, no other tool focuses on reducing the false positive rate of existing <monospace>cAMQ</monospace>, thus we compare <monospace>fimpera</monospace> results applied on a counting Bloom Filter indexing <italic toggle="yes">s</italic>-mers with the original counting Bloom Filter results indexing <italic toggle="yes">k</italic>-mers using a unique hash function. We propose results on biological marine metagenomic data.</p>
      <p>A list of commands for reproducing the results is available here: <ext-link xlink:href="https://github.com/lrobidou/fimpera/blob/paper/paper\_companion/Readme.md" ext-link-type="uri">https://github.com/lrobidou/fimpera/blob/paper/paper\_companion/Readme.md</ext-link> along with a step-by-step explanation of the output. Executions were performed on the GenOuest platform on a node with 4x8cores Xeon E5-2660 2.20 GHz with 200 GB of memory.</p>
    </sec>
    <sec>
      <title>3.2 Metagenomic dataset</title>
      <p>We used two fastq files from the TARA ocean metagenomic dataset (<xref rid="btad305-B24" ref-type="bibr">Sunagawa et al. 2020</xref>) to show the advantages offered by <monospace>fimpera</monospace> on metagenomic samples. The index was computed from the <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.38</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> distinct 31-mers present at least twice in an arctic station (accession number ERR1726642) and the query sample was the first <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> reads from a sample in another arctic station (accession number ERR4691696). Canonical <italic toggle="yes">k</italic>-mers were considered for this experiment.</p>
    </sec>
    <sec>
      <title>3.3 Choice of filters parameters</title>
      <p>In this experiment, we apply the <monospace>fimpera</monospace> approach on top of a counting Bloom Filter designed to have 25% of false positive calls, while using 5 bits per element for storing the abundance of indexed <italic toggle="yes">k</italic>-mers. For indexing <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.38</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>8</mml:mn></mml:msup><mml:mo> </mml:mo><mml:mn>31</mml:mn></mml:mrow></mml:math></inline-formula>-mers this structure requires <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mn>6.96</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> slots (thus <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mn>3.48</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>9</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> bits).</p>
      <p>We compare the results of queries made against this raw counting Bloom Filter with the results of queries made using <monospace>fimpera</monospace> wrapping that same counting Bloom Filter.</p>
      <p>Thus, parameters used are as follow: <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>31, size of the filter of <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mn>3.48</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>9</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> bits, as discussed in Section 3.3, using <italic toggle="yes">b </italic>=<italic toggle="yes"> </italic>5 bits per abundance count (thus <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> slots), and abundances are stored as their <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> values. We use the default <italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>3 parameter (unless otherwise stated). As we use <italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>3, we compare the results of a <monospace>cBF</monospace> indexing 31-mers, with results of <monospace>fimpera</monospace> used on a <monospace>cBF</monospace> with the same sizing, but indexing <italic toggle="yes">s</italic>-mers of size 28 (31-3).</p>
    </sec>
    <sec>
      <title>3.4 Used metrics</title>
      <p>To measure the quality of the <monospace>fimpera</monospace> results and the <monospace>cBF</monospace> results, we propose three metrics:</p>
      <list list-type="bullet">
        <list-item>
          <p>the false positive rate, which provides the probability that the method returns an abundance call &gt; 0 for a <italic toggle="yes">k</italic>-mer absent from the indexed set.</p>
        </list-item>
        <list-item>
          <p>the proportion of incorrect abundance, that provides the probability that the method returns the incorrect abundance for a <italic toggle="yes">k</italic>-mer actually in the indexed set.</p>
        </list-item>
        <list-item>
          <p>statistics of responses for incorrect abundances calls, that estimate the reported abundance of <italic toggle="yes">k</italic>-mers whose abundance is incorrectly reported. When comparing any two approaches, we set up a metric that we call “overestimation score”. It is defined as the sum of the square of errors made on the output of each method. The lower the overestimation score is, the fewer errors were made. Errors that are closer to the ground truth are less penalised by this score than errors distant from it.</p>
        </list-item>
      </list>
    </sec>
    <sec>
      <title>3.5 False positive rate analyses</title>
      <p>Results about false positives obtained with the proposed experiment are shown in <xref rid="btad305-F2" ref-type="fig">Fig. 2</xref>. Results about the <monospace>cBF</monospace> simply confirm the setup and show a false positive rate of 25%. When applying <monospace>fimpera</monospace>, the false positive rate drops to <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.56</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>. Among all these <monospace>fimpera</monospace> false positives, 4.8% are due to the so-called “construction false positives” (see Section 2.2.3), thus representing 0.0027% of the total <italic toggle="yes">k</italic>-mer calls.</p>
      <fig position="float" id="btad305-F2">
        <label>Figure 2.</label>
        <caption>
          <p>Proportion of false positive calls without <monospace>fimpera</monospace> (on a classical counting Bloom Filter) and with <monospace>fimpera</monospace> (<italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>3), indexing and querying real metagenomic read datasets.</p>
        </caption>
        <graphic xlink:href="btad305f2" position="float"/>
      </fig>
      <p>It is important to recall that these comparative results were obtained using the exact same amount of space. Hence the <monospace>fimpera</monospace> approach enabled to yield about 45 times fewer false positive calls, with no drawback and even saving query time (see <xref rid="btad305-T2" ref-type="table">Table 2</xref>).</p>
    </sec>
    <sec>
      <title>3.6 Correctness of the reported abundances</title>
      <p>In this section, we focus only on true positive calls. Hence, these results do not concern the 25% false positive calls obtained with the original <monospace>cBF</monospace>, nor the 0.56% ones using <monospace>fimpera</monospace>.</p>
      <p>Results comparing the proportion of calls reported with an incorrect abundance among the true positives show that 1.54% of true-positive calls are overestimated in the <monospace>cBF</monospace>, while 1.33% of true-positive calls are overestimated with <monospace>fimpera</monospace>. Among the <monospace>fimpera</monospace> calls estimating an incorrect abundance among the true positives, 83% are due to the so-called “construction overestimation”.</p>
    </sec>
    <sec>
      <title>3.7 Distribution of errors in overestimated calls</title>
      <p>In this section, we focus only on the wrongly estimated calls among true positives.</p>
      <p>Results presented <xref rid="btad305-F3" ref-type="fig">Fig. 3</xref> show that, as stated in Section 2.2.5, the erroneous abundance calls are closer to the ground truth with <monospace>fimpera</monospace> compared to those obtained with the original <monospace>cBF</monospace>. As seen <xref rid="btad305-F3" ref-type="fig">Fig. 3</xref>-bottom, with <monospace>fimpera</monospace>, almost all (except for a few outliers) overestimations are only one value apart from the correct range (the average difference with the correct abundance range is 1.07). With the original <monospace>cBF</monospace>, as seen <xref rid="btad305-F3" ref-type="fig">Fig. 3</xref>-left, overestimations are more important (1.33 range in average from the ground truth).</p>
      <fig position="float" id="btad305-F3">
        <label>Figure 3.</label>
        <caption>
          <p>For true-positive calls with an incorrect abundance estimation: reported abundance with respect to the correct abundance. Top: using the original <monospace>cBF</monospace>, Bottom: using <monospace>fimpera</monospace>.</p>
        </caption>
        <graphic xlink:href="btad305f3" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.8 Influence of the size of the underlying <monospace>cAMQ</monospace></title>
      <p>Because there is a trade-off between space usage and the false positive rate of a <monospace>cAMQ</monospace>, <monospace>fimpera</monospace> can either reduce the false positive rate of the <monospace>cAMQ</monospace> without changing its size or reduce its size without changing its false positive rate. This section focuses on the impact of <monospace>fimpera</monospace> on this latter strategy.</p>
      <p>This trade-off (with and without <monospace>fimpera</monospace>) is shown <xref rid="btad305-F4" ref-type="fig">Figs 4</xref> and <xref rid="btad305-F5" ref-type="fig">5</xref>. To be as close as possible to real-life use-case, we consider in this section the average abundance of <italic toggle="yes">k</italic>-mer on each read, not the abundance of each <italic toggle="yes">k</italic>-mer. For precision requirement, abundances were not stored as their <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> values, but rather as their original values.</p>
      <fig position="float" id="btad305-F4">
        <label>Figure 4.</label>
        <caption>
          <p>Variation of the false positive rate with respect to the size of the <monospace>cBF</monospace>, with and without <monospace>fimpera</monospace> (<italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>3). As we consider here the average abundance of <italic toggle="yes">k</italic>-mers on each queried read, a false positive means that the average abundance of a <italic toggle="yes">k</italic>-mer on a read is strictly positive while it should have been 0.</p>
        </caption>
        <graphic xlink:href="btad305f4" position="float"/>
      </fig>
      <fig position="float" id="btad305-F5">
        <label>Figure 5.</label>
        <caption>
          <p>Sum of square error with respect to the size of the <monospace>cBF</monospace>, with and without <monospace>fimpera</monospace> (<italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>3). In this experiment, the output of <monospace>fimpera</monospace> is the <italic toggle="yes">average of each input read</italic>.</p>
        </caption>
        <graphic xlink:href="btad305f5" position="float"/>
      </fig>
      <p>With <monospace>fimpera</monospace>, achieving a false positive rate of 2% requires <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>2.98</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>9</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> bits (<inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>3.72</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> slots of 8 bits each) (see <xref rid="btad305-F4" ref-type="fig">Fig. 4</xref>). Without <monospace>fimpera</monospace>, achieving the same false positive rate requires <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>65.5</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>9</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> bits (21 times more space). The lower the false positive rate, the greater the space gap between using and not using <monospace>fimpera</monospace>. Achieving a false positive rate of 0.02% requires about <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mn>7.25</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>9</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> bits with <monospace>fimpera</monospace>, but <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mn>360</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>9</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> bits were not enough without <monospace>fimpera</monospace> (i.e. allocating more than 50 times the space budget of <monospace>fimpera</monospace> would be required). In order to take into account the abundance information, we set up the output of <monospace>fimpera</monospace> to be the average of <italic toggle="yes">k</italic>-mers’ abundance for each queried read.</p>
      <p><xref rid="btad305-F5" ref-type="fig">Figure 5</xref> shows the sum of square of overestimations, with and without <monospace>fimpera</monospace>. For an overestimation score (defined Section 3.4) of 200000, <monospace>fimpera</monospace> requires <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>3.10</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>9</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> bits (<inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>3.87</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> slots of 8 bits each), whereas a <monospace>cBF</monospace> would requires <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mn>330.9</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>9</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> bits (i.e. 100 times more space).</p>
      <sec>
        <title>3.8.1 Impact of <italic toggle="yes">z</italic></title>
        <p>As shown in <xref rid="btad305-T2" ref-type="table">Table 2</xref>, the false positive rate decreases with respect to <italic toggle="yes">z</italic> and stays low for a wide range of <italic toggle="yes">z</italic> values (at least from <italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>3 to <italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>9). When using an extreme <italic toggle="yes">z</italic> value, for instance, <italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>20, the false positive rate is increased up to almost 100%. With <italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>20, as we use <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>31, the size of the indexed <italic toggle="yes">s</italic>-mers is <italic toggle="yes">s </italic>=<italic toggle="yes"> </italic>11. When indexing as little as a few hundred million characters, each 11-mer has a great probability to appear by chance in the indexed dataset. Indeed, the probability of such event is <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>s</mml:mi></mml:msup></mml:mrow></mml:mfrac><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, with <italic toggle="yes">n</italic> being the number of characters. For instance, for <italic toggle="yes">s </italic>=<italic toggle="yes"> </italic>11 and a sequence as little as <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula>20 million characters, the probability of the presence of any 11-mer is &gt; 99%. This quasi-random existence of all <italic toggle="yes">s</italic>-mers generates a huge amount of construction false positives, as seen in the last column. This has an effect on the running time, which is close to the query time of <italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>0, undoubtedly because all <italic toggle="yes">s</italic>-mers queried are positives, annihilating the <italic toggle="yes">s</italic>-mer skipping optimisation.</p>
        <p>Caveat: in <xref rid="btad305-T2" ref-type="table">Table 2</xref>, the overestimations are reported only for true positive calls. Overall, also taking into account the negative answers, the overestimation rate with <monospace>fimpera</monospace> would be 0.03 with <italic toggle="yes">z </italic>=<italic toggle="yes"> </italic>3 for instance.</p>
        <p>In the <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S3.4</xref>, we show the impact of <italic toggle="yes">z</italic> in a different setup: choosing a fixed <italic toggle="yes">s</italic> and increasing <italic toggle="yes">k</italic> with regard to <italic toggle="yes">z</italic>, instead of fixing <italic toggle="yes">k</italic> and decreasing <italic toggle="yes">s</italic> with regard to <italic toggle="yes">z</italic>. This shows another framework for using <monospace>fimpera</monospace>, with similar conclusions about the quality of the results.</p>
      </sec>
      <sec>
        <title>3.8.2 Query time</title>
        <p>As mentioned in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S2.2</xref>, the <monospace>fimpera</monospace> approach does not increase the query execution time. On the contrary, it makes it possible to reduce the running time slightly as <italic toggle="yes">z</italic> increases. See <xref rid="btad305-T2" ref-type="table">Table 2</xref>.</p>
      </sec>
      <sec>
        <title>3.8.3 Discussion</title>
        <p>A Bloom filter indexing <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.38</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> elements using <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.33</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> bits and one hash function would lead to a false positive rate of <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>6.61</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>. A counting Bloom Filter indexing the same dataset using the same space with 5 bits per slot (thus 5 times fewer slots) yields a false positive rate of 25%. With <monospace>fimpera</monospace>, using 5 bits per slot and the same total number of bits, the false positive rate drops to 0.56%. Using the same space as a Bloom filter, <monospace>fimpera</monospace> allows reducing the false positive rate, while adding count storage and being quicker to query. The only downside may in some cases be the computation of the <italic toggle="yes">s<sub>ab</sub></italic> from the abundance of counted <italic toggle="yes">k</italic>-mers. However, this can be skipped altogether with a moderate impact on the result (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S3.3</xref>).</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>We presented <monospace>fimpera</monospace>, a novel computational method for reducing the false positive rate and increasing precision in any counting AMQ data structure. This is achieved without requiring any changes to the original data structure, with no memory overhead, and even with a slight improvement in query computation time.</p>
    <p>Our results showed that when applied on top of a counting Bloom Filter, <monospace>fimpera</monospace> enabled to yield about 45 times fewer false positive calls than when querying directly a counting Bloom Filter of identical size. Moreover, using <monospace>fimpera</monospace>, abundance errors were slightly less frequent on true positive calls, and finally, those abundance errors were on average 1.07 apart from the ground truth with <monospace>fimpera</monospace> while they are on average 1.33 apart from the ground truth with the original <monospace>cBF</monospace>.</p>
    <p>Independently from parameters of the used <monospace>cAMQ</monospace>, <monospace>fimpera</monospace> requires setting up a unique parameter, <italic toggle="yes">z</italic>. Fortunately, results are highly robust with the choice of <italic toggle="yes">z</italic>, unless extreme values are chosen. Future work will include a formal analysis of the theoretical limits on the choice of <italic toggle="yes">z</italic> usage ranges.</p>
    <p>We provide a C++ implementation of <monospace>fimpera</monospace> which enabled us to validate the approach. This implementation can also be used as a stand-alone tool for indexing and querying genomic datasets, and it can be tuned with user-defined parameters and ranges of abundances. The provided GitHub project also proposes all necessary instructions and links to genomic data to reproduce the results.</p>
    <p>Finally, of independent interest, we proposed a novel algorithm and its implementation for computing the minimal or maximal values of consecutive windows, sliding on an array of integers or floats. To the best of our knowledge, this is the fastest algorithm to perform this task.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad305_Supplementary_Data</label>
      <media xlink:href="btad305_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank Eric Pelletier for his help regarding the usage of the Tara Ocean datasets. They acknowledge the GenOuest bioinformatics core facility (<ext-link xlink:href="https://www.genouest.org" ext-link-type="uri">https://www.genouest.org</ext-link>) for providing the computing infrastructure.</p>
  </ack>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> is available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>The work was funded by ANR SeqDigger [ANR-19-CE45-0008]. The publication charges for this paper have been taken up by Inria in the context of its open science policy.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad305-B1">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Alanko</surname><given-names>JN</given-names></string-name>, <string-name><surname>Simon</surname><given-names>JP</given-names></string-name>, <string-name><surname>Jaakko</surname><given-names>V</given-names></string-name></person-group>. Succinct k-mer sets using subset rank queries on the spectral burrows-wheeler transform. <italic toggle="yes">bioRxiv</italic><year>2022</year>;2022–05.</mixed-citation>
    </ref>
    <ref id="btad305-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>SF</given-names></string-name>, <string-name><surname>Gish</surname><given-names>W</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W</given-names></string-name></person-group><etal>et al</etal><article-title>Basic local alignment search tool</article-title>. <source>J Mol Biol</source><year>1990</year>;<volume>215</volume>:<fpage>403</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B3">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bingmann</surname><given-names>T</given-names></string-name>, <string-name><surname>Bradley</surname><given-names>P</given-names></string-name>, <string-name><surname>Gauger</surname><given-names>F</given-names></string-name>, <string-name><surname>Iqbal</surname><given-names>Z</given-names></string-name></person-group>. COBS: a compact bit-sliced signature index. In: <italic toggle="yes">International Symposium on String Processing and Information Retrieval</italic>, SPIRE 2019, pp. <fpage>285</fpage>–<lpage>303</lpage>. Springer.</mixed-citation>
    </ref>
    <ref id="btad305-B4">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bowe</surname><given-names>A</given-names></string-name>, <string-name><surname>Onodera</surname><given-names>T</given-names></string-name>, <string-name><surname>Sadakane</surname><given-names>K</given-names></string-name>, <string-name><surname>Shibuya</surname><given-names>T</given-names></string-name></person-group>. Succinct de bruijn graphs. In: <italic toggle="yes">Algorithms in Bioinformatics: 12th International Workshop, WABI 2012</italic>, September 10–12, 2012, Ljubljana, Slovenia: Springer, <year>2012</year>, pp. <fpage>225</fpage>–<lpage>235</lpage>.</mixed-citation>
    </ref>
    <ref id="btad305-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bradley</surname><given-names>P</given-names></string-name>, <string-name><surname>den Bakker</surname><given-names>HC</given-names></string-name>, <string-name><surname>Rocha</surname><given-names>EPC</given-names></string-name></person-group><etal>et al</etal><article-title>Ultrafast search of all deposited bacterial and viral genomic data</article-title>. <source>Nat Biotechnol</source><year>2019</year>;<volume>37</volume>:<fpage>152</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">30718882</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Holub</surname><given-names>J</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P</given-names></string-name></person-group><etal>et al</etal><article-title>Data structures to represent a set of k-long DNA sequences</article-title>. <source>ACM Comput Surv</source><year>2022</year>;<volume>54</volume>:<fpage>1</fpage>–<lpage>22</lpage>.</mixed-citation>
    </ref>
    <ref id="btad305-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cummins</surname><given-names>C</given-names></string-name>, <string-name><surname>Ahamed</surname><given-names>A</given-names></string-name>, <string-name><surname>Aslam</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>The European nucleotide archive in 2021</article-title>. <source>Nucleic Acids Res</source><year>2022</year>;<volume>50</volume>:<fpage>D106</fpage>–<lpage>D110</lpage>.<pub-id pub-id-type="pmid">34850158</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Durocher</surname><given-names>S</given-names></string-name>, <string-name><surname>Singh</surname><given-names>R.</given-names></string-name></person-group><article-title>A simple linear-space data structure for constant-time range minimum query</article-title>. <source>Theor Comput Sci</source><year>2019</year>;<volume>770</volume>:<fpage>51</fpage>–<lpage>61</lpage>.</mixed-citation>
    </ref>
    <ref id="btad305-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fan</surname><given-names>L</given-names></string-name>, <string-name><surname>Cao</surname><given-names>P</given-names></string-name>, <string-name><surname>Almeida</surname><given-names>J</given-names></string-name>, <string-name><surname>Broder</surname><given-names>AZ</given-names></string-name></person-group>. <article-title>Summary cache: a scalable wide-area web cache sharing protocol</article-title>. <source>IEEE/ACM Trans Network</source><year>2000</year>;<volume>8</volume>:<fpage>281</fpage>–<lpage>93</lpage>.</mixed-citation>
    </ref>
    <ref id="btad305-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Harris</surname><given-names>RS</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>Improved representation of sequence bloom trees</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>721</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">31504157</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kokot</surname><given-names>M</given-names></string-name>, <string-name><surname>Dlugosz</surname><given-names>M</given-names></string-name>, <string-name><surname>Deorowicz</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>KMC 3: counting and manipulating k-mer statistics</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>2759</fpage>–<lpage>61</lpage>.<pub-id pub-id-type="pmid">28472236</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B12">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Rizk</surname><given-names>G</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Peterlongo</surname><given-names>P</given-names></string-name></person-group>. Fast and scalable minimal perfect hashing for massive key sets. In: <italic toggle="yes">16th International Symposium on Experimental Algorithms (SEA 2017), volume 75 of Leibniz International Proceedings in Informatics (LIPIcs)</italic>, pp. <fpage>25:1</fpage>–<lpage>25:16</lpage>. Dagstuhl, Germany: Schloss Dagstuhl–Leibniz–Zentrum fuer Informatik, <year>2017</year>.</mixed-citation>
    </ref>
    <ref id="btad305-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Marchet</surname><given-names>C,</given-names></string-name></person-group> Kerbiriou M, Limasset A. Efficient exact associative structure for sequencing data. In: <source>Recomb-Seq 2019-9th RECOMB Satellite Workshop on Massively Parallel Sequencing</source>, 2019 May 3 (pp. 1–16).</mixed-citation>
    </ref>
    <ref id="btad305-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marchet</surname><given-names>C</given-names></string-name>, <string-name><surname>Boucher</surname><given-names>C</given-names></string-name>, <string-name><surname>Puglisi</surname><given-names>SJ</given-names></string-name></person-group><etal>et al</etal><article-title>Data structures based on k-mers for querying large collections of sequencing data sets</article-title>. <source>Genome Res</source><year>2021</year>;<volume>31</volume>:<fpage>1</fpage>–<lpage>12</lpage>.<pub-id pub-id-type="pmid">33328168</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B15">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Pandey</surname><given-names>P</given-names></string-name>, <string-name><surname>Bender</surname><given-names>MA</given-names></string-name>, <string-name><surname>Johnson</surname><given-names>R</given-names></string-name>, <string-name><surname>Patro</surname><given-names>R</given-names></string-name></person-group>. A general-purpose counting filter: Making every bit count. In: <italic toggle="yes">Proceedings of the 2017 ACM International Conference on Management of Data</italic>, pp. <fpage>775</fpage>–<lpage>787</lpage>, <year>2017</year>.</mixed-citation>
    </ref>
    <ref id="btad305-B16">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Pibiri</surname><given-names>GE.</given-names></string-name></person-group> On Weighted k-mer Dictionaries. In: Boucher C, Rahmann S (eds.), <italic toggle="yes">22nd International Workshop on Algorithms in Bioinformatics (WABI 2022)</italic>, volume 242 of Leibniz International Proceedings in Informatics (LIPIcs), pp. <fpage>9:1</fpage>–<lpage>9:20</lpage>, Dagstuhl, Germany: Schloss Dagstuhl – Leibniz-Zentrum für Informatik, <year>2022a</year>.</mixed-citation>
    </ref>
    <ref id="btad305-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pibiri</surname><given-names>GE.</given-names></string-name></person-group><article-title>Sparse and skew hashing of k-mers</article-title>. <source>Bioinformatics</source><year>2022b</year>;<volume>38</volume>:<fpage>i185</fpage>–<lpage>i194</lpage>.<pub-id pub-id-type="pmid">35758794</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B18">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Pibiri</surname><given-names>GE</given-names></string-name>, <string-name><surname>Trani</surname><given-names>R.</given-names></string-name></person-group><year>2021</year>. PTHash: Revisiting FCH minimal perfect hashing. In: <italic toggle="yes">Proceedings of the 44th International ACM SIGIR Conference on Research and Development in Information Retrieval</italic>, pp. <fpage>1339</fpage>–<lpage>1348</lpage>.</mixed-citation>
    </ref>
    <ref id="btad305-B19">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Rahman</surname><given-names>A</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group> Representation of k-mer sets using spectrum-preserving string sets. Technical report. Cold Spring Harbor Laboratory. New Results, <year>2020</year>.</mixed-citation>
    </ref>
    <ref id="btad305-B20">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Robidou</surname><given-names>L</given-names></string-name>, <string-name><surname>Peterlongo</surname><given-names>P.</given-names></string-name></person-group> findere: fast and precise approximate membership query. In: <italic toggle="yes">International Symposium on String Processing and Information Retrieval</italic>, pp. <fpage>151</fpage>–<lpage>163</lpage>. Springer, <year>2021</year>.</mixed-citation>
    </ref>
    <ref id="btad305-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shibuya</surname><given-names>Y</given-names></string-name>, <string-name><surname>Belazzougui</surname><given-names>D</given-names></string-name>, <string-name><surname>Kucherov</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal><article-title>Set-min sketch: a probabilistic map for power-law distributions with application to k-mer annotation</article-title>. <source>J Comput Biol</source><year>2022a</year>;<volume>29</volume>:<fpage>140</fpage>–<lpage>54</lpage>.<pub-id pub-id-type="pmid">35049334</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shibuya</surname><given-names>Y</given-names></string-name>, <string-name><surname>Belazzougui</surname><given-names>D</given-names></string-name>, <string-name><surname>Kucherov</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal><article-title>Space-efficient representation of genomic k-mer count tables</article-title>. <source>Algorithms Mol Biol</source><year>2022b</year>;<volume>17</volume>:<fpage>5</fpage>.<pub-id pub-id-type="pmid">35317833</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Solomon</surname><given-names>B</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>Fast search of thousands of short-read sequencing experiments</article-title>. <source>Nat Biotechnol</source><year>2016</year>;<volume>34</volume>:<fpage>300</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">26854477</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sunagawa</surname><given-names>S</given-names></string-name>, <string-name><surname>Acinas</surname><given-names>SG</given-names></string-name>, <string-name><surname>Bork</surname><given-names>P</given-names></string-name></person-group><etal>et al</etal>; <collab>Tara Oceans Coordinators</collab>. <article-title>Tara oceans: towards global ocean ecosystems biology</article-title>. <source>Nat Rev Microbiol</source><year>2020</year>;<volume>18</volume>:<fpage>428</fpage>–<lpage>45</lpage>.<pub-id pub-id-type="pmid">32398798</pub-id></mixed-citation>
    </ref>
    <ref id="btad305-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tomczak</surname><given-names>K</given-names></string-name>, <string-name><surname>Czerwińska</surname><given-names>P</given-names></string-name>, <string-name><surname>Wiznerowicz</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>The cancer genome atlas (TCGA): an immeasurable source of knowledge</article-title>. <source>Contemp Oncol</source><year>2015</year>;<volume>1A</volume>:<fpage>68</fpage>–<lpage>77</lpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
