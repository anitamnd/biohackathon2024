<?DTDIdentifier.IdentifierValue -//NPG//DTD XML Article//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName NPG_XML_Article.dtd?>
<?SourceDTD.Version 2.7.10?>
<?ConverterInfo.XSLTName nature2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Sci Rep</journal-id>
    <journal-id journal-id-type="iso-abbrev">Sci Rep</journal-id>
    <journal-title-group>
      <journal-title>Scientific Reports</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2045-2322</issn>
    <publisher>
      <publisher-name>Nature Publishing Group</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3638164</article-id>
    <article-id pub-id-type="pii">srep01746</article-id>
    <article-id pub-id-type="doi">10.1038/srep01746</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>FOGSAA: Fast Optimal Global Sequence Alignment Algorithm</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Chakraborty</surname>
          <given-names>Angana</given-names>
        </name>
        <xref ref-type="aff" rid="a1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bandyopadhyay</surname>
          <given-names>Sanghamitra</given-names>
        </name>
        <xref ref-type="corresp" rid="c1">a</xref>
        <xref ref-type="aff" rid="a1">1</xref>
      </contrib>
      <aff id="a1"><label>1</label><institution>Machine Intelligence Unit, Indian Statistical Institute</institution>, Kolkata, India</aff>
    </contrib-group>
    <author-notes>
      <corresp id="c1">
        <label>a</label>
        <email>sanghami@isical.ac.in</email>
      </corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>29</day>
      <month>04</month>
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2013</year>
    </pub-date>
    <volume>3</volume>
    <elocation-id>1746</elocation-id>
    <history>
      <date date-type="received">
        <day>13</day>
        <month>12</month>
        <year>2012</year>
      </date>
      <date date-type="accepted">
        <day>15</day>
        <month>04</month>
        <year>2013</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2013, Macmillan Publishers Limited. All rights reserved</copyright-statement>
      <copyright-year>2013</copyright-year>
      <copyright-holder>Macmillan Publishers Limited. All rights reserved</copyright-holder>
      <license xmlns:xlink="http://www.w3.org/1999/xlink" license-type="open-access" xlink:href="http://creativecommons.org/licenses/by-nc-nd/3.0/">
        <!--author-paid-->
        <license-p>This work is licensed under a Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License. To view a copy of this license, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc-nd/3.0/">http://creativecommons.org/licenses/by-nc-nd/3.0/</ext-link></license-p>
      </license>
    </permissions>
    <abstract>
      <p>In this article we propose a Fast Optimal Global Sequence Alignment Algorithm, FOGSAA, which aligns a pair of nucleotide/protein sequences faster than any optimal global alignment method including the widely used Needleman-Wunsch (NW) algorithm. FOGSAA is applicable for all types of sequences, with any scoring scheme, and with or without affine gap penalty. Compared to NW, FOGSAA achieves a time gain of (70–90)% for highly similar nucleotide sequences (&gt; 80% similarity), and (54–70)% for sequences having (30–80)% similarity. For other sequences, it terminates with an approximate score. For protein sequences, the average time gain is between (25–40)%. Compared to three heuristic global alignment methods, the quality of alignment is improved by about 23%–53%. FOGSAA is, in general, suitable for aligning any two sequences defined over a finite alphabet set, where the quality of the global alignment is of supreme importance.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <p>In bioinformatics, a sequence alignment is a way of arranging the sequences of DNA, RNA or protein to identify their degree of similarity that may be important in identifying functional, structural or evolutionary relationships between them. If two sequences in an alignment share a common ancestor, mismatches can be interpreted as point mutations and gaps as indels, introduced in one or both lineages in the time since they diverged from one another. In sequence alignment of proteins, the degree of similarity between amino acids occupying a particular position in the sequence can be interpreted as a rough measure of how conserved a particular region is. The alignment algorithms are generally of two types: <italic>Local Alignment Methods</italic> such as<xref ref-type="bibr" rid="b1">1</xref><xref ref-type="bibr" rid="b2">2</xref><xref ref-type="bibr" rid="b3">3</xref><xref ref-type="bibr" rid="b4">4</xref>, are designed to search locally similar segments between two sequences while in <italic>Global Alignment Methods</italic> the overall similarity is mapped out.</p>
  <p>Global alignment algorithms like<xref ref-type="bibr" rid="b5">5</xref><xref ref-type="bibr" rid="b6">6</xref> are found useful as biological sequences from related organisms satisfy some ordering assumption. For example, the human and mouse genome share a conserved region up to 8 Megabases in length<xref ref-type="bibr" rid="b7">7</xref>. The fundamental contribution of global alignment described in<xref ref-type="bibr" rid="b8">8</xref> was the widely adopted one for optimal alignment of sequences. But this algorithm is very expensive with respect to time and space, proportional to the product of the length of two sequences and hence is not suitable for long sequences. Then GAP3<xref ref-type="bibr" rid="b9">9</xref> was proposed with improved sensitivity and was suitable for comparing sequences with intermittent similarities. But as the underlying principle is based on dynamic programming, the computing time is still proportional to the product of the sequence lengths. Beside this, the optimality of the alignment, as performed by GAP3, is highly sensitive to the parameter values given in the program. There are some heuristic based fast alignment programs also, like ACANA<xref ref-type="bibr" rid="b10">10</xref>, AVID<xref ref-type="bibr" rid="b11">11</xref>, ClustalW<xref ref-type="bibr" rid="b12">12</xref>, BLASTZ<xref ref-type="bibr" rid="b13">13</xref>, NUMmer<xref ref-type="bibr" rid="b14">14</xref>, LAGAN<xref ref-type="bibr" rid="b15">15</xref> etc. However these often compromise on the quality of the alignment.</p>
  <p>In this article we propose a Fast Optimal global sequence alignment that overcomes the shortcomings of the existing methods, and provides the optimal alignment of sequences without any parameter tuning. FOGSAA gives exactly the same result as that provided by the Needleman-Wunsch method (NW)<xref ref-type="bibr" rid="b8">8</xref>, but in much less time. The Result Section shows that among the three optimal global alignment programs (NW, GAP3, FOGSAA), FOGSAA is the fastest. With respect to the heuristic alignment methods mentioned earlier, FOGSAA provides an improvement of alignment scores of about 22.8% on simulated benchmark data<xref ref-type="bibr" rid="b16">16</xref> and 53% on real human-mouse ortholog sequences over these methods. FOGSAA also outperforms GAP3<xref ref-type="bibr" rid="b9">9</xref> on the overall quality of the alignment. Not only for the gene sequences, it can do equally well for protein sequences with or without affine gap penalty. In such cases FOGSAA takes the match and mismatch scores from the substitution matrices like BLOSUM62, PAM etc. and the gap penalties including the gap_open and gap_extension scores can have any value as specified by the user. Experimental results show that for protein sequences FOGSAA achieves a time gain of (25% – 40%).</p>
  <p>The algorithm, FOGSAA, is basically a branch and bound approach of global pairwise sequence alignment. It works by building a branch and bound tree where each root-to-leaf path represents a possible way to align the given pair of sequences. FOGSAA starts the branch expansion in a greedy way taking the symbols from the input sequences (protein or nucleotide) and continues till the end of the path. If at an intermediate point, some other branch is found more promising than the current one, then it is started for expansion. The procedure is repeated until no other branch is found better. Finally it returns the optimal alignment along with the optimal score, by traversing the optimal path. During expansion, if a path is found no longer promising, it is pruned to save unnecessary computation. However, if less than 30% similarity of the input sequences is detected, then the algorithm is terminated with an approximate score which is equal to the best score obtained so far. Although FOGSAA can give the accurate optimal alignment for any sequence pair even if they are less than 30% similar, it may not be worthwhile to spend the resources for aligning such dissimilar sequences. Therefore, we terminate FOGSAA in these cases. The threshold of 30% was chosen based on the intuition, though it can be changed if required. The pruning strategy and the way of computing an approximate score for highly dissimilar sequences are described in the Method Section. The workflow of FOGSAA is depicted in <xref ref-type="fig" rid="f1">Fig. 1</xref>. Some relevant definitions and the theoretical formulation of the algorithm are provided below.</p>
  <p>Let the two sequences of length <italic>m</italic> and <italic>n</italic>, respectively, be the following: <disp-formula id="m10"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e175" xlink:href="srep01746-m10.jpg"/></disp-formula></p>
  <p>Let <italic>P</italic>1 and <italic>P</italic>2 be the pointers to symbols in <italic>S</italic>1 and <italic>S</italic>2 respectively, having initial values <italic>P</italic>1 = 0 and <italic>P</italic>2 = 0. FOGSAA computes the optimal alignment between <italic>S</italic>1 and <italic>S</italic>2 by finding the optimal branch in the corresponding branch and bound tree. Each node of this tree shows the alignment between one pair of symbols pointed by (<italic>P</italic>1,<italic>P</italic>2) which is (0,0) for the root node. A node has four components:</p>
  <p>
    <list id="l1" list-type="bullet">
      <list-item>
        <p>(<italic>P</italic>1,<italic>P</italic>2) value pair </p>
      </list-item>
      <list-item>
        <p>The <italic>Type</italic> of alignment: <inline-formula id="m11"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e227" xlink:href="srep01746-m11.jpg"/></inline-formula>
</p>
      </list-item>
      <list-item>
        <p><italic>PrS</italic> (Defined later) </p>
      </list-item>
      <list-item>
        <p>(<italic>T<sub>max</sub>,T<sub>min</sub></italic>) (Defined later). </p>
      </list-item>
    </list>
  </p>
  <p>Then, a path from the root to a node ((<italic>P</italic>1, <italic>P</italic>2); <italic>Type</italic>; <italic>PrS</italic>; (<italic>T<sub>min</sub>, T<sub>max</sub></italic>)) represents an alignment of <italic>a</italic><sub>1</sub><italic>a</italic><sub>2</sub>…<italic>a<sub>P</sub></italic><sub>1</sub> and <italic>b</italic><sub>1</sub><italic>b</italic><sub>2</sub>…<italic>b<sub>P</sub></italic><sub>2</sub> with the last pair of characters being aligned as <italic>Type</italic>. The <italic>PrS</italic> and (<italic>T<sub>min</sub>, T<sub>max</sub></italic>) give the Present Score and Fitness Score values respectively after alignment of <italic>a</italic><sub>1</sub><italic>a</italic><sub>2</sub>…<italic>a<sub>P</sub></italic><sub>1</sub> and <italic>b</italic><sub>1</sub><italic>b</italic><sub>2</sub>…<italic>b<sub>P</sub></italic><sub>2</sub>. These are defined later. In this way, a path from the root to a leaf node i.e., a complete path represents one possible way to align the given pair of sequences. Therefore, a branch and bound tree is a search tree which searches for an optimal alignment path while using an objective score to bound the search space. Starting from the root of this tree, FOGSAA proceeds in one of the following three ways:</p>
  <p>
    <list id="l5" list-type="bullet">
      <list-item>
        <p>Advance both the pointers <italic>P</italic>1 and <italic>P</italic>2, i.e., align <italic>a</italic><sub>1</sub> with <italic>b</italic><sub>1</sub>, which can lead to either a match or mismatch. </p>
      </list-item>
      <list-item>
        <p>Move the pointer <italic>P</italic>1 keeping <italic>P</italic>2 fixed which will introduce a gap in <italic>S</italic>2, i.e., <italic>a</italic><sub>1</sub> will be paired with a gap. </p>
      </list-item>
      <list-item>
        <p>Move the pointer <italic>P</italic>2 keeping <italic>P</italic>1 fixed, thereby introducing a gap in <italic>S</italic>1. </p>
      </list-item>
    </list>
  </p>
  <p>Hence the root can have three children (<italic>a</italic><sub>1</sub>,<italic>b</italic><sub>1</sub>), (<italic>a</italic><sub>1,–</sub>) or (<sub>–</sub>,<italic>b</italic><sub>1</sub>), where the first child indicates a match or mismatch, the second child indicates a gap in S2 and the third one indicates a gap in S1. The corresponding <italic>P</italic>1 and <italic>P</italic>2 values of these three children would be (1, 1), (1, 0) and (0, 1) respectively. Likewise every node of this branch and bound tree can have at most three children (as shown in <xref ref-type="supplementary-material" rid="s1">Fig. S1 in Supplementary</xref>). Among them only the best one will be expanded according to the ‘Fitness Score’ (see Definitions below), while the others are inserted in a hashed priority queue ordered by their scores. These nodes might be expanded later on if they come in the top of the priority queue.</p>
  <p>This approach of selecting the fittest child based on the ‘Fitness Score’ continues till the end of the branch. One branch, from the root to a leaf, gives one alignment. Then the algorithm proceeds to the next branch in search for a better alignment. This branch always starts from a node which has the highest Fitness Score and is on the top of the priority queue. All the decisions i.e., whether we should go for a next branch or not, which should be that next branch and how far a branch should be expanded, are taken according to the above mentioned score. If at any point FOGSAA detects that the score of the top most node of the priority queue indicates that the two sequences have less than 30% similarity, then it terminates with the best alignment and corresponding score that has been obtained so far. In other cases, FOGSAA terminates with an optimal alignment of the sequences based on the given values of match, mismatch and gap scores. The gap score can also include affine gap penalties<xref ref-type="bibr" rid="b17">17</xref> with Gap-open (<italic>Go</italic>) and Gap-extension (<italic>Ge</italic>) costs. In such cases, the total Gap cost of length <italic>L</italic> would be (<italic>Go</italic> + <italic>L</italic> × <italic>Ge</italic>). Similarly, for protein sequence alignments, FOGSAA can use any substitution matrix, with or without affine gap penalties.</p>
  <p>The working principle of FOGSAA is based on two strategies: i) Select the best child in the current branch. ii) Start next branching from a node showing highest potential. The potential of any node, say <italic>X</italic>, is computed using Fitness Score. If its potential is greater than other siblings, then <italic>X</italic> will be expanded in the tree. The Fitness Score is the summation of two other scores, the Present Score and Future Score. The Present Score is the sum of all match/mismatch/gap scores that have been encountered so far in the current branch starting from root to the node <italic>X</italic>, while the Future Score is an estimated score value that can result when the remaining parts of the sequences would be aligned. These scores are defined below.</p>
  <p>Let the given pair of sequences be <disp-formula id="m34"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e467" xlink:href="srep01746-m34.jpg"/></disp-formula>where |<italic>S</italic>1| = <italic>m</italic> and |<italic>S</italic>2| = <italic>n</italic>. If the current node is at position (<italic>P</italic>1, <italic>P</italic>2) i.e., <italic>P</italic>1 symbols from <italic>S</italic>1 and <italic>P</italic>2 symbols of <italic>S</italic>2 have been checked and (<italic>i</italic><sub>1</sub>, <italic>j</italic><sub>1</sub>),(<italic>i</italic><sub>2</sub>, <italic>j</italic><sub>2</sub>), … ,(<italic>i<sub>k</sub>, j<sub>k</sub></italic>) are the <italic>k</italic> nodes that are expanded so far in the current branch where, <italic>i<sub>k</sub></italic> = <italic>P</italic>1 and <italic>j<sub>k</sub></italic> = <italic>P</italic>2, then the Present Score, denoted by PrS, is defined as: <disp-formula id="m1"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e551" xlink:href="srep01746-m1.jpg"/></disp-formula>The addition of scores for each node, from root to the current node of the current branch, gives the Present Score. Here, <disp-formula id="m2"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e554" xlink:href="srep01746-m2.jpg"/></disp-formula>Where <italic>M</italic> = Match Score, <italic>Ms</italic> = Mismatch Score and <italic>G</italic> = Gap Penalty.</p>
  <p>The Future Score reflects the scenario from the node <italic>X</italic> to the leaf of the current branch. Unlike Present Score, the Future Score is not known at this moment. It will attain its maximum value when there are all matches in the path <italic>X</italic> to the leaf. On the other hand, all mismatches will lead to its minimum value of the optimal alignment. There can be any other alignment worse than this, but it is surely not the optimal one. Note that there will be at least as many number of gaps as the difference of lengths of the two strings. If the current node is at (<italic>P</italic>1, <italic>P</italic>2), then the Present Score includes the alignment of the symbols <italic>a</italic><sub>1</sub>…<italic>a<sub>P</sub></italic><sub>1</sub> of <italic>S</italic>1 and <italic>b</italic><sub>1</sub>…<italic>b<sub>P</sub></italic><sub>2</sub> of <italic>S</italic>2. For the remaining portion, i.e., for <italic>a<sub>P</sub></italic><sub>1 + 1</sub>…<italic>a<sub>m</sub></italic> of sequence <italic>S</italic>1 and <italic>b<sub>P</sub></italic><sub>2 + 1</sub>…<italic>b<sub>n</sub></italic> of <italic>S</italic>2, we have to compute the minimum and maximum scores. In the Future Score, without loss of generality, it may be stated that there must be at least |(<italic>m</italic> − <italic>P</italic>1) − (<italic>n</italic> − <italic>P</italic>2)| gaps. For the remaining part, at best there may be (<italic>m</italic> − <italic>P</italic>1) matches, and at worst (<italic>m</italic> − <italic>P</italic>1) mismatches.</p>
  <p>If the two sequences to be aligned are <italic>a</italic><sub>1</sub>…<italic>a<sub>m</sub></italic> and <italic>b</italic><sub>1</sub>…<italic>b<sub>n</sub></italic> and the present node is at position (<italic>P</italic>1, <italic>P</italic>2), then the two components <italic>F<sub>min</sub></italic> and <italic>F<sub>max</sub></italic> of Future Score, for the subsequences <italic>a<sub>P</sub></italic><sub>1+1</sub>…<italic>a<sub>m</sub></italic> and <italic>b<sub>P</sub></italic><sub>2+1</sub>…<italic>b<sub>n</sub></italic>, are defined as: <disp-formula id="m3"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e732" xlink:href="srep01746-m3.jpg"/></disp-formula><disp-formula id="m4"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e734" xlink:href="srep01746-m4.jpg"/></disp-formula>where, <italic>x</italic><sub>1</sub> = (<italic>n</italic> − <italic>P</italic>2) and <italic>x</italic><sub>2</sub> = (<italic>m</italic> − <italic>P</italic>1).</p>
  <p>Note that for amino-acid sequences, <italic>M</italic> and <italic>Ms</italic> take values from a substitution matrix, which is by default BLOSUM 62.</p>
  <p>The Fitness Score of a node, based on which the potential of a branch is evaluated, is the sum of the Present Score (PrS) and the Future Score. Fitness Score, having two components denoted by <italic>T<sub>min</sub></italic> and <italic>T<sub>max</sub></italic>, is defined as follows: <disp-formula id="m5"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e781" xlink:href="srep01746-m5.jpg"/></disp-formula><disp-formula id="m6"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e783" xlink:href="srep01746-m6.jpg"/></disp-formula></p>
  <p>The entire method for the selection of the best child depending on these scores, which finally results in the optimal alignment, is summarized in Algorithm 1. The nodes are inserted in the priority queue based on their <italic>T<sub>max</sub></italic> values i.e., the node having the highest value of <italic>T<sub>max</sub></italic> will be on the top.</p>
  <p>An example of Fitness Score calculation using Algorithm 1 from the partially computed FOGSAA tree is shown in <xref ref-type="fig" rid="f2">Fig. 2</xref>. It uses +1 and −1 for the Match and Mismatch scores respectively and −2 as the Gap penalty (without using affine gap).</p>
  <p>The root starts with <italic>P</italic>1 = 0 and <italic>P</italic>2 = 0 and since no alignment has been made so far, the Present Score, <italic>PrS</italic> = 0. Here <italic>m</italic> = 8 and <italic>n</italic> = 6, thus in the Future Score there will be at least (<italic>m</italic> − <italic>n</italic>) = 2 gaps. The best case would be if the remaining 6, as <italic>min</italic>(<italic>m, n</italic>) = 6, are all matches yielding <italic>F<sub>max</sub></italic> = 6 * 1 + 2 * (−2) = 2. Similarly, the worst scenario would be if these 6 are all mismatches, giving <italic>F<sub>min</sub></italic> = 6 * (−1) + 2 * (−2) = −10. Therefore, <italic>T<sub>min</sub></italic> = <italic>P</italic> + <italic>F<sub>min</sub></italic> = 0 + (−10) = −10 and <italic>T<sub>max</sub></italic> = <italic>P</italic> + <italic>F<sub>max</sub></italic> = 0 + 2 = 2. This [<italic>T<sub>max</sub>, T<sub>min</sub></italic>] = [2, −10] value pair is shown in the top-right side of the root node in <xref ref-type="fig" rid="f2">Fig. 2</xref>. Now, from the root there are three possible moves (1, 1), (1, 0) or (0, 1). For the first one <italic>PrS</italic> = 1, as it is a match. Here the Future Score is computed for length <italic>x</italic><sub>1</sub> = (<italic>m</italic> − <italic>P</italic>1) = 7 and <italic>x</italic><sub>2</sub> = (<italic>n</italic> − <italic>P</italic>2) = 5 of sequences <italic>S</italic>1 and <italic>S</italic>2 respectively. So, <italic>F<sub>max</sub></italic> = 5 + 2 * (−2) = 1 and <italic>F<sub>min</sub></italic> = 5 * (−1) + 2 * (−2) = −9. Finally, <italic>T<sub>min</sub></italic> = <italic>P</italic> + <italic>F<sub>min</sub></italic> = 1 + (−9) = −8 and <italic>T<sub>max</sub></italic> = <italic>P</italic> + <italic>F<sub>max</sub></italic> = 1 + 1 = 2. Similarly, it can be shown that, node (1,1) has higher <italic>T<sub>max</sub></italic> value than the other two children (1,0) and (0,1). Hence this node is expanded in <xref ref-type="fig" rid="f2">Fig. 2</xref>. The algorithm continues in this way. A detailed illustration of FOGSAA can be found in the <xref ref-type="supplementary-material" rid="s1">Supplementary Figures</xref><xref ref-type="bibr" rid="b2">2</xref><xref ref-type="bibr" rid="b3">3</xref><xref ref-type="bibr" rid="b4">4</xref><xref ref-type="bibr" rid="b5">5</xref><xref ref-type="bibr" rid="b6">6</xref>.</p>
  <p>Note that although the example provided here is for a specific scoring scheme without affine gap penalty, FOGSAA is able to handle any scoring scheme including substitution matrices for protein sequences, and also affine gap penalty. In the case of affine gap penalty, the <italic>G</italic> of Eq. 2 will be computed as follows: <disp-formula id="m7"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e969" xlink:href="srep01746-m7.jpg"/></disp-formula>where <italic>Go</italic> and <italic>Ge</italic> stand for Gap-open and Gap-extension penalties respectively.</p>
  <p>In case of calculating <italic>F<sub>min</sub></italic>, we have to consider the worst case where each gap is a new gap. That means all the gaps are scattered separately and the cost of each gap would be (<italic>Go</italic> + <italic>Ge</italic>). In contrast, for <italic>F<sub>max</sub></italic> we can take the best case scenario in which all the gaps are clubbed together and there is only one gap open penalty. Therefore, the Eq. 3 and Eq. 4 can be extended as follows to include affine gap penalty. <disp-formula id="m8"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e997" xlink:href="srep01746-m8.jpg"/></disp-formula><disp-formula id="m9"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e999" xlink:href="srep01746-m9.jpg"/></disp-formula></p>
  <p>Note that, Eq. 5 and Eq. 6 remain unchanged, though the computation of <italic>PrS</italic> and (<italic>F<sub>min</sub>, F<sub>max</sub></italic>) are modified as described above.</p>
  <sec disp-level="1" sec-type="results">
    <title>Results</title>
    <p>FOGSAA is basically a branch and bound algorithm which starts its branch expansion by greedy selection of nodes based on some specific score value. Branch and bound techniques can take exponential time in the worst case. However, the average complexity of branch and bound method is significantly lower<xref ref-type="bibr" rid="b18">18</xref>. It has already been shown that the average case analysis of branch and bound problem has polynomial complexity<xref ref-type="bibr" rid="b19">19</xref>. Here in FOGSAA, if the two input sequences are of length <italic>m</italic> and <italic>n</italic> respectively, then there cannot be more than <italic>m</italic> × <italic>n</italic> nodes in the branch and bound tree. Therefore, the worst case running time of FOGSAA is bounded by <italic>O</italic>(<italic>m</italic> × <italic>n</italic>), though, on an average, it is much lower. The best case, when FOGSAA finds the optimal alignment just after expanding the first branch, has complexity <italic>O</italic>(<italic>m</italic> + <italic>n</italic>), equal to the maximum length of a branch. This is why FOGSAA achieves a large time gain in comparison to NW, whose complexity is <italic>O</italic>(<italic>m</italic> × <italic>n</italic>) for all the cases -best, average and worst. Note that the alignment quality of FOGSAA and NW are exactly the same.</p>
    <p>We have divided the results into two categories: 1) Running time comparison between three optimal global alignment programs, NW, GAP3 and FOGSAA; 2) Comparative study of alignment quality between FOGSAA, NW, and GAP3, and three heuristic methods ACANA, AVID and ClustalW.</p>
    <sec disp-level="2">
      <title>Running time comparison</title>
      <p>To assess the performance of FOGSAA, we have compared its running time with those of two other optimal alignment programs, NW and GAP3, on 178 real DNA sequences collected from NCBI GenBank (Code, test data and results are available at <ext-link xmlns:xlink="http://www.w3.org/1999/xlink" ext-link-type="uri" xlink:href="http://www.isical.ac.in/~bioinfo_miu/FOGSAA.htm">http://www.isical.ac.in/~bioinfo_miu/FOGSAA.htm</ext-link>). These DNA sequences are then divided into three classes based on their similarity: i) greater than 80% similar, ii) 30% – 80% similar and iii) less than 30% similar. <xref ref-type="fig" rid="f3">Fig. 3</xref> and <xref ref-type="fig" rid="f4">Fig. 4</xref> show the performance of all the three methods for sequences having &gt; 80% similarity and 30% – 80% similarity respectively, when they are run on Intel(R) Core(TM) i7 CPU @ 2.93 GHz machine with 4 GB RAM with the scoring scheme as <italic>M</italic> = 1, <italic>Ms</italic> = −1 and <italic>G</italic> = −2. As can be clearly seen from the graphs, FOGSAA comprehensively outperforms NW as well as GAP3 in every case for sequences upto 6000 bp.</p>
      <p>If FOGSAA encounters a situation when the most promising node of the branch and bound tree (or, the first entry in the priority queue) shows less than 30% similarity, then it terminates with an approximate alignment. A detailed description of pruning strategy and approximate score can be found in the Method Section. <xref ref-type="table" rid="t1">Table 1</xref> shows the behavior of FOGSAA in comparison to NW and GAP3 for real gene sequences of less than 30% similarity. As can be seen from the table, the optimal alignment score, whenever available, is negative reflecting the low similarity of the sequences. And the approximate score as given by FOGSAA, is very close to the optimal one. In certain cases where the input sequences are very long and dissimilar, then most of the times NW and GAP3 fail. However, FOGSAA is able to provide at least a good approximate score as shown in the last row of <xref ref-type="table" rid="t1">Table 1</xref>.</p>
      <p>FOGSAA performs significantly well even for different scoring schemes with or without affine gap penalties. This is reflected in <xref ref-type="table" rid="t2">Table 2</xref>. Here results are shown for 5 different scoring schemes with and without affine gap penalty. Each scheme is tested on nearly 100 pairs of sequences having length upto approximately 10,000 bp, which have been collected from NCBI GenBank. These sequences are of varied similarity as they are picked arbitrarily. As can be seen from the table, FOGSAA performs consistently better over all the scoring schemes and produces an average time gain of 82%. Here, it is also found that on an average 64% of the total possible nodes are pruned.</p>
      <p>As mentioned earlier, FOGSAA is equally applicable for protein sequences with any substitution matrix, both with and without affine gap penalties. Here we provide the results for BLOSUM62. <xref ref-type="fig" rid="f5">Fig. 5</xref> summarizes the performance of FOGSAA as compared with NW for 100 pairs of amino-acid sequences with affine gap penalty. These sequences are also selected arbitrarily from NCBI. Here we have used −90 and −25 as the Gap-open and Gap-extension penalties respectively. From the histogram plot as shown in this figure, it is evident that FOGSAA provides a high time gain for a very large number of times. Here time gain is computed as (<italic>Time<sub>NW</sub></italic> − <italic>Time<sub>FOGSAA</sub></italic>)/<italic>Time<sub>NW</sub></italic>. Similar results using different scoring functions with or without affine gap penalty can be found in the <xref ref-type="supplementary-material" rid="s1">Supplementary Tables (S3–S6)</xref>.</p>
    </sec>
    <sec disp-level="2">
      <title>Result on alignment quality</title>
      <p>FOGSAA is not only a faster alignment tool, it also provides the best or optimal alignment of the input sequences (having &gt; 30% similarity). FOGSAA is sometimes slower than some fast heuristic based alignment approaches. However, the quality of alignment of these faster methods often degrades and is far from the optimal alignment. In this section, we provide results pertaining to the alignment quality. <xref ref-type="supplementary-material" rid="s1">Table S1 of Supplementary</xref>, shows the comparison between FOGSAA, ACANA, AVID, ClustalW and GAP3 for the benchmark gene sequences<xref ref-type="bibr" rid="b16">16</xref>. The mean and median of the alignment scores are provided. Greater the alignment score, better is the alignment quality.</p>
      <p>As can be seen from <xref ref-type="supplementary-material" rid="s1">Table S1 in Supplementary</xref>, FOGSAA shows the highest mean as well as median scores among all the methods. As expected, the corresponding values for NW are the same since both of them have exactly the same alignment quality. GAP3 has the property of removing some base pairs, when they are found not potential for alignment. That is why GAP3 provides good alignment for sequences having intermittent similarity. But the performance often degrades for the overall alignment as reflected by the negative mean in the table. Here we have tuned the parameters of GAP3 in such a way that no base pairs are removed, otherwise it will be difficult to make the comparison as the sequence length would get reduced. GAP3 provides the optimal alignment only in certain cases, but not always as verified through personal communication with the authors.</p>
      <p><xref ref-type="table" rid="t3">Table 3</xref> shows the result of a comparative study on real sequences containing human-mouse orthologs. Here FOGSAA is compared only with ACANA, as it is one of the more recent methods, on 25 pairs of real ortholog sequences. The detailed count of matches (<italic>M</italic>), Mismatches (<italic>MS</italic>), and Gaps (<italic>G</italic>) are given for both the methods. It is evident from <xref ref-type="table" rid="t3">Table 3</xref> that in general, FOGSAA provides better alignment than ACANA for all the sequences with more matches (<italic>M</italic>) and introducing lesser gaps (<italic>G</italic>). It is therefore apparent from the results that FOGSAA provides a good balance of running time and alignment quality. Some more results are included in the <xref ref-type="supplementary-material" rid="s1">Supplementary Table S2</xref> based on alignment quality for 94 pairs of real gene sequences.</p>
    </sec>
  </sec>
  <sec disp-level="1" sec-type="discussion">
    <title>Discussion</title>
    <p>Obtaining high quality sequence alignment while minimizing the running time is a challenge in bioinformatics. Though several efforts have already been made in this regard, the problem is not totally solved. When existing optimal alignment programs were found too slow, faster heuristics were developed. However these faster solutions compromised on the quality of alignment being better suited for sequences with short regions of high similarity. Not only that, the difficulty also lies in the selection of the alignment output because almost no two alignment programs (other than the optimal ones) give the same result for the same input sequences.</p>
    <p>In this article we report on the development of FOGSAA that provides optimal global alignment of a pair of sequences while being remarkably fast. The results reported in this article demonstrate that FOGSAA is effective for nucleotide sequences as well as amino acid sequences, given any scoring scheme. It can also handle affine gap penalty. Compared to the optimal NW algorithm, FOGSAA is faster by 70%–90% for sequences having high similarity, while providing the same optimal score. Compared to some heuristic alignment methods, FOGSAA provides much improved alignment with higher number of matches and smaller number of mismatches and gaps. We believe that FOGSAA is of high significance with applications covering a large number of areas in Computational Biology, as pairwise alignment is a fundamental process in sequence analysis. Most often, it is the first step in any biological analysis, which is used to identify evolutionary relationship between some novel sequences to existing ones. Use of FOGSAA can also significantly reduce the time requirement of database searches, with no reduction in the accuracy of alignment. Evidently, accuracy of the alignment affects the downstream processing tasks. Highly accurate alignments will help to uncover subtle signals embedded in the sequences, that might otherwise be missed or overlooked.</p>
    <p>In future we want to demonstrate the application of FOGSAA for analysis of Next Generation Sequencing data set<xref ref-type="bibr" rid="b20">20</xref>. We believe that the underlying technique of FOGSAA can also bring significant advancement in multiple sequence alignment methods. This is an important direction in future research. Although the effectiveness of FOGSAA is demonstrated for nucleotide and protein sequences, it is equally applicable in other domains, such as web-clustering, where the quality of alignment is of great concern.</p>
  </sec>
  <sec disp-level="1" sec-type="methods">
    <title>Methods</title>
    <p>Being a branch and bound method, FOGSAA starts its branch expansion from the root node, selecting the best child at each step and inserting the other children in the priority queue according to the values of <italic>T<sub>max</sub></italic>, using separate chained hashing technique. Hashing is a specialized technique for storing data which ensures constant time search operation in ideal scenario. In this scheme, the data are placed in a specific cell of the hash table depending on its hashed value, which is <italic>T<sub>max</sub></italic> here. Collision occurs if two or more data have the same hashed value. Separate chaining is one of the most popular collision resolution techniques where the data that has the same hashed value are placed in a chain of linked nodes. That means, all the nodes in a particular chain will always have the same <italic>T<sub>max</sub></italic> value and they are ordered by their corresponding values of <italic>T<sub>min</sub></italic>. The largest difference between <italic>T<sub>max</sub></italic> and <italic>T<sub>min</sub></italic> value provides the theoretical bound on the number of possible hashed values. This node selection procedure continues till the end of the first path (root-to-leaf path) which provides an initial alignment of the sequences. Now, FOGSAA has to check whether there is a chance of obtaining a better alignment. Note that the <italic>T<sub>max</sub></italic> value of a node is the best possible score that might be obtained by aligning along one of the branches starting from it. If the <italic>T<sub>max</sub></italic> value of the top node of the priority queue is greater than the best alignment score that is obtained so far, then there is a possibility of improving the alignment. Therefore, FOGSAA starts a new branch expansion from the corresponding node. In the middle of a branch expansion, if it comes to a node having the same (<italic>P</italic>1, <italic>P</italic>2) value as one of the existing nodes, which has already been expanded in a better way producing better <italic>PrS</italic> score, then the current branch is pruned. The process of selecting a new branch from the top node continues until the <italic>T<sub>max</sub></italic> value of top node falls below the best alignment score achieved till now. Then, FOGSAA reports the optimum alignment along with the score and the algorithm terminates.</p>
    <p>If the best possible score i.e., the <italic>T<sub>max</sub></italic> value of the top node of priority queue indicates less than 30% similarity of the input sequences, then rather than searching for the actual optimal score, FOGSAA terminates with an approximate score which is the score of the best alignment path (root-to-leaf) that has been obtained so far. The detailed method is described in Algorithm 1.</p>
    <p>In the remaining part of this section, we provide some technical insights into the working principle of FOGSAA.</p>
    <p><italic>Lemma</italic> 1. Let a node <italic>X</italic> in FOGSAA tree have Fitness Score [<italic>T<sub>max</sub>, T<sub>min</sub></italic>], then the score of its child will be [<italic>T<sub>max</sub>, T<sub>min</sub></italic> + (<italic>M</italic> − <italic>Ms</italic>)] if it makes a match, where <italic>M</italic> and <italic>Ms</italic> are the match and mismatch scores respectively.</p>
    <p><italic>Proof</italic>. For the parent node <italic>X</italic>, let (<italic>T<sub>max</sub></italic>)<italic><sub>parent</sub></italic> = <italic>PrS<sub>parent</sub></italic> + (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic>, where <italic>PrS</italic> denotes the Present Score (PrS) and (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic> = <italic>x</italic> × <italic>match</italic>_<italic>scores</italic> + <italic>y</italic> × <italic>gap</italic>_<italic>penalties</italic>, and (<italic>F<sub>min</sub></italic>)<italic><sub>parent</sub></italic> = <italic>x</italic> × <italic>mismatch</italic>_<italic>scores</italic> + <italic>y</italic> × <italic>gap</italic>_<italic>penalties</italic>. Where <italic>x</italic> is the number of matches in the best case and number of mismatches in the worst, and <italic>y</italic> is the number of gaps introduced. However, for the child: <italic>PrS<sub>child</sub></italic> = <italic>PrS<sub>parent</sub></italic> + <italic>M</italic>, as it has already made a match. Thus the future part is reduced by length one, i.e., there can be (<italic>x</italic> − 1) matches/mismatches but the gap penalties remain the same as it is proportional to the length difference of the two sequences. So, (<italic>F<sub>max</sub></italic>)<italic><sub>child</sub></italic> = (<italic>x</italic> − 1) × <italic>match</italic>_<italic>scores</italic> + <italic>y</italic> × <italic>gap</italic>_<italic>penalties</italic>, (<italic>F<sub>min</sub></italic>)<italic><sub>child</sub></italic> = (<italic>x</italic> − 1) × <italic>mismatch</italic>_<italic>scores</italic> + <italic>y</italic> × <italic>gap</italic>_<italic>penalties</italic>. Thus (<italic>F<sub>min</sub></italic>)<italic><sub>child</sub></italic> = (<italic>F<sub>min</sub></italic>)<italic><sub>parent</sub></italic> − <italic>Ms</italic>, as one mismatch is reduced and (<italic>F<sub>max</sub></italic>)<italic><sub>child</sub></italic> = (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic> − <italic>M</italic> because the child can have one less match than that of the parent. Therefore, <disp-formula id="m12"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1498" xlink:href="srep01746-m12.jpg"/></disp-formula>and <disp-formula id="m13"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1501" xlink:href="srep01746-m13.jpg"/></disp-formula><italic>Lemma</italic> 2. Let a node <italic>X</italic> in FOGSAA tree have Fitness Score [<italic>T<sub>max</sub></italic>, <italic>T<sub>min</sub></italic>], then the score of its child will be [<italic>T<sub>max</sub></italic> + (<italic>Ms</italic> − <italic>M</italic>), <italic>T<sub>min</sub></italic>] if it makes a mismatch.</p>
    <p><italic>Proof</italic>. For the parent node <italic>X</italic>, let (<italic>T<sub>max</sub></italic>)<italic><sub>parent</sub></italic> = <italic>PrS<sub>parent</sub></italic> + (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic>, and (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic> = <italic>x</italic> × <italic>match</italic>_<italic>scores</italic> + <italic>y</italic> × <italic>gap</italic>_<italic>penalties</italic>, and (<italic>F<sub>min</sub></italic>)<italic><sub>parent</sub></italic> = <italic>x</italic> × <italic>mismatch</italic>_<italic>scores</italic> + <italic>y</italic> × <italic>gap</italic>_<italic>penalties</italic>. However, for the child: <italic>PrS<sub>child</sub></italic> = <italic>PrS<sub>parent</sub></italic> + <italic>Ms</italic>, as it has already made a mismatch. Thus the future part is reduced by length one, i.e., there can be (<italic>x</italic> − 1) matches/mismatches but the gap penalties remain the same, as it is proportional to the length difference of the two sequences. So, (<italic>F<sub>max</sub></italic>)<italic><sub>child</sub></italic> = (<italic>x</italic> − 1) × <italic>match</italic>_<italic>scores</italic> + <italic>y</italic> × <italic>gap</italic>_<italic>penalties</italic>, (<italic>F<sub>min</sub></italic>)<italic><sub>child</sub></italic> = (<italic>x</italic> − 1) × <italic>mismatch</italic>_<italic>scores</italic> + <italic>y</italic> × gap_penalties. Thus (F<sub>min</sub>)<sub>child</sub> = (F<sub>min</sub>)<sub>parent</sub> − M s, as one mismatch is reduced and (<italic>F<sub>max</sub></italic>)<italic><sub>child</sub></italic> = (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic> − <italic>M</italic> because the child can have one less match than that of the parent. Therefore, <disp-formula id="m14"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1725" xlink:href="srep01746-m14.jpg"/></disp-formula>and <disp-formula id="m15"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1728" xlink:href="srep01746-m15.jpg"/></disp-formula><italic>Lemma</italic> 3. Let a node <italic>X</italic> in FOGSAA tree have Fitness Score [<italic>T<sub>max</sub></italic>, <italic>T<sub>min</sub></italic>], then the score of its child will be [<italic>T<sub>max</sub></italic>, <italic>T<sub>min</sub></italic>] or [<italic>T<sub>max</sub></italic> + (2 × <italic>G</italic> − <italic>M</italic>), <italic>T<sub>min</sub></italic> + (2 × <italic>G</italic> − <italic>Ms</italic>)], if it inserts a gap.</p>
    <p><italic>Proof</italic>. For the parent node <italic>X</italic>, let (<italic>T<sub>max</sub></italic>)<italic><sub>parent</sub></italic> = <italic>PrS<sub>parent</sub></italic> + (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic> and (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic> = <italic>x</italic> × <italic>match</italic>_<italic>scores</italic> + <italic>y</italic> × <italic>gap</italic>_<italic>penalties</italic>, (<italic>F<sub>min</sub></italic>)<italic><sub>parent</sub></italic> = <italic>x</italic> × <italic>mismatch</italic>_<italic>scores</italic> + <italic>y</italic> × <italic>gap</italic>_<italic>penalties</italic>. However, for the child: <italic>PrS<sub>child</sub></italic> = <italic>PrS<sub>parent</sub></italic> + <italic>G</italic>, where <italic>G</italic> is the gap penalty. However the gap can be inserted in any of the two sequences.</p>
    <p>Case 1: If the gap is introduced in the shorter sequence then it makes no change, as this gap is due to the length difference of the two sequences and it is already counted within ‘<italic>y</italic> gap penalties' in the parent node. The only change is that the gap has become ‘present’ now leaving <italic>y</italic> − 1 gaps in the future. So, (<italic>F<sub>max</sub></italic>)<italic><sub>child</sub></italic> = <italic>x</italic> × <italic>match_scores</italic> + (<italic>y</italic> − 1) × <italic>gap_penalties</italic>, (<italic>F<sub>min</sub></italic>)<italic><sub>child</sub></italic> = <italic>x</italic> × <italic>mismatch_scores</italic> + (<italic>y</italic> − 1) × <italic>gap_penalties</italic>. Thus (<italic>F<sub>min</sub></italic>)<italic><sub>child</sub></italic> = (<italic>F<sub>min</sub></italic>)<italic><sub>parent</sub></italic> − <italic>G</italic> and (<italic>F<sub>max</sub></italic>)<italic><sub>child</sub></italic> = (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic> − <italic>G</italic> as one gap is reduced . Therefore, <disp-formula id="m16"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1980" xlink:href="srep01746-m16.jpg"/></disp-formula>and <disp-formula id="m17"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1983" xlink:href="srep01746-m17.jpg"/></disp-formula></p>
    <p>Case 2: If the gap is introduced in the longer sequence then it is an extra gap which will always cause an insertion of another gap at some position of the shorter sequence. Hence in the future there can be (<italic>x</italic> − 1) matches/mismatches and (<italic>y</italic> + 1) gaps. So, (<italic>F<sub>max</sub></italic>)<italic><sub>child</sub></italic> = (<italic>x</italic> − 1) × <italic>match_scores</italic> + (<italic>y</italic> + 1) × <italic>gap_penalties</italic>, (<italic>F<sub>min</sub></italic>)<italic><sub>child</sub></italic> = (<italic>x</italic> − 1) × <italic>mismatch_scores</italic> + (<italic>y</italic> + 1) × <italic>gap_penalties</italic>. Thus (<italic>F<sub>min</sub></italic>)<italic><sub>child</sub></italic> = (<italic>F<sub>min</sub></italic>)<italic><sub>parent</sub></italic> − <italic>Ms</italic> + <italic>G</italic> = (<italic>F<sub>min</sub></italic>)<italic><sub>parent</sub></italic> + (<italic>G</italic> − <italic>Ms</italic>) and (<italic>F<sub>max</sub></italic>)<italic><sub>child</sub></italic> = (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic> − <italic>M</italic> + <italic>Gp</italic> = (<italic>F<sub>max</sub></italic>)<italic><sub>parent</sub></italic> + (<italic>G</italic> − <italic>M</italic>). Therefore, <disp-formula id="m18"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2118" xlink:href="srep01746-m18.jpg"/></disp-formula>and <disp-formula id="m19"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2122" xlink:href="srep01746-m19.jpg"/></disp-formula><italic>Lemma</italic> 4. The branches that are pruned by FOGSAA (Algorithm 1) will never give the optimal alignment solution.</p>
    <p><italic>Proof.</italic> The two reasons for which a branch is pruned according to Algorithm 1 are specified in the lines 12 and 17 respectively.</p>
    <p>Case 1: If the current node (say, <italic>X</italic>) of the branch has a Present Score which is smaller than the Present Score of an existing node (say, <italic>Y</italic>) having the same <italic>P</italic>1 and <italic>P</italic>2 value pair, then the current branch is pruned (Line 12 of Algorithm 1), where the <italic>P</italic>1 and <italic>P</italic>2 represents the position in the string <italic>S</italic>1 and <italic>S</italic>2 respectively. As the <italic>P</italic>1, <italic>P</italic>2 values of the nodes <italic>X</italic> and <italic>Y</italic> are same, both of them will have the same successors. Therefore, the remaining part of the alignment, for both the nodes, will be the same. Let the score of this remaining part be <italic>S</italic>. So, the actual score of the full alignment of the branch containing <italic>X</italic> is (<italic>PrS</italic>)<italic><sub>X</sub></italic> + <italic>S</italic> and similarly, the actual score of the entire branch having the node <italic>Y</italic> would be (<italic>PrS</italic>)<italic><sub>Y</sub></italic> + <italic>S</italic>. As (<italic>PrS</italic>)<italic><sub>X</sub></italic> ≤ (<italic>PrS</italic>)<italic><sub>Y</sub></italic>, the branch containing <italic>X</italic> node cannot give better alignment than the branch having node <italic>Y</italic>. Therefore, if this branch of node <italic>X</italic> is pruned, it will not affect the optimal solution.</p>
    <p>Case 2: If the <italic>T<sub>max</sub></italic> value of the current node (say, <italic>Z</italic>) of a branch is less than the optimal score which has been obtained so far (say, along branch <italic>B</italic>1), then this branch is pruned [Line 17 of Algorithm 1]. Note that, the <italic>T<sub>max</sub></italic> value of a node is the best possible score that might be obtained by aligning along one of the branches starting from it. So, a node cannot achieve an alignment having score better than <italic>T<sub>max</sub></italic>. Therefore, even if we expand the branch containing node <italic>Z</italic>, it cannot ever produce an alignment better than <italic>B</italic>1. Hence, the branch which is pruned here will never give the optimal alignment, as at least one better solution has already been found.</p>
    <p><italic>Corollary</italic> 1. Let a node <italic>X</italic> in FOGSAA tree have three children <italic>X</italic>1, <italic>X</italic>2, <italic>X</italic>3, then the child having a match or a gap in the shorter sequence, is always the best child according to the Fitness Score(<italic>T<sub>max</sub></italic>).</p>
    <p><italic>Proof.</italic> Let the node <italic>X</italic> have (<italic>P</italic>1, <italic>P</italic>2) = (<italic>i</italic>, <italic>j</italic>), then its children <italic>X</italic>1, <italic>X</italic>2, <italic>X</italic>3 will have values (<italic>i</italic> + 1, <italic>j</italic> + 1), (<italic>i</italic> + 1, <italic>j</italic>), (<italic>i</italic>, <italic>j</italic> + 1) respectively. The node <italic>X</italic>1 can have either a match or a mismatch depending upon the symbol at that position of the two sequences. But <italic>X</italic>2 and <italic>X</italic>3 will always have a gap. If <italic>X</italic> has Fitness Score value [<italic>T<sub>max</sub></italic>, <italic>T<sub>min</sub></italic>], then according to Lemma 1 and 2, <italic>X</italic>1 will have [<italic>T<sub>max</sub></italic>, <italic>T<sub>min</sub></italic> + (<italic>M</italic> − <italic>Ms</italic>)] if it's a match, and [<italic>T<sub>max</sub></italic> + (<italic>Ms</italic> − <italic>M</italic>), <italic>T<sub>min</sub></italic>] otherwise. <italic>X</italic>2 and <italic>X</italic>3 will have Fitness Score [<italic>T<sub>max</sub></italic>, <italic>T<sub>min</sub></italic>] or [<italic>T<sub>max</sub></italic> + (2 × <italic>G</italic> − <italic>M</italic>), <italic>T<sub>min</sub></italic> + (2 × <italic>G</italic> − <italic>Ms</italic>)], for the two different cases as specified in Lemma 3. As <italic>M</italic> &gt; 0, <italic>Ms</italic> &lt; 0, <italic>G</italic> &lt; 0 and usually <italic>G</italic> &lt; <italic>Ms</italic>, it is obvious that the child with a match or a gap in the shorter sequence has the highest <italic>T<sub>max</sub></italic> value, and hence it is most promising.</p>
    <sec disp-level="2">
      <title>Proof of Correctness of FOGSAA</title>
      <p>Given a pair of input sequences that have more than 30% similarity, the alignment score provided by FOGSAA is optimal for the given scoring scheme.</p>
      <p>We will prove this by the method of contradiction. Let us consider the following two cases:</p>
      <p>Case 1: Without affine gap: Let us assume that the alignment reported by FOGSAA is not optimal. Say <italic>B</italic> is the branch corresponding to the non-optimal alignment provided by FOGSAA on termination. Also assume that there is another branch <inline-formula id="m20"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2457" xlink:href="srep01746-m20.jpg"/></inline-formula> which leads to the optimal alignment. Let <italic>X</italic> and <inline-formula id="m21"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2463" xlink:href="srep01746-m21.jpg"/></inline-formula> be the terminal (leaf) nodes of the branches <italic>B</italic> and <inline-formula id="m22"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2470" xlink:href="srep01746-m22.jpg"/></inline-formula> respectively. At a leaf, there is no Future Score, hence <inline-formula id="m23"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2473" xlink:href="srep01746-m23.jpg"/></inline-formula> and (<italic>PrS</italic>)<italic><sub>X</sub></italic> = (<italic>T<sub>max</sub></italic>)<italic><sub>X</sub></italic>. Since <inline-formula id="m24"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2493" xlink:href="srep01746-m24.jpg"/></inline-formula> is the leaf on the optimal branch <inline-formula id="m25"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2496" xlink:href="srep01746-m25.jpg"/></inline-formula> while <italic>X</italic> is the leaf on the non-optimal branch <italic>B</italic>, so <inline-formula id="m26"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2505" xlink:href="srep01746-m26.jpg"/></inline-formula>. Obviously the <italic>T<sub>max</sub></italic> values of the ancestors of <inline-formula id="m27"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2514" xlink:href="srep01746-m27.jpg"/></inline-formula> is greater than or equal to <inline-formula id="m28"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2517" xlink:href="srep01746-m28.jpg"/></inline-formula>, since while the ancestors overestimate the <italic>T<sub>max</sub></italic> values,the value at the leaf reflects the actual alignment score [The scores of a branch become accurate as the Algorithm 1 moves down through it and makes the modification of scores as specified in the lines 15,16 of Algorithm 1]. Consequently, the <italic>T<sub>max</sub></italic> values of the ancestors of <inline-formula id="m29"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2530" xlink:href="srep01746-m29.jpg"/></inline-formula> are all greater than (<italic>PrS</italic>)<italic><sub>X</sub></italic> as <inline-formula id="m30"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2541" xlink:href="srep01746-m30.jpg"/></inline-formula>. Moreover, as FOGSAA has not expanded the branch <inline-formula id="m31"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2544" xlink:href="srep01746-m31.jpg"/></inline-formula>, as per out assumption, at least one of the ancestor nodes of <inline-formula id="m32"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2547" xlink:href="srep01746-m32.jpg"/></inline-formula> are still there in the priority queue because Algorithm 1 inserts the current node in the priority queue according to the <italic>T<sub>max</sub></italic> values of its best child (Line no.9 of Algorithm 1). That means, the top node of the priority queue has a <italic>T<sub>max</sub></italic> value which is greater than (<italic>PrS</italic>)<italic><sub>X</sub></italic>. But there cannot be any such node because FOGSAA stops only when the <italic>T<sub>max</sub></italic> value of top node of the priority queue becomes smaller than the <italic>PrS</italic> value of its best branch i.e., the optimal score obtained so far (See the loop termination condition of Algorithm 1, line 25). Hence our initial assumption that FOGSAA terminates with a non-optimal alignment, is wrong. Therefore, if FOGSAA has terminated with an alignment along branch <italic>B</italic>, then there can be no branch <inline-formula id="m33"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e2579" xlink:href="srep01746-m33.jpg"/></inline-formula> providing better score than <italic>B</italic>.</p>
      <p>Case 2: With affine gap: When the scoring scheme includes affine gap penalty, then also the branch expansion and termination strategy of FOGSAA remains the same. Only the way <italic>T<sub>max</sub></italic> is being calculated, is different. Here also <italic>T<sub>max</sub></italic> shows the best possible score, but the gap penalties are computed using the formula (<italic>Go</italic> + <italic>L</italic> × <italic>Ge</italic>) where <italic>L</italic> is the gap length. As the inherent technique remains same, it can be shown in the same way that there cannot be any other branch producing better alignment than the one provided by FOGSAA.</p>
      <p>Thus, FOGSAA is correct and always outputs the optimal alignment.</p>
    </sec>
    <sec disp-level="2">
      <title>Proof of termination of FOGSAA</title>
      <p>In the best case, FOGSAA terminates after the expansion of the first branch if the <italic>T<sub>max</sub></italic> value of the top node of the priority queue becomes smaller than the best alignment score obtained so far. Otherwise, it starts expanding a new branch from the top node. This process continues until either <italic>T<sub>max</sub></italic> value of top node falls below the optimal score obtained so far, or the queue becomes empty i.e., all possible paths have been checked. If the given sequences are of length <italic>m</italic> and <italic>n</italic>, then there can be no more than <italic>m</italic> × <italic>n</italic> nodes. Again, each node can be pushed into the queue only once. Therefore, even if FOGSAA checks all the nodes of the queue, it will terminate in <italic>O</italic>(<italic>m</italic> × <italic>n</italic>) time, which is finite. Hence, FOGSAA terminates within a finite amount of time.</p>
    </sec>
    <sec disp-level="2">
      <title>Proof of Completeness of FOGSAA</title>
      <p>It is quite obvious that FOGSAA is applicable for any sequence over a finite alphabet. Just the scoring matrix for this alphabet needs to be defined. This justifies the completeness property of FOGSAA.</p>
    </sec>
    <sec disp-level="2">
      <title>Algorithm 1: FOGSAA</title>
      <p><bold>Input:</bold> A pair of DNA or protein sequence <italic>S</italic>1 and <italic>S</italic>2.</p>
      <p><bold>Output:</bold> Optimal alignment of given sequence pair having ≥ 30% similarity. Otherwise it terminates with an approximate alignment and score.</p>
      <p>
        <bold>Data Structure:</bold>
      </p>
      <p>c[i][j]: The node of FOGSAA tree having <italic>P</italic>1 = <italic>i</italic> and <italic>P</italic>2 = <italic>j</italic>.</p>
      <p>Priority queue: Stores the nodes of FOGSAA tree for future expansion based on their Fitness Score, using separate-chained hashing. (See the Method section for a discussion).</p>
      <p>|<italic>S</italic>1| = <italic>m</italic> and |<italic>S</italic>2| = <italic>n</italic>, <italic>P</italic>1 = 0, <italic>P</italic>2 = 0, <italic>c</italic>[0, 0]. <italic>PrS</italic> = 0, <italic>optimal</italic> = <italic>c</italic>[0, 0]. <italic>T<sub>min</sub></italic></p>
      <p><bold>if</bold><italic>m</italic> ≠ 0 AND <italic>n</italic> ≠ 0 <bold>then</bold></p>
      <p>
        <bold>repeat</bold>
      </p>
      <p><bold>while</bold><italic>P</italic>1 ≤ (<italic>m</italic> − 1) OR <italic>P</italic>2 ≤ (<italic>n</italic> − 1) <bold>do</bold></p>
      <p>Select the best child from the remaining children according to the <italic>T<sub>max</sub></italic>.</p>
      <p>Let the corresponding <italic>P</italic>1, <italic>P</italic>2 values of the selected child be <italic>x</italic> and <italic>y</italic> respectively.</p>
      <p><bold>if</bold> any child of the current node remains to be expanded <bold>then</bold></p>
      <p>insert the current node in the priority queue according to the <italic>T<sub>max</sub></italic> score of the next better child.</p>
      <p>
        <bold>end if</bold>
      </p>
      <p><bold>if</bold><italic>child_node.PrS</italic> ≤ <italic>c</italic>[<italic>x</italic>, <italic>y</italic>].<italic>PrS</italic>
<bold>then</bold></p>
      <p>Prune the current branch, as it has already been traversed in a better way.</p>
      <p>
        <bold>else</bold>
      </p>
      <p><italic>c</italic>[<italic>child_node</italic>] ← <italic>new_score</italic></p>
      <p><italic>P</italic>1 ← <italic>x</italic>, <italic>P</italic>2 ← <italic>y</italic></p>
      <p><bold>if</bold><italic>child_node.T<sub>max</sub></italic> ≤ <italic>optimal</italic>
<bold>then</bold></p>
      <p>Prune the current branch. The <italic>T<sub>max</sub></italic> of a node shows the maximum score that the branch can achieve and if this max value is smaller than the optimal branch score obtained so far, then it can not ever lead to the optimal solution.</p>
      <p>
        <bold>end if</bold>
      </p>
      <p>
        <bold>end if</bold>
      </p>
      <p>
        <bold>end while</bold>
      </p>
      <p><bold>if</bold><italic>c</italic>[<italic>P</italic>1, <italic>P</italic>2].<italic>T<sub>max</sub></italic> ≥ <italic>optimal</italic>
<bold>then</bold></p>
      <p><italic>optimal</italic> = <italic>c</italic>[<italic>P</italic>1, <italic>P</italic>2].<italic>T<sub>max</sub></italic> and set the current path as the optimal one.</p>
      <p>
        <bold>end if</bold>
      </p>
      <p>pick the top most node from the priority queue and update new <italic>T<sub>max</sub></italic>.</p>
      <p><bold>if</bold> The top most node has <italic>T<sub>max</sub></italic> such that it cannot have more than 30% similarity <bold>then</bold></p>
      <p>end the process and report approximate score.</p>
      <p>
        <bold>end if</bold>
      </p>
      <p><bold>until</bold><italic>optimal</italic> ≥ new <italic>T<sub>max</sub></italic></p>
      <p>
        <bold>end if</bold>
      </p>
    </sec>
  </sec>
  <sec disp-level="1">
    <title>Author Contributions</title>
    <p>A.C. developed the idea, carried out the work, wrote the main text, prepared the Figures 1–5 and the software tool for FOGSAA. S.B. conceived of the study, planned the work, provided laboratory facilities and wrote the manuscript. Both authors reviewed the manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material" id="s1">
    <title>Supplementary Material</title>
    <supplementary-material id="d33e61" content-type="local-data">
      <caption>
        <title>Supplementary Information</title>
        <p>Supplementary of FOGSAA</p>
      </caption>
      <media xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="srep01746-s1.doc" mimetype="application" mime-subtype="msword"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <p>Prof. Sanghamitra Bandyopadhyay acknowledges the Swarnajayanti Fellowship scheme of Department of Science and Technology, Government of India (No.DST/SJF/ET-02/2006-07).</p>
  </ack>
  <ref-list>
    <ref id="b1">
      <mixed-citation publication-type="journal"><name><surname>Smith</surname><given-names>T. F.</given-names></name> &amp; <name><surname>Waterman</surname><given-names>M. S.</given-names></name>
<article-title>Identification of Common Molecular Subsequences</article-title>. <source>J. Mol. Biol.</source>
<volume>147</volume>, <fpage>195</fpage>–<lpage>197</lpage> (<year>1981</year>).<pub-id pub-id-type="pmid">7265238</pub-id></mixed-citation>
    </ref>
    <ref id="b2">
      <mixed-citation publication-type="journal"><name><surname>Pearson</surname><given-names>W. R.</given-names></name> &amp; <name><surname>Lipman</surname><given-names>D.</given-names></name>
<article-title>Improved tools for biological sequence comparison</article-title>. <source>Proc. Natl Acad. Sci. USA</source>
<volume>85</volume>, <fpage>2444</fpage>–<lpage>2448</lpage> (<year>1988</year>).<pub-id pub-id-type="pmid">3162770</pub-id></mixed-citation>
    </ref>
    <ref id="b3">
      <mixed-citation publication-type="journal"><name><surname>Altschul</surname><given-names>S. F.</given-names></name>, <name><surname>Gish</surname><given-names>W.</given-names></name>, <name><surname>Miller</surname><given-names>W.</given-names></name>, <name><surname>Myers</surname><given-names>E. W.</given-names></name> &amp; <name><surname>Lipman</surname><given-names>D. J.</given-names></name>
<article-title>Basic local alignment search tool</article-title>. <source>J. Mol. Biology</source>
<volume>215</volume>, <fpage>403</fpage>–<lpage>410</lpage> (<year>1990</year>).</mixed-citation>
    </ref>
    <ref id="b4">
      <mixed-citation publication-type="journal"><name><surname>Huang</surname><given-names>X.</given-names></name> &amp; <name><surname>Miller</surname><given-names>W.</given-names></name>
<article-title>A time-efficient, linear-space local similarity algorithm</article-title>. <source>Adv. Appl. Math</source>
<volume>12</volume>, <fpage>337</fpage>–<lpage>357</lpage> (<year>1991</year>).</mixed-citation>
    </ref>
    <ref id="b5">
      <mixed-citation publication-type="journal"><name><surname>Huang</surname><given-names>X.</given-names></name><article-title>On global sequence alignment</article-title>. <source>Comput Appl Biosci</source><volume>10</volume>(3), <fpage>227</fpage>–<lpage>235</lpage> (<year>1994</year>).<pub-id pub-id-type="pmid">7922677</pub-id></mixed-citation>
    </ref>
    <ref id="b6">
      <mixed-citation publication-type="journal"><name><surname>Chenna</surname><given-names>R.</given-names></name><italic>et al.</italic><article-title>Multiple sequence alignment with the Clustal series of programs</article-title>. <source>Nucleic Acid Research</source><volume>31</volume>(13), <fpage>3497</fpage>–<lpage>3500</lpage> (<year>2003</year>).</mixed-citation>
    </ref>
    <ref id="b7">
      <mixed-citation publication-type="journal"><name><surname>Mural</surname><given-names>R.</given-names></name><italic>et al.</italic><article-title>A comparison of whole genome shotgun-derived mouse chromosome 16 and the human genome</article-title>. <source>Science</source><volume>296</volume>, <fpage>1667</fpage>–<lpage>1671</lpage> (<year>2002</year>).</mixed-citation>
    </ref>
    <ref id="b8">
      <mixed-citation publication-type="journal"><name><surname>Needleman</surname><given-names>S. B.</given-names></name> &amp; <name><surname>Wunsch</surname><given-names>C. D. A.</given-names></name>
<article-title>general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>. <source>J. Mol. Biol.</source>
<volume>48</volume>, <fpage>443</fpage>–<lpage>453</lpage> (<year>1970</year>).<pub-id pub-id-type="pmid">5420325</pub-id></mixed-citation>
    </ref>
    <ref id="b9">
      <mixed-citation publication-type="journal"><name><surname>Huang</surname><given-names>X.</given-names></name> &amp; <name><surname>Chao</surname><given-names>K. A.</given-names></name>
<article-title>generalized global alignment algorithm</article-title>. <source>Bioinformatics</source>
<volume>19</volume>, <fpage>228</fpage>–<lpage>233</lpage> (<year>2003</year>).<pub-id pub-id-type="pmid">12538243</pub-id></mixed-citation>
    </ref>
    <ref id="b10">
      <mixed-citation publication-type="journal"><name><surname>Huang</surname><given-names>W.</given-names></name>, <name><surname>Umbach</surname><given-names>D. M.</given-names></name> &amp; <name><surname>Li</surname><given-names>L.</given-names></name>
<article-title>Accurate anchoring alignment of divergent sequences</article-title>. <source>Bioinformatics</source>
<volume>22</volume>, <fpage>29</fpage>–<lpage>34</lpage> (<year>2006</year>).<pub-id pub-id-type="pmid">16301203</pub-id></mixed-citation>
    </ref>
    <ref id="b11">
      <mixed-citation publication-type="journal"><name><surname>Bray</surname><given-names>N.</given-names></name>, <name><surname>Dubchak</surname><given-names>I.</given-names></name> &amp; <name><surname>Pachter</surname><given-names>L.</given-names></name>
<article-title>AVID : A Global Alignment Program</article-title>. <source>Genome Res.</source>
<volume>13</volume>, <fpage>97</fpage>–<lpage>102</lpage> (<year>2003</year>).<pub-id pub-id-type="pmid">12529311</pub-id></mixed-citation>
    </ref>
    <ref id="b12">
      <mixed-citation publication-type="journal"><name><surname>Thompson</surname><given-names>J. D.</given-names></name><italic>et al.</italic><article-title>CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice</article-title>. <source>Nucleic Acids Res.</source><volume>22</volume>, <fpage>4673</fpage>–<lpage>4680</lpage> (<year>1994</year>).<pub-id pub-id-type="pmid">7984417</pub-id></mixed-citation>
    </ref>
    <ref id="b13">
      <mixed-citation publication-type="journal"><name><surname>Schwartz</surname><given-names>S.</given-names></name><italic>et al.</italic><article-title>Human-mouse alignment with BLASTZ</article-title>. <source>Genome Research</source><volume>13</volume>, <fpage>103</fpage>–<lpage>107</lpage> (<year>2003</year>).<pub-id pub-id-type="pmid">12529312</pub-id></mixed-citation>
    </ref>
    <ref id="b14">
      <mixed-citation publication-type="journal"><name><surname>Delcher</surname><given-names>A. L.</given-names></name><italic>et al.</italic><article-title>Fast algorithms for large scale genome alignmentand comparison</article-title>. <source>Nucleic Acid Res.</source><volume>30</volume>, <fpage>2478</fpage>–<lpage>2483</lpage> (<year>2002</year>).<pub-id pub-id-type="pmid">12034836</pub-id></mixed-citation>
    </ref>
    <ref id="b15">
      <mixed-citation publication-type="journal"><name><surname>Brudno</surname><given-names>M.</given-names></name><italic>et al.</italic><article-title>LAGAN and Multi-LAGAN: efficient tools for large scale multiple alignment of genomic DNA</article-title>. <source>Genome Res.</source><volume>13</volume>, <fpage>721</fpage>–<lpage>731</lpage> (<year>2003</year>).<pub-id pub-id-type="pmid">12654723</pub-id></mixed-citation>
    </ref>
    <ref id="b16">
      <mixed-citation publication-type="journal"><name><surname>Pollard</surname><given-names>D.</given-names></name>, <name><surname>Bergman</surname><given-names>C.</given-names></name>, <name><surname>Stoye</surname><given-names>J.</given-names></name>, <name><surname>Celniker</surname><given-names>S.</given-names></name> &amp; <name><surname>Eisen</surname><given-names>M.</given-names></name>
<article-title>Benchmarking tools for the alignment of functional noncoding DNA</article-title>. <source>BMC Bioinformatics</source>
<volume>5(1)</volume> (<year>2004</year>).</mixed-citation>
    </ref>
    <ref id="b17">
      <mixed-citation publication-type="journal"><name><surname>Gotoh</surname><given-names>O.</given-names></name><article-title>An improved algorithm for matching biological sequences</article-title>. <source>Journal of Molecular Biology</source><volume>162</volume>(3), <fpage>705</fpage>–<lpage>708</lpage> (<year>1990</year>).<pub-id pub-id-type="pmid">7166760</pub-id></mixed-citation>
    </ref>
    <ref id="b18">
      <mixed-citation publication-type="book"><name><surname>Thakoor</surname><given-names>N.</given-names></name> &amp; <name><surname>Devarajan</surname><given-names>V.</given-names></name>
<article-title>Computation Complexity of Branch-and-Bound Model Selection</article-title>. <source>IEEE 12th International Conference on Computer Vision (ICCV)</source> (<year>2009</year>).</mixed-citation>
    </ref>
    <ref id="b19">
      <mixed-citation publication-type="journal"><name><surname>Zhang</surname><given-names>W.</given-names></name> &amp; <name><surname>Korf</surname><given-names>R. E.</given-names></name>
<article-title>An average case analysis of Branch and Bound with applications :Summary of results</article-title>. <source>AAAI-92 Proceedings</source> (<year>1992</year>).</mixed-citation>
    </ref>
    <ref id="b20">
      <mixed-citation publication-type="journal"><name><surname>Rizk</surname><given-names>G.</given-names></name> &amp; <name><surname>Lavenier</surname><given-names>D.</given-names></name>
<article-title>GASSST: global alignment short sequence search tool</article-title>. <source>Bioinformatics</source>
<volume>26</volume>, <fpage>2534</fpage>–<lpage>2540</lpage> (<year>2010</year>).<pub-id pub-id-type="pmid">20739310</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<floats-group>
  <fig id="f1">
    <label>Figure 1</label>
    <caption>
      <title>FOGSAA workflow : The basic working principle of FOGSAA is descried through flow-chart.</title>
    </caption>
    <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="srep01746-f1"/>
  </fig>
  <fig id="f2">
    <label>Figure 2</label>
    <caption>
      <title>FOGSAA tree: partially computed for the sequences <italic>S</italic>1 = <italic>ACGGTTGC</italic> and <italic>S</italic>2 = <italic>AGCGTC</italic>, having <italic>m</italic> = |<italic>S</italic>1| = 8 and <italic>n</italic> = |<italic>S</italic>2| = 6.</title>
      <p>Each node is annotated with (<italic>P</italic>1, <italic>P</italic>2) on the left and [<italic>T<sub>max</sub></italic>, <italic>T<sub>min</sub></italic>] on the right. The label of a node indicates the symbol pairs that are being aligned.</p>
    </caption>
    <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="srep01746-f2"/>
  </fig>
  <fig id="f3">
    <label>Figure 3</label>
    <caption>
      <title>Time comparison between Needleman-Wunsch, GAP3 and FOGSAA for sequences having &gt; 80% similarity.</title>
    </caption>
    <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="srep01746-f3"/>
  </fig>
  <fig id="f4">
    <label>Figure 4</label>
    <caption>
      <title>Time comparison between Needleman-Wunsch, GAP3 and FOGSAA for sequences having (30 – 80)% similarity.</title>
    </caption>
    <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="srep01746-f4"/>
  </fig>
  <fig id="f5">
    <label>Figure 5</label>
    <caption>
      <title>Time gain of FOGSAA over Needleman-Wunsch for protein sequence alignment with affine gap penalty.</title>
    </caption>
    <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="srep01746-f5"/>
  </fig>
  <table-wrap position="float" id="t1">
    <label>Table 1</label>
    <caption>
      <title>Comparative study for sequences having &lt; 30% similarity, where FOGSAA detects the low similarity and terminates with an approximate score</title>
    </caption>
    <table frame="hsides" rules="groups" border="1">
      <colgroup>
        <col align="left"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
      </colgroup>
      <thead valign="bottom">
        <tr>
          <th colspan="2" align="center" valign="top" charoff="50">Seq Length</th>
          <th colspan="2" align="center" valign="top" charoff="50">Score</th>
          <th colspan="3" align="center" valign="top" charoff="50">Time in msec</th>
        </tr>
      </thead>
      <tbody valign="top">
        <tr>
          <td align="center" valign="top" charoff="50">Len1</td>
          <td align="center" valign="top" charoff="50">Len2</td>
          <td align="center" valign="top" charoff="50">Optimal</td>
          <td align="center" valign="top" charoff="50">FOGSAA</td>
          <td align="center" valign="top" charoff="50">FOGSAA</td>
          <td align="center" valign="top" charoff="50">NW</td>
          <td align="center" valign="top" charoff="50">GAP3</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">87</td>
          <td align="char" valign="top" char="." charoff="50">903</td>
          <td align="center" valign="top" charoff="50">−1545</td>
          <td align="center" valign="top" charoff="50">−1545</td>
          <td align="char" valign="top" char="." charoff="50">2</td>
          <td align="char" valign="top" char="." charoff="50">56</td>
          <td align="char" valign="top" char="." charoff="50">20</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">1145</td>
          <td align="char" valign="top" char="." charoff="50">2616</td>
          <td align="center" valign="top" charoff="50">−2167</td>
          <td align="center" valign="top" charoff="50">−2905</td>
          <td align="char" valign="top" char="." charoff="50">11</td>
          <td align="char" valign="top" char="." charoff="50">1505</td>
          <td align="char" valign="top" char="." charoff="50">370</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">2667</td>
          <td align="char" valign="top" char="." charoff="50">7643</td>
          <td align="center" valign="top" charoff="50">−7523</td>
          <td align="center" valign="top" charoff="50">−8847</td>
          <td align="char" valign="top" char="." charoff="50">28</td>
          <td align="char" valign="top" char="." charoff="50">10161</td>
          <td align="char" valign="top" char="." charoff="50">2450</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">3359</td>
          <td align="char" valign="top" char="." charoff="50">12891</td>
          <td align="center" valign="top" charoff="50">−15789</td>
          <td align="center" valign="top" charoff="50">−16877</td>
          <td align="char" valign="top" char="." charoff="50">40</td>
          <td align="char" valign="top" char="." charoff="50">21575</td>
          <td align="char" valign="top" char="." charoff="50">5144</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">11376</td>
          <td align="char" valign="top" char="." charoff="50">2529478</td>
          <td align="center" valign="top" charoff="50">Unknown</td>
          <td align="center" valign="top" charoff="50">−5024828</td>
          <td align="char" valign="top" char="." charoff="50">1463</td>
          <td align="center" valign="top" charoff="50">—</td>
          <td align="center" valign="top" charoff="50">—</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap position="float" id="t2">
    <label>Table 2</label>
    <caption>
      <title>Time comparison between Needleman-Wunsch and FOGSAA for gene sequences using different scoring schemes with and without affine gap penalty. M: Match Score, Ms: Mismatch Score, Gp: Gap penalty in the non-affine case, Go and Ge: Gap open and extension penalties in the affine case</title>
    </caption>
    <table frame="hsides" rules="groups" border="1">
      <colgroup>
        <col align="left"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
      </colgroup>
      <thead valign="bottom">
        <tr>
          <th align="left" valign="top" charoff="50"> </th>
          <th align="center" valign="top" charoff="50"> </th>
          <th align="center" valign="top" charoff="50"> </th>
          <th align="center" valign="top" charoff="50"> </th>
          <th colspan="3" align="center" valign="top" charoff="50">Gap Penalty</th>
          <th colspan="2" align="center" valign="top" charoff="50">Mean Time in msec</th>
        </tr>
        <tr>
          <th align="left" valign="top" charoff="50">Scheme #</th>
          <th align="center" valign="top" charoff="50">M</th>
          <th align="center" valign="top" charoff="50">Ms</th>
          <th align="center" valign="top" charoff="50">Affine-Gap</th>
          <th align="center" valign="top" charoff="50">Gp</th>
          <th align="center" valign="top" charoff="50">Go</th>
          <th align="center" valign="top" charoff="50">Ge</th>
          <th align="center" valign="top" charoff="50">FOGSAA</th>
          <th align="center" valign="top" charoff="50">NW</th>
        </tr>
      </thead>
      <tbody valign="top">
        <tr>
          <td align="center" valign="top" charoff="50">1</td>
          <td align="char" valign="top" char="." charoff="50">5</td>
          <td align="center" valign="top" charoff="50">−2</td>
          <td align="center" valign="top" charoff="50">N</td>
          <td align="center" valign="top" charoff="50">−10</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">539</td>
          <td align="center" valign="top" charoff="50">5091</td>
        </tr>
        <tr>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="center" valign="top" charoff="50">Y</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">−10</td>
          <td align="center" valign="top" charoff="50">−2</td>
          <td align="center" valign="top" charoff="50">615</td>
          <td align="center" valign="top" charoff="50">5300</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">2</td>
          <td align="char" valign="top" char="." charoff="50">10</td>
          <td align="center" valign="top" charoff="50">−5</td>
          <td align="center" valign="top" charoff="50">N</td>
          <td align="center" valign="top" charoff="50">−15</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">733</td>
          <td align="center" valign="top" charoff="50">5068</td>
        </tr>
        <tr>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="center" valign="top" charoff="50">Y</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">−10</td>
          <td align="center" valign="top" charoff="50">−2</td>
          <td align="center" valign="top" charoff="50">530</td>
          <td align="center" valign="top" charoff="50">5330</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">3</td>
          <td align="char" valign="top" char="." charoff="50">12</td>
          <td align="center" valign="top" charoff="50">−6</td>
          <td align="center" valign="top" charoff="50">N</td>
          <td align="center" valign="top" charoff="50">−20</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">417</td>
          <td align="center" valign="top" charoff="50">5074</td>
        </tr>
        <tr>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="center" valign="top" charoff="50">Y</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">−10</td>
          <td align="center" valign="top" charoff="50">−2</td>
          <td align="center" valign="top" charoff="50">402</td>
          <td align="center" valign="top" charoff="50">5240</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">4</td>
          <td align="char" valign="top" char="." charoff="50">20</td>
          <td align="center" valign="top" charoff="50">−10</td>
          <td align="center" valign="top" charoff="50">N</td>
          <td align="center" valign="top" charoff="50">−40</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">677</td>
          <td align="center" valign="top" charoff="50">5184</td>
        </tr>
        <tr>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="center" valign="top" charoff="50">Y</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">−40</td>
          <td align="center" valign="top" charoff="50">−15</td>
          <td align="center" valign="top" charoff="50">782</td>
          <td align="center" valign="top" charoff="50">5649</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">5</td>
          <td align="char" valign="top" char="." charoff="50">30</td>
          <td align="center" valign="top" charoff="50">−20</td>
          <td align="center" valign="top" charoff="50">N</td>
          <td align="center" valign="top" charoff="50">−55</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">789</td>
          <td align="center" valign="top" charoff="50">5484</td>
        </tr>
        <tr>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="left" valign="top" charoff="50"> </td>
          <td align="center" valign="top" charoff="50">Y</td>
          <td align="center" valign="top" charoff="50">X</td>
          <td align="center" valign="top" charoff="50">−60</td>
          <td align="center" valign="top" charoff="50">−25</td>
          <td align="center" valign="top" charoff="50">807</td>
          <td align="center" valign="top" charoff="50">5888</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap position="float" id="t3">
    <label>Table 3</label>
    <caption>
      <title>Comparative Study for alignment quality on gene sequences containing human-mouse orthologs using the scoring scheme where M = +1, Ms = −1 and Gp = −2</title>
    </caption>
    <table frame="hsides" rules="groups" border="1">
      <colgroup>
        <col align="left"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
        <col align="center"/>
      </colgroup>
      <thead valign="bottom">
        <tr>
          <th align="left" valign="top" charoff="50"> </th>
          <th colspan="3" align="center" valign="top" charoff="50">FOGSAA</th>
          <th colspan="3" align="center" valign="top" charoff="50">ACANA</th>
        </tr>
        <tr>
          <th align="center" valign="top" charoff="50">Seq #</th>
          <th align="center" valign="top" charoff="50">
            <italic>#Match</italic>
          </th>
          <th align="center" valign="top" charoff="50">
            <italic>#Mismatch</italic>
          </th>
          <th align="center" valign="top" charoff="50">
            <italic>#Gap</italic>
          </th>
          <th align="center" valign="top" charoff="50">
            <italic>#Match</italic>
          </th>
          <th align="center" valign="top" charoff="50">
            <italic>#Mismatch</italic>
          </th>
          <th align="center" valign="top" charoff="50">
            <italic>#Gap</italic>
          </th>
        </tr>
      </thead>
      <tbody valign="top">
        <tr>
          <td align="center" valign="top" charoff="50">1.</td>
          <td align="char" valign="top" char="." charoff="50">1916</td>
          <td align="char" valign="top" char="." charoff="50">841</td>
          <td align="char" valign="top" char="." charoff="50">492</td>
          <td align="char" valign="top" char="." charoff="50">1277</td>
          <td align="char" valign="top" char="." charoff="50">890</td>
          <td align="char" valign="top" char="." charoff="50">1672</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">2.</td>
          <td align="char" valign="top" char="." charoff="50">1243</td>
          <td align="char" valign="top" char="." charoff="50">808</td>
          <td align="char" valign="top" char="." charoff="50">3123</td>
          <td align="char" valign="top" char="." charoff="50">1244</td>
          <td align="char" valign="top" char="." charoff="50">643</td>
          <td align="char" valign="top" char="." charoff="50">3451</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">3.</td>
          <td align="char" valign="top" char="." charoff="50">1872</td>
          <td align="char" valign="top" char="." charoff="50">383</td>
          <td align="char" valign="top" char="." charoff="50">1259</td>
          <td align="char" valign="top" char="." charoff="50">1273</td>
          <td align="char" valign="top" char="." charoff="50">754</td>
          <td align="char" valign="top" char="." charoff="50">1715</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">4.</td>
          <td align="char" valign="top" char="." charoff="50">946</td>
          <td align="char" valign="top" char="." charoff="50">495</td>
          <td align="char" valign="top" char="." charoff="50">2360</td>
          <td align="char" valign="top" char="." charoff="50">879</td>
          <td align="char" valign="top" char="." charoff="50">481</td>
          <td align="char" valign="top" char="." charoff="50">2522</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">5.</td>
          <td align="char" valign="top" char="." charoff="50">1128</td>
          <td align="char" valign="top" char="." charoff="50">191</td>
          <td align="char" valign="top" char="." charoff="50">1029</td>
          <td align="char" valign="top" char="." charoff="50">978</td>
          <td align="char" valign="top" char="." charoff="50">334</td>
          <td align="char" valign="top" char="." charoff="50">1043</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">6.</td>
          <td align="char" valign="top" char="." charoff="50">1682</td>
          <td align="char" valign="top" char="." charoff="50">426</td>
          <td align="char" valign="top" char="." charoff="50">911</td>
          <td align="char" valign="top" char="." charoff="50">1330</td>
          <td align="char" valign="top" char="." charoff="50">508</td>
          <td align="char" valign="top" char="." charoff="50">1451</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">7.</td>
          <td align="char" valign="top" char="." charoff="50">1638</td>
          <td align="char" valign="top" char="." charoff="50">482</td>
          <td align="char" valign="top" char="." charoff="50">330</td>
          <td align="char" valign="top" char="." charoff="50">1408</td>
          <td align="char" valign="top" char="." charoff="50">690</td>
          <td align="char" valign="top" char="." charoff="50">374</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">8.</td>
          <td align="char" valign="top" char="." charoff="50">757</td>
          <td align="char" valign="top" char="." charoff="50">259</td>
          <td align="char" valign="top" char="." charoff="50">209</td>
          <td align="char" valign="top" char="." charoff="50">599</td>
          <td align="char" valign="top" char="." charoff="50">371</td>
          <td align="char" valign="top" char="." charoff="50">301</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">9.</td>
          <td align="char" valign="top" char="." charoff="50">2019</td>
          <td align="char" valign="top" char="." charoff="50">1072</td>
          <td align="char" valign="top" char="." charoff="50">877</td>
          <td align="char" valign="top" char="." charoff="50">471</td>
          <td align="char" valign="top" char="." charoff="50">810</td>
          <td align="char" valign="top" char="." charoff="50">4497</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">10.</td>
          <td align="char" valign="top" char="." charoff="50">2481</td>
          <td align="char" valign="top" char="." charoff="50">656</td>
          <td align="char" valign="top" char="." charoff="50">1525</td>
          <td align="char" valign="top" char="." charoff="50">1578</td>
          <td align="char" valign="top" char="." charoff="50">1032</td>
          <td align="char" valign="top" char="." charoff="50">2579</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">11.</td>
          <td align="char" valign="top" char="." charoff="50">1172</td>
          <td align="char" valign="top" char="." charoff="50">261</td>
          <td align="char" valign="top" char="." charoff="50">1224</td>
          <td align="char" valign="top" char="." charoff="50">244</td>
          <td align="char" valign="top" char="." charoff="50">332</td>
          <td align="char" valign="top" char="." charoff="50">2938</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">12.</td>
          <td align="char" valign="top" char="." charoff="50">1030</td>
          <td align="char" valign="top" char="." charoff="50">192</td>
          <td align="char" valign="top" char="." charoff="50">353</td>
          <td align="char" valign="top" char="." charoff="50">830</td>
          <td align="char" valign="top" char="." charoff="50">340</td>
          <td align="char" valign="top" char="." charoff="50">457</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">13.</td>
          <td align="char" valign="top" char="." charoff="50">494</td>
          <td align="char" valign="top" char="." charoff="50">291</td>
          <td align="char" valign="top" char="." charoff="50">224</td>
          <td align="char" valign="top" char="." charoff="50">187</td>
          <td align="char" valign="top" char="." charoff="50">382</td>
          <td align="char" valign="top" char="." charoff="50">656</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">14.</td>
          <td align="char" valign="top" char="." charoff="50">623</td>
          <td align="char" valign="top" char="." charoff="50">89</td>
          <td align="char" valign="top" char="." charoff="50">1878</td>
          <td align="char" valign="top" char="." charoff="50">609</td>
          <td align="char" valign="top" char="." charoff="50">103</td>
          <td align="char" valign="top" char="." charoff="50">1878</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">15.</td>
          <td align="char" valign="top" char="." charoff="50">2650</td>
          <td align="char" valign="top" char="." charoff="50">392</td>
          <td align="char" valign="top" char="." charoff="50">239</td>
          <td align="char" valign="top" char="." charoff="50">2368</td>
          <td align="char" valign="top" char="." charoff="50">702</td>
          <td align="char" valign="top" char="." charoff="50">183</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">16.</td>
          <td align="char" valign="top" char="." charoff="50">834</td>
          <td align="char" valign="top" char="." charoff="50">389</td>
          <td align="char" valign="top" char="." charoff="50">431</td>
          <td align="char" valign="top" char="." charoff="50">196</td>
          <td align="char" valign="top" char="." charoff="50">304</td>
          <td align="char" valign="top" char="." charoff="50">1877</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">17.</td>
          <td align="char" valign="top" char="." charoff="50">3986</td>
          <td align="char" valign="top" char="." charoff="50">753</td>
          <td align="char" valign="top" char="." charoff="50">683</td>
          <td align="char" valign="top" char="." charoff="50">3787</td>
          <td align="char" valign="top" char="." charoff="50">898</td>
          <td align="char" valign="top" char="." charoff="50">791</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">18.</td>
          <td align="char" valign="top" char="." charoff="50">2181</td>
          <td align="char" valign="top" char="." charoff="50">410</td>
          <td align="char" valign="top" char="." charoff="50">58</td>
          <td align="char" valign="top" char="." charoff="50">2127</td>
          <td align="char" valign="top" char="." charoff="50">467</td>
          <td align="char" valign="top" char="." charoff="50">52</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">19.</td>
          <td align="char" valign="top" char="." charoff="50">2306</td>
          <td align="char" valign="top" char="." charoff="50">521</td>
          <td align="char" valign="top" char="." charoff="50">196</td>
          <td align="char" valign="top" char="." charoff="50">2093</td>
          <td align="char" valign="top" char="." charoff="50">669</td>
          <td align="char" valign="top" char="." charoff="50">326</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">20.</td>
          <td align="char" valign="top" char="." charoff="50">1078</td>
          <td align="char" valign="top" char="." charoff="50">334</td>
          <td align="char" valign="top" char="." charoff="50">53</td>
          <td align="char" valign="top" char="." charoff="50">1021</td>
          <td align="char" valign="top" char="." charoff="50">384</td>
          <td align="char" valign="top" char="." charoff="50">67</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">21.</td>
          <td align="char" valign="top" char="." charoff="50">1500</td>
          <td align="char" valign="top" char="." charoff="50">0</td>
          <td align="char" valign="top" char="." charoff="50">7238</td>
          <td align="char" valign="top" char="." charoff="50">1067</td>
          <td align="char" valign="top" char="." charoff="50">395</td>
          <td align="char" valign="top" char="." charoff="50">7314</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">22.</td>
          <td align="char" valign="top" char="." charoff="50">1756</td>
          <td align="char" valign="top" char="." charoff="50">0</td>
          <td align="char" valign="top" char="." charoff="50">6407</td>
          <td align="char" valign="top" char="." charoff="50">549</td>
          <td align="char" valign="top" char="." charoff="50">993</td>
          <td align="char" valign="top" char="." charoff="50">6835</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">23.</td>
          <td align="char" valign="top" char="." charoff="50">1390</td>
          <td align="char" valign="top" char="." charoff="50">912</td>
          <td align="char" valign="top" char="." charoff="50">461</td>
          <td align="char" valign="top" char="." charoff="50">823</td>
          <td align="char" valign="top" char="." charoff="50">421</td>
          <td align="char" valign="top" char="." charoff="50">2577</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">24.</td>
          <td align="char" valign="top" char="." charoff="50">1684</td>
          <td align="char" valign="top" char="." charoff="50">383</td>
          <td align="char" valign="top" char="." charoff="50">973</td>
          <td align="char" valign="top" char="." charoff="50">1159</td>
          <td align="char" valign="top" char="." charoff="50">626</td>
          <td align="char" valign="top" char="." charoff="50">1537</td>
        </tr>
        <tr>
          <td align="center" valign="top" charoff="50">25.</td>
          <td align="char" valign="top" char="." charoff="50">3269</td>
          <td align="char" valign="top" char="." charoff="50">782</td>
          <td align="char" valign="top" char="." charoff="50">1041</td>
          <td align="char" valign="top" char="." charoff="50">3073</td>
          <td align="char" valign="top" char="." charoff="50">907</td>
          <td align="char" valign="top" char="." charoff="50">1183</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
</floats-group>
