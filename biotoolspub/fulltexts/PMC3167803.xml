<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3167803</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-12-354</article-id>
    <article-id pub-id-type="pmid">21867511</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-12-354</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Parallelized short read assembly of large genomes using de Bruijn graphs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Liu</surname>
          <given-names>Yongchao</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>liuy0039@ntu.edu.sg</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A2">
        <name>
          <surname>Schmidt</surname>
          <given-names>Bertil</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>bertil.schmidt@uni-mainz.de</email>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Maskell</surname>
          <given-names>Douglas L</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>asdouglas@ntu.edu.sg</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>School of Computer Engineering, Nanyang Technological University, Singapore</aff>
    <aff id="I2"><label>2</label>Institut für Informatik, Johannes Gutenberg University Mainz, Germany</aff>
    <pub-date pub-type="collection">
      <year>2011</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>25</day>
      <month>8</month>
      <year>2011</year>
    </pub-date>
    <volume>12</volume>
    <fpage>354</fpage>
    <lpage>354</lpage>
    <history>
      <date date-type="received">
        <day>21</day>
        <month>4</month>
        <year>2011</year>
      </date>
      <date date-type="accepted">
        <day>25</day>
        <month>8</month>
        <year>2011</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright ©2011 Liu et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2011</copyright-year>
      <copyright-holder>Liu et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/12/354"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Next-generation sequencing technologies have given rise to the explosive increase in DNA sequencing throughput, and have promoted the recent development of <italic>de novo </italic>short read assemblers. However, existing assemblers require high execution times and a large amount of compute resources to assemble large genomes from quantities of short reads.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We present PASHA, a parallelized short read assembler using de Bruijn graphs, which takes advantage of hybrid computing architectures consisting of both shared-memory multi-core CPUs and distributed-memory compute clusters to gain efficiency and scalability. Evaluation using three small-scale real paired-end datasets shows that PASHA is able to produce more contiguous high-quality assemblies in shorter time compared to three leading assemblers: Velvet, ABySS and SOAPdenovo. PASHA's scalability for large genome datasets is demonstrated with human genome assembly. Compared to ABySS, PASHA achieves competitive assembly quality with faster execution speed on the same compute resources, yielding an NG50 <italic>contig </italic>size of 503 with the longest correct <italic>contig </italic>size of 18,252, and an NG50 <italic>scaffold </italic>size of 2,294. Moreover, the human assembly is completed in about 21 hours with only modest compute resources.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>Developing parallel assemblers for large genomes has been garnering significant research efforts due to the explosive size growth of high-throughput short read datasets. By employing hybrid parallelism consisting of multi-threading on multi-core CPUs and message passing on compute clusters, PASHA is able to assemble the human genome with high quality and in reasonable time using modest compute resources.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>The emergence and widespread adoption of massively parallel next-generation sequencing technologies has given rise to the explosive increase in DNA sequencing throughput at a substantially lower unit cost of data, compared to conventional Sanger capillary-based technologies. However, these technologies introduce some new challenges to the assembly of large genomes due to two factors: (i) short read length and (ii) high throughput. This poses a challenge to the bioinformatics community to devise assembly software that can deal with a massive amount of short reads in reasonable time using modest and accessible compute resources.</p>
    <p>Consequently, several assemblers for high-throughput short reads have been recently developed. They can be classified into two approaches: <italic>contig </italic>extension and de Bruijn graph. The <italic>contig </italic>extension approach is based on the base-by-base extension at the 3' end of a <italic>contig </italic>sequence by finding overlaps between the prefixes of reads and the suffixes of the <italic>contig</italic>. SSAKE [<xref ref-type="bibr" rid="B1">1</xref>], VCAKE [<xref ref-type="bibr" rid="B2">2</xref>], SHARCGS [<xref ref-type="bibr" rid="B3">3</xref>], Taipan [<xref ref-type="bibr" rid="B4">4</xref>], and PE-assembler [<xref ref-type="bibr" rid="B5">5</xref>] are example assemblers using this approach. The de Bruijn graph approach to assembly was first introduced in Pevzner et al. [<xref ref-type="bibr" rid="B6">6</xref>], and several short read assemblers based on de Bruijn graphs have been developed. Prominent examples include ALLPATHS [<xref ref-type="bibr" rid="B7">7</xref>], Velvet [<xref ref-type="bibr" rid="B8">8</xref>], ABySS [<xref ref-type="bibr" rid="B9">9</xref>] and SOAPdenovo [<xref ref-type="bibr" rid="B10">10</xref>]. Due to the enormous cost in terms of both memory and execution time, ALLPATHS was initially constrained to the assembly of small genomes and recently has been extended to support large genomes [<xref ref-type="bibr" rid="B11">11</xref>]. Velvet employs a bi-directed simplified de Bruijn graph data structure, which requires accommodating the entire genome in the graph, resulting in a large amount of memory consumption for large genomes. Furthermore, when joining <italic>contigs </italic>into <italic>scaffolds </italic>using paired-end data, Velvet stores the read mapping locations and paired-end information along with the graph, making it infeasible for assembling large genomes. ABySS employs a distributed de Bruijn graph data structure. It is implemented using the message passing interface (MPI), and produces <italic>contigs </italic>in parallel on a distributed-memory compute cluster without the use of paired-end information. SOAPdenovo employs a de Brujin graph data structure similar to that of Velvet, but uses a multi-threaded design to parallelize compute-intensive portions on shared-memory architectures. Besides those algorithms that use directed de Brujin graphs, YAGA [<xref ref-type="bibr" rid="B12">12</xref>] employs a bi-directed string graph, represented by a set of edges, and produces <italic>contigs </italic>through path walking using a variation of the classic parallel list ranking problem. This algorithm shows good parallel scalability for small microbial genomes. However, to assemble the E.coli dataset (see the Results and Discussion section), its execution time (496 seconds) using 256 CPUs of a Blue Gene/L system is longer than PASHA (325 seconds) on a single CPU core (see the Results and Discussion section).</p>
    <p>In this paper, we present PASHA, a parallelized short read assembler for large genomes based on de Bruijn graphs. Some of the concepts adopted in PASHA are inspired by Velvet and ABySS. The primary contribution of our algorithm is the usage of hybrid parallelism consisting of small-scale shared-memory multi-threading on multi-core CPUs and large-scale distributed-memory parallelism on compute clusters to overcome memory constraints and to achieve high speed for large genome assembly. Furthermore, we incorporate several techniques (e.g. a modified Tour-bus method [<xref ref-type="bibr" rid="B8">8</xref>] to remove bubbles and a modified Pebble algorithm [<xref ref-type="bibr" rid="B13">13</xref>] to join <italic>contigs</italic>) in the typical assembly pipeline to facilitate the improvement of assembly quality. Evaluation using three small-scale real paired-end datasets indicates that PASHA produces higher-quality assemblies than Velvet, ABySS and SOAPdenovo in less time. To demonstrate the capability of assembling large genomes, we assembled 3.76 billion paired-end short reads from the whole-genome sequencing of a Yoruban male individual (NA18507) from Bentley et al. [<xref ref-type="bibr" rid="B14">14</xref>], and obtained an NG50 <italic>contig </italic>size of 503, with the longest correct <italic>contig </italic>size of 18,252, and an NG50 <italic>scaffold </italic>size of 2,294.</p>
    <p>The size of the assembly problem severely impacts on the assembly algorithm. The PASHA and ABySS assemblers are implemented using MPI and are able to run on both shared-memory and distributed memory computer clusters. SOAPdenovo is designed using multi-threading and thus is only suitable for shared-memory computers. Because SOAPdenovo requires a computer system with a large amount of shared memory (around 512 GB for this assembly problem), we are not able to execute it to assemble the Yoruban male individual genome on the hardware resources available to us (a symmetric multiprocessing server with 48 CPU cores and 256 GB memory) and thus exclude it from the comparison. For the complete assembly, PASHA took about 21 hours using only modest computing resources, achieving competitive assembly quality with faster execution speed, compared to ABySS.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>Even though de Bruijn graph-based assemblers successfully alleviate the pressure on memory space and execution speed by substituting reads with <italic>k</italic>-mers (a contiguous sequence of <italic>k </italic>bases) as nodes, compared to the conventional overlap-layout-consensus approaches, the memory consumption and execution time is still prohibitive for large genomes. For example, for the genomic data of a Yoruban male individual, the total number of nodes in the preliminary de Bruijn graph (a node corresponds to a distinct 27-mer) is about 7.73 billion. This motivates us to design a scalable assembler for large genomes that is workable on modest and commonly used high-performance computing resources.</p>
    <p>PASHA is a parallelized algorithm for large genome assembly, which overcomes the memory and execution speed constraints by using hybrid computing architectures consisting of shared-memory multi-core CPUs and distributed-memory compute clusters. Figure <xref ref-type="fig" rid="F1">1</xref> illustrates the pipeline of our assembler. The pipeline comprises four stages: (i) generating and distributing <italic>k</italic>-mers, (ii) constructing and simplifying the distributed preliminary de Bruijn graph, (iii) merging bubbles and generating <italic>contigs </italic>after constructing a Velvet-like de Bruijn graph, and (iv) scaffolding to join <italic>contigs </italic>into scaffolds. We have implemented Stages (i) and (ii), which are suitable for parallelization and the most memory-intensive, using MPI. This makes our program compatible with both shared-memory and distributed-memory computing systems. Each MPI process <italic>P</italic><sub><italic>i </italic></sub>comprises two threads <italic>T</italic><sub>0 </sub>and <italic>T</italic><sub>1</sub>. <italic>T</italic><sub>0 </sub>performs computations for the assembly pipeline, and <italic>T</italic><sub>1 </sub>performs communications between different processes (see (i) and (ii) in Figure <xref ref-type="fig" rid="F1">1</xref>), as well as file I/O operations. By employing two threads in a single process, we intend to gain faster speed by overlapping the local computation and remote communications with processes (and file I/O). By distributing the de Bruijn graph over a network of computers, we get a partition of the graph with each part stored in a different computer. Hence, we do not need a large amount of memory in a single computer, making our algorithm workable even on a compute cluster comprised of commonplace workstations or personal computers. Since the size of a message is very small, sending messages one-by-one to remote processes will incur large communication overheads. Thus, for the messages that are not time-critical, we combine them into packets to improve the communication efficiency. <italic>T</italic><sub>0 </sub>and <italic>T</italic><sub>1 </sub>are connected through a bi-directional message queue. The maximal number of messages in the queue is controlled by a maximal capability threshold. Any thread, which tries to append a new message to the queue, will be blocked if the queue reaches the threshold, and will be resumed once the queue has spaces available. Any thread that tries to retrieve a message from an empty queue will be blocked until there is at least one message available. For Stages (iii) and (iv), which exhibit limited parallelism and are less memory-intensive, we use a multi-threaded design, only compatible with shared-memory systems.</p>
    <fig id="F1" position="float">
      <label>Figure 1</label>
      <caption>
        <p><bold>Schematic diagram of the PASHA assembly pipeline</bold>. (i) k-mer generation and distribution over a number of MPI processes; (ii) distributed preliminary de Bruijn graph construction and simplification over a number of MPI processes; (iii) Bubble merging and contig generation; and (iv) scaffolding.</p>
      </caption>
      <graphic xlink:href="1471-2105-12-354-1"/>
    </fig>
    <p>In our proof-of-concept implementation (the source code is available for download at <ext-link ext-link-type="uri" xlink:href="http://sites.google.com/site/yongchaosoftware/pasha">http://sites.google.com/site/yongchaosoftware/pasha</ext-link>), we have used parts of the source code from Velvet for Stages (iii) and (iv) with some algorithmic and data structure modifications. The use of existing open-source code significantly reduces the development time for prototyping our algorithm, and more importantly, our modifications make the two stages feasible and practical to execute on a workstation with limited system memory (i.e. 72 GB RAM in our workstation), as well as providing better assembly qualities. PASHA supports the standard FASTA and FASTQ input formats for single-end and paired-end short reads with different insert sizes. While some other assemblers require users to tune a number of parameters to gain the best assembly, PASHA only needs a single parameter "-k" (i.e. the <italic>k</italic>-mer size), making it relatively user friendly.</p>
    <p>Before describing PASHA in details, we firstly define some terms to facilitate our discussion. Given a sequence <italic>S </italic>of length <italic>l</italic>, we define <italic>S</italic>[<italic>i</italic>] as the <italic>i</italic>-th base in the sequence, <inline-formula><mml:math id="M1" name="1471-2105-12-354-i1" overflow="scroll"><mml:mrow><mml:mover accent="false" class="mml-overline"><mml:mrow><mml:mi>S</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> as the complement of <italic>S</italic>[<italic>i</italic>], <italic>S</italic><sub><italic>i </italic></sub>as the <italic>k</italic>-mer starting at position <italic>i </italic>(1≤<italic>i</italic>≤<italic>l</italic>-<italic>k</italic>+1) of <italic>S</italic>, <inline-formula><mml:math id="M2" name="1471-2105-12-354-i2" overflow="scroll"><mml:mrow><mml:mover accent="false" class="mml-overline"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> as the reverse complement of <italic>S</italic><sub><italic>i</italic></sub>, and <inline-formula><mml:math id="M3" name="1471-2105-12-354-i3" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> as the canonical <italic>k</italic>-mer that is the lexicographically smaller of <italic>S</italic><sub><italic>i </italic></sub>and <inline-formula><mml:math id="M4" name="1471-2105-12-354-i2" overflow="scroll"><mml:mrow><mml:mover accent="false" class="mml-overline"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. A <italic>k</italic>-molecule of <italic>S</italic><sub><italic>i </italic></sub>is a pair of complementary <italic>k</italic>-mer strands consisting of the canonical <italic>k</italic>-mer of <italic>S</italic><sub><italic>i </italic></sub>(i.e. <inline-formula><mml:math id="M5" name="1471-2105-12-354-i3" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>) and the non-canonical <italic>k</italic>-mer of <italic>S</italic><sub><italic>i </italic></sub>(i.e. the reverse complement of <inline-formula><mml:math id="M6" name="1471-2105-12-354-i3" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>).</p>
    <sec>
      <title>K-mer generation and distribution</title>
      <p>In a de Bruijn graph, a node corresponds to a <italic>k</italic>-mer and an edge between two nodes is created if and only if their corresponding <italic>k</italic>-mers have a suffix-prefix overlap of <italic>k</italic>-1 bases. Hence, PASHA starts the construction of its preliminary de Bruijn graph from the generation of all <italic>k</italic>-mers from the input read data.</p>
      <p>As mentioned above, PASHA employs an MPI-based approach to <italic>k</italic>-mer generation and distributes them among the processes. This distribution requires that the location of any <italic>k</italic>-mer is deterministic and can be efficiently computed from the <italic>k</italic>-mer itself. Since a <italic>k</italic>-molecule is a pair of complementary strands, the location of a <italic>k</italic>-mer and its reverse complement must be the same. Before calculating the location of <italic>S</italic><sub><italic>i </italic></sub>and <inline-formula><mml:math id="M7" name="1471-2105-12-354-i2" overflow="scroll"><mml:mrow><mml:mover accent="false" class="mml-overline"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, PASHA first transforms <italic>S</italic><sub><italic>i </italic></sub>and <inline-formula><mml:math id="M8" name="1471-2105-12-354-i2" overflow="scroll"><mml:mrow><mml:mover accent="false" class="mml-overline"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> to their corresponding base-4 representation by assigning numerical value {0, 1, 2, 3} to bases {A, C, G, T}. To determine the location of <italic>S</italic><sub><italic>i</italic></sub>, unlike ABySS (which calculates the hash values of <italic>S</italic><sub><italic>i </italic></sub>and <inline-formula><mml:math id="M9" name="1471-2105-12-354-i2" overflow="scroll"><mml:mrow><mml:mover accent="false" class="mml-overline"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, and then performs an XOR operation on them), PASHA computes the location from the canonical <italic>k</italic>-mer. Since the base-4 representation of a <italic>k</italic>-mer is stored in a 64-bit integer (thus limiting the maximum allowable <italic>k</italic>-mer size to 31), the comparison can be theoretically completed in one clock cycle on a 64-bit computing system. A balanced distribution of <italic>k</italic>-mers among processes is critical to the performance of our algorithm in terms of both execution time and memory space. An unbalanced distribution would cause some processes to consume much more memory for <italic>k</italic>-mer storage, thus resulting in a system failure due to memory limitations on some compute nodes. In PASHA, we first calculate a hash value <italic>I</italic><sub><italic>k </italic></sub>using a linear congruential hash function from the base-4 presentation of the canonical <italic>k</italic>-mer. Then, the ID of the process that owns this <italic>k</italic>-mer is computed as <italic>I</italic><sub><italic>k </italic></sub>% <italic>N</italic><sub><italic>p</italic></sub>, where <italic>N</italic><sub><italic>p </italic></sub>is the number of processes. From our experiments, our location determination method is able to (roughly) balance the distribution of <italic>k</italic>-mers (e.g., for the Yoruban Male genome assembly using 16 processes, the average number of local 27-mers for each process is 483,194,335 ± 963,003).</p>
      <p>To achieve memory efficiency, we use the <italic>sparse_hash_set </italic>template class in the Google Sparse Hash library (<ext-link ext-link-type="uri" xlink:href="http://code.google.com/p/google-sparsehash">http://code.google.com/p/google-sparsehash</ext-link>) to distinguish and store <italic>k</italic>-mers. In PASHA, each process holds a local sparse hash-set to store its <italic>k</italic>-mers. For each process, thread <italic>T</italic><sub>1 </sub>loads the reads from disk and transfers the reads to thread <italic>T</italic><sub>0 </sub>through the message queue, where the short reads are arranged into batches and a message contains a batch of reads. <italic>T</italic><sub>0 </sub>receives batches of reads from the queue, calculates the hash values of all <italic>k</italic>-mers, and stores some of them in its local sparse hash-set depending on the hash values. The cooperation of the two threads overlaps the computation and the file I/O operations, thus reducing the execution time. Since a <italic>k</italic>-mer and its reverse complement are considered equivalent in a <italic>k</italic>-molecule, we only need to store the canonical <italic>k</italic>-mer into the sparse hash-set to represent the <italic>k</italic>-molecule.</p>
      <p>For any read containing non-A/C/G/T bases, PASHA converts those non-A/C/G/T bases to the base "A" (as Velvet does), not simply discarding the whole read as ABySS does [<xref ref-type="bibr" rid="B9">9</xref>]. After completing the generation of <italic>k</italic>-mers, each process writes its local <italic>k</italic>-mers to disk for future use when constructing the preliminary de Bruijn graph. Our distributed <italic>k</italic>-mer generation implementation can also be used (directly or after modification) by other tools, such as CUDA_EC [<xref ref-type="bibr" rid="B15">15</xref>] and Quake [<xref ref-type="bibr" rid="B16">16</xref>] to generate and count the occurrences of <italic>k</italic>-mers in genomic data.</p>
    </sec>
    <sec>
      <title>Distributed de Bruijn graph construction</title>
      <p>The preceding stage only generates <italic>k</italic>-mers, and does not record any graph-related information for a <italic>k</italic>-mer. However, to construct a de Bruijn graph, we need not only the <italic>k</italic>-mers themselves, but also multiplicity and linkage information. A common approach is to use a hash-map implementation, using <italic>k</italic>-mers as keys, to provide fast access to the graph-related information. However, this approach will result in a large memory overhead. Conway and Bromage [<xref ref-type="bibr" rid="B17">17</xref>] suggested a sparse bitmap data structure to represent the de Bruijn graph, achieving memory efficiency at the cost of execution time. However, their proof-of-concept assembler (functionally similar to our Stages (i) and (ii) ) takes about 50 hours and yields a highly fragmented assembly, with an N50 <italic>contig </italic>size of only 250, for the Yoruban male genome. Hence, we exclude it from the following assessments. In PASHA, we instead use a sorted vector data structure to store the <italic>k</italic>-mers and their graph-related information. Each process loads its local <italic>k</italic>-mers from disk and stores them in a sorted vector. The sorted vector is sorted using the <italic>k</italic>-mers as keys.</p>
      <p>We use the same approach as ABySS to represent the linkage information between nodes; i.e., the linkages are compacted into 8 bits with each bit representing the presence or absence of each of the eight edges in the two directions. However, to build the linkages between nodes, PASHA employs a different approach. For each <italic>k</italic>-mer (each node), ABySS checks the existence of all possible neighbours by doing all possible base extensions in each direction. If a neighbour exists, it sets its corresponding bit to represent the existence of the linkage. This approach is effective but has a probability of introducing spurious edges, which connect <italic>k</italic>-mers that are not adjacent in any read. Hence, PASHA builds linkages directly from the adjacency information of <italic>k</italic>-mers in the input reads, i.e., a linkage between two <italic>k</italic>-mers is created if and only if the two <italic>k</italic>-mers are adjacent in at least one read.</p>
      <p>While building linkages, for each process, thread <italic>T</italic><sub>1 </sub>loads batches of reads from disk and transfers them to <italic>T</italic><sub>0 </sub>as the previous stage does. For each read <italic>S</italic>, <italic>T</italic><sub>0 </sub>iterates over each <italic>k</italic>-mer <italic>S</italic><sub><italic>i </italic></sub>and identifies its location after calculating the base-4 representation of its canonical <italic>k</italic>-mer. If the <italic>k</italic>-mer belongs to it, <italic>T</italic><sub>0 </sub>sets the corresponding linkage bits calculated from the bases <italic>S</italic>[<italic>i</italic>-1] and <italic>S</italic>[<italic>i</italic>+<italic>k</italic>], which are the extension bases in the left and the right directions of <italic>S</italic><sub><italic>i</italic></sub>. When the index is out of the range, the corresponding extension base (and its complement) is an invalid base Ø, indicating that no linkage is created in that direction. Figure <xref ref-type="fig" rid="F2">2</xref> shows all four cases of the linkage construction between two adjacent <italic>k</italic>-mers in a read. Because each process iterates all <italic>k</italic>-mers in all input reads, no communication between processes is required during the construction process. While constructing the linkages, we compute the multiplicity of each <italic>k</italic>-mer at the same time. In PASHA, two bytes are used to represent the multiplicity of a <italic>k</italic>-mer. After completing the linkage construction, we will get a distributed preliminary de Bruijn graph with each node corresponding to a <italic>k</italic>-mer.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Linkage construction for two adjacent k-mers in a read</bold>.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-354-2"/>
      </fig>
    </sec>
    <sec>
      <title>Graph simplification</title>
      <p>The preliminary de Bruijn graph contains many linear chains of nodes that can be merged to simplify the graph without loss of information. We start the simplification from the removal of spurious linkages. Generally, there are three major kinds of spurious linkages: <italic>tips</italic>, <italic>low-coverage paths </italic>and <italic>bubbles</italic>. A <italic>tip </italic>is a short and low-coverage dead end, which is likely to be caused by sequence errors at the beginning or the end of reads. A <italic>low-coverage path </italic>only covers one or a few reads and is likely to be a chimeric connection. <italic>Bubbles </italic>are redundant paths with minor differences, which might be due to heterozygosity, internal read errors or nearby tips connecting. At this stage, we only remove tips and low-coverage paths, leaving the removal of bubbles to the following stage.</p>
      <p>Prior to the removal of longer tips, we first remove low-frequency dead-end individual <italic>k</italic>-mers. This removal relies on the assumption that the majority of true <italic>k</italic>-mers should occur in several reads, i.e. the multiplicity of a true <italic>k</italic>-mer is supposed to be above a minimum multiplicity threshold <italic>M</italic>, which is automatically estimated from the multiplicities of all <italic>k</italic>-mers. This removal work is conducted round-by-round until no dead-end <italic>k</italic>-mers meet the removal conditions. For each process, <italic>T</italic><sub>0 </sub>identifies the <italic>k</italic>-mers, which are dead-end and have a multiplicity less than <italic>M</italic>, in its local collection of <italic>k</italic>-mers, and then removes the <italic>k</italic>-mers and their linkages in the graph. When removing linkages to <italic>k</italic>-mers in another process, <italic>T</italic><sub>0 </sub>packs a request message and lets <italic>T</italic><sub>1 </sub>forward to the remote process. <italic>T</italic><sub>1 </sub>forwards the request from <italic>T</italic><sub>0 </sub>to other processes, and handles the requests on the removal of the specific linkages to its local <italic>k</italic>-mers, from the other processes.</p>
      <p>In PASHA, we simply remove tips that are shorter than 2<italic>k</italic>. For each process, <italic>T</italic><sub>0 </sub>generates the current linear chain of <italic>k</italic>-mers, starting from a dead-end <italic>k</italic>-mer, by extending the chain in the left or right directions base-by-base. If the chain is longer than 2<italic>k</italic>, the chain is released; and otherwise, the <italic>k</italic>-mers in the chain will be removed as well as their linkages. If, during the extension of a chain, a linked <italic>k</italic>-mer exists locally, <italic>T</italic><sub>0 </sub>gets the graph-related information of the <italic>k</italic>-mer directly from its local sorted vector. Otherwise, <italic>T</italic><sub>0 </sub>packs a request message and lets <italic>T</italic><sub>1 </sub>forward it to the remote process. <italic>T</italic><sub>0 </sub>will be blocked until receiving the response, forwarded back by <italic>T</italic><sub>1</sub>, from the remote process.</p>
      <p>After completing the removal of tips, the graph is split into different linear chains of nodes. All processes cooperate in parallel to generate the sequences corresponding to the linear chains. The linear chains are generated using two steps. The first step generates linear chains starting from dead-end <italic>k</italic>-mers, where a chain is extended in only one direction. The second step starts from an arbitrary <italic>k</italic>-mer, where a chain must be extended in two directions. In the first step each process <italic>P</italic><sub><italic>i </italic></sub>extends a linear chain from each active local dead-end <italic>k</italic>-mer until another dead-end <italic>k</italic>-mer is met. In this case, <italic>P</italic><sub><italic>i </italic></sub>checks the location process <italic>P</italic><sub><italic>j </italic></sub>of the dead-end <italic>k</italic>-mer to avoid duplicates because <italic>P</italic><sub><italic>j </italic></sub>(if <italic>i </italic>≠ <italic>j</italic>) might be generating this linear chain at the same time. In our algorithm, <italic>P</italic><sub><italic>i </italic></sub>keeps this linear chain only if <italic>P</italic><sub><italic>i </italic></sub>≤ <italic>P</italic><sub><italic>j</italic></sub>, and releases it, otherwise. This process will be conducted iteratively until there are no local dead-end <italic>k</italic>-mers in each process. The second step is completed by assigning processes one-by-one to generate linear chains. At any time, only one process <italic>P</italic><sub><italic>i </italic></sub>is allowed to generate linear chains and the other processes have to wait and process requests from <italic>P</italic><sub><italic>i</italic></sub>. <italic>P</italic><sub><italic>i </italic></sub>starts the two-directional extension from each local <italic>k</italic>-mer until a loop or a dead-end <italic>k</italic>-mer is found. In this case, the loop is simply broken up and output as a linear chain. For each sequence, the coverage is calculated by dividing the sum of multiplicities of the <italic>k</italic>-mers in its corresponding chain by the sequence length. If the coverage is lower than the minimum coverage threshold, the sequence should be given up since it is likely to be generated from linear chains containing spurious connections. The remaining sequences are written to disk for the use in the next stage.</p>
    </sec>
    <sec>
      <title>Bubble merging and contig generation</title>
      <p>This stage consists of three steps. First, a Velvet-like de Bruijn graph is constructed from the sequences produced from the previous stage. To build the Velvet-like graph, we form a node, as well as its twin node, from a sequence and create linkages between nodes by aligning reads to nodes. If two adjacent <italic>k</italic>-mers in a read belong to two different nodes, we create an edge connecting them if there is no edge between them, and otherwise, update the information of the existing edge. While aligning reads to nodes, we do not record any mapping information about the reads. We employ a multi-threaded implementation to accelerate the alignment of reads to nodes on multi-core CPUs, where a single read is aligned to the graph nodes by a thread and locks are carefully employed to guarantee the mutual exclusive access to critical sections (e.g. the creation and updating of links between nodes).</p>
      <p>Secondly, we detect and merge bubbles in the graph. The "Tour-bus" method in Velvet is employed to detect bubbles. The detected bubbles are merged into a single path if the sequences of the parallel paths meet the user-specified similarity requirement. In PASHA, we directly use the source code of the "Tour-bus" method, but modified the conditions to merge the two paths. Two paths are merged if they have at most a two-base-pair difference in length with ≥ 90% identity.</p>
      <p>Finally, we simplify the graph after further removal of short tips and low-coverage nodes, and then generate <italic>contigs </italic>from nodes.</p>
    </sec>
    <sec>
      <title>Scaffolding</title>
      <p>The scaffolding work aims to find the correct ordering of the assembled <italic>contigs</italic>, and then joins them into <italic>scaffolds</italic>. The determination of the ordering of <italic>contigs </italic>relies on the mapping information of paired-end reads onto the <italic>contigs</italic>, and then the mapping information is transferred to scaffolding linkages between <italic>contigs</italic>.</p>
      <p>In PASHA, the scaffolding work starts from the construction of a Velvet-like de Bruijn graph from the assembled <italic>contigs</italic>. While aligning paired-end reads to the graph nodes (we extend the <italic>k</italic>-mer based alignment algorithm in Velvet to provide support for multi-threading), the mapping information of a read pair, such as mapping locations and node identifiers, is recorded into an in-disk database if the two reads successfully map onto the graph. A similar multi-threaded design, as in the previous stage, is employed to accelerate the graph construction on multi-core CPUs.</p>
      <p>Having completed the read mapping, the median insert size, as well as its standard deviation, for each library is estimated from the mapping information of paired-end reads whose two reads map onto the same nodes. We employ a modified Pebble algorithm [<xref ref-type="bibr" rid="B13">13</xref>] to do the scaffolding work. The scaffolding linkages are built from the mapping information of paired-end reads in the in-disk database. Velvet constructs linkages from the mapping information of reads and read pairs. For a single read, if it overlaps with more than one node, linkages will be created between these nodes. For a read pair, both of which have overlaps with nodes, a linkage is created between two nodes that respectively have overlaps with the two reads. In PASHA, we only use the mapping information of read pairs to construct linkages, where a linkage is considered reliable if we have at least three read pairs to form the linkage.</p>
    </sec>
    <sec>
      <title>Speed optimizations</title>
      <p>In the representation of the preliminary de Bruijn graph, PASHA employs a sorted vector data structure, instead of a hash-map, to store <italic>k</italic>-mers and their graph-related information. While reducing memory overhead, a sorted vector causes an increase in the average search time of <italic>k</italic>-mers. Given <italic>N k</italic>-mers stored in a sorted vector, the average search time is about log<italic>N</italic>, generally longer than the (nearly) constant search time of a hash-map. In this case, we build an acceleration table using the most significant <italic>r </italic>bits (<italic>r </italic>= 24 by default) of a <italic>k</italic>-mer to speed up the search. This acceleration table only results in a memory increase of 2<sup><italic>r </italic></sup>times the size of type integer bytes, but is expected to reduce the average search time to log(<italic>N</italic>/2<sup><italic>r</italic></sup>).</p>
      <p>For Stages (i) and (ii), each MPI process has two threads <italic>T</italic><sub>0 </sub>and <italic>T</italic><sub>1</sub>: one for communication and the other for local computation. This mechanism is expected to improve the execution speed by overlapping communication and computation. However, when the two threads communicate frequently, along with memory allocations and de-allocations at the same time, the overhead incurred by system calls on memory operations may offset the performance obtained from the overlapping. Thus, we use the <italic>tbb_allocator </italic>template class in the Intel Threading Building Blocks library to manage the memory allocation and de-allocation for the communication between <italic>T</italic><sub>0 </sub>and <italic>T</italic><sub>1</sub>. The <italic>tbb_allocator </italic>template class does improve the execution speed through its smart management of user memory allocation and de-allocation.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and Discussion</title>
    <sec>
      <title>Experimental data</title>
      <p>To assess PASHA, we use four paired-end short read datasets from four different genomes to conduct experiments (see Table <xref ref-type="table" rid="T1">1</xref>). The first three datasets: <italic>Bacillus</italic>, <italic>Bordetella </italic>and <italic>E.coli </italic>have accession numbers DRR000002, ERR007648 and SRR001665 in the NCBI Sequence Read Archive (SRA), respectively. The reference genome of the <italic>Bacillus </italic>dataset is <italic>Bacillus subtilis subsp. subtilis str. 168 </italic>with accession number <ext-link ext-link-type="gen" xlink:href="NC_000964">NC_000964</ext-link> in GenBank; the reference genome of the <italic>Bordetella </italic>dataset is <italic>Bordetella pertussis Tohama I </italic>with accession number <ext-link ext-link-type="gen" xlink:href="NC_002929">NC_002929</ext-link>; and the reference genome of the <italic>E.coli </italic>dataset is <italic>Escherichia coli str. K-12 substr. MG1655 </italic>with accession number <ext-link ext-link-type="gen" xlink:href="NC_000913">NC_000913</ext-link>. The Yoruban male dataset has the accession number SRA000271 in NCBI SRA, which contains six sub-datasets with accession numbers SRX000600, SRX000601, SRX000602, SRX000603, SRX001539 and SRX001540, respectively. The first four sub-datasets come from the same library CT1194 and the last two sub-datasets from library CT1373. We have used the six sub-datasets (about 4.05 billion reads) to produce <italic>contigs </italic>and used the first four sub-datasets to create <italic>scaffolds </italic>(about 3.76 billion 200bp-insert-size paired-end reads). The use of these short read datasets is consistent for both PASHA and ABySS to produce <italic>contigs </italic>or <italic>scaffolds</italic>.</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p>Short read datasets for assembler assessment</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="left">Bacillus</th>
              <th align="left">Bordetella</th>
              <th align="left">E.coli</th>
              <th align="left">Yoruban male</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">library</td>
              <td align="left">160bp</td>
              <td align="left">198bp*</td>
              <td align="left">200bp</td>
              <td align="left">200bp</td>
            </tr>
            <tr>
              <td align="left">read length</td>
              <td align="left">36</td>
              <td align="left">36</td>
              <td align="left">36</td>
              <td align="left">36~42</td>
            </tr>
            <tr>
              <td align="left">no. of reads</td>
              <td align="left">16,633,474</td>
              <td align="left">12,549,138</td>
              <td align="left">20,816,448</td>
              <td align="left">3,758,659,514</td>
            </tr>
            <tr>
              <td align="left">coverage</td>
              <td align="left">142×</td>
              <td align="left">111×</td>
              <td align="left">162×</td>
              <td align="left">44×</td>
            </tr>
            <tr>
              <td align="left">genome size</td>
              <td align="left">4,215,606</td>
              <td align="left">4,086,189</td>
              <td align="left">4,639,675</td>
              <td align="left">3,101,788,170**</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>* uses an estimated insert size from assembly due to the unavailability of the real library insert size; ** uses the total length of all scaffolds in the GRCh37/hg19 build human reference sequence.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>Assembly quality assessment</title>
      <p>We have assessed the assembly quality of PASHA by comparing it to three leading assemblers: Velvet (version 1.0.17), ABySS (version 1.2.1) and SOAPdenovo (version 1.04) using the datasets in Table <xref ref-type="table" rid="T1">1</xref>. All the tests are conducted on a workstation with two quad-core 2.40 GHz CPUs and 72 GB memory, and on a compute cluster with 8 compute nodes connected by a high-speed Infiniband switch. Each node of the cluster consists of two quad-core 2.93 GHz CPUs and 24 GB memory, running the Linux operating system.</p>
      <p>The assembly quality of all assemblers is compared in terms of NG50, NG80 and maximum <italic>contig </italic>or <italic>scaffold </italic>sizes. The NG50 (NG80) <italic>contig </italic>or <italic>scaffold </italic>size is calculated by ordering all assembled sequences by their lengths, and then adding the lengths from the largest to the smallest until the summed length exceeds 50% (80%) of the reference genome size. In this paper, for each dataset, we use the same reference genome size (shown in Table <xref ref-type="table" rid="T1">1</xref>) to calculate the NG50 (NG80) <italic>contig </italic>or <italic>scaffold </italic>size for all assemblers. This is different from the calculation used in the ABySS and SOAPdenovo papers, where they consider the total length of all assembled sequences by each assembler as the reference genome size. For the calculation of <italic>scaffold </italic>sizes, the intra-scaffold gaps are included. For the calculation of genome coverage, we split the <italic>scaffolds </italic>into their constituent <italic>contigs </italic>at the position of gaps that are filled by a series of "N" bases. The genome coverage and the number of incorrect <italic>contigs </italic>are computed from the results obtained from aligning <italic>contigs </italic>to their reference genomes using BLAT version 34 [<xref ref-type="bibr" rid="B18">18</xref>]. A <italic>contig </italic>is considered correct if it has a full length alignment to the reference genome with a minimum identity of 95% (the number of matches dividing the <italic>contig </italic>length) and a maximal error rate of 5%. The alignment length is calculated by summing up the number of matches, the number of mismatches, and the number of insertions in the query and the target. The error rate is calculated by dividing the sum of the number of mismatches and the number of insertions in the query and the target by the alignment length.</p>
      <p>We first use the three small paired-end datasets (i.e. <italic>Bacillus</italic>, <italic>Bordetella </italic>and <italic>E.coli</italic>) to evaluate the different assemblers in terms of assembly quality and execution speed on a single CPU core of the workstation. The parameters of all the assemblers have been carefully tuned with the intention to gain the highest assembly quality for each dataset, where each assembler chooses the <italic>k</italic>-mer size that produces the largest NG50 <italic>scaffold </italic>size. Table <xref ref-type="table" rid="T2">2</xref>, <xref ref-type="table" rid="T3">3</xref> and <xref ref-type="table" rid="T4">4</xref> show the assembly results of all four assemblers, where we only consider <italic>scaffolds </italic>of length ≥ 100 bps. The tables show that for all the three datasets, PASHA is able to produce more contiguous assemblies with comparable genome coverage and mis-assembly rates in terms of all measures relating to <italic>scaffolds</italic>. Moreover, PASHA achieves the fastest execution speed on a single CPU core. PASHA uses a single MPI process (having two threads) for the first two stages of the pipeline, and a single thread for the last two stages. However, due to the small sizes of datasets, thread <italic>T</italic><sub>1 </sub>contributes little to the actual execution time by overlapping file I/O operations with <italic>T</italic><sub>0</sub>.</p>
      <table-wrap id="T2" position="float">
        <label>Table 2</label>
        <caption>
          <p>Assembly results for <italic>Bacillus</italic></p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="left">PASHA</th>
              <th align="left">Velvet</th>
              <th align="left">ABySS</th>
              <th align="left">SOAPdenovo</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">no. of scaffolds</td>
              <td align="left">20</td>
              <td align="left">80</td>
              <td align="left">66</td>
              <td align="left">98</td>
            </tr>
            <tr>
              <td align="left">NG50</td>
              <td align="left">1,435,675</td>
              <td align="left">670,481</td>
              <td align="left">424,309</td>
              <td align="left">487,364</td>
            </tr>
            <tr>
              <td align="left">NG80</td>
              <td align="left">182,534</td>
              <td align="left">117,643</td>
              <td align="left">124,700</td>
              <td align="left">96,291</td>
            </tr>
            <tr>
              <td align="left">max</td>
              <td align="left">2,044,786</td>
              <td align="left">919,263</td>
              <td align="left">890,628</td>
              <td align="left">918,694</td>
            </tr>
            <tr>
              <td align="left">mean</td>
              <td align="left">208,124</td>
              <td align="left">52,046</td>
              <td align="left">67,457</td>
              <td align="left">42,399</td>
            </tr>
            <tr>
              <td align="left">genome coverage</td>
              <td align="left">92.27%</td>
              <td align="left">98.69%</td>
              <td align="left">97.92%</td>
              <td align="left">97.60%</td>
            </tr>
            <tr>
              <td align="left">incorrect contigs (mean)</td>
              <td align="left">5(61,643)</td>
              <td align="left">1(44,055)</td>
              <td align="left">1(70,485)</td>
              <td align="left">2(22,680)</td>
            </tr>
            <tr>
              <td align="left">time (in seconds)</td>
              <td align="left">332</td>
              <td align="left">433</td>
              <td align="left">747</td>
              <td align="left">467</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>PASHA uses the parameters "k = 29", Velvet uses "k = 29, -exp_cov = auto, -cov_cutoff = auto", ABySS uses "k = 29, n = 10" and SOAPdenvo uses "k = 23, insert_length = 160".</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="T3" position="float">
        <label>Table 3</label>
        <caption>
          <p>Assembly results for <italic>Bordetella</italic></p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="left">PASHA</th>
              <th align="left">Velvet</th>
              <th align="left">ABySS</th>
              <th align="left">SOAPdenovo</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">no. of scaffolds</td>
              <td align="left">228</td>
              <td align="left">294</td>
              <td align="left">287</td>
              <td align="left">298</td>
            </tr>
            <tr>
              <td align="left">NG50</td>
              <td align="left">24,517</td>
              <td align="left">18,063</td>
              <td align="left">18,150</td>
              <td align="left">17,870</td>
            </tr>
            <tr>
              <td align="left">NG80</td>
              <td align="left">10,006</td>
              <td align="left">8,237</td>
              <td align="left">9,215</td>
              <td align="left">8,157</td>
            </tr>
            <tr>
              <td align="left">max</td>
              <td align="left">121,801</td>
              <td align="left">75,085</td>
              <td align="left">75,809</td>
              <td align="left">74,881</td>
            </tr>
            <tr>
              <td align="left">mean</td>
              <td align="left">16,508</td>
              <td align="left">12,797</td>
              <td align="left">13,520</td>
              <td align="left">12,583</td>
            </tr>
            <tr>
              <td align="left">genome coverage</td>
              <td align="left">70.44%</td>
              <td align="left">68.45%</td>
              <td align="left">53.67%</td>
              <td align="left">72.45%</td>
            </tr>
            <tr>
              <td align="left">incorrect contigs (mean)</td>
              <td align="left">166(5,521)</td>
              <td align="left">150(6,834)</td>
              <td align="left">138(12,172)</td>
              <td align="left">81(10,261)</td>
            </tr>
            <tr>
              <td align="left">time (in seconds)</td>
              <td align="left">207</td>
              <td align="left">292</td>
              <td align="left">484</td>
              <td align="left">293</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>PASHA uses the parameters "k = 31", Velvet uses "k = 31, -exp_cov = auto, -cov_cutoff = auto", ABySS uses "k = 31, n = 10" and SOAPdenvo uses "k = 25, insert_length = 198".</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="T4" position="float">
        <label>Table 4</label>
        <caption>
          <p>Assembly results for <italic>E.coli</italic></p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="left">PASHA</th>
              <th align="left">Velvet</th>
              <th align="left">ABySS</th>
              <th align="left">SOAPdenovo</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">no. of scaffolds</td>
              <td align="left">64</td>
              <td align="left">179</td>
              <td align="left">124</td>
              <td align="left">166</td>
            </tr>
            <tr>
              <td align="left">NG50</td>
              <td align="left">164,390</td>
              <td align="left">95,486</td>
              <td align="left">96,308</td>
              <td align="left">105,781</td>
            </tr>
            <tr>
              <td align="left">NG80</td>
              <td align="left">63,677</td>
              <td align="left">43,814</td>
              <td align="left">43,972</td>
              <td align="left">41,901</td>
            </tr>
            <tr>
              <td align="left">max</td>
              <td align="left">297,975</td>
              <td align="left">268,283</td>
              <td align="left">268,372</td>
              <td align="left">221,692</td>
            </tr>
            <tr>
              <td align="left">mean</td>
              <td align="left">71,305</td>
              <td align="left">25,465</td>
              <td align="left">37,381</td>
              <td align="left">27,406</td>
            </tr>
            <tr>
              <td align="left">genome coverage</td>
              <td align="left">97.44%</td>
              <td align="left">98.67%</td>
              <td align="left">95.58%</td>
              <td align="left">97.97%</td>
            </tr>
            <tr>
              <td align="left">incorrect contigs (mean)</td>
              <td align="left">8(6,145)</td>
              <td align="left">5(9,909)</td>
              <td align="left">5(39,765)</td>
              <td align="left">8(7,202)</td>
            </tr>
            <tr>
              <td align="left">time (in seconds)</td>
              <td align="left">325</td>
              <td align="left">490</td>
              <td align="left">595</td>
              <td align="left">533</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>PASHA uses the parameters "k = 31", Velvet uses "k = 31, -exp_cov = auto, -cov_cutoff = auto", ABySS uses "k = 33, n = 10" and SOAPdenvo uses "k = 23, insert_length = 215".</p>
        </table-wrap-foot>
      </table-wrap>
      <p>To demonstrate the capability of PASHA to handle large genomes, we have further assembled the genome of a Yoruban male individual using the above compute resources. The first two stages of PASHA are computed on the 8-node cluster, and the last two stages run on the 8-core workstation. The <italic>contig </italic>generation of ABySS is computed on the 8-node cluster and the scaffolding is performed on the 8-core workstation. Both PAHSA and ABySS use a <italic>k</italic>-mer size of 27 for the assembly. Tables <xref ref-type="table" rid="T5">5</xref> and <xref ref-type="table" rid="T6">6</xref> show the PASHA and ABySS assembly results both with, and without, scaffolding between PASHA and ABySS, where we only consider <italic>contigs </italic>and <italic>scaffolds </italic>of lengths ≥ 100bps. Without scaffolding, PASHA produces an NG50 <italic>contig </italic>size of 503 with a largest <italic>contig </italic>length of 18,981 and ABySS gives an NG50 <italic>contig </italic>size of 513 with a largest <italic>contig </italic>length 15,909. As for genome coverage, PASHA correctly aligned 98.88% of the <italic>contigs</italic>, covering about 66.47% of the human genome, and ABySS correctly aligned 99.18% of the <italic>contigs</italic>, covering about 68.90% of the human genome. The longest correct <italic>contig </italic>has a length of 18,252 for PASHA, indicating that the largest <italic>contig </italic>failed to be aligned to the human genome, and a length of 15,909 for ABySS. With scaffolding, PASHA yields an NG50 <italic>scaffold </italic>size of 2,294 and a largest <italic>scaffold </italic>length of 54,491, giving a genome coverage of about 66.94%. ABySS gives an NG50 <italic>scaffold </italic>size of 1,326 and a largest <italic>scaffold </italic>length of 29,862, giving a genome coverage of about 71.52%. Overall, PASHA demonstrates competitive assembly quality with ABySS in terms of <italic>contigs </italic>and <italic>scaffolds</italic>.</p>
      <table-wrap id="T5" position="float">
        <label>Table 5</label>
        <caption>
          <p>Assembly results for the Yoruban male genome without scaffolding</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="left">PASHA</th>
              <th align="left">ABySS</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">NG50</td>
              <td align="left">503</td>
              <td align="left">513</td>
            </tr>
            <tr>
              <td align="left">max</td>
              <td align="left">18,981</td>
              <td align="left">15,909</td>
            </tr>
            <tr>
              <td align="left">mean</td>
              <td align="left">581</td>
              <td align="left">543</td>
            </tr>
            <tr>
              <td align="left">median</td>
              <td align="left">283</td>
              <td align="left">261</td>
            </tr>
            <tr>
              <td align="left">genome coverage</td>
              <td align="left">66.47%</td>
              <td align="left">68.90%</td>
            </tr>
            <tr>
              <td align="left">no. of contigs</td>
              <td align="left">3,518,718</td>
              <td align="left">3,916,628</td>
            </tr>
            <tr>
              <td align="left">incorrect contigs (mean)</td>
              <td align="left">39,419(467)</td>
              <td align="left">31,189(413)</td>
            </tr>
            <tr>
              <td align="left">sum (bps)</td>
              <td align="left">2,045,433,773</td>
              <td align="left">2,125,482,148</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <table-wrap id="T6" position="float">
        <label>Table 6</label>
        <caption>
          <p>Assembly results for the Yoruban male genome with scaffolding</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="left">PASHA</th>
              <th align="left">ABySS</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">NG50</td>
              <td align="left">2,294</td>
              <td align="left">1,326</td>
            </tr>
            <tr>
              <td align="left">max</td>
              <td align="left">54,491</td>
              <td align="left">29,862</td>
            </tr>
            <tr>
              <td align="left">mean</td>
              <td align="left">1,948</td>
              <td align="left">1,170</td>
            </tr>
            <tr>
              <td align="left">median</td>
              <td align="left">973</td>
              <td align="left">636</td>
            </tr>
            <tr>
              <td align="left">genome coverage</td>
              <td align="left">66.94%</td>
              <td align="left">71.52%</td>
            </tr>
            <tr>
              <td align="left">no. of scaffolds</td>
              <td align="left">1,133,810</td>
              <td align="left">1,893,930</td>
            </tr>
            <tr>
              <td align="left">incorrect contigs (mean)</td>
              <td align="left">70,160(367)</td>
              <td align="left">27,367(726)</td>
            </tr>
            <tr>
              <td align="left">sum (bps)</td>
              <td align="left">2,208,249,938</td>
              <td align="left">2,216,254,604</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>In terms of execution speed, PASHA takes about 21 hours to complete the whole assembly, running on 32 cores (i.e. using 16 MPI processes) in the 8-node cluster with 24 GB per node (a total memory size of 192 GB) and on the 8-core workstation with 72 GB memory (details are shown in Table <xref ref-type="table" rid="T7">7</xref>). Using the same compute resources, ABySS takes about 50.6 hours, about 2.38× slower than PASHA. Hence, we may say that PASHA has a higher performance-cost ratio than ABySS for the assembly of genomes as large as the human genome.</p>
      <table-wrap id="T7" position="float">
        <label>Table 7</label>
        <caption>
          <p>Runtime of PASHA and utilized compute resources for different stages</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">Stages</th>
              <th align="left">Time (h)</th>
              <th align="left">No. of CPUs</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left"><italic>k</italic>-mer generation and distribution</td>
              <td align="left">0.7</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">de Bruijn graph construction and simplification</td>
              <td align="left">3.1</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">bubble merging and contig generation</td>
              <td align="left">11.6</td>
              <td align="left">8</td>
            </tr>
            <tr>
              <td align="left">scaffolding</td>
              <td align="left">5.9</td>
              <td align="left">8</td>
            </tr>
            <tr>
              <td align="left">overall</td>
              <td align="left">21.3</td>
              <td align="left">N/A</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>Scalability</title>
      <p>To evaluate the scalability of PASHA, we have carried out the assemblies of the three small datasets on a different number of CPU cores. The first two stages of PASHA are executed on the compute cluster using different numbers of CPU cores, and the last two stages on a single node using four threads. Since PASHA uses two threads for one MPI process, we start the evaluation from two CPU cores.</p>
      <p>Figure <xref ref-type="fig" rid="F3">3</xref> shows the execution time of PASHA on different numbers of CPU cores. From the figure, it can be seen that PASHA is able to decrease the execution time as the number of CPU cores increases. However, limited by the execution time of the last two stages, the overall execution time decreases slowly and will ultimately reach a plateau. Furthermore, we have compared the execution speed between PASHA and ABySS using the same number of CPU cores in the above cluster. Using the three datasets, PASHA is about 2.25× faster on average than ABySS. We did not compare the execution time with SOAPdenovo since it is a multi-threaded algorithm for shared-memory systems and requires a very large amount of memory for the human genome assembly problem.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Execution time of PASHA on different numbers of CPU cores</bold>.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-354-3"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>Conclusions</title>
    <p>In this paper, we have presented PASHA, a parallelized short read assembler for large genomes using de Bruijn graphs. Taking advantage of both shared-memory multi-core CPUs and distributed-memory compute clusters, PASHA has demonstrated its potential to perform high-quality de-novo assembly of large genomes in reasonable time with modest compute resources.</p>
    <p>Our evaluation using three small real paired-end datasets shows that PASHA is able to produce better assemblies with comparable genome coverage and mis-assembly rates compared to three leading assemblers: Velvet, ABySS and SOAPdenovo. Moreover, PASHA achieves the fastest speed for all three datasets on a single CPU. For the Yoruban male genome, PASHA is able to complete the assembly in about 21 hours with modest compute resources, which is about 2.38× faster than ABySS running on the same compute resources. Without scaffolding, PASHA yields an NG50 <italic>contig </italic>size of 503 with the longest correct <italic>contig </italic>length of 18,252, and with scaffolding, it produces an NG50 <italic>scaffold </italic>size of 2,294. PASHA achieves competitive assembly quality with ABySS, but takes less execution time using the same compute resources. For scalability, PASHA is able to reduce the execution time as the number of CPU cores increases, and is about 2.25× faster on average than ABySS running on the same number of CPU cores.</p>
  </sec>
  <sec>
    <title>Abbreviations</title>
    <p>CPU: Central Processing Unit; MPI: Message Passing Interface; SRA: Sequence Read Archive</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>YL conceptualized the study, carried out the design and implementation of the algorithm, performed benchmark tests, analyzed the results and drafted the manuscript; BS conceptualized the study, participated in the algorithm optimization and analysis of the results and contributed to the revising of the manuscript; DLM conceptualized the study, participated in the analysis of the results, and contributed to the revising of the manuscript. All authors read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>The authors thank Dr. Zheng Zejun for providing the short read datasets as well as their respective reference genomes, thank Dr. Liu Weiguo for providing the experimental environments, and thank the anonymous reviewers whose constructive comments helped to improve the manuscript.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Warren</surname>
          <given-names>RL</given-names>
        </name>
        <name>
          <surname>Sutton</surname>
          <given-names>GG</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>SJ</given-names>
        </name>
        <name>
          <surname>Holt</surname>
          <given-names>RA</given-names>
        </name>
        <article-title>Assembling millions of short DNA sequences using SSAKE</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <issue>4</issue>
        <fpage>500</fpage>
        <lpage>501</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl629</pub-id>
        <pub-id pub-id-type="pmid">17158514</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Jeck</surname>
          <given-names>WR</given-names>
        </name>
        <name>
          <surname>Reinhardt</surname>
          <given-names>JA</given-names>
        </name>
        <name>
          <surname>Baltrus</surname>
          <given-names>DA</given-names>
        </name>
        <name>
          <surname>Hickenbotham</surname>
          <given-names>MT</given-names>
        </name>
        <name>
          <surname>Magrini</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Mardis</surname>
          <given-names>ER</given-names>
        </name>
        <name>
          <surname>Dangl</surname>
          <given-names>JL</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>CD</given-names>
        </name>
        <article-title>Extending assembly of short DNA sequences to handle error</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <issue>21</issue>
        <fpage>2942</fpage>
        <lpage>2944</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btm451</pub-id>
        <pub-id pub-id-type="pmid">17893086</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dohm</surname>
          <given-names>JC</given-names>
        </name>
        <name>
          <surname>Lottaz</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Borodina</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Himmelbauer</surname>
          <given-names>H</given-names>
        </name>
        <article-title>SHARCGS, a fast and highly accurate short-read assembly algorithm for de novo genomic sequencing</article-title>
        <source>Genome Res</source>
        <year>2007</year>
        <volume>17</volume>
        <issue>11</issue>
        <fpage>1697</fpage>
        <lpage>1706</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.6435207</pub-id>
        <pub-id pub-id-type="pmid">17908823</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Sinha</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Beresford-Smith</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Puglisi</surname>
          <given-names>SJ</given-names>
        </name>
        <article-title>A fast hybrid short read fragment assembly algorithm</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>17</issue>
        <fpage>2279</fpage>
        <lpage>2280</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp374</pub-id>
        <pub-id pub-id-type="pmid">19535537</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ariyaratne</surname>
          <given-names>PN</given-names>
        </name>
        <name>
          <surname>Sung</surname>
          <given-names>WK</given-names>
        </name>
        <article-title>PE-Assembler: de novo assembler using short paired-end reads</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>2</issue>
        <fpage>167</fpage>
        <lpage>174</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq626</pub-id>
        <pub-id pub-id-type="pmid">21149345</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pevzner</surname>
          <given-names>PA</given-names>
        </name>
        <name>
          <surname>Tang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>MS</given-names>
        </name>
        <article-title>An Eulerian path approach to DNA fragment assembly</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>2001</year>
        <volume>98</volume>
        <issue>17</issue>
        <fpage>9748</fpage>
        <lpage>9753</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.171285098</pub-id>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Butler</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>MacCallum</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Kleber</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Shlyakhter</surname>
          <given-names>IA</given-names>
        </name>
        <name>
          <surname>Belmonte</surname>
          <given-names>MK</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>ES</given-names>
        </name>
        <name>
          <surname>Nusbaum</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Jaffe</surname>
          <given-names>DB</given-names>
        </name>
        <article-title>ALLPATHS: de novo assembly of whole-genome shotgun microreads</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>5</issue>
        <fpage>810</fpage>
        <lpage>820</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.7337908</pub-id>
        <pub-id pub-id-type="pmid">18340039</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zerbino</surname>
          <given-names>DR</given-names>
        </name>
        <name>
          <surname>Birney</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>5</issue>
        <fpage>821</fpage>
        <lpage>829</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.074492.107</pub-id>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Simpson</surname>
          <given-names>JT</given-names>
        </name>
        <name>
          <surname>Wong</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Jackman</surname>
          <given-names>SD</given-names>
        </name>
        <name>
          <surname>Schein</surname>
          <given-names>JE</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>SJ</given-names>
        </name>
        <name>
          <surname>Birol</surname>
          <given-names>I</given-names>
        </name>
        <article-title>ABySS: a parallel assembler for short read sequence data</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <issue>6</issue>
        <fpage>1117</fpage>
        <lpage>1123</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.089532.108</pub-id>
        <pub-id pub-id-type="pmid">19251739</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Zhu</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Qian</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Fang</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Shi</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Shan</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Yang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title>
        <source>Genome Res</source>
        <year>2010</year>
        <volume>20</volume>
        <issue>2</issue>
        <fpage>265</fpage>
        <lpage>272</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.097261.109</pub-id>
        <pub-id pub-id-type="pmid">20019144</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gnerre</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Maccallum</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Przybylski</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Ribeiro</surname>
          <given-names>FJ</given-names>
        </name>
        <name>
          <surname>Burton</surname>
          <given-names>JN</given-names>
        </name>
        <name>
          <surname>Walker</surname>
          <given-names>BJ</given-names>
        </name>
        <name>
          <surname>Sharpe</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Hall</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Shea</surname>
          <given-names>TP</given-names>
        </name>
        <name>
          <surname>Sykes</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Berlin</surname>
          <given-names>AM</given-names>
        </name>
        <name>
          <surname>Aird</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Costello</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Daza</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Williams</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Nicol</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Gnirke</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Nusbaum</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>ES</given-names>
        </name>
        <name>
          <surname>Jaffe</surname>
          <given-names>DB</given-names>
        </name>
        <article-title>High-quality draft assemblies of mammalian genomes from massively parallel sequence data</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>2011</year>
        <volume>108</volume>
        <issue>4</issue>
        <fpage>1513</fpage>
        <lpage>1518</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.1017351108</pub-id>
        <pub-id pub-id-type="pmid">21187386</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="other">
        <name>
          <surname>Jackson</surname>
          <given-names>BG</given-names>
        </name>
        <name>
          <surname>Regennitter</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Yang</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Schnable</surname>
          <given-names>PS</given-names>
        </name>
        <name>
          <surname>Aluru</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Parallel de novo assembly of large genomes from high-throughput short reads</article-title>
        <source>25th IEEE International Symposium on Parallel &amp; Distributed Processing (IPDPS)</source>
        <year>2010</year>
        <fpage>1</fpage>
        <lpage>10</lpage>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zerbino</surname>
          <given-names>DR</given-names>
        </name>
        <name>
          <surname>McEwen</surname>
          <given-names>GK</given-names>
        </name>
        <name>
          <surname>Margulies</surname>
          <given-names>EH</given-names>
        </name>
        <name>
          <surname>Birney</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Pebble and Rock Band: heuristic resolution of repeats and scaffolding in the Velvet short-read de novo assembler</article-title>
        <source>PLoS One</source>
        <year>2009</year>
        <volume>4</volume>
        <issue>12</issue>
        <fpage>e8407</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0008407</pub-id>
        <pub-id pub-id-type="pmid">20027311</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bentley</surname>
          <given-names>DR</given-names>
        </name>
        <name>
          <surname>Balasubramanian</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Swerdlow</surname>
          <given-names>HP</given-names>
        </name>
        <name>
          <surname>Smith</surname>
          <given-names>GP</given-names>
        </name>
        <name>
          <surname>Milton</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Brown</surname>
          <given-names>CG</given-names>
        </name>
        <name>
          <surname>Hall</surname>
          <given-names>KP</given-names>
        </name>
        <name>
          <surname>Evers</surname>
          <given-names>DJ</given-names>
        </name>
        <name>
          <surname>Barnes</surname>
          <given-names>CL</given-names>
        </name>
        <name>
          <surname>Bignell</surname>
          <given-names>HR</given-names>
        </name>
        <name>
          <surname>Boutell</surname>
          <given-names>JM</given-names>
        </name>
        <name>
          <surname>Bryant</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Carter</surname>
          <given-names>RJ</given-names>
        </name>
        <name>
          <surname>Keira Cheetham</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Cox</surname>
          <given-names>AJ</given-names>
        </name>
        <name>
          <surname>Ellis</surname>
          <given-names>DJ</given-names>
        </name>
        <name>
          <surname>Flatbush</surname>
          <given-names>MR</given-names>
        </name>
        <name>
          <surname>Gormley</surname>
          <given-names>NA</given-names>
        </name>
        <name>
          <surname>Humphray</surname>
          <given-names>SJ</given-names>
        </name>
        <name>
          <surname>Irving</surname>
          <given-names>LJ</given-names>
        </name>
        <name>
          <surname>Karbelashvili</surname>
          <given-names>MS</given-names>
        </name>
        <name>
          <surname>Kirk</surname>
          <given-names>SM</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Liu</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Maisinger</surname>
          <given-names>KS</given-names>
        </name>
        <name>
          <surname>Murray</surname>
          <given-names>LJ</given-names>
        </name>
        <name>
          <surname>Obradovic</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Ost</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Parkinson</surname>
          <given-names>ML</given-names>
        </name>
        <name>
          <surname>Pratt</surname>
          <given-names>MR</given-names>
        </name>
        <etal/>
        <article-title>Accurate whole human genome sequencing using reversible terminator chemistry</article-title>
        <source>Nature</source>
        <year>2008</year>
        <volume>456</volume>
        <issue>7218</issue>
        <fpage>53</fpage>
        <lpage>59</lpage>
        <pub-id pub-id-type="doi">10.1038/nature07517</pub-id>
        <pub-id pub-id-type="pmid">18987734</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Shi</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Liu</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Müller-Wittig</surname>
          <given-names>W</given-names>
        </name>
        <article-title>A parallel algorithm for error correction in high-throughput short-read data on CUDA-enabled graphics hardware</article-title>
        <source>J Comput Biol</source>
        <year>2010</year>
        <volume>17</volume>
        <issue>4</issue>
        <fpage>603</fpage>
        <lpage>615</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2009.0062</pub-id>
        <pub-id pub-id-type="pmid">20426693</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kelley</surname>
          <given-names>DR</given-names>
        </name>
        <name>
          <surname>Schatz</surname>
          <given-names>MC</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <article-title>Quake: quality-aware detection and correction of sequencing errors</article-title>
        <source>Genome Biol</source>
        <year>2010</year>
        <volume>11</volume>
        <issue>11</issue>
        <fpage>R116</fpage>
        <pub-id pub-id-type="pmid">21114842</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Conway</surname>
          <given-names>TC</given-names>
        </name>
        <name>
          <surname>Bromage</surname>
          <given-names>AJ</given-names>
        </name>
        <article-title>Succinct data structures for assembling large genomes</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>4</issue>
        <fpage>479</fpage>
        <lpage>486</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq697</pub-id>
        <pub-id pub-id-type="pmid">21245053</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kent</surname>
          <given-names>WJ</given-names>
        </name>
        <article-title>BLAT--the BLAST-like alignment tool</article-title>
        <source>Genome Res</source>
        <year>2002</year>
        <volume>12</volume>
        <fpage>656</fpage>
        <lpage>664</lpage>
        <pub-id pub-id-type="pmid">11932250</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
