<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Acta Crystallogr A Found Adv</journal-id>
    <journal-id journal-id-type="iso-abbrev">Acta Crystallogr A Found Adv</journal-id>
    <journal-id journal-id-type="publisher-id">Acta Cryst. A</journal-id>
    <journal-title-group>
      <journal-title>Acta Crystallographica. Section A, Foundations and Advances</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2053-2733</issn>
    <publisher>
      <publisher-name>International Union of Crystallography</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6718201</article-id>
    <article-id pub-id-type="publisher-id">ae5071</article-id>
    <article-id pub-id-type="doi">10.1107/S2053273319010593</article-id>
    <article-id pub-id-type="coden">ACSAD7</article-id>
    <article-id pub-id-type="pii">S2053273319010593</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Papers</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title><italic>XGANDALF</italic> – extended gradient descent algorithm for lattice finding</article-title>
      <alt-title>
        <italic>XGANDALF</italic>
      </alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0001-9273-7648</contrib-id>
        <name>
          <surname>Gevorkov</surname>
          <given-names>Yaroslav</given-names>
        </name>
        <xref ref-type="aff" rid="a">a</xref>
        <xref ref-type="aff" rid="b">b</xref>
        <xref ref-type="corresp" rid="cor">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Yefanov</surname>
          <given-names>Oleksandr</given-names>
        </name>
        <xref ref-type="aff" rid="a">a</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Barty</surname>
          <given-names>Anton</given-names>
        </name>
        <xref ref-type="aff" rid="a">a</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>White</surname>
          <given-names>Thomas A.</given-names>
        </name>
        <xref ref-type="aff" rid="a">a</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mariani</surname>
          <given-names>Valerio</given-names>
        </name>
        <xref ref-type="aff" rid="a">a</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Brehm</surname>
          <given-names>Wolfgang</given-names>
        </name>
        <xref ref-type="aff" rid="a">a</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tolstikova</surname>
          <given-names>Aleksandra</given-names>
        </name>
        <xref ref-type="aff" rid="a">a</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Grigat</surname>
          <given-names>Rolf-Rainer</given-names>
        </name>
        <xref ref-type="aff" rid="b">b</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0002-4655-1743</contrib-id>
        <name>
          <surname>Chapman</surname>
          <given-names>Henry N.</given-names>
        </name>
        <xref ref-type="aff" rid="a">a</xref>
        <xref ref-type="aff" rid="c">c</xref>
        <xref ref-type="aff" rid="d">d</xref>
      </contrib>
      <aff id="a"><label>a</label>Center for Free-Electron Laser Science, Deutsches Elektronen-Synchrotron DESY, Notkestraße 85, 22607 Hamburg, <country>Germany</country></aff>
      <aff id="b"><label>b</label>Institute of Vision Systems, Hamburg University of Technology, Harburger Schloßstraße 20, 21079 Hamburg, <country>Germany</country></aff>
      <aff id="c"><label>c</label>Department of Physics, Universität Hamburg, Luruper Chaussee 149, 22761 Hamburg, <country>Germany</country></aff>
      <aff id="d"><label>d</label>The Hamburg Center for Ultrafast Imaging, Universität Hamburg, Luruper Chaussee 149, 22761 Hamburg, <country>Germany</country></aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor">Correspondence e-mail: <email>yaroslav.gevorkov@desy.de</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <day>01</day>
      <month>9</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>30</day>
      <month>8</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>8</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>75</volume>
    <issue>Pt 5</issue>
    <issue-id pub-id-type="publisher-id">a190500</issue-id>
    <fpage>694</fpage>
    <lpage>704</lpage>
    <history>
      <date date-type="received">
        <day>29</day>
        <month>5</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>26</day>
        <month>7</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© Yaroslav Gevorkov et al. 2019</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution (CC-BY) Licence, which permits unrestricted
use, distribution, and reproduction in any medium, provided the original authors and source are cited.</license-p>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/">http://creativecommons.org/licenses/by/4.0/</ali:license_ref>
      </license>
    </permissions>
    <self-uri xlink:href="https://doi.org/10.1107/S2053273319010593">A full version of this article is available from Crystallography Journals Online.</self-uri>
    <abstract abstract-type="toc">
      <p>A description and evaluation are given of <italic>XGANDALF</italic>, extended gradient descent algorithm for lattice finding, an algorithm developed for fast and accurate indexing of snapshot diffraction patterns.</p>
    </abstract>
    <abstract>
      <p>Serial crystallography records still diffraction patterns from single, randomly oriented crystals, then merges data from hundreds or thousands of them to form a complete data set. To process the data, the diffraction patterns must first be indexed, equivalent to determining the orientation of each crystal. A novel automatic indexing algorithm is presented, which in tests usually gives significantly higher indexing rates than alternative programs currently available for this task. The algorithm does not require prior knowledge of the lattice parameters but can make use of that information if provided, and also allows indexing of diffraction patterns generated by several crystals in the beam. Cases with a small number of Bragg spots per pattern appear to particularly benefit from the new approach. The algorithm has been implemented and optimized for fast execution, making it suitable for real-time feedback during serial crystallography experiments. It is implemented in an open-source C++ library and distributed under the LGPLv3 licence. An interface to it has been added to the <italic>CrystFEL</italic> software suite.</p>
    </abstract>
    <kwd-group>
      <kwd>indexing</kwd>
      <kwd>
        <italic>XGANDALF</italic>
      </kwd>
      <kwd>
        <italic>CrystFEL</italic>
      </kwd>
      <kwd>multiple lattices</kwd>
      <kwd>serial crystallography</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>H2020 Marie Skłodowska-Curie Actions</funding-source>
        <award-id>637295</award-id>
      </award-group>
      <award-group>
        <funding-source>Bundesministerium für Bildung und Forschung</funding-source>
        <award-id>05K18CHA</award-id>
      </award-group>
      <award-group>
        <funding-source>Deutsche Forschungsgemeinschaft</funding-source>
        <award-id>194651731</award-id>
        <award-id>390715994</award-id>
      </award-group>
      <funding-statement>This work was funded by <funding-source>H2020 Marie Skłodowska-Curie Actions</funding-source> grant <award-id>637295</award-id>. <funding-source>Bundesministerium für Bildung und Forschung</funding-source> grant <award-id>05K18CHA</award-id>. <funding-source>Deutsche Forschungsgemeinschaft</funding-source> grants <award-id>194651731</award-id> and <award-id>390715994</award-id>. </funding-statement>
    </funding-group>
    <counts>
      <page-count count="11"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec sec-type="introduction" id="sec1">
    <label>1.</label>
    <title>Introduction   </title>
    <p>Serial crystallography (SX) experiments (Chapman <italic>et al.</italic>, 2011<xref ref-type="bibr" rid="bb2"> ▸</xref>; Schlichting, 2015<xref ref-type="bibr" rid="bb17"> ▸</xref>) record a sequence of diffraction patterns, each from a different crystal in a random and unknown orientation. Measurements from hundreds or many thousands of crystals are used to build up a complete data set. Experiments usually aim to measure not more than one crystal per diffraction pattern, although the contribution of multiple crystals in a single diffraction measurement is not uncommon. The difference in the measurement approach compared with conventional rotation crystallography has necessitated the development of new software for processing SX data, with several software packages now available including <italic>CrystFEL</italic> (White <italic>et al.</italic>, 2012<xref ref-type="bibr" rid="bb24"> ▸</xref>), <italic>DIALS</italic> (Winter <italic>et al.</italic>, 2018<xref ref-type="bibr" rid="bb26"> ▸</xref>) and <italic>nXDS</italic> (Kabsch, 2014<xref ref-type="bibr" rid="bb10"> ▸</xref>). The main steps in analysis involve Bragg spot detection, indexing diffraction patterns, integration of detector counts in Bragg reflections, and merging of data from all individual crystals into a common data set. A key step is indexing the Bragg spots observed in a pattern, which is required to integrate and scale Bragg intensities into a common lattice and to predict the locations of other Bragg spots to be included in this merging process. Several automatic indexing algorithms have been developed and implemented in widely used software like <italic>MOSFLM</italic> (Powell, 1999<xref ref-type="bibr" rid="bb15"> ▸</xref>), <italic>XDS</italic> (Kabsch, 1993<xref ref-type="bibr" rid="bb8"> ▸</xref>, 2010<xref ref-type="bibr" rid="bb9"> ▸</xref>), <italic>DirAx</italic> (Duisenberg, 1992<xref ref-type="bibr" rid="bb3"> ▸</xref>) and <italic>LABELIT</italic> (Sauter &amp; Zwart, 2009<xref ref-type="bibr" rid="bb16"> ▸</xref>). Although originally devised for rotation-series data, these algorithms are also capable of indexing snapshot diffraction patterns. Other algorithms have been devised specifically for snapshot data (Ginn <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb5"> ▸</xref>; Gildea <italic>et al.</italic>, 2014<xref ref-type="bibr" rid="bb4"> ▸</xref>).</p>
    <p>In our SX experiments we often observe crystal diffraction patterns which appear to correspond to crystal lattices but nonetheless cannot be indexed by the existing approaches. Even when several different indexing algorithms are applied to each pattern, only a fraction of the frames can be indexed. Patterns with small numbers of Bragg spots, large amounts of background noise that lead to spurious peaks in the Bragg peak detection stage, or with multiple overlapping crystal diffraction patterns (‘multiple hits’) are particularly problematic and often cannot be indexed by current algorithms. In principle, it should be possible to index every diffraction pattern provided that Bragg spot locations are consistent with a true crystal diffraction pattern rather than spurious noise. It thus appears advantageous to deviate from previous approaches adapted from indexing rotation data and instead develop an algorithm for the express purpose of indexing SX crystal diffraction patterns. We set out to develop such a new and computationally efficient algorithm for indexing SX crystal diffraction patterns with the aim of maximizing the indexing rate while being robust to outliers.</p>
    <p>Indexing involves identifying the diffraction order of all Bragg spots measured in a diffraction pattern, equivalent to determining the crystal orientation. In most indexing algorithms, the process begins by mapping the positions of Bragg spots found on the detector to radiation scattering momentum transfer vectors <inline-formula><inline-graphic xlink:href="a-75-00694-efi1.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> in the three-dimensional (3D) reciprocal space using prior information about the detector geometry (including sample-to-detector distance) and the wavelength of the incident beam. The resulting points in 3D reciprocal space approximate the points of the reciprocal lattice, which is initially unknown. We call these points ‘nodes’ to abstract the problem from crystallographic indexing to the more general problem of fitting a lattice to noisy locations. One possible approach to indexing is to detect maxima in the Fourier transform of the pattern of nodes (Steller <italic>et al.</italic>, 1997<xref ref-type="bibr" rid="bb20"> ▸</xref>). Such maxima mark the directions with maximum periodic repetition, which can form the basis vectors of the wanted lattice. This approach is taken in <italic>DIALS</italic> (Gildea <italic>et al.</italic>, 2014<xref ref-type="bibr" rid="bb4"> ▸</xref>) and <italic>MOSFLM</italic> (Powell, 1999<xref ref-type="bibr" rid="bb15"> ▸</xref>). The related <italic>DirAx</italic> algorithm finds principal repeat directions by searching for frequently occurring repeats perpendicular to triplets of nodes (Duisenberg, 1992<xref ref-type="bibr" rid="bb3"> ▸</xref>). Another popular indexing approach is to search for frequently occurring difference vectors between the nodes, as is done in <italic>XDS</italic> (Kabsch, 2010<xref ref-type="bibr" rid="bb9"> ▸</xref>) and <italic>TakeTwo</italic> (Ginn <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb5"> ▸</xref>). The <italic>FELIX</italic> indexer (Beyerlein <italic>et al.</italic>, 2017<xref ref-type="bibr" rid="bb1"> ▸</xref>) uses a different approach which is to map the set of possible crystal orientations that are consistent with particular Bragg spots to lines in Rodrigues–Frank space to find a consensus orientation for all peaks.</p>
    <p>Our algorithm can be considered as a modified version of the Fourier methods. To improve noise tolerance, we replace the Fourier transform by a similar transform that uses periodic basis functions combined with a non-linear weighting scheme. To achieve fast execution, the algorithm employs a multi-step heuristic, <italic>i.e.</italic> an approximate but efficient method, based on an extended gradient approach to identify maxima in the transformed pattern of nodes corresponding to points on the real-space crystal lattice. The real-space lattice basis is then formed from these maxima, while maximizing the number of the observed nodes that are consistent with that basis choice and minimizing the distances between those nodes and their closest lattice point. An overview of the main steps of the proposed algorithm is provided in Fig. 1<xref ref-type="fig" rid="fig1"> ▸</xref>.</p>
    <p>We call our algorithm <italic>XGANDALF</italic>, eXtended GrAdieNt Descent Algorithm for Lattice Finding.</p>
  </sec>
  <sec id="sec2">
    <label>2.</label>
    <title>Algorithm description   </title>
    <sec id="sec2.1">
      <label>2.1.</label>
      <title>Overview   </title>
      <p>The indexing algorithm determines the Miller indices of a number of observed Bragg peaks in a snapshot diffraction pattern, given knowledge of the experiment geometry and optionally the unit-cell parameters of the crystal. It consists of the following key steps:</p>
      <p>(i) Bragg spot locations on the detector are mapped to positions in reciprocal space. We call the location of the momentum transfer vector of a Bragg spot a node, to distinguish it from the exact reciprocal-lattice points, the locations of which are initially unknown.</p>
      <p>(ii) Each node in reciprocal space is used to define a set of equidistant parallel planes in 3D real space, as shown in Fig. 2<xref ref-type="fig" rid="fig2"> ▸</xref>. Intersections of parallel planes generated from different nodes are solutions to the indexing problem. The rest of the algorithm is devoted to finding these intersections in the presence of noise, spurious peaks and multiple lattices.</p>
      <p>(iii) Continuous ‘proximity functions’ based on distance to each node’s parallel planes are defined and summed to create a score function to find the points of intersection. Intersections of planes become maxima of the score function, with the continuous score function serving to suppress the effect of experiment noise and inaccuracies. A series of progressively sharper and steeper proximity functions are used with the result that spurious nodes corresponding to falsely identified Bragg peaks or reflections belonging to competing lattices are removed from the set of Bragg reflections that are used to generate the nodes.</p>
      <p>(iv) A heuristic (a fast technique for finding approximate solutions) is used to find maxima of the score function. Sharper proximity functions require more computations to find maxima, hence we choose more computationally efficient proximity functions to reduce the search space early in the computation. An extended gradient descent method is applied to migrate the starting points to the maxima of the score function and avoid otherwise slow convergence due to zigzag optimization trajectories.</p>
      <p>(v) The bases of the found lattices provide the indexing solutions once the maxima of the score function have been found. A refinement step is then performed to minimize the mean Euclidean distance between the observed and predicted nodes using a gradient descent approach.</p>
    </sec>
    <sec id="sec2.2">
      <label>2.2.</label>
      <title>Relation between nodes and the indexing solution   </title>
      <p>The Laue equations for a node <bold>q</bold>, the crystal lattice basis vectors <bold>a</bold>, <bold>b</bold>, <bold>c</bold>, and the Miller indices <italic>h</italic>, <italic>k</italic>, <italic>l</italic>, are defined as <disp-formula id="fd1"><graphic xlink:href="a-75-00694-efd1.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>The nodes are the known observables, defined by the Bragg spots and the experimental parameters. The basis as well as the Miller indices need to be identified. Finding a solution to the above equation is equivalent to finding three linear independent solutions to the equation <disp-formula id="fd2"><graphic xlink:href="a-75-00694-efd2.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>with a lattice basis vector <bold>t</bold>. Enforcing all <italic>K</italic> nodes found in the pattern to be on the reciprocal lattice by combining the nodes <bold>q</bold> into a matrix <bold>Q</bold> yields the following over-determined system of equations: <disp-formula id="fd3"><graphic xlink:href="a-75-00694-efd3.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>Each node <inline-formula><inline-graphic xlink:href="a-75-00694-efi2.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> forms through equation (3)<xref ref-type="disp-formula" rid="fd3"/> a series of equidistant parallel planes in the 3D space of <bold>t</bold> vectors distinguished and enumerated by the integers <inline-formula><inline-graphic xlink:href="a-75-00694-efi3.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>. These are the planes of the real-space lattice of the crystal associated with the node. Any point on any of the planes is a solution to the equation formed by this node. The planes are orthogonal to <inline-formula><inline-graphic xlink:href="a-75-00694-efi2.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> and their spacing is given by <inline-formula><inline-graphic xlink:href="a-75-00694-efi5.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>. Different nodes form different sets of real-space planes; their intersections correspond to the real-space lattice, which are thus the points that solve equation (3)<xref ref-type="disp-formula" rid="fd3"/>. In an equivalent two-dimensional (2D) model, every node would form a series of equidistant parallel lines, as depicted in Fig. 2<xref ref-type="fig" rid="fig2"> ▸</xref>.</p>
      <p>To solve equation (3)<xref ref-type="disp-formula" rid="fd3"/>, three linearly independent vectors must be found, where each vector points to one of the planes of each and every node (that is, to their intersections). Under real conditions, there are usually more than three nodes, making the problem over-determined. However, due to noise, the planes corresponding to these nodes will generally not all intersect at common points in real space (see the red node in Fig. 2<xref ref-type="fig" rid="fig2"> ▸</xref>), so an exact solution usually will not exist. The optimal solution <bold>t</bold> for equation (3)<xref ref-type="disp-formula" rid="fd3"/> is therefore one that minimizes the average distance to one of the planes of each node. To find this solution we introduce a score function defined as a sum of proximity functions which themselves encapsulate the distance of the assumed solution from these geometrical planes.</p>
    </sec>
    <sec id="sec2.3">
      <label>2.3.</label>
      <title>Continuous proximity function for noise tolerance   </title>
      <p>Every node defines a series of real-space parallel planes according to equation (3)<xref ref-type="disp-formula" rid="fd3"/> and as sketched in Fig. 2<xref ref-type="fig" rid="fig2"> ▸</xref> for the 2D case. Since the nodes are assumed to be noisy, the locations of the parallel planes also must be assumed to be noisy. This implies that the best estimate of the lattice basis vectors <bold>t</bold> (the optimal solution) might not exactly lie on the planes, but may instead lie close to the planes. Thus we define a 3D real-space proximity function c, that indicates how close a real-space vector is to a plane. This function is chosen to equal its maximum value at points on the planes, and is equal to its minimum value at points equidistant between two planes. A score function is then constructed for the entire arrangement of nodes as a normalized weighted sum of proximity functions given by <disp-formula id="fd4"><graphic xlink:href="a-75-00694-efd4.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>The weighting <inline-formula><inline-graphic xlink:href="a-75-00694-efi6.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> can depend on the intensities of the nodes, their norms, or other properties. The maxima of this score function are the feasible solutions of equation (3)<xref ref-type="disp-formula" rid="fd3"/>, corresponding to real-space lattice points. From these we obtain three linearly independent vectors to describe that lattice.</p>
      <p>An example for the 2D case can be seen in Figs. 3<xref ref-type="fig" rid="fig3"> ▸</xref> and 4<xref ref-type="fig" rid="fig4"> ▸</xref>. Fig. 3<xref ref-type="fig" rid="fig3"> ▸</xref> shows the interpolation of the lines in Fig. 2<xref ref-type="fig" rid="fig2"> ▸</xref> using proximity functions that vary linearly from their minimum to maximum values. Fig. 4<xref ref-type="fig" rid="fig4"> ▸</xref> shows the score function of a sample arrangement of 13 nodes with this same choice of linear proximity functions.</p>
      <p>As mentioned above, the proximity function indicates the distance from sets of parallel planes of equal spacing. While it is defined in 3D real space, it is a function only of distance along lines orthogonal to those planes. It is reasonable to define the proximity function to equal 1 on the planes, −1 midway between two planes, and to vary monotonically between these values. Combining these considerations, a proximity function of the following form is reasonable: <disp-formula id="fd5"><graphic xlink:href="a-75-00694-efd5.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>Many different functions are suitable for use as proximity functions. The execution time and thus the complexity of the function evaluation must be considered in its selection. The proximity function is periodic with a period of 1, so it can be defined in the interval [−0.5, 0.5] with <inline-formula><inline-graphic xlink:href="a-75-00694-efi7.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>. The following proximity functions are available in a tool-kit for further exploration and development of the program:</p>
      <p>(<italic>a</italic>) <inline-formula><inline-graphic xlink:href="a-75-00694-efi8.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>.</p>
      <p>(<italic>b</italic>) <inline-formula><inline-graphic xlink:href="a-75-00694-efi9.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>.</p>
      <p>(<italic>c</italic>) <inline-formula><inline-graphic xlink:href="a-75-00694-efi10.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>.</p>
      <p>(<italic>d</italic>) <inline-formula><inline-graphic xlink:href="a-75-00694-efi11.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>.</p>
      <p>(<italic>e</italic>) <inline-formula><inline-graphic xlink:href="a-75-00694-efi12.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>.</p>
      <p>(<italic>f</italic>) <inline-formula><inline-graphic xlink:href="a-75-00694-efi13.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>.</p>
      <p>(<italic>g</italic>) <inline-formula><inline-graphic xlink:href="a-75-00694-efi14.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>.</p>
      <p>(<italic>h</italic>) <inline-formula><inline-graphic xlink:href="a-75-00694-efi15.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>.</p>
      <p>The proximity functions are visualized in Fig. 5<xref ref-type="fig" rid="fig5"> ▸</xref>. In the implemented heuristic we use only <inline-formula><inline-graphic xlink:href="a-75-00694-efi16.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> and <inline-formula><inline-graphic xlink:href="a-75-00694-efi17.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>.</p>
      <p>It can be noted that using <inline-formula><inline-graphic xlink:href="a-75-00694-efi18.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> as a proximity function turns the score function [equation (4)<xref ref-type="disp-formula" rid="fd4"/>] into the real part of the Fourier transform. Assuming that the geometry of the experiment is accurately known, the locations of the reflections in reciprocal space are centrosymmetric and so, if symmetrized, the Fourier transform of the arrangement of reflections would indeed be real. That is, the score function using <inline-formula><inline-graphic xlink:href="a-75-00694-efi19.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> with <inline-formula><inline-graphic xlink:href="a-75-00694-efi20.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> produces the Fourier transform of the given arrangement of reflections. Such a score function is used in the Fourier indexing methods, where lattice vectors are found by searching for maxima in the Fourier transform of a given arrangement of reflections. Our approach generalizes the use of a Fourier transform to that of an arbitrary proximity function. This extension provides a means to tune the proximity function to either achieve a greater noise tolerance (with a narrowly peaked function) or larger convergence radius for the search (with a broad function).</p>
      <p>Not every Bragg spot found belongs to the same lattice. There may be false positives in the peak finding algorithm or peaks from different crystals in the same diffraction pattern. Such spurious peaks should ideally have as little impact as possible on the maxima of the score function. Their contribution can be removed by introducing a tolerance parameter <inline-formula><inline-graphic xlink:href="a-75-00694-efi21.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>. Nodes that generate planes that are too far away from the inspected vector are excluded from the computation of the score function. This distance of inclusion is given by ∊, so the smaller ∊, the more resistant the score function is to spurious peaks. The drawback of this method is that the score function can be discontinuous. The resulting score function is given by <disp-formula id="fd6"><graphic xlink:href="a-75-00694-efd6.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>with <disp-formula id="fd7"><graphic xlink:href="a-75-00694-efd7.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>The solution to the indexing problem requires finding maxima of the score function. This is done by a local search in the 3D real space of the <bold>t</bold> vectors, which we aim to carry out efficiently to reduce computational time. The search must be started from a diverse number of starting points to ensure that more than one maximum is found. However, the search need only be conducted within a volume of the real space which can feasibly contain the real-space lattice vectors of the crystal. If the lattice parameters are not known in advance, then this volume can be restricted to a shell centred on the origin ranging in radius from the minimum to maximum possible lattice vector magnitudes, given reasonable assumptions. If the lattice parameters are known, then this search volume can be restricted considerably further, to spherical shells, each with a mean radius given by each of the real-space lattice parameters, as done by Gildea <italic>et al.</italic> (2014<xref ref-type="bibr" rid="bb4"> ▸</xref>). The width of the shells is set to a tolerance that is dependent on the uncertainty of the lattice parameters.</p>
      <p>The search is started simultaneously from a large number of evenly spaced points within the search volume that later migrate to the maxima of <inline-formula><inline-graphic xlink:href="a-75-00694-efi22.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> by a gradient descent approach. A typical number of starting points is 50 000. We achieve a set of starting points that are approximately uniformly separated and distributed throughout the volume of the spherical shell by first obtaining positions of points on a spherical surface that are approximately equally spaced from each other. This is done by minimizing a generalized electrostatic potential energy of a system of charged particles (Semechko, 2015<xref ref-type="bibr" rid="bb19"> ▸</xref>). Since such computations can take a very long time, we use a set of pre-computed distributions of points on the unit sphere. This distribution is then scaled to several spherical surfaces that span the desired search shell. The radial increment of neighbouring surfaces is chosen to equal the average distance of neighbouring points on the sphere. To avoid systematic alignment of the points on each sphere, each point set is rotated about the origin in a random way.</p>
      <p>While in theory it is sufficient to find the primary lattice vectors (<italic>i.e.</italic> the vectors of the reduced real-space lattice basis with Miller indices 100, 010 and 001), in the presence of spurious Bragg spots or multiple lattices we find that it is often beneficial to also search for the lattice vectors with Miller indices 110, 011 or 101. This is because spurious Bragg spots or spots from other lattices can significantly diminish some peaks in the score function. The use of additional lattice vectors adds redundancy and allows one to handle cases where the peaks in the score function belonging to the primary lattice basis vectors of a lattice are not detected. This procedure increases the execution time but improves the success rate of the algorithm, and is therefore provided as an option in our implementation of the algorithm.</p>
      <p>Using even proximity functions <inline-formula><inline-graphic xlink:href="a-75-00694-efi23.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>, the score function <inline-formula><inline-graphic xlink:href="a-75-00694-efi22.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> is centrosymmetric about the origin. We exploit this symmetry which allows the use of only half of the starting points.</p>
    </sec>
    <sec id="sec2.4">
      <label>2.4.</label>
      <title>Gradient descent extension   </title>
      <p>We use an extended gradient descent method to let the starting points migrate to the maxima of <inline-formula><inline-graphic xlink:href="a-75-00694-efi22.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>.<xref ref-type="fn" rid="fn1">1</xref> Empirical analysis shows that, for typical score functions <inline-formula><inline-graphic xlink:href="a-75-00694-efi22.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> that we have employed, the gradient is often large at locations close to the maximum (see Fig. 4<xref ref-type="fig" rid="fig4"> ▸</xref>). The ordinary gradient descent method uses large step sizes for large gradients, which here is counterproductive. Instead, we generate a step size using a combination of the previous step length, the change in step direction, the value of <inline-formula><inline-graphic xlink:href="a-75-00694-efi22.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>, the number of well-fitted nodes, a parameter γ (as it is used in the ordinary gradient descent to regulate the relative step length), and clipping to a minimum and maximum step size. The parameters for the choice of the step size are empirically optimized and are not visible to the user.</p>
      <p>As with the ordinary gradient descent algorithm, the problem occurs that convergence is often severely slowed down by zigzag migration trajectories (Wang, 2008<xref ref-type="bibr" rid="bb21"> ▸</xref>). A common approach to overcome this problem is to use the conjugate gradient method (Hestenes &amp; Stiefel, 1952<xref ref-type="bibr" rid="bb6"> ▸</xref>). Given the known composition of our score function we instead use a different method. For every step we check whether the direction of the current step is nearly opposite that of the previous step. If this is the case, a zigzag path is probable and the current step direction is replaced by the sum of the unit-length vector pointing in the current direction and the unit-length vector pointing in the previous direction. This takes the search in a direction almost orthogonal to the previous ones, helping to overcome zigzag paths while being computationally very cheap.</p>
    </sec>
    <sec id="sec2.5">
      <label>2.5.</label>
      <title>Heuristic algorithm for locating maxima in the score function   </title>
      <p>The goal of the heuristic is to find peaks in the score function, and hence probable lattice vectors, quickly and precisely. A large radius of convergence is required, but at the same time a very precise detection of the maxima is important. We therefore use a custom, empirically tuned algorithm with a multi-step design to home in on the maxima in stages. In this method, the earlier stages use smoother proximity functions, whereas in the later stages one with a sharper peak is used to achieve a more precise determination of the maxima:</p>
      <p>(i) Gradient descent: proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi28.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>, score function from equation (4)<xref ref-type="disp-formula" rid="fd4"/>, inverse radial weighting. [See Fig. 6<xref ref-type="fig" rid="fig6"> ▸</xref>(<italic>d</italic>) for visualization of the score function.]</p>
      <p>The first stage is responsible for bringing the sampling positions close to the peak maximum without getting stuck in the local maxima. This is accomplished by using the Fourier transform proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi19.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> in conjunction with a weighting of the nodes proportional to <inline-formula><inline-graphic xlink:href="a-75-00694-efi30.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>. The radius-dependent weighting ensures a smooth score function by reducing weights of short-period proximity functions from high-resolution Bragg peaks, that otherwise would cause many local maxima. This stage is the most computationally expensive one, since it contains many gradient descent steps and operates on a large number of sampling points to ensure capturing the peak within the radius of convergence.</p>
      <p>(ii) Gradient descent: proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi19.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>, score function from equation (6)<xref ref-type="disp-formula" rid="fd6"/>. [See Fig. 6<xref ref-type="fig" rid="fig6"> ▸</xref>(<italic>e</italic>) for visualization of the score function.]</p>
      <p>This and all subsequent stages bring the sampling points closer to their corresponding local maximum. These stages use the noise-tolerant and computationally expensive score function from equation (6)<xref ref-type="disp-formula" rid="fd6"/>, and unity weighting.</p>
      <p>(iii) Gradient descent: proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi32.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>, score function from equation (6)<xref ref-type="disp-formula" rid="fd6"/>, few steps. [See Fig. 6<xref ref-type="fig" rid="fig6"> ▸</xref>(<italic>f</italic>) for visualization of the score function.]</p>
      <p>The third stage uses the very local and computationally expensive proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi32.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>. Using finer gradient descent steps, it is responsible to bring the sampling points close enough to the maxima to be able to identify even very sharp maxima by the score function evaluation at these sampling points.</p>
      <p>(iv) Sparse peak finding on the sampling points.</p>
      <p>Only the 50 sampling points with the highest score function evaluation in their respective local environment are kept. This drastically reduces the number of sampling points.</p>
      <p>(v) Gradient descent: proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi32.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>, score function from equation (6)<xref ref-type="disp-formula" rid="fd6"/>, many steps. [See Fig. 6<xref ref-type="fig" rid="fig6"> ▸</xref>(<italic>f</italic>) for visualization of the score function.]</p>
      <p>This last stage uses many fine gradient descent steps with the local and computationally expensive proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi32.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>, and with the score function of equation (6)<xref ref-type="disp-formula" rid="fd6"/>. This ensures that the sampling points migrate extremely close to the maxima, yet maintains an affordable computational effort due to the small number of sampling points used in this stage.</p>
      <p>The numbers of steps for each stage can be chosen by a flag to the program.</p>
      <p>A visualization of the employed score functions can be seen in Fig. 6<xref ref-type="fig" rid="fig6"> ▸</xref>, which shows score functions for a set of 13 simulated nodes that were generated by adding noise to the position of randomly chosen points on a lattice grid. For images (<italic>b</italic>)–(<italic>f</italic>) an additional seven spurious nodes were added, <italic>i.e.</italic> nodes not lying on the lattice. Despite the noise in the positions of the nodes, image (<italic>a</italic>) shows a high degree of periodicity. The additional seven spurious peaks significantly diminish some of the maxima in image (<italic>b</italic>). Image (<italic>c</italic>) shows slightly better contrast than image (<italic>b</italic>) at the expense of a more computationally expensive proximity function. Image (<italic>d</italic>) has a high radius of convergence for the gradient descent approach, but does not provide exact peak locations. Case (<italic>e</italic>) provides more accurate peak locations, but has a small convergence radius for the gradient descent approach. Case (<italic>f</italic>) uses a computationally expensive proximity function and suffers from a small convergence radius, but provides better noise-suppression capabilities and accurate peak locations.</p>
    </sec>
    <sec id="sec2.6">
      <label>2.6.</label>
      <title>Selection of lattice bases   </title>
      <p>Once the maxima of the score function have been found, the bases of the found lattices can be formed. As a first step, all possible lattice bases are selected that each correctly predict at least five nodes. In theory, five nodes (given that they span the <inline-formula><inline-graphic xlink:href="a-75-00694-efi36.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>) are more than what is minimally required to define a single lattice, but this increases the noise tolerance. The selection of candidate bases is computationally expensive, since there are <inline-formula><inline-graphic xlink:href="a-75-00694-efi37.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> basis choices for <italic>N</italic> found peaks in the score function. To reduce computation time, as a first step all those vectors that predict less than five nodes are excluded. The next steps check for a reasonably high determinant of the basis and the number of correctly predicted nodes using two vectors and afterwards using three vectors. If the lattice parameters are known, the candidate lattices not fitting to these parameters are excluded as well. Finally, the basis vectors are sorted by the sum of each vector’s score function and the best 500 are kept.</p>
      <p>Each kept candidate basis is reduced (to find the shortest vectors) using an efficient algorithm described by Semaev (2001<xref ref-type="bibr" rid="bb18"> ▸</xref>). Afterwards, for each reduced basis the absolute defect (mean distance between the nodes and their positions predicted by the basis) and the relative defect (mean difference between the Miller indices of the nodes and the fractional Miller indices of the predicted nodes) are computed. From the 500 candidate lattices, 15 with the largest score function evaluation and 50 with the smallest relative defects are kept for the final stage.</p>
      <p>In the final stage, the bases which best predict the nodes are selected. For this, the candidate bases are sorted in descending order by the number of nodes they correctly predict. Starting with the basis predicting the most nodes, it is considered as generating a true lattice if it either predicts at least five points that were not predicted by any other basis or if it has significantly smaller defects than a previously accepted basis. In the latter case, the newly found basis replaces the previous one. To avoid supercells in cases with unknown lattice parameters, bases with smaller determinants are preferred.</p>
      <p><italic>XGANDALF</italic> thus can detect several lattices in a diffraction pattern in one pass. This allows fast data processing despite the presence of several lattices in the pattern. If processing time is not of concern, employing the delete-and-retry technique (<italic>i.e.</italic> detect the strongest lattice in a pattern, delete the corresponding peaks and retry the indexing) can lead to better results. However, only this latter method is implemented in the interface to <italic>CrystFEL</italic> 0.8.0 (White <italic>et al.</italic>, 2012<xref ref-type="bibr" rid="bb24"> ▸</xref>).</p>
    </sec>
    <sec id="sec2.7">
      <label>2.7.</label>
      <title>Refinement   </title>
      <p>After the identification of the bases, a refinement step is performed. The lattice bases are refined to minimize the mean Euclidean distance between the nodes and the predicted nodes using a gradient descent approach. Only the nodes close to the predicted nodes are used for refinement to improve noise tolerance.</p>
    </sec>
  </sec>
  <sec id="sec3">
    <label>3.</label>
    <title>Evaluation of the algorithm   </title>
    <sec id="sec3.1">
      <label>3.1.</label>
      <title>Indexing rate   </title>
      <p>Indexing solutions of measured diffraction patterns are often tested for correctness by comparing the locations of Bragg spots predicted by the lattice basis with those of the observed spots. If the pattern contains a large number of Bragg spots (say, 50) then this test usually yields a reliable estimate of correctness. If, on the other hand, the number of found spots is small then there can be several incorrect orientations of a crystal that predict the found spots, often giving a false indication of correctness. A reliable evaluation of the algorithm to index patterns as a function of the number of Bragg spots therefore requires ground truths, but ones which are as close as possible to real data. We generated our ground truths from a set of diffraction patterns which all had large numbers of Bragg spots, and as such were reliably indexed using <italic>MOSFLM</italic> (giving more than 50 correctly predicted peaks). The patterns were chosen from serial femtosecond crystallography data of crystals from serotonin receptor 5-HT<sub>2B</sub> bound to ergotamine, publicly available from the CXIDB (Maia, 2012<xref ref-type="bibr" rid="bb14"> ▸</xref>) entry 21 (Liu <italic>et al.</italic>, 2013<xref ref-type="bibr" rid="bb12"> ▸</xref>). Patterns with fewer spots were created by simply deleting spots from these previously indexed patterns. This way we obtained realistic patterns with five to 50 spots, all with a known crystal orientation. We created two sets of patterns: one with the spots randomly distributed throughout the pattern, and the other with only low-resolution spots generated by removing Bragg spots from the original patterns at high scattering angles.</p>
      <p>To compare our indexing algorithm with others, the patterns from the two data sets were indexed using the <italic>indexamajig</italic> program from <italic>CrystFEL</italic> (White <italic>et al.</italic>, 2012<xref ref-type="bibr" rid="bb24"> ▸</xref>). The use of <italic>CrystFEL</italic> allows a fair comparison of several (although not all) indexing algorithms with limited effort. The employed indexers are <italic>MOSFLM</italic> (Powell, 1999<xref ref-type="bibr" rid="bb15"> ▸</xref>), <italic>XDS</italic> (Kabsch, 1993<xref ref-type="bibr" rid="bb8"> ▸</xref>, 2010<xref ref-type="bibr" rid="bb9"> ▸</xref>), <italic>DirAx</italic> (Duisenberg, 1992<xref ref-type="bibr" rid="bb3"> ▸</xref>), <italic>TakeTwo</italic> (Ginn <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb5"> ▸</xref>), and two different modes of <italic>XGANDALF</italic>. One of these modes implemented many starting points and many gradient descent steps while the other mode used fewer starting points and fewer gradient descent steps. These are labelled, respectively, ‘XGANDALF_precise’ and ‘XGANDALF_fast’ in Fig. 7<xref ref-type="fig" rid="fig7"> ▸</xref>. In all cases the lattice parameters were specified to the indexing algorithm. No additional tuning of the indexing algorithms was performed. The indexing results were compared with the ground truths obtained from the original indexing of the patterns with <italic>MOSFLM</italic>. This comparison was accomplished by applying the Kabsch algorithm (Kabsch, 1976<xref ref-type="bibr" rid="bb7"> ▸</xref>) to compute the angle needed to rotate one lattice basis onto another. Indexing solutions that required rotations of no more than 3° to bring them into coincidence with the ground-truth solution of <italic>MOSFLM</italic> (prior to removing spots) were counted as correct. For this test, all <italic>CrystFEL</italic> optimizations were turned off by using the options <monospace>--no-retry --no-refine --no-check-cell</monospace>. Only one indexing solution per pattern was accepted (using the option <monospace>--no-multi</monospace>). Although 3° is a significant deviation, this value is usually good enough for the subsequent refinement. For patterns with few peaks and a significant amount of noise, large deviations are anyway unavoidable. The results of the comparison are displayed in Fig. 7<xref ref-type="fig" rid="fig7"> ▸</xref>.</p>
      <p>In a previous paper we remarked that <italic>XDS</italic> had a low success rate when indexing snapshot diffraction patterns (White, 2019<xref ref-type="bibr" rid="bb22"> ▸</xref>), but due to parameter tuning and other improvements in the interface between <italic>CrystFEL</italic> and <italic>XDS</italic>, its success rate has been greatly improved with <italic>CrystFEL</italic> version 0.8.0 to be comparable with other algorithms, as indicated in Fig. 7<xref ref-type="fig" rid="fig7"> ▸</xref>.</p>
      <p>The most practical test of indexing is the quality of the final merged data, as detailed in Section 3.3<xref ref-type="sec" rid="sec3.3"/>. Before that data can be merged, the full data set must be indexed. We used diffraction of beta-lactamase crystals from CXIDB ID 83 (Wiedorn <italic>et al.</italic>, 2018<xref ref-type="bibr" rid="bb25"> ▸</xref>) for comparison. This data set consists of a total of 14 445 patterns identified as containing crystal diffraction, which were indexed by a variety of algorithms – the results are summarized in Tables 1<xref ref-type="table" rid="table1"> ▸</xref> and 2<xref ref-type="table" rid="table2"> ▸</xref>. No additional tuning of the indexing algorithms was performed. Most patterns contained multiple hits, resulting in a total number of indexed crystals that for many indexers was higher than the number of patterns. Based on the experiment setup, the quality of the prediction and the quality of the merge results, it is most likely that these patterns really arose from multiple crystals. Although the unit-cell parameters were known, the indexing was processed in one case without providing that knowledge (only <italic>MOSFLM</italic>, <italic>DirAx</italic> and <italic>XGANDALF</italic> provided reasonably high indexing rates) and another with these parameters provided. Table 1<xref ref-type="table" rid="table1"> ▸</xref> shows results for the case where the unit-cell parameters were not provided to the algorithms. In this case the indexers often report unit cells that differ from the known ones. For a fair comparison, the numbers of correctly identified unit cells are also listed. Table 2<xref ref-type="table" rid="table2"> ▸</xref> presents the case using known unit-cell parameters.</p>
      <p>As seen from Tables 1<xref ref-type="table" rid="table1"> ▸</xref> and 2<xref ref-type="table" rid="table2"> ▸</xref>, <italic>XGANDALF</italic> outperforms all the other state-of-the-art indexers with and without prior cell information. Surprisingly, without prior cell information <italic>XGANDALF</italic> performs better in fast mode than in precise mode for this data set. It is likely that in the ‘precise’ mode more local maxima are found, making the choice for the basis selection algorithm more difficult.</p>
    </sec>
    <sec id="sec3.2">
      <label>3.2.</label>
      <title>Execution time   </title>
      <p>For comparison of execution time, we took 1000 random patterns from the same data set of CXIDB ID 21 as described above in Section 3.1<xref ref-type="sec" rid="sec3.1"/> and indexed them in the same fashion using the <italic>CrystFEL</italic> software suite on an Intel E5-2698 v4 CPU. Here, however, we did not remove spots from any of the patterns, nor did we select patterns only with a high number of Bragg peaks to create ground truths. The average number of Bragg peaks per pattern was 49. As before, the test was carried out for the two modes of <italic>XGANDALF</italic> – ‘XGANDALF_precise’ and ‘XGANDALF_fast’ – where parameters are chosen to either maximize the indexing success or maximize the indexing speed. Settings in between are also possible. The mean times to index the patterns are given in Table 3<xref ref-type="table" rid="table3"> ▸</xref>.</p>
      <p>As can be seen in Table 3<xref ref-type="table" rid="table3"> ▸</xref>, again <italic>XGANDALF</italic> has the highest indexing rate among all tested indexers (in agreement with Fig. 7<xref ref-type="fig" rid="fig7"> ▸</xref>), while having an execution time of the same order of magnitude as the fastest-tested indexer. The high execution time for the <italic>TakeTwo</italic> algorithm reflects its mode of operation: if it does not find a solution, it will keep searching in the hope of eventually finding one, hence maximizing its indexing rate. Most patterns could be indexed by <italic>TakeTwo</italic> in a very short time, but several resulted in a long search. <italic>CrystFEL</italic> imposes a maximum running time on the indexing routines, and as a result the execution time shown for <italic>TakeTwo</italic> reflects this maximum time rather than the performance of the algorithm.</p>
    </sec>
    <sec id="sec3.3">
      <label>3.3.</label>
      <title>Final merged data quality   </title>
      <p>After indexing, the next stage in the processing pipeline is the merge of the measured Bragg spots of all patterns into a set of structure factors. Better indexing results should presumably lead to better statistics of the merged data, so the quality of the merge can be used as a measure of the quality of the indexing results. Here we merged the indexed data of CXIDB ID 83 that were summarized in Tables 1<xref ref-type="table" rid="table1"> ▸</xref> and 2<xref ref-type="table" rid="table1"> ▸</xref>. Apart from the indexing algorithm selection, all parameters to <italic>CrystFEL</italic> were the same for all tests. For comparison of the merge results we used the figures of merit CC* (Karplus &amp; Diederichs, 2012<xref ref-type="bibr" rid="bb11"> ▸</xref>) and <inline-formula><inline-graphic xlink:href="a-75-00694-efi38.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> (White <italic>et al.</italic>, 2013<xref ref-type="bibr" rid="bb23"> ▸</xref>). As shown in Figs. 8<xref ref-type="fig" rid="fig8"> ▸</xref> and 9<xref ref-type="fig" rid="fig9"> ▸</xref>, <italic>XGANDALF</italic> significantly outperforms the other indexers in both of these figures of merit.</p>
      <p>For each indexed pattern <italic>CrystFEL</italic> (White <italic>et al.</italic>, 2012<xref ref-type="bibr" rid="bb24"> ▸</xref>) estimates a profile radius of the Bragg spots. This is defined as the maximum distance of a reciprocal-lattice point to the Ewald sphere that still gives rise to a Bragg reflection, and can be considered as a property of the crystal, influenced by mosaicity for example. <italic>CrystFEL</italic> estimates this measure from the detected Bragg spots and the reciprocal-lattice points that predict them best. A similar metric, called the Ewald proximal volume, was used by Lyubimov <italic>et al.</italic> (2016<xref ref-type="bibr" rid="bb13"> ▸</xref>) in their software <italic>IOTA</italic>. Errors in the indexing solution generally increase the estimated profile radius. A comparison of the profile radius estimation for <italic>MOSFLM</italic> and <italic>XGANDALF</italic> is depicted in Fig. 10<xref ref-type="fig" rid="fig10"> ▸</xref>. The estimated profile radii for patterns indexed by <italic>XGANDALF</italic> are generally smaller than the ones of <italic>MOSFLM</italic>, indicating that the indexing solution is more precise.</p>
    </sec>
  </sec>
  <sec id="sec4">
    <label>4.</label>
    <title>Availability   </title>
    <p><italic>XGANDALF</italic> is implemented as an open-source C++ library, which can be used directly from applications written in C or C++, or from a Python program using a Cython interface. <italic>XGANDALF</italic> has been implemented in <italic>CrystFEL</italic> (White <italic>et al.</italic>, 2012<xref ref-type="bibr" rid="bb24"> ▸</xref>) and is available from version 0.8.0 onwards. The <italic>XGANDALF</italic> implementation provides the tools for programmers to adjust the heuristic by defining their own high-level heuristic stages based upon optimized low-level implementations. The library is distributed under the LGPLv3 licence, and the source code can be downloaded from <ext-link ext-link-type="uri" xlink:href="https://stash.desy.de/users/gevorkov/repos/xgandalf/browse">https://stash.desy.de/users/gevorkov/repos/xgandalf/browse</ext-link>.</p>
  </sec>
  <sec id="sec5">
    <label>5.</label>
    <title>Conclusion   </title>
    <p>A new indexing algorithm, <italic>XGANDALF</italic>, has been presented which was designed specifically for indexing still diffraction patterns for snapshot serial crystallography experiments. As such, it outperforms the current state-of-the-art indexers that, although commonly used in serial crystallography, were mostly created for the indexing and analysis of rotation crystal data. Compared with those programs, <italic>XGANDALF</italic> gives higher indexing rates and higher indexing precision, and can be used both with and without prior unit-cell parameters. The execution time of the implementation is of the same order of magnitude as currently used indexing algorithms and, with mean indexing times of about 20 ms, is fast enough to allow real-time feedback in experiments. Compared with the available indexers, the algorithm successfully indexes more patterns in test serial crystallography data sets and is more robust to multiple lattices in a single image. The program has already been used in serial crystallography experiments by several other groups with very positive results. We therefore anticipate that <italic>XGANDALF</italic> will be a valuable addition to the collection of software tools for serial crystallography.</p>
  </sec>
</body>
<back>
  <fn-group>
    <fn id="fn1">
      <label>1</label>
      <p>Strictly, we minimize the negative of the score function by gradient <italic>descent</italic>.</p>
    </fn>
  </fn-group>
  <ref-list>
    <title>References</title>
    <ref id="bb1">
      <mixed-citation publication-type="other">Beyerlein, K. R., White, T. A., Yefanov, O., Gati, C., Kazantsev, I. G., Nielsen, N. F.-G., Larsen, P. M., Chapman, H. N. &amp; Schmidt, S. (2017). <italic>J. Appl. Cryst.</italic>
<bold>50</bold>, 1075–1083.</mixed-citation>
    </ref>
    <ref id="bb2">
      <mixed-citation publication-type="other">Chapman, H. N., Fromme, P., Barty, A., White, T. A., Kirian, R. A., Aquila, A., Hunter, M. S., Schulz, J., DePonte, D. P., Weierstall, U., Doak, R. B., Maia, F. R. N. C., Martin, A. V., Schlichting, I., Lomb, L., Coppola, N., Shoeman, R. L., Epp, S. W., Hartmann, R., Rolles, D., Rudenko, A., Foucar, L., Kimmel, N., Weidenspointner, G., Holl, P., Liang, M., Barthelmess, M., Caleman, C., Boutet, S., Bogan, M. J., Krzywinski, J., Bostedt, C., Bajt, S., Gumprecht, L., Rudek, B., Erk, B., Schmidt, C., Hömke, A., Reich, C., Pietschner, D., Strüder, L., Hauser, G., Gorke, H., Ullrich, J., Herrmann, S., Schaller, G., Schopper, F., Soltau, H., Kühnel, K.-U., Messerschmidt, M., Bozek, J. D., Hau-Riege, S. P., Frank, M., Hampton, C. Y., Sierra, R. G., Starodub, D., Williams, G. J., Hajdu, J., Timneanu, N., Seibert, M. M., Andreasson, J., Rocker, A., Jönsson, O., Svenda, M., Stern, S., Nass, K., Andritschke, R., Schröter, C.-D., Krasniqi, F., Bott, M., Schmidt, K. E., Wang, X., Grotjohann, I., Holton, J. M., Barends, T. R. M., Neutze, R., Marchesini, S., Fromme, R., Schorb, S., Rupp, D., Adolph, M., Gorkhover, T., Andersson, I., Hirsemann, H., Potdevin, G., Graafsma, H., Nilsson, B. &amp; Spence, J. C. H. (2011). <italic>Nature</italic>, <bold>470</bold>, 73–77.</mixed-citation>
    </ref>
    <ref id="bb3">
      <mixed-citation publication-type="other">Duisenberg, A. J. M. (1992). <italic>J. Appl. Cryst.</italic>
<bold>25</bold>, 92–96.</mixed-citation>
    </ref>
    <ref id="bb4">
      <mixed-citation publication-type="other">Gildea, R. J., Waterman, D. G., Parkhurst, J. M., Axford, D., Sutton, G., Stuart, D. I., Sauter, N. K., Evans, G. &amp; Winter, G. (2014). <italic>Acta Cryst.</italic> D<bold>70</bold>, 2652–2666.</mixed-citation>
    </ref>
    <ref id="bb5">
      <mixed-citation publication-type="other">Ginn, H. M., Roedig, P., Kuo, A., Evans, G., Sauter, N. K., Ernst, O. P., Meents, A., Mueller-Werkmeister, H., Miller, R. J. D. &amp; Stuart, D. I. (2016). <italic>Acta Cryst.</italic> D<bold>72</bold>, 956–965.</mixed-citation>
    </ref>
    <ref id="bb6">
      <mixed-citation publication-type="other">Hestenes, M. R. &amp; Stiefel, E. (1952). <italic>J. Res. Natl Bur. Standards</italic>, <bold>49</bold>, 409.</mixed-citation>
    </ref>
    <ref id="bb7">
      <mixed-citation publication-type="other">Kabsch, W. (1976). <italic>Acta Cryst.</italic> A<bold>32</bold>, 922–923.</mixed-citation>
    </ref>
    <ref id="bb8">
      <mixed-citation publication-type="other">Kabsch, W. (1993). <italic>J. Appl. Cryst.</italic>
<bold>26</bold>, 795–800.</mixed-citation>
    </ref>
    <ref id="bb9">
      <mixed-citation publication-type="other">Kabsch, W. (2010). <italic>Acta Cryst.</italic> D<bold>66</bold>, 125–132.</mixed-citation>
    </ref>
    <ref id="bb10">
      <mixed-citation publication-type="other">Kabsch, W. (2014). <italic>Acta Cryst.</italic> D<bold>70</bold>, 2204–2216.</mixed-citation>
    </ref>
    <ref id="bb11">
      <mixed-citation publication-type="other">Karplus, P. A. &amp; Diederichs, K. (2012). <italic>Science</italic>, <bold>336</bold>, 1030–1033.</mixed-citation>
    </ref>
    <ref id="bb12">
      <mixed-citation publication-type="other">Liu, W., Wacker, D., Gati, C., Han, G. W., James, D., Wang, D., Nelson, G., Weierstall, U., Katritch, V., Barty, A., Zatsepin, N. A., Li, D., Messerschmidt, M., Boutet, S., Williams, G. J., Koglin, J. E., Seibert, M. M., Wang, C., Shah, S. T. A., Basu, S., Fromme, R., Kupitz, C., Rendek, K. N., Grotjohann, I., Fromme, P., Kirian, R. A., Beyerlein, K. R., White, T. A., Chapman, H. N., Caffrey, M., Spence, J. C. H., Stevens, R. C. &amp; Cherezov, V. (2013). <italic>Science</italic>, <bold>342</bold>, 1521–1524.</mixed-citation>
    </ref>
    <ref id="bb13">
      <mixed-citation publication-type="other">Lyubimov, A. Y., Uervirojnangkoorn, M., Zeldin, O. B., Brewster, A. S., Murray, T. D., Sauter, N. K., Berger, J. M., Weis, W. I. &amp; Brunger, A. T. (2016). <italic>J. Appl. Cryst.</italic>
<bold>49</bold>, 1057–1064.</mixed-citation>
    </ref>
    <ref id="bb14">
      <mixed-citation publication-type="other">Maia, F. R. N. C. (2012). <italic>Nat. Methods</italic>, <bold>9</bold>, 854–855.</mixed-citation>
    </ref>
    <ref id="bb15">
      <mixed-citation publication-type="other">Powell, H. R. (1999). <italic>Acta Cryst.</italic> D<bold>55</bold>, 1690–1695.</mixed-citation>
    </ref>
    <ref id="bb16">
      <mixed-citation publication-type="other">Sauter, N. K. &amp; Zwart, P. H. (2009). <italic>Acta Cryst.</italic> D<bold>65</bold>, 553–559.</mixed-citation>
    </ref>
    <ref id="bb17">
      <mixed-citation publication-type="other">Schlichting, I. (2015). <italic>IUCrJ</italic>, <bold>2</bold>, 246–255.</mixed-citation>
    </ref>
    <ref id="bb18">
      <mixed-citation publication-type="other">Semaev, I. (2001). <italic>Lecture Notes in Computer Science</italic>, pp. 181–193. Berlin, Heidelberg: Springer.</mixed-citation>
    </ref>
    <ref id="bb19">
      <mixed-citation publication-type="other">Semechko, A. (2015). <italic>Suite of functions to perform uniform sampling of a sphere.</italic> https://de.mathworks.com/matlabcentral/fileexchange/37004-suite-of-functions-to-perform-uniform-sampling-of-a-sphere.</mixed-citation>
    </ref>
    <ref id="bb20">
      <mixed-citation publication-type="other">Steller, I., Bolotovsky, R. &amp; Rossmann, M. G. (1997). <italic>J. Appl. Cryst.</italic>
<bold>30</bold>, 1036–1040.</mixed-citation>
    </ref>
    <ref id="bb21">
      <mixed-citation publication-type="other">Wang, X. (2008). <italic>IEEE Microwave Wireless Components Lett.</italic>
<bold>12</bold>, 24–26.</mixed-citation>
    </ref>
    <ref id="bb22">
      <mixed-citation publication-type="other">White, T. A. (2019). <italic>Acta Cryst.</italic> D<bold>75</bold>, 219–233.</mixed-citation>
    </ref>
    <ref id="bb23">
      <mixed-citation publication-type="other">White, T. A., Barty, A., Stellato, F., Holton, J. M., Kirian, R. A., Zatsepin, N. A. &amp; Chapman, H. N. (2013). <italic>Acta Cryst.</italic> D<bold>69</bold>, 1231–1240.</mixed-citation>
    </ref>
    <ref id="bb24">
      <mixed-citation publication-type="other">White, T. A., Kirian, R. A., Martin, A. V., Aquila, A., Nass, K., Barty, A. &amp; Chapman, H. N. (2012). <italic>J. Appl. Cryst.</italic>
<bold>45</bold>, 335–341.</mixed-citation>
    </ref>
    <ref id="bb25">
      <mixed-citation publication-type="other">Wiedorn, M. O., <italic>et al.</italic> (2018). <italic>Nat. Commun.</italic>
<bold>9</bold>, 4025.</mixed-citation>
    </ref>
    <ref id="bb26">
      <mixed-citation publication-type="other">Winter, G., Waterman, D. G., Parkhurst, J. M., Brewster, A. S., Gildea, R. J., Gerstel, M., Fuentes-Montero, L., Vollmar, M., Michels-Clark, T., Young, I. D., Sauter, N. K. &amp; Evans, G. (2018). <italic>Acta Cryst.</italic> D<bold>74</bold>, 85–97.</mixed-citation>
    </ref>
  </ref-list>
</back>
<floats-group>
  <fig id="fig1" orientation="portrait" position="float">
    <label>Figure 1</label>
    <caption>
      <p>Overall structure of the <italic>XGANDALF</italic> algorithm.</p>
    </caption>
    <graphic xlink:href="a-75-00694-fig1"/>
  </fig>
  <fig id="fig2" orientation="portrait" position="float">
    <label>Figure 2</label>
    <caption>
      <p>Line series in real space (green and purple, right panel) generated by two nodes <italic>a</italic> and <italic>b</italic> in the 2D reciprocal space (left). The distances between adjacent parallel lines are given by the familiar reciprocal of the distance of magnitude of the momentum transfer of the node. A third node (<inline-formula><inline-graphic xlink:href="a-75-00694-efi39.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>, red) is shown, along with a corresponding set of lines in the right panel, to show that in the presence of noise there usually are no points where all sets of lines intersect.</p>
    </caption>
    <graphic xlink:href="a-75-00694-fig2"/>
  </fig>
  <fig id="fig3" orientation="portrait" position="float">
    <label>Figure 3</label>
    <caption>
      <p>Score function for the lines from vectors <italic>a</italic> and <italic>b</italic> in Fig. 2<xref ref-type="fig" rid="fig2"> ▸</xref>. For each node, positions on the lines are assigned a proximity of 1 and positions in the middle between two lines are assigned the proximity −1. The rest of the proximity function for a single node is a linear interpolation of these values. The score function is formed by the normalized sum of the proximity functions of each node.</p>
    </caption>
    <graphic xlink:href="a-75-00694-fig3"/>
  </fig>
  <fig id="fig4" orientation="portrait" position="float">
    <label>Figure 4</label>
    <caption>
      <p>Score function for a set of 13 nodes that were generated by adding noise to the position of randomly chosen points on a lattice grid. For each node, positions on the lines are assigned a proximity of 1 and positions in the middle between two lines are assigned the proximity −1. The rest of the proximity function for a single node is a linear interpolation of these values. The score function is formed by the sum of the proximity functions of each node.</p>
    </caption>
    <graphic xlink:href="a-75-00694-fig4"/>
  </fig>
  <fig id="fig5" orientation="portrait" position="float">
    <label>Figure 5</label>
    <caption>
      <p>Plotted proximity functions <inline-formula><inline-graphic xlink:href="a-75-00694-efi16.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> (top) to <inline-formula><inline-graphic xlink:href="a-75-00694-efi17.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> (bottom).</p>
    </caption>
    <graphic xlink:href="a-75-00694-fig5"/>
  </fig>
  <fig id="fig6" orientation="portrait" position="float">
    <label>Figure 6</label>
    <caption>
      <p>Score functions for a set of 13 simulated nodes that were generated by adding noise to the position of randomly chosen points on a lattice grid. For images (<italic>b</italic>)–(<italic>f</italic>) an additional seven spurious nodes were added, <italic>i.e.</italic> nodes not lying on the lattice. (<italic>a</italic>) Proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi42.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>, no spurious nodes. (<italic>b</italic>) Proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi42.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>. (<italic>c</italic>) Proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi16.jpg" mimetype="image" mime-subtype="gif"/></inline-formula>. (<italic>d</italic>) Proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi42.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> with inverse radial weighting. (<italic>e</italic>) Proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi42.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> with score function from equation (6)<xref ref-type="disp-formula" rid="fd6"/>. (<italic>f</italic>) Proximity function <inline-formula><inline-graphic xlink:href="a-75-00694-efi47.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> with score function from equation (6)<xref ref-type="disp-formula" rid="fd6"/>.</p>
    </caption>
    <graphic xlink:href="a-75-00694-fig6"/>
  </fig>
  <fig id="fig7" orientation="portrait" position="float">
    <label>Figure 7</label>
    <caption>
      <p>Comparison of the success rates of algorithms in indexing patterns as a function of the numbers of Bragg spots <italic>N</italic> in those patterns. The patterns were generated by selecting <italic>N</italic> Bragg spots from real diffraction patterns: (<italic>a</italic>) the <italic>N</italic> low-resolution Bragg spots were selected, (<italic>b</italic>) random <italic>N</italic> Bragg spots were selected. <italic>XGANDALF</italic> was used with ‘precise’ and with ‘fast’ settings. <italic>XGANDALF</italic> outperforms the other tested indexers over the whole range of Bragg spot counts in both (<italic>a</italic>) and (<italic>b</italic>).</p>
    </caption>
    <graphic xlink:href="a-75-00694-fig7"/>
  </fig>
  <fig id="fig8" orientation="portrait" position="float">
    <label>Figure 8</label>
    <caption>
      <p>Comparison of the achieved <inline-formula><inline-graphic xlink:href="a-75-00694-efi48.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> (White <italic>et al.</italic>, 2013<xref ref-type="bibr" rid="bb23"> ▸</xref>) (lower is better) for <italic>XGANDALF</italic> and current state-of-the-art indexers. <italic>XGANDALF</italic> outperforms the other indexers in all significant resolution shells.</p>
    </caption>
    <graphic xlink:href="a-75-00694-fig8"/>
  </fig>
  <fig id="fig9" orientation="portrait" position="float">
    <label>Figure 9</label>
    <caption>
      <p>Comparison of the achieved CC* (Karplus &amp; Diederichs, 2012<xref ref-type="bibr" rid="bb11"> ▸</xref>) (higher is better) for <italic>XGANDALF</italic> and current state-of-the-art indexers. <italic>XGANDALF</italic> outperforms the other indexers in all significant resolution shells.</p>
    </caption>
    <graphic xlink:href="a-75-00694-fig9"/>
  </fig>
  <fig id="fig10" orientation="portrait" position="float">
    <label>Figure 10</label>
    <caption>
      <p>Comparison of the estimated profile radii of <italic>MOSFLM</italic> and <italic>XGANDALF</italic>. The estimated radii for patterns indexed by <italic>XGANDALF</italic> are generally smaller than the ones of <italic>MOSFLM</italic>, which means that the indexing solution is more precise.</p>
    </caption>
    <graphic xlink:href="a-75-00694-fig10"/>
  </fig>
  <table-wrap id="table1" orientation="portrait" position="float">
    <label>Table 1</label>
    <caption>
      <title>Numbers of crystals of CXIDB ID 83 indexed without prior unit-cell knowledge</title>
    </caption>
    <table frame="hsides" rules="groups">
      <thead valign="top">
        <tr>
          <th style="border-bottom:1px solid black;" rowspan="1" colspan="1" align="left" charoff="50" valign="bottom">Indexer (no prior cell information)</th>
          <th style="border-bottom:1px solid black;" rowspan="1" colspan="1" align="left" charoff="50" valign="bottom">Total indexed</th>
          <th style="border-bottom:1px solid black;" rowspan="1" colspan="1" align="left" charoff="50" valign="bottom">Indexed with correct unit cell</th>
        </tr>
      </thead>
      <tbody valign="top">
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top">
            <italic>DirAx</italic>
          </td>
          <td rowspan="1" colspan="1" align="left" valign="top">28 832</td>
          <td rowspan="1" colspan="1" align="char" char=" " charoff="50" valign="top">3553</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top">
            <italic>MOSFLM</italic>
          </td>
          <td rowspan="1" colspan="1" align="left" valign="top">18 346</td>
          <td rowspan="1" colspan="1" align="char" char=" " charoff="50" valign="top">11 742</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top"><italic>XGANDALF</italic> fast mode</td>
          <td rowspan="1" colspan="1" align="left" valign="top">26 040</td>
          <td rowspan="1" colspan="1" align="char" char=" " charoff="50" valign="top">14 631</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top"><italic>XGANDALF</italic> precise mode</td>
          <td rowspan="1" colspan="1" align="left" valign="top">24 748</td>
          <td rowspan="1" colspan="1" align="char" char=" " charoff="50" valign="top">10 899</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="table2" orientation="portrait" position="float">
    <label>Table 2</label>
    <caption>
      <title>Numbers of crystals of CXIDB ID 83 indexed with prior unit-cell knowledge</title>
    </caption>
    <table frame="hsides" rules="groups">
      <thead valign="top">
        <tr>
          <th style="border-bottom:1px solid black;" rowspan="1" colspan="1" align="left" charoff="50" valign="bottom">Indexer</th>
          <th style="border-bottom:1px solid black;" rowspan="1" colspan="1" align="left" charoff="50" valign="bottom">Indexed</th>
        </tr>
      </thead>
      <tbody valign="top">
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top">
            <italic>XDS</italic>
          </td>
          <td rowspan="1" colspan="1" align="left" valign="top">13 922</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top">
            <italic>MOSFLM</italic>
          </td>
          <td rowspan="1" colspan="1" align="left" valign="top">16 120</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top">
            <italic>MOSFLM DirAx XDS</italic>
          </td>
          <td rowspan="1" colspan="1" align="left" valign="top">17 433</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top">
            <italic>TakeTwo</italic>
          </td>
          <td rowspan="1" colspan="1" align="left" valign="top">18 808</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top"><italic>XGANDALF</italic> ‘fast’ mode</td>
          <td rowspan="1" colspan="1" align="left" valign="top">19 914</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top"><italic>XGANDALF</italic> ‘precise’ mode</td>
          <td rowspan="1" colspan="1" align="left" valign="top">21 171</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="table3" orientation="portrait" position="float">
    <label>Table 3</label>
    <caption>
      <title>Comparison of mean execution times (per pattern) and indexing results for a data set consisting of 1000 patterns</title>
    </caption>
    <table frame="hsides" rules="groups">
      <thead valign="top">
        <tr>
          <th style="border-bottom:1px solid black;" rowspan="1" colspan="1" align="left" charoff="50" valign="bottom">Indexer name</th>
          <th style="border-bottom:1px solid black;" rowspan="1" colspan="1" align="left" charoff="50" valign="bottom">Indexed patterns</th>
          <th style="border-bottom:1px solid black;" rowspan="1" colspan="1" align="left" charoff="50" valign="bottom">Mean execution time (ms)</th>
        </tr>
      </thead>
      <tbody valign="top">
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top">
            <italic>MOSFLM</italic>
          </td>
          <td rowspan="1" colspan="1" align="left" valign="top">452</td>
          <td rowspan="1" colspan="1" align="char" char=" " charoff="50" valign="top">17</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top">
            <italic>XDS</italic>
          </td>
          <td rowspan="1" colspan="1" align="left" valign="top">400</td>
          <td rowspan="1" colspan="1" align="char" char=" " charoff="50" valign="top">22</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top">
            <italic>DirAx</italic>
          </td>
          <td rowspan="1" colspan="1" align="left" valign="top">394</td>
          <td rowspan="1" colspan="1" align="char" char=" " charoff="50" valign="top">12</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top">
            <italic>TakeTwo</italic>
          </td>
          <td rowspan="1" colspan="1" align="left" valign="top">545</td>
          <td rowspan="1" colspan="1" align="char" char=" " charoff="50" valign="top">662</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top"><italic>XGANDALF</italic> fast mode</td>
          <td rowspan="1" colspan="1" align="left" valign="top">724</td>
          <td rowspan="1" colspan="1" align="char" char=" " charoff="50" valign="top">19</td>
        </tr>
        <tr>
          <td rowspan="1" colspan="1" align="left" valign="top"><italic>XGANDALF</italic> precise mode</td>
          <td rowspan="1" colspan="1" align="left" valign="top">725</td>
          <td rowspan="1" colspan="1" align="char" char=" " charoff="50" valign="top">106</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
</floats-group>
