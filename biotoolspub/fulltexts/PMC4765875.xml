<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4765875</article-id>
    <article-id pub-id-type="pmid">26072514</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btv226</article-id>
    <article-id pub-id-type="publisher-id">btv226</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2015 Proceedings Papers Committee July 10 to July 14, 2015, Dublin, Ireland</subject>
        <subj-group subj-group-type="heading">
          <subject>Genes</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title><italic>De novo</italic> meta-assembly of ultra-deep sequencing data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Mirebrahim</surname>
          <given-names>Hamid</given-names>
        </name>
        <xref ref-type="aff" rid="btv226-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="btv226-COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Close</surname>
          <given-names>Timothy J.</given-names>
        </name>
        <xref ref-type="aff" rid="btv226-AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lonardi</surname>
          <given-names>Stefano</given-names>
        </name>
        <xref ref-type="aff" rid="btv226-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <aff id="btv226-AFF1"><sup>1</sup>Department of Computer Science and Engineering and <sup>2</sup>Department of Botany and Plant Sciences, University of California, Riverside, CA 92521, USA</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btv226-COR1">*To whom correspondence should be addressed.</corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>6</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>10</day>
      <month>6</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>10</day>
      <month>6</month>
      <year>2015</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>31</volume>
    <issue>12</issue>
    <fpage>i9</fpage>
    <lpage>i16</lpage>
    <permissions>
      <copyright-statement>© The Author 2015. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2015</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by-nc/4.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <abstract>
      <p>We introduce a new divide and conquer approach to deal with the problem of <italic>de novo</italic> genome assembly in the presence of ultra-deep sequencing data (i.e. coverage of 1000x or higher). Our proposed meta-assembler S<sc>licembler</sc> partitions the input data into optimal-sized ‘slices’ and uses a standard assembly tool (e.g. Velvet, SPAdes, IDBA_UD and Ray) to assemble each slice individually. S<sc>licembler</sc> uses majority voting among the individual assemblies to identify long contigs that can be merged to the consensus assembly. To improve its efficiency, S<sc>licembler</sc> uses a generalized suffix tree to identify these frequent contigs (or fraction thereof). Extensive experimental results on real ultra-deep sequencing data (8000x coverage) and simulated data show that S<sc>licembler</sc> significantly improves the quality of the assembly compared with the performance of the base assembler. In fact, most of the times, S<sc>licembler</sc> generates error-free assemblies. We also show that S<sc>licembler</sc> is much more resistant against high sequencing error rate than the base assembler.</p>
      <p><bold>Availability and implementation:</bold> S<sc>licembler</sc> can be accessed at <ext-link ext-link-type="uri" xlink:href="http://slicembler.cs.ucr.edu/">http://slicembler.cs.ucr.edu/</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>hamid.mirebrahim@email.ucr.edu</email>
      </p>
    </abstract>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Since the early days of DNA sequencing, the problem of <italic>de novo</italic> genome assembly has been characterized by insufficient and/or uneven depth of sequencing coverage (see e.g. <xref rid="btv226-B11" ref-type="bibr">Ekblom <italic>et al.</italic>, 2014</xref>). Insufficient sequencing coverage, along with other shortcomings of sequencing instruments (e.g. short read length and sequencing errors) exacerbated the algorithmic challenges in assembling large, complex genome—in particular those with high repetitive content. Some of the third generation of sequencing technology currently on the market, e.g. Pacific Biosciences (<xref rid="btv226-B10" ref-type="bibr">Eid <italic>et al.</italic> 2009</xref>) and Oxford Nanopore (<xref rid="btv226-B8" ref-type="bibr">Clarke <italic>et al.</italic> 2009</xref>), offers very long reads at a higher cost per base, but sequencing error rate is much higher. As a consequence, long reads are more commonly used for scaffolding contigs created from second generation data, rather than for <italic>de novo</italic> assembly (<xref rid="btv226-B12" ref-type="bibr">English <italic>et al.</italic> 2012</xref>).</p>
    <p>Thanks to continuous improvements in sequencing technologies, life scientists can now easily sequence DNA at depth of sequencing coverage in excess of 1000x, especially for smaller genomes like viruses, bacteria or bacterial artificial chromosome (BAC)/YAC clones. ‘Ultra-deep’ sequencing (i.e. 1000 x or higher) has already been used in the literature for detecting rare DNA variants including mutations causing cancer (<xref rid="btv226-B6" ref-type="bibr">Campbell <italic>et al.</italic> 2008</xref>), for studing viruses (<xref rid="btv226-B3" ref-type="bibr">Beerenwinkel and Zagordi 2011</xref>; <xref rid="btv226-B25" ref-type="bibr">Widasari <italic>et al.</italic> 2014</xref>), as well as other applications (<xref rid="btv226-B11" ref-type="bibr">Ekblom <italic>et al.</italic> 2014</xref>). As it becomes more and more common, ultra-deep sequencing data are expected to create new algorithmic challenges in the analysis pipeline. In this article, we focus on one of these challenges, namely the problem of <italic>de novo</italic> assembly. We showed recently that modern <italic>de novo</italic> assemblers SPAdes (<xref rid="btv226-B2" ref-type="bibr">Bankevich <italic>et al.</italic> 2012</xref>), IDBA_UD (<xref rid="btv226-B20" ref-type="bibr">Peng <italic>et al.</italic> 2012</xref>) and Velvet (<xref rid="btv226-B27" ref-type="bibr">Zerbino and Birney 2008</xref>) are unable to take advantage of ultra-deep coverage (<xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> 2015</xref>). Even more surprising was the finding that the assembly quality produced by these assemblers starts degrading when the sequencing depth exceeds 500x–1000x (depending on the assembler and the sequencing error rate). By means of simulations on synthetic reads, we also showed in <xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> (2015)</xref> that the likely culprit is the presence of sequencing errors: the assembly quality degradation cannot be observed with error-free reads, whereas higher sequencing error rate intensifies the problem. The ‘message’ of our study (<xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> 2015</xref>) is that when the data are noisy, more data are not necessarily better. Rather, there is an error-rate-dependent optimum.</p>
    <p>Independently from us, study (<xref rid="btv226-B9" ref-type="bibr">Desai <italic>et al.</italic> 2013</xref>) reached similar conclusions: the authors assembled <italic>E. coli</italic> (4.6 Mb), <italic>S. kudriavzevii</italic> (11.18 Mb) and <italic>C. elegans</italic> (100 Mb) using SOAPdenovo, Velvet, ABySS, Meraculous and IDBA_UD at increasing sequencing depths up to 200x (which is not ultra-deep according to our definition). Their analysis showed an optimum sequencing depth (around 100x) for assembling these genomes, which depends on the specific genome and the assembler.</p>
    <p>In addition to sequencing errors, real sequencing data are also plagued by read duplications that contribute to uneven coverage. Read duplication is typically attributed to polymerase chain reaction amplification bias (<xref rid="btv226-B1" ref-type="bibr">Aird <italic>et al.</italic> 2011</xref>; <xref rid="btv226-B28" ref-type="bibr">Zhou <italic>et al.</italic> 2014</xref>). The presence of highly duplicated reads complicates the task for assemblers when they contain sequencing errors; if unique, it would be easy to detect and remove them. As the coverage increases, the probability of an overlap that involves duplicated reads agreeing to each other due to sequencing errors becomes higher and higher. These new overlaps can induce spurious contigs (typically short) or prevent the creation of longer contigs. In turn, this manifests in a degradation of the assembly quality (N50, number of misassemblies, portion of the target genome covered, etc.). We also suspect that the removal of bubbles/bulges from the de Bruijn graph [for details on bubbles/bulges, see e.g. <xref rid="btv226-B27" ref-type="bibr">Zerbino and Birney (2008)</xref> or <xref rid="btv226-B2" ref-type="bibr">Bankevich <italic>et al.</italic> (2012)</xref>] is significantly harder with ultra-deep sequencing data.</p>
    <p>As sequencing errors are the source of the problem, one could attempt to correct them before the assembly. Several stand-alone methods have been proposed in the literature [see <xref rid="btv226-B26" ref-type="bibr">Yang <italic>et al.</italic> (2013)</xref> for a recent survey], and several <italic>de novo</italic> assemblers [e.g. SPAdes (<xref rid="btv226-B2" ref-type="bibr">Bankevich <italic>et al.</italic> 2012</xref>)] employ a preprocessing step for correcting errors. Unfortunately, error correction is not very effective for ultra-deep sequencing data. Most error correction tools are based on k-mer spectrum analysis: the underlying assumption is that ‘rare’ k-mers are likely to contain sequencing errors. As the depth of sequencing increases, so does the number of occurrences of <italic>any</italic> k-mer, including the ones that contain sequencing errors. In <xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> (2015)</xref> and this article, we have collected experimental evidence of the inefficacy of error-correction methods on the assembly of ultra-deep sequencing data.</p>
    <p>An alternative approach to deal with excessive sequencing data is down-sampling. The idea of down-sampling is to disregard a fraction of the input reads, according to some predetermined strategy. The simplest approach is to randomly sample the input and only assemble a fraction of the reads. Although coverage reduction has been primarily used for unbalanced data (<xref rid="btv226-B5" ref-type="bibr">Brown <italic>et al.</italic> 2012</xref>), we have shown in <xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> (2015)</xref> that in the presence of ultra-deep sequencing data, the assembly of a random sample of the input reads only marginally improves the assembly quality compared with the assembly of entire dataset. Diginorm (<xref rid="btv226-B5" ref-type="bibr">Brown <italic>et al.</italic> 2012</xref>) and NeatFreq (<xref rid="btv226-B18" ref-type="bibr">McCorrison <italic>et al.</italic> 2014</xref>) are two examples of down-sampling methods aimed to produce a more uniform coverage. They both reduce coverage by selecting representative reads binned by their median k-mer frequency. In general, down-sampling is not a satisfactory technique to deal with large datasets, unless it is expected to remove most of the ‘bad’ reads and none of the ‘good’ reads. Otherwise, it has the undesirable effect of removing ‘critical’ reads, i.e. rare but error-free reads that can help bridge or fill assembly gaps.</p>
    <p>In this article, we address the question of how to create high-quality assemblies when an ultra-deep dataset is available. We propose a meta-assembly method called S<sc>licembler</sc> that, unlike down-sampling techniques, takes the advantage of the whole input dataset. S<sc>licembler</sc> uses a divide-and-conquer approach: it ‘slices’ a large input into smaller sets of reads, assembles each set individually (using a standard assembler) and then merges the individual assemblies. Our experimental results on real and synthetic data show that S<sc>licembler</sc> can produce higher quality assemblies than the regular assembly of entire dataset (before or after error correction), as well as better assemblies compared with the assembly of random samples of the reads. The assemblies produced by S<sc>licembler</sc> demonstrate that, when an ultra-deep coverage dataset is available, it is possible to create long contigs with no assembly errors. We believe these results can be considered the first step toward making ‘perfect assemblies’. We also show that S<sc>licembler</sc> is less sensitive to sequencing error rates, which could make it desirable for third-generation sequencing data.</p>
  </sec>
  <sec>
    <title>2 Methods</title>
    <p>The availability of ultra-deep sequencing data opens the opportunity to construct assemblies from multiple independent samples of the reads and then compare them with the objective either to (i) merge them or (ii) discover assembly errors and correct them. S<sc>licembler</sc> is based on <italic>majority voting</italic>: if a contig (or a fraction thereof) appears in the majority of the individual assemblies, we assume that it is safe to add that contig to the <italic>consensus</italic> assembly being built. S<sc>licembler</sc> is a meta-assembler for second-generation paired-end short reads, but its framework can be adapted to other type of sequencing data.</p>
    <p><xref ref-type="fig" rid="btv226-F1">Figure 1</xref> illustrates the proposed iterative algorithm. First, S<sc>licembler</sc> partitions the reads into several smaller sets (<italic>slices</italic>). In the second step, it assembles each set individually using a standard assembler (e.g. Velvet, SPAdes, IDBA_UD or Ray). Third, S<sc>licembler</sc> analyzes the individual assemblies and identifies long common contigs (or fractions thereof) supported by a majority of the assemblies. In the fourth step, it merges these common contigs (or fractions thereof) to the partially constructed (<italic>consensus</italic>) assembly being built. Before repeating steps 2, 3 and 4, any read that maps to the consensus assembly is removed from the input.
<fig id="btv226-F1" position="float"><label>Fig. 1.</label><caption><p>S<sc>LICEMBLER’s</sc> pipeline: First, the input reads are partitioned into smaller <italic>slices</italic> (1). Each slice is assembled individually (2), and the resulting assemblies are merged by a ‘majority voting’ process (3, 4). Before repeating these steps, any read in the input that maps to the consensus assembly is removed (6). When no further merging is possible, the final <italic>consensus</italic> assembly is produced (7)</p></caption><graphic xlink:href="btv226f1p"/></fig>
</p>
    <sec id="SEC2.1">
      <title>2.1 ‘Slicing’ the input</title>
      <p>In the first step, the set of input reads is partitioned into <italic>n</italic> distinct slices. Each paired-end read is assigned to exactly one slice, although it is also possible to assign a read to multiple slices. For simplicity, each slice contains approximately the same number of reads. The number of slices is determined from the desired depth of coverage <italic>D</italic><sub>s</sub> for each slice. As we discussed in <xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> (2015)</xref>, the coverage <italic>D</italic><sub>s</sub> is a critical parameter for the quality of assembly. To find a good value for <italic>D</italic><sub>s</sub>, one can run the base assembler (e.g. Velvet, SPAdes, Ray or IDBA_UD) on larger and larger samples of the input and find the coverage that maximizes the chosen assembly statistics (e.g. N50). Once the value of <italic>D</italic><sub>s</sub> is established, one can determine the number of slices by computing <inline-formula><mml:math id="MM1"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mtext>t</mml:mtext></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mtext>s</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula>, where <italic>D</italic><sub>t</sub> is the depth of coverage for the whole input read set. Given the set of input reads, the slice coverage <italic>D</italic><sub>s</sub> and the average read length, it is straightforward to partition the reads into <italic>n</italic> slices with the desired coverage.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Assembling the slices</title>
      <p>In the second step, each of the <italic>n</italic> slices is assembled independently with a standard assembler (e.g. Velvet, SPAdes, Ray or IDBA_UD), possibly with different choices of the <italic>k</italic>-mer values in each slice. Under the assumption that the number of reads in every slice is sufficient for a complete assembly, the ideal outcome is that each of the <italic>n</italic> assemblies covers the entire target genome. In practice, each assembly is expected to contain a mixture of ‘good’ and ‘bad’ contigs due to sequencing errors, repetitive regions and imperfections in the assembly algorithms. The objective of the next step is to identify the ‘good portion’ of each contig by taking a majority vote among the assemblies.</p>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Finding frequently occurring substrings</title>
      <p>In the third step, S<sc>licembler</sc> searches for long substrings that occur exactly in the majority of individual assemblies. The input to this step is a set of <italic>n</italic> assemblies <inline-formula><mml:math id="MM2"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> where each assembly <italic>A<sub>i</sub></italic> is represented as a set of contigs. Given a string <italic>s</italic>, we define <italic>c</italic>(<italic>s</italic>) as a subset <inline-formula><mml:math id="MM3"><mml:mrow><mml:mi>T</mml:mi><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> of assemblies in which <italic>s</italic> appears exactly in at least one contig of each assembly in <italic>T</italic>. Given a minimum support <italic>u</italic> and minimum length <italic>l</italic>, S<sc>licembler</sc> identifies all maximal substrings <italic>r</italic> such that <italic>|r| &gt; l</italic> and |<italic>c</italic>(<italic>r</italic>)<italic>| &gt; u</italic>, that is, <italic>r</italic> is longer than <italic>l</italic> nucleotides and it appears in at least <italic>u</italic> assemblies. By <italic>maximal</italic> we mean that if string <italic>r</italic> was extended by one extra symbol to the left or to the right, then |<italic>c</italic>(<italic>r</italic>)<italic>|</italic> would decrease below threshold <italic>u + </italic>1. We call such substrings <italic>r</italic>, <italic>frequently occurring substrings</italic> (FOS). <xref ref-type="fig" rid="btv226-F2">Figure 2</xref> illustrates four FOS detected from a set of five assemblies. FOS<sub>1</sub> occurs in four assemblies, whereas FOS<sub>2</sub> appears in three of them. FOS<sub>3</sub> and FOS<sub>4</sub> is a pair of overlapping substrings occurring in three assemblies.
<fig id="btv226-F2" position="float"><label>Fig. 2.</label><caption><p>Examples of <italic>frequently occurring substrings</italic> (FOS) from five assemblies (FOS can overlap)</p></caption><graphic xlink:href="btv226f2p"/></fig>
</p>
      <p>To find FOS, we build a generalized suffix tree on the contigs of <italic>n</italic> assemblies (and their reverse complement), then use a variant of the algorithm proposed in <xref rid="btv226-B7" ref-type="bibr">Hui (1992)</xref>. In this algorithm, each input string is assigned a distinct ‘color’. The algorithm uses the generalized suffix tree to compute for each tree node <italic>u</italic> the number of distinct colors in the subtree rooted at node <italic>u.</italic> The algorithm computes the number of colors for each node in linear time in the length of the input strings. Algorithm (<xref rid="btv226-B7" ref-type="bibr">Hui 1992</xref>), however, does not produce maximal substrings. Once the internal nodes have the color information, to ensure right-maximality our algorithm finds the deepest internal node <italic>u</italic> (spelling out string <italic>r, |r| &gt; l</italic>), such that |<italic>c</italic>(<italic>r</italic>)<italic>| &gt; k</italic>. To guarantee left-maximality, we take advantage of suffix links: if node <italic>u</italic> has a suffix link to node <italic>v</italic>, and subtrees rooted at <italic>u</italic> and <italic>v</italic> have the same number of leaves and colors then the string corresponding to <italic>v</italic> is not left-maximal and should not be reported. We mark all the nodes corresponding to the loci of strings contained in string <italic>r</italic>, then the process above is repeated to find the second longest FOS.</p>
      <p>As we mentioned earlier, repetitive regions in the genome represent a major challenge for assemblers. Often a FOS includes a repetitive pattern at the end due to disagreements among assemblies on how many times that pattern should be repeated. The ends of each FOS are critical for merging, which requires a prefix–suffix overlap. Any error in these sections may prevent the algorithm from merging overlapping FOS (discussed in Section 2.4 later). To avoid merging errors in later steps, S<sc>licembler</sc> checks 20 bp at the ends of each FOS. If a tandem repeat is found at any of the ends, all copies (except one) of the repeated pattern are eliminated. Specifically, any string in the form of αββ<sup>+</sup> (where |β| &lt; 10 bp) is replaced with αβ.</p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 Merging frequently occurring sequences</title>
      <p>When detected FOS are overlapping (e.g. FOS<sub>3</sub> and FOS<sub>4</sub> in <xref ref-type="fig" rid="btv226-F2">Fig. 2</xref>), they can be merged to obtain longer FOS (FOS will also be merged to the contigs in the consensus assembly being built). S<sc>licembler</sc> identifies any FOS that has an exact suffix–prefix overlap (i.e. no mismatches/indels) with another FOS (or its reverse complement) and determines the number of paired-end reads that connect each pair of such overlapping FOS. A pair of FOS is merged if either (i) the exact overlap is at least 100 bp or (ii) the exact overlap is 50–99 bp and the number of paired end reads connecting them is at least <italic>D</italic><sub>t</sub>/1000 or (iii) the exact overlap is 20–49 bp and the number of paired end reads connecting them is at least <italic>D</italic><sub>t</sub>/100. This idea of using paired-end read to increase the confidence of an overlap is similar to the scaffolding step used to order and orient contigs in <italic>de novo</italic> assemblers or specialized scaffolding tools like (<xref rid="btv226-B21" ref-type="bibr">Pop <italic>et al.</italic> 2004</xref>).</p>
    </sec>
    <sec id="SEC2.5">
      <title>2.5 S<sc>licembler</sc> algorithm</title>
      <p>S<sc>licembler</sc> is an iterative meta-assembler. The main steps of slicing/assembling/merging are executed iteratively until a predetermined condition is met. <xref ref-type="table" rid="btv226-T1">Table 1</xref> presents a sketch of our algorithm. As described in Section 2.1, the number of slices is calculated from the chosen slice coverage (<italic>D</italic><sub>S</sub>). The input read set is partitioned into <italic>n</italic> slices (line 2). The rest of the algorithm is performed iteratively (lines 3–19) until the total length of the consensus assembly <italic>F</italic> meets or exceeds the target genome size, or no sufficiently long FOS can be found. At the beginning of a new iteration, S<sc>licembler</sc> assembles the reads in each slice individually (lines 4–6). Next, a generalized suffix tree <italic>T</italic> is created from the contigs in the individual assemblies (both forward and reverse complement) (line 7). Using the suffix tree, S<sc>licembler</sc> produces the set of maximal substrings longer than <italic>l</italic> bases that occur in at least <italic>u</italic> assemblies (out of <italic>n</italic>, line 11). The FOS set could contain any number of strings (including none). Then, S<sc>licembler</sc> checks whether FOS overlapping with the current consensus assembly meet the conditions described in Section 2.4 and merges them (line 12). The parameter <italic>u</italic> is set to <italic>n</italic> initially, so S<sc>licembler</sc> first tries to determine whether there is any FOS that appears in all the assemblies. If no new FOS is found, the support <italic>u</italic> is decreased (by one) and the loop is repeated. The parameter <italic>u</italic> is decreased until at least one FOS is detected or <italic>u</italic> becomes smaller than <italic>n</italic>/2. If <italic>u</italic> becomes smaller than <italic>n</italic>/2, the minimum length <italic>l</italic> is halved and <italic>u</italic> is initialized again to <italic>n</italic>. We selected <italic>n</italic>/2 as the ‘turning point’ because we would not trust any common substring that appears in the minority of the assemblies. The initial value for <italic>l</italic> is one-fifth of the size of the target; based on our observations, using a larger value for the initial value of <italic>l</italic> is unlikely to improve the results but makes S<sc>licembler</sc> slower. The iterative process stops when <italic>l</italic> drops below <italic>l</italic><sub>min</sub>, which is desired minimum contig length in the final assembly (<italic>l</italic><sub>min</sub> is user-defined, typically 200–500 bp). If <italic>l</italic> is below <italic>l</italic><sub>min</sub> and no new FOS have been identified in the current iteration (line 17), S<sc>licembler</sc>’s iterative process is terminated and the consensus assembly is reported.
<table-wrap id="btv226-T1" position="float"><label>Table 1.</label><caption><p>A sketch of S<sc>licembler</sc>’s algorithm</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Inputs</th><th rowspan="1" colspan="1">Input reads (<italic>S</italic>), slice coverage (<italic>D</italic><sub>S</sub>), min contig length (<italic>l</italic><sub>min</sub>), size of the target genome (<italic>l</italic><sub>target</sub>)</th></tr><tr><th rowspan="1" colspan="1">Output</th><th rowspan="1" colspan="1">Set of contigs (<italic>F</italic>)</th></tr></thead><tbody align="left"><tr><td align="char" char="." rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1"><italic>F</italic> ← Ø</td></tr><tr><td align="char" char="." rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">Partition <italic>S</italic> into <italic>n</italic> slices <italic>S</italic><sub>1</sub><italic>,S</italic><sub>2</sub><italic>,…, S<sub>n</sub></italic> each of which has coverage <italic>D</italic><sub>S</sub></td></tr><tr><td align="char" char="." rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1"><bold>while</bold> (<italic>|F| &lt; l</italic><sub>target)</sub>
<bold>do</bold></td></tr><tr><td align="char" char="." rowspan="1" colspan="1">4</td><td rowspan="1" colspan="1"><italic>A</italic> ← Ø</td></tr><tr><td align="char" char="." rowspan="1" colspan="1">5</td><td rowspan="1" colspan="1"><bold>for</bold> i ←1 <bold>to</bold>
<italic>n</italic>
<bold>do</bold></td></tr><tr><td align="char" char="." rowspan="1" colspan="1">6</td><td rowspan="1" colspan="1"><italic>A</italic> ← <italic>A</italic> ∪ Assemble(<italic>S<sub>i</sub></italic>)</td></tr><tr><td align="char" char="." rowspan="1" colspan="1">7</td><td rowspan="1" colspan="1"><italic>T</italic> ← GeneralizedSuffixTree (<italic>A</italic>, ReverseComplement(<italic>A</italic>))</td></tr><tr><td align="char" char="." rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1"><italic>u ← n</italic></td></tr><tr><td align="char" char="." rowspan="1" colspan="1">9</td><td rowspan="1" colspan="1"><italic>l ← l</italic><sub>target</sub>/5</td></tr><tr><td align="char" char="." rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1"><bold>while (</bold><italic>l &gt; l</italic><sub>min</sub><bold>)</bold></td></tr><tr><td align="char" char="." rowspan="1" colspan="1">11</td><td rowspan="1" colspan="1">FOS ← FindFOS(<italic>T, u, l</italic>)</td></tr><tr><td align="char" char="." rowspan="1" colspan="1">12</td><td rowspan="1" colspan="1"><bold>if</bold> (FOS ≠ Ø) <bold>then</bold>
<italic>F</italic> ← MergeFOS(FOS, <italic>F</italic>)</td></tr><tr><td align="char" char="." rowspan="1" colspan="1">13</td><td rowspan="1" colspan="1"><bold>break</bold></td></tr><tr><td align="char" char="." rowspan="1" colspan="1">14</td><td rowspan="1" colspan="1"><bold>else if</bold> (<italic>u &gt; n</italic>/2) <bold>then</bold>
<italic>u</italic> ← <italic>u –</italic> 1</td></tr><tr><td align="char" char="." rowspan="1" colspan="1">15</td><td rowspan="1" colspan="1"><bold>else</bold><italic>l ← l</italic>/2</td></tr><tr><td align="char" char="." rowspan="1" colspan="1">16</td><td rowspan="1" colspan="1"><italic>u ← n</italic></td></tr><tr><td align="char" char="." rowspan="1" colspan="1">17</td><td rowspan="1" colspan="1"><bold>if (</bold><italic>l &lt;</italic><bold> = </bold><italic>l</italic><sub>min</sub>) <bold>and</bold> (FOS<bold> = </bold>Ø) <bold>then break</bold></td></tr><tr><td align="char" char="." rowspan="1" colspan="1">18</td><td rowspan="1" colspan="1"><bold>for</bold> i ← 1 <bold>to</bold>
<italic>n</italic>
<bold>do</bold></td></tr><tr><td align="char" char="." rowspan="1" colspan="1">19</td><td rowspan="1" colspan="1"><italic>S<sub>i</sub></italic> ← FindUnmappedReads(<italic>F, S<sub>i</sub></italic>)</td></tr><tr><td align="char" char="." rowspan="1" colspan="1">20</td><td rowspan="1" colspan="1"><bold>return</bold><italic>F</italic></td></tr></tbody></table></table-wrap></p>
      <p>Before starting a new iteration, all the reads in each slice are mapped to all detected FOS in the current consensus assembly. Each paired end read that maps exactly to any contig in the current assembly is removed (lines 18-19), and only the remaining reads are assembled in the next iteration. Note that we do not repartition the read sets after this step, because although the number of reads decreases, so does the size of the target we are supposed to reconstruct. There is one exception to this strategy of read elimination. Recall that to be able to merge the FOS set with the current assembly, the strings have to overlap a minimum number of bases. To make sure that this will be possible in future iterations, reads that are mapped close to the ends of contigs of the current assembly are not eliminated.</p>
      <p>Like any other assembly pipeline, gap filling and scaffolding can be applied at the end of the process to improve the quality of final assembly. In this case, gap filling is easier than usual because of the high quality of contigs produced by S<sc>licembler</sc> and the very large number of reads available for filling the gaps. Also, the number of gaps to be filled at the end is relatively small since S<sc>licembler</sc> fills some of the gaps during the merging process (see <xref ref-type="fig" rid="btv226-F4">Fig. 4</xref> for an example). The merging step uses small FOS identified in the later iterations to ‘glue’ adjacent contigs.</p>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 Experimental results</title>
    <p>We implemented S<sc>licembler</sc> in Python. Our tool can be accessed at <ext-link ext-link-type="uri" xlink:href="http://slicembler.cs.ucr.edu/">http://slicembler.cs.ucr.edu/</ext-link>. S<sc>licembler</sc> is a meta-assembler; its performance directly depends on the base assembler. In the following experiments, we used Velvet as the base assembler, unless stated otherwise. The performance of S<sc>licembler</sc> using other base assemblers (IDBA_UD, Ray and SPAdes) is presented in Section 3.3. The number of slices and the sequencing error rate for the input reads are other factors that critically influence the quality of the final assembly. We study these issues in Section 3.4 and Section 3.5.</p>
    <p>Recall that at the end of every iteration, all reads are mapped to the partially constructed assembly to detect bridge reads (to be used later in the merging step) and to eliminate reads that are already represented in the assembly. S<sc>licembler</sc> uses BWA (<xref rid="btv226-B16" ref-type="bibr">Li and Durbin 2009</xref>) to find perfect alignments (no mismatches, no gaps) for this purpose. We used a minimum contig length <italic>l</italic><sub>min</sub> = 200 (which is the default parameter for S<sc>licembler</sc>). We did not use any gap filling or scaffolding tool on the final assemblies. All experiments were carried on a Linux server with 20 computing cores and 194 GB of RAM.</p>
    <sec id="SEC3.1">
      <title>3.1 Ultra-deep sequencing of barley BACs</title>
      <p>To carry out experiments on real ultra-deep data, we sequenced a set of 16 BAC genomic clones of barley (<italic>Hordeum vulgare</italic> L<italic>.</italic>) on an Illumina HiSeq2000 at UC Riverside at a depth of coverage 8000 x–15 000 x. The average read length was about 88 bases after quality trimming; reads were paired-end with an average insert size of 275 bases. Another set of 52 barley BACs was sequenced by the Department of Energy Joint Genome Institute using Sanger sequencing. As the primary DNA sequences for each of these 52 BACs were assembled in one solid contig [details in <xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> (2015)</xref>], we assumed these Sanger-based assemblies to be the ‘ground truth’ or ‘reference’. Five ultra-deep sequenced BACs had such a reference, so we used them to objectively evaluate the performance of S<sc>licembler</sc>. To have an equal-sized input dataset for all BACs, we used only 8000x worth of coverage. These five barley BAC clones, hereafter referred as BAC 1–5 have the following lengths: 131 747 bp, 108 261 bp, 110 772 bp, 111 748 bp and 102 968 bp, respectively. We should remind the reader that the barley genome is highly repetitive. Approximately 84% of the genome consists of mobile elements or other repeat structures (<xref rid="btv226-B15" ref-type="bibr">International Barley Genome Sequencing Consortium <italic>et al.</italic>, 2012</xref>).</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Quality of S<sc>licembler</sc>’s assemblies</title>
      <p>S<sc>licembler</sc> divided each of the five ultra-deep BAC inputs into 10 slices (<italic>D</italic><sub>s</sub> = 800 x coverage). We showed in <xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> (2015)</xref> that such coverage is expected to provide a ‘good’ assembly in terms of N50, longest contig, number of misassemblies (i.e. misjoined contigs) and percentage of the target genome covered. We compared the performance of S<sc>licembler</sc> to three alternative methods, namely (A) assemble all reads (8000x coverage) with the same assembler used in S<sc>licembler</sc>, (B) run error-correction [using Racer (<xref rid="btv226-B14" ref-type="bibr">Ilie and Molnar 2013</xref>)] on all reads (8000x coverage) then assemble the corrected reads with the same assembler used in S<sc>licembler</sc> and (C) assemble each of the slices (800x coverage) individually and consider the average statistics over the 10 slices (down-sampling).</p>
      <p><xref ref-type="fig" rid="btv226-F3">Figure 3</xref> summarizes the assembly statistics collected with QUAST (<xref rid="btv226-B13" ref-type="bibr">Gurevich <italic>et al.</italic> 2013</xref>) for S<sc>licembler</sc> compared with methods A, B and C described above. The base assembler was Velvet (hash value 69). Several observations on <xref ref-type="fig" rid="btv226-F3">Figure 3</xref> are in order. First, note that for most of the BACs, down-sampling at 800 x leads to better quality assemblies than the assembly of all the reads at 8000 x. This is consistent with our previous results (<xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> 2015</xref>). Second, error correction increases the quality of assemblies for most of the BACs. At the same time, error correction affects negatively other statistics like duplication ratio and N50.
<fig id="btv226-F3" position="float"><label>Fig. 3.</label><caption><p>Summary of assembly statistics on five barley BACs sequenced at 8000x. We compared S<sc>licembler</sc> (using Velvet) with three alternative methods: Velvet on the entire dataset, Racer + Velvet on the entire dataset and the average performance of Velvet on the slices of 800 x each (see legend). Ground truth was based on Sanger-based assemblies. Statistics were collected with QUAST for contigs longer than 500 bp</p></caption><graphic xlink:href="btv226f3p"/></fig>
<fig id="btv226-F4" position="float"><label>Fig. 4.</label><caption><p>An illustration of S<sc>LICEMBLER’s</sc> progressive construction of the consensus assembly for BACs 1, 2 and 3 (‘snapshots’ are taken every five iterations). Each box represents a perfect alignment between that contig and the reference. Light green boxes indicate a new FOS compared with the previous snapshot. Circles point to gaps closed or contig extended via the merging process (picture created with CLC sequence viewer)</p></caption><graphic xlink:href="btv226f4p"/></fig>
</p>
      <p>Finally and more importantly, observe that in the majority of cases, S<sc>licembler</sc> generates the highest quality assemblies. Its assemblies are less fragmented, which is reflected by a smaller number of contigs, longer longest contigs and higher N50. Also, S<sc>licembler</sc>’s assemblies cover a higher fraction of the target genome and they have a much smaller number of misassembly errors compared with the other approaches. In fact, S<sc>licembler</sc>’s assemblies are almost error-free. BAC 4 is the only exception: although S<sc>licembler</sc>’s assembly of BAC 4 has fewer misassemblies than the assembly of all the reads before or after error correction, it contains more errors than the average downsampling-based assembly. The slightly higher number of assembly errors for S<sc>licembler</sc> is due to the merging step, which could be made more conservative. S<sc>licembler</sc>’s contigs also contained less mismatches and indels compared with the other methods (data not shown). Finally, note that S<sc>licembler</sc>’s assemblies are less inflated than the other approaches. The assembly of all the reads, with or without error correction, has quite large duplication ratio.</p>
      <p>To illustrate the progress during S<sc>licembler</sc>’s iterative refinements, <xref ref-type="fig" rid="btv226-F4">Figure 4</xref> shows the status of the consensus assembly created for BACs 1, 2 and 3 every five iterations. Each box represents a perfect alignment of a S<sc>licembler</sc>’s contig to the reference genome (no insertion/deletion/mismatches allowed). Observe that in the last iteration 85–95% of the target genome is covered by the error-free contigs. In the first iterations, most of the target genome is covered by large FOS. In later iterations, FOS are smaller but they can connect adjacent contigs or extend them (see red circles). Most of the small gaps between the contigs are composed by repetitive patterns. These gaps are induced by the ‘trimming’ step of the algorithm, which eliminates repetitive patterns from the ends of FOS to avoid false overlaps. A gap-filling tool can easily close these small gaps during the finishing step.</p>
      <p>As mentioned above, at the end of each iteration, S<sc>licembler</sc> maps the current set of input reads to the consensus assembly: any read that is mapped exactly is discarded. This allows S<sc>licembler</sc> (and its base assembler) to ‘focus’ on the parts of the genome/BAC that are still missing from the consensus assembly. Because FOS in early iterations are ‘safer’ to be added to the consensus assembly, the set of reads discarded in early iterations are expected to be of higher quality. To this end, we determined the percentage of reads at each iteration of S<sc>licembler</sc> that could be mapped exactly (i.e. no mismatches/indels) to the reference genome. <xref ref-type="fig" rid="btv226-F5">Figure 5</xref> shows these percentages for the first 15 iterations in the assembly of the five BACs. Observe that the percentage of high-quality reads is about 85% in early iterations.
<fig id="btv226-F5" position="float"><label>Fig. 5.</label><caption><p>The percentage of reads (<italic>y</italic> axis) at each iteration of S<sc>licembler</sc> (<italic>x</italic> axis) that map exactly (i.e. zero mismatches/indels) to the reference on the five ultra-deep sequenced BACs</p></caption><graphic xlink:href="btv226f5p"/></fig>
</p>
      <p>As the number of iterations increases, the percentage of high-quality reads in the input monotonically decreases. In the last few iterations, the percentage stays somewhat flat because later FOS are shorter, so the additional number of high-quality reads mapped to these FOS is also small.</p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 The choice of the base assembler</title>
      <p>Recall that S<sc>licembler</sc> is a meta-assembler, and its performance depends on the performance on the base assembler. To evaluate the influence of base assembler on the assembly quality, we compared several assemblers, namely Velvet (<xref rid="btv226-B27" ref-type="bibr">Zerbino and Birney 2008</xref>), SPAdes (<xref rid="btv226-B2" ref-type="bibr">Bankevich <italic>et al.</italic> 2012</xref>), Ray (<xref rid="btv226-B4" ref-type="bibr">Boisvert <italic>et al.</italic> 2010</xref>) and IDBA_UD (<xref rid="btv226-B20" ref-type="bibr">Peng <italic>et al.</italic> 2012</xref>).</p>
      <p>Experimental results for BAC 3 are shown below in <xref ref-type="table" rid="btv226-T2">Table 2</xref>. We compared the assembly produced by Velvet, SPAdes, Ray and IDBA_UD on all the reads (8000x) against the assemblies created by S<sc>licembler</sc> in conjunction with the corresponding base assembler. S<sc>licembler</sc> was run on 10 slices (800x each). The k-mer used was 69 for Velvet and Ray. For IDBA_UD and SPAdes, the reported assembly was based on three different k-mers (29, 49 and 69).
<table-wrap id="btv226-T2" position="float"><label>Table 2.</label><caption><p>Comparing BAC assemblies produced with IDBA_UD, Velvet, SPAdes and Ray to the assemblies produced by S<sc>LICEMBLER</sc> in conjunction with the same assembler; the numbers in bold represent the best assembly statistic between S<sc>LICEMBLER</sc> and the coresponding base assembler</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Methods</th><th rowspan="1" colspan="1">Number of contigs</th><th rowspan="1" colspan="1">Percent ref covered</th><th rowspan="1" colspan="1">Duplication ratio</th><th rowspan="1" colspan="1">Misassemblies|mismatches per 100 kb</th><th rowspan="1" colspan="1">N50</th><th rowspan="1" colspan="1">Longest contig</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">IDBA_UD (8000x)</td><td align="char" char="." rowspan="1" colspan="1">34</td><td align="char" char="." rowspan="1" colspan="1">97.0%</td><td align="char" char="." rowspan="1" colspan="1"><bold>1.010</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0|0.93</bold></td><td align="char" char="." rowspan="1" colspan="1">7335</td><td align="char" char="." rowspan="1" colspan="1">13 889</td></tr><tr><td rowspan="1" colspan="1">S<sc>licembler</sc> + IDBA (10 slices of 800 x)</td><td align="char" char="." rowspan="1" colspan="1"><bold>13</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>97.0%</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>1.010</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0</bold>|1.1</td><td align="char" char="." rowspan="1" colspan="1"><bold>16 121</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>31 161</bold></td></tr><tr><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">Velvet (8000x)</td><td align="char" char="." rowspan="1" colspan="1">39</td><td align="char" char="." rowspan="1" colspan="1">94.7%</td><td align="char" char="." rowspan="1" colspan="1">1.027</td><td rowspan="1" colspan="1">10|20.0</td><td align="char" char="." rowspan="1" colspan="1">3649</td><td align="char" char="." rowspan="1" colspan="1">16 048</td></tr><tr><td rowspan="1" colspan="1">S<sc>licembler</sc> + Velvet (10 slices of 800 x)</td><td align="char" char="." rowspan="1" colspan="1"><bold>14</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>95.1%</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>1.001</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0</bold>|<bold>0</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>12 178</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>16 128</bold></td></tr><tr><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">SPAdes (8000x)</td><td align="char" char="." rowspan="1" colspan="1">49</td><td align="char" char="." rowspan="1" colspan="1">95.7%</td><td align="char" char="." rowspan="1" colspan="1"><bold>1.006</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0</bold>|<bold>0.94</bold></td><td align="char" char="." rowspan="1" colspan="1">9129</td><td align="char" char="." rowspan="1" colspan="1">21 872</td></tr><tr><td rowspan="1" colspan="1">S<sc>licembler</sc> + SPAdes (10 slices of 800 x)</td><td align="char" char="." rowspan="1" colspan="1"><bold>11</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>96.9%</bold></td><td align="char" char="." rowspan="1" colspan="1">1.024</td><td align="char" char="." rowspan="1" colspan="1"><bold>0</bold>|1.2</td><td align="char" char="." rowspan="1" colspan="1"><bold>27 685</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>31 158</bold></td></tr><tr><td rowspan="1" colspan="1"/></tr><tr><td rowspan="1" colspan="1">Ray (8000x)</td><td align="char" char="." rowspan="1" colspan="1">35</td><td align="char" char="." rowspan="1" colspan="1">80.0%</td><td align="char" char="." rowspan="1" colspan="1">1.003</td><td align="char" char="." rowspan="1" colspan="1"><bold>0</bold>|<bold>0</bold></td><td align="char" char="." rowspan="1" colspan="1">3996</td><td align="char" char="." rowspan="1" colspan="1">7186</td></tr><tr><td rowspan="1" colspan="1">S<sc>licembler</sc> + Ray (10 slices of 800 x)</td><td align="char" char="." rowspan="1" colspan="1"><bold>24</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>88.0%</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>1.000</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0</bold>|<bold>0</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>7192</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>12 842</bold></td></tr></tbody></table><table-wrap-foot><fn id="btv226-TF1"><p>Statistics were collected with QUAST for contigs longer than 500 bp.</p></fn></table-wrap-foot></table-wrap></p>
      <p>Observe that among the stand-alone assemblers, IDBA_UD and SPAdes created higher quality assemblies compared with Velvet and Ray. However, regardless of the choice of the base assembler, S<sc>licembler</sc> improved the quality of the assemblies.</p>
      <p>The only ‘negative’ statistics for S<sc>licembler</sc> is that it introduced a few more errors in the assemblies created using IDBA_UD and SPAdes. We determined that these additional errors were due to incorrect merging in later iterations. Also, S<sc>licembler</sc> had a slightly higher duplication ratio than SPAdes. Other than these, S<sc>licembler</sc> significantly improved all other statistics. In fact, similar results were observed on the other four BACs (data not shown). In general, S<sc>licembler</sc> created higher quality assemblies when used in conjunction with IDBA_UD and SPAdes</p>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 The choice of depth of coverage for each slice</title>
      <p>The depth of coverage in each slice is critical to optimize on the quality of the assemblies. If the depth of coverage is too low, the assembly of each slice will be fragmented, which will be reflected in shorter FOS. On the other hand, more slices can increase the confidence in choosing FOS due to more ‘votes’ available. For this reason, we decided to use simulations to study the tradeoffs of the depth of coverage in each slice. To this end, we used wgsim (<ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/wgsim">https://github.com/lh3/wgsim</ext-link>) to generate synthetic datasets with 500x, 1000x, 2500x, 5000x, 7500x and 10 000x reads at 1% sequencing error rate (no indels) based on the reference sequence of BAC 3. Each dataset was assembled with S<sc>licembler</sc> using Velvet as the base assembler by dividing the input into 10 slices, so that the coverage in each slice was 50x, 100x, 250x, 500x, 750x and 1000x.</p>
      <p><xref ref-type="table" rid="btv226-T3">Table 3</xref> shows the usual quality statistics for the assemblies on simulated reads. Observe that S<sc>licembler</sc>’s best performance is observed when slices are in the 100x–500x coverage range. When the slice coverage is lower than 100x, assemblies are more fragmented due to insufficient coverage. When the slice coverage is higher than 500x, we experience the negative effects of ultra-deep sequencing data on the quality of the individual assemblies: FOS become smaller and the final assembly is more fragmented. Note that despite the 1% sequencing error rate, S<sc>licembler</sc> was able to create error free contigs for all cases.
<table-wrap id="btv226-T3" position="float"><label>Table 3.</label><caption><p>Quality statistics for S<sc>LICEMBLER's</sc> assemblies for simulated reads with different depth of coverage; the number in bold represent the best assembly statistic in each row</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">500x</th><th rowspan="1" colspan="1">1000x</th><th rowspan="1" colspan="1">2500x</th><th rowspan="1" colspan="1">5000x</th><th rowspan="1" colspan="1">7500x</th><th rowspan="1" colspan="1">10 000x</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">Number of contigs</td><td align="char" char="." rowspan="1" colspan="1">20</td><td align="char" char="." rowspan="1" colspan="1">12</td><td align="char" char="." rowspan="1" colspan="1">11</td><td align="char" char="." rowspan="1" colspan="1"><bold>10</bold></td><td align="char" char="." rowspan="1" colspan="1">18</td><td align="char" char="." rowspan="1" colspan="1">38</td></tr><tr><td rowspan="1" colspan="1">Longest contig</td><td align="char" char="." rowspan="1" colspan="1">27 364</td><td align="char" char="." rowspan="1" colspan="1">31 823</td><td align="char" char="." rowspan="1" colspan="1">31 946</td><td align="char" char="." rowspan="1" colspan="1"><bold>31 950</bold></td><td align="char" char="." rowspan="1" colspan="1">21 865</td><td align="char" char="." rowspan="1" colspan="1">9425</td></tr><tr><td rowspan="1" colspan="1">N50</td><td align="char" char="." rowspan="1" colspan="1">6707</td><td align="char" char="." rowspan="1" colspan="1">26 275</td><td align="char" char="." rowspan="1" colspan="1"><bold>26 288</bold></td><td align="char" char="." rowspan="1" colspan="1">26 267</td><td align="char" char="." rowspan="1" colspan="1">12 428</td><td align="char" char="." rowspan="1" colspan="1">3643</td></tr><tr><td rowspan="1" colspan="1">Percent refer. covered</td><td align="center" rowspan="1" colspan="1">90.6%</td><td align="center" rowspan="1" colspan="1">88.7%</td><td align="center" rowspan="1" colspan="1"><bold>94%</bold></td><td align="center" rowspan="1" colspan="1">93.9%</td><td align="center" rowspan="1" colspan="1">92.9%</td><td align="center" rowspan="1" colspan="1">84.7%</td></tr><tr><td rowspan="1" colspan="1">Duplication ratio</td><td align="char" char="." rowspan="1" colspan="1">1</td><td align="char" char="." rowspan="1" colspan="1">1</td><td align="char" char="." rowspan="1" colspan="1">1</td><td align="char" char="." rowspan="1" colspan="1">1</td><td align="char" char="." rowspan="1" colspan="1">1</td><td align="char" char="." rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">Misassemblies</td><td align="char" char="." rowspan="1" colspan="1">0</td><td align="char" char="." rowspan="1" colspan="1">0</td><td align="char" char="." rowspan="1" colspan="1">0</td><td align="char" char="." rowspan="1" colspan="1">0</td><td align="char" char="." rowspan="1" colspan="1">0</td><td align="char" char="." rowspan="1" colspan="1">0</td></tr><tr><td rowspan="1" colspan="1">Mismatches and indels</td><td align="char" char="." rowspan="1" colspan="1">0</td><td align="char" char="." rowspan="1" colspan="1">0</td><td align="char" char="." rowspan="1" colspan="1">0</td><td align="char" char="." rowspan="1" colspan="1">0</td><td align="char" char="." rowspan="1" colspan="1">0</td><td align="char" char="." rowspan="1" colspan="1">0</td></tr></tbody></table><table-wrap-foot><fn id="btv226-TF2"><p>We used 10 slices in all experiments (i.e. the coverage for each slice was 50x, 100x, 250x, 500x, 750x and 1000x). Statistics were collected with QUAST for contigs longer than 500 bp.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="SEC3.5">
      <title>3.5 Effect of sequencing error rate in the reads</title>
      <p><italic>De novo</italic> assemblers are quite sensitive to sequencing error rate in the input reads. Even assemblers that have a preprocessing step for error correction (e.g. SPAdes) have difficulties handling errors when the depth of coverage is very high (<xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> 2015</xref>). Because S<sc>licembler</sc> relies on majority voting for common contigs in the slice assemblies, we wondered whether it would be more resilient compared with its base assembler. To this end, we used wgsim to generate datasets at 3000x coverage with increasing sequencing error rate, namely 0% (errorless), 0.5%, 1% and 2% error rate based on BAC 3. We assembled each set with S<sc>licembler</sc>+Velvet using six slices of 500x coverage each. Results are reported in <xref ref-type="fig" rid="btv226-F6">Figure 6</xref>.
<fig id="btv226-F6" position="float"><label>Fig. 6.</label><caption><p>The effect of increasing sequencing error rates on the quality of assemblies created by Velvet and S<sc>licembler</sc> + Velvet. Input paired-end reads were generated using wgsim with a coverage of 3000x using BAC 3 as a reference. For S<sc>licembler</sc>, simulated read sets were divided into six slices. Statistics were collected with QUAST for contigs longer than 500 bp</p></caption><graphic xlink:href="btv226f6p"/></fig>
</p>
      <p>First, note that S<sc>licembler</sc> was not able to improve the quality of assembly when the reads are error-free. This is consistent with the results in <xref rid="btv226-B17" ref-type="bibr">Lonardi <italic>et al.</italic> (2015)</xref> for error-free reads. Velvet and other <italic>de novo</italic> assemblers are capable of producing high-quality assemblies when reads are error-free, since there are no imperfections in the de Bruijn graph. More importantly, observe that as the sequencing error rate increases, the performance of Velvet quickly degrades, whereas the performance of S<sc>licembler</sc> is unaffected (despite using Velvet as the base assembler). Particularly remarkable is the number of mismatches and indels per 100 kb, which stays at zero for S<sc>licembler</sc> for all the tested error rates (up to 2%). There were no misassemblies in the assemblies created by both Velvet and S<sc>licembler</sc>.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion and conclusion</title>
    <p>Advancement in sequencing technologies has been reducing sequencing costs exponentially fast. Ultra-deep sequencing is now feasible, especially for smaller genomes and clones. We expect that in the near future life, scientists will sequence ‘as much as they want’ because the sequencing cost will be a minor component of total project costs. This explosion of data will create new algorithmic challenges. We have shown previously that popular modern <italic>de novo</italic> assemblers are unable to take advantage of ultra-deep coverage, and the quality of assemblies starts degrading after a certain depth of coverage. S<sc>licembler</sc> is an iterative meta-assembler that solves this problem: it takes advantage of the whole dataset and significantly improves the final quality of the assembly. The strength of S<sc>licembler</sc> is based on the majority voting scheme: in our experiments, FOS selected by S<sc>licembler</sc> from the slice assemblies never contain errors with the exception of FOS belonging to the very ends of the target genome, which are not as reliable because coverage tends to be lower. S<sc>licembler</sc> extracts high-quality contigs from the slice assemblies, and it prevents contigs containing mis-joins and calling errors to be included in the final assembly.</p>
    <p>Experiments on a set of ultra-deep barley BACs and simulated data show that our proposed method leads to higher quality assemblies than the corresponding base assembler. We also demonstrated that S<sc>licembler</sc> is more resilient to high sequencing error rates than its base assembler. Our proposed algorithm is expected to work for genomes of any length, but the current implementation of S<sc>licembler</sc> has been tested only on relatively small genomic target sequences for which real ultra-deep coverage is now available. For S<sc>licembler</sc> to scale to larger genomes, its efficiency must be improved. S<sc>licembler</sc> has to execute the base assemblers tens to hundreds of times (depending on the number or slices and iterations). Obviously, S<sc>licembler</sc> is expected to be significantly slower than the base assembler. For example, S<sc>licembler</sc> was around 50x slower than Velvet to assemble BAC 1. Most of the computational effort in S<sc>licembler</sc> is spent in finding FOS (this required construction of the generalized suffix tree), merging FOS (this requires computing exact prefix–suffix overlaps) and mapping the reads (this requires running BWA) at every iteration. One way to increase the algorithm speed would be to process the slices in parallel. Another possible improvement would be to map the reads to each slice assembly only once and process the alignment file to determine which reads should be passed to the following iteration, instead of mapping the reads to the slice assembly from scratch in every iteration. We are also working on improving the merging step, to prevent mis-joins. More advanced approaches for merging contigs, like methods proposed for merging draft assemblies (<xref rid="btv226-B19" ref-type="bibr">Nijkamp <italic>et al.</italic> 2010</xref>; <xref rid="btv226-B22" ref-type="bibr">Soueidan <italic>et al.</italic> 2013</xref>; <xref rid="btv226-B24" ref-type="bibr">Vicedomini <italic>et al.</italic> 2013</xref>), may improve the quality of S<sc>licembler</sc> results. We plan to release soon an improved version of S<sc>licembler</sc> implemented in C++.</p>
    <p>To conclude, the results presented in this article indicate the possibility of having (almost) perfect assemblies when the depth of coverage is very high. Although there is more work to be done to achieve a perfect assembly, we believe that S<sc>licembler</sc> represents a significant step forward in this direction.</p>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>We thank Weihua Pan (UC Riverside), Hind Alhakami (UC Riverside) and Prof. Pavel Pevzner (UC San Diego) for early comments on this study.</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>This work was supported in part by the <funding-source>U.S. National Science Foundation</funding-source> [<award-id>DBI-1062301</award-id>] and [<award-id>IIS-1302134</award-id>], by the <funding-source>USDA National Institute of Food and Agriculture</funding-source> [<award-id>2009-65300-05645</award-id>], by the <funding-source>USAID Feed the Future program</funding-source> [<award-id>AID-OAA-A-13-00070</award-id>] and the <funding-source>UC Riverside Agricultural Experiment Station Hatch Project CA-R-BPS-5306-H</funding-source>.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="btv226-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Aird</surname><given-names>D.</given-names></name><etal/></person-group> (<year>2011</year>) 
<article-title>Analyzing and minimizing PCR amplification bias in Illumina sequencing libraries</article-title>. <source>Genome Biol.</source>, <volume>12</volume>, <fpage>R18</fpage>.<pub-id pub-id-type="pmid">21338519</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bankevich</surname><given-names>A.</given-names></name><etal/></person-group> (<year>2012</year>) 
<article-title>SPAdes: a new genome assembly algorithm and its applications to single-cell sequencing</article-title>. <source>J. Comput. Biol.</source>, <volume>19</volume>,<fpage>455</fpage>–<lpage>477</lpage>.<pub-id pub-id-type="pmid">22506599</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Beerenwinkel</surname><given-names>N.</given-names></name><name><surname>Zagordi</surname><given-names>O.</given-names></name></person-group> (<year>2011</year>) 
<article-title>Ultra-deep sequencing for the analysis of viral populations</article-title>. <source>Curr. Opin. Virol.</source>, <volume>1</volume>, <fpage>413</fpage>–<lpage>418</lpage>.<pub-id pub-id-type="pmid">22440844</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Boisvert</surname><given-names>S.</given-names></name><etal/></person-group> (<year>2010</year>) 
<article-title>Ray: simultaneous assembly of reads from a mix of high-throughput sequencing technologies</article-title>. <source>J. Comput. Biol.</source>, <volume>17</volume>, <fpage>1519</fpage>–<lpage>1533</lpage>.<pub-id pub-id-type="pmid">20958248</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B5">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name><surname>Brown</surname><given-names>C.T.</given-names></name><etal/></person-group> (<year>2012</year>) <comment>A reference-free algorithm for computational normalization of shotgun sequencing data. arXiv:1203.4802.</comment></mixed-citation>
    </ref>
    <ref id="btv226-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Campbell</surname><given-names>P.J.</given-names></name><etal/></person-group> (<year>2008</year>) 
<article-title>Subclonal phylogenetic structures in cancer revealed by ultra-deep sequencing</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>105</volume>, <fpage>13081</fpage>–<lpage>13086</lpage>.<pub-id pub-id-type="pmid">18723673</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B7">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Hui</surname><given-names>L.</given-names></name></person-group> (<year>1992</year>) 
<article-title>Color set size problem with applications to string matching</article-title>. In: <person-group person-group-type="editor"><name><surname>Apostolico</surname><given-names>A.</given-names></name><etal/></person-group> (eds.), <source>Combinatorial Pattern Matching</source>. 
<publisher-name>Springer</publisher-name>, 
<publisher-loc>Berlin Heidelberg</publisher-loc>, <comment>pp. 230–243</comment>.</mixed-citation>
    </ref>
    <ref id="btv226-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Clarke</surname><given-names>J.</given-names></name><etal/></person-group> (<year>2009</year>) 
<article-title>Continuous base identification for single-molecule nanopore DNA sequencing</article-title>. <source>Nat. Nanotechnol.</source>, <volume>4</volume>, <fpage>265</fpage>–<lpage>270</lpage>.<pub-id pub-id-type="pmid">19350039</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Desai</surname><given-names>A.</given-names></name><etal/></person-group> (<year>2013</year>) 
<article-title>Identification of optimum sequencing depth especially for de novo genome assembly of small genomes using next generation sequencing data</article-title>. <source>PLoS One</source>, <volume>8</volume>, <fpage>e60204</fpage>.<pub-id pub-id-type="pmid">23593174</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Eid</surname><given-names>J.</given-names></name><etal/></person-group> (<year>2009</year>) 
<article-title>Real-time DNA sequencing from single polymerase molecules</article-title>. <source>Science</source>, <volume>323</volume>, <fpage>133</fpage>–<lpage>138</lpage>.<pub-id pub-id-type="pmid">19023044</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ekblom</surname><given-names>R.</given-names></name><etal/></person-group> (<year>2014</year>) 
<article-title>Patterns of sequencing coverage bias revealed by ultra-deep sequencing of vertebrate mitochondria</article-title>. <source>BMC Genomics</source>, <volume>15</volume>, <fpage>467</fpage>.<pub-id pub-id-type="pmid">24923674</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>English</surname><given-names>A.C.</given-names></name><etal/></person-group> (<year>2012</year>) 
<article-title>Mind the gap: upgrading genomes with Pacific Biosciences RS long-read sequencing technology</article-title>. <source>PLoS One</source>, <volume>7</volume>,<fpage>e47768</fpage>.<pub-id pub-id-type="pmid">23185243</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gurevich</surname><given-names>A.</given-names></name><etal/></person-group> (<year>2013</year>) 
<article-title>QUAST: quality assessment tool for genome assemblies</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>1072</fpage>–<lpage>1075</lpage>.<pub-id pub-id-type="pmid">23422339</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ilie</surname><given-names>L.</given-names></name><name><surname>Molnar</surname><given-names>M.</given-names></name></person-group> (<year>2013</year>) 
<article-title>RACER: rapid and accurate correction of errors in reads</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>2490</fpage>–<lpage>2493</lpage>.<pub-id pub-id-type="pmid">23853064</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B15">
      <mixed-citation publication-type="journal"><collab>International Barley Genome Sequencing Consortium. <italic>et al.</italic></collab>. (<year>2012</year>) 
<article-title>A physical, genetic and functional sequence assembly of the barley genome</article-title>. <source>Nature</source>, <volume>491</volume>, <fpage>711</fpage>–<lpage>716</lpage>.<pub-id pub-id-type="pmid">23075845</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H.</given-names></name><name><surname>Durbin</surname><given-names>R.</given-names></name></person-group> (<year>2009</year>) 
<article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>1754</fpage>–<lpage>1760</lpage>.<pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B17">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name><surname>Lonardi</surname><given-names>S.</given-names></name><etal/></person-group> (<year>2015</year>) <comment>When less is more: “slicing” sequencing data improves read decoding accuracy and de novo assembly quality. <italic>Bioinformatics</italic>, doi: 10.1093/bioinformatics/btv311 (in press)</comment>.</mixed-citation>
    </ref>
    <ref id="btv226-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>McCorrison</surname><given-names>J.M.</given-names></name><etal/></person-group> (<year>2014</year>) 
<article-title>NeatFreq: reference-free data reduction and coverage normalization for <italic>de novo</italic> sequence assembly</article-title>. <source>BMC Bioinformatics</source>, <volume>15</volume>, <fpage>357</fpage>.<pub-id pub-id-type="pmid">25407910</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nijkamp</surname><given-names>J.</given-names></name><etal/></person-group> (<year>2010</year>) 
<article-title>Integrating genome assemblies with MAIA</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>i433</fpage>–<lpage>439</lpage>.<pub-id pub-id-type="pmid">20823304</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Peng</surname><given-names>Y.</given-names></name><etal/></person-group> (<year>2012</year>) 
<article-title>IDBA-UD: a <italic>de novo</italic> assembler for single-cell and metagenomic sequencing data with highly uneven depth</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>1420</fpage>–<lpage>1428</lpage>.<pub-id pub-id-type="pmid">22495754</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pop</surname><given-names>M.</given-names></name><etal/></person-group> (<year>2004</year>) 
<article-title>Hierarchical scaffolding with Bambus</article-title>. <source>Genome Res.</source>, <volume>14</volume>, <fpage>149</fpage>–<lpage>159</lpage>.<pub-id pub-id-type="pmid">14707177</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Soueidan</surname><given-names>H.</given-names></name><etal/></person-group> (<year>2013</year>) 
<article-title>Finishing bacterial genome assemblies with Mix</article-title>. <source>BMC Bioinformatics</source>, <volume>14</volume>, <fpage>S16</fpage>.<pub-id pub-id-type="pmid">24564706</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vicedomini</surname><given-names>R.</given-names></name><etal/></person-group> (<year>2013</year>) 
<article-title>GAM-NGS: genomic assemblies merger for next generation sequencing</article-title>. <source>BMC Bioinformatics</source>, <volume>14</volume>, <fpage>S6</fpage>.<pub-id pub-id-type="pmid">23815503</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Widasari</surname><given-names>D.I.</given-names></name><etal/></person-group> (<year>2014</year>) 
<article-title>A deep-sequencing method detects drug-resistant mutations in the hepatitis B virus in indonesians</article-title>. <source>Intervirology</source>, <volume>57</volume>, <fpage>384</fpage>–<lpage>392</lpage>.<pub-id pub-id-type="pmid">25382636</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>X.</given-names></name><etal/></person-group> (<year>2013</year>) 
<article-title>A survey of error-correction methods for next-generation sequencing</article-title>. <source>Brief. Bioinform.</source>, <volume>14</volume>, <fpage>56</fpage>–<lpage>66</lpage>.<pub-id pub-id-type="pmid">22492192</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zerbino</surname><given-names>D.R.</given-names></name><name><surname>Birney</surname><given-names>E.</given-names></name></person-group> (<year>2008</year>) 
<article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>. <source>Genome Res.</source>, <volume>18</volume>, <fpage>821</fpage>–<lpage>829</lpage>.<pub-id pub-id-type="pmid">18349386</pub-id></mixed-citation>
    </ref>
    <ref id="btv226-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhou</surname><given-names>W.</given-names></name><etal/></person-group> (<year>2014</year>) 
<article-title>Bias from removing read duplication in ultra-deep sequencing experiments</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>1073</fpage>–<lpage>1080</lpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
