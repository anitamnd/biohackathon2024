<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311318</article-id>
    <article-id pub-id-type="pmid">37387177</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad230</article-id>
    <article-id pub-id-type="publisher-id">btad230</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Evolutionary, Comparative and Population Genomics</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A weighted distance-based approach for deriving consensus tumor evolutionary trees</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Guang</surname>
          <given-names>Ziyun</given-names>
        </name>
        <aff><institution>Department of Computer Science, Carleton College</institution>, Northfield, MN 55057, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Smith-Erb</surname>
          <given-names>Matthew</given-names>
        </name>
        <aff><institution>Department of Computer Science, Carleton College</institution>, Northfield, MN 55057, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Oesper</surname>
          <given-names>Layla</given-names>
        </name>
        <aff><institution>Department of Computer Science, Carleton College</institution>, Northfield, MN 55057, <country country="US">USA</country></aff>
        <xref rid="btad230-cor1" ref-type="corresp"/>
        <!--loesper@carleton.edu-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad230-cor1">Corresponding author. Department of Computer Science, Carleton College, Northfield, MN 55057, USA. E-mail: <email>loesper@carleton.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i204</fpage>
    <lpage>i212</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad230.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>The acquisition of somatic mutations by a tumor can be modeled by a type of evolutionary tree. However, it is impossible to observe this tree directly. Instead, numerous algorithms have been developed to infer such a tree from different types of sequencing data. But such methods can produce conflicting trees for the same patient, making it desirable to have approaches that can combine several such tumor trees into a consensus or summary tree. We introduce The Weighted m-Tumor Tree Consensus Problem (W-<italic toggle="yes">m</italic>-TTCP) to find a consensus tree among multiple plausible tumor evolutionary histories, each assigned a confidence weight, given a specific distance measure between tumor trees. We present an algorithm called TuELiP that is based on integer linear programming which solves the W-<italic toggle="yes">m</italic>-TTCP, and unlike other existing consensus methods, allows the input trees to be weighted differently.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>On simulated data we show that TuELiP outperforms two existing methods at correctly identifying the true underlying tree used to create the simulations. We also show that the incorporation of weights can lead to more accurate tree inference. On a Triple-Negative Breast Cancer dataset, we show that including confidence weights can have important impacts on the consensus tree identified.</p>
      </sec>
      <sec id="s3">
        <title>Availability</title>
        <p>An implementation of TuELiP and simulated datasets are available at <ext-link xlink:href="https://bitbucket.org/oesperlab/consensus-ilp/src/main/" ext-link-type="uri">https://bitbucket.org/oesperlab/consensus-ilp/src/main/.</ext-link></p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>CAREER-IIS-2046011</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Large Faculty Development Endowment</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Carleton College</institution>
            <institution-id institution-id-type="DOI">10.13039/100006433</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Tumor progression has been recognized as an evolutionary process where somatic mutations accumulate (<xref rid="btad230-B20" ref-type="bibr">Nowell 1976</xref>), leading to the growth of a tumor. A tumor’s evolutionary history is the order and configuration in which these mutations arose. A better understanding of this history provides important insights into tumors’ development processes, such as the selection for variants that lead to tumor growth and tumor migration, which helps scientists develop more effective treatment plan for patients (<xref rid="btad230-B6" ref-type="bibr">Fittall and Van Loo 2019</xref>).</p>
    <p>Many computational methods have been developed to derive the evolutionary histories of tumors, typically depicting them as rooted trees where the nodes represent tumor cell populations, and the edges indicate ancestral relationships (<xref rid="btad230-B22" ref-type="bibr">Schwartz and Schäffer 2017</xref>). There has been explosive growth in the methods that infer such a tumor tree from DNA sequencing data. For example, <xref rid="btad230-B12" ref-type="bibr">Jahn et al. (2016)</xref> and <xref rid="btad230-B18" ref-type="bibr">Malikic et al. (2019b)</xref> use single-cell data, <xref rid="btad230-B17" ref-type="bibr">Malikic et al. (2019a)</xref> uses both single-cell and bulk sequencing data, and <xref rid="btad230-B19" ref-type="bibr">Myers et al. (2019)</xref> uses longitudinal data. Different methods also consider different types of mutations (e.g. SNVs, CNAs, etc.) as input. Although advancements in different algorithms and methods can produce improved inference of tumor evolutionary histories, interpretation can be challenging due to the multiple possible trees returned from these methods, even when run on data from the same patient. It would be useful to combine these sets of output trees to better infer a single evolutionary history that best represents the tumor’s evolutionary process.</p>
    <p>In recent years, several approaches have been introduced to identify a consensus tumor tree from a set of disparate input trees for a single patient. GraPhyC, first introduced in <xref rid="btad230-B10" ref-type="bibr">Govek et al. (2018)</xref> and then extended in <xref rid="btad230-B11" ref-type="bibr">Govek et al. (2020)</xref>, is a graph-theoretic approach that aims to find a consensus tree with minimal total distance from all input trees for a specified tree distance function. However, there are several limitations to this method. First, it requires a pre-clustering step to identify a set of mutation clusters before identifying a consensus tree. This means that the approach is only able to consider a single mutation clustering. Second, this method is optimized for a specific distance measure called Parent–Child (PC) distance. While this distance measure is easy to compute, it has been suggested (<xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>) that other distance measures may be more appropriate for comparing tumor evolutionary trees. <xref rid="btad230-B1" ref-type="bibr">Aguse et al. (2019)</xref> instead find multiple consensus trees, rather than a single tree. However, this approach still relies upon optimization for the PC distance as well. More recently, <xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz (2021)</xref> used a different approach to the consensus tree problem which instead aims to find a tree that maximizes directed partition support from the input trees. This approach does consider different mutation clusterings, unlike GraPhyC and the method from <xref rid="btad230-B1" ref-type="bibr">Aguse et al. (2019)</xref>, but its implementation only allows it to operate on trees which have nodes containing four or fewer children. Consensus approaches have also recently be used to detect evolutionary patterns across patients (<xref rid="btad230-B3" ref-type="bibr">Christensen et al. 2020</xref>).</p>
    <p>One major downside to all existing tumor tree consensus methods is that they consider all input trees as equally informative. However, tumor evolution inference methods have been evolving quickly and make different assumptions or use varying techniques (<xref rid="btad230-B22" ref-type="bibr">Schwartz and Schäffer, 2017</xref>). Furthermore, there have been more studies where multiple types of sequencing data are available for a single patient (e.g. <xref rid="btad230-B8" ref-type="bibr">Gawad et al. 2014</xref>; <xref rid="btad230-B16" ref-type="bibr">Leung et al. 2017</xref>; and others). These studies can contain bulk, single-cell, and even longitudinal sequencing data, making features like the depth and quality of these different datasets even more important to consider when constructing consensus trees from them. For example, more weight could be given to trees constructed using the higher coverage data.</p>
    <p>Here, we introduce an integer linear programming (ILP) based method to solve the consensus tree problem, but that allows for the input trees to have confidence weights. We name our method TuELiP (<bold>Tu</bold>mor <bold>E</bold>volution integer <bold>Li</bold>near <bold>P</bold>rogram). Specifically, we pose the Weighted <italic toggle="yes">m</italic>-Tumor Tree Consensus Problem (W-<italic toggle="yes">m</italic>-TTCP), which given (i) a set of input tumor trees, (ii) weights for each tree; and (iii) a tumor tree distance measure, finds a consensus tree that minimizes the total weighted distance from it to all input trees. In contrast to other existing distance-based consensus methods, our approach allows all clusterings of mutations to be considered when identifying a consensus tree, and optimizes for a more complex distance measure [Ancestor–Descendant (AD) distance]. To our knowledge, TuELiP is the first tumor consensus tree approach to allow for the input trees to be weighted differently. We validate our approach on both simulated and a Triple-Negative Breast Cancer (TNBC) dataset and show that our method outperforms two competing methods. On the real data, we show that including confidence weights can have important impacts on the consensus tree identified.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Problem formalization</title>
      <p>Let <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be a set of <italic toggle="yes">m</italic> mutations. A tumor that has acquired <italic toggle="yes">m</italic> mutations during its evolution, can be described using the following definition. An <italic toggle="yes">m-tumor tree</italic> is a directed rooted tree <italic toggle="yes">T</italic> where: (i) each node in the tree is labeled by one or more mutations from the mutation set <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>; and (ii) the collection of mutation labels over all nodes form a partition of the mutation set <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, which we call a “mutation clustering.” The nodes in <italic toggle="yes">m</italic>-tumor trees correspond to clones in a heterogeneous tumor where its cell population contains a unique set of somatic mutations. The direction of the edges indicate that a child clone originated from the cells of a parent clone. Thus, node labels represent the new mutations acquired by the clone which distinguish it from its parent, and are also the mutations that will be inherited by its descendants. It will also be useful to refer to the space of all <italic toggle="yes">m</italic>-tumor trees. Therefore, we define <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to be the set of all <italic toggle="yes">m</italic>-tumor trees. Finally, we also define <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to be the cluster of mutations labeling node <italic toggle="yes">v</italic>.</p>
      <p>A recent problem of interest in the computational cancer field has been how to identify a consensus, or summary tree, from a set of conflicting, but similar tumor trees. Two general approaches to this problem have been proposed: (i) distance based methods (<xref rid="btad230-B11" ref-type="bibr">Govek et al. 2020</xref>, <xref rid="btad230-B10" ref-type="bibr">2018</xref>); and (ii) partition based methods (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>). However, both types of approaches treat all input trees equally, and often restrict the trees considered to a subset of all possible <italic toggle="yes">m</italic> tumor trees. Our approach builds upon the distance-based methods, but allows for the input trees to be weighted rather than treated equally, and considers the entire space of <italic toggle="yes">m</italic> tumor trees <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We introduce the following problem.</p>
      <p><bold>The Weighted <italic toggle="yes">m</italic>-Tumor Tree Consensus Problem (W-<italic toggle="yes">m</italic>-TTCP)</bold>: Given a set <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">m</italic>-tumor trees, an <italic toggle="yes">m</italic>-tumor tree distance measure <italic toggle="yes">dist</italic>(.,.), and a tree weighting function <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo>:</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>→</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, find a consensus tree <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> such that
</p>
      <disp-formula id="E1">
        <label>(1)</label>
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msup>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mo>*</mml:mo>
            </mml:msup>
            <mml:mo>=</mml:mo>
            <mml:munder>
              <mml:mrow>
                <mml:mtext>arg</mml:mtext>
                <mml:mo> </mml:mo>
                <mml:mtext>min</mml:mtext>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>T</mml:mi>
                <mml:mo>∈</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="script">T</mml:mi>
                  </mml:mrow>
                  <mml:mi>m</mml:mi>
                </mml:msub>
              </mml:mrow>
            </mml:munder>
            <mml:munderover>
              <mml:mo>∑</mml:mo>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mi>n</mml:mi>
            </mml:munderover>
            <mml:mi>w</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>·</mml:mo>
            <mml:mi mathvariant="italic">dist</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>T</mml:mi>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
          </mml:mrow>
          <mml:mo>.</mml:mo>
        </mml:math>
      </disp-formula>
      <p>We note that this formalization can easily be extended to find <italic toggle="yes">k</italic> consensus trees, as is done by <xref rid="btad230-B1" ref-type="bibr">Aguse et al. (2019)</xref>. Our implementation of TuELiP also allows for the finding of all consensus trees that minimize the objective function.</p>
    </sec>
    <sec>
      <title>2.2 Distance measures</title>
      <p>Distance-based consensus methods require the use of a distance measure that considers how similar two input trees are, with lower values for more similar trees and higher values for more dissimilar trees. Previous distance-based consensus methods focused on one distance measure called PC distance (<xref rid="btad230-B11" ref-type="bibr">Govek et al. 2020</xref>). This distance measure counts the number of unique PC mutation relationships that appear in one tree but not the other. This distance measure has been used in previous consensus approaches mainly due to how easy it is to compute. However, it has been shown that other distance measures, in particular, those that consider not just parental but also longer range ancestral relationships may be more accurate (<xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>). One reason for this is that ancestral mutations are inherited by all of their descendants, not just their children. Therefore, we will focus on using a distance measure called AD distance originally proposed by <xref rid="btad230-B11" ref-type="bibr">Govek et al. (2020)</xref> and described below.</p>
      <p>For an <italic toggle="yes">m</italic>-tumor tree <italic toggle="yes">T</italic>, and distinct mutations <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic>, we say <italic toggle="yes">i</italic> is ancestral to <italic toggle="yes">j</italic> if <italic toggle="yes">i</italic> labels a node which is on the path from the root to the node labeled by <italic toggle="yes">j</italic>. When <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic> label the same node, they are considered ancestral to each other since their exact ordering is unknown. Additionally, if <italic toggle="yes">i</italic> is ancestral to <italic toggle="yes">j</italic>, we say that (<italic toggle="yes">i</italic>, <italic toggle="yes">j</italic>) is an “Ancestor-Descendant pair.” Given the <italic toggle="yes">m</italic>-tumor tree <italic toggle="yes">T</italic>, we define <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">i</italic> is ancestral to <italic toggle="yes">j</italic> in <italic toggle="yes">T</italic><inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> to be the set of all AD pairs in <italic toggle="yes">T</italic>. Given two <italic toggle="yes">m</italic>-tumor trees <italic toggle="yes">T</italic><sub>1</sub> and <italic toggle="yes">T</italic><sub>2</sub>, the AD distance between them is the number of AD pairs in one tree but not the other. Formally, the “Ancestor-Descendant (AD) distance measure” is defined as:
</p>
      <disp-formula id="E2">
        <label>(2)</label>
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>A</mml:mi>
            <mml:mi>D</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ϕ</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>A</mml:mi>
                <mml:mi>D</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>∖</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ϕ</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>A</mml:mi>
                <mml:mi>D</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo>+</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ϕ</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>A</mml:mi>
                <mml:mi>D</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>∖</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ϕ</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>A</mml:mi>
                <mml:mi>D</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
    </sec>
    <sec>
      <title>2.3 Our method</title>
      <p>We take a two-step approach to solving the W-<italic toggle="yes">m</italic>-TTCP when the distance measure is AD distance. (i) We first use an ILP to find a directed acyclic graph (DAG) whose nodes are labeled with mutations and whose edges represent all ancestral relationships between those mutations. We will show that this graph represents the transitive closure of the desired consensus tree. (ii) We then turn the resulting DAG into a directed tree through a transitive reduction. This is our consensus tree. <xref rid="btad230-F1" ref-type="fig">Figure 1</xref> shows an overview of our approach. In contrast to the existing methods (<xref rid="btad230-B11" ref-type="bibr">Govek et al., 2020</xref>; <xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz, 2021</xref>), our approach considers all possible mutation clusterings (i.e. assignment of mutation labels to nodes), rather than restricting to a single mutation clustering, and utilizes a confidence weight assigned to each input tree when constructing the consensus tree.</p>
      <fig position="float" id="btad230-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Overview of the TuELiP method. Consensus tree is found as a transitive reduction on ILP output graph, which has edges between nodes that are ancestral to each other in the final tumor tree.</p>
        </caption>
        <graphic xlink:href="btad230f1" position="float"/>
      </fig>
      <sec>
        <title>2.3.1 ILP variables and constraints</title>
        <p>We start by introducing two sets of variables that model the ancestral relationships in our solution. For every pair of unique mutations <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>≠</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>, we introduce a variable <italic toggle="yes">x<sub>ab</sub></italic> where <italic toggle="yes">x<sub>ab</sub></italic> = 1 if mutation <italic toggle="yes">a</italic> is ancestral to mutation <italic toggle="yes">b</italic>, and <italic toggle="yes">x<sub>ab</sub></italic> = 0 if <italic toggle="yes">a</italic> is not ancestral to <italic toggle="yes">b</italic>. In the case if <italic toggle="yes">a</italic> and <italic toggle="yes">b</italic> label the same node, both <italic toggle="yes">x<sub>ab</sub></italic> = 1 and <italic toggle="yes">x<sub>ba</sub></italic> = 1. For each mutation <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> we also introduce a variable <italic toggle="yes">r<sub>a</sub></italic> where <italic toggle="yes">r<sub>a</sub></italic> = 1 if mutation <italic toggle="yes">a</italic> labels the root of our consensus tree and <italic toggle="yes">r<sub>a</sub></italic> = 0 otherwise. For a root with multiple labels, the corresponding set of variables are all set to 1. <xref rid="btad230-F2" ref-type="fig">Figure 2</xref> shows a small example of how these variables would be set for a specific <italic toggle="yes">m</italic>-tumor tree.</p>
        <fig position="float" id="btad230-F2">
          <label>Figure 2.</label>
          <caption>
            <p>A small example on how the variables used in our ILP formulation might be set for a particular tree (<italic toggle="yes">x<sub>ij</sub></italic> denoting ancestral relationship between mutations <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic> and <italic toggle="yes">r<sub>i</sub></italic> denoting whether mutation <italic toggle="yes">i</italic> labels the root). For example, since mutation B is ancestral to mutation C in the tree on the left, the variable <italic toggle="yes">x<sub>BC</sub></italic> is set to 1.</p>
          </caption>
          <graphic xlink:href="btad230f2" position="float"/>
        </fig>
        <p>To ensure that these variables are set in a way that yields a configuration consistent with the transitive closure of a valid <italic toggle="yes">m</italic>-tumor tree, we introduce the following linear constraints.
</p>
        <disp-formula id="E3">
          <label>(3)</label>
          <mml:math id="M3" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mi>c</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>≥</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>+</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>c</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>−</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo> </mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
              <mml:mo>,</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>a</mml:mi>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E4">
          <label>(4)</label>
          <mml:math id="M4" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>+</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>a</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>≥</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mi>c</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>+</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>c</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>−</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
              <mml:mo>,</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>a</mml:mi>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E5">
          <label>(5)</label>
          <mml:math id="M5" display="block" overflow="scroll">
            <mml:mrow>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mi>m</mml:mi>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>r</mml:mi>
                  </mml:mrow>
                  <mml:mi>a</mml:mi>
                </mml:msub>
              </mml:mrow>
              <mml:mo>≥</mml:mo>
              <mml:mn>1</mml:mn>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E6">
          <label>(6)</label>
          <mml:math id="M6" display="block" overflow="scroll">
            <mml:mrow>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mi>m</mml:mi>
                  <mml:mo stretchy="false">]</mml:mo>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo>≠</mml:mo>
                  <mml:mi>a</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>a</mml:mi>
                    <mml:mi>b</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mo>·</mml:mo>
              <mml:mfrac>
                <mml:mn>1</mml:mn>
                <mml:mrow>
                  <mml:mi>m</mml:mi>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo>≥</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>r</mml:mi>
                </mml:mrow>
                <mml:mi>a</mml:mi>
              </mml:msub>
              <mml:mo> </mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E7">
          <label>(7)</label>
          <mml:math id="M7" display="block" overflow="scroll">
            <mml:mrow>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mi>m</mml:mi>
                  <mml:mo stretchy="false">]</mml:mo>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo>≠</mml:mo>
                  <mml:mi>a</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>a</mml:mi>
                    <mml:mi>b</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mo>−</mml:mo>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo>−</mml:mo>
              <mml:mn>2</mml:mn>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>≤</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>r</mml:mi>
                </mml:mrow>
                <mml:mi>a</mml:mi>
              </mml:msub>
              <mml:mo> </mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E8">
          <label>(8)</label>
          <mml:math id="M8" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>∈</mml:mo>
              <mml:mo>{</mml:mo>
              <mml:mn>0</mml:mn>
              <mml:mo>,</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>}</mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
              <mml:mo>,</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>b</mml:mi>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E9">
          <label>(9)</label>
          <mml:math id="M9" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>r</mml:mi>
                </mml:mrow>
                <mml:mi>a</mml:mi>
              </mml:msub>
              <mml:mo>∈</mml:mo>
              <mml:mo>{</mml:mo>
              <mml:mn>0</mml:mn>
              <mml:mo>,</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>}</mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <p>We need to ensure that the ancestral relations output by TuELiP are transitive. That is, if mutation <italic toggle="yes">a</italic> is ancestral to mutation <italic toggle="yes">b</italic> and mutation <italic toggle="yes">b</italic> is ancestral to mutation <italic toggle="yes">c</italic> then we need to enforce that mutation <italic toggle="yes">a</italic> is ancestral to mutation <italic toggle="yes">c</italic>. This is accomplished with constraint (3). Furthermore, we need to ensure that if mutations <italic toggle="yes">a</italic> and <italic toggle="yes">b</italic> are both ancestral to <italic toggle="yes">c</italic>, then either <italic toggle="yes">a</italic> is ancestral to <italic toggle="yes">b</italic> or <italic toggle="yes">b</italic> is ancestral to <italic toggle="yes">a</italic>, or <italic toggle="yes">a</italic> and <italic toggle="yes">b</italic> are in the same node. This keeps all ancestral mutations on a single lineage path. Accordingly, constraint (4) ensures that if both <italic toggle="yes">x<sub>ac</sub></italic> and <italic toggle="yes">x<sub>bc</sub></italic> are 1, then at least one of <italic toggle="yes">x<sub>ab</sub></italic> and <italic toggle="yes">x<sub>ba</sub></italic> is also set to 1.</p>
        <p>We also need constraints that ensure that the output from TuELiP is a connected DAG with a single root node. Constraint (5) ensures that there is at least one mutation in the root. To ensure the resulting graph is connected, constraint (6) requires that all mutations labeling the root are ancestral to all other <italic toggle="yes">m −</italic> 1 mutations (this includes any other mutations that also label the root). Similarly, constraint (7) ensures that any mutation that does not label the root must be ancestral to fewer than <italic toggle="yes">m −</italic> 1 mutations. Additional explanation of these constraints is provided in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>.</p>
      </sec>
      <sec>
        <title>2.3.2 ILP objective function</title>
        <p>Recall we want to find the setting of TuELiP variables subject to our constraints that minimizes the total weighted AD distance from the set of input trees <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> to the resulting tree <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> (whose transitive closure the ILP returns). To formulate this objective function using our variables, we introduce the function <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mo>δ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which is 1 if mutation <italic toggle="yes">a</italic> is ancestral to mutation <italic toggle="yes">b</italic> in tree <italic toggle="yes">T</italic>, and 0 if <italic toggle="yes">a</italic> is not ancestral to mutation <italic toggle="yes">b</italic> in tree <italic toggle="yes">T</italic>. We show below how to formulate our desired objective function we wish to minimize.
</p>
        <disp-formula id="E10">
          <mml:math id="M10" display="block" overflow="scroll">
            <mml:mtable columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:mo> </mml:mo>
                  <mml:mi>w</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>·</mml:mo>
                  <mml:mi>A</mml:mi>
                  <mml:mi>D</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:mo> </mml:mo>
                  <mml:mi>w</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>·</mml:mo>
                  <mml:mrow>
                    <mml:mo>[</mml:mo>
                    <mml:mrow>
                      <mml:mo>|</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>ϕ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>A</mml:mi>
                          <mml:mi>D</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>T</mml:mi>
                        </mml:mrow>
                        <mml:mo>*</mml:mo>
                      </mml:msup>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>∖</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>ϕ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>A</mml:mi>
                          <mml:mi>D</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>T</mml:mi>
                        </mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo>+</mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>ϕ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>A</mml:mi>
                          <mml:mi>D</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>T</mml:mi>
                        </mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>∖</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>ϕ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>A</mml:mi>
                          <mml:mi>D</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>T</mml:mi>
                        </mml:mrow>
                        <mml:mo>*</mml:mo>
                      </mml:msup>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                    <mml:mo>]</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:mo> </mml:mo>
                  <mml:mi>w</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>b</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mi>m</mml:mi>
                      <mml:mo stretchy="false">]</mml:mo>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>x</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                        <mml:mi>b</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>−</mml:mo>
                  <mml:mo>δ</mml:mo>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:mi>a</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>+</mml:mo>
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>b</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mi>m</mml:mi>
                      <mml:mo stretchy="false">]</mml:mo>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>−</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>x</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                        <mml:mi>b</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>δ</mml:mo>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:mi>a</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:mo> </mml:mo>
                  <mml:mi>w</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>b</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mi>m</mml:mi>
                      <mml:mo stretchy="false">]</mml:mo>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo>[</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>x</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>a</mml:mi>
                            <mml:mi>b</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:mo>δ</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>T</mml:mi>
                          </mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>+</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>x</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>a</mml:mi>
                            <mml:mi>b</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>δ</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>T</mml:mi>
                          </mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mo>]</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:mo> </mml:mo>
                  <mml:mi>w</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>b</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mi>m</mml:mi>
                      <mml:mo stretchy="false">]</mml:mo>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo>[</mml:mo>
                      <mml:mrow>
                        <mml:mo>δ</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>T</mml:mi>
                          </mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>+</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>x</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>a</mml:mi>
                            <mml:mi>b</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:mn>2</mml:mn>
                        <mml:mo>δ</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>T</mml:mi>
                          </mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mo>]</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>We note this objective function has a very natural interpretation. If the output tree does not have <italic toggle="yes">a</italic> ancestral to <italic toggle="yes">b</italic> given by the assignment of <italic toggle="yes">x<sub>ab</sub></italic> = 0, but in a input tree <italic toggle="yes">T<sub>k</sub></italic>, <italic toggle="yes">a</italic> is ancestral to <italic toggle="yes">b</italic>, then the objective function helps to add a penalization of <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to the objective. Conversely, if the output tree has <italic toggle="yes">a</italic> being ancestral to <italic toggle="yes">b</italic> given by <italic toggle="yes">x<sub>ab</sub></italic> = 1, but in the input tree <italic toggle="yes">T<sub>j</sub> a</italic> is not ancestral to <italic toggle="yes">b</italic>, then <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mo>δ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and a penalization of <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> will be added to the objective.</p>
      </sec>
      <sec>
        <title>2.3.3 Transitive reduction from ILP solution</title>
        <p>The final step for our approach is to convert the output from the ILP into an <italic toggle="yes">m</italic>-tumor tree. Specifically, we construct a DAG <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from the ancestral relationships indicated by the <italic toggle="yes">x<sub>ab</sub></italic> variables and then create the <italic toggle="yes">m</italic>-tumor tree <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> from <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> by finding its transitive reduction. Creation of <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is straightforward. If <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, then <italic toggle="yes">a</italic> and <italic toggle="yes">b</italic> label the same node in <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. There is an edge from node <italic toggle="yes">v</italic> to node <italic toggle="yes">w</italic> if any mutation in <italic toggle="yes">l</italic>(<italic toggle="yes">v</italic>) is ancestral to any mutation in <italic toggle="yes">l</italic>(<italic toggle="yes">w</italic>). Because of the enforced transitive property of ancestral relationships [constraints (3) and (4)], it is sufficient to only consider a single mutation in a node when constructing edges. Formally, <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mtext>where</mml:mtext><mml:mo> </mml:mo><mml:mi>v</mml:mi><mml:mo>≠</mml:mo><mml:mi>w</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Finally, we perform a transitive reduction of <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> (<xref rid="btad230-B2" ref-type="bibr">Aho et al. 1972</xref>). We then show that the output of the transitive reduction is guaranteed to be an arborscence and is the returned consensus tree.</p>
      </sec>
    </sec>
    <sec>
      <title>2.4 Solving the <italic toggle="yes">W</italic>-<italic toggle="yes">m</italic>-TTCP</title>
      <p>In order to show the efficacy of our approach to solving the <italic toggle="yes">W</italic>-<italic toggle="yes">m</italic>-TTCP when the distance measure is AD distance, we need to show that the output of our ILP, after a transitive reduction, is guaranteed to be an arborescence. An “arborescence” is a directed graph that contains a node called the root and that has a directed path from the root to all other nodes. First we make two observations (full proofs are provided in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>) that will be useful in showing that the output of our method fits this definition.<statement id="mthst1"><label>Observation 1.</label><p><italic toggle="yes">The graph</italic> <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">produced by our ILP is acyclic.</italic></p></statement></p>
      <p>For a directed acyclic graph <italic toggle="yes">G</italic> with <italic toggle="yes">n</italic> nodes, there is a construction that finds a transitive reduction of <italic toggle="yes">G</italic> in <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, denoted <italic toggle="yes">G<sup>t</sup></italic>, which is unique and defined as having the following two conditions (<xref rid="btad230-B2" ref-type="bibr">Aho et al. 1972</xref>).</p>
      <list list-type="roman-lower">
        <list-item>
          <p>There is a directed path from node <italic toggle="yes">u</italic> to node <italic toggle="yes">v</italic> in <italic toggle="yes">G<sup>t</sup></italic> if and only if there is a directed path from <italic toggle="yes">u</italic> to <italic toggle="yes">v</italic> in <italic toggle="yes">G</italic>.</p>
        </list-item>
        <list-item>
          <p>There is no graph with fewer edges than <italic toggle="yes">G<sup>t</sup></italic> satisfying condition (i).</p>
        </list-item>
      </list>
      <statement id="mthst2">
        <label>Observation 2.</label>
        <p><italic toggle="yes">The transitive reduction of</italic> <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula><italic toggle="yes">, denoted as</italic> <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula><italic toggle="yes">, is acyclic.</italic></p>
      </statement>
      <p>We can now prove the following theorem about the output of our method.<statement id="mthst3"><label>Theorem 1.</label><p><inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula><italic toggle="yes">is an arborescence.</italic></p></statement></p>
      <p><italic toggle="yes">Proof.</italic> To prove <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is an arborescence, we must show that for a node <italic toggle="yes">u</italic>, called the root, there exists one path from <italic toggle="yes">u</italic> to any other node <italic toggle="yes">v</italic> (<xref rid="btad230-B9" ref-type="bibr">Gordon and McMahon 1989</xref>). We let <italic toggle="yes">u</italic> be the node that contains mutations that are ancestral to all other mutations. The existence of such a node is guaranteed by our constraints and can be identified using the <italic toggle="yes">r<sub>a</sub></italic> variables from the ILP. Thus, there are paths from <italic toggle="yes">u</italic> to any other node <italic toggle="yes">v</italic> in <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, which implies there exists a path from <italic toggle="yes">u</italic> to any other node <italic toggle="yes">v</italic> in <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> per condition (i) above. Now, we need that there cannot exist more than one path from <italic toggle="yes">u</italic> to any node <italic toggle="yes">v</italic>.</p>
      <p>Assume that there do exist multiple paths from <italic toggle="yes">u</italic> to <italic toggle="yes">v</italic>. Also since <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is acyclic (by Observation 2), there must exist a node on a path from <italic toggle="yes">u</italic> to <italic toggle="yes">v</italic>, say <italic toggle="yes">w</italic> (which may be <italic toggle="yes">v</italic>) that has more than one parent. Let <italic toggle="yes">y</italic> and <italic toggle="yes">z</italic> be two arbitrary and distinct parents of <italic toggle="yes">w</italic>. Then, let <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. By constraint (4), <italic toggle="yes">a</italic> is ancestral to <italic toggle="yes">b</italic> or <italic toggle="yes">b</italic> is ancestral to <italic toggle="yes">a</italic>, which implies that in <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. Without loss of generality, say that <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, and so there must exist a path from <italic toggle="yes">y</italic> to <italic toggle="yes">z</italic> in <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. So, there exist distinct paths from <italic toggle="yes">u</italic> to <italic toggle="yes">v</italic>, one that contains the edge (<italic toggle="yes">y</italic>, <italic toggle="yes">w</italic>), and one that contains the edge (<italic toggle="yes">z</italic>, <italic toggle="yes">w</italic>). By removing the edge (<italic toggle="yes">y</italic>, <italic toggle="yes">w</italic>) from <italic toggle="yes">G<sup>t</sup></italic>, there still exists a path from <italic toggle="yes">u</italic> to <italic toggle="yes">y</italic>, <italic toggle="yes">z</italic>, <italic toggle="yes">w</italic>, and <italic toggle="yes">v</italic>, namely the path that went from <italic toggle="yes">u</italic> to <italic toggle="yes">y</italic>, to the edge (<italic toggle="yes">z</italic>, <italic toggle="yes">w</italic>), to <italic toggle="yes">x</italic>. Therefore, we have constructed a graph with fewer edges than <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> that still follows property (i) of being a transitive reduction. This contradicts property (ii) that <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is the transitive reduction of <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
      <p>Thus, for any node <italic toggle="yes">v</italic> in <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, there is exactly one path from the root <italic toggle="yes">u</italic> to <italic toggle="yes">v</italic>. This implies that <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is an arborescence. □</p>
      <p>We have shown that the output of our method is an arboresence, a type of directed tree, and is therefore a valid <italic toggle="yes">m</italic>-tumor tree. Furthermore, we have shown that this tree minimizes the total AD distance to the set of input trees.</p>
    </sec>
    <sec>
      <title>2.5 Different mutation sets</title>
      <p>We have also modified our approach to work with input trees that contain different sets of mutations. In short, mutations are only present in the consensus tree if they occur in more than half of all the input trees. For more details, see the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We implemented TuELiP in Python 3.7.1 and use the MIP library v1.13.0 (<xref rid="btad230-B21" ref-type="bibr">Santos and Toffolo 2020</xref>). We test the application of our method on both simulated and real data.</p>
    <sec>
      <title>3.1 Simulated data</title>
      <p>First, we describe our approach for simulated data creation. Second, we assess TuELiP’s ability to solve the W-<italic toggle="yes">m</italic>-TTCP problem. Third, we compare how well TuELiP does against other consensus models at uncovering the true simulated tree of a patient. Finally, we analyze the effects of using different weighting schemes on the input trees.</p>
      <sec>
        <title>3.1.1 Dataset creation</title>
        <p>We simulate sets of input trees with a method similar to (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>). We create 6 datasets, each composed of 100 trials over all combinations of 5 or 10 input trees and 10, 20, or 30 mutations per tree. For each trial, we generate a ground truth tree with three steps: (i) randomly cluster mutations such that the expected number of clusters/nodes is <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="true">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, (ii) randomly assign parental relationships to each cluster such that all clusters have three or fewer children, (iii) assign mutation frequencies to each cluster while adhering to the sum rule (a cluster’s frequency must be greater than or equal to the sum of its children’s frequencies) (<xref rid="btad230-B14" ref-type="bibr">Jiao et al. 2014</xref>). We create each input tree for the given trial with the following modifications to the ground truth tree. Each modification is applied with the given probability during a traversal of all nodes in the tree, as long as the sum rule is still followed: (i) move the subtree rooted at each node with a probability of 1/3 to a grandparent or sibling node (ii), collapse edges between nodes with a probability inversely related to the closeness in mutation frequencies between the two nodes, (iii) randomly expand multi-labeled nodes with a constant probability of 1/3 into a new parental node and a child node. During the input tree generation process, we also ensure that no tree has a branching factor exceeding four, which allows us to run the consensus method ConTreeDP (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>) on the simulated trees. For full details, see the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>.</p>
      </sec>
      <sec>
        <title>3.1.2 Ability to solve W-m-TTCP</title>
        <p>We evaluated the efficacy of TuELiP at solving the W-<italic toggle="yes">m</italic>-TTCP compared to GraPhyC’s approach (<xref rid="btad230-B11" ref-type="bibr">Govek et al. 2020</xref>). We do not evaluate ConTreeDP in this scenario because its output is not a median tree, that is, it is not trying to minimize the total distance to the input trees. Instead, ConTreeDP creates an output tree that maximizes directed partition support from the input trees (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>), and this formulation does not yet have a corresponding tumor tree distance. For this experiment, we run both our method and GraPhyC on all six simulated datasets and calculate the total distance from each method’s consensus trees to all input trees for each trial using PC distance (which GraPhyC optimizes for), AD distance (which TuELiP optimizes for), as well as two other tumor evolution tree distances: CASet and DISC (<xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>).</p>
        <p>Since GraPhyC does not consider weights for input trees, we weigh all trees equally in this experiment so we can make fair comparisons. For each trial and distance measure, we calculate the percent change of the total distance between GraPhyC and TuELiP, in order to show the differences in outputs of these two methods directly. We define the percent change from GraPhyC as the difference of TuELiP’s total distance to the input trees and GraPhyC’s total distance, all divided by GraPhyC’s total distance to the input trees. Thus, 0% indicates their consensus trees were equally close to the input trees, a −50% change would indicate TuELiP’s consensus tree had a total distance to the input trees that is 50% less than the distance from the output of GraPhyC to the input trees, and a 50% change indicates that TuELiP’s tree had a total distance to the input trees that was 50% greater than the output of GraPhyC. <xref rid="btad230-F3" ref-type="fig">Figure 3</xref> shows our results for PC and AD distances. The results for CASet and DISC are similar to AD and are included in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>.</p>
        <fig position="float" id="btad230-F3">
          <label>Figure 3.</label>
          <caption>
            <p>A boxplot showing how well our approach solves the W-<italic toggle="yes">m</italic>-TTCP problem for PC distance, AD distance in terms of percent change from the output found by GraPhyC. A negative value indicates that our consensus tree is closer to the input trees than GraPhyC’s consensus tree.</p>
          </caption>
          <graphic xlink:href="btad230f3" position="float"/>
        </fig>
        <p>We see that our approach always returns a solution closer to, or equal to, all input trees in terms of AD distance (negative percent changes), while GraphyC usually (85% of trials) outperforms or ties with regards to PC distance. It is not surprising that TuELiP outperforms GraPhyC when considering AD distance, as our method is designed to optimize for that distance measure. However, it is notable that we still perform better than GraPhyC in some situations when considering PC distance, which GraPhyC is optimized for. Our method also has a smaller AD percent change when there are 10 input trees versus 5 input trees. We see similar trends to AD when using CASet and DISC to measure percent change. Specifically, TuELiP outperforms or ties GraPhyC in 94% trials when using CASet and in 91% trials when using DISC. Thus, TuELiP performs well under a variety of distance measures.</p>
      </sec>
      <sec>
        <title>3.1.3 Ability to uncover the true tree</title>
        <p>To demonstrate TuELiP’s ability to uncover the true tree used to create each simulation, we compare its performance to two other consensus methods: GraPhyC (<xref rid="btad230-B11" ref-type="bibr">Govek et al. 2020</xref>) and ConTreeDP (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>). Since neither of these methods have the ability to consider weights for the input trees, we set the weights for our method to be equal for all trees.</p>
        <p>We ran all three models on the 600 simulated trials and counted the number of trials in which they returned the exact ground truth tree. <xref rid="btad230-F4" ref-type="fig">Figure 4</xref> shows that TuELiP uncovers more trees than the other methods for 5 input trees. However, for 10 input trees, TuELiP only uncovers more trees than GraPhyC for 10 and 20 mutations, and uncovers slightly fewer trees for 30 mutations (25% of true trees uncovered for GraPhyC and 22% for TuELiP).</p>
        <fig position="float" id="btad230-F4">
          <label>Figure 4.</label>
          <caption>
            <p>The results of counting the proportion of trials in which each method returned the exact true tree.</p>
          </caption>
          <graphic xlink:href="btad230f4" position="float"/>
        </fig>
        <p>On all simulations for all models we also calculate the distance from their found consensus tree to the ground truth tree. This allows for a more nuanced analysis of how well the methods perform. We use three different distance measures in this evaluation: (i) AD distance; (ii) CASet distance (<xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>); and (iii) DISC distance (<xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>). Unlike previous sections, we did not use PC distance here because the distance measure was only used to compare to GraPhyC and does not represent longer range ancestral relationships within tumor trees. <xref rid="btad230-B5" ref-type="bibr">DiNardo et al. (2019)</xref> also showed that PC distance has limited uses when comparing tumor trees.</p>
        <p>For trials with 5 input trees, the median distance from our TuELiP’s consensus tree to the ground truth tree was lower than the median distances of both ConTreeDP and GraPhyC across all three distance metrics for 10, 20, and 30 mutations in each tree. Restricting to the 300 trials with 5 input trees, TuELiP found a tree that was closer to the ground truth tree than the tree found by ConTreeDP in around 220 trials using AD, CASet, and DISC. For the same 300 trials with 5 input trees, TuELiP found a tree closer to the true tree than the output of GraPhyC in around 160 trials with the three distance metrics. When there were 10 input trees, TuELiP consistently outperformed ConTreeDP by outputting trees closer to the true tree in at least 244 trials using the three distances, and TuELiP outperformed GraPhyC in at least 100 trials. In the trials with 10 input trees, there were many more ties between TuELiP and GraPhyC in comparison to the trials with 5 input trees. There were 48 more ties in the trials with 10 trees versus 5 trees using AD, 47 more ties using CASet, and 47 more ties using DISC.</p>
        <p>We observe that while GraPhyC identifies more consensus trees correctly than TuELiP when there are 10 input trees, each with 30 mutations (<xref rid="btad230-F3" ref-type="fig">Fig. 3</xref>), it has a higher mean distance to the true tree (11.09 using AD) than TuELiP (4.94 using AD) in these same trials (<xref rid="btad230-F5" ref-type="fig">Fig. 5</xref>). This means that while GraPhyC is able to find the correct tree slightly more of the time for this particular dataset, when it gets it wrong, it is significantly more different from the correct tree than that inferred by TuELiP.</p>
        <fig position="float" id="btad230-F5">
          <label>Figure 5.</label>
          <caption>
            <p>Results showing how well ConTreeDP, GraPhyC, and TuELiP uncover the true tumor trees for our simulated data. We measure the distances between the consensus trees and true trees using AD, CASet, and DISC.</p>
          </caption>
          <graphic xlink:href="btad230f5" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.1.4 Impact of input tree weighting</title>
        <p>Our model allows a user to weight the input trees based on their level of confidence in each. Existing methods ConTreeDP or GraPhyC do not have this capability, so in our previous experiments we weighted all trees equally in order to be able to compare to these methods. In this section, we show how our method performs under different weighting schemes and show that this feature allows us to find improved consensus trees.</p>
        <p>To test the effect of different weights on input trees, we try various weighting schemes and compare our distances to the true tree used to create the simulation. For each trial in our simulated data, we rank the input trees in ascending order of AD distance to the true tree of the trial. We use this to first create two baseline weighting schemes. The “Naive” weighting scheme assigns a weight of 1 to the tree closest to the input and a 0 to the other inputs, forcing the consensus tree to be the one closest tree. The “Constant” scheme refers to weighting all trees the same, as was done in the previous benchmarking. Finally, we model how a user might use weights by creating the “Linear” scheme where the closest tree was given the highest weight (0.3 for trials with 5 trees, 0.15 for 10 trees), and then the weight of each ranked tree decreased by a constant amount (0.05 for trials with 5 trees, 0.0111 for 10 trees). This weighting scheme is intended to mimic how a user may use outside information (e.g. sequencing coverage and type) to weight input trees. <xref rid="btad230-T1" ref-type="table">Table 1</xref> shows the mean AD distance from the outputs of the three weighting schemes to the true tree.</p>
        <table-wrap position="float" id="btad230-T1">
          <label>Table 1.</label>
          <caption>
            <p>The mean AD distance from the output of TuELiP when using “Naïve,” “Constant,” and “Linear” weighting schemes on the input trees.<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1">No. of mutations</th>
                <th rowspan="1" colspan="1">No. of trees</th>
                <th rowspan="1" colspan="1">“Naive” weighting</th>
                <th rowspan="1" colspan="1">“Constant” weighting</th>
                <th rowspan="1" colspan="1">“Linear” weighting</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">10</td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">7.45</td>
                <td rowspan="1" colspan="1">1.92</td>
                <td rowspan="1" colspan="1">
                  <bold>1.28</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">10</td>
                <td rowspan="1" colspan="1">10</td>
                <td rowspan="1" colspan="1">6.05</td>
                <td rowspan="1" colspan="1">0.94</td>
                <td rowspan="1" colspan="1">
                  <bold>0.34</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">20</td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">18.88</td>
                <td rowspan="1" colspan="1">5.43</td>
                <td rowspan="1" colspan="1">
                  <bold>3.87</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">20</td>
                <td rowspan="1" colspan="1">10</td>
                <td rowspan="1" colspan="1">21.28</td>
                <td rowspan="1" colspan="1">3.07</td>
                <td rowspan="1" colspan="1">
                  <bold>1.97</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">30</td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">39.24</td>
                <td rowspan="1" colspan="1">
                  <bold>9.07</bold>
                </td>
                <td rowspan="1" colspan="1">9.26</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">30</td>
                <td rowspan="1" colspan="1">10</td>
                <td rowspan="1" colspan="1">39.94</td>
                <td rowspan="1" colspan="1">4.94</td>
                <td rowspan="1" colspan="1">
                  <bold>3.51</bold>
                </td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn1">
              <label>a</label>
              <p>The values in bold indicate they are the lowest mean AD distance of the three weighting schemes. See the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref> for a boxplot of each trials’ distances.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <p>The “Linear” scheme outperformed the “Naive” weighting scheme across trials with 5 and 10 input trees and 10, 20, and 30 mutations. “Linear” also outperformed “Constant” for all cases except 5 trees and 30 mutations, in which its mean distance was 2% higher than the mean distance of the “Constant” consensus trees. For the other cases, the “Linear” weighting scheme had a mean distance of at least 28% less than the mean distance of “Constant”. Additionally, out of all 600 trials, the “Linear” weighting scheme uncovered the true tree in 249 trials, compared to the “Constant” scheme uncovering the tree in 221 trials, and “Naive” uncovering the true tree in just 9 trials. This demonstrates the possible benefit of being able to use weights when identifying consensus trees. We also note that across all of the simulated data trials, the “Naive” weighting scheme significantly performed the worst. This further demonstrates the utility of finding the consensus of several possible trees instead of trying to select the single best input.</p>
      </sec>
    </sec>
    <sec>
      <title>3.2 Real data</title>
      <sec>
        <title>3.2.1 TNBC dataset</title>
        <p>We apply our method to a single-cell TNBC dataset from <xref rid="btad230-B23" ref-type="bibr">Wang et al. (2014)</xref>. <xref rid="btad230-B15" ref-type="bibr">Karpov et al. (2019)</xref> applied three different single-cell sequencing tumor evolution inference methods, SCITE (<xref rid="btad230-B12" ref-type="bibr">Jahn et al. 2016</xref>), SiFit (<xref rid="btad230-B24" ref-type="bibr">Zafar et al. 2017</xref>), and PhISCS (<xref rid="btad230-B18" ref-type="bibr">Malikic et al. 2019b</xref>) to this dataset to recover three possible tumor evolution trees for the patient. Both GraPhyC (<xref rid="btad230-B11" ref-type="bibr">Govek et al. 2020</xref>) and ConTreeDP (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>) used this dataset in their original analysis after restricting the set of trees to the same set of 19 mutations that appear in all three trees. We use that same restricted dataset for our analysis here.</p>
      </sec>
      <sec>
        <title>3.2.2 Equal weights consensus tree</title>
        <p>We first apply TuELiP GraPhyC, and ConTreeDP to this TNBC dataset using constant weights for all three input trees. The input trees and inferred trees by all three methods are shown in <xref rid="btad230-F6" ref-type="fig">Fig. 6</xref>. TuELiP and ConTreeDP generate identical consensus trees, which is the same as the tree inferred by PhISCS. The difference between this consensus tree and the one generated by GraPhyC is the placement of the mutation to the <italic toggle="yes">MAP3K4</italic> gene. Our method and ConTreeDP have it in a mutation cluster in the root with six other mutations, indicating it is a relatively early mutation in this history of this tumor, which is congruent with both the PhISCS and SCITE patient trees. GraPhyC pulled the mutation out from the root mutation cluster and made it a child of <italic toggle="yes">AFF4</italic> and <italic toggle="yes">NTRK1</italic>, indicating that it was a later mutation, which is only reflected in the SiFIT tree. Furthermore, the total distance from our (and ConTreeDP’s) consensus tree to the three input trees is lower than the distance from GraPhyC’s consensus tree to the input trees when using AD (24% lower), CASet (17% lower), and DISC (18% lower) distances. One reason that GraPhyC likely outputs this different tree is because it only considers a single mutation clustering, and is therefore forced to put <italic toggle="yes">MAP3k4</italic> in its own node. Both our method and ConTreeDP do not have this limitation and in fact are able to consider all possible mutation clusterings, leading to placing <italic toggle="yes">MAP3k4</italic> on a node with other mutations higher in the tree, which also is a better solution in terms of AD distance.</p>
        <fig position="float" id="btad230-F6">
          <label>Figure 6.</label>
          <caption>
            <p>(Left) Each tumor tree was inferred by a separate method for a single TNBC patient. (Right) Two consensus tree were generated by TuELiP (and ConTreeDP) and GraPhyC. The nodes with yellow denote that they are labeled by mutation MAP3K4, the mutation whose placement differs between the two consensus trees.</p>
          </caption>
          <graphic xlink:href="btad230f6" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.2.3 Varied weights consensus trees</title>
        <p>We also performed experiments on this TNBC dataset to show the impact of varying the confidence weights in the input trees when inferring a consensus tree. We varied the weights of each patient tree to cover all permutations of three numbers between 0 and 1 (with one decimal place) that sum to 1. The full resulting outputs can be seen in the ternary graph in <xref rid="btad230-F7" ref-type="fig">Fig. 7</xref> that indicates which tree, or trees, were output for each weighting configuration. As one might expect, the three corners of the plot, where one tree is much more heavily weighted than the other two, are dominated by the input trees found by SCITE, SiFIT, and PhISCS (labeled as Trees 1, 2 and 4, respectively, in the plot). Furthermore, the extent of these regions demonstrate that if the confidence weight for an individual tree exceeds 0.5 (meaning it exceeds the confidence of the other two trees combined), our method will output that tree. We also see two stripes across the plot where multiple solutions are found. The orange stripe (Tie Set 1) with greater than 100 solutions shows when we move away from the highly weighted SCITE tree (which puts many mutations in their own cluster) and start clustering the mutations, we obtain trees more similar to the other trees.</p>
        <fig position="float" id="btad230-F7">
          <label>Figure 7.</label>
          <caption>
            <p>The weights of each input tree from (<xref rid="btad230-B15" ref-type="bibr">Karpov et al. 2019</xref>) were varied, while still adding up to 1, and used as input to TuELiP. Tree 1 (cyan) is the SCITE tree, Tree 2 (blue) is the SiFIT tree, and Tree 4 (yellow) is the PhISCS tree. The number of ties are present when there is more than one optimal tree for the given weight. All of the tree topologies can be found in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>. The red star denotes the center of the triangle in which all three trees were given a weight of <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>.</p>
          </caption>
          <graphic xlink:href="btad230f7" position="float"/>
        </fig>
        <p>We also see that if we weight all trees equally (marked with a star in the plot), we return Tree 4 (the same as the input tree from PhISCS). The region associated with this tree is larger in the ternary plot than the regions associated with the other two input trees. However, the exact consensus tree(s) returned can change as these weights change. For example, if we use the weights <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">PhISCS</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0.3</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">SiFIT</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0.4</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">SCITE</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0.3</mml:mn></mml:mrow></mml:math></inline-formula>, which more strongly support the SiFIT tree, we actually find that there are two optimal consensus trees, labeled as Tie Set 3 in the figure. This set includes the tree returned when using equal weights (Tree 4 in the plot) as well as an additional tree (Tree 3 in the plot) that is identical to this tree except that the mutation to <italic toggle="yes">MAP3K4</italic> labels its own node inserted in-between the nodes labeled by <italic toggle="yes">PTEN, TBX3,…, AKAP9</italic> and by <italic toggle="yes">ECM2, NOTCH3,…, MAP2K7</italic>. Both trees support this mutation as having occurred earlier than what was predicted by GraPhyC, but provides additional information on the uncertainty of when exactly this mutation occurred. This experiment highlights the important variations that may occur in inferred consensus trees when outside information, such as different types of sequencing data being used to infer different trees, allows for applying weights to these trees.</p>
        <p>This plot also shows other interesting features of the space of consensus trees, which thus far have not been able to be captured by other consensus methods that do not consider weights for the input trees. For instance, we can see that a set of 16 equally scoring trees separate the regions between the PhISCS tree (Tree 4) and the SiFIT tree (Tree 2). A similar boundary region, but with even more trees exists between the regions dominated by the PhISCS tree (Tree 4) and the SCITE tree (Tree 1). However in this case, we only were able to find 100 trees in each set before timing out. Having the ability to explore the space of consensus trees, or even to be able to see how quickly or slowly the consensus tree changes when changing weights will provide additional information to support inferred consensus trees.</p>
        <p>Two additional weighting experiments on trees inferred by <xref rid="btad230-B17" ref-type="bibr">Malikic et al. (2019a)</xref> are located in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>. These datasets include trees inferred from both bulk-sequencing and single-cell sequencing data.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this work we introduce the Weighted <italic toggle="yes">m</italic>-Tumor Tree Consensus Problem (W-<italic toggle="yes">m</italic>-TTCP), which given (i) a set of input tumor trees, (ii) weights for each tree, and (iii) a tumor tree distance measure, finds a consensus tree that minimizes the total weighted distance from it to all input trees. We then present an ILP method, TuELiP, that solves the W-<italic toggle="yes">m</italic>-TTCP when the distance measure is AD distance. In contrast to the existing distance-based consensus methods, TuELiP is able to consider all possible mutation clusterings when identifying a consensus tree and is optimized for a more appropriate distance measure (existing methods use the simpler PC distance). Furthermore, in contrast to all existing tumor tree consensus methods, TuELiP allows a user to weight different input trees differently based upon any outside knowledge they have about either the methods used to create those trees, or the data from which they were derived.</p>
    <p>On simulated data we show that TuELiP is able to find better solutions to the W-<italic toggle="yes">m</italic>-TTCP when the distance measure is AD distance and all trees are weighted equally than the method GraPhyC. We also show that TuELiP is better at recovering the true underlying tree used to create the simulated data than both GraPhyC and ConTreeDP. On a real TNBC dataset, we found that TuELiP returned the same consensus tree as ConTreeDP which better represents input trees when equal weights were used. However, on this same dataset, we saw that variations in the confidence weights of the input trees could lead to alternative consensus trees being found—thus indicating the impact of incorporating weights into the consensus model.</p>
    <p>There are a number of different methodological extensions we hope to make to this work. Our work here focuses on using the AD distance. While this is an improvement from previous work that used the simpler PC distance, there are other more specialized distance measures (e.g. <xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>; <xref rid="btad230-B15" ref-type="bibr">Karpov et al. 2019</xref>; <xref rid="btad230-B4" ref-type="bibr">Ciccolella et al. 2021</xref>; <xref rid="btad230-B13" ref-type="bibr">Jahn et al. 2021</xref>) that might be even more appropriate to use. We would also like to explore the solution space of the W-<italic toggle="yes">m</italic>-TTCP using a generalization of the approach we took in <xref rid="btad230-F7" ref-type="fig">Fig. 7</xref>. This would help to discover if concrete things can be said about when multiple optimal solutions exist for a given input, or if different patterns exist for how consensus trees change with weights.</p>
    <p>Additionally, while our model presents a step forward as it allows all input trees to be weighted differently, the best way to choose such weights is not straightforward. We hope to do additional work to show how different features of the input data (e.g. inference algorithms used, sequencing type and coverage, etc.) can affect the inferred consensus tree and may be used when choosing weights.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad230_Supplementary_Data</label>
      <media xlink:href="btad230_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work has been supported by the National Science Foundation (NSF) award CAREER-IIS-2046011 and a Large Faculty Development Endowment grant from Carleton College.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad230-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Aguse</surname><given-names>N</given-names></string-name>, <string-name><surname>Qi</surname><given-names>Y</given-names></string-name>, <string-name><surname>El-Kebir</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Summarizing the solution space in tumor phylogeny inference by multiple consensus trees</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>i408</fpage>–<lpage>16</lpage>.<pub-id pub-id-type="pmid">31510657</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Aho</surname><given-names>AV</given-names></string-name>, <string-name><surname>Garey</surname><given-names>MR</given-names></string-name>, <string-name><surname>Ullman</surname><given-names>JD</given-names></string-name></person-group><etal>et al</etal><article-title>The transitive reduction of a directed graph</article-title>. <source>SIAM J Comput</source><year>1972</year>;<volume>1</volume>:<fpage>131</fpage>–<lpage>7</lpage>.</mixed-citation>
    </ref>
    <ref id="btad230-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Christensen</surname><given-names>S</given-names></string-name>, <string-name><surname>Kim</surname><given-names>J</given-names></string-name>, <string-name><surname>Chia</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Detecting evolutionary patterns of cancers using consensus trees</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>i684</fpage>–<lpage>91</lpage>.<pub-id pub-id-type="pmid">33381820</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ciccolella</surname><given-names>S</given-names></string-name>, <string-name><surname>Bernardini</surname><given-names>G</given-names></string-name>, <string-name><surname>Denti</surname><given-names>L</given-names></string-name></person-group><etal>et al</etal><article-title>Triplet-based similarity score for fully multilabeled trees with poly-occurring labels</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>178</fpage>–<lpage>84</lpage>.<pub-id pub-id-type="pmid">32730595</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>DiNardo</surname><given-names>Z</given-names></string-name>, <string-name><surname>Tomlinson</surname><given-names>K</given-names></string-name>, <string-name><surname>Ritz</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Distance measures for tumor evolutionary trees</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>36</volume>:<fpage>2090</fpage>–<lpage>7</lpage>.</mixed-citation>
    </ref>
    <ref id="btad230-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fittall</surname><given-names>MW</given-names></string-name>, <string-name><surname>Van Loo</surname><given-names>P.</given-names></string-name></person-group><article-title>Translating insights into tumor evolution to clinical practice: promises and challenges</article-title>. <source>Genome Med</source><year>2019</year>;<volume>11</volume>:<fpage>20</fpage>–<lpage>14</lpage>.<pub-id pub-id-type="pmid">30925887</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B7">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Fu</surname><given-names>X</given-names></string-name>, <string-name><surname>Schwartz</surname><given-names>R.</given-names></string-name></person-group><year>2021</year>. Contreedp: A consensus method of tumor trees based on maximum directed partition support problem. In: <italic toggle="yes">2021 IEEE International Conference on Bioinformatics and Biomedicine (BIBM)</italic>. IEEE, <fpage>125</fpage>–<lpage>30</lpage>.</mixed-citation>
    </ref>
    <ref id="btad230-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gawad</surname><given-names>C</given-names></string-name>, <string-name><surname>Koh</surname><given-names>W</given-names></string-name>, <string-name><surname>Quake</surname><given-names>SR</given-names></string-name></person-group><etal>et al</etal><article-title>Dissecting the clonal origins of childhood acute lymphoblastic leukemia by single-cell genomics</article-title>. <source>Proc Natl Acad Sci USA</source><year>2014</year>;<volume>111</volume>:<fpage>17947</fpage>–<lpage>52</lpage>.<pub-id pub-id-type="pmid">25425670</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gordon</surname><given-names>G</given-names></string-name>, <string-name><surname>McMahon</surname><given-names>E.</given-names></string-name></person-group><article-title>A greedoid polynomial which distinguishes rooted arborescences</article-title>. <source>Proc Amer Math Soc</source><year>1989</year>;<volume>107</volume>:<fpage>287</fpage>–<lpage>98</lpage>.</mixed-citation>
    </ref>
    <ref id="btad230-B10">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Govek</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><year>2018</year>. A consensus approach to infer tumor evolutionary histories. In: <italic toggle="yes">Proceedings of the 2018 ACM International Conference on Bioinformatics, Computational Biology, and Health Informatics</italic>, <fpage>63</fpage>–<lpage>72</lpage>.</mixed-citation>
    </ref>
    <ref id="btad230-B11">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Govek</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><year>2020</year>. <italic toggle="yes">Graphyc: Using Consensus to Infer Tumor Evolution</italic>. IEEE/ACM Transactions on Computational Biology and Bioinformatics.</mixed-citation>
    </ref>
    <ref id="btad230-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jahn</surname><given-names>K</given-names></string-name>, <string-name><surname>Kuipers</surname><given-names>J</given-names></string-name>, <string-name><surname>Beerenwinkel</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Tree inference for single-cell data</article-title>. <source>Genome Biol</source><year>2016</year>;<volume>17</volume>:<fpage>1</fpage>–<lpage>17</lpage>.<pub-id pub-id-type="pmid">26753840</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jahn</surname><given-names>K</given-names></string-name>, <string-name><surname>Beerenwinkel</surname><given-names>N</given-names></string-name>, <string-name><surname>Zhang</surname><given-names>L</given-names></string-name></person-group><etal>et al</etal><article-title>The bourque distances for mutation trees of cancers</article-title>. <source>Algorithms Mol Biol</source><year>2021</year>;<volume>16</volume>:<fpage>1</fpage>–<lpage>15</lpage>.<pub-id pub-id-type="pmid">33639968</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jiao</surname><given-names>W</given-names></string-name>, <string-name><surname>Vembu</surname><given-names>S</given-names></string-name>, <string-name><surname>Deshwar</surname><given-names>AG</given-names></string-name></person-group><etal>et al</etal><article-title>Inferring clonal evolution of tumors from single nucleotide somatic mutations</article-title>. <source>BMC Bioinformatics</source><year>2014</year>;<volume>15</volume>:<fpage>1</fpage>–<lpage>16</lpage>.<pub-id pub-id-type="pmid">24383880</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Karpov</surname><given-names>N</given-names></string-name>, <string-name><surname>Malikic</surname><given-names>S</given-names></string-name>, <string-name><surname>Rahman</surname><given-names>MK</given-names></string-name></person-group><etal>et al</etal><article-title>A multi-labeled tree dissimilarity measure for comparing “clonal trees” of tumor progression</article-title>. <source>Algorithms Mol Biol</source><year>2019</year>;<volume>14</volume>:<fpage>1</fpage>–<lpage>18</lpage>.<pub-id pub-id-type="pmid">30839948</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Leung</surname><given-names>ML</given-names></string-name>, <string-name><surname>Davis</surname><given-names>A</given-names></string-name>, <string-name><surname>Gao</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Single-cell DNA sequencing reveals a late-dissemination model in metastatic colorectal cancer</article-title>. <source>Genome Res</source><year>2017</year>;<volume>27</volume>:<fpage>1287</fpage>–<lpage>99</lpage>.<pub-id pub-id-type="pmid">28546418</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Malikic</surname><given-names>S</given-names></string-name>, <string-name><surname>Jahn</surname><given-names>K</given-names></string-name>, <string-name><surname>Kuipers</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Integrative inference of subclonal tumour evolution from single-cell and bulk sequencing data</article-title>. <source>Nat Commun</source><year>2019a</year>;<volume>10</volume>:<fpage>1</fpage>–<lpage>12</lpage>.<pub-id pub-id-type="pmid">30602773</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Malikic</surname><given-names>S</given-names></string-name>, <string-name><surname>Mehrabadi</surname><given-names>FR</given-names></string-name>, <string-name><surname>Ciccolella</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>PhISCS: a combinatorial approach for subperfect tumor phylogeny reconstruction via integrative use of single-cell and bulk sequencing data</article-title>. <source>Genome Res</source><year>2019b</year>;<volume>29</volume>:<fpage>1860</fpage>–<lpage>77</lpage>.<pub-id pub-id-type="pmid">31628256</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>MA</given-names></string-name>, <string-name><surname>Satas</surname><given-names>G</given-names></string-name>, <string-name><surname>Raphael</surname><given-names>BJ</given-names></string-name></person-group><etal>et al</etal><article-title>Calder: inferring phylogenetic trees from longitudinal tumor samples</article-title>. <source>Cell Syst</source><year>2019</year>;<volume>8</volume>:<fpage>514</fpage>–<lpage>22.e5</lpage>.<pub-id pub-id-type="pmid">31229560</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nowell</surname><given-names>PC.</given-names></string-name></person-group><article-title>The clonal evolution of tumor cell populations</article-title>. <source>Science</source><year>1976</year>;<volume>194</volume>:<fpage>23</fpage>–<lpage>28</lpage>.<pub-id pub-id-type="pmid">959840</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B21">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Santos</surname><given-names>HG</given-names></string-name>, <string-name><surname>Toffolo</surname><given-names>T.</given-names></string-name></person-group><italic toggle="yes">Mixed Integer Linear Programming with Python</italic>. <year>2020</year>. <ext-link xlink:href="https://buildmedia.readthedocs.org/media/pdf/python-mip/latest/python-mip.pdf" ext-link-type="uri">https://buildmedia.readthedocs.org/media/pdf/python-mip/latest/python-mip.pdf</ext-link>.</mixed-citation>
    </ref>
    <ref id="btad230-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schwartz</surname><given-names>R</given-names></string-name>, <string-name><surname>Schäffer</surname><given-names>AA.</given-names></string-name></person-group><article-title>The evolution of tumour phylogenetics: principles and practice</article-title>. <source>Nat Rev Genet</source><year>2017</year>;<volume>18</volume>:<fpage>213</fpage>–<lpage>29</lpage>.<pub-id pub-id-type="pmid">28190876</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname><given-names>Y</given-names></string-name>, <string-name><surname>Waters</surname><given-names>J</given-names></string-name>, <string-name><surname>Leung</surname><given-names>ML</given-names></string-name></person-group><etal>et al</etal><article-title>Clonal evolution in breast cancer revealed by single nucleus genome sequencing</article-title>. <source>Nature</source><year>2014</year>;<volume>512</volume>:<fpage>155</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">25079324</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zafar</surname><given-names>H</given-names></string-name>, <string-name><surname>Tzen</surname><given-names>A</given-names></string-name>, <string-name><surname>Navin</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Sifit: inferring tumor trees from single-cell sequencing data under finite-sites models</article-title>. <source>Genome Biol</source><year>2017</year>;<volume>18</volume>:<fpage>1</fpage>–<lpage>20</lpage>.<pub-id pub-id-type="pmid">28077169</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311318</article-id>
    <article-id pub-id-type="pmid">37387177</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad230</article-id>
    <article-id pub-id-type="publisher-id">btad230</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Evolutionary, Comparative and Population Genomics</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A weighted distance-based approach for deriving consensus tumor evolutionary trees</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Guang</surname>
          <given-names>Ziyun</given-names>
        </name>
        <aff><institution>Department of Computer Science, Carleton College</institution>, Northfield, MN 55057, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Smith-Erb</surname>
          <given-names>Matthew</given-names>
        </name>
        <aff><institution>Department of Computer Science, Carleton College</institution>, Northfield, MN 55057, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Oesper</surname>
          <given-names>Layla</given-names>
        </name>
        <aff><institution>Department of Computer Science, Carleton College</institution>, Northfield, MN 55057, <country country="US">USA</country></aff>
        <xref rid="btad230-cor1" ref-type="corresp"/>
        <!--loesper@carleton.edu-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad230-cor1">Corresponding author. Department of Computer Science, Carleton College, Northfield, MN 55057, USA. E-mail: <email>loesper@carleton.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i204</fpage>
    <lpage>i212</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad230.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>The acquisition of somatic mutations by a tumor can be modeled by a type of evolutionary tree. However, it is impossible to observe this tree directly. Instead, numerous algorithms have been developed to infer such a tree from different types of sequencing data. But such methods can produce conflicting trees for the same patient, making it desirable to have approaches that can combine several such tumor trees into a consensus or summary tree. We introduce The Weighted m-Tumor Tree Consensus Problem (W-<italic toggle="yes">m</italic>-TTCP) to find a consensus tree among multiple plausible tumor evolutionary histories, each assigned a confidence weight, given a specific distance measure between tumor trees. We present an algorithm called TuELiP that is based on integer linear programming which solves the W-<italic toggle="yes">m</italic>-TTCP, and unlike other existing consensus methods, allows the input trees to be weighted differently.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>On simulated data we show that TuELiP outperforms two existing methods at correctly identifying the true underlying tree used to create the simulations. We also show that the incorporation of weights can lead to more accurate tree inference. On a Triple-Negative Breast Cancer dataset, we show that including confidence weights can have important impacts on the consensus tree identified.</p>
      </sec>
      <sec id="s3">
        <title>Availability</title>
        <p>An implementation of TuELiP and simulated datasets are available at <ext-link xlink:href="https://bitbucket.org/oesperlab/consensus-ilp/src/main/" ext-link-type="uri">https://bitbucket.org/oesperlab/consensus-ilp/src/main/.</ext-link></p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>CAREER-IIS-2046011</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Large Faculty Development Endowment</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Carleton College</institution>
            <institution-id institution-id-type="DOI">10.13039/100006433</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Tumor progression has been recognized as an evolutionary process where somatic mutations accumulate (<xref rid="btad230-B20" ref-type="bibr">Nowell 1976</xref>), leading to the growth of a tumor. A tumor’s evolutionary history is the order and configuration in which these mutations arose. A better understanding of this history provides important insights into tumors’ development processes, such as the selection for variants that lead to tumor growth and tumor migration, which helps scientists develop more effective treatment plan for patients (<xref rid="btad230-B6" ref-type="bibr">Fittall and Van Loo 2019</xref>).</p>
    <p>Many computational methods have been developed to derive the evolutionary histories of tumors, typically depicting them as rooted trees where the nodes represent tumor cell populations, and the edges indicate ancestral relationships (<xref rid="btad230-B22" ref-type="bibr">Schwartz and Schäffer 2017</xref>). There has been explosive growth in the methods that infer such a tumor tree from DNA sequencing data. For example, <xref rid="btad230-B12" ref-type="bibr">Jahn et al. (2016)</xref> and <xref rid="btad230-B18" ref-type="bibr">Malikic et al. (2019b)</xref> use single-cell data, <xref rid="btad230-B17" ref-type="bibr">Malikic et al. (2019a)</xref> uses both single-cell and bulk sequencing data, and <xref rid="btad230-B19" ref-type="bibr">Myers et al. (2019)</xref> uses longitudinal data. Different methods also consider different types of mutations (e.g. SNVs, CNAs, etc.) as input. Although advancements in different algorithms and methods can produce improved inference of tumor evolutionary histories, interpretation can be challenging due to the multiple possible trees returned from these methods, even when run on data from the same patient. It would be useful to combine these sets of output trees to better infer a single evolutionary history that best represents the tumor’s evolutionary process.</p>
    <p>In recent years, several approaches have been introduced to identify a consensus tumor tree from a set of disparate input trees for a single patient. GraPhyC, first introduced in <xref rid="btad230-B10" ref-type="bibr">Govek et al. (2018)</xref> and then extended in <xref rid="btad230-B11" ref-type="bibr">Govek et al. (2020)</xref>, is a graph-theoretic approach that aims to find a consensus tree with minimal total distance from all input trees for a specified tree distance function. However, there are several limitations to this method. First, it requires a pre-clustering step to identify a set of mutation clusters before identifying a consensus tree. This means that the approach is only able to consider a single mutation clustering. Second, this method is optimized for a specific distance measure called Parent–Child (PC) distance. While this distance measure is easy to compute, it has been suggested (<xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>) that other distance measures may be more appropriate for comparing tumor evolutionary trees. <xref rid="btad230-B1" ref-type="bibr">Aguse et al. (2019)</xref> instead find multiple consensus trees, rather than a single tree. However, this approach still relies upon optimization for the PC distance as well. More recently, <xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz (2021)</xref> used a different approach to the consensus tree problem which instead aims to find a tree that maximizes directed partition support from the input trees. This approach does consider different mutation clusterings, unlike GraPhyC and the method from <xref rid="btad230-B1" ref-type="bibr">Aguse et al. (2019)</xref>, but its implementation only allows it to operate on trees which have nodes containing four or fewer children. Consensus approaches have also recently be used to detect evolutionary patterns across patients (<xref rid="btad230-B3" ref-type="bibr">Christensen et al. 2020</xref>).</p>
    <p>One major downside to all existing tumor tree consensus methods is that they consider all input trees as equally informative. However, tumor evolution inference methods have been evolving quickly and make different assumptions or use varying techniques (<xref rid="btad230-B22" ref-type="bibr">Schwartz and Schäffer, 2017</xref>). Furthermore, there have been more studies where multiple types of sequencing data are available for a single patient (e.g. <xref rid="btad230-B8" ref-type="bibr">Gawad et al. 2014</xref>; <xref rid="btad230-B16" ref-type="bibr">Leung et al. 2017</xref>; and others). These studies can contain bulk, single-cell, and even longitudinal sequencing data, making features like the depth and quality of these different datasets even more important to consider when constructing consensus trees from them. For example, more weight could be given to trees constructed using the higher coverage data.</p>
    <p>Here, we introduce an integer linear programming (ILP) based method to solve the consensus tree problem, but that allows for the input trees to have confidence weights. We name our method TuELiP (<bold>Tu</bold>mor <bold>E</bold>volution integer <bold>Li</bold>near <bold>P</bold>rogram). Specifically, we pose the Weighted <italic toggle="yes">m</italic>-Tumor Tree Consensus Problem (W-<italic toggle="yes">m</italic>-TTCP), which given (i) a set of input tumor trees, (ii) weights for each tree; and (iii) a tumor tree distance measure, finds a consensus tree that minimizes the total weighted distance from it to all input trees. In contrast to other existing distance-based consensus methods, our approach allows all clusterings of mutations to be considered when identifying a consensus tree, and optimizes for a more complex distance measure [Ancestor–Descendant (AD) distance]. To our knowledge, TuELiP is the first tumor consensus tree approach to allow for the input trees to be weighted differently. We validate our approach on both simulated and a Triple-Negative Breast Cancer (TNBC) dataset and show that our method outperforms two competing methods. On the real data, we show that including confidence weights can have important impacts on the consensus tree identified.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Problem formalization</title>
      <p>Let <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be a set of <italic toggle="yes">m</italic> mutations. A tumor that has acquired <italic toggle="yes">m</italic> mutations during its evolution, can be described using the following definition. An <italic toggle="yes">m-tumor tree</italic> is a directed rooted tree <italic toggle="yes">T</italic> where: (i) each node in the tree is labeled by one or more mutations from the mutation set <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>; and (ii) the collection of mutation labels over all nodes form a partition of the mutation set <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, which we call a “mutation clustering.” The nodes in <italic toggle="yes">m</italic>-tumor trees correspond to clones in a heterogeneous tumor where its cell population contains a unique set of somatic mutations. The direction of the edges indicate that a child clone originated from the cells of a parent clone. Thus, node labels represent the new mutations acquired by the clone which distinguish it from its parent, and are also the mutations that will be inherited by its descendants. It will also be useful to refer to the space of all <italic toggle="yes">m</italic>-tumor trees. Therefore, we define <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to be the set of all <italic toggle="yes">m</italic>-tumor trees. Finally, we also define <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to be the cluster of mutations labeling node <italic toggle="yes">v</italic>.</p>
      <p>A recent problem of interest in the computational cancer field has been how to identify a consensus, or summary tree, from a set of conflicting, but similar tumor trees. Two general approaches to this problem have been proposed: (i) distance based methods (<xref rid="btad230-B11" ref-type="bibr">Govek et al. 2020</xref>, <xref rid="btad230-B10" ref-type="bibr">2018</xref>); and (ii) partition based methods (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>). However, both types of approaches treat all input trees equally, and often restrict the trees considered to a subset of all possible <italic toggle="yes">m</italic> tumor trees. Our approach builds upon the distance-based methods, but allows for the input trees to be weighted rather than treated equally, and considers the entire space of <italic toggle="yes">m</italic> tumor trees <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We introduce the following problem.</p>
      <p><bold>The Weighted <italic toggle="yes">m</italic>-Tumor Tree Consensus Problem (W-<italic toggle="yes">m</italic>-TTCP)</bold>: Given a set <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">m</italic>-tumor trees, an <italic toggle="yes">m</italic>-tumor tree distance measure <italic toggle="yes">dist</italic>(.,.), and a tree weighting function <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo>:</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>→</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, find a consensus tree <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> such that
</p>
      <disp-formula id="E1">
        <label>(1)</label>
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msup>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mo>*</mml:mo>
            </mml:msup>
            <mml:mo>=</mml:mo>
            <mml:munder>
              <mml:mrow>
                <mml:mtext>arg</mml:mtext>
                <mml:mo> </mml:mo>
                <mml:mtext>min</mml:mtext>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>T</mml:mi>
                <mml:mo>∈</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="script">T</mml:mi>
                  </mml:mrow>
                  <mml:mi>m</mml:mi>
                </mml:msub>
              </mml:mrow>
            </mml:munder>
            <mml:munderover>
              <mml:mo>∑</mml:mo>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mi>n</mml:mi>
            </mml:munderover>
            <mml:mi>w</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>·</mml:mo>
            <mml:mi mathvariant="italic">dist</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>T</mml:mi>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
          </mml:mrow>
          <mml:mo>.</mml:mo>
        </mml:math>
      </disp-formula>
      <p>We note that this formalization can easily be extended to find <italic toggle="yes">k</italic> consensus trees, as is done by <xref rid="btad230-B1" ref-type="bibr">Aguse et al. (2019)</xref>. Our implementation of TuELiP also allows for the finding of all consensus trees that minimize the objective function.</p>
    </sec>
    <sec>
      <title>2.2 Distance measures</title>
      <p>Distance-based consensus methods require the use of a distance measure that considers how similar two input trees are, with lower values for more similar trees and higher values for more dissimilar trees. Previous distance-based consensus methods focused on one distance measure called PC distance (<xref rid="btad230-B11" ref-type="bibr">Govek et al. 2020</xref>). This distance measure counts the number of unique PC mutation relationships that appear in one tree but not the other. This distance measure has been used in previous consensus approaches mainly due to how easy it is to compute. However, it has been shown that other distance measures, in particular, those that consider not just parental but also longer range ancestral relationships may be more accurate (<xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>). One reason for this is that ancestral mutations are inherited by all of their descendants, not just their children. Therefore, we will focus on using a distance measure called AD distance originally proposed by <xref rid="btad230-B11" ref-type="bibr">Govek et al. (2020)</xref> and described below.</p>
      <p>For an <italic toggle="yes">m</italic>-tumor tree <italic toggle="yes">T</italic>, and distinct mutations <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic>, we say <italic toggle="yes">i</italic> is ancestral to <italic toggle="yes">j</italic> if <italic toggle="yes">i</italic> labels a node which is on the path from the root to the node labeled by <italic toggle="yes">j</italic>. When <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic> label the same node, they are considered ancestral to each other since their exact ordering is unknown. Additionally, if <italic toggle="yes">i</italic> is ancestral to <italic toggle="yes">j</italic>, we say that (<italic toggle="yes">i</italic>, <italic toggle="yes">j</italic>) is an “Ancestor-Descendant pair.” Given the <italic toggle="yes">m</italic>-tumor tree <italic toggle="yes">T</italic>, we define <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">i</italic> is ancestral to <italic toggle="yes">j</italic> in <italic toggle="yes">T</italic><inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> to be the set of all AD pairs in <italic toggle="yes">T</italic>. Given two <italic toggle="yes">m</italic>-tumor trees <italic toggle="yes">T</italic><sub>1</sub> and <italic toggle="yes">T</italic><sub>2</sub>, the AD distance between them is the number of AD pairs in one tree but not the other. Formally, the “Ancestor-Descendant (AD) distance measure” is defined as:
</p>
      <disp-formula id="E2">
        <label>(2)</label>
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>A</mml:mi>
            <mml:mi>D</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ϕ</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>A</mml:mi>
                <mml:mi>D</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>∖</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ϕ</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>A</mml:mi>
                <mml:mi>D</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo>+</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ϕ</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>A</mml:mi>
                <mml:mi>D</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>∖</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>ϕ</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>A</mml:mi>
                <mml:mi>D</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>T</mml:mi>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
    </sec>
    <sec>
      <title>2.3 Our method</title>
      <p>We take a two-step approach to solving the W-<italic toggle="yes">m</italic>-TTCP when the distance measure is AD distance. (i) We first use an ILP to find a directed acyclic graph (DAG) whose nodes are labeled with mutations and whose edges represent all ancestral relationships between those mutations. We will show that this graph represents the transitive closure of the desired consensus tree. (ii) We then turn the resulting DAG into a directed tree through a transitive reduction. This is our consensus tree. <xref rid="btad230-F1" ref-type="fig">Figure 1</xref> shows an overview of our approach. In contrast to the existing methods (<xref rid="btad230-B11" ref-type="bibr">Govek et al., 2020</xref>; <xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz, 2021</xref>), our approach considers all possible mutation clusterings (i.e. assignment of mutation labels to nodes), rather than restricting to a single mutation clustering, and utilizes a confidence weight assigned to each input tree when constructing the consensus tree.</p>
      <fig position="float" id="btad230-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Overview of the TuELiP method. Consensus tree is found as a transitive reduction on ILP output graph, which has edges between nodes that are ancestral to each other in the final tumor tree.</p>
        </caption>
        <graphic xlink:href="btad230f1" position="float"/>
      </fig>
      <sec>
        <title>2.3.1 ILP variables and constraints</title>
        <p>We start by introducing two sets of variables that model the ancestral relationships in our solution. For every pair of unique mutations <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>≠</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>, we introduce a variable <italic toggle="yes">x<sub>ab</sub></italic> where <italic toggle="yes">x<sub>ab</sub></italic> = 1 if mutation <italic toggle="yes">a</italic> is ancestral to mutation <italic toggle="yes">b</italic>, and <italic toggle="yes">x<sub>ab</sub></italic> = 0 if <italic toggle="yes">a</italic> is not ancestral to <italic toggle="yes">b</italic>. In the case if <italic toggle="yes">a</italic> and <italic toggle="yes">b</italic> label the same node, both <italic toggle="yes">x<sub>ab</sub></italic> = 1 and <italic toggle="yes">x<sub>ba</sub></italic> = 1. For each mutation <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> we also introduce a variable <italic toggle="yes">r<sub>a</sub></italic> where <italic toggle="yes">r<sub>a</sub></italic> = 1 if mutation <italic toggle="yes">a</italic> labels the root of our consensus tree and <italic toggle="yes">r<sub>a</sub></italic> = 0 otherwise. For a root with multiple labels, the corresponding set of variables are all set to 1. <xref rid="btad230-F2" ref-type="fig">Figure 2</xref> shows a small example of how these variables would be set for a specific <italic toggle="yes">m</italic>-tumor tree.</p>
        <fig position="float" id="btad230-F2">
          <label>Figure 2.</label>
          <caption>
            <p>A small example on how the variables used in our ILP formulation might be set for a particular tree (<italic toggle="yes">x<sub>ij</sub></italic> denoting ancestral relationship between mutations <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic> and <italic toggle="yes">r<sub>i</sub></italic> denoting whether mutation <italic toggle="yes">i</italic> labels the root). For example, since mutation B is ancestral to mutation C in the tree on the left, the variable <italic toggle="yes">x<sub>BC</sub></italic> is set to 1.</p>
          </caption>
          <graphic xlink:href="btad230f2" position="float"/>
        </fig>
        <p>To ensure that these variables are set in a way that yields a configuration consistent with the transitive closure of a valid <italic toggle="yes">m</italic>-tumor tree, we introduce the following linear constraints.
</p>
        <disp-formula id="E3">
          <label>(3)</label>
          <mml:math id="M3" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mi>c</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>≥</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>+</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>c</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>−</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo> </mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
              <mml:mo>,</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>a</mml:mi>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E4">
          <label>(4)</label>
          <mml:math id="M4" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>+</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>a</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>≥</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mi>c</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>+</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mi>c</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>−</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
              <mml:mo>,</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>a</mml:mi>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E5">
          <label>(5)</label>
          <mml:math id="M5" display="block" overflow="scroll">
            <mml:mrow>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mi>m</mml:mi>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>r</mml:mi>
                  </mml:mrow>
                  <mml:mi>a</mml:mi>
                </mml:msub>
              </mml:mrow>
              <mml:mo>≥</mml:mo>
              <mml:mn>1</mml:mn>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E6">
          <label>(6)</label>
          <mml:math id="M6" display="block" overflow="scroll">
            <mml:mrow>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mi>m</mml:mi>
                  <mml:mo stretchy="false">]</mml:mo>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo>≠</mml:mo>
                  <mml:mi>a</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>a</mml:mi>
                    <mml:mi>b</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mo>·</mml:mo>
              <mml:mfrac>
                <mml:mn>1</mml:mn>
                <mml:mrow>
                  <mml:mi>m</mml:mi>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:mfrac>
              <mml:mo>≥</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>r</mml:mi>
                </mml:mrow>
                <mml:mi>a</mml:mi>
              </mml:msub>
              <mml:mo> </mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E7">
          <label>(7)</label>
          <mml:math id="M7" display="block" overflow="scroll">
            <mml:mrow>
              <mml:munder>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>b</mml:mi>
                  <mml:mo>∈</mml:mo>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mi>m</mml:mi>
                  <mml:mo stretchy="false">]</mml:mo>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo>≠</mml:mo>
                  <mml:mi>a</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>a</mml:mi>
                    <mml:mi>b</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mo>−</mml:mo>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo>−</mml:mo>
              <mml:mn>2</mml:mn>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>≤</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>r</mml:mi>
                </mml:mrow>
                <mml:mi>a</mml:mi>
              </mml:msub>
              <mml:mo> </mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E8">
          <label>(8)</label>
          <mml:math id="M8" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>a</mml:mi>
                  <mml:mi>b</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>∈</mml:mo>
              <mml:mo>{</mml:mo>
              <mml:mn>0</mml:mn>
              <mml:mo>,</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>}</mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>b</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
              <mml:mo>,</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>≠</mml:mo>
              <mml:mi>b</mml:mi>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <disp-formula id="E9">
          <label>(9)</label>
          <mml:math id="M9" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>r</mml:mi>
                </mml:mrow>
                <mml:mi>a</mml:mi>
              </mml:msub>
              <mml:mo>∈</mml:mo>
              <mml:mo>{</mml:mo>
              <mml:mn>0</mml:mn>
              <mml:mo>,</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>}</mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo> </mml:mo>
              <mml:mo>∀</mml:mo>
              <mml:mi>a</mml:mi>
              <mml:mo>∈</mml:mo>
              <mml:mo stretchy="false">[</mml:mo>
              <mml:mi>m</mml:mi>
              <mml:mo stretchy="false">]</mml:mo>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:math>
        </disp-formula>
        <p>We need to ensure that the ancestral relations output by TuELiP are transitive. That is, if mutation <italic toggle="yes">a</italic> is ancestral to mutation <italic toggle="yes">b</italic> and mutation <italic toggle="yes">b</italic> is ancestral to mutation <italic toggle="yes">c</italic> then we need to enforce that mutation <italic toggle="yes">a</italic> is ancestral to mutation <italic toggle="yes">c</italic>. This is accomplished with constraint (3). Furthermore, we need to ensure that if mutations <italic toggle="yes">a</italic> and <italic toggle="yes">b</italic> are both ancestral to <italic toggle="yes">c</italic>, then either <italic toggle="yes">a</italic> is ancestral to <italic toggle="yes">b</italic> or <italic toggle="yes">b</italic> is ancestral to <italic toggle="yes">a</italic>, or <italic toggle="yes">a</italic> and <italic toggle="yes">b</italic> are in the same node. This keeps all ancestral mutations on a single lineage path. Accordingly, constraint (4) ensures that if both <italic toggle="yes">x<sub>ac</sub></italic> and <italic toggle="yes">x<sub>bc</sub></italic> are 1, then at least one of <italic toggle="yes">x<sub>ab</sub></italic> and <italic toggle="yes">x<sub>ba</sub></italic> is also set to 1.</p>
        <p>We also need constraints that ensure that the output from TuELiP is a connected DAG with a single root node. Constraint (5) ensures that there is at least one mutation in the root. To ensure the resulting graph is connected, constraint (6) requires that all mutations labeling the root are ancestral to all other <italic toggle="yes">m −</italic> 1 mutations (this includes any other mutations that also label the root). Similarly, constraint (7) ensures that any mutation that does not label the root must be ancestral to fewer than <italic toggle="yes">m −</italic> 1 mutations. Additional explanation of these constraints is provided in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>.</p>
      </sec>
      <sec>
        <title>2.3.2 ILP objective function</title>
        <p>Recall we want to find the setting of TuELiP variables subject to our constraints that minimizes the total weighted AD distance from the set of input trees <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> to the resulting tree <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> (whose transitive closure the ILP returns). To formulate this objective function using our variables, we introduce the function <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mo>δ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which is 1 if mutation <italic toggle="yes">a</italic> is ancestral to mutation <italic toggle="yes">b</italic> in tree <italic toggle="yes">T</italic>, and 0 if <italic toggle="yes">a</italic> is not ancestral to mutation <italic toggle="yes">b</italic> in tree <italic toggle="yes">T</italic>. We show below how to formulate our desired objective function we wish to minimize.
</p>
        <disp-formula id="E10">
          <mml:math id="M10" display="block" overflow="scroll">
            <mml:mtable columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:mo> </mml:mo>
                  <mml:mi>w</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>·</mml:mo>
                  <mml:mi>A</mml:mi>
                  <mml:mi>D</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:mo> </mml:mo>
                  <mml:mi>w</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>·</mml:mo>
                  <mml:mrow>
                    <mml:mo>[</mml:mo>
                    <mml:mrow>
                      <mml:mo>|</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>ϕ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>A</mml:mi>
                          <mml:mi>D</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>T</mml:mi>
                        </mml:mrow>
                        <mml:mo>*</mml:mo>
                      </mml:msup>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>∖</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>ϕ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>A</mml:mi>
                          <mml:mi>D</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>T</mml:mi>
                        </mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo>+</mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>ϕ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>A</mml:mi>
                          <mml:mi>D</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>T</mml:mi>
                        </mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>∖</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mo>ϕ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>A</mml:mi>
                          <mml:mi>D</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>T</mml:mi>
                        </mml:mrow>
                        <mml:mo>*</mml:mo>
                      </mml:msup>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                    <mml:mo>]</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:mo> </mml:mo>
                  <mml:mi>w</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>b</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mi>m</mml:mi>
                      <mml:mo stretchy="false">]</mml:mo>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>x</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                        <mml:mi>b</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>−</mml:mo>
                  <mml:mo>δ</mml:mo>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:mi>a</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>+</mml:mo>
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>b</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mi>m</mml:mi>
                      <mml:mo stretchy="false">]</mml:mo>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>−</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>x</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                        <mml:mi>b</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>δ</mml:mo>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:mi>a</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>b</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo stretchy="false">]</mml:mo>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:mo> </mml:mo>
                  <mml:mi>w</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>b</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mi>m</mml:mi>
                      <mml:mo stretchy="false">]</mml:mo>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo>[</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>x</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>a</mml:mi>
                            <mml:mi>b</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:mo>δ</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>T</mml:mi>
                          </mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>+</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>x</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>a</mml:mi>
                            <mml:mi>b</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>δ</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>T</mml:mi>
                          </mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mo>]</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:munderover>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:munderover>
                  <mml:mo> </mml:mo>
                  <mml:mi>w</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>T</mml:mi>
                    </mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>b</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mo stretchy="false">[</mml:mo>
                      <mml:mi>m</mml:mi>
                      <mml:mo stretchy="false">]</mml:mo>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo>[</mml:mo>
                      <mml:mrow>
                        <mml:mo>δ</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>T</mml:mi>
                          </mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>+</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>x</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>a</mml:mi>
                            <mml:mi>b</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:mn>2</mml:mn>
                        <mml:mo>δ</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>T</mml:mi>
                          </mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mo>]</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>We note this objective function has a very natural interpretation. If the output tree does not have <italic toggle="yes">a</italic> ancestral to <italic toggle="yes">b</italic> given by the assignment of <italic toggle="yes">x<sub>ab</sub></italic> = 0, but in a input tree <italic toggle="yes">T<sub>k</sub></italic>, <italic toggle="yes">a</italic> is ancestral to <italic toggle="yes">b</italic>, then the objective function helps to add a penalization of <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to the objective. Conversely, if the output tree has <italic toggle="yes">a</italic> being ancestral to <italic toggle="yes">b</italic> given by <italic toggle="yes">x<sub>ab</sub></italic> = 1, but in the input tree <italic toggle="yes">T<sub>j</sub> a</italic> is not ancestral to <italic toggle="yes">b</italic>, then <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mo>δ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and a penalization of <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> will be added to the objective.</p>
      </sec>
      <sec>
        <title>2.3.3 Transitive reduction from ILP solution</title>
        <p>The final step for our approach is to convert the output from the ILP into an <italic toggle="yes">m</italic>-tumor tree. Specifically, we construct a DAG <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from the ancestral relationships indicated by the <italic toggle="yes">x<sub>ab</sub></italic> variables and then create the <italic toggle="yes">m</italic>-tumor tree <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> from <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> by finding its transitive reduction. Creation of <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is straightforward. If <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, then <italic toggle="yes">a</italic> and <italic toggle="yes">b</italic> label the same node in <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. There is an edge from node <italic toggle="yes">v</italic> to node <italic toggle="yes">w</italic> if any mutation in <italic toggle="yes">l</italic>(<italic toggle="yes">v</italic>) is ancestral to any mutation in <italic toggle="yes">l</italic>(<italic toggle="yes">w</italic>). Because of the enforced transitive property of ancestral relationships [constraints (3) and (4)], it is sufficient to only consider a single mutation in a node when constructing edges. Formally, <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mtext>where</mml:mtext><mml:mo> </mml:mo><mml:mi>v</mml:mi><mml:mo>≠</mml:mo><mml:mi>w</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Finally, we perform a transitive reduction of <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> (<xref rid="btad230-B2" ref-type="bibr">Aho et al. 1972</xref>). We then show that the output of the transitive reduction is guaranteed to be an arborscence and is the returned consensus tree.</p>
      </sec>
    </sec>
    <sec>
      <title>2.4 Solving the <italic toggle="yes">W</italic>-<italic toggle="yes">m</italic>-TTCP</title>
      <p>In order to show the efficacy of our approach to solving the <italic toggle="yes">W</italic>-<italic toggle="yes">m</italic>-TTCP when the distance measure is AD distance, we need to show that the output of our ILP, after a transitive reduction, is guaranteed to be an arborescence. An “arborescence” is a directed graph that contains a node called the root and that has a directed path from the root to all other nodes. First we make two observations (full proofs are provided in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>) that will be useful in showing that the output of our method fits this definition.<statement id="mthst1"><label>Observation 1.</label><p><italic toggle="yes">The graph</italic> <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">produced by our ILP is acyclic.</italic></p></statement></p>
      <p>For a directed acyclic graph <italic toggle="yes">G</italic> with <italic toggle="yes">n</italic> nodes, there is a construction that finds a transitive reduction of <italic toggle="yes">G</italic> in <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, denoted <italic toggle="yes">G<sup>t</sup></italic>, which is unique and defined as having the following two conditions (<xref rid="btad230-B2" ref-type="bibr">Aho et al. 1972</xref>).</p>
      <list list-type="roman-lower">
        <list-item>
          <p>There is a directed path from node <italic toggle="yes">u</italic> to node <italic toggle="yes">v</italic> in <italic toggle="yes">G<sup>t</sup></italic> if and only if there is a directed path from <italic toggle="yes">u</italic> to <italic toggle="yes">v</italic> in <italic toggle="yes">G</italic>.</p>
        </list-item>
        <list-item>
          <p>There is no graph with fewer edges than <italic toggle="yes">G<sup>t</sup></italic> satisfying condition (i).</p>
        </list-item>
      </list>
      <statement id="mthst2">
        <label>Observation 2.</label>
        <p><italic toggle="yes">The transitive reduction of</italic> <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula><italic toggle="yes">, denoted as</italic> <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula><italic toggle="yes">, is acyclic.</italic></p>
      </statement>
      <p>We can now prove the following theorem about the output of our method.<statement id="mthst3"><label>Theorem 1.</label><p><inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula><italic toggle="yes">is an arborescence.</italic></p></statement></p>
      <p><italic toggle="yes">Proof.</italic> To prove <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is an arborescence, we must show that for a node <italic toggle="yes">u</italic>, called the root, there exists one path from <italic toggle="yes">u</italic> to any other node <italic toggle="yes">v</italic> (<xref rid="btad230-B9" ref-type="bibr">Gordon and McMahon 1989</xref>). We let <italic toggle="yes">u</italic> be the node that contains mutations that are ancestral to all other mutations. The existence of such a node is guaranteed by our constraints and can be identified using the <italic toggle="yes">r<sub>a</sub></italic> variables from the ILP. Thus, there are paths from <italic toggle="yes">u</italic> to any other node <italic toggle="yes">v</italic> in <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, which implies there exists a path from <italic toggle="yes">u</italic> to any other node <italic toggle="yes">v</italic> in <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> per condition (i) above. Now, we need that there cannot exist more than one path from <italic toggle="yes">u</italic> to any node <italic toggle="yes">v</italic>.</p>
      <p>Assume that there do exist multiple paths from <italic toggle="yes">u</italic> to <italic toggle="yes">v</italic>. Also since <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is acyclic (by Observation 2), there must exist a node on a path from <italic toggle="yes">u</italic> to <italic toggle="yes">v</italic>, say <italic toggle="yes">w</italic> (which may be <italic toggle="yes">v</italic>) that has more than one parent. Let <italic toggle="yes">y</italic> and <italic toggle="yes">z</italic> be two arbitrary and distinct parents of <italic toggle="yes">w</italic>. Then, let <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. By constraint (4), <italic toggle="yes">a</italic> is ancestral to <italic toggle="yes">b</italic> or <italic toggle="yes">b</italic> is ancestral to <italic toggle="yes">a</italic>, which implies that in <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. Without loss of generality, say that <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, and so there must exist a path from <italic toggle="yes">y</italic> to <italic toggle="yes">z</italic> in <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. So, there exist distinct paths from <italic toggle="yes">u</italic> to <italic toggle="yes">v</italic>, one that contains the edge (<italic toggle="yes">y</italic>, <italic toggle="yes">w</italic>), and one that contains the edge (<italic toggle="yes">z</italic>, <italic toggle="yes">w</italic>). By removing the edge (<italic toggle="yes">y</italic>, <italic toggle="yes">w</italic>) from <italic toggle="yes">G<sup>t</sup></italic>, there still exists a path from <italic toggle="yes">u</italic> to <italic toggle="yes">y</italic>, <italic toggle="yes">z</italic>, <italic toggle="yes">w</italic>, and <italic toggle="yes">v</italic>, namely the path that went from <italic toggle="yes">u</italic> to <italic toggle="yes">y</italic>, to the edge (<italic toggle="yes">z</italic>, <italic toggle="yes">w</italic>), to <italic toggle="yes">x</italic>. Therefore, we have constructed a graph with fewer edges than <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> that still follows property (i) of being a transitive reduction. This contradicts property (ii) that <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is the transitive reduction of <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
      <p>Thus, for any node <italic toggle="yes">v</italic> in <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, there is exactly one path from the root <italic toggle="yes">u</italic> to <italic toggle="yes">v</italic>. This implies that <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is an arborescence. □</p>
      <p>We have shown that the output of our method is an arboresence, a type of directed tree, and is therefore a valid <italic toggle="yes">m</italic>-tumor tree. Furthermore, we have shown that this tree minimizes the total AD distance to the set of input trees.</p>
    </sec>
    <sec>
      <title>2.5 Different mutation sets</title>
      <p>We have also modified our approach to work with input trees that contain different sets of mutations. In short, mutations are only present in the consensus tree if they occur in more than half of all the input trees. For more details, see the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We implemented TuELiP in Python 3.7.1 and use the MIP library v1.13.0 (<xref rid="btad230-B21" ref-type="bibr">Santos and Toffolo 2020</xref>). We test the application of our method on both simulated and real data.</p>
    <sec>
      <title>3.1 Simulated data</title>
      <p>First, we describe our approach for simulated data creation. Second, we assess TuELiP’s ability to solve the W-<italic toggle="yes">m</italic>-TTCP problem. Third, we compare how well TuELiP does against other consensus models at uncovering the true simulated tree of a patient. Finally, we analyze the effects of using different weighting schemes on the input trees.</p>
      <sec>
        <title>3.1.1 Dataset creation</title>
        <p>We simulate sets of input trees with a method similar to (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>). We create 6 datasets, each composed of 100 trials over all combinations of 5 or 10 input trees and 10, 20, or 30 mutations per tree. For each trial, we generate a ground truth tree with three steps: (i) randomly cluster mutations such that the expected number of clusters/nodes is <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="true">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, (ii) randomly assign parental relationships to each cluster such that all clusters have three or fewer children, (iii) assign mutation frequencies to each cluster while adhering to the sum rule (a cluster’s frequency must be greater than or equal to the sum of its children’s frequencies) (<xref rid="btad230-B14" ref-type="bibr">Jiao et al. 2014</xref>). We create each input tree for the given trial with the following modifications to the ground truth tree. Each modification is applied with the given probability during a traversal of all nodes in the tree, as long as the sum rule is still followed: (i) move the subtree rooted at each node with a probability of 1/3 to a grandparent or sibling node (ii), collapse edges between nodes with a probability inversely related to the closeness in mutation frequencies between the two nodes, (iii) randomly expand multi-labeled nodes with a constant probability of 1/3 into a new parental node and a child node. During the input tree generation process, we also ensure that no tree has a branching factor exceeding four, which allows us to run the consensus method ConTreeDP (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>) on the simulated trees. For full details, see the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>.</p>
      </sec>
      <sec>
        <title>3.1.2 Ability to solve W-m-TTCP</title>
        <p>We evaluated the efficacy of TuELiP at solving the W-<italic toggle="yes">m</italic>-TTCP compared to GraPhyC’s approach (<xref rid="btad230-B11" ref-type="bibr">Govek et al. 2020</xref>). We do not evaluate ConTreeDP in this scenario because its output is not a median tree, that is, it is not trying to minimize the total distance to the input trees. Instead, ConTreeDP creates an output tree that maximizes directed partition support from the input trees (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>), and this formulation does not yet have a corresponding tumor tree distance. For this experiment, we run both our method and GraPhyC on all six simulated datasets and calculate the total distance from each method’s consensus trees to all input trees for each trial using PC distance (which GraPhyC optimizes for), AD distance (which TuELiP optimizes for), as well as two other tumor evolution tree distances: CASet and DISC (<xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>).</p>
        <p>Since GraPhyC does not consider weights for input trees, we weigh all trees equally in this experiment so we can make fair comparisons. For each trial and distance measure, we calculate the percent change of the total distance between GraPhyC and TuELiP, in order to show the differences in outputs of these two methods directly. We define the percent change from GraPhyC as the difference of TuELiP’s total distance to the input trees and GraPhyC’s total distance, all divided by GraPhyC’s total distance to the input trees. Thus, 0% indicates their consensus trees were equally close to the input trees, a −50% change would indicate TuELiP’s consensus tree had a total distance to the input trees that is 50% less than the distance from the output of GraPhyC to the input trees, and a 50% change indicates that TuELiP’s tree had a total distance to the input trees that was 50% greater than the output of GraPhyC. <xref rid="btad230-F3" ref-type="fig">Figure 3</xref> shows our results for PC and AD distances. The results for CASet and DISC are similar to AD and are included in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>.</p>
        <fig position="float" id="btad230-F3">
          <label>Figure 3.</label>
          <caption>
            <p>A boxplot showing how well our approach solves the W-<italic toggle="yes">m</italic>-TTCP problem for PC distance, AD distance in terms of percent change from the output found by GraPhyC. A negative value indicates that our consensus tree is closer to the input trees than GraPhyC’s consensus tree.</p>
          </caption>
          <graphic xlink:href="btad230f3" position="float"/>
        </fig>
        <p>We see that our approach always returns a solution closer to, or equal to, all input trees in terms of AD distance (negative percent changes), while GraphyC usually (85% of trials) outperforms or ties with regards to PC distance. It is not surprising that TuELiP outperforms GraPhyC when considering AD distance, as our method is designed to optimize for that distance measure. However, it is notable that we still perform better than GraPhyC in some situations when considering PC distance, which GraPhyC is optimized for. Our method also has a smaller AD percent change when there are 10 input trees versus 5 input trees. We see similar trends to AD when using CASet and DISC to measure percent change. Specifically, TuELiP outperforms or ties GraPhyC in 94% trials when using CASet and in 91% trials when using DISC. Thus, TuELiP performs well under a variety of distance measures.</p>
      </sec>
      <sec>
        <title>3.1.3 Ability to uncover the true tree</title>
        <p>To demonstrate TuELiP’s ability to uncover the true tree used to create each simulation, we compare its performance to two other consensus methods: GraPhyC (<xref rid="btad230-B11" ref-type="bibr">Govek et al. 2020</xref>) and ConTreeDP (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>). Since neither of these methods have the ability to consider weights for the input trees, we set the weights for our method to be equal for all trees.</p>
        <p>We ran all three models on the 600 simulated trials and counted the number of trials in which they returned the exact ground truth tree. <xref rid="btad230-F4" ref-type="fig">Figure 4</xref> shows that TuELiP uncovers more trees than the other methods for 5 input trees. However, for 10 input trees, TuELiP only uncovers more trees than GraPhyC for 10 and 20 mutations, and uncovers slightly fewer trees for 30 mutations (25% of true trees uncovered for GraPhyC and 22% for TuELiP).</p>
        <fig position="float" id="btad230-F4">
          <label>Figure 4.</label>
          <caption>
            <p>The results of counting the proportion of trials in which each method returned the exact true tree.</p>
          </caption>
          <graphic xlink:href="btad230f4" position="float"/>
        </fig>
        <p>On all simulations for all models we also calculate the distance from their found consensus tree to the ground truth tree. This allows for a more nuanced analysis of how well the methods perform. We use three different distance measures in this evaluation: (i) AD distance; (ii) CASet distance (<xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>); and (iii) DISC distance (<xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>). Unlike previous sections, we did not use PC distance here because the distance measure was only used to compare to GraPhyC and does not represent longer range ancestral relationships within tumor trees. <xref rid="btad230-B5" ref-type="bibr">DiNardo et al. (2019)</xref> also showed that PC distance has limited uses when comparing tumor trees.</p>
        <p>For trials with 5 input trees, the median distance from our TuELiP’s consensus tree to the ground truth tree was lower than the median distances of both ConTreeDP and GraPhyC across all three distance metrics for 10, 20, and 30 mutations in each tree. Restricting to the 300 trials with 5 input trees, TuELiP found a tree that was closer to the ground truth tree than the tree found by ConTreeDP in around 220 trials using AD, CASet, and DISC. For the same 300 trials with 5 input trees, TuELiP found a tree closer to the true tree than the output of GraPhyC in around 160 trials with the three distance metrics. When there were 10 input trees, TuELiP consistently outperformed ConTreeDP by outputting trees closer to the true tree in at least 244 trials using the three distances, and TuELiP outperformed GraPhyC in at least 100 trials. In the trials with 10 input trees, there were many more ties between TuELiP and GraPhyC in comparison to the trials with 5 input trees. There were 48 more ties in the trials with 10 trees versus 5 trees using AD, 47 more ties using CASet, and 47 more ties using DISC.</p>
        <p>We observe that while GraPhyC identifies more consensus trees correctly than TuELiP when there are 10 input trees, each with 30 mutations (<xref rid="btad230-F3" ref-type="fig">Fig. 3</xref>), it has a higher mean distance to the true tree (11.09 using AD) than TuELiP (4.94 using AD) in these same trials (<xref rid="btad230-F5" ref-type="fig">Fig. 5</xref>). This means that while GraPhyC is able to find the correct tree slightly more of the time for this particular dataset, when it gets it wrong, it is significantly more different from the correct tree than that inferred by TuELiP.</p>
        <fig position="float" id="btad230-F5">
          <label>Figure 5.</label>
          <caption>
            <p>Results showing how well ConTreeDP, GraPhyC, and TuELiP uncover the true tumor trees for our simulated data. We measure the distances between the consensus trees and true trees using AD, CASet, and DISC.</p>
          </caption>
          <graphic xlink:href="btad230f5" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.1.4 Impact of input tree weighting</title>
        <p>Our model allows a user to weight the input trees based on their level of confidence in each. Existing methods ConTreeDP or GraPhyC do not have this capability, so in our previous experiments we weighted all trees equally in order to be able to compare to these methods. In this section, we show how our method performs under different weighting schemes and show that this feature allows us to find improved consensus trees.</p>
        <p>To test the effect of different weights on input trees, we try various weighting schemes and compare our distances to the true tree used to create the simulation. For each trial in our simulated data, we rank the input trees in ascending order of AD distance to the true tree of the trial. We use this to first create two baseline weighting schemes. The “Naive” weighting scheme assigns a weight of 1 to the tree closest to the input and a 0 to the other inputs, forcing the consensus tree to be the one closest tree. The “Constant” scheme refers to weighting all trees the same, as was done in the previous benchmarking. Finally, we model how a user might use weights by creating the “Linear” scheme where the closest tree was given the highest weight (0.3 for trials with 5 trees, 0.15 for 10 trees), and then the weight of each ranked tree decreased by a constant amount (0.05 for trials with 5 trees, 0.0111 for 10 trees). This weighting scheme is intended to mimic how a user may use outside information (e.g. sequencing coverage and type) to weight input trees. <xref rid="btad230-T1" ref-type="table">Table 1</xref> shows the mean AD distance from the outputs of the three weighting schemes to the true tree.</p>
        <table-wrap position="float" id="btad230-T1">
          <label>Table 1.</label>
          <caption>
            <p>The mean AD distance from the output of TuELiP when using “Naïve,” “Constant,” and “Linear” weighting schemes on the input trees.<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1">No. of mutations</th>
                <th rowspan="1" colspan="1">No. of trees</th>
                <th rowspan="1" colspan="1">“Naive” weighting</th>
                <th rowspan="1" colspan="1">“Constant” weighting</th>
                <th rowspan="1" colspan="1">“Linear” weighting</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">10</td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">7.45</td>
                <td rowspan="1" colspan="1">1.92</td>
                <td rowspan="1" colspan="1">
                  <bold>1.28</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">10</td>
                <td rowspan="1" colspan="1">10</td>
                <td rowspan="1" colspan="1">6.05</td>
                <td rowspan="1" colspan="1">0.94</td>
                <td rowspan="1" colspan="1">
                  <bold>0.34</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">20</td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">18.88</td>
                <td rowspan="1" colspan="1">5.43</td>
                <td rowspan="1" colspan="1">
                  <bold>3.87</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">20</td>
                <td rowspan="1" colspan="1">10</td>
                <td rowspan="1" colspan="1">21.28</td>
                <td rowspan="1" colspan="1">3.07</td>
                <td rowspan="1" colspan="1">
                  <bold>1.97</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">30</td>
                <td rowspan="1" colspan="1">5</td>
                <td rowspan="1" colspan="1">39.24</td>
                <td rowspan="1" colspan="1">
                  <bold>9.07</bold>
                </td>
                <td rowspan="1" colspan="1">9.26</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">30</td>
                <td rowspan="1" colspan="1">10</td>
                <td rowspan="1" colspan="1">39.94</td>
                <td rowspan="1" colspan="1">4.94</td>
                <td rowspan="1" colspan="1">
                  <bold>3.51</bold>
                </td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn1">
              <label>a</label>
              <p>The values in bold indicate they are the lowest mean AD distance of the three weighting schemes. See the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref> for a boxplot of each trials’ distances.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <p>The “Linear” scheme outperformed the “Naive” weighting scheme across trials with 5 and 10 input trees and 10, 20, and 30 mutations. “Linear” also outperformed “Constant” for all cases except 5 trees and 30 mutations, in which its mean distance was 2% higher than the mean distance of the “Constant” consensus trees. For the other cases, the “Linear” weighting scheme had a mean distance of at least 28% less than the mean distance of “Constant”. Additionally, out of all 600 trials, the “Linear” weighting scheme uncovered the true tree in 249 trials, compared to the “Constant” scheme uncovering the tree in 221 trials, and “Naive” uncovering the true tree in just 9 trials. This demonstrates the possible benefit of being able to use weights when identifying consensus trees. We also note that across all of the simulated data trials, the “Naive” weighting scheme significantly performed the worst. This further demonstrates the utility of finding the consensus of several possible trees instead of trying to select the single best input.</p>
      </sec>
    </sec>
    <sec>
      <title>3.2 Real data</title>
      <sec>
        <title>3.2.1 TNBC dataset</title>
        <p>We apply our method to a single-cell TNBC dataset from <xref rid="btad230-B23" ref-type="bibr">Wang et al. (2014)</xref>. <xref rid="btad230-B15" ref-type="bibr">Karpov et al. (2019)</xref> applied three different single-cell sequencing tumor evolution inference methods, SCITE (<xref rid="btad230-B12" ref-type="bibr">Jahn et al. 2016</xref>), SiFit (<xref rid="btad230-B24" ref-type="bibr">Zafar et al. 2017</xref>), and PhISCS (<xref rid="btad230-B18" ref-type="bibr">Malikic et al. 2019b</xref>) to this dataset to recover three possible tumor evolution trees for the patient. Both GraPhyC (<xref rid="btad230-B11" ref-type="bibr">Govek et al. 2020</xref>) and ConTreeDP (<xref rid="btad230-B7" ref-type="bibr">Fu and Schwartz 2021</xref>) used this dataset in their original analysis after restricting the set of trees to the same set of 19 mutations that appear in all three trees. We use that same restricted dataset for our analysis here.</p>
      </sec>
      <sec>
        <title>3.2.2 Equal weights consensus tree</title>
        <p>We first apply TuELiP GraPhyC, and ConTreeDP to this TNBC dataset using constant weights for all three input trees. The input trees and inferred trees by all three methods are shown in <xref rid="btad230-F6" ref-type="fig">Fig. 6</xref>. TuELiP and ConTreeDP generate identical consensus trees, which is the same as the tree inferred by PhISCS. The difference between this consensus tree and the one generated by GraPhyC is the placement of the mutation to the <italic toggle="yes">MAP3K4</italic> gene. Our method and ConTreeDP have it in a mutation cluster in the root with six other mutations, indicating it is a relatively early mutation in this history of this tumor, which is congruent with both the PhISCS and SCITE patient trees. GraPhyC pulled the mutation out from the root mutation cluster and made it a child of <italic toggle="yes">AFF4</italic> and <italic toggle="yes">NTRK1</italic>, indicating that it was a later mutation, which is only reflected in the SiFIT tree. Furthermore, the total distance from our (and ConTreeDP’s) consensus tree to the three input trees is lower than the distance from GraPhyC’s consensus tree to the input trees when using AD (24% lower), CASet (17% lower), and DISC (18% lower) distances. One reason that GraPhyC likely outputs this different tree is because it only considers a single mutation clustering, and is therefore forced to put <italic toggle="yes">MAP3k4</italic> in its own node. Both our method and ConTreeDP do not have this limitation and in fact are able to consider all possible mutation clusterings, leading to placing <italic toggle="yes">MAP3k4</italic> on a node with other mutations higher in the tree, which also is a better solution in terms of AD distance.</p>
        <fig position="float" id="btad230-F6">
          <label>Figure 6.</label>
          <caption>
            <p>(Left) Each tumor tree was inferred by a separate method for a single TNBC patient. (Right) Two consensus tree were generated by TuELiP (and ConTreeDP) and GraPhyC. The nodes with yellow denote that they are labeled by mutation MAP3K4, the mutation whose placement differs between the two consensus trees.</p>
          </caption>
          <graphic xlink:href="btad230f6" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.2.3 Varied weights consensus trees</title>
        <p>We also performed experiments on this TNBC dataset to show the impact of varying the confidence weights in the input trees when inferring a consensus tree. We varied the weights of each patient tree to cover all permutations of three numbers between 0 and 1 (with one decimal place) that sum to 1. The full resulting outputs can be seen in the ternary graph in <xref rid="btad230-F7" ref-type="fig">Fig. 7</xref> that indicates which tree, or trees, were output for each weighting configuration. As one might expect, the three corners of the plot, where one tree is much more heavily weighted than the other two, are dominated by the input trees found by SCITE, SiFIT, and PhISCS (labeled as Trees 1, 2 and 4, respectively, in the plot). Furthermore, the extent of these regions demonstrate that if the confidence weight for an individual tree exceeds 0.5 (meaning it exceeds the confidence of the other two trees combined), our method will output that tree. We also see two stripes across the plot where multiple solutions are found. The orange stripe (Tie Set 1) with greater than 100 solutions shows when we move away from the highly weighted SCITE tree (which puts many mutations in their own cluster) and start clustering the mutations, we obtain trees more similar to the other trees.</p>
        <fig position="float" id="btad230-F7">
          <label>Figure 7.</label>
          <caption>
            <p>The weights of each input tree from (<xref rid="btad230-B15" ref-type="bibr">Karpov et al. 2019</xref>) were varied, while still adding up to 1, and used as input to TuELiP. Tree 1 (cyan) is the SCITE tree, Tree 2 (blue) is the SiFIT tree, and Tree 4 (yellow) is the PhISCS tree. The number of ties are present when there is more than one optimal tree for the given weight. All of the tree topologies can be found in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>. The red star denotes the center of the triangle in which all three trees were given a weight of <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>.</p>
          </caption>
          <graphic xlink:href="btad230f7" position="float"/>
        </fig>
        <p>We also see that if we weight all trees equally (marked with a star in the plot), we return Tree 4 (the same as the input tree from PhISCS). The region associated with this tree is larger in the ternary plot than the regions associated with the other two input trees. However, the exact consensus tree(s) returned can change as these weights change. For example, if we use the weights <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">PhISCS</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0.3</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">SiFIT</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0.4</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">SCITE</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0.3</mml:mn></mml:mrow></mml:math></inline-formula>, which more strongly support the SiFIT tree, we actually find that there are two optimal consensus trees, labeled as Tie Set 3 in the figure. This set includes the tree returned when using equal weights (Tree 4 in the plot) as well as an additional tree (Tree 3 in the plot) that is identical to this tree except that the mutation to <italic toggle="yes">MAP3K4</italic> labels its own node inserted in-between the nodes labeled by <italic toggle="yes">PTEN, TBX3,…, AKAP9</italic> and by <italic toggle="yes">ECM2, NOTCH3,…, MAP2K7</italic>. Both trees support this mutation as having occurred earlier than what was predicted by GraPhyC, but provides additional information on the uncertainty of when exactly this mutation occurred. This experiment highlights the important variations that may occur in inferred consensus trees when outside information, such as different types of sequencing data being used to infer different trees, allows for applying weights to these trees.</p>
        <p>This plot also shows other interesting features of the space of consensus trees, which thus far have not been able to be captured by other consensus methods that do not consider weights for the input trees. For instance, we can see that a set of 16 equally scoring trees separate the regions between the PhISCS tree (Tree 4) and the SiFIT tree (Tree 2). A similar boundary region, but with even more trees exists between the regions dominated by the PhISCS tree (Tree 4) and the SCITE tree (Tree 1). However in this case, we only were able to find 100 trees in each set before timing out. Having the ability to explore the space of consensus trees, or even to be able to see how quickly or slowly the consensus tree changes when changing weights will provide additional information to support inferred consensus trees.</p>
        <p>Two additional weighting experiments on trees inferred by <xref rid="btad230-B17" ref-type="bibr">Malikic et al. (2019a)</xref> are located in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>. These datasets include trees inferred from both bulk-sequencing and single-cell sequencing data.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this work we introduce the Weighted <italic toggle="yes">m</italic>-Tumor Tree Consensus Problem (W-<italic toggle="yes">m</italic>-TTCP), which given (i) a set of input tumor trees, (ii) weights for each tree, and (iii) a tumor tree distance measure, finds a consensus tree that minimizes the total weighted distance from it to all input trees. We then present an ILP method, TuELiP, that solves the W-<italic toggle="yes">m</italic>-TTCP when the distance measure is AD distance. In contrast to the existing distance-based consensus methods, TuELiP is able to consider all possible mutation clusterings when identifying a consensus tree and is optimized for a more appropriate distance measure (existing methods use the simpler PC distance). Furthermore, in contrast to all existing tumor tree consensus methods, TuELiP allows a user to weight different input trees differently based upon any outside knowledge they have about either the methods used to create those trees, or the data from which they were derived.</p>
    <p>On simulated data we show that TuELiP is able to find better solutions to the W-<italic toggle="yes">m</italic>-TTCP when the distance measure is AD distance and all trees are weighted equally than the method GraPhyC. We also show that TuELiP is better at recovering the true underlying tree used to create the simulated data than both GraPhyC and ConTreeDP. On a real TNBC dataset, we found that TuELiP returned the same consensus tree as ConTreeDP which better represents input trees when equal weights were used. However, on this same dataset, we saw that variations in the confidence weights of the input trees could lead to alternative consensus trees being found—thus indicating the impact of incorporating weights into the consensus model.</p>
    <p>There are a number of different methodological extensions we hope to make to this work. Our work here focuses on using the AD distance. While this is an improvement from previous work that used the simpler PC distance, there are other more specialized distance measures (e.g. <xref rid="btad230-B5" ref-type="bibr">DiNardo et al. 2019</xref>; <xref rid="btad230-B15" ref-type="bibr">Karpov et al. 2019</xref>; <xref rid="btad230-B4" ref-type="bibr">Ciccolella et al. 2021</xref>; <xref rid="btad230-B13" ref-type="bibr">Jahn et al. 2021</xref>) that might be even more appropriate to use. We would also like to explore the solution space of the W-<italic toggle="yes">m</italic>-TTCP using a generalization of the approach we took in <xref rid="btad230-F7" ref-type="fig">Fig. 7</xref>. This would help to discover if concrete things can be said about when multiple optimal solutions exist for a given input, or if different patterns exist for how consensus trees change with weights.</p>
    <p>Additionally, while our model presents a step forward as it allows all input trees to be weighted differently, the best way to choose such weights is not straightforward. We hope to do additional work to show how different features of the input data (e.g. inference algorithms used, sequencing type and coverage, etc.) can affect the inferred consensus tree and may be used when choosing weights.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad230_Supplementary_Data</label>
      <media xlink:href="btad230_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work has been supported by the National Science Foundation (NSF) award CAREER-IIS-2046011 and a Large Faculty Development Endowment grant from Carleton College.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad230-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Aguse</surname><given-names>N</given-names></string-name>, <string-name><surname>Qi</surname><given-names>Y</given-names></string-name>, <string-name><surname>El-Kebir</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Summarizing the solution space in tumor phylogeny inference by multiple consensus trees</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>i408</fpage>–<lpage>16</lpage>.<pub-id pub-id-type="pmid">31510657</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Aho</surname><given-names>AV</given-names></string-name>, <string-name><surname>Garey</surname><given-names>MR</given-names></string-name>, <string-name><surname>Ullman</surname><given-names>JD</given-names></string-name></person-group><etal>et al</etal><article-title>The transitive reduction of a directed graph</article-title>. <source>SIAM J Comput</source><year>1972</year>;<volume>1</volume>:<fpage>131</fpage>–<lpage>7</lpage>.</mixed-citation>
    </ref>
    <ref id="btad230-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Christensen</surname><given-names>S</given-names></string-name>, <string-name><surname>Kim</surname><given-names>J</given-names></string-name>, <string-name><surname>Chia</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Detecting evolutionary patterns of cancers using consensus trees</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>i684</fpage>–<lpage>91</lpage>.<pub-id pub-id-type="pmid">33381820</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ciccolella</surname><given-names>S</given-names></string-name>, <string-name><surname>Bernardini</surname><given-names>G</given-names></string-name>, <string-name><surname>Denti</surname><given-names>L</given-names></string-name></person-group><etal>et al</etal><article-title>Triplet-based similarity score for fully multilabeled trees with poly-occurring labels</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>178</fpage>–<lpage>84</lpage>.<pub-id pub-id-type="pmid">32730595</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>DiNardo</surname><given-names>Z</given-names></string-name>, <string-name><surname>Tomlinson</surname><given-names>K</given-names></string-name>, <string-name><surname>Ritz</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Distance measures for tumor evolutionary trees</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>36</volume>:<fpage>2090</fpage>–<lpage>7</lpage>.</mixed-citation>
    </ref>
    <ref id="btad230-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fittall</surname><given-names>MW</given-names></string-name>, <string-name><surname>Van Loo</surname><given-names>P.</given-names></string-name></person-group><article-title>Translating insights into tumor evolution to clinical practice: promises and challenges</article-title>. <source>Genome Med</source><year>2019</year>;<volume>11</volume>:<fpage>20</fpage>–<lpage>14</lpage>.<pub-id pub-id-type="pmid">30925887</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B7">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Fu</surname><given-names>X</given-names></string-name>, <string-name><surname>Schwartz</surname><given-names>R.</given-names></string-name></person-group><year>2021</year>. Contreedp: A consensus method of tumor trees based on maximum directed partition support problem. In: <italic toggle="yes">2021 IEEE International Conference on Bioinformatics and Biomedicine (BIBM)</italic>. IEEE, <fpage>125</fpage>–<lpage>30</lpage>.</mixed-citation>
    </ref>
    <ref id="btad230-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gawad</surname><given-names>C</given-names></string-name>, <string-name><surname>Koh</surname><given-names>W</given-names></string-name>, <string-name><surname>Quake</surname><given-names>SR</given-names></string-name></person-group><etal>et al</etal><article-title>Dissecting the clonal origins of childhood acute lymphoblastic leukemia by single-cell genomics</article-title>. <source>Proc Natl Acad Sci USA</source><year>2014</year>;<volume>111</volume>:<fpage>17947</fpage>–<lpage>52</lpage>.<pub-id pub-id-type="pmid">25425670</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gordon</surname><given-names>G</given-names></string-name>, <string-name><surname>McMahon</surname><given-names>E.</given-names></string-name></person-group><article-title>A greedoid polynomial which distinguishes rooted arborescences</article-title>. <source>Proc Amer Math Soc</source><year>1989</year>;<volume>107</volume>:<fpage>287</fpage>–<lpage>98</lpage>.</mixed-citation>
    </ref>
    <ref id="btad230-B10">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Govek</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><year>2018</year>. A consensus approach to infer tumor evolutionary histories. In: <italic toggle="yes">Proceedings of the 2018 ACM International Conference on Bioinformatics, Computational Biology, and Health Informatics</italic>, <fpage>63</fpage>–<lpage>72</lpage>.</mixed-citation>
    </ref>
    <ref id="btad230-B11">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Govek</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><year>2020</year>. <italic toggle="yes">Graphyc: Using Consensus to Infer Tumor Evolution</italic>. IEEE/ACM Transactions on Computational Biology and Bioinformatics.</mixed-citation>
    </ref>
    <ref id="btad230-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jahn</surname><given-names>K</given-names></string-name>, <string-name><surname>Kuipers</surname><given-names>J</given-names></string-name>, <string-name><surname>Beerenwinkel</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Tree inference for single-cell data</article-title>. <source>Genome Biol</source><year>2016</year>;<volume>17</volume>:<fpage>1</fpage>–<lpage>17</lpage>.<pub-id pub-id-type="pmid">26753840</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jahn</surname><given-names>K</given-names></string-name>, <string-name><surname>Beerenwinkel</surname><given-names>N</given-names></string-name>, <string-name><surname>Zhang</surname><given-names>L</given-names></string-name></person-group><etal>et al</etal><article-title>The bourque distances for mutation trees of cancers</article-title>. <source>Algorithms Mol Biol</source><year>2021</year>;<volume>16</volume>:<fpage>1</fpage>–<lpage>15</lpage>.<pub-id pub-id-type="pmid">33639968</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jiao</surname><given-names>W</given-names></string-name>, <string-name><surname>Vembu</surname><given-names>S</given-names></string-name>, <string-name><surname>Deshwar</surname><given-names>AG</given-names></string-name></person-group><etal>et al</etal><article-title>Inferring clonal evolution of tumors from single nucleotide somatic mutations</article-title>. <source>BMC Bioinformatics</source><year>2014</year>;<volume>15</volume>:<fpage>1</fpage>–<lpage>16</lpage>.<pub-id pub-id-type="pmid">24383880</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Karpov</surname><given-names>N</given-names></string-name>, <string-name><surname>Malikic</surname><given-names>S</given-names></string-name>, <string-name><surname>Rahman</surname><given-names>MK</given-names></string-name></person-group><etal>et al</etal><article-title>A multi-labeled tree dissimilarity measure for comparing “clonal trees” of tumor progression</article-title>. <source>Algorithms Mol Biol</source><year>2019</year>;<volume>14</volume>:<fpage>1</fpage>–<lpage>18</lpage>.<pub-id pub-id-type="pmid">30839948</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Leung</surname><given-names>ML</given-names></string-name>, <string-name><surname>Davis</surname><given-names>A</given-names></string-name>, <string-name><surname>Gao</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Single-cell DNA sequencing reveals a late-dissemination model in metastatic colorectal cancer</article-title>. <source>Genome Res</source><year>2017</year>;<volume>27</volume>:<fpage>1287</fpage>–<lpage>99</lpage>.<pub-id pub-id-type="pmid">28546418</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Malikic</surname><given-names>S</given-names></string-name>, <string-name><surname>Jahn</surname><given-names>K</given-names></string-name>, <string-name><surname>Kuipers</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Integrative inference of subclonal tumour evolution from single-cell and bulk sequencing data</article-title>. <source>Nat Commun</source><year>2019a</year>;<volume>10</volume>:<fpage>1</fpage>–<lpage>12</lpage>.<pub-id pub-id-type="pmid">30602773</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Malikic</surname><given-names>S</given-names></string-name>, <string-name><surname>Mehrabadi</surname><given-names>FR</given-names></string-name>, <string-name><surname>Ciccolella</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>PhISCS: a combinatorial approach for subperfect tumor phylogeny reconstruction via integrative use of single-cell and bulk sequencing data</article-title>. <source>Genome Res</source><year>2019b</year>;<volume>29</volume>:<fpage>1860</fpage>–<lpage>77</lpage>.<pub-id pub-id-type="pmid">31628256</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>MA</given-names></string-name>, <string-name><surname>Satas</surname><given-names>G</given-names></string-name>, <string-name><surname>Raphael</surname><given-names>BJ</given-names></string-name></person-group><etal>et al</etal><article-title>Calder: inferring phylogenetic trees from longitudinal tumor samples</article-title>. <source>Cell Syst</source><year>2019</year>;<volume>8</volume>:<fpage>514</fpage>–<lpage>22.e5</lpage>.<pub-id pub-id-type="pmid">31229560</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nowell</surname><given-names>PC.</given-names></string-name></person-group><article-title>The clonal evolution of tumor cell populations</article-title>. <source>Science</source><year>1976</year>;<volume>194</volume>:<fpage>23</fpage>–<lpage>28</lpage>.<pub-id pub-id-type="pmid">959840</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B21">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Santos</surname><given-names>HG</given-names></string-name>, <string-name><surname>Toffolo</surname><given-names>T.</given-names></string-name></person-group><italic toggle="yes">Mixed Integer Linear Programming with Python</italic>. <year>2020</year>. <ext-link xlink:href="https://buildmedia.readthedocs.org/media/pdf/python-mip/latest/python-mip.pdf" ext-link-type="uri">https://buildmedia.readthedocs.org/media/pdf/python-mip/latest/python-mip.pdf</ext-link>.</mixed-citation>
    </ref>
    <ref id="btad230-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schwartz</surname><given-names>R</given-names></string-name>, <string-name><surname>Schäffer</surname><given-names>AA.</given-names></string-name></person-group><article-title>The evolution of tumour phylogenetics: principles and practice</article-title>. <source>Nat Rev Genet</source><year>2017</year>;<volume>18</volume>:<fpage>213</fpage>–<lpage>29</lpage>.<pub-id pub-id-type="pmid">28190876</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname><given-names>Y</given-names></string-name>, <string-name><surname>Waters</surname><given-names>J</given-names></string-name>, <string-name><surname>Leung</surname><given-names>ML</given-names></string-name></person-group><etal>et al</etal><article-title>Clonal evolution in breast cancer revealed by single nucleus genome sequencing</article-title>. <source>Nature</source><year>2014</year>;<volume>512</volume>:<fpage>155</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">25079324</pub-id></mixed-citation>
    </ref>
    <ref id="btad230-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zafar</surname><given-names>H</given-names></string-name>, <string-name><surname>Tzen</surname><given-names>A</given-names></string-name>, <string-name><surname>Navin</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Sifit: inferring tumor trees from single-cell sequencing data under finite-sites models</article-title>. <source>Genome Biol</source><year>2017</year>;<volume>18</volume>:<fpage>1</fpage>–<lpage>20</lpage>.<pub-id pub-id-type="pmid">28077169</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
