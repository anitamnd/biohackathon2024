<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.0 20120330//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genome Res</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genome Res</journal-id>
    <journal-id journal-id-type="hwp">genome</journal-id>
    <journal-id journal-id-type="pmc">genome</journal-id>
    <journal-id journal-id-type="publisher-id">GENOME</journal-id>
    <journal-title-group>
      <journal-title>Genome Research</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1088-9051</issn>
    <issn pub-type="epub">1549-5469</issn>
    <publisher>
      <publisher-name>Cold Spring Harbor Laboratory Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6314158</article-id>
    <article-id pub-id-type="medline">9509184</article-id>
    <article-id pub-id-type="doi">10.1101/gr.235499.118</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Method</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Minerva: an alignment- and reference-free approach to deconvolve Linked-Reads for metagenomics</article-title>
      <alt-title alt-title-type="left-running">Danko et al.</alt-title>
      <alt-title alt-title-type="right-running">Minerva: an alignment- and reference-free approach</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Danko</surname>
          <given-names>David C.</given-names>
        </name>
        <xref ref-type="aff" rid="af1">1</xref>
        <xref ref-type="aff" rid="af2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Meleshko</surname>
          <given-names>Dmitry</given-names>
        </name>
        <xref ref-type="aff" rid="af1">1</xref>
        <xref ref-type="aff" rid="af2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bezdan</surname>
          <given-names>Daniela</given-names>
        </name>
        <xref ref-type="aff" rid="af2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mason</surname>
          <given-names>Christopher</given-names>
        </name>
        <xref ref-type="aff" rid="af2">2</xref>
        <xref ref-type="aff" rid="af3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hajirasouliha</surname>
          <given-names>Iman</given-names>
        </name>
        <xref ref-type="aff" rid="af2">2</xref>
        <xref ref-type="aff" rid="af4">4</xref>
      </contrib>
    </contrib-group>
    <aff id="af1"><label>1</label>Tri-Institutional Computational Biology and Medicine Program, Weill Cornell Medicine of Cornell University, New York, New York 10065, USA;</aff>
    <aff id="af2"><label>2</label>Institute for Computational Biomedicine, Department of Physiology and Biophysics, Weill Cornell Medicine of Cornell University, New York, New York 10065, USA;</aff>
    <aff id="af3"><label>3</label>The Feil Family Brain and Mind Research Institute, Weill Cornell Medicine, New York, New York 10065, USA;</aff>
    <aff id="af4"><label>4</label>Englander Institute for Precision Medicine, The Meyer Cancer Center, Weill Cornell Medicine, New York, New York 10065, USA</aff>
    <author-notes>
      <corresp>Corresponding author: <email>imh2003@med.cornell.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>1</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <month>1</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="ppub"/>. -->
    <volume>29</volume>
    <issue>1</issue>
    <fpage>116</fpage>
    <lpage>124</lpage>
    <history>
      <date date-type="received">
        <day>31</day>
        <month>1</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>26</day>
        <month>11</month>
        <year>2018</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>
        <ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/site/misc/terms.xhtml">© 2019 Danko et al.; Published by Cold Spring Harbor Laboratory Press</ext-link>
      </copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This article, published in <italic>Genome Research</italic>, is available under a Creative Commons License (Attribution 4.0 International), as described at <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="116.pdf"/>
    <abstract>
      <p>Emerging Linked-Read technologies (aka read cloud or barcoded short-reads) have revived interest in short-read technology as a viable approach to understand large-scale structures in genomes and metagenomes. Linked-Read technologies, such as the 10x Chromium system, use a microfluidic system and a specialized set of 3′ barcodes (aka UIDs) to tag short DNA reads sourced from the same long fragment of DNA; subsequently, the tagged reads are sequenced on standard short-read platforms. This approach results in interesting compromises. Each long fragment of DNA is only sparsely covered by reads, no information about the ordering of reads from the same fragment is preserved, and 3′ barcodes match reads from roughly 2–20 long fragments of DNA. However, compared to long-read technologies, the cost per base to sequence is far lower, far less input DNA is required, and the per base error rate is that of Illumina short-reads. In this paper, we formally describe a particular algorithmic issue common to Linked-Read technology: the deconvolution of reads with a single 3′ barcode into clusters that represent single long fragments of DNA. We introduce Minerva, a graph-based algorithm that approximately solves the barcode deconvolution problem for metagenomic data (where reference genomes may be incomplete or unavailable). Additionally, we develop two demonstrations where the deconvolution of barcoded reads improves downstream results, improving the specificity of taxonomic assignments and of <italic>k</italic>-mer-based clustering. To the best of our knowledge, we are the first to address the problem of barcode deconvolution in metagenomics.</p>
    </abstract>
    <funding-group>
      <award-group id="funding-1">
        <funding-source>
          <institution-wrap>
            <institution>National Institutes of Health (NIH) </institution>
            <institution-id institution-id-type="open-funder-registry">10.13039/100000002</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>1T32GM083937</award-id>
      </award-group>
      <award-group id="funding-2">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation (NSF) </institution>
            <institution-id institution-id-type="open-funder-registry">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>IIS-1840275</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <p>Recently, long-read sequencing technologies (e.g., Pacific Biosciences, Oxford Nanopore) have become commercially available. These techniques promise the ability to improve de novo assembly (<xref rid="GR235499DANC7" ref-type="bibr">Jain et al. 2018</xref>), particularly in metagenomics (<xref rid="GR235499DANC3" ref-type="bibr">Frank et al. 2016</xref>). While these technologies offer much longer reads than standard short-read sequencing, their base pair error rates are substantially higher than short reads (10%–15% error vs. 0.3%). More important, long-read technologies have substantially higher costs, lower throughput, and require large amounts of DNA, or PCR amplification, as input. Currently, this makes long reads impractical for large-scale screening of whole genome or metagenome samples and most low-input clinical samples.</p>
  <p>As an alternative, low-cost and low-input (∼1 ng) DNA library preparation techniques using microfluidic 3′ barcoding methods have recently emerged (e.g., Moleculo/Illumina, 10x Genomics) that address these shortcomings. With these new technologies, input DNA is sheared into long fragments of ∼10–100 kbp. After shearing, a 3′ barcode is ligated to short reads from the fragments such that short reads from the same fragment share the same 3′ barcode (note that the 3′ barcode is unrelated to the standard 5′ barcode used for sample multiplexing). Finally, the short reads are sequenced using industry standard sequencing technologies (e.g., Illumina HiSeq). This process is commonly referred to as Linked-Read sequencing. Linked-Reads offer additional <italic>long-range</italic> information over standard short reads. We refer to the set of reads that share a 3′ barcode as a read cloud. For a more detailed explanation of the process of Linked-Read sequencing we refer the reader to <xref rid="GR235499DANC15" ref-type="bibr">Zheng et al. (2016)</xref>.</p>
  <p>Reads with matching 3′ barcodes are more likely to have emerged from the same fragment of DNA than two randomly sampled reads. However, each fragment of DNA is only fractionally covered by reads. This increases the amount of long-range information obtained from a given experiment but makes it impossible to assemble reads from a single barcode into a contiguous stretch of sequence. This trade-off has been used recently to phase large-scale somatic structural variations (<xref rid="GR235499DANC5" ref-type="bibr">Greer et al. 2017</xref>; <xref rid="GR235499DANC13" ref-type="bibr">Spies et al. 2017</xref>).</p>
  <p>State-of-the-art Linked-Read sequencing systems use the same 3′ barcode to label reads from several fragments of DNA. Existing systems hone the order of 10<sup>6</sup> 3′ barcodes; loading multiple fragments of DNA into the same 3′ barcodes is critical for high-throughput experiments. In particular, in our work using the 10x Genomics system, we observed that there were 2–20 long fragments of DNA per 3′ barcode (<ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.235499.118/-/DC1">Supplemental Fig. S1</ext-link>) and that 3′ barcodes with more reads tended to have more fragments. This can complicate downstream applications. In the absence of other information, it is difficult to distinguish the random assortment of reads into a 3′ barcode from an actual structural variation or a different source genome.</p>
  <p>To address this critical issue, we define the barcode deconvolution problem. Briefly, each group of reads that share a 3′ barcode has an unobserved set of fragments from which each read was drawn. The barcode deconvolution problem is the problem of assigning each read with a given 3′ barcode to a group such that every read in the group came from the same fragment and so there is only one group per fragment. We note that a fragment assignment is stricter than genomic assignment. Each read from the same fragment necessarily came from the same genome, but it is possible to have multiple fragments from the same genome whose reads share the same 3′ barcode.</p>
  <p>Linked-Reads provide significantly more information about the proximity of short reads than standard short-read sequencing. With the exception of very common or repetitive sequences, the co-occurrence of particular sequences across several 3′ barcodes provides evidence that the co-occurring sequences were drawn from the same underlying DNA molecules.</p>
  <p>Linked-Reads have several potential benefits for metagenomic research compared to standard short reads. Linked-Reads carry information about long stretches of sequence. In principle, this information can be used to improve taxonomic classification of reads, improve the assembly of microbial genomes, identify horizontally transferred sequences, quantify the genetic structure of low-abundance organisms, and catalog intra-sample genetic structural variants. In the near term, algorithms for analyzing short-read sequences can be used on Linked-Read data without modification which makes Linked-Reads a practical choice for many studies.</p>
  <p>Compared to long-read sequencing, Linked-Reads can be used to sequence samples far more deeply for the same amount of money and can accept much smaller amounts of input DNA. This is important for metagenomics; even at the same read depth, Linked-Reads may be more useful for studying low-abundance organisms because Linked-Reads span a much longer stretch of a genome for the number of bases sequenced (i.e., very high physical coverage) and could be used to resolve microbial structural variation.</p>
  <p>In this paper, we address the barcode deconvolution problem, a fundamental problem of using Linked-Reads for metagenomics. We show that addressing the barcode deconvolution problem improves downstream results for two demonstration applications.</p>
  <p>We formally define the barcode deconvolution problem for a single 3′ barcode. We note that our solution requires information from multiple 3′ barcodes but that this is not necessary to state the barcode deconvolution problem generally.</p>
  <p>As input, we are given a set of <italic>n</italic> reads from the same read cloud. Each read has the same 3′ barcode and an unobserved class that represents the fragment from which the read was drawn. For a given 3′ barcode with <italic>n</italic> reads drawn from <italic>f</italic> fragments, we have <inline-formula><mml:math id="il1"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false">⟨</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">⟩</mml:mo></mml:math></inline-formula> where <italic>r</italic><sub><italic>i</italic></sub> represents the unobserved class for read <italic>i</italic>, and <inline-formula><mml:math id="il2"><mml:mrow><mml:mover><mml:mi>F</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, the set of possible fragment classes [1, <italic>f</italic>].</p>
  <p>A solution to the barcode deconvolution problem for a single read cloud would be a function mapping a set of read classes to fragment classes
<disp-formula><mml:math id="UM1"><mml:mi>D</mml:mi><mml:mo>:</mml:mo><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mrow><mml:mo>↦</mml:mo><mml:mrow><mml:mover><mml:mi>F</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mrow></mml:math></disp-formula>
such that the function produces the same value for reads from the same fragment for all <italic>n</italic> reads in <inline-formula><mml:math id="il3"><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>
<disp-formula><mml:math id="UM2"><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:mrow><mml:mover><mml:mi>R</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula>
</p>
  <p>A solution to the barcode deconvolution problem for a set of read clouds would be a map from each read cloud to a function which solves the barcode deconvolution problem for that read cloud.</p>
  <p>When a reference genome is available, the barcode deconvolution problem is relatively trivial, so long as major structural variants are absent. All individual reads from the same read cloud can be mapped to the reference genome using any good read alignment method. Reads from the same fragment will tend to be clustered near one another on the reference genome; there is little chance that reads from different fragments in the same read cloud will be proximal, unless the reference genome is very small. However, if a reference genome is not available, is small, or structural variation is present, read mapping may not provide a good solution to the barcode deconvolution problem. All of these conditions are common in metagenomics.</p>
  <p>To the best of our knowledge, we are the first to formally describe the barcode deconvolution problem.</p>
  <p>We have developed a novel method, Minerva, that explicitly uses information from sequence overlap between read clouds to approximately solve the barcode deconvolution problem for metagenomic samples. Our approach was inspired by topic modeling in Natural Language Processing (NLP) which studies methods to find groups of co-occurring words in text. We demonstrate how our technique can be effectively applied to real metagenomic Linked-Read data and improve analysis for two example use cases.</p>
  <p>We present our solution to the barcode deconvolution problem in detail. We also develop a probabilistic generative model justifying key assumptions of our procedure. We also report our negative results—models that we tested but that performed poorly (<ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.235499.118/-/DC1">Supplemental Materials</ext-link>).</p>
  <sec sec-type="results" id="s1">
    <title>Results</title>
    <sec id="s1a">
      <title>Algorithm overview</title>
      <p>We have developed Minerva, an algorithm that approximately solves the barcode deconvolution problem for metagenomics. Minerva works by matching reads from the same read cloud that share <italic>k</italic>-mers with reads from other read clouds. This algorithm processes each read cloud individually by building a sparse graph between reads and other read clouds, converting that graph into a graph between reads, and clustering that graph. This method is discussed in detail.</p>
    </sec>
    <sec id="s1b">
      <title>Primary data sets</title>
      <p>We tested Minerva using two primary real data sets from two microbial mock communities. The first community (Data set 1) contained five bacterial species: <italic>Escherichia coli</italic>, <italic>Enterobacter cloacae</italic>, <italic>Micrococcus luteus</italic>, <italic>Pseudomonas antarctica</italic>, and <italic>Staphylococcus epidermidis</italic>. The second community (Data set 2) contained eight bacterial species and two fungi: <italic>Bacillus subtilis</italic>, <italic>Cryptococcus neoformans</italic>, <italic>Enterococcus faecalis</italic>, <italic>E. coli</italic>, <italic>Lactobacillus fermentum</italic>, <italic>Listeria monocytogenes</italic>, <italic>Pseudomonas aeruginosa</italic>, <italic>Saccharomyces cerevisiae</italic>, <italic>Salmonella enterica</italic>, and <italic>Staphylococcus aureus</italic>. The relative abundance of each species in each data set is listed in <xref rid="GR235499DANTB1" ref-type="table">Table 1</xref>.</p>
      <table-wrap id="GR235499DANTB1" orientation="portrait" position="float">
        <label>Table 1.</label>
        <caption>
          <p>Taxa detail: Relative abundance is based on read counts and is not adjusted for genome size</p>
        </caption>
        <graphic xlink:href="116tb01"/>
      </table-wrap>
      <p>We elected to use mock communities over simulated data in order to provide as realistic a data set as possible. All species in the mock communities had well-characterized genomes and make taxonomic assignment easy. The mock communities chosen are standard microbial positive controls as noted by <xref rid="GR235499DANC9" ref-type="bibr">Mason et al. (2017)</xref>.</p>
      <p>Roughly 1 ng of high molecular weight (HMW) DNA was extracted from each sample. The HMW DNA was processed using a 10x Chromium instrument, and we prepared sequencing libraries. Each library was sequenced on an Illumina HiSeq with 2 × 150 paired-end reads. Roughly 20 million reads were generated for each sample; for testing, we selected 10 million reads from each while ensuring that we only selected complete barcodes. Both samples showed some evidence of human contamination; reads that mapped to the human genome were not removed from the samples (but were not used to generate statistics on barcode purity) since some amount of human DNA is typical in metagenomic samples. In both samples, reads were distributed over 3 × 10<sup>6</sup> barcodes.</p>
      <p>We used <italic>Long Ranger BASIC</italic> to attach barcodes to reads and perform error correction on barcodes (<uri xlink:href="https://support.10xgenomics.com/genome-exome/software/pipelines/latest/advanced/other-pipelines">https://support.10xgenomics.com/genome-exome/software/pipelines/latest/advanced/other-pipelines</uri>). Both samples have a similar number of reads per barcode. Sample 2 had more species represented in each barcode, on average, though not necessarily more fragments, since fragments can originate from the same genome. Statistics about the data sets are summarized in <xref rid="GR235499DANTB2" ref-type="table">Table 2</xref>.</p>
      <table-wrap id="GR235499DANTB2" orientation="portrait" position="float">
        <label>Table 2.</label>
        <caption>
          <p>Data set properties</p>
        </caption>
        <graphic xlink:href="116tb02"/>
      </table-wrap>
      <p>We determined the actual fragment of origin for each read by mapping reads to the source genomes and clustering positions in case multiple fragments from the same genome were present in the same read cloud.</p>
    </sec>
    <sec id="s1c">
      <title>Runtime and performance</title>
      <p>Minerva's runtime performance largely depends on two parameters: <italic>K</italic>, the size of the <italic>k</italic>-mers used to match reads; and anchor dropout, the minimum size of the read cloud being deconvolved. We list the total runtime and RAM usage for Minerva (<xref rid="GR235499DANTB3" ref-type="table">Table 3</xref>) on both of our test data sets with different parameters. We note that our implementation of Minerva is single-threaded but that the algorithm itself is trivially parallelizable across 3′ barcodes.</p>
      <table-wrap id="GR235499DANTB3" orientation="portrait" position="float">
        <label>Table 3.</label>
        <caption>
          <p>Runtime performance</p>
        </caption>
        <graphic xlink:href="116tb03"/>
      </table-wrap>
    </sec>
    <sec id="s1d">
      <title>Minerva approximately solves the barcode deconvolution problem</title>
      <p>Minerva was able to identify subgroups in read clouds that largely corresponded to individual fragments of DNA. We term these subgroups ‘enhanced read clouds.’ We measured the quality of each enhanced read cloud using two metrics: Shannon entropy index <inline-formula><mml:math id="il4"><mml:mi>H</mml:mi><mml:mo>=</mml:mo><mml:mo>∑</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>log</mml:mi><mml:mspace width="0.4em"/><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula>, and purity <inline-formula><mml:math id="il5"><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mo movablelimits="true">max</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:mover><mml:mrow><mml:mspace width="0.4em"/><mml:mi>p</mml:mi></mml:mrow><mml:mo>→</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:math></inline-formula>, where <italic>p</italic><sub><italic>i</italic></sub> indicates the proportion of an enhanced read cloud that belongs to each fragment. These values are shown in <xref ref-type="fig" rid="GR235499DANF1">Figure 1</xref> as compared to read clouds which were not enhanced (‘standard’ read clouds). In general, Minerva produced a large number of perfect (<italic>P</italic> = 1, <italic>H</italic> = 0) enhanced read clouds.</p>
      <fig id="GR235499DANF1" orientation="portrait" position="float">
        <label>Figure 1.</label>
        <caption>
          <p>Clockwise from <italic>top, left</italic>: (1) Purity in Data set 1 for enhanced and 3′ barcodes; (2) Shannon index in Data set 1 for enhanced and 3′ barcodes; (3) Shannon index in Data set 2 for enhanced and 3′ barcodes; (4) purity in Data set 2 for enhanced and 3′ barcodes.</p>
        </caption>
        <graphic xlink:href="116f01"/>
      </fig>
      <p>We also tested whether the quality of the enhanced read clouds changed with the number of reads in the read cloud. We found a small inverse relationship between read cloud size and purity but established that our previous results were not being inflated by a large number of very small enhanced read clouds (<ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.235499.118/-/DC1">Supplemental Fig. S2</ext-link>). Note that enhanced read clouds of size 1 would be trivially perfect and are always excluded from results.</p>
      <p>In testing, we found three parameters that seemed to have the most effect on Minerva's performance. The number of links required between reads to form a cluster (<italic>eps</italic>), the <italic>k</italic>-mer size used to make minimizing <italic>k</italic>-mers (<italic>K</italic>), and the maximum allowed frequency of each read (<italic>maxk</italic>). In <ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.235499.118/-/DC1">Supplemental Figure S3</ext-link>, we show how these parameters affect Minerva's performance under three different metrics: mean enhanced barcode purity, mean enhanced barcode size, and total reads clustered, large, pure, and complete clusters being the ideal. We found that Minerva's parameters could be used to tune performance between very large and very pure enhanced barcodes depending on the downstream application.</p>
    </sec>
    <sec id="s1e">
      <title>Enhanced read clouds can be clustered into meaningful groups</title>
      <p>After deconvolving barcodes into enhanced read clouds, it is useful to group enhanced read clouds that likely came from the same genome. This is essentially a clustering problem. Initially, we explored graph-based approaches similar to our algorithm for read cloud deconvolution. These algorithms relied on the assumption that elements being clustered would have small numbers of distinguishing elements and a relatively high a priori probability of originating from the same cluster. When dealing with individual barcodes, these assumptions proved reasonable; faced with the complexity of a full data set, these assumptions became inaccurate, and graph-based algorithms performed poorly.</p>
      <p>With relatively little structure in the data that could be known a priori, we turned to topic modeling algorithms to discover implicit genetic structures in our data. Latent Dirichlet allocation (LDA) is a classic model in Natural Language Processing (<xref rid="GR235499DANC1" ref-type="bibr">Blei et al. 2003</xref>). LDA is a generative model that assumes data was created using a certain well-defined, stochastic process. Training the model consists of finding parameters that make it more likely that the observed data would be generated using the given stochastic process; typically, this is done with Gibbs sampling.</p>
      <p>Typically, LDA is used to analyze corpora of natural language. Natural language corpora are organized into documents (e.g., emails or book chapters) that consist of words. The base version of LDA does not consider what order words in a document occur, just how often each word occurs in a given document; this is referred to as a bag-of-words model. Formally, documents are modeled as a sparse vector over a large vocabulary of words where entries represent the number of times a word occurs in the document. LDA maps document from a high dimensional word-space to a lower dimensional topic-space. In NLP, topics typically have intuitive interpretations as thematically consistent units. A key advantage of LDA is that it can distinguish synonyms based on context (i.e., a river bank vs. a financial bank); this may be useful for classifying conserved motifs.</p>
      <p>We used LDA to cluster read clouds (represented as sets of <italic>k</italic>-mers). Each topic generated by LDA was considered to be a single cluster.</p>
      <p>We used LDA to project enhanced and standard read clouds into a lower dimensional space. We treated each read cloud as a document containing minimum sparse <italic>k</italic>-mers as words. We removed <italic>k</italic>-mers that occurred far more often than average in a process similar to removing stop-words in NLP. We ran LDA with hyperparameter optimization on our read cloud documents and clustered to obtain a topic vector for each read cloud using the implementation LDA in MALLET (<uri xlink:href="http://mallet.cs.umass.edu">http://mallet.cs.umass.edu</uri>). Using X-Means, we clustered the topic vectors representing read clouds into discrete groups.</p>
      <p>With standard read clouds, LDA essentially cannot distinguish any structure; with enhanced read clouds, LDA can generate clusters that are less diverse. The clusterings are compared in <xref ref-type="fig" rid="GR235499DANF2">Figure 2</xref>. This could be used to improve assemblies by clustering similar reads and reducing spurious connections. Note that we denote chromosomes rather than genomes in the figure since our process does not attempt to link chromosomes from the same organisms.</p>
      <fig id="GR235499DANF2" orientation="portrait" position="float">
        <label>Figure 2.</label>
        <caption>
          <p>Abundance of different chromosomes across clusters as assigned by Latent Dirichlet allocation (LDA). Enhanced read clouds dramatically improve LDA's ability to distinguish structure in Data set 1. This figure uses the same deconvolution as <xref ref-type="fig" rid="GR235499DANF1">Figure 1</xref>.</p>
        </caption>
        <graphic xlink:href="116f02"/>
      </fig>
    </sec>
    <sec id="s1f">
      <title>Enhanced read clouds improve short-read taxonomic assignment</title>
      <p>We observed that reads from a single linked fragment could be classified using any short-read taxonomic classifier. These classifiers, however, often have trade-offs between recall and precision. Enhanced read clouds can be used to improve recall of a short-read classifier without harming precision.</p>
      <p>Many of the reads classified by short-read taxonomic classifiers cannot be assigned to low taxonomic ranks. However, all reads from the same fragment of DNA must all have the same taxonomic rank. Read clouds can be used to promote unspecific taxonomic assignments. Any read with a taxonomic rank that is an antecedent of a lower taxonomic rank in the same read cloud can be promoted to the lower rank, provided there are no conflicts with other ranks in the same cloud. Enhanced read clouds reduce the risk of conflicting ranks and make it more likely that reads can be promoted.</p>
      <p>We used Minerva to improve the specificity of short-read taxonomic assignments obtained from Kraken, a popular pseudo-alignment-based tool (<xref rid="GR235499DANC14" ref-type="bibr">Wood and Salzberg 2014</xref>). We selected Kraken because it was found to have good precision but relatively poor recall in a study by <xref rid="GR235499DANC10" ref-type="bibr">McIntyre et al. (2017)</xref>.</p>
      <p>Using the technique described above, we were able to rescue a large number of reads from unspecific taxonomic assignments. We rescued reads using both enhanced read clouds and standard read clouds. In every case, rescue with enhanced read clouds matched or outperformed rescue with standard read clouds. All cases where rescue with enhanced read clouds outperformed standard read clouds for Data set 1 are shown in <xref rid="GR235499DANTB4" ref-type="table">Table 4</xref>. All observed taxonomic assignments were correct after promotion. Without enhanced barcodes, many annotations cannot be rescued or are incorrect.</p>
      <table-wrap id="GR235499DANTB4" orientation="portrait" position="float">
        <label>Table 4.</label>
        <caption>
          <p>Taxonomic promotion</p>
        </caption>
        <graphic xlink:href="116tb04"/>
      </table-wrap>
    </sec>
  </sec>
  <sec sec-type="discussion" id="s2">
    <title>Discussion</title>
    <p>We have introduced Minerva, a graph-based algorithm, to provide a solution to the barcode deconvolution problem. By design, Minerva provides conservative solutions to barcode deconvolution for metagenomics and uses essentially no information (except <italic>k</italic>-mer overlaps) about the sequences being clustered. We note that it will be beneficial to test Minerva on more complex communities. As such, Minerva is a relatively pure demonstration of how information can be extracted from Linked-Reads. With some modification, the algorithms underlying Minerva may even be useful for detecting structural variations and other genetic structures in the human genome.</p>
    <p>However, the current version of Minerva could be enhanced by leveraging a number of practical sequence features, such as known taxonomic assignment, GC content, tetramer frequency, or motifs. These have been shown to be good indicators of lineage in metagenomics and could be easily incorporated to improve Minerva's clusterings. In particular, taxonomic assignments could be incorporated into Minerva to evaluate barcode deconvolution, since there is no a priori reason to think reads with a known taxonomic classification would be deconvolved more effectively than reads that could not be classified.</p>
    <p>The current version of Minerva provides reasonable performance but still represents a potential bottleneck for workflows using Linked-Reads. A large performance issue is Minerva's routine to calculate the size of an intersection between two sets that is naïve and exact. <xref rid="GR235499DANC7" ref-type="bibr">Jain et al. (2018)</xref> has shown that bloom filters can be effectively used to speed up the calculation of set intersection in biology with acceptable errors. Future versions of Minerva could employ similar techniques to improve performance. Minerva uses the same parameters to process every barcode; however, the nature of Linked-Read sequencing provides a rich source of information that could be used to optimize model parameters for deconvolving individual barcodes. This would require a more thorough mathematical model of Linked–Reads, which we leave to a future work. Similarly, external sequence annotation could be incorporated as a practical approach to setting parameters for individual barcodes, though it is unlikely that such a technique would generalize to nonmicrobial applications.</p>
    <p>Of particular interest to us is the possibility of using Minerva to directly improve downstream applications. For simple applications, Minerva may be used with a single set of parameters to produce a deconvolution that meets certain requirements. For applications built to take advantage of barcode deconvolution, Minerva could be run with multiple parameters to produce increasingly strict tiers of enhancement. This may be particularly important for de Bruijn graph (DBG) assembly. DBG assembly typically relies on effectively trimming and finding paths through a de Bruijn graph. Multiple tiers of linkage between reads could be used to inform trimming or pathfinding programs about likely paths and spurious connections. This could likely be modeled either as an information theory or probabilistic approach depending on the situation and assembler.</p>
    <p>Overall, we believe that Minerva is an important step toward building techniques designed to take advantage of Linked-Reads. Linked-Reads have the potential to dramatically improve detection of large genetic structures without dramatically increasing sequencing costs, while taking advantage of existing techniques to process short reads.</p>
  </sec>
  <sec sec-type="methods" id="s3">
    <title>Methods</title>
    <p>We have developed a graph-based algorithm to subdivide reads from the same read cloud into groups that, ideally, solve the barcode deconvolution problem.</p>
    <p>The core intuition behind our approach is that reads from the same read cloud from the same fragment will tend to overlap with similar sets of reads from other read clouds. Critically, if the total genome length in a sample is large enough, a pair of read clouds is unlikely to contain reads from more than one overlapping genomic region. In what follows, we justify this statement.</p>
    <sec id="s3a">
      <title>Mathematical justification of the model</title>
      <p>We have developed a simple model to justify our statement that reads from the same fragment will overlap with reads from similar sets of read clouds. This model is similar to empirical results and can be used to inform the parameters used for deconvolution.</p>
      <p>First, we develop a model for drawing fragments of DNA from genomes in a metagenomic sample. For simplicity, we model each microbial genome <italic>G</italic><sub><italic>i</italic></sub> in a metagenome <italic>G</italic> as a discrete collection of exactly <italic>N</italic><sub><italic>g</italic></sub> fragments <inline-formula><mml:math id="il6"><mml:mover><mml:msub><mml:mi>F</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo accent="false">→</mml:mo></mml:mover></mml:math></inline-formula>, where <italic>i</italic> is an index numbering each genome in the metagenome. <italic>N</italic><sub><italic>g</italic></sub> is the same for all genomes. The probability of selecting a given fragment <italic>F</italic><sub><italic>i</italic></sub><sub>,<italic>j</italic></sub> (where individual fragments are indexed by <italic>j</italic>) from a given microbial genome <italic>G</italic><sub><italic>i</italic></sub> is given by a uniform distribution. We model the probability of selecting a given genome as a geometric distribution; this choice is motivated by observations of real microbial communities that tend to be dominated by 1–2 species with a long tail of lower abundance species.</p>
      <p>The probability of selecting a particular fragment <italic>F</italic><sub><italic>i</italic></sub><sub>,<italic>j</italic></sub> given that we are drawing fragments from genome <italic>G</italic><sub><italic>i</italic></sub> is
<disp-formula><mml:math id="UM3"><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>.</mml:mo></mml:mstyle></mml:math></disp-formula>
For simplicity, we assume the abundance of genomes <italic>G</italic><sub>1</sub>, <italic>G</italic><sub>2</sub>, … is sorted in descending order by their index. The probability of selecting a given genome <italic>G</italic><sub><italic>i</italic></sub> is
<disp-formula><mml:math id="UM4"><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mstyle></mml:math></disp-formula>
This gives us the probability of drawing a single given fragment <italic>F</italic><sub><italic>i</italic></sub><sub>,<italic>j</italic></sub> without a given genome.
<disp-formula><mml:math id="UM5"><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>g</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:msup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mstyle></mml:math></disp-formula>
The probability that two fragments <italic>F</italic><sub><italic>w</italic>,<italic>x</italic></sub>, <italic>F</italic><sub><italic>y</italic>,<italic>z</italic></sub> are the same given that their genomes <italic>G</italic><sub><italic>w</italic></sub>, <italic>G</italic><sub><italic>y</italic></sub> are the same is
<disp-formula><mml:math id="UM6"><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>w</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mstyle></mml:math></disp-formula>
The probability that two genomes <italic>G</italic><sub><italic>w</italic></sub>, <italic>G</italic><sub><italic>y</italic></sub> are the same is given below. In real communities, this is an approximation that improves as the total number of species increases.
<disp-formula><mml:math id="UM7"><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>w</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo movablelimits="true">lim</mml:mo></mml:mrow><mml:mrow><mml:mo fence="false">|</mml:mo><mml:mi>G</mml:mi><mml:mo fence="false">|</mml:mo><mml:mo>→</mml:mo><mml:mi mathvariant="normal">∞</mml:mi></mml:mrow></mml:munder><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo fence="false">|</mml:mo><mml:mi>G</mml:mi><mml:mo fence="false">|</mml:mo></mml:mrow></mml:munderover><mml:mstyle><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow><mml:mo>=</mml:mo><mml:mstyle><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mstyle></mml:mstyle></mml:math></disp-formula>
Let <italic>p</italic><sub><italic>f</italic></sub> be the probability that two fragments <italic>F</italic><sub><italic>w</italic>,<italic>x</italic></sub>, <italic>F</italic><sub><italic>y</italic>,<italic>z</italic></sub> are the same without conditioning on a given genome. We have
<disp-formula><mml:math id="UM8"><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>N</mml:mi><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mstyle></mml:math></disp-formula>
Second, we develop a generative model for assembling a read cloud from a set of fragments. We model each read cloud as a selection of <italic>N</italic><sub><italic>f</italic></sub> fragments drawn from the set of all possible fragments. We refer to the set of fragments in a given read cloud as <italic>R</italic><sub><italic>i</italic></sub>. For simplicity, we do handle the case where two read clouds both contain multiple fragments from the same class; this case is very unlikely with parameters relevant to our scenario (1 in 25,000 with the parameters given below).</p>
      <p>Let <italic>X</italic>(<italic>k</italic>) be the probability that two read clouds <italic>R</italic><sub><italic>i</italic></sub> and <italic>R</italic><sub><italic>j</italic></sub>, both with <italic>N</italic><sub><italic>f</italic></sub> fragments, share exactly <italic>k</italic> fragments. In other words, any fragment in <italic>R</italic><sub><italic>i</italic></sub> overlaps with at least one fragment in <italic>R</italic><sub><italic>j</italic></sub> and vice versa.</p>
      <p>We have
<disp-formula><mml:math id="UM9"><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mi>N</mml:mi><mml:mi>f</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:math></disp-formula>
This is simply because none of the <inline-formula><mml:math id="il7"><mml:msubsup><mml:mi>N</mml:mi><mml:mi>f</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:math></inline-formula> possible pairs of fragments (i.e., one in <italic>R</italic><sub><italic>i</italic></sub> and one in <italic>R</italic><sub><italic>j</italic></sub>) overlap.</p>
      <p>We also have
<disp-formula><mml:math id="UM10"><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>N</mml:mi><mml:mi>f</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mi>N</mml:mi><mml:mi>f</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:math></disp-formula>
Here, exactly one fragment in <italic>R</italic><sub><italic>i</italic></sub> overlaps with one or more fragments in <italic>R</italic><sub><italic>j</italic></sub> or vice versa. While it is extremely unlikely that we observe overlap of a fragment in <italic>R</italic><sub><italic>i</italic></sub> with more than one fragment in <italic>R</italic><sub><italic>j</italic></sub>, we handle this case in our equations because this is allowed in our approximate generative model. We have 2<italic>N</italic><sub><italic>f</italic></sub> possibilities to select a fragment in either <italic>R</italic><sub><italic>i</italic></sub> or <italic>R</italic><sub><italic>j</italic></sub>. This fragment must overlap with at least one fragment in the other read cloud (i.e., the term <inline-formula><mml:math id="il8"><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msup></mml:math></inline-formula>). No other pair of fragments must overlap (i.e., the term <inline-formula><mml:math id="il9"><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>⋅</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula>) and because we double-counted cases where exactly one fragment in <italic>R</italic><sub><italic>i</italic></sub> overlaps with exactly one in <italic>R</italic><sub><italic>j</italic></sub> we subtracted the term <inline-formula><mml:math id="il10"><mml:msubsup><mml:mi>N</mml:mi><mml:mi>f</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mi>N</mml:mi><mml:mi>f</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula>.</p>
      <p>The probability that two read clouds share more than one fragment is
<disp-formula><mml:math id="UM11"><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula>
We choose reasonable, conservative (compared to our observed data) values for all parameters <italic>N</italic><sub><italic>f</italic></sub> = 5, <italic>N</italic><sub><italic>g</italic></sub> = 100, |<italic>G</italic>| = 10 and obtain the following estimates
<disp-formula><mml:math id="UM12"><mml:msub><mml:mi>p</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mstyle><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>200</mml:mn></mml:mrow></mml:mfrac></mml:mrow><mml:mo>,</mml:mo></mml:mstyle></mml:math></disp-formula>
<disp-formula><mml:math id="UM13"><mml:mi>X</mml:mi><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo><mml:mo>≈</mml:mo><mml:mn>0.8822</mml:mn><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>≈</mml:mo><mml:mn>0.113</mml:mn><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo>(</mml:mo><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>≈</mml:mo><mml:mn>0.0048</mml:mn><mml:mo>,</mml:mo></mml:math></disp-formula>
<disp-formula><mml:math id="UM14"><mml:mstyle><mml:mrow><mml:mfrac><mml:mrow><mml:mi>X</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>(</mml:mo><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mfrac></mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>23.</mml:mn></mml:mstyle></mml:math></disp-formula>
We find that it is about 23 times more likely to have exactly one overlapping fragment between two read clouds than multiple overlapping fragments in our mathematical model. We verified this through simulation and obtained a similar ratio of 1 to 40 (the discrepancy occurs because of how our simulation samples the geometric distribution). This is true even with conservative parameters chosen to minimize the ratio. This is important because it means we are likely to avoid a large number of spurious connections between genomic regions that could lead to poor deconvolution. However, this model does not account for the fact that individual fragments may have similar sequences, which is a major source of noise for Minerva. To reduce this noise, we use the parameters of this model to justify removing any overlaps that occur far more often than expected.</p>
      <p>On average, each fragment in a data set is only fractionally covered at a rate of <italic>C</italic><sub><italic>r</italic></sub> (with a read depth of 1). While the precise coverage might vary between fragments, this parameter can be used to estimate the size of overlaps between fragments and their expected sparsity. Two long fragments would be expected to overlap at <inline-formula><mml:math id="il11"><mml:msubsup><mml:mi>C</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:math></inline-formula> points in their overlap. In cases where fragments overlap much more frequently than <inline-formula><mml:math id="il12"><mml:msubsup><mml:mi>C</mml:mi><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:math></inline-formula> over their lengths, it can be inferred that the sequence present is too repetitive or common to be useful for deconvolution.</p>
      <p>These facts are used in Minerva to filter connections between repetitive regions, restrict overlaps to regions of a certain length, and to heuristically filter comparisons between read clouds unlikely to have significant overlap. This carries practical performance benefits and reduces errors.</p>
    </sec>
    <sec id="s3b">
      <title>A graph-based algorithm for barcode deconvolution</title>
      <sec id="s3b1">
        <title>Summary</title>
        <p>We have developed a graph-based algorithm that effectively deconvolves the reads within a given read cloud. The model constructs a bipartite graph between all reads with a given read cloud and all other read clouds. Reads have an edge to a read cloud if they are found to contain a <italic>k</italic>-mer that is specific to exactly one read in the foreign read cloud. Once the bipartite graph is constructed, read clouds and reads with too many or too few edges (by user-supplied parameters) are removed. The filtered bipartite graph is used to construct an adjacency matrix between reads, and the matrix is clustered into groups of reads. This algorithm is <italic>O</italic>(<italic>n</italic><sup>2</sup>) over the number of read clouds, though we note that the number of read clouds is a constant for each specific technology that could be used.</p>
        <p>The specific steps in our algorithm are as follows:
<list list-type="order"><list-item><p>Read clouds are parsed; read clouds below a certain size (dropout) are dropped. Each read in each read cloud is parsed into a set of minimum sparse <italic>k</italic>-mers.</p></list-item><list-item><p>Each read cloud above a certain size (anchor dropout) is compared to all other read clouds. The read cloud being compared is called the ‘anchor.’</p></list-item><list-item><p>A bipartite graph is constructed between the reads in the anchor and all other read clouds based on <italic>k</italic>-mer overlap.</p></list-item><list-item><p>The bipartite graph is reduced to a graph between reads in the anchor.</p></list-item><list-item><p>The read graph is broken into discrete clusters which are output as solutions to the barcode deconvolution problem.</p></list-item></list></p>
      </sec>
      <sec id="s3b2">
        <title>The model</title>
        <p>Initially, each read cloud in a given data set is parsed into a set of minimizing <italic>k</italic>-mers (<xref ref-type="fig" rid="GR235499DANF3">Fig. 3</xref>, part 1). Global counts for <italic>k</italic>-mers are retained. Once parsing is complete, <italic>k</italic>-mers that occur exactly once or many times more than the average (10 times more, by default) are discarded. Singleton <italic>k</italic>-mers cannot occur in more than one barcode and <italic>k</italic>-mers that are too common tend to create false positives (these <italic>k</italic>-mers appear to originate from low complexity or conserved regions). This process is analogous to removing stop words in Natural Language Processing applications. A map of <italic>k</italic>-mers to reads is retained for each read cloud.</p>
        <fig id="GR235499DANF3" orientation="portrait" position="float">
          <label>Figure 3.</label>
          <caption>
            <p>Processing steps for a single read cloud. From <italic>top</italic>: (1) Fragments are sequenced and tagged with 3′ barcodes. (2) Reads in a given read cloud are mapped to reads in other read clouds using minimizing <italic>k</italic>-mers. (3) A bipartite graph between reads and other read clouds is constructed. (4) A graph between reads that map to the same read clouds is constructed. (5) Reads are clustered into groups.</p>
          </caption>
          <graphic xlink:href="116f03"/>
        </fig>
        <p>After parsing, the set of reads in a given read cloud is compared to every other read cloud (<xref ref-type="fig" rid="GR235499DANF3">Fig. 3</xref>, part 2). Comparisons between read clouds that share too many <italic>k</italic>-mers are discarded as these likely represent low complexity or evolutionarily conserved regions as opposed to real overlaps. Comparisons between read clouds that share too few <italic>k</italic>-mers are also rejected to improve performance. The intersection of the <italic>k</italic>-mer sets between the given read clouds and all read clouds that passed filtering is calculated.</p>
        <p>A bipartite graph is constructed by creating nodes for every read in the read cloud being processed and every read cloud that was not filtered out (<xref ref-type="fig" rid="GR235499DANF3">Fig. 3</xref>, part 3). Edges are only added between read-nodes (left nodes) and read cloud-nodes (right nodes). An edge is drawn between a read-node and a read cloud-node if, and only if, the read shares a <italic>k</italic>-mer with the given read cloud. This is a fast proxy measure for read overlap. Finally, any read cloud-node with degree above a given threshold is discarded.</p>
        <p>Each bipartite graph representing the reads from a given read cloud is given a final round of filtering where reads that matched too many foreign read clouds are removed based on a user-supplied threshold. The filtered bipartite graph is converted to an adjacency matrix of reads where the similarity between reads is equivalent to the number of read clouds with which both reads overlapped (<xref ref-type="fig" rid="GR235499DANF3">Fig. 3</xref>, part 4). This adjacency matrix is converted to a binary matrix by setting all values below a user-supplied threshold to zero and all remaining values to one (<xref ref-type="fig" rid="GR235499DANF3">Fig. 3</xref>, part 5).</p>
        <p>All connected components in the binary matrix are found. Connected components consisting of single reads are discarded; the remaining components define clusters. This process is analogous to DBSCAN (<xref rid="GR235499DANC2" ref-type="bibr">Ester et al. 1996</xref>) for graphs.</p>
      </sec>
    </sec>
    <sec id="s3c">
      <title>Information Theory bounds on barcode deconvolution</title>
      <p>We note that the barcode deconvolution problem on the graph-based model we have described is analogous to the community recovery problem (<xref rid="GR235499DANC4" ref-type="bibr">Girvan and Newman 2002</xref>) in Information Theory. In particular, 3′ barcodes provide linkage information between pairs of reads. We use this linkage information to construct a graph between the reads being deconvolved with the expectation that reads from the same fragment will have a better chance of being linked than reads from different fragments. Formally, we say that two reads are connected with probability <italic>p</italic> if they are from the same fragment and probability <italic>q</italic> if they are from different fragments. Termed differently, <italic>p</italic> is the true positive rate while <italic>q</italic> is the false positive rate.</p>
      <p>For clarity, we note that this model is distinct from the model we developed previously to justify why overlaps between read clouds were likely to be useful for deconvolution.</p>
      <p>If we make a simplifying assumption that all fragments in our read cloud produce equal numbers of reads, we can use the formula determined by <xref rid="GR235499DANC6" ref-type="bibr">Hajek et al. (2016)</xref> to determine the minimum connectivity of linking 3′ barcodes necessary to deconvolve our reads. We define the number of reads per fragment as <italic>N</italic><sub><italic>r</italic></sub>/<italic>N</italic><sub><italic>f</italic></sub>, where <italic>N</italic><sub><italic>r</italic></sub> is the total number of reads in a read cloud and <italic>N</italic><sub><italic>f</italic></sub> is the number of fragments in the given read cloud.</p>
      <p>For the community recovery problem, <xref rid="GR235499DANC6" ref-type="bibr">Hajek et al. (2016)</xref> have provided a lower bound on the size of graph that can be accurately clustered given values of <italic>p</italic> and <italic>q</italic>, regardless of the algorithm used. If a graph is smaller than this threshold, it is unlikely that it will be possible to distinguish clusters from spurious edges. This boundary requires us to assume that all fragments with the same 3′ barcode produced equal numbers of reads. Using the definitions above this definition, we can apply the following inequality to read cloud deconvolution:
<disp-formula><mml:math id="UM15"><mml:mstyle><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:msub><mml:mi>N</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msqrt><mml:mi>p</mml:mi></mml:msqrt><mml:mo>−</mml:mo><mml:msqrt><mml:mi>q</mml:mi></mml:msqrt><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mstyle></mml:math></disp-formula>
</p>
      <p>Using the model developed previously and a simulation, we estimate the maximum true positive rate <italic>p</italic> to be 0.998 and we estimate the minimum false positive rate <italic>q</italic> to be <italic>p</italic>/15 = 0.067. We note that these values do not account for multiple sources of error, notably sequence homology, and should be interpreted as a best case scenario. Using these values, we can reduce the previous equation
<disp-formula><mml:math id="UM16"><mml:mn>0.549</mml:mn><mml:mstyle><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mspace width="0.4em"/><mml:msub><mml:mi>N</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mstyle></mml:math></disp-formula>
If a barcode deconvolution graph does not meet this inequality, it is unlikely that it will be possible to accurately reconstruct all clusters. More generally, this formula can be used to estimate the minimum number of reads and maximum error rates that can lead to effective barcode deconvolutions. In principle, this inequality should apply to all barcode deconvolution algorithms that can be formulated as a graph. However, different algorithms may have different values of <italic>p</italic> and <italic>q</italic>. We also note that the above formula is based on asymptotic behavior for graphs with thousands of nodes. We observed that typical deconvolution graphs in our model have fewer than 50 nodes.</p>
    </sec>
    <sec id="s3d">
      <title>Minimum sparse hashing</title>
      <p>Minerva frequently tests whether pairs of reads overlap. Many solutions to finding overlaps between reads exist, such as sequence clustering algorithms, sequence aligners, and <italic>k</italic>-mer matching. These techniques typically make trade-offs between overall performance and error rates. Since Minerva is meant to be relatively fast and can tolerate some errors, we elected to use a minimal sparse hash of <italic>k</italic>-mers to match read pairs. This technique reduces the number of unique <italic>k</italic>-mers Minerva uses to find overlaps, which reduces runtime and RAM usage.</p>
      <p>Minimum sparse hashing was originally developed independently for biological sequence search and Natural Language document search (<xref rid="GR235499DANC12" ref-type="bibr">Schleimer et al. 2003</xref>; <xref rid="GR235499DANC8" ref-type="bibr">Marçais et al. 2017</xref>) (in a Natural Language search, the technique is referred to as winnowing). While the original application of this technique in biology defined minimization as the lexicographic minimum of a set of sequences, we use a uniform random hash function to determine the minimal sequence in a set. This is a common practical enhancement recently detailed by <xref rid="GR235499DANC11" ref-type="bibr">Orenstein et al. (2016)</xref>.</p>
      <p>Minimum sparse hashing for sequences takes three parameters—a length <italic>k</italic>, a window size <italic>w</italic>, and a hash function <italic>h</italic>. Given a set <italic>K</italic> of <italic>n</italic>, <italic>n</italic> ≥ <italic>w k</italic>-mers, the min-sparse hash computes the hash <italic>h</italic> of each <italic>k</italic>-mer, then selects the <italic>k</italic>-mer with the smallest numerical hash from each consecutive set of <italic>w k</italic>-mers in <italic>K</italic>. The final set of minimizers is the unique set of <italic>k</italic>-mers generated, <italic>W</italic>. Each consecutive window shares <italic>w</italic> − 1 <italic>k</italic>-mers, so there is a good chance that each window shares the same minimum with its predecessor. Formally, <inline-formula><mml:math id="il13"><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mo movablelimits="true">min</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">∀</mml:mi><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mn>0</mml:mn><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula>. This algorithm guarantees that any pair of reads with an exact overlap of at least <italic>w</italic> + <italic>k</italic> − 1 bases will share at least one minimum sparse <italic>k</italic>-mer while drastically reducing the number of <italic>k</italic>-mers which must be stored in memory (<xref ref-type="fig" rid="GR235499DANF4">Fig. 4</xref>). In certain implementations, minimum sparse <italic>k</italic>-mers may also improve performance by allowing a <italic>k</italic>-mer that can be stored in a single 64-bit cell (<italic>k</italic> ≤ 32) of memory to represent a longer sequence.</p>
      <p>Minimum sparse <italic>k</italic>-mers are prone to false positives when presented with similar, but not identical, runs of <italic>w</italic> bases in read pairs. We measured this phenomenon by comparing all <italic>k</italic>-mers of length <italic>w</italic> from pairs of reads that share a minimum sparse hash. <xref ref-type="fig" rid="GR235499DANF4">Figure 4</xref> shows the minimum hamming distance for windows of length <italic>w</italic> between reads that share a min-sparse hash. When <italic>k</italic> is larger, the average hamming distance is smaller, though outliers persist. Small values of <italic>k</italic> produce many distant false positives. Raising <italic>k</italic> from 20 to 30 (<italic>w</italic> = 40) improved accuracy and precision to the point where false positives could be controlled using downstream techniques.</p>
      <fig id="GR235499DANF4" orientation="portrait" position="float">
        <label>Figure 4.</label>
        <caption>
          <p><italic>Top:</italic> hamming distance between windows that share minimizing <italic>k</italic>-mers, using various parameters. <italic>Bottom</italic>: number of representative minimizing <italic>k</italic>-mers per read.</p>
        </caption>
        <graphic xlink:href="116f04"/>
      </fig>
      <p>The mathematics that underlie minimum sparse hashing may also be used to efficiently approximate the overlap between sets, another important operation for Minerva. We did not use this technique in our current implementation of Minerva but plan to explore this for later versions.</p>
    </sec>
  </sec>
  <sec id="s4">
    <title>Data access</title>
    <p>All raw sequencing reads from this study have been submitted to the NCBI BioProject (<uri xlink:href="https://www.ncbi.nlm.nih.gov/bioproject">https://www.ncbi.nlm.nih.gov/bioproject</uri>) under accession number PRJNA505182. All code from this study is available in the <ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/lookup/suppl/doi:10.1101/gr.235499.118/-/DC1">Supplemental Materials</ext-link> and at <uri xlink:href="https://github.com/dcdanko/minerva_barcode_deconvolution">https://github.com/dcdanko/minerva_barcode_deconvolution</uri>.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplemental Material</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_29_1_116__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="x-zip-compressed" xlink:href="supp_gr.235499.118_supplemental_materials_IH.zip"/>
      <media xlink:role="associated-file" mimetype="image" mime-subtype="jpeg" xlink:href="supp_gr.235499.118_Supplemental_Fig_S3.jpg"/>
      <media xlink:role="associated-file" mimetype="image" mime-subtype="jpeg" xlink:href="supp_gr.235499.118_Supplemental_Fig_S1.jpg"/>
      <media xlink:role="associated-file" mimetype="image" mime-subtype="jpeg" xlink:href="supp_gr.235499.118_Supplemental_Fig_S2.jpg"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="x-zip-compressed" xlink:href="supp_gr.235499.118_Supplemental_Code.zip"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="msword" xlink:href="supp_gr.235499.118_Supplemental_Material.docx"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgments</title>
    <p>We thank Victoria Popic and her team at Illumina, Inc. for fruitful discussions on the problem and her help in benchmarking. We sincerely thank 10x Genomics, Inc. for providing us with valuable real sequencing data sets used in this study for evaluations. We also thank Stephen Williams of 10x Genomics, Inc. for coordinating the 10x Metagenomics consortium (a small group of laboratories committed to studying the role of Linked-Reads in metagenomics) in which our team participates. D.C.D. and D.M. were supported by the Tri-Institutional Training Program in Computational Biology and Medicine (CBM) funded by National Institutes of Health (NIH) grant 1T32GM083937. This work was also supported by start-up funds (Weill Cornell Medicine) to I.H. and a National Science Foundation (NSF) grant under award number IIS-1840275 to I.H. and C.M.</p>
  </ack>
  <fn-group>
    <fn fn-type="supplementary-material">
      <p>[Supplemental material is available for this article.]</p>
    </fn>
    <fn>
      <p>Article published online before print. Article, supplemental material, and publication date are at <ext-link ext-link-type="uri" xlink:href="http://www.genome.org/cgi/doi/10.1101/gr.235499.118">http://www.genome.org/cgi/doi/10.1101/gr.235499.118</ext-link>.</p>
    </fn>
    <fn>
      <p>Freely available online through the <italic>Genome Research</italic> Open Access option.</p>
    </fn>
  </fn-group>
  <ref-list>
    <title>References</title>
    <ref id="GR235499DANC1">
      <mixed-citation publication-type="journal"><string-name><surname>Blei</surname><given-names>DM</given-names></string-name>, <string-name><surname>Ng</surname><given-names>AY</given-names></string-name>, <string-name><surname>Jordan</surname><given-names>MI</given-names></string-name>. <year>2003</year><article-title>Latent Dirichlet allocation</article-title>. <source>J Mach Learn Res</source><volume>3</volume>: <fpage>993</fpage>–<lpage>1022</lpage>.</mixed-citation>
    </ref>
    <ref id="GR235499DANC2">
      <mixed-citation publication-type="confproc"><string-name><surname>Ester</surname><given-names>M</given-names></string-name>, <string-name><surname>Kriegel</surname><given-names>H-P</given-names></string-name>, <string-name><surname>Sander</surname><given-names>J</given-names></string-name>, <string-name><surname>Xu</surname><given-names>X</given-names></string-name>. <year>1996</year><article-title>A density-based algorithm for discovering clusters in large spatial databases with noise</article-title>. In <conf-name>Proceedings of the second international conference on knowledge discovery anddata mining</conf-name>, pp. <fpage>226</fpage>–<lpage>231</lpage>, <publisher-loc>Portland</publisher-loc>, <publisher-loc>OR</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR235499DANC3">
      <mixed-citation publication-type="journal"><string-name><surname>Frank</surname><given-names>JA</given-names></string-name>, <string-name><surname>Pan</surname><given-names>Y</given-names></string-name>, <string-name><surname>Tooming-Klunderud</surname><given-names>A</given-names></string-name>, <string-name><surname>Eijsink</surname><given-names>VGH</given-names></string-name>, <string-name><surname>McHardy</surname><given-names>AC</given-names></string-name>, <string-name><surname>Nederbragt</surname><given-names>AJ</given-names></string-name>, <string-name><surname>Pope</surname><given-names>PB</given-names></string-name>. <year>2016</year><article-title>Improved metagenome assemblies and taxonomic binning using long-read circular consensus sequence data</article-title>. <source>Sci Rep</source><volume>6</volume>: <fpage>25373</fpage><pub-id pub-id-type="doi">10.1038/srep25373</pub-id><pub-id pub-id-type="pmid">27156482</pub-id></mixed-citation>
    </ref>
    <ref id="GR235499DANC4">
      <mixed-citation publication-type="journal"><string-name><surname>Girvan</surname><given-names>M</given-names></string-name>, <string-name><surname>Newman</surname><given-names>MEJ</given-names></string-name>. <year>2002</year><article-title>Community structure in social and biological networks</article-title>. <source>Proc Natl Acad Sci</source><volume>99</volume>: <fpage>7821</fpage>–<lpage>7826</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.122653799</pub-id><pub-id pub-id-type="pmid">12060727</pub-id></mixed-citation>
    </ref>
    <ref id="GR235499DANC5">
      <mixed-citation publication-type="journal"><string-name><surname>Greer</surname><given-names>SU</given-names></string-name>, <string-name><surname>Nadauld</surname><given-names>LD</given-names></string-name>, <string-name><surname>Lau</surname><given-names>BT</given-names></string-name>, <string-name><surname>Chen</surname><given-names>J</given-names></string-name>, <string-name><surname>Wood-Bouwens</surname><given-names>C</given-names></string-name>, <string-name><surname>Ford</surname><given-names>JM</given-names></string-name>, <string-name><surname>Kuo</surname><given-names>CJ</given-names></string-name>, <string-name><surname>Ji</surname><given-names>HP</given-names></string-name>. <year>2017</year><article-title>Linked read sequencing resolves complex genomic rearrangements in gastric cancer metastases</article-title>. <source>Genome Med</source><volume>9</volume>: <fpage>57</fpage><pub-id pub-id-type="doi">10.1186/s13073-017-0447-8</pub-id><pub-id pub-id-type="pmid">28629429</pub-id></mixed-citation>
    </ref>
    <ref id="GR235499DANC6">
      <mixed-citation publication-type="journal"><string-name><surname>Hajek</surname><given-names>B</given-names></string-name>, <string-name><surname>Wu</surname><given-names>Y</given-names></string-name>, <string-name><surname>Xu</surname><given-names>J</given-names></string-name>. <year>2016</year><article-title>Achieving exact cluster recovery threshold via semidefinite programming: extensions</article-title>. <source>IEEE Trans Inf Theory</source><volume>62</volume>: <fpage>5918</fpage>–<lpage>5937</lpage>. <pub-id pub-id-type="doi">10.1109/TIT.2016.2594812</pub-id></mixed-citation>
    </ref>
    <ref id="GR235499DANC7">
      <mixed-citation publication-type="journal"><string-name><surname>Jain</surname><given-names>M</given-names></string-name>, <string-name><surname>Koren</surname><given-names>S</given-names></string-name>, <string-name><surname>Miga</surname><given-names>KH</given-names></string-name>, <string-name><surname>Quick</surname><given-names>J</given-names></string-name>, <string-name><surname>Rand</surname><given-names>AC</given-names></string-name>, <string-name><surname>Sasani</surname><given-names>TA</given-names></string-name>, <string-name><surname>Tyson</surname><given-names>JR</given-names></string-name>, <string-name><surname>Beggs</surname><given-names>AD</given-names></string-name>, <string-name><surname>Dilthey</surname><given-names>AT</given-names></string-name>, <string-name><surname>Fiddes</surname><given-names>IT</given-names></string-name>, <etal/><year>2018</year><article-title>Nanopore sequencing and assembly of a human</article-title><article-title>genome with ultra-long reads</article-title>. <source>Nat Biotechnol</source><volume>36</volume>: <fpage>338</fpage>–<lpage>345</lpage>. <pub-id pub-id-type="doi">10.1038/nbt.4060</pub-id></mixed-citation>
    </ref>
    <ref id="GR235499DANC8">
      <mixed-citation publication-type="journal"><string-name><surname>Marçais</surname><given-names>G</given-names></string-name>, <string-name><surname>Pellow</surname><given-names>D</given-names></string-name>, <string-name><surname>Bork</surname><given-names>D</given-names></string-name>, <string-name><surname>Orenstein</surname><given-names>Y</given-names></string-name>, <string-name><surname>Shamir</surname><given-names>R</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C</given-names></string-name>. <year>2017</year><article-title>Improving the performance of minimizers and winnowing schemes</article-title>. <source>Bioinformatics</source><volume>33</volume>: <fpage>i110</fpage>–<lpage>i117</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btx235</pub-id><pub-id pub-id-type="pmid">28881970</pub-id></mixed-citation>
    </ref>
    <ref id="GR235499DANC9">
      <mixed-citation publication-type="journal"><string-name><surname>Mason</surname><given-names>CE</given-names></string-name>, <string-name><surname>Afshinnekoo</surname><given-names>E</given-names></string-name>, <string-name><surname>Tighe</surname><given-names>S</given-names></string-name>, <string-name><surname>Wu</surname><given-names>S</given-names></string-name>, <string-name><surname>Levy</surname><given-names>S</given-names></string-name>. <year>2017</year><article-title>International standards for genomes, transcriptomes, and metagenomes</article-title>. <source>J Biomol Tech</source><volume>28</volume>: <fpage>8</fpage>–<lpage>18</lpage>. <pub-id pub-id-type="doi">10.7171/jbt.17-2801-006</pub-id><pub-id pub-id-type="pmid">28337071</pub-id></mixed-citation>
    </ref>
    <ref id="GR235499DANC10">
      <mixed-citation publication-type="journal"><string-name><surname>McIntyre</surname><given-names>ABR</given-names></string-name>, <string-name><surname>Ounit</surname><given-names>R</given-names></string-name>, <string-name><surname>Afshinnekoo</surname><given-names>E</given-names></string-name>, <string-name><surname>Prill</surname><given-names>RJ</given-names></string-name>, <string-name><surname>Hénaff</surname><given-names>E</given-names></string-name>, <string-name><surname>Alexander</surname><given-names>N</given-names></string-name>, <string-name><surname>Minot</surname><given-names>SS</given-names></string-name>, <string-name><surname>Danko</surname><given-names>D</given-names></string-name>, <string-name><surname>Foox</surname><given-names>J</given-names></string-name>, <string-name><surname>Ahsanuddin</surname><given-names>S</given-names></string-name>, <etal/><year>2017</year><article-title>Comprehensive benchmarking and ensemble approaches for metagenomic classifiers</article-title>. <source>Genome Biol</source><volume>18</volume>: <fpage>182</fpage><pub-id pub-id-type="doi">10.1186/s13059-017-1299-7</pub-id><pub-id pub-id-type="pmid">28934964</pub-id></mixed-citation>
    </ref>
    <ref id="GR235499DANC11">
      <mixed-citation publication-type="book"><string-name><surname>Orenstein</surname><given-names>Y</given-names></string-name>, <string-name><surname>Pellow</surname><given-names>D</given-names></string-name>, <string-name><surname>Marçais</surname><given-names>G</given-names></string-name>, <string-name><surname>Shamir</surname><given-names>R</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C</given-names></string-name>. <year>2016</year><article-title>Compact universal k-mer hitting sets</article-title>. In <source>Algorithms in bioinformatics, WABI 2016, lecture notes in computer science</source> (ed. <string-name><surname>Frith</surname><given-names>M</given-names></string-name>, <etal/>), Vol. <volume>9838</volume>, pp. <fpage>257</fpage>–<lpage>268</lpage>. <publisher-name>Springer</publisher-name>, <publisher-loc>New York</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR235499DANC12">
      <mixed-citation publication-type="confproc"><string-name><surname>Schleimer</surname><given-names>S</given-names></string-name>, <string-name><surname>Wilkerson</surname><given-names>DS</given-names></string-name>, <string-name><surname>Aiken</surname><given-names>A</given-names></string-name>. <year>2003</year><article-title>Winnowing: local algorithms for document fingerprinting</article-title>. In <conf-name>Proceedings of the 2003 ACM SIGMOD international conference on management of data - SIGMOD'03</conf-name>, pp. <fpage>76</fpage>–<lpage>85</lpage>, <publisher-loc>San Diego</publisher-loc>, <publisher-loc>CA</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="GR235499DANC13">
      <mixed-citation publication-type="journal"><string-name><surname>Spies</surname><given-names>N</given-names></string-name>, <string-name><surname>Weng</surname><given-names>Z</given-names></string-name>, <string-name><surname>Bishara</surname><given-names>A</given-names></string-name>, <string-name><surname>McDaniel</surname><given-names>J</given-names></string-name>, <string-name><surname>Catoe</surname><given-names>D</given-names></string-name>, <string-name><surname>Zook</surname><given-names>JM</given-names></string-name>, <string-name><surname>Salit</surname><given-names>M</given-names></string-name>, <string-name><surname>West</surname><given-names>RB</given-names></string-name>, <string-name><surname>Batzoglou</surname><given-names>S</given-names></string-name>, <string-name><surname>Sidow</surname><given-names>A</given-names></string-name>. <year>2017</year><article-title>Genome-wide reconstruction of complex structural variants using read clouds</article-title>. <source>Nat Methods</source><volume>14</volume>: <fpage>915</fpage>–<lpage>920</lpage>. <pub-id pub-id-type="doi">10.1038/nmeth.4366</pub-id><pub-id pub-id-type="pmid">28714986</pub-id></mixed-citation>
    </ref>
    <ref id="GR235499DANC14">
      <mixed-citation publication-type="journal"><string-name><surname>Wood</surname><given-names>DE</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>SL</given-names></string-name>. <year>2014</year><article-title>Kraken: ultrafast metagenomic sequence classification using exact alignments</article-title>. <source>Genome Biol</source><volume>15</volume>: <fpage>R46</fpage><pub-id pub-id-type="doi">10.1186/gb-2014-15-3-r46</pub-id><pub-id pub-id-type="pmid">24580807</pub-id></mixed-citation>
    </ref>
    <ref id="GR235499DANC15">
      <mixed-citation publication-type="journal"><string-name><surname>Zheng</surname><given-names>GXY</given-names></string-name>, <string-name><surname>Lau</surname><given-names>BT</given-names></string-name>, <string-name><surname>Schnall-Levin</surname><given-names>M</given-names></string-name>, <string-name><surname>Jarosz</surname><given-names>M</given-names></string-name>, <string-name><surname>Bell</surname><given-names>JM</given-names></string-name>, <string-name><surname>Hindson</surname><given-names>CM</given-names></string-name>, <string-name><surname>Kyriazopoulou-Panagiotopoulou</surname><given-names>S</given-names></string-name>, <string-name><surname>Masquelier</surname><given-names>DA</given-names></string-name>, <string-name><surname>Merrill</surname><given-names>L</given-names></string-name>, <string-name><surname>Terry</surname><given-names>JM</given-names></string-name>, <etal/><year>2016</year><article-title>Haplotyping germline and cancer genomes with high-throughput linked-read sequencing</article-title>. <source>Nat Biotechnol</source><volume>34</volume>: <fpage>303</fpage>–<lpage>311</lpage>. <pub-id pub-id-type="doi">10.1038/nbt.3432</pub-id><pub-id pub-id-type="pmid">26829319</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
