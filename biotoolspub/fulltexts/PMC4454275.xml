<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Algorithms Mol Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Algorithms Mol Biol</journal-id>
    <journal-title-group>
      <journal-title>Algorithms for Molecular Biology : AMB</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1748-7188</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4454275</article-id>
    <article-id pub-id-type="publisher-id">52</article-id>
    <article-id pub-id-type="doi">10.1186/s13015-015-0052-6</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>GAML: genome assembly by maximum likelihood</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Boža</surname>
          <given-names>Vladimír</given-names>
        </name>
        <address>
          <email>boza@fmph.uniba.sk</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Brejová</surname>
          <given-names>Broňa</given-names>
        </name>
        <address>
          <email>brejova@dcs.fmph.uniba.sk</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Vinař</surname>
          <given-names>Tomáš</given-names>
        </name>
        <address>
          <email>vinar@fmph.uniba.sk</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1">Faculty of Mathematics, Physics, and Informatics, Comenius University, Mlynská dolina, 842 48 Bratislava, Slovakia </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>3</day>
      <month>6</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>3</day>
      <month>6</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2015</year>
    </pub-date>
    <volume>10</volume>
    <elocation-id>18</elocation-id>
    <history>
      <date date-type="received">
        <day>8</day>
        <month>4</month>
        <year>2015</year>
      </date>
      <date date-type="accepted">
        <day>7</day>
        <month>5</month>
        <year>2015</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© Boža et al. 2015</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p>Resolution of repeats and scaffolding of shorter contigs are critical parts of genome assembly. Modern assemblers usually perform such steps by heuristics, often tailored to a particular technology for producing paired or long reads.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We propose a new framework that allows systematic combination of diverse sequencing datasets into a single assembly. We achieve this by searching for an assembly with the maximum likelihood in a probabilistic model capturing error rate, insert lengths, and other characteristics of the sequencing technology used to produce each dataset. We have implemented a prototype genome assembler GAML that can use any combination of insert sizes with Illumina or 454 reads, as well as PacBio reads. Our experiments show that we can assemble short genomes with N50 sizes and error rates comparable to ALLPATHS-LG or Cerulean. While ALLPATHS-LG and Cerulean require each a specific combination of datasets, GAML works on any combination.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>We have introduced a new probabilistic approach to genome assembly and demonstrated that this approach can lead to superior results when used to combine diverse set of datasets from different sequencing technologies. Data and software is available at <ext-link ext-link-type="uri" xlink:href="http://compbio.fmph.uniba.sk/gaml">http://compbio.fmph.uniba.sk/gaml</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Genome assembly</kwd>
      <kwd>Maximum likelihood</kwd>
      <kwd>Simulated annealing</kwd>
      <kwd>De Bruijn graphs</kwd>
      <kwd>Next generation sequencing</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2015</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>The second and third generation sequencing technologies have dramatically decreased the cost of sequencing. Nowadays, we have a surprising variety of sequencing technologies, each with its own strengths and weaknesses. For example, Illumina platforms are characteristic by low cost and high accuracy, but the reads are short. On the other hand, Pacific Biosciences offer long reads at the cost of quality and coverage. In the meantime, the cost of sequencing was brought down to the point, where it is no longer a sole domain of large sequencing centers; even small labs can experiment with cost-effective genome sequencing. As a result, it is not realistic to assume an existence of a single standard protocol for sequencing genomes of a particular size. In this paper, we propose a framework for genome assembly that allows flexible combination of datasets from different technologies in order to harness their individual strengths.</p>
    <p>Modern genome assemblers are usually based either on the overlap–layout–consensus framework (e.g. Celera [<xref ref-type="bibr" rid="CR1">1</xref>], SGA [<xref ref-type="bibr" rid="CR2">2</xref>]), or on de Bruijn graphs (e.g. Velvet [<xref ref-type="bibr" rid="CR3">3</xref>], ALLPATHS-LG [<xref ref-type="bibr" rid="CR4">4</xref>]). Both approaches can be seen as special cases of a string graph [<xref ref-type="bibr" rid="CR5">5</xref>], in which we represent sequence fragments as vertices, while edges represent possible adjacencies of fragments in the assembly. A genome assembly is simply a set of walks through this graph. The main difference between the two frameworks is how we arrive at a string graph: through detecting long overlaps of reads (overlap–layout–consensus) or through construction of de Bruijn graphs based on<italic> k</italic>-mers.</p>
    <p>However, neither of these frameworks is designed to systematically handle pair-end reads and additional heuristic steps are necessary to build larger scaffolds from assembled contigs. For example, ALLPATHS-LG [<xref ref-type="bibr" rid="CR4">4</xref>] uses libraries with different insert lengths for scaffolding contigs assembled without the use of paired read information, while Cerulean [<xref ref-type="bibr" rid="CR6">6</xref>] uses Pacific Biosystems long reads for the same purpose. Recently, the techniques of paired de Bruijn graphs [<xref ref-type="bibr" rid="CR7">7</xref>] and pathset graphs [<xref ref-type="bibr" rid="CR8">8</xref>] were developed to address paired reads systematically, however these approaches cannot combine libraries with different insert sizes.</p>
    <p>Combination of sequencing technologies with complementary strengths can help to improve assembly quality. However, it is not feasible to design new algorithms for every possible combination of datasets. Often it is possible to supplement previously developed tools with additional heuristics for new types of data. For example, PBJelly [<xref ref-type="bibr" rid="CR9">9</xref>] uses Pacific Biosystems reads solely to aid gap filling in draft assemblies. Assemblers like PacbioToCa [<xref ref-type="bibr" rid="CR10">10</xref>] or Cerulean [<xref ref-type="bibr" rid="CR6">6</xref>] use short reads to improve the quality of Pacific Biosystems reads so that they can be used within traditional assemblers. However, such approaches do not use all information contained within the datasets.</p>
    <p>We propose a new framework that allows systematic combination of diverse datasets into a single assembly, without requiring a particular type of data for specific heuristic steps. Recently, probabilistic models have been used very successfully to evaluate the quality of genome assemblers [<xref ref-type="bibr" rid="CR11">11</xref>–<xref ref-type="bibr" rid="CR13">13</xref>]. In our work, we use likelihood of a genome assembly as an optimization criterion, with the goal of finding the assembly with the highest likelihood. Even though this may not be always feasible, we demonstrate that optimization based on simulated annealing can be very successful at finding high likelihood genome assemblies.</p>
    <p>To evaluate the likelihood, we adapted a model by Ghodsi et al. [<xref ref-type="bibr" rid="CR13">13</xref>], which can capture characteristics of each dataset, such as sequencing error rate, as well as length distribution and expected orientation of paired reads (“<xref rid="Sec2" ref-type="sec">Probabilistic model for sequence assembly</xref>”). We can thus transparently combine information from multiple diverse datasets into a single score. Previously, there have been several works in this direction in much simpler models without sequencing errors [<xref ref-type="bibr" rid="CR14">14</xref>, <xref ref-type="bibr" rid="CR15">15</xref>]. These papers used likelihood to estimate repeat counts, without considering other problems, such as how exactly are repeats integrated within scaffolds.</p>
    <p>To test our framework, we have implemented a prototype genome assembler genome assembly by maximum likelihood (GAML) that can use any combination of insert sizes with Illumina or 454 reads, as well as PacBio reads. The starting point of the assembly are short contigs derived from Velvet [<xref ref-type="bibr" rid="CR3">3</xref>] with very conservative settings in order to avoid assembly errors. We then use simulated annealing to combine these short contigs into high likelihood assemblies (“<xref rid="Sec3" ref-type="sec">Finding a high likelihood assembly</xref>”). We compare our assembler to existing tools on benchmark datasets (“<xref rid="Sec4" ref-type="sec">Experimental evaluation</xref>”), demonstrating that we can assemble genomes of up to 10 MB long with N50 sizes and error rates comparable to ALLPATHS-LG or Cerulean. For larger genomes, we can start from an assembly given by a different tool and improve on the result. While ALLPATHS-LG and Cerulean each require a very specific combination of datasets, GAML works on any combination.</p>
  </sec>
  <sec id="Sec2">
    <title>Probabilistic model for sequence assembly</title>
    <p>Recently, several probabilistic models were introduced as a measure of the assembly quality [<xref ref-type="bibr" rid="CR11">11</xref>–<xref ref-type="bibr" rid="CR13">13</xref>]. All of these authors have shown that the likelihood consistently favours higher quality assemblies. In general, the probabilistic model defines the probability <inline-formula id="IEq2"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Pr (R|A)$$\end{document}</tex-math><mml:math id="M2"><mml:mrow><mml:mo>Pr</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq2.gif"/></alternatives></inline-formula> that a set of sequencing reads<italic> R</italic> is observed assuming that assembly<italic> A</italic> is the correct assembly of the genome. Since the sequencing itself is a stochastic process, it is very natural to characterize concordance of reads and an assembly by giving a probability of observing a particular read. In our work, instead of evaluating the quality of a single assembly, we use the likelihood as an optimization criterion with the goal of finding high likelihood genome assemblies. We adapt the model of Ghodsi et al. [<xref ref-type="bibr" rid="CR13">13</xref>], which we describe in this section.</p>
    <sec id="Sec40">
      <title>Basics of the likelihood model</title>
      <p>The model assumes that individual reads are independently sampled, and thus the overall likelihood is the product of likelihoods of the reads: <inline-formula id="IEq5"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Pr (R|A) = \prod _{r\in R} \Pr (r|A).$$\end{document}</tex-math><mml:math id="M4"><mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mo>∏</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq5.gif"/></alternatives></inline-formula> To make the resulting value independent of the number of reads in set<italic> R</italic>, we use as the main assembly score the log average probability of a read computed as follows: <inline-formula id="IEq7"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\text {LAP}(A|R) = (1/|R|)\sum\nolimits_{r\in R} \log \Pr (r|A).$$\end{document}</tex-math><mml:math id="M6"><mml:mrow><mml:mtext>LAP</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">/</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:msub><mml:mo>∑</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo>log</mml:mo><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq7.gif"/></alternatives></inline-formula> Note that maximizing <inline-formula id="IEq8"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Pr (R|A)$$\end{document}</tex-math><mml:math id="M8"><mml:mrow><mml:mo>Pr</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq8.gif"/></alternatives></inline-formula> is equivalent to maximizing <inline-formula id="IEq9"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\text {LAP}(A|R)$$\end{document}</tex-math><mml:math id="M10"><mml:mrow><mml:mtext>LAP</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq9.gif"/></alternatives></inline-formula>.</p>
      <p>If the reads were error-free and each position in the genome was sequenced equally likely, the probability of observing read<italic> r</italic> would simply be <inline-formula id="IEq11"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Pr (r|A)=n_r/(2L)$$\end{document}</tex-math><mml:math id="M12"><mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq11.gif"/></alternatives></inline-formula>, where <inline-formula id="IEq12"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$n_r$$\end{document}</tex-math><mml:math id="M14"><mml:msub><mml:mi>n</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq12.gif"/></alternatives></inline-formula> is the number of occurrences of the read as a substring of the assembly <italic>A</italic>,<italic> L</italic> is the length of<italic> A</italic>, and thus 2<italic>L</italic> is the length of the two strands combined [<xref ref-type="bibr" rid="CR14">14</xref>]. Ghodsi et al. [<xref ref-type="bibr" rid="CR13">13</xref>] have shown a dynamic programming computation of read probability for more complex models, accounting for sequencing errors. The algorithm marginalizes over all possible alignments of<italic> r</italic> and<italic> A</italic>, weighting each by the probability that a certain number of substitution and indel errors would happen during sequencing. In particular, the probability of a single alignment with<italic> m</italic> matching positions and<italic> s</italic> errors (substitutions and indels) is defined as <inline-formula id="IEq21"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$R(s,m)/(2L)$$\end{document}</tex-math><mml:math id="M16"><mml:mrow><mml:mi>R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq21.gif"/></alternatives></inline-formula>, where <inline-formula id="IEq22"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$R(s,m) = \epsilon ^{s}(1-\epsilon )^{m}$$\end{document}</tex-math><mml:math id="M18"><mml:mrow><mml:mi>R</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi mathvariant="italic">ϵ</mml:mi><mml:mi>s</mml:mi></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi mathvariant="italic">ϵ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>m</mml:mi></mml:msup></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq22.gif"/></alternatives></inline-formula> and <inline-formula id="IEq23"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\epsilon$$\end{document}</tex-math><mml:math id="M20"><mml:mi mathvariant="italic">ϵ</mml:mi></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq23.gif"/></alternatives></inline-formula> is the sequencing error rate.</p>
      <p>However, the full dynamic programming is too time consuming, and in practice only several best alignments contribute significantly to the overall probability. We approximate the probability of observing read<italic> r</italic> with an estimate based on a set<italic> S</italic><sub><italic>r</italic></sub> of a few best alignments of<italic> r</italic> to genome <italic>A</italic>, as obtained by one of the standard fast read alignment tools:<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \Pr (r|A)\approx \frac{\sum _{j\in S_r} R(s_j, m_j)}{2L}, \end{aligned}$$\end{document}</tex-math><mml:math id="M22" display="block"><mml:mrow><mml:mtable columnspacing="0.5ex"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>≈</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>L</mml:mi></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="13015_2015_52_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula>where<italic> m</italic><sub><italic>j</italic></sub> is the number of matches in the<italic> j</italic>th alignment, and<italic> s</italic><sub><italic>j</italic></sub> is the number of mismatches and indels implied by this alignment. The formula assumes the simplest possible error model, where insertions, deletions, and substitutions have the same probability, and ignores GC content bias. Of course, much more comprehensive read models are possible (see e.g. [<xref ref-type="bibr" rid="CR12">12</xref>]).</p>
    </sec>
    <sec id="Sec41">
      <title>Paired reads</title>
      <p>Many technologies provide paired reads produced from the opposite ends of a sequence insert of a certain size. We assume that the insert size distribution in a set of reads<italic> R</italic> can be modeled by the normal distribution with known mean<italic> μ</italic> and standard deviation<italic> σ</italic>. The probability of observing paired reads<italic> r</italic><sub>1</sub> and <italic> r</italic><sub>2</sub> can be estimated from the sets of alignments <inline-formula id="IEq36"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$S_{r_1}$$\end{document}</tex-math><mml:math id="M24"><mml:msub><mml:mi>S</mml:mi><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq36.gif"/></alternatives></inline-formula> and <inline-formula id="IEq37"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$S_{r_2}$$\end{document}</tex-math><mml:math id="M26"><mml:msub><mml:mi>S</mml:mi><mml:msub><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq37.gif"/></alternatives></inline-formula> as follows:<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \Pr (r_1, r_2|A) \approx \frac{1}{2L} \displaystyle \sum _{j_1 \in S_{r_1}} \displaystyle \sum _{j_2 \in S_{r_2}} R(s_{j_1}, m_{j_1}) R(s_{j_2}, m_{j_2}) \Pr (d(j_1, j_2)|\mu , \sigma ) \end{aligned}$$\end{document}</tex-math><mml:math id="M28" display="block"><mml:mrow><mml:mtable columnspacing="0.5ex"><mml:mtr><mml:mtd columnalign="right"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>≈</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>L</mml:mi></mml:mrow></mml:mfrac><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub></mml:mrow></mml:munder><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:msub><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub></mml:mrow></mml:munder><mml:mi>R</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>R</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>Pr</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="italic">μ</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="13015_2015_52_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula>As before, <inline-formula id="IEq38"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$m_{j_i}$$\end{document}</tex-math><mml:math id="M30"><mml:msub><mml:mi>m</mml:mi><mml:msub><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:msub></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq38.gif"/></alternatives></inline-formula> and <inline-formula id="IEq39"><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$s_{j_i}$$\end{document}</tex-math><mml:math id="M32"><mml:msub><mml:mi>s</mml:mi><mml:msub><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:msub></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq39.gif"/></alternatives></inline-formula> are the numbers of matches and sequencing errors in alignment<italic> j</italic><sub><italic>i</italic></sub> respectively, and <inline-formula id="IEq41"><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$d(j_1,j_2)$$\end{document}</tex-math><mml:math id="M34"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq41.gif"/></alternatives></inline-formula> is the distance between the two alignments as observed in the assembly. If alignments <italic> j</italic><sub>1</sub> and <italic> j</italic><sub>2</sub> are in two different contigs, or on inconsistent strands, <inline-formula id="IEq44"><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Pr (d(j_1, j_2)|\mu , \sigma )$$\end{document}</tex-math><mml:math id="M36"><mml:mrow><mml:mo>Pr</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="italic">μ</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">σ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq44.gif"/></alternatives></inline-formula> is zero.</p>
    </sec>
    <sec id="Sec42">
      <title>Reads that have no good alignment to A</title>
      <p>Some reads or read pairs do not align well to<italic> A</italic>, and as a result, their probability <inline-formula id="IEq47"><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Pr (r|A)$$\end{document}</tex-math><mml:math id="M38"><mml:mrow><mml:mo>Pr</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq47.gif"/></alternatives></inline-formula> is very low; our approximation by a set of high-scoring alignments can even yield zero probability if set<italic> S</italic><sub><italic>r</italic></sub> is empty. Such extremely low probabilities then dominate the log likelihood score. Ghodsi et al. [<xref ref-type="bibr" rid="CR13">13</xref>] propose a method that assigns such a read a score approximating the situation when the read would be added as a new contig to the assembly. We modify their formulas for variable read length, and use score <inline-formula id="IEq49"><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$e^{c + k\ell }$$\end{document}</tex-math><mml:math id="M40"><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mi>ℓ</mml:mi></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq49.gif"/></alternatives></inline-formula> for a single read of length <inline-formula id="IEq50"><alternatives><tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\ell$$\end{document}</tex-math><mml:math id="M42"><mml:mi>ℓ</mml:mi></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq50.gif"/></alternatives></inline-formula> or <inline-formula id="IEq51"><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$e^{c + k(\ell _1 + \ell _2)}$$\end{document}</tex-math><mml:math id="M44"><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ℓ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>ℓ</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq51.gif"/></alternatives></inline-formula> for a pair of reads of lengths <inline-formula id="IEq52"><alternatives><tex-math id="M45">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\ell _1$$\end{document}</tex-math><mml:math id="M46"><mml:msub><mml:mi>ℓ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq52.gif"/></alternatives></inline-formula> and <inline-formula id="IEq53"><alternatives><tex-math id="M47">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\ell _2$$\end{document}</tex-math><mml:math id="M48"><mml:msub><mml:mi>ℓ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq53.gif"/></alternatives></inline-formula>. Values<italic> k</italic> and<italic> c</italic> are scaling constants set similarly as by Ghodsi et al. [<xref ref-type="bibr" rid="CR13">13</xref>]. These alternative scores are used instead of the read probability <inline-formula id="IEq56"><alternatives><tex-math id="M49">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Pr (r|A)$$\end{document}</tex-math><mml:math id="M50"><mml:mrow><mml:mo>Pr</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq56.gif"/></alternatives></inline-formula> whenever the probability is lower than the score.</p>
    </sec>
    <sec id="Sec43">
      <title>Multiple read sets</title>
      <p>Our work is specifically targeted at a scenario, where we have multiple read sets obtained from different libraries with different insert lengths or even with different sequencing technologies. We use different model parameters for each set and compute the final score as a weighted combination of log average probabilities for individual read sets <inline-formula id="IEq57"><alternatives><tex-math id="M51">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$R_1,\dots, R_k$$\end{document}</tex-math><mml:math id="M52"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>⋯</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq57.gif"/></alternatives></inline-formula>:<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M53">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\begin{aligned} \text {LAP}(A|R_1, \dots , R_k) = w_1 \text {LAP}(A|R_1) + \dots + w_k \text {LAP}(A|R_k). \end{aligned}$$\end{document}</tex-math><mml:math id="M54" display="block"><mml:mrow><mml:mtable columnspacing="0.5ex"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>LAP</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>⋯</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mtext>LAP</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mo>⋯</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mtext>LAP</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="13015_2015_52_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula>In our experiments, we use weight <inline-formula id="IEq58"><alternatives><tex-math id="M55">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$w_i=1$$\end{document}</tex-math><mml:math id="M56"><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq58.gif"/></alternatives></inline-formula> for most datasets, but we lower the weight for Pacific Biosciences reads, because otherwise they dominate the likelihood value due to their longer length. The user can also increase or decrease weights <italic> w</italic><sub><italic>i</italic></sub> of individual sets based on their reliability.</p>
    </sec>
    <sec id="Sec44">
      <title>Penalizing spuriously joined contigs</title>
      <p>The model described above does not penalize obvious misassemblies when two contigs are joined together without any evidence in the reads. We have observed that to make the likelihood function applicable as an optimization criterion for the best assembly, we need to introduce a penalty for such spurious connections. We say that a particular base<italic> j</italic> in the assembly is <italic>connected</italic> with respect to read set<italic> R</italic> if there is a read which covers base<italic> j</italic> and starts at least<italic> k</italic> bases before<italic> j</italic>, where<italic> k</italic> is a constant specific to the read set. In this setting, we treat a pair of reads as one long read. If the assembly contains<italic> d</italic> disconnected bases with respect to<italic> d</italic>, penalty <inline-formula id="IEq68"><alternatives><tex-math id="M57">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\alpha d$$\end{document}</tex-math><mml:math id="M58"><mml:mrow><mml:mi mathvariant="italic">α</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq68.gif"/></alternatives></inline-formula> is added to the <inline-formula id="IEq69"><alternatives><tex-math id="M59">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\text {LAP}(A|R)$$\end{document}</tex-math><mml:math id="M60"><mml:mrow><mml:mtext>LAP</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq69.gif"/></alternatives></inline-formula> score (<italic>α</italic> is a scaling constant).</p>
    </sec>
    <sec id="Sec45">
      <title>Properties of different sequencing technologies</title>
      <p>Our model can be applied to different sequencing technologies by appropriate settings of model parameters. For example, Illumina technology typically produces reads of length 75–150 bp with error rate below 1% [<xref ref-type="bibr" rid="CR16">16</xref>]. For smaller genomes, we often have a high coverage of Illumina reads. Using paired reads or mate pair technologies, it is possible to prepare libraries with different insert sizes ranging up to tens of kilobases, which are instrumental in resolving longer repeats [<xref ref-type="bibr" rid="CR4">4</xref>]. To align these reads to proposed assemblies, we use Bowtie2 [<xref ref-type="bibr" rid="CR17">17</xref>]. Similarly, we can process reads by the Roche 454 technology, which are characteristic by higher read lengths (hundreds of bases).</p>
      <p>Pacific Biosciences technology produces single reads of variable length, with median length reaching several kilobases, but the error rate exceeds 10% [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR16">16</xref>]. Their length makes them ideal for resolving ambiguities in assemblies, but the high error rate makes their use challenging. To align these reads, we use BLASR [<xref ref-type="bibr" rid="CR18">18</xref>]. When we calculate the probability <inline-formula id="IEq71"><alternatives><tex-math id="M61">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Pr (r|A)$$\end{document}</tex-math><mml:math id="M62"><mml:mrow><mml:mo>Pr</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq71.gif"/></alternatives></inline-formula>, we consider not only the best alignments found by BLASR, but for each BLASR alignment, we also add probabilities of similar alignments in its neighborhood. More specifically, we run a banded version of the forward algorithm by [<xref ref-type="bibr" rid="CR13">13</xref>], considering all alignments in a band of size three around a guide alignment produced by BLASR.</p>
    </sec>
  </sec>
  <sec id="Sec3">
    <title>Finding a high likelihood assembly</title>
    <p>Complex probabilistic models, like the one described in “<xref rid="Sec2" ref-type="sec">Probabilistic model for sequence assembly</xref>”, were previously used to compare the quality of several assemblies [<xref ref-type="bibr" rid="CR11">11</xref>–<xref ref-type="bibr" rid="CR13">13</xref>]. In our work, we instead attempt to find the highest likelihood assembly directly. Of course, the search space is huge, and the objective function too complex to admit exact methods. Here, we describe an effective optimization routine based on the simulated annealing framework [<xref ref-type="bibr" rid="CR19">19</xref>].</p>
    <p>Our algorithm for finding the maximum likelihood assembly consists of three main steps: preprocessing, optimization, and postprocessing. In <italic>preprocessing</italic>, we decrease the scale of the problem by creating an assembly graph, where vertices correspond to contigs and edges correspond to possible adjacencies between contigs supported by reads. In order to make the search viable, we will restrict our search to assemblies that can be represented as a set of walks in this graph. Therefore, the assembly graph should be built in a conservative way, where the goal is not to produce long contigs, but rather to avoid errors inside them. In the <italic>optimization step</italic>, we start with an initial assembly (a set of walks in the assembly graph), and iteratively propose changes in order to optimize the assembly likelihood. Finally, <italic>postprocessing</italic> examines the resulting walks and splits some of them into shorter contigs if there are multiple equally likely possibilities of resolving ambiguities. This happens, for example, when the genome contains long repeats that cannot be resolved by any of the datasets. In the rest of this section, we discuss individual steps in more detail.</p>
    <sec id="Sec4">
      <title>Optimization by simulated annealing</title>
      <p>To find a high likelihood assembly, we use an iterative simulated annealing scheme. We start from an initial assembly <inline-formula id="IEq72"><alternatives><tex-math id="M63">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$A_0$$\end{document}</tex-math><mml:math id="M64"><mml:msub><mml:mi>A</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq72.gif"/></alternatives></inline-formula> in the assembly graph. In each iteration, we randomly choose a <italic>move</italic> that proposes a new assembly <inline-formula id="IEq73"><alternatives><tex-math id="M65">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$A'$$\end{document}</tex-math><mml:math id="M66"><mml:msup><mml:mi>A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq73.gif"/></alternatives></inline-formula> similar to the current assembly<italic> A</italic>. The next step depends on the likelihoods of the two assemblies<italic> A</italic> and <inline-formula id="IEq76"><alternatives><tex-math id="M67">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$A'$$\end{document}</tex-math><mml:math id="M68"><mml:msup><mml:mi>A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq76.gif"/></alternatives></inline-formula> as follows:<list list-type="bullet"><list-item><p>If <inline-formula id="IEq77"><alternatives><tex-math id="M69">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\text {LAP}(A'|R)\ge \text {LAP}(A|R)$$\end{document}</tex-math><mml:math id="M70"><mml:mrow><mml:mtext>LAP</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>A</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:mtext>LAP</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq77.gif"/></alternatives></inline-formula>, the new assembly <inline-formula id="IEq78"><alternatives><tex-math id="M71">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$A'$$\end{document}</tex-math><mml:math id="M72"><mml:msup><mml:mi>A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq78.gif"/></alternatives></inline-formula> is accepted and the algorithm continues with the new assembly.</p></list-item><list-item><p>If <inline-formula id="IEq79"><alternatives><tex-math id="M73">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\text {LAP}(A'|R)&lt; \text {LAP}(A|R)$$\end{document}</tex-math><mml:math id="M74"><mml:mrow><mml:mtext>LAP</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>A</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>&lt;</mml:mo><mml:mtext>LAP</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq79.gif"/></alternatives></inline-formula>, the new assembly <inline-formula id="IEq80"><alternatives><tex-math id="M75">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$A'$$\end{document}</tex-math><mml:math id="M76"><mml:msup><mml:mi>A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq80.gif"/></alternatives></inline-formula> is accepted with probability <inline-formula id="IEq81"><alternatives><tex-math id="M77">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$e^{(\text {LAP}(A'|R)-\text {LAP}(A|R))/T}$$\end{document}</tex-math><mml:math id="M78"><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>LAP</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>A</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>-</mml:mo><mml:mtext>LAP</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">/</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq81.gif"/></alternatives></inline-formula>; otherwise <inline-formula id="IEq82"><alternatives><tex-math id="M79">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$A'$$\end{document}</tex-math><mml:math id="M80"><mml:msup><mml:mi>A</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq82.gif"/></alternatives></inline-formula> is rejected and the algorithm retains the old assembly<italic> A</italic> for the next step.</p></list-item></list>Here, parameter<italic> T</italic> is called the temperature, and it changes over time. In general, the higher the temperature, the more aggressive moves are permitted. We use a simple cooling schedule, where <inline-formula id="IEq85"><alternatives><tex-math id="M81">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$T = T_0/\ln (i)$$\end{document}</tex-math><mml:math id="M82"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:mo>ln</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq85.gif"/></alternatives></inline-formula> in the<italic> i</italic>th iteration. The computation ends when there is no improvement in the likelihood for a certain number of iterations. We select the assembly with the highest LAP score as the result.</p>
      <p>To further reduce the complexity of the assembly problem, we classify all contigs as either <italic>long</italic> (more than 500 bp) or <italic>short</italic> and concentrate on ordering the long contigs correctly. The short contigs are used to fill the gaps between the long contigs. Recall that each assembly is a set of walks in the assembly graph. A contig can appear in more than one walk or can be present in a single walk multiple times.<fig id="Fig1"><label>Figure 1</label><caption><p>Examples of proposal moves.<bold> a</bold> Walk extension joining two walks.<bold> b</bold> Local improvement by addition of a new loop.<bold> c</bold> Repeat interchange.</p></caption><graphic xlink:href="13015_2015_52_Fig1_HTML" id="MO4"/></fig></p>
      <p>Proposals of new assemblies are created from the current assembly using the following moves:<list list-type="bullet"><list-item><p><italic>Walk extension</italic> (Figure <xref rid="Fig1" ref-type="fig">1</xref>a) We start from one end of an existing walk and randomly walk through the graph, in every step uniformly choosing one of the edges outgoing from the current node. Each time we encounter the end of another walk, the two walks are considered for joining. We randomly (uniformly) decide whether we join the walks, end the current walk without joining, or continue walking.</p></list-item><list-item><p><italic>Local improvement</italic> (Figure <xref rid="Fig1" ref-type="fig">1</xref>b) We optimize the part of some walk connecting two long contigs<italic> s</italic> and<italic> t</italic>. We first sample multiple random walks starting from contig<italic> s</italic>. In each walk, we only consider nodes from which contig<italic> t</italic> is reachable. Then we evaluate these random walks and choose the one that increases the likelihood the most. If the gap between contigs <italic> s</italic> and <italic> t</italic> is too big, we instead use a greedy strategy where in each step we explore multiple random extensions of the walk of length around 200 bp and pick the one with the highest score.</p></list-item><list-item><p><italic>Repeat optimization</italic> We optimize the copy number of short tandem repeats. We do this by removing or adding a loop to some walk. We precompute the list of all short loops (up to five nodes) in the graph and use it for adding loops.</p></list-item><list-item><p><italic>Joining with advice</italic> We join two walks that are spanned by long reads or paired reads with long inserts. We first select a starting walk, align all reads to this walk and randomly choose a read which has the other end outside the walk. Then we find to which node this other end belongs to and join appropriate walks. If possible, we fill the gap between the two walks using the same procedure as in the local improvement move. Otherwise we introduce a gap filled with Ns.</p></list-item><list-item><p><italic>Disconnecting</italic> We remove a path through short contigs connecting two long contigs in the same walk, resulting in two shorter walks.</p></list-item><list-item><p><italic>Repeat interchange</italic> (Figure <xref rid="Fig1" ref-type="fig">1</xref>c) If a long contig has several incoming and outgoing walks, we optimize the pairing of incoming and outgoing edges. In particular, we evaluate all moves that exchange parts of two walks through this contig. If one of these changes improves the score, we accept it and repeat this step, until the score cannot be improved at this contig.</p></list-item></list>At the beginning of each annealing step, the type of the move is chosen randomly; each type of move has its own probability. We also choose randomly the contig at which we attempt to apply the move.</p>
      <p>Note that some moves (e.g. local improvement) are very general, while other moves (e.g. joining with advice) are targeted at specific types of data. This does not contradict a general nature of our framework; it is possible to add new moves as new types of data emerge, leading to improvement when using specific datasets, while not affecting the performance when such data is unavailable.</p>
    </sec>
    <sec id="Sec5">
      <title>Preprocessing and the initial assembly</title>
      <p>To obtain the assembly graph, we use Velvet with basic error correction and unambiguous concatenation of<italic> k</italic>-mers. These settings will produce very short contigs, but will also give a much lower error rate than a regular Velvet run. GAML with the default settings then uses each long contig as a separate walk in the starting assembly for the simulated annealing procedure.</p>
    </sec>
    <sec id="Sec6">
      <title>Postprocessing</title>
      <p>The assembly obtained by the simulated annealing procedure may contain walks with no evidence for a particular configuration of incoming and outgoing edges in the assembly graph. This happens for example if a repeat is longer than the span of the longest paired read. In this case, there would be several versions of the assembly with the same or very similar likelihood score. In the postprocessing step, we therefore apply the repeat interchange move at every possible location of the assembly. If the likelihood change resulting from such a move is negligible, we break the corresponding walks into shorter contigs to avoid assembly errors.</p>
    </sec>
    <sec id="Sec7">
      <title>Fast likelihood evaluation</title>
      <p>The most time consuming step in our algorithm is evaluation of the assembly likelihood, which we perform in each iteration of simulated annealing. This step involves alignment of a large number of reads to the current assembly. However, only a small part of the assembly is changed in each annealing step, which we can use to significantly reduce the running time. Next, we describe three optimizations implemented in our software.</p>
      <p><italic>Limiting read alignment to affected regions of the assembly</italic> Since only a small portion of the assembly is affected in each step, we can keep most alignments from the previous iterations and only align reads to the regions that changed. To determine these regions, we split walks into overlapping windows, each window containing several adjacent contigs of a walk. Windows should be as short as possible, but adjacent windows should overlap by at least <inline-formula id="IEq95"><alternatives><tex-math id="M83">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$2\ell _r$$\end{document}</tex-math><mml:math id="M84"><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq95.gif"/></alternatives></inline-formula> bases, where <inline-formula id="IEq96"><alternatives><tex-math id="M85">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\ell _r$$\end{document}</tex-math><mml:math id="M86"><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq96.gif"/></alternatives></inline-formula> is the length of the longest read. As a result, each alignment is completely contained in at least one window even in the presence of extensive indels.</p>
      <p>We determine the window boundaries by a simple greedy strategy, which starts at the first contig of a walk, and then extends the window by at least <inline-formula id="IEq97"><alternatives><tex-math id="M87">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$2\ell _r$$\end{document}</tex-math><mml:math id="M88"><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq97.gif"/></alternatives></inline-formula> bases beyond the boundary of the first contig. The next window always starts at the latest possible location that ensures a sufficient overlap and extends at least <inline-formula id="IEq98"><alternatives><tex-math id="M89">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$2\ell _r$$\end{document}</tex-math><mml:math id="M90"><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq98.gif"/></alternatives></inline-formula> bases beyond the end of the previous window.</p>
      <p>For each window, we keep the position and edit distance of all alignments. In each annealing step, we identify which windows of the assembly were changed since the last iteration. We then glue together overlapping windows and align reads against these sequences.</p>
      <p>We further improve this heuristics by avoiding repeated alignments of reads to interiors of long contigs, because these parts of the assembly never change. In particular, if some window starts with a long contig, we only realign reads to the last <inline-formula id="IEq99"><alternatives><tex-math id="M91">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$2\ell _r$$\end{document}</tex-math><mml:math id="M92"><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq99.gif"/></alternatives></inline-formula> bases from that contig, and similarly we use only the first <inline-formula id="IEq100"><alternatives><tex-math id="M93">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$2\ell _r$$\end{document}</tex-math><mml:math id="M94"><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq100.gif"/></alternatives></inline-formula> bases from a long contig at the end of a window.</p>
      <p><italic>Reducing the number of reads which need to be aligned</italic> The first improvement eliminates most of the assembly from read mapping. In contrast, the second improvement reduces the set of reads which need to be realigned, because most of the reads will not align to the changed part of the assembly. We use a prefiltering step to find the reads which are likely to align to the target sequence. In the current implementation, we use the following three options for such filtering.</p>
      <p>In the simplest approach, we look for reads which contain some<italic> k</italic>-mer (usually <inline-formula id="IEq102"><alternatives><tex-math id="M95">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$k=13$$\end{document}</tex-math><mml:math id="M96"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>13</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq102.gif"/></alternatives></inline-formula>) from the target sequence. We store an index of all<italic> k</italic>-mers from all reads in a hash map. In each annealing step, we iterate over all<italic> k</italic>-mers in the target portion of the assembly and retrieve reads that contain them. This approach is very memory consuming, because the identifier of each read is stored for each<italic> k</italic>-mer from this read.</p>
      <p>In the second approach, we save memory using min-hashing [<xref ref-type="bibr" rid="CR20">20</xref>]. Given hash function<italic> h</italic>, the min-hash of set<italic> A</italic> is defined as <inline-formula id="IEq108"><alternatives><tex-math id="M97">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$m(A) = \min _{x \in A} h(x)$$\end{document}</tex-math><mml:math id="M98"><mml:mrow><mml:mi>m</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mo movablelimits="true">min</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq108.gif"/></alternatives></inline-formula>. For each read<italic> R</italic>, we calculate min-hash for the set of all its<italic> k</italic>-mers. Thus, the identifier of each read is stored in the hash table only once. In each annealing step, we calculate the min-hash for each substring of the target sequence of length <inline-formula id="IEq111"><alternatives><tex-math id="M99">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\ell _r$$\end{document}</tex-math><mml:math id="M100"><mml:msub><mml:mi>ℓ</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq111.gif"/></alternatives></inline-formula> and retrieve the reads that have the same min-hash.</p>
      <p>An important property of min-hashing is that <inline-formula id="IEq112"><alternatives><tex-math id="M101">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Pr (m(A) = m(B)) = J(A, B)$$\end{document}</tex-math><mml:math id="M102"><mml:mrow><mml:mo>Pr</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq112.gif"/></alternatives></inline-formula>, where <inline-formula id="IEq113"><alternatives><tex-math id="M103">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$J(A, B) = \frac{|A \cap B|}{|A \cup B|}$$\end{document}</tex-math><mml:math id="M104"><mml:mrow><mml:mi>J</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo>∩</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo>∪</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq113.gif"/></alternatives></inline-formula> is the Jaccard similarity of two sets<italic> A</italic> and<italic> B</italic> [<xref ref-type="bibr" rid="CR21">21</xref>]. The statement holds if the hash function<italic> h</italic> is randomly chosen from a family with the min-wise independence property, which means that for every subset of elements<italic> X</italic>, each element in<italic> X</italic> has the same chance to have the minimum hash.</p>
      <p>Note that strings with a very small edit distance have a high Jaccard similarity between their<italic> k</italic>-mer sets, and therefore a high chance that they will hash to the same value using min-hashing. We can use several min-hashes with different hash functions to improve the sensitivity of our filtering at the cost of additional memory.</p>
      <p>In our implementation, we use a simple hash function which maps<italic> k</italic>-mers into 32-bit integers. We first represent the<italic> k</italic>-mer as an integer (where each base corresponds to two bits). We then xor this integer with a random number. Finally, we perform mixing similar to the finalization of the Murmur hash function [<xref ref-type="bibr" rid="CR22">22</xref>]: <graphic xlink:href="13015_2015_52_Figa_HTML.gif" id="MO30"/></p>
      <p>We choose this finalizer because the Murmur hash function is fast and results in few collisions. It is not min-hash independent, but we found it to perform well in practice.</p>
      <p>To illustrate the specificity and sensitivity of min-hashing, we have compared our min-hashing approach with indexing all<italic> k</italic>-mers (with <inline-formula id="IEq123"><alternatives><tex-math id="M105">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$k=15$$\end{document}</tex-math><mml:math id="M106"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>15</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="13015_2015_52_Article_IEq123.gif"/></alternatives></inline-formula>) on evaluating LAP of the Allpaths-LG assembly of <italic>Staphylococus aureus</italic> (using read set SA1 described in “<xref rid="Sec4" ref-type="sec">Experimental evaluation</xref>” and aligning it to the whole <italic>S. aureus</italic> genome). Indexing all<italic> k</italic>-mers resulted in 3,659,273 alignments found by examining 21,241,474 candidate positions. Using min-hashing with three hash functions, we were able to find 3,639,625 alignments by examining 3,905,595 candidates positions. Since these reads have a low error rate,<italic> k</italic>-mer indexing retrieves practically all relevant alignments, while the sensitivity of min-hashing is approximately 99.5%. In min-hashing, 93% of examined positions yield an alignment, whereas specificity of<italic> k</italic>-mer indexing is only 17%. Also min-hashing used 30 times smaller index.</p>
      <p>Note that min-hashing was previously used in a similar context by Berlin et al. [<xref ref-type="bibr" rid="CR23">23</xref>] to find similarities among PacBio reads. However, since PacBio reads have a high error rate, the authors had to use a high number of hash functions, whereas we use only a few hash functions to filter Illumina reads, which have a low error rate.</p>
      <p>In GAML, we filter PacBio reads by a completely different approach, which is based on alignments, rather than<italic> k</italic>-mers. In particular, we take all reasonably long contigs (at least 100 bases) and align them to PacBio reads. Since BLASR can find alignments where a contig and a read overlap by only around 100 bases, we use these alignments as a filter.</p>
      <p><italic>Final computation of the likelihood score</italic> When all reads are properly aligned to the new version of the assembly, we can combine the alignments to the final score. In the implementation, we need to handle several issues, such as correctly computing likelihood for reads that align to multiple walks, assigning a special likelihood to reads without any good alignment, and avoiding double counting for reads that align to regions covered by two overlapping windows of the same walk.</p>
      <p>Again we improve the running time by considering only reads that were influenced by the most recent change. Between consecutive iterations, we keep all alignments for each sequence window of the assembly and recompute only alignments to affected windows, as outlined above. We also keep the likelihood value of each read or a read pair. Recall that the likelihood of a read or a read pair is the sum of likelihoods of individual alignments.</p>
      <p>In each iteration, we then identify which walks were removed and added. Then we calculate likelihoods of all read alignments in these walks (using stored or newly computed alignments) and we use these values to adjust the likelihood values of individual reads, subtracting for removed walks and adding for new walks. At this step, we also handle paired reads, identifying pairs of alignments in correct distance and orientation. Finally, we sum likelihoods of all reads in each dataset and compute the total likelihood score.</p>
    </sec>
  </sec>
  <sec id="Sec8">
    <title>Experimental evaluation</title>
    <p>We have implemented the algorithm proposed in the previous section in a prototype assembler GAML. At this stage, GAML can assemble small genomes (approx. 10 Mbp) in a reasonable amount of time (approximately 4 h on a single CPU and using 10GB of memory).</p>
    <p>To evaluate the quality of our assembler, we have adopted the methodology used for Genome Assembly Gold-Standard Evaluation [<xref ref-type="bibr" rid="CR24">24</xref>], using metrics on scaffolds. We have used the same genomes and libraries as Salzber et al. [<xref ref-type="bibr" rid="CR24">24</xref>] (the <italic>Staphylococus aureus</italic> genome and the human chromosome 14) and Deshpande et al. [<xref ref-type="bibr" rid="CR6">6</xref>] (the <italic>Escherichia coli</italic> genome). The overview of the datasets is shown in Table <xref rid="Tab1" ref-type="table">1</xref>. An additional dataset EC3 (long insert, low coverage) was simulated using the ART software [<xref ref-type="bibr" rid="CR25">25</xref>].</p>
    <p>We have evaluated GAML in the following scenarios:<list list-type="order"><list-item><p>combination of fragment and short insert Illumina libraries (SA1, SA2),</p></list-item><list-item><p>combination of a fragment Illumina library and a long-read high-error-rate Pacific Biosciences library (EC1, EC2),</p></list-item><list-item><p>combination of a fragment Illumina library, a long-read high-error-rate Pacific Biosciences library, and a long jump Illumina library (EC1, EC2, EC3),</p></list-item></list><table-wrap id="Tab1"><label>Table 1</label><caption><p>Properties of datasets used</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">ID</th><th align="left">References</th><th align="left">Technology</th><th align="left">Insert length (bp)</th><th align="left">Read length (bp)</th><th align="left">Coverage</th><th align="left">Error rate (%)</th></tr></thead><tbody><tr><td align="left" colspan="7"><italic>Staphylococus aureus</italic> (2.87 Mbp)</td></tr><tr><td align="left"> SA1</td><td align="left">[<xref ref-type="bibr" rid="CR24">24</xref>]</td><td align="left">Illumina</td><td char="." align="char">180</td><td char="." align="char">101</td><td align="left">90</td><td align="left">3</td></tr><tr><td align="left"> SA2</td><td align="left">[<xref ref-type="bibr" rid="CR24">24</xref>]</td><td align="left">Illumina</td><td char="." align="char">3,500</td><td char="." align="char">37</td><td align="left">90</td><td align="left">3</td></tr><tr><td align="left" colspan="7"><italic>Escherichia coli</italic> (4.64 Mbp)</td></tr><tr><td align="left"> EC1</td><td align="left">[<xref ref-type="bibr" rid="CR6">6</xref>]</td><td align="left">Illumina</td><td char="." align="char">300</td><td char="." align="char">151</td><td align="left">400</td><td align="left">0.75</td></tr><tr><td align="left"> EC2</td><td align="left">[<xref ref-type="bibr" rid="CR6">6</xref>]</td><td align="left">PacBio</td><td char="." align="char"/><td char="." align="char">4,000</td><td align="left">30</td><td align="left">13</td></tr><tr><td align="left"> EC3</td><td align="left">Simulated</td><td align="left">Illumina</td><td char="." align="char">37,000</td><td char="." align="char">75</td><td align="left">0.5</td><td align="left">4</td></tr><tr><td align="left" colspan="7"><italic>Human chromosome 14</italic> (88.29 Mbp)</td></tr><tr><td align="left"> H1</td><td align="left">[<xref ref-type="bibr" rid="CR24">24</xref>]</td><td align="left">Illumina</td><td char="." align="char">150</td><td char="." align="char">101</td><td align="left">42</td><td align="left">1</td></tr><tr><td align="left"> H2</td><td align="left">[<xref ref-type="bibr" rid="CR24">24</xref>]</td><td align="left">Illumina</td><td char="." align="char">2,500</td><td char="." align="char">101</td><td align="left">26</td><td align="left">3</td></tr><tr><td align="left"> H3</td><td align="left">[<xref ref-type="bibr" rid="CR24">24</xref>]</td><td align="left">Illumina</td><td char="." align="char">35,000</td><td char="." align="char">76</td><td align="left">1.3</td><td align="left">4.5</td></tr></tbody></table></table-wrap></p>
    <p>In each scenario, we use the short insert Illumina reads (SA1 or EC1) in Velvet with conservative settings to build the initial contigs and assembly graph. For the LAP score, we give all Illumina datasets weight 1 and the PacBio dataset weight 0.01. The results are summarized in Table <xref rid="Tab2" ref-type="table">2</xref>. Note that none of the assemblers considered here can effectively run in all three of these scenarios, except for GAML.<table-wrap id="Tab2"><label>Table 2</label><caption><p>Comparison of assembly accuracy in the first three scenarios</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Assembler</th><th align="left">Number of scaffolds</th><th align="left">Longest scaffold (kb)</th><th align="left">Longest scaffold corr. (kb)</th><th align="left">N50 (kb)</th><th align="left">Err.</th><th align="left">N50 corr. (kb)</th><th align="left">LAP</th></tr></thead><tbody><tr><td align="left" colspan="8"><italic>Staphylococus aureus</italic>, read sets SA1, SA2</td></tr><tr><td align="left"> GAML</td><td char="." align="char">28</td><td char="." align="char">1,191</td><td char="." align="char">1,191</td><td char="." align="char">514</td><td char="." align="char"><italic>0</italic></td><td char="." align="char">514</td><td align="left"><italic>−23.45</italic></td></tr><tr><td align="left"> Allpaths-LG</td><td char="." align="char"><italic>12</italic></td><td char="." align="char">1,435</td><td char="." align="char"><italic>1,435</italic></td><td char="." align="char">1,092</td><td char="." align="char"><italic>0</italic></td><td char="." align="char"><italic>1,092</italic></td><td align="left">−25.02</td></tr><tr><td align="left"> SOAPdenovo</td><td char="." align="char">99</td><td char="." align="char">518</td><td char="." align="char">518</td><td char="." align="char">332</td><td char="." align="char"><italic>0</italic></td><td char="." align="char">332</td><td align="left">−25.03</td></tr><tr><td align="left"> Velvet</td><td char="." align="char">45</td><td char="." align="char">958</td><td char="." align="char">532</td><td char="." align="char">762</td><td char="." align="char">17</td><td char="." align="char">126</td><td align="left">−25.34</td></tr><tr><td align="left"> Bambus2</td><td char="." align="char">17</td><td char="." align="char">1,426</td><td char="." align="char">1,426</td><td char="." align="char">1,084</td><td char="." align="char"><italic>0</italic></td><td char="." align="char">1,084</td><td align="left">−25.73</td></tr><tr><td align="left"> MSR-CA</td><td char="." align="char">17</td><td char="." align="char"><italic>2,411</italic></td><td char="." align="char">1,343</td><td char="." align="char"><italic>2,414</italic></td><td char="." align="char">3</td><td char="." align="char">1,022</td><td align="left">−26.26</td></tr><tr><td align="left"> ABySS</td><td char="." align="char">246</td><td char="." align="char">125</td><td char="." align="char">125</td><td char="." align="char">34</td><td char="." align="char">1</td><td char="." align="char">28</td><td align="left">−29.43</td></tr><tr><td align="left"> Cons. Velvet*</td><td char="." align="char">219</td><td char="." align="char">95</td><td char="." align="char">95</td><td char="." align="char">31</td><td char="." align="char"><italic>0</italic></td><td char="." align="char">31</td><td align="left">−30.82</td></tr><tr><td align="left"> SGA</td><td char="." align="char">456</td><td char="." align="char">286</td><td char="." align="char">286</td><td char="." align="char">208</td><td char="." align="char">1</td><td char="." align="char">208</td><td align="left">−31.80</td></tr><tr><td align="left" colspan="8"><italic>Escherichia coli</italic>, read sets EC1, EC2</td></tr><tr><td align="left"> PacbioToCA</td><td char="." align="char">55</td><td char="." align="char">1,533</td><td char="." align="char">1,533</td><td char="." align="char"><italic>957</italic></td><td char="." align="char"><italic>0</italic></td><td char="." align="char"><italic>957</italic></td><td align="left"><italic>−33.86</italic></td></tr><tr><td align="left"> GAML</td><td char="." align="char">29</td><td char="." align="char">1,283</td><td char="." align="char">1,283</td><td char="." align="char">653</td><td char="." align="char"><italic>0</italic></td><td char="." align="char">653</td><td align="left">−33.91</td></tr><tr><td align="left"> Cerulean</td><td char="." align="char"><italic>21</italic></td><td char="." align="char"><italic>1,991</italic></td><td char="." align="char"><italic>1,991</italic></td><td char="." align="char">694</td><td char="." align="char"><italic>0</italic></td><td char="." align="char">694</td><td align="left">−34.18</td></tr><tr><td align="left"> AHA</td><td char="." align="char">54</td><td char="." align="char">477</td><td char="." align="char">477</td><td char="." align="char">213</td><td char="." align="char">5</td><td char="." align="char">194</td><td align="left">−34.52</td></tr><tr><td align="left"> Cons. Velvet*</td><td char="." align="char">383</td><td char="." align="char">80</td><td char="." align="char">80</td><td char="." align="char">21</td><td char="." align="char"><italic>0</italic></td><td char="." align="char">21</td><td align="left">−36.02</td></tr><tr><td align="left" colspan="8"><italic>Escherichia coli</italic>, read sets EC1, EC2, EC3</td></tr><tr><td align="left"> GAML</td><td char="." align="char"><italic>4</italic></td><td char="." align="char"><italic>4,662</italic></td><td char="." align="char"><italic>4,661</italic></td><td char="." align="char"><italic>4,662</italic></td><td char="." align="char"><italic>3</italic></td><td char="." align="char"><italic>4,661</italic></td><td align="left"><italic>−60.38</italic></td></tr><tr><td align="left"> Celera</td><td char="." align="char">19</td><td char="." align="char">4,635</td><td char="." align="char">2,085</td><td char="." align="char">4,635</td><td char="." align="char">19</td><td char="." align="char">2,085</td><td align="left">−61.47</td></tr><tr><td align="left"> Cons. Velvet*</td><td char="." align="char">383</td><td char="." align="char">80</td><td char="." align="char">80</td><td char="." align="char">21</td><td char="." align="char"><italic>0</italic></td><td char="." align="char">21</td><td align="left">−72.03</td></tr></tbody></table><table-wrap-foot><p>For all assemblies, N50 values are based on the actual genome size. All misjoins were considered as errors and error-corrected values of N50 and contig sizes were obtained by breaking each contig at each error [<xref ref-type="bibr" rid="CR24">24</xref>]. All assemblies except for GAML and conservative Velvet were obtained from [<xref ref-type="bibr" rid="CR24">24</xref>] in the first experiment, and from [<xref ref-type="bibr" rid="CR6">6</xref>] in the second experiment.</p><p>Italic numbers in each column signify the best result.</p><p>* Velvet with conservative settings used to create the assembly graph in our method.</p></table-wrap-foot></table-wrap></p>
    <p>In the first scenario, GAML performance ranks third among zero-error assemblers in the N50 length. The best N50 assembly is given by ALLPATHS-LG [<xref ref-type="bibr" rid="CR4">4</xref>]. A closer inspection of the assemblies indicates that GAML missed several possible joins. One such miss was caused by a 4.5 kbp repeat, while the longest insert size in this dataset is 3.5 kbp. Even though in such cases it is sometimes possible to reconstruct the correct assembly thanks to small differences in the repeated regions, the difference in likelihood between alternative repeat resolutions may be very small. Another missed join was caused by a sequence coverage gap penalized in our scoring function. Perhaps in both of these cases the manually set constants may have caused GAML to be overly conservative. Otherwise, the GAML assembly is very similar to the one given by ALLPATHS-LG.</p>
    <p>In the second scenario, Pacific Biosystems reads were employed instead of jump libraries. These reads pose a significant challenge due to their high error rate, but they are very useful due to their long length. Assemblers such as Cerulean [<xref ref-type="bibr" rid="CR6">6</xref>] deploy special algorithms taylored to this technology. GAML, even though not explicitly tuned to handle Pacific Biosystems reads, builds an assembly with N50 size and the number of scaffolds very similar to that of Cerulean. In N50, both programs are outperformed by PacbioToCA [<xref ref-type="bibr" rid="CR10">10</xref>], however, this is again due to a few very long repeats (approx. 5,000 bp) in the reference genome which were not resolved by GAML or Cerulean. (Cerulean also aims to be conservative in repeat resolution.) Note that in this case, simulated annealing failed to give the highest likelihood assembly among those that we examined, so perhaps our results can be improved by tuning the likelihood optimization.</p>
    <p>The third scenario shows that the assembly quality can be hugely improved by including a long jump library, even if the coverage is really small (we have used 0.5× coverage in this experiment). This requires a flexible genome assembler; in fact, only Celera [<xref ref-type="bibr" rid="CR1">1</xref>] can process this data, but GAML assembly is clearly superior. We have attempted to run also ALLPATHS-LG, but the program could not process this combination of libraries. Compared to the previous scenario, GAML N50 size increased approximately sevenfold (or approx. fourfold compared to the best N50 from the second scenario assemblies).<table-wrap id="Tab3"><label>Table 3</label><caption><p>Improving existing assemblies of the human chromosome 14 by GAML</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Assembler</th><th align="left">Number of scaffolds</th><th align="left">Longest scaffold (kb)</th><th align="left">Longest scaffold corr. (kb)</th><th align="left">N50 (kb)</th><th align="left">Err.</th><th align="left">N50 corr. (kb)</th><th align="left">LAP</th></tr></thead><tbody><tr><td align="left" colspan="8"><italic>Human chromosome 14</italic>, starting from Velvet assembly</td></tr><tr><td align="left"> Before</td><td char="." align="char">1,081</td><td char="." align="char">4,628</td><td char="." align="char">263</td><td char="." align="char">1,190</td><td char="." align="char">9,156</td><td char="." align="char">27</td><td align="left">−138.765779</td></tr><tr><td align="left"> After</td><td char="." align="char">1,634</td><td char="." align="char">1,046</td><td char="." align="char">265</td><td char="." align="char">347</td><td char="." align="char">8,049</td><td char="." align="char">27</td><td align="left">−138.632657</td></tr><tr><td align="left"> REAPR</td><td char="." align="char">17,727</td><td char="." align="char">153</td><td char="." align="char">81</td><td char="." align="char">36</td><td char="." align="char">4,607</td><td char="." align="char">14</td><td align="left">−162.869192</td></tr><tr><td align="left" colspan="8"><italic>Human chromosome 14</italic>, starting from ALLPATHS assembly</td></tr><tr><td align="left"> Before</td><td char="." align="char">129</td><td char="." align="char">81,640</td><td char="." align="char">14,918</td><td char="." align="char">81,640</td><td char="." align="char">34</td><td char="." align="char">7,652</td><td align="left">−111.288806</td></tr><tr><td align="left"> After</td><td char="." align="char">139</td><td char="." align="char">81,640</td><td char="." align="char">14,918</td><td char="." align="char">81,640</td><td char="." align="char">33</td><td char="." align="char">7,652</td><td align="left">−111.287938</td></tr><tr><td align="left"> REAPR</td><td char="." align="char">858</td><td char="." align="char">977</td><td char="." align="char">146</td><td char="." align="char">190</td><td char="." align="char">4,230</td><td char="." align="char">17</td><td align="left">−168.024865</td></tr></tbody></table><table-wrap-foot><p> In both experiments, we use read sets H1, H2, and H3 and compare the original assembly computed by another tool with the assembly found by GAML.</p></table-wrap-foot></table-wrap></p>
  </sec>
  <sec id="Sec9">
    <title>Improving previously assembled genomes</title>
    <p>For medium and large genomes, it would take GAML too many iterations to arrive at a reasonable assembly starting from the contigs produced by Velvet with conservative settings. However, it is still possible to scale up GAML to larger genomes by using another assembler to provide a more reasonable starting point.</p>
    <p>To this end, we have to map such an input assembly to the assembly graph. We first align the assembly contigs to the Velvet contigs using NUCmer [<xref ref-type="bibr" rid="CR26">26</xref>]. We keep only alignments which cover entire Velvet contigs and have a high sequence identity. If a single input contig is aligned to several Velvet contigs, we connect these Velvet contigs to a walk in the assembly graph. The missing portions of the walk are found by dynamic programming so as to minimize the edit distance between the input contig and the walk. In the dynamic programming, we consider only edit distance of up to 10, and if we do not find a connection within this threshold, we add a corresponding number of Ns to our walk.</p>
    <p>If the input assembly differs too much from the Velvet contigs, a good mapping of the contigs to walks in the Velvet assembly graph cannot be found. In such cases, we construct the assembly graph directly from the input assembly. We first build a deBruijn graph from the contigs, and then we concatenate nodes connected by unambiguous connections.</p>
    <p>We can now use GAML to improve medium-size genome assemblies (approx. 100 Mbp). In this setting, 10,000 iterations require approximately 2 days time and 50GB of memory.</p>
    <p>We have tested this approach by using Illumina reads with three different insert sizes (H1, H2, H3) on the human chromosome 14 (data from [<xref ref-type="bibr" rid="CR24">24</xref>]; see Table <xref rid="Tab1" ref-type="table">1</xref>). We use the non-conservative Velvet assembly and the ALLPATHS assembly as our starting point. The results are shown in Table <xref rid="Tab3" ref-type="table">3</xref>.</p>
    <p>Starting from the Velvet assembly, GAML makes 787 breaks and 234 joins, reducing the error count by more than a thousand. Our joins did not introduce any new errors to the assembly. The ALLPATHS assembly has a much higher quality, and starting from this assembly, GAML decreases the number of errors only by one at the cost of introducing ten breaks. In both cases, we were able to remove some assembly errors, while not decreasing the error-corrected N50 values. Perhaps more corrections could be found if we ran our algorithm for more iterations (especially in the Velvet case).</p>
    <p>Since breaks predominate in the changes made by GAML, we have also compared our results to REAPR [<xref ref-type="bibr" rid="CR27">27</xref>], which is a tool that aligns reads to an existing assembly and then splits contigs at the positions weakly supported or even in conflict with the reads. When it concludes that some place is not a breakpoint, but should instead contain an insertion, it inserts a sequence of Ns. Note that REAPR can only process one jumping library along with an optional fragment library, and it requires the library to have a reasonable coverage (15×). Due to these constraints, we have used REAPR only with short jump library H2. For the Velvet assembly, REAPR removes significantly more errors than GAML, but at the cost of a great increase in the number of contigs and a decrease in the error-corrected N50 value. REAPR also introduces many cuts in the ALLPATHS assembly and the GAGE error checking tools report a high increase in errors. We hypothesize that this due to REAPR adding many regions of Ns in the corrected assembly, which leads to a high number of small contigs which GAGE checker cannot align correctly.</p>
  </sec>
  <sec id="Sec10" sec-type="conclusions">
    <title>Conclusion</title>
    <p>We have presented a new probabilistic approach to genome assembly, maximizing likelihood in a model capturing essential characteristics of individual sequencing technologies. It can be used on any combination of read datasets and can be easily adapted to other technologies arising in the future. We have also adapted our tool to improve existing assemblies after converting a given assembly to a set of walks.</p>
    <p>Our work opens several avenues for future research. First, we plan to further improve running time and memory and to allow the use of our tool on larger genomes. Second, the simulated annealing procedure could be improved by optimizing probabilities of individual moves or devising new types of moves. Finally, it would be interesting to explore even more detailed probabilistic models, featuring coverage biases and various sources of experimental error.</p>
  </sec>
</body>
<back>
  <ack>
    <title>Authors' contributions</title>
    <p>TV and VB have conceived the study. All authors have participated in design of algorithms and experiments. VB has implemented the software and conducted the experiments. All authors participated in manuscript preparation. All authors read and approved the final manuscript.</p>
    <sec id="d30e3560">
      <title>Acknowledgements</title>
      <p>This research was funded by VEGA Grants 1/1085/12 (BB) and 1/0719/14 (TV). The authors would like to thank Viraj Deshpande for sharing his research data. An early version of this paper was published in WABI 2014 conference proceedings.</p>
    </sec>
    <sec id="d30e3565">
      <title>Compliance with ethical guidelines</title>
      <p><bold>Competing interests</bold> The authors declare that they have no competing interests.</p>
    </sec>
  </ack>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Sutton</surname>
            <given-names>GG</given-names>
          </name>
          <name>
            <surname>Delcher</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Dew</surname>
            <given-names>IM</given-names>
          </name>
          <name>
            <surname>Fasulo</surname>
            <given-names>DP</given-names>
          </name>
          <name>
            <surname>Flanigan</surname>
            <given-names>MJ</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A whole-genome assembly of <italic>Drosophila</italic></article-title>
        <source>Science</source>
        <year>2000</year>
        <volume>287</volume>
        <issue>5461</issue>
        <fpage>2196</fpage>
        <lpage>2204</lpage>
        <pub-id pub-id-type="doi">10.1126/science.287.5461.2196</pub-id>
        <?supplied-pmid 10731133?>
        <pub-id pub-id-type="pmid">10731133</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Efficient construction of an assembly string graph using the FM-index</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>12</issue>
        <fpage>367</fpage>
        <lpage>373</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq217</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zerbino</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>5</issue>
        <fpage>821</fpage>
        <lpage>829</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.074492.107</pub-id>
        <?supplied-pmid 18349386?>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gnerre</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>MacCallum</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Przybylski</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Ribeiro</surname>
            <given-names>FJ</given-names>
          </name>
          <name>
            <surname>Burton</surname>
            <given-names>JN</given-names>
          </name>
          <name>
            <surname>Walker</surname>
            <given-names>BJ</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>High-quality draft assemblies of mammalian genomes from massively parallel sequence data</article-title>
        <source>Proc Nat Acad Sci</source>
        <year>2011</year>
        <volume>108</volume>
        <issue>4</issue>
        <fpage>1513</fpage>
        <lpage>1518</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.1017351108</pub-id>
        <?supplied-pmid 21187386?>
        <pub-id pub-id-type="pmid">21187386</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
        </person-group>
        <article-title>The fragment assembly string graph</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <issue>suppl 2</issue>
        <fpage>79</fpage>
        <lpage>85</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bti1114</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <mixed-citation publication-type="other">Deshpande V, Fung ED, Pham S, Bafna V (2013) Cerulean: a hybrid assembly using high throughput short and long reads. In: Algorithms in Bioinformatics (WABI). LNCS, vol 8126. Springer, Berlin, pp 349–363</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Medvedev</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Pham</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Chaisson</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Paired de Bruijn graphs: a novel approach for incorporating mate pair information into genome assemblers</article-title>
        <source>J Comput Biol</source>
        <year>2011</year>
        <volume>18</volume>
        <issue>11</issue>
        <fpage>1625</fpage>
        <lpage>1634</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2011.0151</pub-id>
        <?supplied-pmid 21999285?>
        <pub-id pub-id-type="pmid">21999285</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pham</surname>
            <given-names>SK</given-names>
          </name>
          <name>
            <surname>Antipov</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Sirotkin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
          <name>
            <surname>Alekseyev</surname>
            <given-names>MA</given-names>
          </name>
        </person-group>
        <article-title>Pathset graphs: a novel approach for comprehensive utilization of paired reads in genome assembly</article-title>
        <source>J Comput Biol</source>
        <year>2013</year>
        <volume>20</volume>
        <issue>4</issue>
        <fpage>359</fpage>
        <lpage>371</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2012.0098</pub-id>
        <?supplied-pmid 22803627?>
        <pub-id pub-id-type="pmid">22803627</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>English</surname>
            <given-names>AC</given-names>
          </name>
          <name>
            <surname>Richards</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Han</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Vee</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Qu</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mind the gap: upgrading genomes with Pacific Biosciences RS long-read sequencing technology</article-title>
        <source>PLoS One</source>
        <year>2012</year>
        <volume>7</volume>
        <issue>11</issue>
        <fpage>47768</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0047768</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Schatz</surname>
            <given-names>MC</given-names>
          </name>
          <name>
            <surname>Walenz</surname>
            <given-names>BP</given-names>
          </name>
          <name>
            <surname>Martin</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Howard</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Ganapathy</surname>
            <given-names>G</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Hybrid error correction and <italic>de novo</italic> assembly of single-molecule sequencing reads</article-title>
        <source>Nat Biotechnol</source>
        <year>2012</year>
        <volume>30</volume>
        <issue>7</issue>
        <fpage>693</fpage>
        <lpage>700</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.2280</pub-id>
        <?supplied-pmid 22750884?>
        <pub-id pub-id-type="pmid">22750884</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rahman</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>CGAL: computing genome assembly likelihoods</article-title>
        <source>Genome Biol</source>
        <year>2013</year>
        <volume>14</volume>
        <issue>1</issue>
        <fpage>8</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2013-14-1-r8</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Clark</surname>
            <given-names>SC</given-names>
          </name>
          <name>
            <surname>Egan</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Frazier</surname>
            <given-names>PI</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>ALE: a generic assembly likelihood evaluation framework for assessing the accuracy of genome and metagenome assemblies</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <issue>4</issue>
        <fpage>435</fpage>
        <lpage>443</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts723</pub-id>
        <?supplied-pmid 23303509?>
        <pub-id pub-id-type="pmid">23303509</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ghodsi</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hill</surname>
            <given-names>CM</given-names>
          </name>
          <name>
            <surname>Astrovskaya</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Lin</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Sommer</surname>
            <given-names>DD</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>De novo likelihood-based measures for comparing genome assemblies</article-title>
        <source>BMC Res Notes</source>
        <year>2013</year>
        <volume>6</volume>
        <issue>1</issue>
        <fpage>334</fpage>
        <pub-id pub-id-type="doi">10.1186/1756-0500-6-334</pub-id>
        <?supplied-pmid 23965294?>
        <pub-id pub-id-type="pmid">23965294</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Medvedev</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Brudno</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Maximum likelihood genome assembly</article-title>
        <source>J Comput Biol</source>
        <year>2009</year>
        <volume>16</volume>
        <issue>8</issue>
        <fpage>1101</fpage>
        <lpage>1116</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2009.0047</pub-id>
        <?supplied-pmid 19645596?>
        <pub-id pub-id-type="pmid">19645596</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <mixed-citation publication-type="other">Varma A, Ranade A, Aluru S (2011) An improved maximum likelihood formulation for accurate genome assembly. In: Computational Advances in Bio and Medical Sciences (ICCABS 2011). IEEE, pp 165–170</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Quail</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Smith</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Coupland</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Otto</surname>
            <given-names>TD</given-names>
          </name>
          <name>
            <surname>Harris</surname>
            <given-names>SR</given-names>
          </name>
          <name>
            <surname>Connor</surname>
            <given-names>TR</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A tale of three next generation sequencing platforms: comparison of Ion Torrent, Pacific Biosciences and Illumina MiSeq sequencers</article-title>
        <source>BMC Genomics</source>
        <year>2012</year>
        <volume>13</volume>
        <issue>1</issue>
        <fpage>341</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2164-13-341</pub-id>
        <?supplied-pmid 22827831?>
        <pub-id pub-id-type="pmid">22827831</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Fast gapped-read alignment with Bowtie 2</article-title>
        <source>Nat Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <issue>4</issue>
        <fpage>357</fpage>
        <lpage>359</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1923</pub-id>
        <?supplied-pmid 22388286?>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chaisson</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Mapping single molecule sequencing reads using basic local alignment with successive refinement (BLASR): application and theory</article-title>
        <source>BMC Bioinform</source>
        <year>2012</year>
        <volume>13</volume>
        <issue>1</issue>
        <fpage>238</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-13-238</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Eglese</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Simulated annealing: a tool for operational research</article-title>
        <source>Eur J Oper Res</source>
        <year>1990</year>
        <volume>46</volume>
        <issue>3</issue>
        <fpage>271</fpage>
        <lpage>281</lpage>
        <pub-id pub-id-type="doi">10.1016/0377-2217(90)90001-R</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <mixed-citation publication-type="other">Broder AZ (1997) On the resemblance and containment of documents. In: Proceedings of the Compression and Complexity of Sequences 1997. IEEE, pp 21–29</mixed-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Broder</surname>
            <given-names>AZ</given-names>
          </name>
          <name>
            <surname>Charikar</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Frieze</surname>
            <given-names>AM</given-names>
          </name>
          <name>
            <surname>Mitzenmacher</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Min-wise independent permutations</article-title>
        <source>J Comput Syst Sci</source>
        <year>2000</year>
        <volume>60</volume>
        <issue>3</issue>
        <fpage>630</fpage>
        <lpage>659</lpage>
        <pub-id pub-id-type="doi">10.1006/jcss.1999.1690</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <mixed-citation publication-type="other">Appleby A (2008) MurmurHash. <ext-link ext-link-type="uri" xlink:href="https://code.google.com/p/smhasher/wiki/MurmurHash">https://code.google.com/p/smhasher/wiki/MurmurHash</ext-link></mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <mixed-citation publication-type="other">Berlin K, Koren S, Chin CS, Drake J, Landolin JM, Phillippy AM (2014) Assembling large genomes with single-molecule sequencing and locality sensitive hashing. bioRxiv, <ext-link ext-link-type="uri" xlink:href="http://biorxiv.org/content/early/2014/08/14/008003">008003</ext-link></mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
          <name>
            <surname>Zimin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Puiu</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Magoc</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>GAGE: a critical evaluation of genome assemblies and assembly algorithms</article-title>
        <source>Genome Res</source>
        <year>2012</year>
        <volume>22</volume>
        <issue>3</issue>
        <fpage>557</fpage>
        <lpage>567</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.131383.111</pub-id>
        <?supplied-pmid 22147368?>
        <pub-id pub-id-type="pmid">22147368</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Huang</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>JR</given-names>
          </name>
          <name>
            <surname>Marth</surname>
            <given-names>GT</given-names>
          </name>
        </person-group>
        <article-title>ART: a next-generation sequencing read simulator</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>4</issue>
        <fpage>593</fpage>
        <lpage>594</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr708</pub-id>
        <?supplied-pmid 22199392?>
        <pub-id pub-id-type="pmid">22199392</pub-id>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Delcher</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Carlton</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Fast algorithms for large-scale genome alignment and comparison</article-title>
        <source>Nucleic Acids Res</source>
        <year>2002</year>
        <volume>30</volume>
        <issue>11</issue>
        <fpage>2478</fpage>
        <lpage>2483</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/30.11.2478</pub-id>
        <?supplied-pmid 12034836?>
        <pub-id pub-id-type="pmid">12034836</pub-id>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hunt</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kikuchi</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Sanders</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Newbold</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Berriman</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Otto</surname>
            <given-names>TD</given-names>
          </name>
        </person-group>
        <article-title>Reapr: a universal tool for genome assembly evaluation</article-title>
        <source>Genome Biol</source>
        <year>2013</year>
        <volume>14</volume>
        <issue>5</issue>
        <fpage>47</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2013-14-5-r47</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
