<?DTDIdentifier.IdentifierValue -//ES//DTD journal article DTD version 5.6.0//EN//XML?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName art560.dtd?>
<?SourceDTD.Version 5.6.0?>
<?ConverterInfo.XSLTName elsevier2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<?origin publisher?>
<?FILEmeta_MEX101437 xml ?>
<?FILEmain xml ?>
<?FILEmain pdf ?>
<?FILEgr1 jpg ?>
<?FILEgr2 jpg ?>
<?FILEgr3 jpg ?>
<?FILEgr4 jpg ?>
<?FILEfx1 jpg ?>
<?FILEfx2 jpg ?>
<?FILEfx3 jpg ?>
<?FILEsi1 svg ?>
<?FILEsi2 svg ?>
<?FILEsi3 svg ?>
<?FILEsi4 svg ?>
<?FILEsi5 svg ?>
<?FILEsi6 svg ?>
<?FILEsi7 svg ?>
<?FILEsi8 svg ?>
<?FILEsi9 svg ?>
<?FILEsi10 svg ?>
<?FILEsi11 svg ?>
<?FILEsi12 svg ?>
<?FILEsi13 svg ?>
<?FILEsi14 svg ?>
<?FILEsi15 svg ?>
<?FILEsi16 svg ?>
<?FILEsi17 svg ?>
<?FILEsi18 svg ?>
<?FILEsi19 svg ?>
<?FILEsi20 svg ?>
<?FILEsi21 svg ?>
<?FILEsi22 svg ?>
<?FILEsi23 svg ?>
<?FILEsi24 svg ?>
<?FILEsi25 svg ?>
<?FILEsi26 svg ?>
<?FILEsi27 svg ?>
<?FILEsi28 svg ?>
<?FILEsi29 svg ?>
<?FILEsi30 svg ?>
<?FILEsi31 svg ?>
<?FILEsi32 svg ?>
<?FILEsi33 svg ?>
<?FILEsi34 svg ?>
<?FILEsi35 svg ?>
<?FILEsi36 svg ?>
<?FILEsi37 svg ?>
<?FILEsi38 svg ?>
<?FILEsi39 svg ?>
<?FILEsi40 svg ?>
<?FILEsi41 svg ?>
<?FILEsi42 svg ?>
<?FILEsi43 svg ?>
<?FILEsi44 svg ?>
<?FILEsi45 svg ?>
<?FILEsi46 svg ?>
<?FILEsi47 svg ?>
<?FILEsi48 svg ?>
<?FILEsi49 svg ?>
<?FILEsi50 svg ?>
<?FILEsi51 svg ?>
<?FILEsi52 svg ?>
<?FILEsi53 svg ?>
<?FILEsi54 svg ?>
<?FILEsi55 svg ?>
<?FILEsi56 svg ?>
<?FILEsi57 svg ?>
<?FILEsi58 svg ?>
<?FILEsi59 svg ?>
<?FILEsi60 svg ?>
<?FILEsi61 svg ?>
<?FILEsi62 svg ?>
<?FILEsi63 svg ?>
<?FILEsi64 svg ?>
<?FILEsi65 svg ?>
<?FILEsi66 svg ?>
<?FILEsi67 svg ?>
<?FILEsi68 svg ?>
<?FILEsi69 svg ?>
<?FILEsi70 svg ?>
<?FILEsi71 svg ?>
<?FILEsi72 svg ?>
<?FILEsi73 svg ?>
<?FILEsi74 svg ?>
<?FILEsi75 svg ?>
<?FILEsi76 svg ?>
<?FILEsi77 svg ?>
<?FILEsi78 svg ?>
<?FILEsi79 svg ?>
<?FILEsi80 svg ?>
<?FILEsi81 svg ?>
<?FILEsi82 svg ?>
<?FILEsi83 svg ?>
<?FILEsi84 svg ?>
<?FILEsi85 svg ?>
<?FILEsi86 svg ?>
<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">MethodsX</journal-id>
    <journal-id journal-id-type="iso-abbrev">MethodsX</journal-id>
    <journal-title-group>
      <journal-title>MethodsX</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2215-0161</issn>
    <publisher>
      <publisher-name>Elsevier</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8374653</article-id>
    <article-id pub-id-type="pii">S2215-0161(21)00230-2</article-id>
    <article-id pub-id-type="doi">10.1016/j.mex.2021.101437</article-id>
    <article-id pub-id-type="publisher-id">101437</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Method Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>BSF-skeleton: A template for parallelization of iterative numerical algorithms on cluster computing systems</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="au0001">
        <name>
          <surname>Sokolinsky</surname>
          <given-names>Leonid B.</given-names>
        </name>
        <email>leonid.sokolinsky@susu.ru</email>
        <xref rid="cor0001" ref-type="corresp">⁎</xref>
      </contrib>
      <aff id="aff0001">South Ural State University, 76, Lenin prospekt, Chelyabinsk, Russian Federation, 454080</aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor0001"><label>⁎</label>Corresponding author's. <email>leonid.sokolinsky@susu.ru</email></corresp>
    </author-notes>
    <pub-date pub-type="pmc-release">
      <day>03</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on <pub-date
						pub-type="epub">.-->
    <pub-date pub-type="collection">
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>03</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <volume>8</volume>
    <elocation-id>101437</elocation-id>
    <history>
      <date date-type="received">
        <day>4</day>
        <month>1</month>
        <year>2021</year>
      </date>
      <date date-type="accepted">
        <day>1</day>
        <month>7</month>
        <year>2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2021 The Author(s). Published by Elsevier B.V.</copyright-statement>
      <copyright-year>2021</copyright-year>
      <copyright-holder/>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).</license-p>
      </license>
    </permissions>
    <abstract id="abs0001">
      <p>This article describes a method for creating applications for cluster computing systems using the parallel BSF-skeleton based on the original BSF (Bulk Synchronous Farm) model of parallel computations developed by the author earlier. This model uses the master/slave paradigm. The main advantage of the BSF model is that it allows to estimate the scalability of a parallel algorithm before its implementation. Another important feature of the BSF model is the representation of problem data in the form of lists that greatly simplifies the logic of building applications. The BSF-skeleton is designed for creating parallel programs in C++ using the MPI library. The scope of the BSF-skeleton is iterative numerical algorithms of high computational complexity. The BSF-skeleton has the following distinctive features.</p>
      <p>• The BSF-skeleton completely encapsulates all aspects that are associated with parallelizing a program.</p>
      <p>• The BSF-skeleton allows error-free compilation at all stages of application development.</p>
      <p>• The BSF-skeleton supports OpenMP programming model and workflows.</p>
    </abstract>
    <abstract abstract-type="graphical" id="abs0003a">
      <title>Graphical abstract</title>
      <p>
        <fig id="fig0006" position="anchor">
          <alt-text id="alttx001a">Image, graphical abstract</alt-text>
          <graphic xlink:href="fx1"/>
        </fig>
      </p>
    </abstract>
    <kwd-group id="keys0001">
      <title>Keywords</title>
      <kwd>Parallel computation model</kwd>
      <kwd>C++</kwd>
      <kwd>MPI</kwd>
      <kwd>Master/slave framework</kwd>
      <kwd>Higher-order function</kwd>
      <kwd>Map/Reduce</kwd>
      <kwd>Scalability boundary prediction</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <p id="para0001">Specifications Table<table-wrap position="float" id="utbl0001"><table frame="hsides" rules="groups"><thead><tr><th valign="top">Subject Area</th><th valign="top">Computer Science</th></tr></thead><tbody><tr><td valign="top">More specific subject area</td><td valign="top">Parallel programming</td></tr><tr><td valign="top">Method name</td><td valign="top">BSF parallel skeleton</td></tr><tr><td valign="top">Name and reference of original method</td><td valign="top">Bulk Synchronous Farm: parallel computation modelL.B. Sokolinsky, BSF: a parallel computation model for scalability estimation of iterative numerical algorithms on cluster computing systems, Journal of Parallel and Distributed Computing, 149 (2021): pp. 193–206. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.jpdc.2020.12.009" id="interref0001">https://doi.org/10.1016/j.jpdc.2020.12.009</ext-link>.</td></tr><tr><td valign="top">Resource availability</td><td valign="top">Source code is freely available at <ext-link ext-link-type="uri" xlink:href="https://github.com/leonid-sokolinsky/BSF-skeleton" id="interref0002">https://github.com/leonid-sokolinsky/BSF-skeleton</ext-link></td></tr></tbody></table></table-wrap></p>
  <sec id="sec0001">
    <title>Method details</title>
    <p id="para0002">A parallel skeleton is a programming construct, which abstracts a pattern of parallel computation and interaction <xref rid="bib0001" ref-type="bibr">[1]</xref>. The BSF-skeleton extends <italic>farm</italic> skeleton based on the master/slave paradigm. The <italic>farm</italic> skeleton and the master/slave paradigm are discussed in a large number of papers (see, for example, <xref rid="bib0002" ref-type="bibr">[2]</xref>, <xref rid="bib0003" ref-type="bibr">[3]</xref>, <xref rid="bib0004" ref-type="bibr">[4]</xref>, <xref rid="bib0005" ref-type="bibr">[5]</xref>). A distinctive feature of the BSF-skeleton is that it combines <italic>farm, map</italic>, and <italic>reduce</italic> algorithmic skeletons. The theoretical basis of the BSF-skeleton is the BSF (Bulk Synchronous Farm) model of parallel computations <xref rid="bib0006" ref-type="bibr">[6]</xref>. The BSF-skeleton uses the master/worker (master/slave) paradigm to organize interaction between MPI processes (see <xref rid="fig0001" ref-type="fig">Fig. 1</xref>). This means that worker processes can only exchange messages with the master process. To use the BSF-skeleton, you must represent your algorithm in the form of operations on lists using the higher-order functions <italic>Map</italic> and <italic>Reduce</italic>
<xref rid="bib0007" ref-type="bibr">[7]</xref>. The higher-order function <inline-formula><mml:math id="M1" altimg="si35.svg"><mml:mrow><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>p</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> applies the function <italic>f</italic> to each element of list <inline-formula><mml:math id="M2" altimg="si36.svg"><mml:mrow><mml:mi>A</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula> converting it to the list <inline-formula><mml:math id="M3" altimg="si37.svg"><mml:mrow><mml:mi>B</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mo>[</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula>. The higher-order function <inline-formula><mml:math id="M4" altimg="si38.svg"><mml:mrow><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mo>⊕</mml:mo><mml:mo>,</mml:mo><mml:mi>B</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> taking an associative binary operation <inline-formula><mml:math id="M5" altimg="si39.svg"><mml:mo>⊕</mml:mo></mml:math></inline-formula> and a list <inline-formula><mml:math id="M6" altimg="si40.svg"><mml:mrow><mml:mi>B</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula> as parameters calculates the element <inline-formula><mml:math id="M7" altimg="si41.svg"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⊕</mml:mo><mml:mo>…</mml:mo><mml:mo>⊕</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. One should use <xref rid="tbl0006" ref-type="table">Algorithm 1</xref> as a template. Let us comment on <xref rid="tbl0006" ref-type="table">Algorithm 1</xref>. The variable <italic>i</italic> denotes the iteration number; <inline-formula><mml:math id="M8" altimg="si12.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> is an initial approximation; <inline-formula><mml:math id="M9" altimg="si11.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> is the <italic>i</italic>-th approximation (the approximation can be a number, a vector, or any other data structure); <italic>A</italic> is the list of elements of a certain set <inline-formula><mml:math id="M10" altimg="si42.svg"><mml:mi mathvariant="double-struck">A</mml:mi></mml:math></inline-formula>, which represents the source data of the problem; <inline-formula><mml:math id="M11" altimg="si43.svg"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mi mathvariant="double-struck">A</mml:mi><mml:mo>→</mml:mo><mml:mi mathvariant="double-struck">B</mml:mi></mml:mrow></mml:math></inline-formula> is a parameterized user function (the parameter <italic>x</italic> is the current approximation) that maps the set <inline-formula><mml:math id="M12" altimg="si42.svg"><mml:mi mathvariant="double-struck">A</mml:mi></mml:math></inline-formula> to a set <inline-formula><mml:math id="M13" altimg="si44.svg"><mml:mi mathvariant="double-struck">B</mml:mi></mml:math></inline-formula>; <italic>B</italic> is a list of elements of the set <inline-formula><mml:math id="M14" altimg="si44.svg"><mml:mi mathvariant="double-struck">B</mml:mi></mml:math></inline-formula> calculated by applying the function <inline-formula><mml:math id="M15" altimg="si45.svg"><mml:msub><mml:mi>F</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> to each element of the list <italic>A</italic>; <inline-formula><mml:math id="M16" altimg="si39.svg"><mml:mo>⊕</mml:mo></mml:math></inline-formula> is an binary associative operation on the set <inline-formula><mml:math id="M17" altimg="si44.svg"><mml:mi mathvariant="double-struck">B</mml:mi></mml:math></inline-formula>.<fig id="fig0001"><label>Fig. 1</label><caption><p>Interaction of <inline-formula><mml:math id="M18" altimg="si1.svg"><mml:mrow><mml:mi>K</mml:mi><mml:mo linebreak="goodbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> MPI processes in the BSF-skeleton.</p></caption><alt-text id="alt0001">Fig 1</alt-text><graphic xlink:href="gr1"/></fig></p>
    <p id="para0003">Step 1 reads input data of the problem and an initial approximation. Step 2 assigns the zero value to the iteration counter <italic>i</italic>. Step 3 calculates the list <italic>B</italic> by applying the higher-order function <inline-formula><mml:math id="M19" altimg="si46.svg"><mml:mrow><mml:mtext>Map</mml:mtext><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="normal">F</mml:mi><mml:msup><mml:mrow><mml:mi mathvariant="normal">x</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="normal">i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal">A</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>. Step 4 assigns the result of the higher-order function <inline-formula><mml:math id="M20" altimg="si47.svg"><mml:mrow><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mo>⊕</mml:mo><mml:mo>,</mml:mo><mml:mi>B</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> to the intermediate variable <inline-formula><mml:math id="M21" altimg="si48.svg"><mml:mrow><mml:mi mathvariant="normal">s</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">B</mml:mi></mml:mrow></mml:math></inline-formula>. Step 5 invocates the user function <italic>Compute</italic> that calculates the next approximation <inline-formula><mml:math id="M22" altimg="si49.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> taking two parameters: the current approximation <inline-formula><mml:math id="M23" altimg="si11.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> and the result <italic>s</italic> of the higher-order function <italic>Reduce</italic>. Step 6 increases the iteration counter <italic>i</italic> by one. Step 7 checks a termination criteria by invocating the Boolean user function <italic>StopCond</italic>, which takes two parameters: the new approximation <inline-formula><mml:math id="M24" altimg="si11.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> and the previous approximation <inline-formula><mml:math id="M25" altimg="si49.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula>. If <italic>StopCond</italic> returns true, the algorithm outputs <inline-formula><mml:math id="M26" altimg="si11.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> as an approximate problem solution and stops working. Otherwise, the control is passed to Step 3 starting the next iteration.</p>
    <p id="para0004">The BSF-skeleton automatically parallelizes <xref rid="tbl0006" ref-type="table">Algorithm 1</xref> by splitting the list <italic>A</italic> into <italic>K</italic> sublists of equal length (<inline-formula><mml:math id="M27" altimg="si50.svg"><mml:mrow><mml:mo>±</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>):<disp-formula id="ueqn0001"><inline-graphic xlink:href="fx2.gif"/></disp-formula>where <italic>K</italic> is the number of worker processes and <inline-graphic xlink:href="fx3.gif"/> denotes the operation of list concatenation. This uses the parallelization scheme shown in <xref rid="fig0002" ref-type="fig">Fig. 2</xref>.<fig id="fig0002"><label>Fig. 2</label><caption><p>BSF-skeleton parallelization schema.</p></caption><alt-text id="alt0002">Fig 2</alt-text><graphic xlink:href="gr2"/></fig></p>
    <p id="para0005">The result is the parallel <xref rid="tbl0007" ref-type="table">Algorithm 2</xref>. It includes <inline-formula><mml:math id="M28" altimg="si51.svg"><mml:mrow><mml:mi>K</mml:mi><mml:mspace width="0.28em"/><mml:mo linebreak="goodbreak">+</mml:mo><mml:mspace width="0.28em"/><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> parallel processes: one master process and <italic>K</italic> worker processes. In Step 2, the master process sends the current approximation <inline-formula><mml:math id="M29" altimg="si11.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> to all worker processes. After that, every <italic>j</italic>-th worker process independently applies higher-order function <italic>Map</italic> and <italic>Reduce</italic> to its sublist (the steps 3 and 4). In the steps 3 and 4, the master process is idle. In Step 5, all worker processes send the partial foldings <inline-formula><mml:math id="M30" altimg="si52.svg"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to the master process. In the steps 6-9, the master process performs the following actions: executes the higher-order function <italic>Reduce</italic> over the list of partial foldings <inline-formula><mml:math id="M31" altimg="si53.svg"><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula>; invocates the user function <italic>Compute</italic> that calculates the next approximation; checks the termination criteria by using the Boolean user function <italic>StopCond</italic> and assigns its result to the Boolean variable <italic>exit</italic>. In the steps 6-9, the worker processes are idle. In Step 10, the master process sends the <italic>exit</italic> value to all worker processes. If the <italic>exit</italic> value is false, the master process and worker processes go to the next iteration, otherwise the master processes outputs the result and the computation stops. Note that, in the Steps 2 and 10, all processes perform the implicit global synchronization.</p>
  </sec>
  <sec id="sec0002">
    <title>Source code structure of BSF-skeleton</title>
    <p id="para0006">The BSF-skeleton is a compilable but not executable set of files. This set is divided into two groups: files with the “<italic>BSF</italic>” prefix contain problem-independent code and are not subject to changes by the user; files with the “<italic>Problem</italic>” prefix are intended for filling in problem-dependent parts of the program by the user. Descriptions of all source code files are given in <xref rid="tbl0001" ref-type="table">Table 1</xref>.<table-wrap position="float" id="tbl0001"><label>Table 1</label><caption><p>Source code files of the BSF-skeleton.</p></caption><alt-text id="alt0005">Table 1</alt-text><table frame="hsides" rules="groups"><thead><tr><th valign="top">File</th><th valign="top">Description</th></tr></thead><tbody><tr><td colspan="2" align="center" valign="top"><italic><bold>Problem-independent code</bold></italic></td></tr><tr><td valign="top"><italic>BSF-Code.cpp</italic></td><td valign="top">Implementations of the <italic>main</italic> function and all problem-independent functions</td></tr><tr><td valign="top"><italic>BSF-Data.h</italic></td><td valign="top">Problem-independent variables and data structures</td></tr><tr><td valign="top"><italic>BSF-Forwards.h</italic></td><td valign="top">Declarations of the problem-independent functions</td></tr><tr><td valign="top"><italic>BSF-Include.h</italic></td><td valign="top">The inclusion of problem-independent libraries</td></tr><tr><td valign="top"><italic>BSF-SkeletonVariables.h</italic></td><td valign="top">Definitions of the skeleton variables (see Section “Skeleton variables”)</td></tr><tr><td valign="top"><italic>BSF-ProblemFunctions.h</italic></td><td valign="top">Declarations of the problem-dependent BSF functions (see Section “Predefined problem-dependent BSF functions (prefix PC_bsf_)”)</td></tr><tr><td valign="top"><italic>BSF-Types.h</italic></td><td valign="top">Definitions of problem-independent types</td></tr><tr><td colspan="2" align="center" valign="top"><italic><bold>Problem-dependent code</bold></italic></td></tr><tr><td valign="top"><italic>Problem-bsfCode.cpp</italic></td><td valign="top">Implementations of the problem-dependent BSF functions (see Section “Predefined problem-dependent BSF functions (prefix PC_bsf_)”)</td></tr><tr><td valign="top"><italic>Problem-bsfParameters.h</italic></td><td valign="top">BSF-skeleton parameters (see Section “BSF-skeleton parameters”)</td></tr><tr><td valign="top"><italic>Problem-bsfTypes.h</italic></td><td valign="top">Predefined BSF types (see Section “Predefined problem-depended BSF types”)</td></tr><tr><td valign="top"><italic>Problem-Data.h</italic></td><td valign="top">Problem-dependent variables and data structures</td></tr><tr><td valign="top"><italic>Problem-Forwards.h</italic></td><td valign="top">Declarations of the problem-dependent functions</td></tr><tr><td valign="top"><italic>Problem-Include.h</italic></td><td valign="top">Inclusion of problem-dependent libraries</td></tr><tr><td valign="top"><italic>Problem-Parameters.h</italic></td><td valign="top">Parameters of the problem</td></tr><tr><td valign="top"><italic>Problem-Types.h</italic></td><td valign="top">Problem types</td></tr></tbody></table></table-wrap></p>
    <p id="para0007">The dependency graph of the source code files by the directive #<italic>include</italic> is shown in <xref rid="fig0003" ref-type="fig">Fig. 3</xref>. The gray rectangles indicate the code files that do not allow changes. The rectangles with striped shading indicate the code files containing predefined declarations that must be defined (filled in) by the user. The white rectangles indicate the code files that should be fully implemented by the user.<fig id="fig0003"><label>Fig. 3</label><caption><p>Dependency graph of the source code files by the directive #include.</p></caption><alt-text id="alt0003">Fig 3</alt-text><graphic xlink:href="gr3"/></fig></p>
  </sec>
  <sec id="sec0003">
    <title>BSF-skeleton parameters</title>
    <p id="para0008">The BSF-skeleton parameters are declared as macroses in the file <italic>Problem-bsfParameters.h</italic>. They are used in the <italic>BSF-Code.cpp</italic> and should be set by the user. All these parameters are presented in <xref rid="tbl0002" ref-type="table">Table 2</xref>.<table-wrap position="float" id="tbl0002"><label>Table 2</label><caption><p>Predefined problem-dependent parameters.</p></caption><alt-text id="alt0006">Table 2</alt-text><table frame="hsides" rules="groups"><thead><tr><th valign="top">ID</th><th valign="top">Description</th><th valign="top">Default value</th></tr></thead><tbody><tr><td valign="top"><italic>PP_BSF_MAX_MPI_SIZE</italic></td><td valign="top">Defines the maximum possible number of MPI processes (the result returned by the function <italic>MPI_Comm_size</italic> cannot exceed this number).</td><td valign="top">500</td></tr><tr><td valign="top"><italic>PP_BSF_PRECISION</italic></td><td valign="top">Sets the decimal precision to be used to format floating-point values on output operations.</td><td valign="top">4</td></tr><tr><td valign="top"><italic>PP_BSF_ITER_OUTPUT</italic></td><td valign="top">If this macros is defined, at the end of each <italic>k</italic>-th iteration, the master process will invocate the predefined BSF function <italic>PC_bsf_IterOutput</italic> that outputs intermediate results. The number <italic>k</italic> is defined by the macros <italic>PP_BSF_TRACE_COUNT</italic>.</td><td valign="top">#undef</td></tr><tr><td valign="top"><italic>PP_BSF_TRACE_COUNT</italic></td><td valign="top">Defines the number <italic>k</italic> mentioned in the description of the macros <italic>PP_BSF_ITER_OUTPUT</italic>.</td><td valign="top">1</td></tr><tr><td valign="top"><italic>PP_BSF_MAX_JOB_CASE</italic></td><td valign="top">Defines the maximum number of activities (jobs) in workflow minus 1. See Section “Workflow support”.</td><td valign="top">0</td></tr><tr><td valign="top"><italic>PP_BSF_OMP</italic></td><td valign="top">If this macros is defined, the worker processes use <italic>#pragma OMP parallel for</italic> to perform the higher-order function <italic>Map</italic>.</td><td valign="top">#undef</td></tr><tr><td valign="top"><italic>PP_BSF_NUM_THREADS</italic></td><td valign="top">If this macros is defined, <italic>OMP parallel for</italic> uses the specified number of threads to perform the higher-order function <italic>Map</italic>. If this macros is not defined, <italic>OMP parallel for</italic> uses the maximum possible number of threads.</td><td valign="top">#undef</td></tr></tbody></table></table-wrap></p>
  </sec>
  <sec id="sec0004">
    <title>Predefined problem-depended BSF types</title>
    <p id="para0009">The predefined problem-depended BSF types are declared as data structures in the file <italic>Problem-bsfTypes.h</italic>. They are used in the <italic>BSF-Code.cpp</italic> and should be set by the user. All these types are presented in <xref rid="tbl0003" ref-type="table">Table 3</xref>.<table-wrap position="float" id="tbl0003"><label>Table 3</label><caption><p>Predefined BSF types (file <italic>Problem-bsfTypes.h</italic>).</p></caption><alt-text id="alt0007">Table 3</alt-text><table frame="hsides" rules="groups"><thead><tr><th valign="top">Type ID</th><th valign="top">Data type</th><th valign="top">Description</th><th valign="top">Mandatoryto fill in</th></tr></thead><tbody><tr><td valign="top"><italic>PT_bsf_parameter_T</italic></td><td align="center" valign="top">Struct</td><td valign="top">Defines the structure (set of data elements) that is transferred by the master process to all the worker processes and includes the order parameters (usually the current approximation).</td><td align="center" valign="top">Yes</td></tr><tr><td valign="top"><italic>PT_bsf_mapElem_T</italic></td><td align="center" valign="top">Struct</td><td valign="top">Defines the record that represents an element in the map-list (list <italic>A</italic> in <xref rid="tbl0006" ref-type="table">Algorithm 1</xref>).</td><td align="center" valign="top">Yes</td></tr><tr><td valign="top"><italic>PT_bsf_reduceElem_T</italic></td><td align="center" valign="top">Struct</td><td valign="top">Defines the record that represents an element in the reduce-list<xref rid="tb3fn1" ref-type="table-fn">#</xref> (list <italic>B</italic> in <xref rid="tbl0006" ref-type="table">Algorithm 1</xref>).</td><td align="center" valign="top">Yes</td></tr><tr><td valign="top"><italic>PT_bsf_reduceElem_T_1</italic></td><td align="center" rowspan="3" valign="top">Struct</td><td rowspan="3" valign="top">Alternative types of the reduce-list elements that are used to organize the workflow (see Section “Workflow support”).</td><td align="center" rowspan="3" valign="top">No</td></tr><tr><td valign="top"><italic>PT_bsf_reduceElem_T_2</italic></td></tr><tr><td valign="top"><italic>PT_bsf_reduceElem_T_3</italic></td></tr></tbody></table><table-wrap-foot><fn id="tb3fn1"><label>#</label><p id="notep0001"><italic>Reduce-list</italic> is the list being the second parameter of the higher-order function <italic>Reduce</italic>.</p></fn></table-wrap-foot></table-wrap></p>
  </sec>
  <sec id="sec0005">
    <title>Extended reduce-list</title>
    <p id="para0010">The BSF-skeleton appends to each element of the reduce-list the additional integer field called <italic>reduceCounter</italic>. This extended reduce-list is presented by the pointer <italic>BD_extendedReduceList</italic> declared in the <italic>BSF-Data.h</italic>. When performing the <italic>Reduce</italic> function (see <italic>BC_ProcessExtendedReduceList</italic> in Section “Key problem-independent functions (prefix <italic>BC_</italic>)”), the elements that have this field equal to zero are ignored. For elements where <italic>reduceCounter</italic> is not zero, the values of the <italic>reduceCounter</italic> are added together. By default, the function <italic>BC_WorkerMap</italic> (see Section “Key problem-independent functions (prefix <italic>BC_</italic>)”) sets the <italic>reduceCounter</italic> to 1. The user can set the value of this field to 0 by setting the parameter *<italic>success</italic> of the function <italic>PC_bsf_MapF</italic> to 0.</p>
  </sec>
  <sec id="sec0006">
    <title>Skeleton variables</title>
    <p id="para0011">The skeleton variables are declared in the file <italic>BSF-SkeletonVariables.h</italic>. The user can exploit these variables for the sake of debugging, tracing, and non-standard implementing (see, for example, Section “Using Map without Reduce”). The user should not change the values of these variables. All skeleton variables are presented in <xref rid="tbl0004" ref-type="table">Table 4</xref>.<table-wrap position="float" id="tbl0004"><label>Table 4</label><caption><p>Skeleton variables (file <italic>BSF-SkeletonVariables.h</italic>).</p></caption><alt-text id="alt0008">Table 4</alt-text><table frame="hsides" rules="groups"><thead><tr><th valign="top">Skeleton variable</th><th valign="top">Type</th><th valign="top">Description</th></tr></thead><tbody><tr><td valign="top"><italic>BSF_sv_addressOffset</italic></td><td valign="top"><italic>INT</italic></td><td valign="top">Contains the number of the first element of the map-sublist appointed to the current worker process.</td></tr><tr><td valign="top"><italic>BSF_sv_iterCounter</italic></td><td valign="top"><italic>INT</italic></td><td valign="top">Contains the number of iterations performed so far.</td></tr><tr><td valign="top"><italic>BSF_sv_jobCase</italic></td><td valign="top"><italic>INT</italic></td><td valign="top">Contains the number of the current activity (job) in workflow (see Section “Workflow support”).</td></tr><tr><td valign="top"><italic>BSF_sv_mpiMaster</italic></td><td valign="top"><italic>INT</italic></td><td valign="top">Contains the rank (number) of the master MPI process.</td></tr><tr><td valign="top"><italic>BSF_sv_mpiRank</italic></td><td valign="top"><italic>INT</italic></td><td valign="top">Contains the rank (number) of current MPI process.</td></tr><tr><td valign="top"><italic>BSF_sv_numberInSublist</italic></td><td valign="top"><italic>INT</italic></td><td valign="top">This variable contains the relative number of the element in the map-sublist that the function <italic>Map</italic> is currently applied to.</td></tr><tr><td valign="top"><italic>BSF_sv_numOfWorkers</italic></td><td valign="top"><italic>INT</italic></td><td valign="top">Contains the total number of the worker processes.</td></tr><tr><td valign="top"><italic>BSF_sv_parameter</italic></td><td valign="top"><italic>PT_bsf_parameter_T</italic></td><td valign="top">Structure that contains the order parameters.</td></tr><tr><td valign="top"><italic>BSF_sv_sublistLength</italic></td><td valign="top"><italic>INT</italic></td><td valign="top">Contains the length of the map-sublist appointed to a worker process.</td></tr></tbody></table></table-wrap></p>
  </sec>
  <sec id="sec0007">
    <title>Functions</title>
    <p id="para0012">The skeleton functions are divided into two groups:</p>
    <p id="para0013">1) problem-independent functions with the prefix <italic>BC</italic>_ that have implemented in the file <italic>BSF-Code.cpp</italic>; problem-dependent functions (predefined BSF functions) with the prefix PC_bsf_ that have declared in the file Problem-Code.cpp.</p>
    <p id="para0015">The user cannot change the headers and bodies of the functions with the prefix <italic>BC_</italic>. The user also cannot change function headers with the prefix <italic>PC_bsf_</italic> but must write an implementation of these functions. The body of a predefined BSF function cannot include calls of problem-independent functions with the prefix <italic>BC</italic>_. The hierarchy of the key function calls is presented in <xref rid="fig0004" ref-type="fig">Fig. 4</xref>.<fig id="fig0004"><label>Fig. 4</label><caption><p>Hierarchy of the key function calls.</p></caption><alt-text id="alt0004">Fig 4</alt-text><graphic xlink:href="gr4"/></fig></p>
  </sec>
  <sec id="sec0008">
    <title>Key problem-independent functions (prefix <italic>BC_</italic>)</title>
    <p id="para0016">The implementations of all problem-independent functions can be found in the file <italic>BSF-Code.cpp</italic>. Descriptions of some key problem-independent functions are presented in <xref rid="tbl0005" ref-type="table">Table 5</xref>.<table-wrap position="float" id="tbl0005"><label>Table 5</label><caption><p>Key problem-independent functions (file <italic>BSF-Code.cpp</italic>).</p></caption><alt-text id="alt0009">Table 5</alt-text><table frame="hsides" rules="groups"><thead><tr><th valign="top">Function</th><th valign="top">Description</th></tr></thead><tbody><tr><td valign="top"><italic>BC_Init</italic></td><td valign="top">Performs the memory allocation and the initialization of the skeleton data structures and variables.</td></tr><tr><td valign="top"><italic>BC_Master</italic></td><td valign="top">The head function of the master process.</td></tr><tr><td valign="top"><italic>BC_MasterMap</italic></td><td valign="top">Forms an order and sends it to the worker processes to perform the <italic>Map</italic> function in the current iteration.</td></tr><tr><td valign="top"><italic>BC_MasterReduce</italic></td><td valign="top">Receives the results produced by the worker processes, collects them in a list, and performs the function <italic>Reduce</italic> on this list.</td></tr><tr><td valign="top"><italic>BC_MpiRun</italic></td><td valign="top">Executes the MPI initialization. After it, the number of worker processes is accessible by the skeleton variable <italic>BSF_sv_numOfWorkers</italic>; total number of MPI processes (<italic>MPI_Comm_size</italic>) is equal to <inline-formula><mml:math id="M32" altimg="si2.svg"><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>F</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mi>O</mml:mi><mml:mi>f</mml:mi><mml:mi>W</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>s</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>; the rank of a MPI process (<italic>MPI_Comm_rank</italic>) is accessible by the skeleton variable <italic>BSF_sv_mpiRank</italic>; the rank of the master MPI process is accessible by the skeleton variable <italic>BSF_sv_mpiMaster</italic> (is equal to <italic>MPI_Comm_size</italic>-1). The MPI ranks of the worker processes have values from 0 to <inline-formula><mml:math id="M33" altimg="si3.svg"><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>F</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mi>O</mml:mi><mml:mi>f</mml:mi><mml:mi>W</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>s</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>. The MPI rank of the worker process is equal to <italic>BSF_sv_numOfWorkers</italic>.</td></tr><tr><td valign="top"><italic>BC_ProcessExtendedReduceList</italic></td><td valign="top">This function finds the first element in the extended reduce-list with the <italic>reduceCounter</italic> not equal to zero and adds to it all other elements that have the <italic>reduceCounter</italic> not equal to zero. For pairwise addition of elements of the original reduce-list, the function <italic>PC_bsf_ReduceF</italic> is used.</td></tr><tr><td valign="top"><italic>BC_Worker</italic></td><td valign="top">The head function of a worker process.</td></tr><tr><td valign="top"><italic>BC_WorkerMap</italic></td><td valign="top">Receives the order from the master process, assigns the skeleton variables (see Section “Skeleton variables”), and applies the function <italic>PC_bsf_MapF</italic> to the appointed map-sublist to produce the corresponding part of the reduce-list.</td></tr><tr><td valign="top"><italic>BC_WorkerReduce</italic></td><td valign="top">Sends to the master process the element that is the sum of all reduce-sublist elements.</td></tr></tbody></table></table-wrap></p>
  </sec>
  <sec id="sec0009">
    <title>Predefined problem-dependent BSF functions (prefix PC_bsf_)</title>
    <p id="para0017">This section contains detailed descriptions of the predefined problem-dependent BSF functions with the prefix <italic>PC_bsf_</italic> declared in <italic>Problem-bsfCode.cpp</italic>. The user must implement all these functions. An instruction is presented in Section “Step-by-step instruction”. An example is presented in Section “Example of using the BSF-skeleton”.</p>
    <p id="para0018">
      <bold>PC_bsf_CopyParameter</bold>
    </p>
    <p id="para0019">Copies all order parameters from the in-structure to the out-structure. The order parameters are declared in the predefined problem-depended BSF type <italic>PT_bsf_parameter_T</italic> (see Section “Error! Reference source not found.”).</p>
    <p id="para0020">
      <italic>Syntax</italic>
    </p>
    <p id="para9001">
void PC_bsf_CopyParameter(
</p>
    <p id="para9002">
PT_bsf_parameter_T parameterIn,
</p>
    <p id="para9003">
PT_bsf_parameter_T* parameterOutP
</p>
    <p id="para9004">
);
</p>
    <p id="para0022"><italic>In parameters</italic> parameterIn</p>
    <p id="para0024">The structure from which parameters are copied.</p>
    <p id="para0025"><italic>Out parameters</italic> parameterOutP</p>
    <p id="para0027">The pointer to the structure to which parameters are copied.</p>
    <p id="para0028">
      <bold>PC_bsf_Init</bold>
    </p>
    <p id="para0029">Initializes the problem-depended variables and data structures defined in <italic>Problem-Data.h</italic>.</p>
    <p id="para0030">
      <italic>Syntax</italic>
    </p>
    <p id="para9005">
void PC_bsf_Init(
</p>
    <p id="para9006">
bool* success
</p>
    <p id="para9007">
);
</p>
    <p id="para0032">
      <italic>Out parameters</italic>
    </p>
    <p id="para0033">*success</p>
    <p id="para0034">Must be set to <italic>false</italic> if the initialization failed. The default value is <italic>true</italic>.</p>
    <p id="para0035">
      <bold>PC_bsf_IterOutput</bold>
    </p>
    <p id="para0036">Outputs intermediate results of the current iteration.</p>
    <p id="para0037">
      <italic>Syntax</italic>
    </p>
    <p id="para9008">
void PC_bsf_IterOutput(
</p>
    <p id="para9009">
PT_bsf_reduceElem_T* reduceResult,
</p>
    <p id="para9010">
int reduceCounter,
</p>
    <p id="para9011">
PT_bsf_parameter_T parameter,
</p>
    <p id="para9012">
double elapsedTime,
</p>
    <p id="para9013">
int nextJob
</p>
    <p id="para9014">
);
</p>
    <p id="para9015">
void PC_bsf_IterOutput_1(
</p>
    <p id="para9016">
PT_bsf_reduceElem_T_1* reduceResult,
</p>
    <p id="para9017">
int reduceCounter,
</p>
    <p id="para9018">
PT_bsf_parameter_T parameter,
</p>
    <p id="para9019">
double elapsedTime,
</p>
    <p id="para9020">
int nextJob
</p>
    <p id="para9021">
);
</p>
    <p id="para9022">
PC_bsf_IterOutput_2(
</p>
    <p id="para9023">
PT_bsf_reduceElem_T_2* reduceResult,
</p>
    <p id="para9024">
int reduceCounter,
</p>
    <p id="para9025">
PT_bsf_parameter_T parameter,
</p>
    <p id="para9026">
double elapsedTime,
</p>
    <p id="para9027">
int nextJob
</p>
    <p id="para9028">
);
</p>
    <p id="para9029">
void PC_bsf_IterOutput_3(
</p>
    <p id="para9030">
PT_bsf_reduceElem_T_3* reduceResult,
</p>
    <p id="para9031">
int reduceCounter,
</p>
    <p id="para9032">
PT_bsf_parameter_T parameter,
</p>
    <p id="para9033">
double elapsedTime,
</p>
    <p id="para9034">
int nextJob
</p>
    <p id="para9035">
);
</p>
    <p id="para0039"><italic>In parameters</italic> reduceResult</p>
    <p id="para0041">Pointer to the structure that contains the result of executing the <italic>Reduce</italic> function. reduceCounter</p>
    <p id="para0043">The number of summed (by <inline-formula><mml:math id="M34" altimg="si39.svg"><mml:mo>⊕</mml:mo></mml:math></inline-formula>) elements in the reduce-list. This number matches the number of extended reduce-list elements that have the value 1 in the field <italic>reduceCounter</italic> (see Section “Extended reduce-list”).</p>
    <p id="para0044">
      <italic>Remarks</italic>
    </p>
    <p id="para0045">The functions <italic>PC_bsf_IterOutput_1, PC_bsf_IterOutput_2</italic> and <italic>PC_bsf_IterOutput_3</italic> are used to organize a workflow (optional filling).</p>
    <p id="para0046">
      <bold>PC_bsf_JobDispatcher</bold>
    </p>
    <p id="para0047">This function is used to organize the workflow (see Section “Workflow support”) and is executed by the master process before starting each iteration. It implements a state machine that switches from one state to another. If you do not need the workflow support, then you should use the empty implementation of this function.</p>
    <p id="para0048">
      <italic>Syntax</italic>
    </p>
    <p id="para9036">
void PC_bsf_JobDispatcher(
</p>
    <p id="para9037">
PT_bsf_parameter_T* parameter,
</p>
    <p id="para9038">
int* job,
</p>
    <p id="para9039">
bool* exit
</p>
    <p id="para9040">
);
</p>
    <p id="para0050"><italic>In|out parameters</italic> parameter</p>
    <p id="para0052">The pointer to the structure containing the parameters of the next iteration. This structure may be also modified by the functions <italic>PC_bsf_ProcessResults_1, PC_bsf_ProcessResults_2</italic> and <italic>PC_bsf_ProcessResults_3</italic>.</p>
    <p id="para0053">
      <italic>Out parameters</italic>
    </p>
    <p id="para0054">*job</p>
    <p id="para0055">This variable must be assigned the number of the next action (job).</p>
    <p id="para0056">*exit</p>
    <p id="para0057">If the stop condition holds, then this variable must be assigned <italic>true</italic>. The default value is <italic>false</italic>.</p>
    <p id="para0058">
      <italic>Remarks</italic>
    </p>
    <p id="para0059">Important: The use of the structure <italic>BSF_sv_parameter</italic> is not allowed in the implementation of this function.</p>
    <p id="para0060">The function <italic>PC_bsf_JobDispatcher</italic> is invocated after the invocation of function <italic>PC_bsf_ProcessResults_1, PC_bsf_ProcessResults_2</italic> or <italic>PC_bsf_ProcessResults_3</italic>.</p>
    <p id="para0061">
      <bold>PC_bsf_MapF</bold>
    </p>
    <p id="para0062">Implements the function that is applied to the map-list elements when performing the higher-order function <italic>Map</italic>. To implement the <italic>PC_bsf_MapF</italic> function, we can use the problem-dependent variables and data structures defined in the file <italic>Problem-Data.h</italic>, and the structure <italic>BSF_sv_parameter</italic> of the type <italic>PT_bsf_parameter_T</italic> defined in <italic>Problem-bsfTypes.h</italic>.</p>
    <p id="para0063">
      <italic>Syntax</italic>
    </p>
    <p id="para9041">
void PC_bsf_MapF(
</p>
    <p id="para9042">
PT_bsf_mapElem_T* mapElem,
</p>
    <p id="para9043">
PT_bsf_reduceElem_T* reduceElem,
</p>
    <p id="para9044">
int* success
</p>
    <p id="para9045">
);
</p>
    <p id="para9046">
void PC_bsf_MapF_1(
</p>
    <p id="para9047">
PT_bsf_mapElem_T* mapElem,
</p>
    <p id="para9048">
PT_bsf_reduceElem_T_1* reduceElem,
</p>
    <p id="para9049">
int* success
</p>
    <p id="para9050">
);
</p>
    <p id="para9051">
void PC_bsf_MapF_2(
</p>
    <p id="para9052">
PT_bsf_mapElem_T* mapElem,
</p>
    <p id="para9053">
PT_bsf_reduceElem_T_2* reduceElem,
</p>
    <p id="para9054">
int* success
</p>
    <p id="para9055">
);
</p>
    <p id="para9056">
void PC_bsf_MapF_3(
</p>
    <p id="para9057">
PT_bsf_mapElem_T* mapElem,
</p>
    <p id="para9058">
PT_bsf_reduceElem_T_3* reduceElem,
</p>
    <p id="para9059">
int* success
</p>
    <p id="para9060">
);
</p>
    <p id="para0065"><italic>In parameters</italic> mapElem</p>
    <p id="para0067">The pointer to the structure that is the current element of the map-list.</p>
    <p id="para0068"><italic>Out parameters</italic> reduceElem</p>
    <p id="para0070">The pointer to the structure that is the corresponding reduce-list element to be calculated.</p>
    <p id="para0071">*success</p>
    <p id="para0072">Must be set to <italic>false</italic> if the corresponding reduce-list element must be ignored when the <italic>Reduce</italic> function will be executed. The default value is <italic>true</italic>.</p>
    <p id="para0073">
      <italic>Remarks</italic>
    </p>
    <p id="para0074">The functions <italic>PC_bsf_MapF_1, PC_bsf_MapF_2</italic> and <italic>PC_bsf_MapF_3</italic> are used to organize a workflow (optional filling).</p>
    <p id="para0075">
      <bold>PC_bsf_ParametersOutput</bold>
    </p>
    <p id="para0076">Outputs parameters of the problem before starting the iterative process.</p>
    <p id="para0077">
      <italic>Syntax</italic>
    </p>
    <p id="para9061">
void PC_bsf_ParametersOutput(
</p>
    <p id="para9062">
PT_bsf_parameter_T parameter
</p>
    <p id="para9063">
);
</p>
    <p id="para0079"><italic>In parameters</italic> parameter</p>
    <p id="para0081">The structure containing the parameters of the problem.</p>
    <p id="para0082">
      <bold>PC_bsf_ProblemOutput</bold>
    </p>
    <p id="para0083">Outputs the results of solving the problem.</p>
    <p id="para0084">
      <italic>Syntax</italic>
    </p>
    <p id="para9064">
void PC_bsf_ProblemOutput(
</p>
    <p id="para9065">
PT_bsf_reduceElem_T* reduceResult,
</p>
    <p id="para9066">
int reduceCounter,
</p>
    <p id="para9067">
PT_bsf_parameter_T parameter,
</p>
    <p id="para9068">
double t
</p>
    <p id="para9069">
);
</p>
    <p id="para9070">
void PC_bsf_ProblemOutput_1(
</p>
    <p id="para9071">
PT_bsf_reduceElem_T_1* reduceResult,
</p>
    <p id="para9072">
int reduceCounter,
</p>
    <p id="para9073">
PT_bsf_parameter_T parameter,
</p>
    <p id="para9074">
double t
</p>
    <p id="para9075">
);
</p>
    <p id="para9076">
void PC_bsf_ProblemOutput_2(
</p>
    <p id="para9077">
PT_bsf_reduceElem_T_2* reduceResult,
</p>
    <p id="para9078">
int reduceCounter,
</p>
    <p id="para9079">
PT_bsf_parameter_T parameter,
</p>
    <p id="para9080">
double t
</p>
    <p id="para9081">
);
</p>
    <p id="para9082">
void PC_bsf_ProblemOutput_3(
</p>
    <p id="para9083">
PT_bsf_reduceElem_T_3* reduceResult,
</p>
    <p id="para9084">
int reduceCounter,
</p>
    <p id="para9085">
PT_bsf_parameter_T parameter,
</p>
    <p id="para9086">
double t
</p>
    <p id="para9087">
);
</p>
    <p id="para0086"><italic>In parameters</italic> reduceResult</p>
    <p id="para0088">The pointer to the structure that is the result of executing the higher-order function <italic>Reduce</italic>. parameter</p>
    <p id="para0090">The structure containing the parameters of the final iteration.</p>
    <p id="para0091">
      <italic>Remarks</italic>
    </p>
    <p id="para0092">The functions PC_bsf_ProblemOutput_1, PC_bsf_ProblemOutput_2 and PC_bsf_ProblemOutput_3 are used to organize a workflow (optional filling).</p>
    <p id="para0093">
      <bold>PC_bsf_ProcessResults</bold>
    </p>
    <p id="para0094">Processes the results of the current iteration: computes the order parameters for the next iteration and checks the stop condition.</p>
    <p id="para0095">
      <italic>Syntax</italic>
    </p>
    <p id="para9088">
void PC_bsf_ProcessResults(
</p>
    <p id="para9089">
PT_bsf_reduceElem_T* reduceResult,
</p>
    <p id="para9090">
int reduceCounter,
</p>
    <p id="para9091">
PT_bsf_parameter_T* parameter,
</p>
    <p id="para9092">
int* nextJob,
</p>
    <p id="para9093">
bool* exit
</p>
    <p id="para9094">
);
</p>
    <p id="para9095">
void PC_bsf_ProcessResults_1(
</p>
    <p id="para9096">
PT_bsf_reduceElem_T_1* reduceResult,
</p>
    <p id="para9097">
int reduceCounter,
</p>
    <p id="para9098">
PT_bsf_parameter_T* parameter,
</p>
    <p id="para9099">
int* nextJob,
</p>
    <p id="para9100">
bool* exit
</p>
    <p id="para9101">
);
</p>
    <p id="para9102">
void PC_bsf_ProcessResults_2(
</p>
    <p id="para9103">
PT_bsf_reduceElem_T_2* reduceResult,
</p>
    <p id="para9104">
int reduceCounter,
</p>
    <p id="para9105">
PT_bsf_parameter_T* parameter,
</p>
    <p id="para9106">
int* nextJob,
</p>
    <p id="para9107">
bool* exit
</p>
    <p id="para9108">
);
</p>
    <p id="para9109">
void PC_bsf_ProcessResults_3(
</p>
    <p id="para9110">
PT_bsf_reduceElem_T_3* reduceResult,
</p>
    <p id="para9111">
int reduceCounter,
</p>
    <p id="para9112">
PT_bsf_parameter_T* parameter,
</p>
    <p id="para9113">
int* nextJob,
</p>
    <p id="para9114">
bool* exit
</p>
    <p id="para9115">
);
</p>
    <p id="para0097"><italic>In parameters</italic> reduceResult</p>
    <p id="para0099">The pointer to the structure that is the result of executing the higher-order function <italic>Reduce</italic>. reduceCounter</p>
    <p id="para0101">The number of summed (by <inline-formula><mml:math id="M35" altimg="si39.svg"><mml:mo>⊕</mml:mo></mml:math></inline-formula>) elements in the reduce-list. This number matches the number of extended reduce-list elements that have the value 1 in the field <italic>reduceCounter</italic> (see Section “Extended reduce-list”).</p>
    <p id="para0102"><italic>In|out parameters</italic> parameter</p>
    <p id="para0104">The pointer to the structure containing the parameters of the current iteration. This structure must be modified by setting new values of the parameters for the next iteration.</p>
    <p id="para0105">
      <italic>Out parameters</italic>
    </p>
    <p id="para0106">*nextJob</p>
    <p id="para0107">If a workflow is used (see Section “Workflow support”), then this variable must be assigned the number of the next action (job). Otherwise, this parameter is not used.</p>
    <p id="para0108">*exit</p>
    <p id="para0109">If the stop condition holds, then this variable must be assigned <italic>true</italic>. The default value is <italic>false</italic>.</p>
    <p id="para0110">
      <italic>Remarks</italic>
    </p>
    <p id="para0111">Important: The use of the structure <italic>BSF_sv_parameter</italic> is not allowed in the implementations of these functions.</p>
    <p id="para0112">The functions <italic>PC_bsf_ProcessResults_1, PC_bsf_ProcessResults_2</italic> and <italic>PC_bsf_ProcessResults_3</italic> are used to organize a workflow (optional filling).</p>
    <p id="para0113">
      <bold>PC_bsf_ReduceF</bold>
    </p>
    <p id="para0114">Implements the operation <inline-formula><mml:math id="M36" altimg="si54.svg"><mml:mrow><mml:mi>z</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mi>x</mml:mi><mml:mo>⊕</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> (see Section “Method details”).</p>
    <p id="para0115">
      <italic>Syntax</italic>
    </p>
    <p id="para9116">
void PC_bsf_ReduceF(
</p>
    <p id="para9117">
PT_bsf_reduceElem_T* x,
</p>
    <p id="para9118">
PT_bsf_reduceElem_T* y,
</p>
    <p id="para9119">
PT_bsf_reduceElem_T* z
</p>
    <p id="para9120">
);
</p>
    <p id="para9121">
void PC_bsf_ReduceF_1(
</p>
    <p id="para9122">
PT_bsf_reduceElem_T_1* x,
</p>
    <p id="para9123">
PT_bsf_reduceElem_T_1* y,
</p>
    <p id="para9124">
PT_bsf_reduceElem_T_1* z
</p>
    <p id="para9125">
);
</p>
    <p id="para9126">
void PC_bsf_ReduceF_2(
</p>
    <p id="para9127">
PT_bsf_reduceElem_T_2* x,
</p>
    <p id="para9128">
PT_bsf_reduceElem_T_2* y,
</p>
    <p id="para9129">
PT_bsf_reduceElem_T_2* z
</p>
    <p id="para9130">
);
</p>
    <p id="para9131">
void PC_bsf_ReduceF_3(
</p>
    <p id="para9132">
PT_bsf_reduceElem_T_3* x,
</p>
    <p id="para9133">
PT_bsf_reduceElem_T_3* y,
</p>
    <p id="para9134">
PT_bsf_reduceElem_T_3* z
</p>
    <p id="para9135">
);
</p>
    <p id="para0117"><italic>In parameters</italic> x</p>
    <p id="para0119">The pointer to the structure that presents the first term. y</p>
    <p id="para0121">The pointer to the structure that presents the second term.</p>
    <p id="para0122"><italic>Out parameters</italic> z</p>
    <p id="para0124">The pointer to the structure that presents the result of the operation.</p>
    <p id="para0125">
      <italic>Remarks</italic>
    </p>
    <p id="para0126">The functions <italic>PC_bsf_ReduceF_1, PC_bsf_ReduceF_2</italic> and <italic>PC_bsf_ReduceF_3</italic> are used to organize a workflow (optional filling).</p>
    <p id="para0127">
      <bold>PC_bsf_SetInitParameter</bold>
    </p>
    <p id="para0128">Sets initial order parameters for the workers in the first iteration. These order parameters are declared in the predefined problem-depended BSF type <italic>PT_bsf_parameter_T</italic> (see Section “Error! Reference source not found.”).</p>
    <p id="para0129">
      <italic>Syntax</italic>
    </p>
    <p id="para9136">
void PC_bsf_SetInitParameter(
</p>
    <p id="para9137">
PT_bsf_parameter_T* parameter
</p>
    <p id="para9138">
);
</p>
    <p id="para0131"><italic>Out parameters</italic> parameter</p>
    <p id="para0133">The pointer to the structure that the initial parameters should be assigned to.</p>
    <p id="para0134">
      <bold>PC_bsf_SetListSize</bold>
    </p>
    <p id="para0135">Sets the length of the list.</p>
    <p id="para0136">
      <italic>Syntax</italic>
    </p>
    <p id="para9139">
void PC_bsf_SetListSize(
</p>
    <p id="para9140">
int* listSize
</p>
    <p id="para9141">
);
</p>
    <p id="para0138">
      <italic>Out parameters</italic>
    </p>
    <p id="para0139">*listSize</p>
    <p id="para0140">Must be assigned a positive integer that specifies the length of the list.</p>
    <p id="para0141">
      <italic>Remarks</italic>
    </p>
    <p id="para0142">The list size should be greater than or equal to the number of workers.</p>
    <p id="para0143">
      <bold>PC_bsf_SetMapListElem</bold>
    </p>
    <p id="para0144">Initializes the map-list element with the number <italic>i</italic>.</p>
    <p id="para0145">
      <italic>Syntax</italic>
    </p>
    <p id="para9142">
void PC_bsf_SetMapListElem(
</p>
    <p id="para9143">
PT_bsf_mapElem_T* elem,
</p>
    <p id="para9144">
int i
</p>
    <p id="para9145">
);
</p>
    <p id="para0147">
      <italic>In parameters</italic>
    </p>
    <p id="para0148">
      <italic>elem</italic>
    </p>
    <p id="para0149">The pointer to the map-list element.</p>
    <p id="para0150">
      <italic>i</italic>
    </p>
    <p id="para0151">The ordinal number of the specified element.</p>
    <p id="para0152">
      <italic>Remarks</italic>
    </p>
    <p id="para0153">Important: The numbering of elements in the list begins from zero.</p>
    <p id="para0154">
      <bold>PC_bsfAssignAddressOffset</bold>
    </p>
    <p id="para0155">Assigns the number of the first element of the map-sublist to the skeleton variables <italic>BSF_sv_addressOffset</italic> (see Section “Skeleton variables”).</p>
    <p id="para0156"><italic>Syntax</italic> void PC_bsfAssignAddressOffset(int value);</p>
    <p id="para0158"><italic>In parameters</italic> value</p>
    <p id="para0160">Non-negative integer value.</p>
    <p id="para0161">
      <italic>Remarks</italic>
    </p>
    <p id="para0162">Important: The user should not use this function.</p>
    <p id="para0163">
      <bold>PC_bsfAssignIterCounter</bold>
    </p>
    <p id="para0164">Assigns the number of the first element of the map-sublist to the skeleton variables <italic>BSF_sv_iterCounter</italic> (see Section “Skeleton variables”).</p>
    <p id="para0165"><italic>Syntax</italic> void PC_bsfAssignIterCounter(int value);</p>
    <p id="para0167"><italic>In parameters</italic> value</p>
    <p id="para0169">Non-negative integer value.</p>
    <p id="para0170">
      <italic>Remarks</italic>
    </p>
    <p id="para0171">Important: The user should not use this function.</p>
    <p id="para0172">
      <bold>PC_bsfAssignJobCase</bold>
    </p>
    <p id="para0173">Assigns the number of the current activity (job) in workflow to the skeleton variables <italic>BSF_sv_jobCase</italic> (see Section “Skeleton variables”).</p>
    <p id="para0174"><italic>Syntax</italic> void PC_bsfAssignJobCase(int value);</p>
    <p id="para0176"><italic>In parameters</italic> value</p>
    <p id="para0178">Non-negative integer value.</p>
    <p id="para0179">
      <italic>Remarks</italic>
    </p>
    <p id="para0180">Important: The user should not use this function.</p>
    <p id="para0181">
      <bold>PC_bsfAssignMpiMaster</bold>
    </p>
    <p id="para0182">Assigns the rank of the master MPI process to the skeleton variables <italic>BSF_sv_mpiMaster</italic> (see Section “Skeleton variables”).</p>
    <p id="para0183"><italic>Syntax</italic> void PC_bsfAssignMpiMaster(int value);</p>
    <p id="para0185"><italic>In parameters</italic> value</p>
    <p id="para0187">Non-negative integer value.</p>
    <p id="para0188">
      <italic>Remarks</italic>
    </p>
    <p id="para0189">Important: The user should not use this function.</p>
    <p id="para0190">
      <bold>PC_bsfAssignMpiRank</bold>
    </p>
    <p id="para0191">Assigns the rank of current MPI process to the skeleton variables <italic>BSF_sv_mpiRank</italic> (see Section “Skeleton variables”).</p>
    <p id="para0192"><italic>Syntax</italic> void PC_bsfAssignMpiRank(int value);</p>
    <p id="para0194"><italic>In parameters</italic> value</p>
    <p id="para0196">Non-negative integer value.</p>
    <p id="para0197">
      <italic>Remarks</italic>
    </p>
    <p id="para0198">Important: The user should not use this function.</p>
    <p id="para0199">
      <bold>PC_bsfAssignNumberInSublist</bold>
    </p>
    <p id="para0200">Assigns the number of the current element in the map-sublist to the skeleton variables <italic>BSF_sv_numberInSublist</italic> (see Section “Skeleton variables”).</p>
    <p id="para0201"><italic>Syntax</italic> void PC_bsfAssignNumberInSublist(int value);</p>
    <p id="para0203"><italic>In parameters</italic> value</p>
    <p id="para0205">Non-negative integer value.</p>
    <p id="para0206">
      <italic>Remarks</italic>
    </p>
    <p id="para0207">Important: The user should not use this function.</p>
    <p id="para0208">
      <bold>PC_bsfAssignNumOfWorkers</bold>
    </p>
    <p id="para0209">Assigns the total number of the worker processes to the skeleton variables <italic>BSF_sv_numOfWorkers</italic> (see Section “Skeleton variables”).</p>
    <p id="para0210"><italic>Syntax</italic> void PC_bsfAssignNumOfWorkers(int value);</p>
    <p id="para0212"><italic>In parameters</italic> value</p>
    <p id="para0214">Non-negative integer value.</p>
    <p id="para0215">
      <italic>Remarks</italic>
    </p>
    <p id="para0216">Important: The user should not use this function.</p>
    <p id="para0217">
      <bold>PC_bsfAssignParameter</bold>
    </p>
    <p id="para0218">Assigns the order parameters to the structure <italic>BSF_sv_parameter</italic> (see Section “Skeleton variables”).</p>
    <p id="para0219"><italic>Syntax</italic> void PC_bsfAssignParameter(PT_bsf_parameter_T parameter);</p>
    <p id="para0221"><italic>In parameters</italic> parameter</p>
    <p id="para0223">The structure from which the order parameters are taken.</p>
    <p id="para0224">
      <italic>Remarks</italic>
    </p>
    <p id="para0225">Important: The user should not use this function.</p>
    <p id="para0226">
      <bold>PC_bsfAssignSublistLength</bold>
    </p>
    <p id="para0227">Assigns the length of the current map-sublist to the skeleton variables <italic>BSF_sv_sublistLength</italic> (see Section “Skeleton variables”).</p>
    <p id="para0228"><italic>Syntax</italic> void PC_bsfAssignSublistLength(int value);</p>
    <p id="para0230"><italic>In parameters</italic> value</p>
    <p id="para0232">Non-negative integer value.</p>
    <p id="para0233">
      <italic>Remarks</italic>
    </p>
    <p id="para0234">Important: The user should not use this function.</p>
    <p id="para0235">
      <bold>Step-by-step instruction</bold>
    </p>
    <p id="para0236">This section contains step-by-step instructions on how to use the BSF-skeleton to quickly create a parallel program. Starting from Step 2, we strongly recommend compiling the program after adding each language construction.</p>
    <p id="para0237"><bold>Step 1</bold>. First of all, we must represent our algorithm in the form of operations on lists using the higher-order functions <italic>Map</italic> and <italic>Reduce</italic> (see <xref rid="tbl0006" ref-type="table">Algorithm 1</xref>. Generic BSF-algorithm template.). An example is presented in Section “Example of using the BSF-skeleton”.<table-wrap position="float" id="tbl0006"><label>Algorithm 1</label><caption><p> </p></caption><alt-text id="alt0010">Algorithm 1</alt-text><table frame="hsides" rules="groups"><thead><tr><th valign="top"><inline-formula><mml:math id="M37" altimg="si4.svg"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula></th><th valign="top">input <inline-formula><mml:math id="M38" altimg="si4.svg"><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula></th></tr></thead><tbody><tr><td>1:</td><td>input <italic>A, x</italic><sup>(0)</sup></td></tr><tr><td valign="top">2:</td><td valign="top"><inline-formula><mml:math id="M39" altimg="si5.svg"><mml:mrow><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">3:</td><td valign="top"><inline-formula><mml:math id="M40" altimg="si6.svg"><mml:mrow><mml:mi>B</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>p</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:msub><mml:mo>,</mml:mo><mml:mi>A</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">4:</td><td valign="top"><inline-formula><mml:math id="M41" altimg="si7.svg"><mml:mrow><mml:mi>s</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mspace width="0.28em"/><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>m</mml:mi><mml:mi>p</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mo>⊕</mml:mo><mml:mo>,</mml:mo><mml:mi>B</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">5:</td><td valign="top"><inline-formula><mml:math id="M42" altimg="si8.svg"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>m</mml:mi><mml:mi>p</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">6:</td><td valign="top"><inline-formula><mml:math id="M43" altimg="si9.svg"><mml:mrow><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">7:</td><td valign="top">if <inline-formula><mml:math id="M44" altimg="si10.svg"><mml:mrow><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mi>p</mml:mi><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> goto 9</td></tr><tr><td valign="top">8:</td><td valign="top">goto 3</td></tr><tr><td valign="top">9:</td><td valign="top">output <inline-formula><mml:math id="M45" altimg="si11.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula></td></tr><tr><td valign="top">10:</td><td valign="top">stop</td></tr></tbody></table></table-wrap></p>
    <p id="para0238"><bold>Step 2</bold>. In the file <italic>Problem-Parameters.h</italic>, define problem parameters. For example:</p>
    <p id="para0239">#define PP_N 3 // Dimension of space</p>
    <p id="para0240"><bold>Step 3.</bold> In the file <italic>Problem-Types.h</italic>, declare problem types (optional). For example: typedef PT_point_T[PP_N]; // Point in n-Dimensional Space</p>
    <p id="para0242"><bold>Step 4</bold>. In the file <italic>Problem-bsfTypes.h</italic>, implement the predefined BSF types. If we do not use a workflow then we do not have to implement the types <italic>PT_bsf_reduceElem_T_1, PT_bsf_reduceElem_T_2, PT_bsf_reduceElem_T_3</italic>, but we can't delete these empty structures. For example:</p>
    <p id="para9146">
struct PT_bsf_parameter_T {
</p>
    <p id="para9147">
PT_point_T approximation; // Current approximation
</p>
    <p id="para9148">
};
</p>
    <p id="para9149">
struct PT_bsf_mapElem_T {
</p>
    <p id="para9150">
int columnNo; // Column number in matrix Alpha
</p>
    <p id="para9151">
};
</p>
    <p id="para9152">
struct PT_bsf_reduceElem_T {
</p>
    <p id="para9153">
double column[PP_N]; // Column of intermediate matrix
</p>
    <p id="para9154">
};
</p>
    <p id="para9155">
struct PT_bsf_reduceElem_T_1 {};
</p>
    <p id="para9156">
struct PT_bsf_reduceElem_T_2 {};
</p>
    <p id="para9157">
struct PT_bsf_reduceElem_T_3 {};
</p>
    <p id="para0244"><bold>Step 5</bold>. In the file <italic>Problem-Data.h</italic>, define the problem-dependent variables and data structures. For example: static double PD_A[PP_N][PP_N]; // Coefficients of equations</p>
    <p id="para0246"><bold>Step 6</bold>. In the file <italic>Problem-bsfCode.cpp</italic>, implement the predefined problem-dependent BSF functions (see Section “Predefined problem-dependent BSF functions (prefix PC_bsf_)”) in the suggested order. To implement these functions, the user can write additional <italic>problem (user) functions</italic> in the <italic>Problem-bsfCode.cpp</italic>. The prototypes of these problem functions must be included in the <italic>Problem-Forwards.h</italic>.</p>
    <p id="para0247"><bold>Step 7</bold>. In the file <italic>Problem-bsfCode.cpp</italic>, we can configure the BSF-skeleton parameters (see Section “BSF-skeleton parameters”).</p>
    <p id="para0248">Build and run the solution in the MPI environment.</p>
  </sec>
  <sec id="sec0010">
    <title>Example of using the BSF-skeleton</title>
    <p id="para0249">In this section, we show how to use the BSF-skeleton to implement the iterative Jacobi method as an example. The <italic>Jacobi method</italic>
<xref rid="bib0008" ref-type="bibr">[8]</xref> is a simple iterative method for solving a system of linear equations. Let us give a brief description of the Jacobi method. Let a joint square system of linear equations in a matrix form be given in Euclidean space <inline-formula><mml:math id="M46" altimg="si55.svg"><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:math></inline-formula>:<disp-formula id="eqn0001"><label>(1)</label><mml:math id="M47" altimg="si56.svg"><mml:mrow><mml:mi mathvariant="bold">Ax</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mi mathvariant="bold">b</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where<disp-formula id="ueqn0003"><mml:math id="M48" altimg="si57.svg"><mml:mrow><mml:mi>A</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>a</mml:mi><mml:mn>11</mml:mn></mml:msub></mml:mtd><mml:mtd><mml:mo>⋯</mml:mo></mml:mtd><mml:mtd><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd><mml:mtd><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mo>⋯</mml:mo></mml:mtd><mml:mtd><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="ueqn0004"><mml:math id="M49" altimg="si58.svg"><mml:mrow><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="ueqn0005"><mml:math id="M50" altimg="si59.svg"><mml:mrow><mml:mi mathvariant="bold">b</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
    <p id="para0250">It is assumed that <inline-formula><mml:math id="M51" altimg="si60.svg"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> for all <inline-formula><mml:math id="M52" altimg="si61.svg"><mml:mrow><mml:mi>i</mml:mi><mml:mspace width="0.28em"/><mml:mo linebreak="goodbreak">=</mml:mo><mml:mspace width="0.28em"/><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mspace width="0.28em"/><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. Let us define the matrix<disp-formula id="ueqn0006"><mml:math id="M53" altimg="si62.svg"><mml:mrow><mml:mi mathvariant="bold">C</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>c</mml:mi><mml:mn>11</mml:mn></mml:msub></mml:mtd><mml:mtd><mml:mo>⋯</mml:mo></mml:mtd><mml:mtd><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd><mml:mtd><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mo>⋯</mml:mo></mml:mtd><mml:mtd><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>in the following way:<disp-formula id="ueqn0007"><mml:math id="M54" altimg="si63.svg"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>=</mml:mo><mml:mspace width="0.28em"/><mml:mo>{</mml:mo></mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi><mml:mo>;</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>i</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
    <p id="para0251">Let us define the vector <inline-formula><mml:math id="M55" altimg="si64.svg"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> as follows: <inline-formula><mml:math id="M56" altimg="si65.svg"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak">=</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak">/</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The Jacobi method of finding an approximate solution of system (1) consists of the following steps:</p>
    <p id="para0252">Step 1. <inline-formula><mml:math id="M57" altimg="si26.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="M58" altimg="si27.svg"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
    <p id="para0253">Step 2. <inline-formula><mml:math id="M59" altimg="si66.svg"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="goodbreak">+</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
    <p id="para0254">Step 3. If <inline-formula><mml:math id="M60" altimg="si67.svg"><mml:mrow><mml:mrow><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo linebreak="badbreak">−</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:msup><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo linebreak="goodbreak">&lt;</mml:mo><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, go to Step 5.</p>
    <p id="para0255">Step 4. <inline-formula><mml:math id="M61" altimg="si68.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mspace width="0.28em"/><mml:mo linebreak="goodbreak">+</mml:mo><mml:mspace width="0.28em"/><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>; go to Step 2.</p>
    <p id="para0256">Step 5. Stop.</p>
    <p id="para0257">In the Jacobi method, an arbitrary vector <inline-formula><mml:math id="M62" altimg="si12.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> can be taken as the initial approximation. In Step 1, the initial approximation <inline-formula><mml:math id="M63" altimg="si12.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> is assigned by the vector <inline-formula><mml:math id="M64" altimg="si69.svg"><mml:mi>d</mml:mi></mml:math></inline-formula>. In Step 3, the Euclidean norm <inline-formula><mml:math id="M65" altimg="si70.svg"><mml:mrow><mml:mo>∥</mml:mo><mml:mo>·</mml:mo><mml:mo>∥</mml:mo></mml:mrow></mml:math></inline-formula> is used in the termination criteria. The <italic>diagonal dominance</italic> of the matrix <inline-formula><mml:math id="M66" altimg="si71.svg"><mml:mi>A</mml:mi></mml:math></inline-formula> is a sufficient condition for the convergence of the Jacobi method:<disp-formula id="ueqn0008"><mml:math id="M67" altimg="si72.svg"><mml:mrow><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true">|</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true">|</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak">−</mml:mo><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="true">|</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>for all <inline-formula><mml:math id="M68" altimg="si61.svg"><mml:mrow><mml:mi>i</mml:mi><mml:mspace width="0.28em"/><mml:mo linebreak="goodbreak">=</mml:mo><mml:mspace width="0.28em"/><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mspace width="0.28em"/><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, and at least one inequality is strict. In this case, the system (1) has a unique solution for any right-hand side.</p>
    <p id="para0258">Let us represent the Jacobi method in the form of algorithm on lists. Let <inline-formula><mml:math id="M69" altimg="si73.svg"><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula> denotes the <italic>j</italic>-th column of matrix <inline-formula><mml:math id="M70" altimg="si74.svg"><mml:mi>C</mml:mi></mml:math></inline-formula>:<disp-formula id="ueqn0009"><mml:math id="M71" altimg="si75.svg"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo linebreak="goodbreak">=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
    <p id="para0259">Let <inline-formula><mml:math id="M72" altimg="si76.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula> be the list of natural numbers from 1 to <italic>n</italic>. For any vector <inline-formula><mml:math id="M73" altimg="si77.svg"><mml:mrow><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, let us define the function <inline-formula><mml:math id="M74" altimg="si78.svg"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mo>→</mml:mo><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> as follows:<disp-formula id="ueqn0010"><mml:math id="M75" altimg="si79.svg"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak">=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> i.e. the function <inline-formula><mml:math id="M76" altimg="si80.svg"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> multiplies the <italic>j</italic>-th column of the matrix <italic>C</italic> by the <italic>j</italic>-th coordinate of the vector <italic>x</italic>. The BSF-implementation of the Jacobi method presented as <xref rid="tbl0008" ref-type="table">Algorithm 3</xref> can be easily obtained from the generic BSF-algorithm template (see <xref rid="tbl0006" ref-type="table">Algorithm 1</xref>). In the <xref rid="tbl0007" ref-type="table">algorithm 2</xref>, <inline-formula><mml:math id="M77" altimg="si81.svg"><mml:mover accent="true"><mml:mo>+</mml:mo><mml:mo>→</mml:mo></mml:mover></mml:math></inline-formula> and <inline-formula><mml:math id="M78" altimg="si82.svg"><mml:mover accent="true"><mml:mo>−</mml:mo><mml:mo>→</mml:mo></mml:mover></mml:math></inline-formula> denote the operations of vector addition and subtraction, respectively. Note that the matrix <italic>C</italic> entered in line 1 is implicitly used to calculate the values of the function <inline-formula><mml:math id="M79" altimg="si83.svg"><mml:msub><mml:mi>F</mml:mi><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:msub></mml:math></inline-formula> in line 3.<table-wrap position="float" id="tbl0007"><label>Algorithm 2</label><caption><p>BSF-skeleton parallelization template.</p></caption><alt-text id="alt0011">Algorithm 2</alt-text><table frame="hsides" rules="groups"><thead><tr><th valign="top"/><th valign="top"><italic>Master</italic></th><th valign="top"/><th valign="top"><italic>j-th worker (j=0,…,K-1)</italic></th></tr></thead><tbody><tr><td valign="top">1:</td><td valign="top">input <inline-formula><mml:math id="M80" altimg="si12.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula>; <inline-formula><mml:math id="M81" altimg="si5.svg"><mml:mrow><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></td><td valign="top">1:</td><td valign="top">input <inline-formula><mml:math id="M82" altimg="si13.svg"><mml:msub><mml:mi>A</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula></td></tr><tr><td valign="top">2:</td><td valign="top"><inline-formula><mml:math id="M83" altimg="si14.svg"><mml:mrow><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mi>T</mml:mi><mml:mi>o</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>l</mml:mi><mml:mi>W</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td><td valign="top">2:</td><td valign="top"><inline-formula><mml:math id="M84" altimg="si15.svg"><mml:mrow><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi><mml:mi>v</mml:mi><mml:mi>F</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>m</mml:mi><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">3:</td><td valign="top"/><td valign="top">3:</td><td valign="top"><inline-formula><mml:math id="M85" altimg="si16.svg"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>p</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">4:</td><td valign="top"/><td valign="top">4:</td><td valign="top"><inline-formula><mml:math id="M86" altimg="si17.svg"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>⊕</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">5:</td><td valign="top"><inline-formula><mml:math id="M87" altimg="si18.svg"><mml:mrow><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi><mml:mi>v</mml:mi><mml:mi>F</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>m</mml:mi><mml:mi>W</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td><td valign="top">5:</td><td valign="top"><inline-formula><mml:math id="M88" altimg="si19.svg"><mml:mrow><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mi>T</mml:mi><mml:mi>o</mml:mi><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">6:</td><td valign="top"><inline-formula><mml:math id="M89" altimg="si20.svg"><mml:mrow><mml:mi>s</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mo>⊕</mml:mo><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>K</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td><td valign="top">6:</td><td valign="top"/></tr><tr><td valign="top">7:</td><td valign="top"><inline-formula><mml:math id="M90" altimg="si8.svg"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>m</mml:mi><mml:mi>p</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td valign="top">7:</td><td valign="top"/></tr><tr><td valign="top">8:</td><td valign="top"><inline-formula><mml:math id="M91" altimg="si9.svg"><mml:mrow><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td><td valign="top">8:</td><td valign="top"/></tr><tr><td valign="top">9:</td><td valign="top"><inline-formula><mml:math id="M92" altimg="si21.svg"><mml:mrow><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mi>p</mml:mi><mml:mi>C</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td><td valign="top">9:</td><td valign="top"/></tr><tr><td valign="top">10:</td><td valign="top"><inline-formula><mml:math id="M93" altimg="si22.svg"><mml:mrow><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mi>T</mml:mi><mml:mi>o</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>l</mml:mi><mml:mi>W</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>s</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td><td valign="top">10:</td><td valign="top"><inline-formula><mml:math id="M94" altimg="si23.svg"><mml:mrow><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi><mml:mi>v</mml:mi><mml:mi>F</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>m</mml:mi><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">11:</td><td valign="top">if <inline-formula><mml:math id="M95" altimg="si24.svg"><mml:mrow><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> goto 2</td><td valign="top">11:</td><td valign="top">if <inline-formula><mml:math id="M96" altimg="si24.svg"><mml:mrow><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> goto 2</td></tr><tr><td valign="top">12:</td><td valign="top">output <inline-formula><mml:math id="M97" altimg="si11.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula></td><td valign="top">12:</td><td valign="top"/></tr><tr><td valign="top">13:</td><td valign="top">stop</td><td valign="top">13:</td><td valign="top">stop</td></tr></tbody></table></table-wrap><table-wrap position="float" id="tbl0008"><label>Algorithm 3</label><caption><p> </p></caption><alt-text id="alt0012">Algorithm 3</alt-text><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="top"><inline-formula><mml:math id="M98" altimg="si25.svg"><mml:mrow><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula></th><th valign="top">input <inline-formula><mml:math id="M99" altimg="si25.svg"><mml:mrow><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula></th></tr></thead><tbody><tr><td>1:</td><td>input <italic>C, d</italic></td></tr><tr><td valign="top">2:</td><td valign="top"><inline-formula><mml:math id="M100" altimg="si26.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="M101" altimg="si27.svg"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="M102" altimg="si28.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">3:</td><td valign="top"><inline-formula><mml:math id="M103" altimg="si29.svg"><mml:mrow><mml:mi>B</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>p</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:msub><mml:mo>,</mml:mo><mml:mi>G</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">4:</td><td valign="top"><inline-formula><mml:math id="M104" altimg="si30.svg"><mml:mrow><mml:mi>s</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mo>+</mml:mo><mml:mo>→</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mi>B</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">5:</td><td valign="top"><inline-formula><mml:math id="M105" altimg="si31.svg"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mover accent="true"><mml:mo>+</mml:mo><mml:mo>→</mml:mo></mml:mover><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">6:</td><td valign="top"><inline-formula><mml:math id="M106" altimg="si32.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">7:</td><td valign="top">If <inline-formula><mml:math id="M107" altimg="si33.svg"><mml:mrow><mml:mrow><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mover accent="true"><mml:mo>−</mml:mo><mml:mo>→</mml:mo></mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:msup><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo linebreak="goodbreak">&lt;</mml:mo><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> goto 9</td></tr><tr><td valign="top">8:</td><td valign="top">goto 3</td></tr><tr><td valign="top">9:</td><td valign="top">output <inline-formula><mml:math id="M108" altimg="si11.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula></td></tr><tr><td valign="top">10:</td><td valign="top">stop</td></tr></tbody></table></table-wrap></p>
    <p id="para0261">The source code of the BSF-Jacobi algorithm, implemented by using the BSF-skeleton, is freely available on Github at <ext-link ext-link-type="uri" xlink:href="https://github.com/leonid-sokolinsky/BSF-Jacobi" id="interref0003">https://github.com/leonid-sokolinsky/BSF-Jacobi</ext-link>. Additional examples of using the BSF-skeleton can be found on GitHub at the following links:<list list-type="simple" id="celist0001"><list-item id="celistitem0001"><label>•</label><p id="para0262"><ext-link ext-link-type="uri" xlink:href="https://github.com/leonid-sokolinsky/BSF-LPP-Generator" id="interref0004">https://github.com/leonid-sokolinsky/BSF-LPP-Generator</ext-link>;</p></list-item><list-item id="celistitem0002"><label>•</label><p id="para0263"><ext-link ext-link-type="uri" xlink:href="https://github.com/leonid-sokolinsky/BSF-LPP-Validator" id="interref0005">https://github.com/leonid-sokolinsky/BSF-LPP-Validator</ext-link>;</p></list-item><list-item id="celistitem0003"><label>•</label><p id="para0264"><ext-link ext-link-type="uri" xlink:href="https://github.com/leonid-sokolinsky/BSF-gravity" id="interref0006">https://github.com/leonid-sokolinsky/BSF-gravity</ext-link>;</p></list-item><list-item id="celistitem0004"><label>•</label><p id="para0265"><ext-link ext-link-type="uri" xlink:href="https://github.com/leonid-sokolinsky/BSF-Cimmino" id="interref0007">https://github.com/leonid-sokolinsky/BSF-Cimmino</ext-link>;</p></list-item><list-item id="celistitem0005"><label>•</label><p id="para0266"><ext-link ext-link-type="uri" xlink:href="https://github.com/leonid-sokolinsky/NSLP-Quest" id="interref0008">https://github.com/leonid-sokolinsky/NSLP-Quest</ext-link>.</p></list-item></list></p>
  </sec>
  <sec id="sec0011">
    <title>Workflow support</title>
    <p id="para0267">The BSF-skeleton supports workflows. A workflow consists of orchestrated and repeatable activities (jobs). The BSF-skeleton supports up to four different jobs. The starting job is always numbered 0 (omitted in the source codes). The other jobs have sequential numbers 1, ..., 3. Each job has its own type of reduce-list elements defined in the file <italic>Problem-bsfTypes.h</italic>. All jobs have the same type of map list elements. To organize the workflow, we need to follow these steps:</p>
    <p id="para0268">In the file <italic>Problem-bsfParameters.h</italic>, redefine the macros <italic>PP_BSF_MAX_JOB_CASE</italic> specifying the largest number of a job. For example, if the total job quantity is 3, the number to be assigned to <italic>PP_BSF_MAX_JOB_CASE</italic> must be 2.</p>
    <p id="para0269">In the file <italic>Problem-bsfTypes.h</italic>, define the types of reduce-list elements for all jobs whose sequential numbers are less than or equal to <italic>PP_BSF_MAX_JOB_CASE</italic>.</p>
    <p id="para0270">In the file <italic>Problem-bsfCode.cpp</italic>, implement the functions <italic>PC_bsf_MapF[_*], PC_bsf_ReduceF[_*], PC_bsf_ProcessResults[_*], PC_bsf_ProblemOutput[_*]</italic> and <italic>PC_bsf_IterOutput[_*]</italic> for all jobs whose sequential numbers are less than or equal to <italic>PP_BSF_MAX_JOB_CASE</italic>. The functions <italic>PC_bsf_ProblemOutput[_*]</italic> should assign the parameter <italic>*nextJob</italic> a sequential number of the next job (possibly the same).</p>
    <p id="para0271">If the number of workflow states is greater than the number of jobs, you can use the function <italic>PC_bsd_JobDispatcher</italic> to manage these states. An example of a solution using the BSF-skeleton with the workflow support is freely available on Github at <ext-link ext-link-type="uri" xlink:href="https://github.com/leonid-sokolinsky/Apex-method" id="interref0009">https://github.com/leonid-sokolinsky/Apex-method</ext-link>
<xref rid="bib0009" ref-type="bibr">[9]</xref>.</p>
  </sec>
  <sec id="sec0012">
    <title>OpenMP support</title>
    <p id="para0272">The BSF-skeleton supports a parallelization of the map-list processing cycle in the worker processes (the function <italic>BC_WorkerMap</italic>) using the #pragma omp parallel for. This support is disabled by default. To enable this support, we must define the macros <italic>PP_SF_OMP</italic> in the file <italic>Problem-bsfParameters.h</italic>. Using the macros <italic>PP_BSF_NUM_THREADS</italic>, we can specify the number of threads to use in the parallel for. By default, all available threads are used.</p>
  </sec>
  <sec id="sec0013">
    <title>Using Map without Reduce</title>
    <p id="para0273">Some numerical algorithms can be implemented naturally using the function <italic>Map</italic> without the function <italic>Reduce</italic>
<xref rid="bib0010" ref-type="bibr">[10]</xref>. In this section, we will show how to use the BSF-skeleton in this case. As an example, we use the Jacobi method described above. Let <inline-formula><mml:math id="M109" altimg="si76.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula> be the list of natural numbers from 1 to <italic>n</italic>. For any vector <inline-formula><mml:math id="M110" altimg="si77.svg"><mml:mrow><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mi mathvariant="double-struck">R</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, let us define the function <inline-formula><mml:math id="M111" altimg="si84.svg"><mml:mrow><mml:msub><mml:mstyle mathvariant="normal"><mml:mi>Φ</mml:mi></mml:mstyle><mml:mi>x</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mo>→</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:math></inline-formula> as follows:<disp-formula id="eqn0002"><label>(2)</label><mml:math id="M112" altimg="si85.svg"><mml:mrow><mml:msub><mml:mstyle mathvariant="normal"><mml:mi>Φ</mml:mi></mml:mstyle><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak">=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo linebreak="goodbreak">+</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:msub><mml:mi>c</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> i.e. the function <inline-formula><mml:math id="M113" altimg="si86.svg"><mml:mrow><mml:msub><mml:mstyle mathvariant="normal"><mml:mi>Φ</mml:mi></mml:mstyle><mml:mi>x</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> calculates the <italic>i</italic>-th coordinate of the next approximation. An implementation of the Jacobi method that uses only a higher-order function <italic>Map</italic> is shown in <xref rid="tbl0009" ref-type="table">Algorithm 4</xref>. In this case, the reduce-list consists of coordinates of the next approximation and does not require performing <italic>Reduce</italic>. An implementation of <xref rid="tbl0009" ref-type="table">Algorithm 4</xref> using the BSF-skeleton is freely available on Github at <ext-link ext-link-type="uri" xlink:href="https://github.com/leonid-sokolinsky/BSF-Jacobi-Map" id="interref0010">https://github.com/leonid-sokolinsky/BSF-Jacobi-Map</ext-link>. In the implementation of the function <italic>PC_bsf_MapF</italic>, we had to apply a couple of tricks that use the skeleton variables <italic>BSF_sv_numberInSublist, BSF_sv_addressOffset</italic> and <italic>BSF_sv_sublistLength</italic> (see Section “Skeleton variables”).<table-wrap position="float" id="tbl0009"><label>Algorithm 4</label><caption><p> </p></caption><alt-text id="alt0013">Algorithm 4</alt-text><table frame="hsides" rules="groups"><thead><tr><th align="left" valign="top"><inline-formula><mml:math id="M114" altimg="si25.svg"><mml:mrow><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula></th><th valign="top">input <inline-formula><mml:math id="M115" altimg="si25.svg"><mml:mrow><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula></th></tr></thead><tbody><tr><td>1:</td><td>input <italic>C, d</italic></td></tr><tr><td valign="top">2:</td><td valign="top"><inline-formula><mml:math id="M116" altimg="si26.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="M117" altimg="si27.svg"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="M118" altimg="si28.svg"><mml:mrow><mml:mi>G</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">3:</td><td valign="top"><inline-formula><mml:math id="M119" altimg="si34.svg"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mi>a</mml:mi><mml:mi>p</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mstyle mathvariant="normal"><mml:mi>Φ</mml:mi></mml:mstyle><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:msub><mml:mo>,</mml:mo><mml:mi>G</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">4:</td><td valign="top"><inline-formula><mml:math id="M120" altimg="si32.svg"><mml:mrow><mml:mi>k</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td></tr><tr><td valign="top">5:</td><td valign="top">if <inline-formula><mml:math id="M121" altimg="si33.svg"><mml:mrow><mml:mrow><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mover accent="true"><mml:mo>−</mml:mo><mml:mo>→</mml:mo></mml:mover><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:msup><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo linebreak="goodbreak">&lt;</mml:mo><mml:mrow><mml:mi>ε</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> goto 7</td></tr><tr><td valign="top">6:</td><td valign="top">goto 3</td></tr><tr><td valign="top">7:</td><td valign="top">output <inline-formula><mml:math id="M122" altimg="si11.svg"><mml:msup><mml:mi>x</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula></td></tr><tr><td valign="top">8:</td><td valign="top">stop</td></tr></tbody></table></table-wrap></p>
    <p id="para0275">Supplementary material: The source code of the BSF-skeleton is freely available on Github at <ext-link ext-link-type="uri" xlink:href="https://github.com/leonid-sokolinsky/BSF-skeleton" id="interref0011">https://github.com/leonid-sokolinsky/BSF-skeleton</ext-link>.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Declaration of competing Interest</title>
    <p id="para0276">The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.</p>
  </sec>
</body>
<back>
  <ref-list id="cebibl1">
    <title>References</title>
    <ref id="bib0001">
      <label>1</label>
      <element-citation publication-type="journal" id="sbref0001">
        <person-group person-group-type="author">
          <name>
            <surname>Gorlatch</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Cole</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>Parallel Skeletons</article-title>
        <source>Encyclop. Parallel Comput.</source>
        <year>2011</year>
        <fpage>1417</fpage>
        <lpage>1422</lpage>
        <pub-id pub-id-type="doi">10.1007/978-0-387-09766-4_24</pub-id>
      </element-citation>
    </ref>
    <ref id="bib0002">
      <label>2</label>
      <element-citation publication-type="journal" id="sbref0002">
        <person-group person-group-type="author">
          <name>
            <surname>Ernsting</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Kuchen</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <article-title>A scalable farm skeleton for hybrid parallel and distributed programming</article-title>
        <source>Int. J. Parallel Program.</source>
        <volume>42</volume>
        <year>2014</year>
        <fpage>968</fpage>
        <lpage>987</lpage>
        <pub-id pub-id-type="doi">10.1007/s10766-013-0269-2</pub-id>
      </element-citation>
    </ref>
    <ref id="bib0003">
      <label>3</label>
      <element-citation publication-type="journal" id="sbref0003">
        <person-group person-group-type="author">
          <name>
            <surname>Beaumont</surname>
            <given-names>O.</given-names>
          </name>
          <name>
            <surname>Legrand</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Robert</surname>
            <given-names>Y.</given-names>
          </name>
        </person-group>
        <article-title>The master-slave paradigm with heterogeneous processors</article-title>
        <source>IEEE Trans. Parallel Distrib. Syst.</source>
        <volume>14</volume>
        <year>2003</year>
        <fpage>897</fpage>
        <lpage>908</lpage>
        <pub-id pub-id-type="doi">10.1109/TPDS.2003.1233712</pub-id>
      </element-citation>
    </ref>
    <ref id="bib0004">
      <label>4</label>
      <element-citation publication-type="journal" id="sbref0004">
        <person-group person-group-type="author">
          <name>
            <surname>Leung</surname>
            <given-names>J.Y.-T.</given-names>
          </name>
          <name>
            <surname>Zhao</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <article-title>Scheduling problems in master-slave model</article-title>
        <source>Ann. Oper. Res.</source>
        <volume>159</volume>
        <year>2008</year>
        <fpage>215</fpage>
        <lpage>231</lpage>
        <pub-id pub-id-type="doi">10.1007/s10479-007-0271-4</pub-id>
      </element-citation>
    </ref>
    <ref id="bib0005">
      <label>5</label>
      <element-citation publication-type="journal" id="sbref0005">
        <person-group person-group-type="author">
          <name>
            <surname>Sahni</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Vairaktarakis</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>The master-slave paradigm in parallel computer and industrial settings</article-title>
        <source>J. Glob. Optim.</source>
        <volume>9</volume>
        <year>1996</year>
        <fpage>357</fpage>
        <lpage>377</lpage>
        <pub-id pub-id-type="doi">10.1007/BF00121679</pub-id>
      </element-citation>
    </ref>
    <ref id="bib0006">
      <label>6</label>
      <element-citation publication-type="journal" id="sbref0006">
        <person-group person-group-type="author">
          <name>
            <surname>Sokolinsky</surname>
            <given-names>L.B.</given-names>
          </name>
        </person-group>
        <article-title>BSF: A parallel computation model for scalability estimation of iterative numerical algorithms on cluster computing systems</article-title>
        <source>J. Parallel Distrib. Comput.</source>
        <volume>149</volume>
        <year>2021</year>
        <fpage>193</fpage>
        <lpage>206</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jpdc.2020.12.009</pub-id>
      </element-citation>
    </ref>
    <ref id="bib0007">
      <label>7</label>
      <mixed-citation publication-type="other" id="sbref0007">R.S. Bird, Lectures on constructive functional programming, in: M. Broy (Ed.), Constructive Methods in Computing Science. NATO ASI Series F: Computer and Systems Sciences, Vol. 55, Springer, Berlin, Heidlberg, 1988: pp. 151–216.</mixed-citation>
    </ref>
    <ref id="bib0008">
      <label>8</label>
      <mixed-citation publication-type="other" id="sbref0007a"><pub-id pub-id-type="doi">10.1007/978-3-662-39778-7_12</pub-id>.</mixed-citation>
    </ref>
    <ref id="bib0009">
      <label>9</label>
      <element-citation publication-type="book" id="sbref0009">
        <person-group person-group-type="author">
          <name>
            <surname>Sokolinsky</surname>
            <given-names>L.B.</given-names>
          </name>
          <name>
            <surname>Sokolinskaya</surname>
            <given-names>I.M.</given-names>
          </name>
        </person-group>
        <chapter-title>Scalable method for linear optimization of industrial processes</chapter-title>
        <source>Proceedings - 2020 Global Smart Industry Conference, GloSIC 2020</source>
        <year>2020</year>
        <publisher-name>IEEE</publisher-name>
        <fpage>20</fpage>
        <lpage>26</lpage>
        <pub-id pub-id-type="doi">10.1109/GloSIC50886.2020.9267854</pub-id>
      </element-citation>
    </ref>
    <ref id="bib0010">
      <label>10</label>
      <element-citation publication-type="book" id="sbref0010">
        <person-group person-group-type="author">
          <name>
            <surname>Ezhova</surname>
            <given-names>N.A.</given-names>
          </name>
          <name>
            <surname>Sokolinsky</surname>
            <given-names>L.B.</given-names>
          </name>
        </person-group>
        <chapter-title>Scalability evaluation of iterative algorithms used for supercomputer simulation of physical processes</chapter-title>
        <source>Proceedings - 2018 Global Smart Industry Conference, GloSIC 2018</source>
        <year>2018</year>
        <publisher-name>IEEE</publisher-name>
        <fpage>10</fpage>
        <pub-id pub-id-type="doi">10.1109/GloSIC.2018.8570131</pub-id>
      </element-citation>
    </ref>
  </ref-list>
  <ack id="ack0001">
    <title>Acknowledgements</title>
    <p id="para0277">This work was supported by the <funding-source id="gs0001"><institution-wrap><institution-id institution-id-type="doi">10.13039/100012555</institution-id><institution>Russian Foundation</institution></institution-wrap></funding-source> for Basic Research [project No. 20-07-00092-a] and the Ministry of Science and Higher Education of the <funding-source id="gs0002"><institution-wrap><institution-id institution-id-type="doi">10.13039/501100017638</institution-id><institution>Russian Federation</institution></institution-wrap></funding-source> [gov. order FENU-2020-0022].</p>
  </ack>
</back>
