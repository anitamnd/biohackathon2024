<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d1 20130915//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Syst Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Syst. Biol</journal-id>
    <journal-id journal-id-type="publisher-id">sysbio</journal-id>
    <journal-id journal-id-type="hwp">sysbio</journal-id>
    <journal-title-group>
      <journal-title>Systematic Biology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1063-5157</issn>
    <issn pub-type="epub">1076-836X</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4678253</article-id>
    <article-id pub-id-type="doi">10.1093/sysbio/syv068</article-id>
    <article-id pub-id-type="publisher-id">syv068</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Regular Articles</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Fast Dating Using Least-Squares Criteria and Algorithms</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>To</surname>
          <given-names>Thu-Hien</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Jung</surname>
          <given-names>Matthieu</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="AFF2">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lycett</surname>
          <given-names>Samantha</given-names>
        </name>
        <xref ref-type="aff" rid="AFF3">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Gascuel</surname>
          <given-names>Olivier</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="COR1">*</xref>
      </contrib>
      <aff id="AFF1"><sup>1</sup>Institut de Biologie Computationnelle, LIRMM, UMR 5506 CNRS – Université de Montpellier, France;</aff>
      <aff id="AFF2"><sup>2</sup>IGBMC (Institut de Génétique et de Biologie Moléculaire et Cellulaire), INSERM, U596, CNRS, UMR7104, Université de Strasbourg, Illkirch, France;</aff>
      <aff id="AFF3"><sup>3</sup>Institute of Evolutionary Biology, University of Edinburgh, Ashworth Laboratories, Edinburgh, UK</aff>
    </contrib-group>
    <author-notes>
      <corresp id="COR1">*Correspondence to be sent to: Institut de Biologie Computationnelle, LIRMM, UMR 5506 CNRS – Université de Montpellier, 161 rue Ada, 34392 Montpellier, France; Email: <email>gascuel@lirmm.fr</email></corresp>
      <fn id="FN1">
        <p>Associate Editor: Lars Jermiin</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>1</month>
      <year>2016</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>30</day>
      <month>9</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>9</month>
      <year>2015</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>65</volume>
    <issue>1</issue>
    <fpage>82</fpage>
    <lpage>97</lpage>
    <history>
      <date date-type="received">
        <day>10</day>
        <month>9</month>
        <year>2014</year>
      </date>
      <date date-type="rev-request">
        <day>16</day>
        <month>9</month>
        <year>2015</year>
      </date>
      <date date-type="accepted">
        <day>16</day>
        <month>9</month>
        <year>2015</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2015. Published by Oxford University Press, on behalf of the Society of Systematic Biologists.</copyright-statement>
      <copyright-year>2015</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>Phylogenies provide a useful way to understand the evolutionary history of genetic samples, and data sets with more than a thousand taxa are becoming increasingly common, notably with viruses (e.g., human immunodeficiency virus (HIV)). Dating ancestral events is one of the first, essential goals with such data. However, current sophisticated probabilistic approaches struggle to handle data sets of this size. Here, we present very fast dating algorithms, based on a Gaussian model closely related to the Langley–Fitch molecular-clock model. We show that this model is robust to uncorrelated violations of the molecular clock. Our algorithms apply to serial data, where the tips of the tree have been sampled through times. They estimate the substitution rate and the dates of all ancestral nodes. When the input tree is unrooted, they can provide an estimate for the root position, thus representing a new, practical alternative to the standard rooting methods (e.g., midpoint). Our algorithms exploit the tree (recursive) structure of the problem at hand, and the close relationships between least-squares and linear algebra. We distinguish between an unconstrained setting and the case where the temporal precedence constraint (i.e., an ancestral node must be older that its daughter nodes) is accounted for. With rooted trees, the former is solved using linear algebra in linear computing time (i.e., proportional to the number of taxa), while the resolution of the latter, constrained setting, is based on an active-set method that runs in nearly linear time. With unrooted trees the computing time becomes (nearly) quadratic (i.e., proportional to the square of the number of taxa). In all cases, very large input trees (&gt;10,000 taxa) can easily be processed and transformed into time-scaled trees. We compare these algorithms to standard methods (root-to-tip, r8s version of Langley–Fitch method, and BEAST). Using simulated data, we show that their estimation accuracy is similar to that of the most sophisticated methods, while their computing time is much faster. We apply these algorithms on a large data set comprising 1194 strains of Influenza virus from the pdm09 H1N1 Human pandemic. Again the results show that these algorithms provide a very fast alternative with results similar to those of other computer programs. These algorithms are implemented in the LSD software (least-squares dating), which can be downloaded from <ext-link ext-link-type="uri" xlink:href="http://www.atgc-montpellier.fr/LSD/">http://www.atgc-montpellier.fr/LSD/</ext-link>, along with all our data sets and detailed results. An Online Appendix, providing additional algorithm descriptions, tables, and figures can be found in the Supplementary Material available on Dryad at <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.5061/dryad.968t3">http://dx.doi.org/10.5061/dryad.968t3</ext-link>.</p>
    </abstract>
    <kwd-group>
      <kwd>Active-set method</kwd>
      <kwd>algorithms</kwd>
      <kwd>computer simulations</kwd>
      <kwd>dating</kwd>
      <kwd>influenza (H1N1)</kwd>
      <kwd>least-squares</kwd>
      <kwd>linear algebra</kwd>
      <kwd>molecular clock</kwd>
      <kwd>serial data</kwd>
      <kwd>substitution rate estimation</kwd>
      <kwd>temporal precedence constraints</kwd>
      <kwd>viruses</kwd>
    </kwd-group>
    <counts>
      <page-count count="16"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec sec-type="Introduction">
    <title>I<sc>ntroduction</sc></title>
    <p>The explosion of genetic data and progress in phylogenetic reconstruction algorithms has resulted in increasing utility and popularity of phylogenetic analyses. Data sets with thousands of taxa are becoming more and more common, especially amongst virus evolution studies. Moreover, a number of studies have used molecular-dating techniques to tackle a wide range of biological questions, for example, in systematics for timing the tree of life (<xref rid="B27" ref-type="bibr">Hedges and Kumar 2009</xref>; <xref rid="B28" ref-type="bibr">Jetz et al. 2014</xref>), in epidemiology to trace back the phylodynamics and phylogeography of epidemics (<xref rid="B22" ref-type="bibr">Grenfell et al. 2004</xref>; <xref rid="B58" ref-type="bibr">Volz et al. 2013</xref>), and in functional genomics to decipher orthology/paralogy relationships within gene families and improve reconciliation inferences (<xref rid="B2" ref-type="bibr">Akerborg et al. 2009</xref>; <xref rid="B12" ref-type="bibr">Doyon et al. 2011</xref>; <xref rid="B44" ref-type="bibr">Rasmussen and Kellis 2012</xref>).</p>
    <p>Currently, the most popular dating approaches are based on sophisticated probabilistic models, most often implemented in the Bayesian framework and able to account for complex priors (<xref rid="B57" ref-type="bibr">Thorne and Kishino 2002</xref>; <xref rid="B43" ref-type="bibr">Rannala and Yang 2007</xref>; <xref rid="B17" ref-type="bibr">Drummond and Rambaut 2007</xref>; <xref rid="B23" ref-type="bibr">Guindon et al. 2010</xref>). Maximum-likelihood methods have also been designed to deal with simpler models (<xref rid="B39" ref-type="bibr">Rambaut 2000</xref>). Corresponding computer programs take a sequence alignment and a set of known dates as input and return a time-scaled tree, with estimates of the substitution rate(s) and of the dates of all tree nodes. Some programs (e.g., PAML, <xref rid="B43" ref-type="bibr">Rannala and Yang 2007</xref>) perform calculations on a fixed, user-supplied tree, while others (e.g., BEAST, <xref rid="B17" ref-type="bibr">Drummond and Rambaut 2007</xref>; <xref rid="B18" ref-type="bibr">Drummond et al. 2012</xref>) infer the tree from the sequence alignment. These programs typically contain several submodels, which describe the substitution process (e.g., GTR, <inline-formula><mml:math id="I1"><mml:mo>Γ</mml:mo></mml:math></inline-formula> distribution of rates across sites, etc.), the tree (e.g., coalescent, constant or varying population size, birth–death, etc.), priors on the parameter values and, most importantly regarding dating, the molecular clock. We distinguish the strict molecular clock (SMC) model, where the substitution rate is assumed to be constant across all tree branches, and uncorrelated and correlated relaxed-clock models. With uncorrelated models, the rate associated with each branch is drawn independently from a common underlying distribution; these models are commonly used with fast-evolving species over short time periods, typically with viruses for which there is no strong evidence of rate correlation among branches (<xref rid="B16" ref-type="bibr">Drummond et al. 2006</xref>). With correlated (also called autocorrelated) models, the rate distribution for a particular branch depends on the rate value of the neighboring branches; the use of correlated models seems to be the preferred choice with large groups of slowly evolving species, for example mammals, where it has been demonstrated that some subgroups evolve faster than others (e.g., the rodents, <xref rid="B11" ref-type="bibr">Douzery et al. 2003</xref>). However, the advantages and limitations of this large variety of models is still a question of debate (<xref rid="B16" ref-type="bibr">Drummond et al. 2006</xref>; <xref rid="B33" ref-type="bibr">Lepage et al. 2007</xref>; <xref rid="B4" ref-type="bibr">Battistuzzi et al. 2010</xref>). All these models and methods have shown to be useful in a number of studies, but they are computationally intensive, making it virtually impossible to deal with the larger data sets available today, even when using sophisticated implementations and powerful computers (<xref rid="B3" ref-type="bibr">Ayres et al. 2012</xref>). Typically, days of computations are required to analyze a few hundred taxa, although faster approaches are available, using complex algorithmic approaches (<xref rid="B1" ref-type="bibr">Akerborg et al. 2008</xref>; <xref rid="B23" ref-type="bibr">Guindon et al. 2010</xref>) and multinormal approximations of the likelihood function (<xref rid="B56" ref-type="bibr">Thorne et al. 1998</xref>).</p>
    <p>Here we are interested in dating very large phylogenies, typically with a thousand tips or more, a need that is becoming increasingly common, for example, in molecular epidemiology. We propose distance-based algorithms to estimate rates and dates, a mathematical and computational framework that has proven to produce fast and fairly accurate tools in phylogenetics (e.g., NJ, <xref rid="B46" ref-type="bibr">Saitou and Nei 1987</xref>). Several distance-based (as opposed to sequence-based, see above) dating methods have already been proposed. Most of these methods deal with time calibration points, where the dates of certain ancestral nodes in the tree are known, possibly with uncertainty (e.g., min–max values), and all of the tree tips are contemporaneous. These methods input a rooted tree with time calibration points, and return a time-scaled, ultrametric tree. PATHd8 (<xref rid="B8" ref-type="bibr">Britton et al. 2007</xref>) and the <xref rid="B55" ref-type="bibr">Tamura et al. (2012)</xref> method use smoothing and averaging techniques to accommodate for local rate variations. <xref rid="B59" ref-type="bibr">Xia and Yang's (2011)</xref> method assumes a SMC or two different local clocks, and achieves least-squares estimations under these assumptions. <xref rid="B47" ref-type="bibr">Sanderson's (1997</xref>, <xref rid="B48" ref-type="bibr">2002</xref>) approach is based on a penalized-likelihood criterion to account for the autocorrelation of rates, combined with standard optimization techniques (see also TreePL, <xref rid="B51" ref-type="bibr">Smith and O'Meara 2012</xref>). Based on computer simulations, these fast methods were shown to be accurate by their authors, producing time-scaled trees similar to those obtained using sequence-based approaches.</p>
    <p>The focus of the present study is on serial phylogenies, where the tips of the tree have been sampled through times. Such phylogenies are common with fast-evolving organisms (e.g., human immunodeficiency virus (HIV)), where a few years of evolution induce significant changes at the sequence level (<xref rid="B14" ref-type="bibr">Drummond et al. 2003a</xref>). Serial phylogenies are also used with ancient DNA (<xref rid="B29" ref-type="bibr">Lambert et al. 2002</xref>). Moreover, close relationships exist between the calibration-points and dated-tips approaches (<xref rid="B45" ref-type="bibr">Ronquist et al. 2012</xref>). Several methods have been proposed in this framework. One of the very first is root-to-tip regression (RTT) (<xref rid="B50" ref-type="bibr">Shankarappa et al. 1999</xref>; <xref rid="B15" ref-type="bibr">Drummond et al. 2003b</xref>): assuming a SMC, the root-to-tip distance in the input tree should be proportional to the corresponding elapsed time; then, a standard regression of the root-to-tip distance for every tip as a function of its date provides estimates of the substitution rate (regression slope) and root date (intercept with <inline-formula><mml:math id="I2"><mml:mi>X</mml:mi></mml:math></inline-formula>-axis). This method is very fast and can be extended to unrooted trees by searching among all tree branches for the best root position, according to some numerical criterion (e.g., the sum of regression residues, to be minimized). However, this method does not provide estimates for the dates of internal nodes, and thus does not output time-scaled trees. The same holds for TREBLE (<xref rid="B60" ref-type="bibr">Yang et al. 2007</xref>), which is a triplet-based alternative to RTT that is also able to process unrooted trees. To obtain date estimates of the internal nodes, sUPGMA (<xref rid="B13" ref-type="bibr">Drummond and Rodrigo 2000</xref>) combines a regression method to estimate the substitution rate in a first step, corrects the non-contemporaneous tips into contemporaneous tips in a second step and then uses UPGMA (<xref rid="B52" ref-type="bibr">Sokal and Michener 1958</xref>) to compute the tree. Unlike the former approaches, Langley and Fitch's (<xref rid="B30" ref-type="bibr">LF; 1974</xref>) method uses an explicit model. The LF method assumes a SMC with a constant substitution rate, and models the number of substitutions along each branch of the tree by a Poisson distribution. The estimates of the global substitution rate and of the internal node dates are then obtained by maximizing the likelihood of the input, rooted tree. LF is implemented in r8s (<xref rid="B49" ref-type="bibr">Sanderson 2003</xref>).</p>
    <p>In this article, we study a model analogous to LF's, but using a normal approximation that allows for a least-squares approach, and show that this model is robust to uncorrelated violations of the molecular clock. Using the tree (recursive) structure of the problem at hand, and the close relationships between least-squares and linear algebra, we propose very fast algorithms to estimate the substitution rate and the dates of all internal tree nodes. With rooted trees, the time complexity is nearly linear (i.e., proportional to the number of taxa), while with unrooted trees, it becomes nearly quadratic (i.e., proportional to the square of the number of taxa). In both cases, very large trees (&gt;10,000 taxa) can easily be processed and transformed into time-scaled trees. The article is organized as follows: we first define the model and show its ability to handle uncorrelated rate variations among tree branches, as is commonly assumed with virus data. We then present our two main algorithms, distinguishing the unconstrained setting and the case where the temporal precedence constraints (i.e., an ancestral node must be older than its daughter nodes) are accounted for. Last, we compare these algorithms to standard approaches using simulated data and a large influenza data set. Our algorithms are implemented in the LSD program (least-squares dating), which can be downloaded (along with all data and results reported here) from <ext-link ext-link-type="uri" xlink:href="http://www.atgc-montpellier.fr/LSD/">http://www.atgc-montpellier.fr/LSD/</ext-link> (last accessed October 2015). An Online Appendix, providing additional algorithm descriptions, tables, and figures, can be found in the in the Supplementary Material available on Dryad at <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.5061/dryad.968t3">http://dx.doi.org/10.5061/dryad.968t3</ext-link>.</p>
  </sec>
  <sec>
    <title>M<sc>odels and</sc> A<sc>lgorithms</sc></title>
    <sec>
      <title>Preliminaries and Notation</title>
      <p>Our algorithms take as input a binary phylogenetic tree with branch lengths, inferred by any tree building program, and sampling dates associated with the taxa. As our algorithms are very fast, it is consistent to combine them with fast tree-building methods, for example distance-based methods (e.g., NJ, <xref rid="B46" ref-type="bibr">Saitou and Nei 1987</xref>, or FastME, <xref rid="B10" ref-type="bibr">Desper and Gascuel 2002</xref>, <xref rid="B31" ref-type="bibr">Lefort et al. 2015</xref>), but more accurate results are expected from trees obtained using maximum-likelihood (ML) methods (e.g., PhyML, <xref rid="B24" ref-type="bibr">Guindon and Gascuel 2003</xref>, <xref rid="B23" ref-type="bibr">Guindon et al. 2010</xref>). However, we shall see that results obtained with both approaches are close. The algorithms accept a rooted or unrooted tree, and for unrooted trees we propose a method to estimate the root position, though simulations show that the use of an outgroup is generally preferable. In the following, we first assume that the tree is rooted, and then summarize the rooting procedure, which is described in more details in the Online Appendix (available as Supplementary Material on Dryad at <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.5061/dryad.968t3">http://dx.doi.org/10.5061/dryad.968t3</ext-link>).</p>
      <p>Given a set of <inline-formula><mml:math id="I3"><mml:mi>n</mml:mi></mml:math></inline-formula> serially dated sequences, let <inline-formula><mml:math id="I4"><mml:mi>R</mml:mi></mml:math></inline-formula> be the input rooted binary phylogenetic tree on these sequences with known branch lengths. Enumerate the internal nodes of <inline-formula><mml:math id="I5"><mml:mi>R</mml:mi></mml:math></inline-formula> by <inline-formula><mml:math id="I6"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and the leaves by <inline-formula><mml:math id="I7"><mml:mi>n</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="I8"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Node 1 corresponds to the root. The date of node <inline-formula><mml:math id="I9"><mml:mi>i</mml:mi></mml:math></inline-formula> is denoted by <inline-formula><mml:math id="I10"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. So <inline-formula><mml:math id="I11"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="I12"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are known. Times are measured from the origin, that is, <inline-formula><mml:math id="I13"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⩾</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> when <inline-formula><mml:math id="I14"><mml:mi>i</mml:mi></mml:math></inline-formula> is more recent than <inline-formula><mml:math id="I15"><mml:mi>j</mml:mi></mml:math></inline-formula>.</p>
      <p>For every node <inline-formula><mml:math id="I16"><mml:mi>i</mml:mi></mml:math></inline-formula> different from the root (<inline-formula><mml:math id="I17"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>), let <inline-formula><mml:math id="I18"><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the parent node of <inline-formula><mml:math id="I19"><mml:mi>i</mml:mi></mml:math></inline-formula>. For every internal node <inline-formula><mml:math id="I20"><mml:mi>i</mml:mi></mml:math></inline-formula>, let <inline-formula><mml:math id="I21"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="I22"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the two direct descendants of <inline-formula><mml:math id="I23"><mml:mi>i</mml:mi></mml:math></inline-formula>. Let <inline-formula><mml:math id="I24"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the length of the branch <inline-formula><mml:math id="I25"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="I26"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is an estimate of the number of substitutions per site that occurred along the branch from time <inline-formula><mml:math id="I27"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="I28"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. With a SMC, the substitution rate (i.e., the expected number of substitutions per site per time unit) along the tree is constant and is denoted as <inline-formula><mml:math id="I29"><mml:mo>ω</mml:mo></mml:math></inline-formula>. The goal of our algorithms is to estimate the substitution rate and the dates of all internal nodes, that is <inline-formula><mml:math id="I30"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ω</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>Probabilistic Model and Objective Function</title>
      <p>We use a Gaussian model, which is closely related to that proposed by <xref rid="B30" ref-type="bibr">Langley and Fitch (1974)</xref>. Assuming a SMC, the expected branch length <inline-formula><mml:math id="I31"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is equal to <inline-formula><mml:math id="I32"><mml:mo>ω</mml:mo></mml:math></inline-formula> times the time interval <inline-formula><mml:math id="I33"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Due to sampling noise and estimation errors, the branch length estimate <inline-formula><mml:math id="I34"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (available in input tree <inline-formula><mml:math id="I35"><mml:mi>R</mml:mi></mml:math></inline-formula>) can be expressed as:
<disp-formula id="syv068-M1"><label>(1)</label><mml:math id="MM1"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>ω</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mo>ϵ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="I36"><mml:mrow><mml:msub><mml:mo>ϵ</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the noise (error) term. <xref rid="B30" ref-type="bibr">Langley and Fitch's (1974)</xref> method assumes a Poisson model for <inline-formula><mml:math id="I37"><mml:mrow><mml:msub><mml:mo>ϵ</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, which is biologically meaningful (at least with low substitution rates and simple mutation processes). Here, we use a normal approximation for the distribution of the noise term <inline-formula><mml:math id="I38"><mml:mrow><mml:msub><mml:mo>ϵ</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (such an approximation is quite standard in computational statistics to accelerate the calculations, with a huge number of successful applications in many domains, and sound justifications related to the Law of Large Numbers). We thus assume:
<disp-formula><mml:math id="UM1"><mml:mrow><mml:msub><mml:mo>ϵ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>N</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mo>σ</mml:mo><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="I39"><mml:mrow><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mo>σ</mml:mo><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the normal distribution with mean 0 and variance <inline-formula><mml:math id="I40"><mml:mrow><mml:msubsup><mml:mo>σ</mml:mo><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>. A limit of this model is that short branches may be negative according to Equation (<xref ref-type="disp-formula" rid="syv068-M1">1</xref>), but we impose positivity using temporal precedence constraints (see below). As evolution is independent from one branch to another, we consistently assume that the noise terms are mutually independent. The weighted least squares (WLS) criterion to be minimized (proportional to the log-likelihood assuming this model) is given by:
<disp-formula id="syv068-M2"><label>(2)</label><mml:math id="MM2"><mml:mrow><mml:mo>φ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>ω</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msubsup><mml:mo>σ</mml:mo><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>One difficulty with such a WLS criterion lies in the variance terms <inline-formula><mml:math id="I41"><mml:mrow><mml:msubsup><mml:mo>σ</mml:mo><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>, which are unknown and depend on the (unknown) branch lengths and possibly on some model parameters (e.g., <inline-formula><mml:math id="I42"><mml:mo>Γ</mml:mo></mml:math></inline-formula> distribution of site rates). <xref rid="B20" ref-type="bibr">Fitch and Margoliash's (1967)</xref> tree inference method use the square of the pairwise evolutionary distance estimate. We use here another standard approach (for discussion, see <xref rid="B21" ref-type="bibr">Gascuel 1997</xref>) derived from the Poisson nature of the substitution process, where
<disp-formula id="syv068-M3"><label>(3)</label><mml:math id="MM3"><mml:mrow><mml:msubsup><mml:mo>σ</mml:mo><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>s</mml:mi></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>ω</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:mfrac><mml:mo> </mml:mo><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mo> </mml:mo><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mo>σ</mml:mo><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo stretchy="true">ˆ</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mi>s</mml:mi></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
with <inline-formula><mml:math id="I43"><mml:mi>s</mml:mi></mml:math></inline-formula> being the sequence length.</p>
      <p>However, the limit of such variance estimates is that overconfidence is given on very short branches, while their short length may be due to sampling randomness or estimation errors. For example, with a null branch length estimate (<inline-formula><mml:math id="I44"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>), we have an infinite weight in Equation (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>). This makes the method inapplicable, while the observation that <inline-formula><mml:math id="I45"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> most likely is due to the limited amount of sites available. To avoid this problem, we use the following additive smoothing for the variance estimates:
<disp-formula id="syv068-M4"><label>(4)</label><mml:math id="MM4"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mo>σ</mml:mo><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo stretchy="true">ˆ</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo>/</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>where <inline-formula><mml:math id="I46"><mml:mi>c</mml:mi></mml:math></inline-formula> is a constant. The higher <inline-formula><mml:math id="I47"><mml:mi>c</mml:mi></mml:math></inline-formula> is, the closer we are to equal variances, that is, ordinary least squares (OLS). A value of <inline-formula><mml:math id="I48"><mml:mrow><mml:mi>c</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> corresponds to Laplace's Rule of Succession, which is commonly used to estimate probabilities with limited numbers of observations (with short branches, <inline-formula><mml:math id="I49"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is very close to a frequency of observed differences, or <inline-formula><mml:math id="I50"><mml:mi>p</mml:mi></mml:math></inline-formula>-distance, and <inline-formula><mml:math id="I51"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to the corresponding probability). Simulation experiments (not shown) indicate that <inline-formula><mml:math id="I52"><mml:mrow><mml:mi>c</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> is not large enough and that <inline-formula><mml:math id="I53"><mml:mrow><mml:mi>c</mml:mi><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> provides best average results; this is the default value in our computer program, but <inline-formula><mml:math id="I54"><mml:mi>c</mml:mi></mml:math></inline-formula> can be chosen by the user.</p>
      <p>This model accommodates some violations of the molecular clock. Assume a simple model (similar to <xref rid="B16" ref-type="bibr">Drummond et al. 2006</xref>; see also <xref rid="B56" ref-type="bibr">Thorne et al. 1998</xref>) where the rate <inline-formula><mml:math id="I55"><mml:mrow><mml:msub><mml:mo>ω</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> attached to the branch <inline-formula><mml:math id="I56"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> follows a normal distribution <inline-formula><mml:math id="I57"><mml:mrow><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>ω</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mo>ξ</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, assume a simple model for <inline-formula><mml:math id="I58"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="I59"><mml:mrow><mml:msub><mml:mo>ϵ</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in Equation (<xref ref-type="disp-formula" rid="syv068-M1">1</xref>) does not depend on the branch specific rate <inline-formula><mml:math id="I60"><mml:mrow><mml:msub><mml:mo>ω</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, but on its expectation <inline-formula><mml:math id="I61"><mml:mo>ω</mml:mo></mml:math></inline-formula>, that is
<disp-formula><mml:math id="UM2"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mo>ω</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>N</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>s</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
Then, it is easily seen that
<disp-formula><mml:math id="UM3"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>ω</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi>N</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mo>ξ</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>s</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
In other words, <inline-formula><mml:math id="I62"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> follows a normal distribution having a similar form as Equation (<xref ref-type="disp-formula" rid="syv068-M1">1</xref>), but the error term incorporates an additional factor (<italic>i.e</italic>., <inline-formula><mml:math id="I63"><mml:mrow><mml:msup><mml:mo>ξ</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the relevance of which may be tested against the SMC. Moreover, the variance term is an increasing function of <inline-formula><mml:math id="I64"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, as in Equation (<xref ref-type="disp-formula" rid="syv068-M3">3</xref>), meaning that using our algorithms with uncorrelated violations of the molecular clock is still well founded.</p>
      <p>To summarize, our model (Eq. (<xref ref-type="disp-formula" rid="syv068-M1">1</xref>)) is a normal approximation of the LF model and it naturally accommodates uncorrelated variation of rates across branches. This corresponds to the default option in several programs (e.g., BEAST), which have shown their accuracy and usefulness with numerous data sets (typically viruses, see section ‘Introduction’). We certainly do not pretend that this model depicts all the complexity of sequence evolution, but it makes possible very efficient calculations with little loss in terms of estimation accuracy, as described later.</p>
    </sec>
    <sec>
      <title>Outline of the Approach</title>
      <p>The rate <inline-formula><mml:math id="I65"><mml:mo>ω</mml:mo></mml:math></inline-formula> is positive, and we can fix in LSD the minimum value of the estimated rate to <inline-formula><mml:math id="I66"><mml:mrow><mml:mover accent="true"><mml:mo>ω</mml:mo><mml:mo>ˆ</mml:mo></mml:mover><mml:mo>⩾</mml:mo><mml:msub><mml:mo>ω</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Moreover, time is measured forward from the root to the tips of the tree, so it must satisfy the temporal precedence constraints <inline-formula><mml:math id="I67"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⩾</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for every node <inline-formula><mml:math id="I68"><mml:mi>i</mml:mi></mml:math></inline-formula> that is not the tree root (<inline-formula><mml:math id="I69"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>). In other words, any daughter node (<inline-formula><mml:math id="I70"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) is more recent than its parent node <inline-formula><mml:math id="I71"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This is an obvious requirement, analogous to the positivity of branch lengths in phylogenetic trees. However, not all dating methods comply with this requirement (e.g., see our example below with BEAST and the influenza data set), just as some phylogenetic algorithms (e.g., NJ) infer trees with negative branch lengths. The reasons for this are mostly computational. Imposing positivity constraints has a computational cost, as we shall see below in our dating context.</p>
      <p>The estimates are obtained by minimizing the objective function <inline-formula><mml:math id="I72"><mml:mo>φ</mml:mo></mml:math></inline-formula> defined in Equation (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>). By using <inline-formula><mml:math id="I73"><mml:mrow><mml:msub><mml:mo>β</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>ω</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for every node <inline-formula><mml:math id="I74"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> (<italic>i.e</italic>. <inline-formula><mml:math id="I75"><mml:mi>i</mml:mi></mml:math></inline-formula> is an internal node) and <inline-formula><mml:math id="I76"><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msubsup><mml:mo>σ</mml:mo><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula>, the function <inline-formula><mml:math id="I77"><mml:mo>φ</mml:mo></mml:math></inline-formula> in Equation (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>) becomes:
<disp-formula id="syv068-M5"><label>(2b)</label><mml:math id="MM5"><mml:mtable><mml:mtr><mml:mtd><mml:mo>Ψ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>ω</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mo>β</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mo>β</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mo>β</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mo>β</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mo>ω</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mo>β</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
      <p>This function is a convex quadratic form (<xref rid="B37" ref-type="bibr">O'Meara 2000</xref>) and has a unique minimum (see Proof in the Online Appendix). Therefore, Equation (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>) also has a unique minimum. However, to improve numerical precision our algorithms use Equation (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>) and not Equation (<xref ref-type="disp-formula" rid="syv068-M5">2b</xref>), as in Equation (<xref ref-type="disp-formula" rid="syv068-M5">2b</xref>) we have to divide the variables <inline-formula><mml:math id="I78"><mml:mrow><mml:msub><mml:mo>β</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> by <inline-formula><mml:math id="I79"><mml:mo>ω</mml:mo></mml:math></inline-formula> (another variable) to obtain the <inline-formula><mml:math id="I80"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, which are the true variables of interest.</p>
      <p>We propose two different algorithms. One takes into account the temporal precedence constraints, while the other does not. For each algorithm implemented in our computer program LSD, we have two versions: weighted, where each term in Equation (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>) is associated with a weight denoted <inline-formula><mml:math id="I81"><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mover accent="true"><mml:mrow><mml:msubsup><mml:mo>σ</mml:mo><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo stretchy="true">ˆ</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> (cf. Eq. (<xref ref-type="disp-formula" rid="syv068-M4">4</xref>)), and unweighted (all <inline-formula><mml:math id="I82"><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are equal and set to 1). We present the weighted versions in the following, as the unweighted versions are simply obtained by fixing the <inline-formula><mml:math id="I83"><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to 1.</p>
    </sec>
    <sec>
      <title>Linear Dating (LD) Algorithm, Without Constraints</title>
      <p>Let <inline-formula><mml:math id="I84"><mml:mrow><mml:mi>B</mml:mi><mml:mo>'</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mn>2</mml:mn><mml:mo>'</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>'</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where:
<disp-formula><mml:math id="UM4"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mo>'</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>f</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mo>'</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mo>ω</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>f</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
Then, Equation (<xref ref-type="disp-formula" rid="syv068-M1">1</xref>) becomes:
<disp-formula><mml:math id="UM5"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mo>'</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mo>ω</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mo>ϵ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>f</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mo>'</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mo>ω</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mo>ϵ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>f</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>These equations can be rewritten, using matrix notation, as <inline-formula><mml:math id="I85"><mml:mrow><mml:mi>B</mml:mi><mml:mo>'</mml:mo><mml:mo>=</mml:mo><mml:mo>ω</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>+</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="I86"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="I87"><mml:mi>E</mml:mi></mml:math></inline-formula> is the error (noise) vector, and <inline-formula><mml:math id="I88"><mml:mi>A</mml:mi></mml:math></inline-formula> is a <inline-formula><mml:math id="I89"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> matrix, which depends on the topology of <inline-formula><mml:math id="I90"><mml:mi>R</mml:mi></mml:math></inline-formula>, such that for any <inline-formula><mml:math id="I91"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="I92"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, we have:
<disp-formula><mml:math id="UM6"><mml:mrow><mml:msub><mml:mi>A</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>n</mml:mi><mml:mo> </mml:mo><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mo> </mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>⩾</mml:mo><mml:mi>n</mml:mi><mml:mo> </mml:mo><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>n</mml:mi><mml:mo> </mml:mo><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>d</mml:mi><mml:mo> </mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>h</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>w</mml:mi><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>The objective function (Eq. (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>)) is then written as <inline-formula><mml:math id="I93"><mml:mrow><mml:mo>φ</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>'</mml:mo><mml:mo>−</mml:mo><mml:mo>ω</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mi>W</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>'</mml:mo><mml:mo>−</mml:mo><mml:mo>ω</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="I94"><mml:mrow><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the diagonal matrix of inversed variances. By the pseudo-inverse method, the estimates of <inline-formula><mml:math id="I95"><mml:mo>ω</mml:mo></mml:math></inline-formula> and <inline-formula><mml:math id="I96"><mml:mi>T</mml:mi></mml:math></inline-formula> that minimize <inline-formula><mml:math id="I97"><mml:mo>φ</mml:mo></mml:math></inline-formula>, satisfy <inline-formula><mml:math id="I98"><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>A</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>W</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mi>A</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>W</mml:mi><mml:msup><mml:mi>B</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. The latter equation is equivalent to the following system of equations:
<disp-formula id="syv068-M6"><label>(5.1)</label><mml:math id="MM6"><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>ω</mml:mo></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>ω</mml:mo></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<disp-formula id="syv068-M7"><label>(5.i)</label><mml:math id="MM7"><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>ω</mml:mo></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>ω</mml:mo></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>ω</mml:mo></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>f</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1.</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
      <p>This system of Equations (5) can also be obtained by taking the first-order derivatives of <inline-formula><mml:math id="I99"><mml:mo>φ</mml:mo></mml:math></inline-formula> with respect to each variable <inline-formula><mml:math id="I100"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Based on Equation (<xref ref-type="disp-formula" rid="syv068-M1">1</xref>), <inline-formula><mml:math id="I101"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mo>ω</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mo>ϵ</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mo>ω</mml:mo></mml:mrow></mml:math></inline-formula>. Consequently, Equations (5) mean that the estimate of <inline-formula><mml:math id="I102"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is equal to the weighted average of its estimates with respect to all <inline-formula><mml:math id="I103"><mml:msup><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:math></inline-formula>s neighbors (2 for tree root (<inline-formula><mml:math id="I104"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) in Eq. (5.1), and 3 for other internal nodes (<inline-formula><mml:math id="I105"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) in Eqs. (5.i)). The resolution of Equations (5) can be achieved in linear time (i.e., <inline-formula><mml:math id="I106"><mml:mrow><mml:mtext>O</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="I107"><mml:mi>n</mml:mi></mml:math></inline-formula> is the number of tree tips), while solving such a system with generic tools requires cubic time (i.e., <inline-formula><mml:math id="I108"><mml:mrow><mml:mtext>O</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The technical details of the LD algorithm are given in the Online Appendix. The main idea is to simplify progressively this system (Eq. (5)) by recursive replacements using specific tree traversals. After the first, bottom-up set of replacements, we have
<disp-formula id="syv068-M8"><label>(6.i)</label><mml:math id="MM8"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>ω</mml:mo></mml:mfrac><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mtext>for</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>where</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>are</mml:mtext><mml:mo> </mml:mo><mml:mtext>constants</mml:mtext><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
After the second, top-down set of replacements, we obtain
<disp-formula id="syv068-M9"><label>(7.i)</label><mml:math id="MM9"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>ω</mml:mo></mml:mfrac><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mtext>for</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>where</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>are</mml:mtext><mml:mo> </mml:mo><mml:mtext>constants</mml:mtext><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
By using Equations (7) into Equation (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>), <inline-formula><mml:math id="I109"><mml:mo>φ</mml:mo></mml:math></inline-formula> becomes a quadratic function of one variable <inline-formula><mml:math id="I110"><mml:mo>ω</mml:mo></mml:math></inline-formula>. Then, it is easy to compute the unique <inline-formula><mml:math id="I111"><mml:mover accent="true"><mml:mo>ω</mml:mo><mml:mo>ˆ</mml:mo></mml:mover></mml:math></inline-formula> value that minimizes this function. If <inline-formula><mml:math id="I112"><mml:mrow><mml:mover accent="true"><mml:mo>ω</mml:mo><mml:mo>ˆ</mml:mo></mml:mover><mml:mo>&lt;</mml:mo><mml:msub><mml:mo>ω</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, then we set <inline-formula><mml:math id="I113"><mml:mrow><mml:mover accent="true"><mml:mo>ω</mml:mo><mml:mo>ˆ</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msub><mml:mo>ω</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (optimality is shown in the Online Appendix). Last, <inline-formula><mml:math id="I114"><mml:mo>ω</mml:mo></mml:math></inline-formula> in Equations (7) is replaced by <inline-formula><mml:math id="I115"><mml:mover accent="true"><mml:mo>ω</mml:mo><mml:mo>ˆ</mml:mo></mml:mover></mml:math></inline-formula> to obtain all date estimates <inline-formula><mml:math id="I116"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">ˆ</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
      <p>This algorithm can be extended to non-binary trees. However, nothing guarantees that the date estimates satisfy the temporal precedence constraints. This is why we designed the QPD (quadratic programming dating) algorithm, which we describe now.</p>
    </sec>
    <sec>
      <title>QPD Algorithm</title>
      <p>QPD is based on an active-set method, which is commonly used to solve optimization problems with linear constraints (<xref rid="B36" ref-type="bibr">Nocedal and Wright 2006</xref>). Let <inline-formula><mml:math id="I117"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>ω</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>); the function to minimize is <inline-formula><mml:math id="I118"><mml:mrow><mml:mo>φ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> defined by Equation (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>), subject to the constraints <inline-formula><mml:math id="I119"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>⩾</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, for <inline-formula><mml:math id="I120"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. For the sake of simplicity, we do not include the (<inline-formula><mml:math id="I121"><mml:mrow><mml:mo>ω</mml:mo><mml:mo>⩾</mml:mo><mml:msub><mml:mo>ω</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>) constraint, as it is already accounted for in the LD algorithm, which is part of QPD. <inline-formula><mml:math id="I122"><mml:mi>x</mml:mi></mml:math></inline-formula> is a “feasible” point if and only if it satisfies all the constraints. A constraint <inline-formula><mml:math id="I123"><mml:mi>i</mml:mi></mml:math></inline-formula> is “active” at <inline-formula><mml:math id="I124"><mml:mi>x</mml:mi></mml:math></inline-formula> if and only if <inline-formula><mml:math id="I125"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The active-set method applied to our problem can be summarized as follows (see the Online Appendix for details): starting from a feasible point <inline-formula><mml:math id="I126"><mml:mi>x</mml:mi></mml:math></inline-formula> with <inline-formula><mml:math id="I127"><mml:mi>C</mml:mi></mml:math></inline-formula> being the set of active constraints, we compute the minimal solution of Equation (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>) with respect to <inline-formula><mml:math id="I128"><mml:mi>C</mml:mi></mml:math></inline-formula>, that is, the minimal solution such that <inline-formula><mml:math id="I129"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, for every <inline-formula><mml:math id="I130"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>. We thus have to calculate the stationary point <inline-formula><mml:math id="I131"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mo>∗</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mo>λ</mml:mo><mml:mo>∗</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the Lagrange function:
<disp-formula id="syv068-M10"><label>(8)</label><mml:math id="MM10"><mml:mrow><mml:mo>Γ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo>λ</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>φ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mo>λ</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>We then check if: (i) some constraints are violated in <inline-formula><mml:math id="I132"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mo>∗</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, and (ii) all constraints in <inline-formula><mml:math id="I133"><mml:mi>C</mml:mi></mml:math></inline-formula> are useful. <inline-formula><mml:math id="I134"><mml:mi>C</mml:mi></mml:math></inline-formula> is updated accordingly, by relaxing the “most useless” constraint and adding the “most violated” one. The algorithm stops when all constraints in <inline-formula><mml:math id="I135"><mml:mi>C</mml:mi></mml:math></inline-formula> are useful and no more constraints are violated (Karush–Kuhn–Tucker (KKT) conditions, <xref rid="B7" ref-type="bibr">Boyd and Vandenberghe 2004</xref>). With strictly convex quadratic functions, this method is ensured to converge to the unique global minimum (<xref rid="B36" ref-type="bibr">Nocedal and Wright 2006</xref>). Although Equation (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>) does not comply with these requirements, a proof of QPD convergence to the unique minimum is provided in the Online Appendix.</p>
      <p>The active-set method is especially efficient here, because we can find the stationary point of the Lagrange function (Eq. (<xref ref-type="disp-formula" rid="syv068-M10">8</xref>)) in linear time. Indeed, <inline-formula><mml:math id="I136"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mo>∗</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is computed by a modified version of the LD algorithm, which applies to a new tree obtained from the input tree <inline-formula><mml:math id="I137"><mml:mi>R</mml:mi></mml:math></inline-formula> by collapsing the branches corresponding to the active set <inline-formula><mml:math id="I138"><mml:mi>C</mml:mi></mml:math></inline-formula>. Then, <inline-formula><mml:math id="I139"><mml:mrow><mml:msup><mml:mo>λ</mml:mo><mml:mo>∗</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> can also be calculated in linear time (Online Appendix).</p>
      <p>The time complexity of QPD is <inline-formula><mml:math id="I140"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="I141"><mml:mi>f</mml:mi></mml:math></inline-formula> is the number of iterations needed to reach the optimal solution, and <inline-formula><mml:math id="I142"><mml:mi>n</mml:mi></mml:math></inline-formula> is the number of taxa. <inline-formula><mml:math id="I143"><mml:mi>f</mml:mi></mml:math></inline-formula> depends on the data and the chosen starting point. We use here the LD algorithm, initializing <inline-formula><mml:math id="I144"><mml:mi>C</mml:mi></mml:math></inline-formula> with the violated constraints <inline-formula><mml:math id="I145"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in the LD solution, which are combined to obtain a feasible point. In our experiments (described below), QPD performs 3 iterations on average with simulated trees of 110 taxa, and 69 iterations with an H1N1 influenza data set of 891 taxa. Although, it is difficult to extrapolate from these experiments, it seems that in practice <inline-formula><mml:math id="I146"><mml:mi>f</mml:mi></mml:math></inline-formula> is much smaller than <inline-formula><mml:math id="I147"><mml:mi>n</mml:mi></mml:math></inline-formula>, and thus the computing time of QPD appears to be nearly linear.</p>
    </sec>
    <sec>
      <title>Estimating the Root Position for Unrooted Trees</title>
      <p>Given an unrooted tree, we estimate the root position by searching for the point in the tree that minimizes the objective function (Eq. (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>)) when the tree is rooted at this point. A similar approach is used in RTT-based Path-O-Gen software (<xref rid="B40" ref-type="bibr">Rambaut 2007</xref>). In essence, this is the point that makes the tree the most molecular clock-like. Let <inline-formula><mml:math id="I148"><mml:mi>R</mml:mi></mml:math></inline-formula> be an unrooted tree with the internal nodes enumerated from 2 to <inline-formula><mml:math id="I149"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, and the external nodes from <inline-formula><mml:math id="I150"><mml:mi>n</mml:mi></mml:math></inline-formula> to <inline-formula><mml:math id="I151"><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Let <inline-formula><mml:math id="I152"><mml:mi>r</mml:mi></mml:math></inline-formula> be a point on a branch <inline-formula><mml:math id="I153"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of length <inline-formula><mml:math id="I154"><mml:mi>b</mml:mi></mml:math></inline-formula>. Let <inline-formula><mml:math id="I155"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the date of <inline-formula><mml:math id="I156"><mml:mi>r</mml:mi></mml:math></inline-formula> assuming <inline-formula><mml:math id="I157"><mml:mi>r</mml:mi></mml:math></inline-formula> is the tree root, and <inline-formula><mml:math id="I158"><mml:mo>μ</mml:mo></mml:math></inline-formula> a variable in <inline-formula><mml:math id="I159"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that the length of branch <inline-formula><mml:math id="I160"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is equal to <inline-formula><mml:math id="I161"><mml:mrow><mml:mo>μ</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>; then, the objective function (Eq. (<xref ref-type="disp-formula" rid="syv068-M2">2</xref>)) of the tree rooted at <inline-formula><mml:math id="I162"><mml:mi>r</mml:mi></mml:math></inline-formula> becomes:
<disp-formula id="syv068-M11"><label>(9)</label><mml:math id="MM11"><mml:mtable><mml:mtr><mml:mtd><mml:mo> </mml:mo><mml:mo>ϕ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>ω</mml:mo><mml:mo>,</mml:mo><mml:mo>μ</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>μ</mml:mo><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mo>μ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
Note that we do not use weights (variances) in the objective function, since weights depend on their associated branch lengths, which are unknown for the two branches containing the assumed root. Optimizing this function without and with constraints can be done by slightly modifying the LD and QPD algorithms, without changing their time complexities. The technical details are given in the Online Appendix. For each branch, we calculate the root position (<inline-formula><mml:math id="I163"><mml:mo>μ</mml:mo></mml:math></inline-formula>) which minimizes Equation (<xref ref-type="disp-formula" rid="syv068-M11">9</xref>), and then take the minimum point among all branches. Therefore, the time complexity is <inline-formula><mml:math id="I164"><mml:mi>n</mml:mi></mml:math></inline-formula> times that of the LD and QPD algorithms. Since LD is linear, the corresponding rooting algorithm is quadratic. For QPD, to avoid exploring all branches, which could be time consuming with large trees, we pre-estimate the position of the root using LD, and then we use QPD to perform a greedy search for the local minimum around that position. This rooting method is also applicable when all tips are contemporaneous, thus representing a new alternative to the standard rooting methods (midpoint, minimum-variance, etc.).</p>
    </sec>
  </sec>
  <sec>
    <title>R<sc>esults with</sc> S<sc>imulated</sc> D<sc>ata</sc></title>
    <sec>
      <title>Data Simulation</title>
      <p>We implemented a tree generator based on a simple birth–death model with periodic sampling times, mimicking typical intrahost studies with yearly sampling, or (interhost) epidemic surveillance through time. We first assumed a SMC, and then a lognormal relaxed molecular clock (RMC). Let us start with SMC. At time <inline-formula><mml:math id="I165"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, there is one single individual (<inline-formula><mml:math id="I166"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>), which is iteratively subdivided. At each step, one of the <inline-formula><mml:math id="I167"><mml:mi>n</mml:mi></mml:math></inline-formula> individuals is randomly selected and divided into two individuals, resulting in <inline-formula><mml:math id="I168"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> individuals. The elapsed time between the previous division event and the new one is equal to <inline-formula><mml:math id="I169"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> (i.e., like the standard Yule tree, where the expected time is equal to <inline-formula><mml:math id="I170"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>). This process is continued until we have 1000 individuals. Then we proceed with sampling and death: the evolution of a number of individuals (e.g., 750) is stopped, most of them (e.g., 725) are removed from the tree (or “culled”), while the remaining ones (e.g., 25) are retained to be the sampled individuals of the first sampling time. The process continues with the nonculled and nonsampled individuals (250 in our example), which are further divided using the same Yule-type rule until we again have 1000 individuals to be sampled, culled, or conserved for the next step. The whole process is continued until we attain the desired number of sampling times. The final set of sampled individuals is exactly the taxon set (or leaves) of the final tree. This tree is then rescaled so that the time between the first and the last sampling time is 20 years, with the root date being zero. An advantage of this scheme is that the time elapsed from one sampling time to the next one is constant, thus emulating the sampling of DNA sequences from an evolving population on a regular basis, as opposed to standard birth–death tree generators (<xref rid="B53" ref-type="bibr">Stadler 2010</xref>). Moreover, with birth–death trees the divergence times vary among replicates, while here we use fixed divergence times for easy estimation of method accuracy and presentation of the results.</p>
      <p>We generated two kinds of trees, intended to simulate interhost and intrahost HIV evolution (<xref rid="B58" ref-type="bibr">Volz et al. 2013</xref>), by using two death rates (ratio of individuals removed at each sampling time): 750/1000 was used for interhost trees, and 995/1000 for intrahost (typically ladderized) trees. For each, we used 3 sampling times (separated by 10 years) with 25 selected individuals at each time, and 11 sampling times (separated by 2 years) with 10 selected individuals at each time. See <xref ref-type="fig" rid="F1">Figure 1</xref> for examples of trees. Additionally, we added one outgroup to simulate the search for the root position using the standard outgroup-based approach. The length of the branch from the ingroup root to the outgroup was three times the length from the ingroup root to the nearest ingroup leaf. Last, to simulate sequence evolution, we used the substitution rate <inline-formula><mml:math id="I171"><mml:mo>ω</mml:mo></mml:math></inline-formula> to obtain the length of each branch <inline-formula><mml:math id="I172"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>), corresponding to the expected number of substitutions per site along that branch; <inline-formula><mml:math id="I173"><mml:mo>ω</mml:mo></mml:math></inline-formula> was equal to 0.006 substitutions per site and per year, which is similar to the substitution rate of the HIV <italic>env</italic> gene (<xref rid="B5" ref-type="bibr">Bello et al. 2008</xref>). With each combination of these parameters, 100 trees were randomly generated. Hence, there are in total <inline-formula><mml:math id="I174"><mml:mrow><mml:mn>4</mml:mn><mml:mo>×</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:math></inline-formula> SMC trees, denoted as (death rate/sampling scheme): <inline-formula><mml:math id="I175"><mml:mrow><mml:mn>750</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mn>25</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="I176"><mml:mrow><mml:mn>750</mml:mn><mml:mo>/</mml:mo><mml:mn>11</mml:mn><mml:mo>×</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="I177"><mml:mrow><mml:mn>995</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo>×</mml:mo><mml:mn>25</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="I178"><mml:mrow><mml:mn>995</mml:mn><mml:mo>/</mml:mo><mml:mn>11</mml:mn><mml:mo>×</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula>.
<fig id="F1" orientation="portrait" position="float"><label>Figure 1.</label><caption><p>Examples of simulated trees. Four examples of trees extracted from our simulated data sets. Trees a) and c) are intended to simulate inter-host evolution of HIV (one tip per host; 750/1000 of the strains are removed at each sampling date). Trees b) and d) are intended to simulate intra-host evolution of HIV, with its typical “ladder shape” (all tips from a single host; 995/1000 of the strains are removed at each sampling date). Trees a) and b) have each 3 sampling dates with 25 sampled strains each. Trees c) and d) have each 11 sampling dates with 10 sampled strains each. See text and <xref rid="B58" ref-type="bibr">Volz et al. (2013)</xref> for explanations.</p></caption><graphic xlink:href="syv068f1"/></fig></p>
      <p>To simulate trees with RMC, we used the uncorrelated lognormal model, which is one of the most widely used in BEAST (<xref rid="B16" ref-type="bibr">Drummond et al. 2006</xref>). For this purpose, we reused the previous trees, but multiplied every branch length by a random variable following a lognormal distribution with mean 1 and standard deviation 0.4. This value is between the estimates we obtained for <italic>pol</italic> and <italic>env</italic> HIV genes (unpublished results). We thus obtained <inline-formula><mml:math id="I179"><mml:mrow><mml:mn>4</mml:mn><mml:mo>×</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:math></inline-formula> RMC trees.</p>
      <p>DNA sequences of length 1000 were evolved along these trees using Seq-Gen (<xref rid="B41" ref-type="bibr">Rambaut and Grassly 1997</xref>), version 1.3.2x. We used the F84 model with a <inline-formula><mml:math id="I180"><mml:mo>Γ</mml:mo></mml:math></inline-formula> distribution with shape parameter 1.0 and 8 rate categories, a transition/transversion rate ratio of 2.5, and nucleotide frequencies of (A, C, G, T) = (0.35, 0.20, 0.20, 0.25). These parameter values are similar to estimates already observed with the <italic>env</italic> region of HIV (<xref rid="B38" ref-type="bibr">Posada and Crandall 2001</xref>).</p>
      <p>To assess the accuracy of the distance-based dating methods, we inferred trees from these alignments. First, we used the correct tree topology but re-estimated the branch lengths using PhyML+F84<inline-formula><mml:math id="I181"><mml:mrow><mml:mo>+</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:math></inline-formula>8; the aim was to measure the impact of topological errors that are unavoidable in real studies; moreover, we used these trees to assess the performance of the various methods to estimate all tree node dates, instead of the root date only. Second, we used DNADIST+F84<inline-formula><mml:math id="I182"><mml:mrow><mml:mo>+</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:math></inline-formula> (PHYLIP, <xref rid="B19" ref-type="bibr">Felsenstein 1989</xref>, v3.69) to estimate pairwise evolutionary distance matrices, and then FastME with SPR option to estimate trees (negative branch lengths were set to zero); the distance estimation parameters in DNADIST were the same as those used to generate the data with Seq-Gen; the aim was to check the accuracy of a fast distance approach, being easily bootstrapped or able to tackle very large data sets. Last, we used PhyML+F84<inline-formula><mml:math id="I183"><mml:mrow><mml:mo>+</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:math></inline-formula>8 with SPR option to infer both the tree topology and branch lengths, that is, a standard ML method with high accuracy, but slower than DNADIST+FastME. All these trees were used in two ways: (i) the outgroup was used to produce rooted trees, from which the outgroup was deleted; (ii) we simply removed the outgroup to obtain unrooted trees. All of our data sets (model trees, alignments, distance matrices, inferred trees, etc.) are available at <ext-link ext-link-type="uri" xlink:href="http://www.atgc-montpellier.fr/LSD/">http://www.atgc-montpellier.fr/LSD/</ext-link>.</p>
    </sec>
    <sec sec-type="methods">
      <title>Methods for Comparison</title>
      <p>These simulated data were used to assess the performance of our two methods (LD and QPD) and of three other methods: RTT, Langley-Fitch (LF*), and BEAST (BSMC with a SMC model and BRMC with a relaxed clock):
<list list-type="bullet"><list-item><p>For LD and QPD, if the tree is rooted, the program uses the given tree; the methods are then denoted as LD* and QPD*, and we use the “variance” option (WLS). Otherwise, the root position is estimated and the methods are simply denoted as LD and QPD.</p></list-item><list-item><p>For RTT, we re-implemented the linear regression method, which takes both rooted and unrooted trees as input. Given unrooted trees, it estimates the position of the root by minimizing the sum of squared residues. Given rooted trees, the method is a standard regression and is denoted as RTT*. For dozens of data sets, we checked that our implementation gives the same result as Path-O-Gen v1.3 (<xref rid="B40" ref-type="bibr">Rambaut 2007</xref>). Unlike other methods used here, RTT does not estimate the dates of internal nodes but only the root date and the substitution rate.</p></list-item><list-item><p>For LF*, we used the program implemented in the <italic>r8s</italic> package v1.8 (<xref rid="B49" ref-type="bibr">Sanderson 2003</xref>); the likelihood function was optimized thanks to Powel's algorithm (TN algorithm was much faster, but returned inconsistent results with ∼20% of our data sets); this program has no ability to search for the root position and takes only rooted trees as input, hence the notation LF*.</p></list-item><list-item><p>For BSMC and BRMC, BEAST version 1.7 was used with HKY<inline-formula><mml:math id="I184"><mml:mrow><mml:mo>+</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:math></inline-formula>8 (closely related to F84<inline-formula><mml:math id="I185"><mml:mrow><mml:mo>+</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:math></inline-formula>8 used to simulate the data) and coalescent with constant population size tree prior. We used a SMC with an uninformative prior (<italic>clock rate</italic> had a uniform distribution between 0 and 1). The length of the MCMC chain was <inline-formula><mml:math id="I186"><mml:mrow><mml:mn>5</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mtext>6</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula> generations, with a burn-in of 10% and a sampling every <inline-formula><mml:math id="I187"><mml:mrow><mml:mn>5</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mtext>3</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula> generation. For the relaxed-clock data, we also used a lognormal relaxed-clock model (i.e., the model used to generate the data); the prior of the <italic>ucld.mean</italic> parameter had a uniform distribution between 0 and 1, and the prior of <italic>ucld.stdev</italic> had an exponential distribution with parameter 1/3 (default value). The MCMC chain length was increased to <inline-formula><mml:math id="I188"><mml:mrow><mml:mn>20</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mtext>6</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula> generations, with a burn-in of 10% and a sampling every <inline-formula><mml:math id="I189"><mml:mrow><mml:mn>20</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mtext>3</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula> generations. These parameter values are standard and default options were used in all of our analyses. We increased the burn-in up to 25%, but did not observe significant changes. Additional runs with several alternative priors were also performed (uniform prior in a much more narrow interval [0, 0.05] for <italic>clock.rate</italic> and <italic>ucld.mean</italic> parameters; uniform prior on the inverse of these parameters; birth–death tree prior), but without improvement, and the same held with alternative program options (Drummond A., Yanez R., personal communication). Moreover, other runs of BEAST were carried out to assess the accuracy of internal node date estimations. We then used the true rooted tree topology (otherwise date comparisons are meaningless), and forced it to be constant in BEAST, so that only the branch lengths were re-estimated, just as with PhyML (see above). The length of the MCMC chain was set to <inline-formula><mml:math id="I190"><mml:mrow><mml:mn>10</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mtext>6</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula> generations, with a burn-in of 10% and a sampling every <inline-formula><mml:math id="I191"><mml:mrow><mml:mn>10</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mtext>3</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula> generations. In all of our analyses, we used <italic>meanRate</italic> estimator for rate estimations with BRMC, since it was more accurate than <italic>ucld.mean</italic>, and <italic>clock.rate</italic> with BSMC; <italic>treeModel.rootHeight</italic> was used to estimate the root date with both BSMC and BRMC. BEAST xml and log files with the 800 simulated data sets are available at <ext-link ext-link-type="uri" xlink:href="http://www.atgc-montpellier.fr/LSD/">http://www.atgc-montpellier.fr/LSD/</ext-link>.</p></list-item></list></p>
    </sec>
    <sec>
      <title>Comparison Criteria</title>
      <p>With simulated data, the true value of the parameters (substitution rate, root and node dates) are known. We used standard quadratic error measures to compare the true and estimated values and assess the accuracy of the methods being compared. An advantage of these measures is that they can be decomposed into variance and bias terms, thus indicating whether the estimation method shows some tendency to over- or underestimate the true parameter value, and whether the main source of errors is, or is not, the variance of the estimates.
<list list-type="bullet"><list-item><p>For the substitution rate, let <inline-formula><mml:math id="I192"><mml:mo>ω</mml:mo></mml:math></inline-formula> be the true value, <inline-formula><mml:math id="I193"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mo>ω</mml:mo><mml:mo>ˆ</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> the value estimated by a given method with the <inline-formula><mml:math id="I194"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> data set among <inline-formula><mml:math id="I195"><mml:mi>m</mml:mi></mml:math></inline-formula> (= 100 in our experiments), and <inline-formula><mml:math id="I196"><mml:mover accent="true"><mml:mo>ω</mml:mo><mml:mo>¯</mml:mo></mml:mover></mml:math></inline-formula> the average of the <inline-formula><mml:math id="I197"><mml:mi>m</mml:mi></mml:math></inline-formula> estimates. The accuracy of that method in estimating the substitution rate is measured by the relative error:
<disp-formula><mml:math id="UM7"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mo>ω</mml:mo></mml:mfrac><mml:msqrt><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>m</mml:mi></mml:mfrac><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>ω</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mover accent="true"><mml:mo>ω</mml:mo><mml:mo>ˆ</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
and the relative bias is defined by:
<disp-formula><mml:math id="UM8"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mo>ω</mml:mo></mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mo>ω</mml:mo><mml:mo>¯</mml:mo></mml:mover><mml:mo>−</mml:mo><mml:mo>ω</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p></list-item><list-item><p>Similar measures are used for the root date, with relative error defined by:
<disp-formula><mml:math id="UM9"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:msqrt><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>m</mml:mi></mml:mfrac><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>t</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mstyle></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
and relative bias:
<disp-formula><mml:math id="UM10"><mml:mrow><mml:mfrac><mml:mover accent="true"><mml:mi>t</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="I198"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>t</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the estimated root date with the <inline-formula><mml:math id="I199"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> data set, <inline-formula><mml:math id="I200"><mml:mover accent="true"><mml:mi>t</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math></inline-formula> is the average root date estimate, and <inline-formula><mml:math id="I201"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the contemporary time (which is the same for all trees within each tree model); moreover, remember that the true root date is zero. These relative error terms can be interpreted as percentages; for example, a bias of −0.1 means that the true value is underestimated by 10%, in average. A basic result in estimation theory is that the square of the bias plus the variance of the estimates is equal to the mean square error. It follows that our relative bias is less than the relative error and that their difference corresponds to the relative, standard deviation of the estimates. We calculated the confidence intervals of these error measures using the bootstrap method; for each data set of 100 trees, we re-sampled 10,000 times with replacement the set of the 100 estimated values and computed the corresponding error; then, the 2.5% and 97.5% quantiles were picked up to form 95% confidence intervals.</p></list-item><list-item><p>For the dates of internal nodes, we used the absolute error (measured in years and thus easily interpreted) defined by:
<disp-formula><mml:math id="UM11"><mml:mrow><mml:msqrt><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mi>m</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>t</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="I202"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> represents one of the <inline-formula><mml:math id="I203"><mml:mi>m</mml:mi></mml:math></inline-formula> trees, and <inline-formula><mml:math id="I204"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> is one of the internal nodes (including the root, where <inline-formula><mml:math id="I205"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="I206"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the date of the node <inline-formula><mml:math id="I207"><mml:mi>k</mml:mi></mml:math></inline-formula> in the tree <inline-formula><mml:math id="I208"><mml:mi>i</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="I209"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>t</mml:mi><mml:mo>ˆ</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is its estimated value. Again we used the bootstrap to build confidence intervals.</p></list-item></list></p>
    </sec>
    <sec sec-type="results">
      <title>Results</title>
      <p>The detailed results of all tested methods using above criteria are available from our web site <ext-link ext-link-type="uri" xlink:href="http://www.atgc-montpellier.fr/LSD/">http://www.atgc-montpellier.fr/LSD/</ext-link> and in the Online Appendix.</p>
      <p>Distance-based dating methods have negligible computing times with these data (∼0.1 seconds or less, even with unrooted trees where the root position has to be searched among all edges), except LF*, which is still fast but requires a few seconds with rooted trees. In contrast, BEAST requires a few hours with a SMC, and a dozen hours with a relaxed clock. For a fair comparison, we also have to account for tree building, as BEAST infers both the tree and the dates. However, PhyML is much faster, requiring 8 min for the largest 110-taxon trees. The computing time difference between distance-based approaches and BEAST is thus very large (see Online Appendix Supplementary Table S1 for details), but does not correspond to gains in estimation accuracy, as discussed below.</p>
      <p>With SMC data (<xref ref-type="fig" rid="F2">Fig. 2</xref>a,c,e), the relative errors are low (∼ 5%) and most methods have similar, high accuracy. RTT and RTT* are a bit less accurate than the others for both root date and rate estimations, most likely due to their overly simple model. BEAST is also behind the others regarding rate estimation, with a substantial positive bias (up to ∼10% with 995/11x10 trees, Online Appendix Supplementary Table S2), but performs well with date estimation, both for the root (<xref ref-type="fig" rid="F2">Fig. 2</xref>c) and all internal nodes (<xref ref-type="fig" rid="F2">Fig. 2</xref>e). As a general tendency (<xref ref-type="fig" rid="F2">Fig. 2</xref>a,c, e.g., LD vs. LD*, and QPD vs. QPD*), molecular clock-based rooting produces similar results to outgroup-based rooting for both the root date and the rate, as expected since trees were generated with SMC. Surprisingly, the accuracy of rate and root date estimations are not significantly affected by topological errors: although the FastME and PhyML trees contain a substantial amount of erroneous branches, we see very little difference in accuracy between the results obtained with the true and inferred topologies. Moreover, there is almost no difference between the results obtained with FastME (topological error ∼15%, Online Appendix Supplementary Table S4) and PhyML (topological error ∼10%). This suggests the use of (much faster) FastME rather than PhyML, when the aim is not to obtain a fully correct tree topology but to quickly estimate rates and dates, or to perform bootstrap analyses. The topological accuracy of BEAST and PhyML are quite similar (Supplementary Table S4), with BEAST providing a slight advantage, meaning that the high error of BEAST in rate estimation is not due to topological errors, but to the positive bias already indicated above. BEAST results with the fixed, true topology confirm this finding (Online Appendix Supplementary Fig. S5).
<fig id="F2" orientation="portrait" position="float"><label>Figure 2.</label><caption><p>Summary results with simulated data. Panels a), c) and e) contain summary results of the trees with a SMC, panels b), d) and f) those with a lognormal, RMC. Panels a) and b) show the relative error of the substitution rate estimates, panels c) and d) show the relative error of the root date estimates, panels e) and f) show the average error (in years) of the data estimates of all tree nodes. See text for the definitions of these measures. From left to right (see legends) tested methods are: linear dating with tree root estimation (LD); linear dating with outgroup-based tree rooting (LD*); quadratic programing dating with tree root estimation (QPD); quadratic programing dating with outgroup-based tree rooting (QPD*); Langley-Fitch that uses rooted trees only (LF*); root-to-type regression with tree root estimation (RTT); root-to-type regression with outgroup-based tree rooting (RTT*); BEAST with strict molecular clock (BSMC); BEAST with lognormal, relaxed molecular clock (BRMC).</p></caption><graphic xlink:href="syv068f2"/></fig></p>
      <p>With RMC data (<xref ref-type="fig" rid="F2">Fig. 2</xref>b,d,f), the relative errors of all methods are much higher (from ∼10% to ∼20%) than with SMC data (∼5%). Again, the topological errors have little impact on the accuracy of rate and date estimations, and cannot explain the differences among the various methods, especially with BEAST the topological accuracy of which is still slightly better than PhyML's (Supplementary Table S4). Again, FastME and PhyML trees produce rate and date estimates showing similar accuracy. As expected the main factor is root positioning, which has a high impact on root date estimations. If the root is misplaced, the tree cannot be dated precisely. Among the methods directly inferring the root position (i.e., without outgroup), LD, QPD, and RTT show similar accuracy (poor regarding root date), while BEAST results differ depending on the clock model. With BSMC the rate is well estimated but the date is not any better than with direct distance-based approaches; with BRMC the rate is poorly estimated due to a high positive bias (&gt;10%), but the root date is fairly well estimated. Results with the fixed, true topology confirm these findings: BEAST rate estimations are not improved (Supplementary Fig. S5), but BEAST with the RMC model is the most accurate method to estimate internal node dates (<xref ref-type="fig" rid="F2">Fig. 2</xref>f), which is to be expected since the data were generated using the very same model. Moreover, the global average results (<xref ref-type="fig" rid="F2">Fig. 2</xref>) hide that BEAST does well with model trees with low death rate (750/1000, Online Appendix Supplementary Figs. S1–S2), but not so with high death rate (995/1000, Online Appendix Supplementary Figs. S3–S4). Among the methods using outgroup-based rooted trees: LF* is best to estimate the rate and slightly (but not significantly) better than LD* and QPD* in estimating root and internal node dates; RTT* is worse both to estimate the rate and the root date.</p>
      <p>Up until now, we mostly discussed average results over the four types of model trees (<xref ref-type="fig" rid="F2">Fig. 2</xref>). As expected, the accuracy of the various methods differs depending on the model tree (Online Appendix Supplementary Figs. S1–S4). The accuracy of the estimates is better with the larger sample of 110 dated sequences, than with 75 sequences, and the impact is especially sensible with date estimations since we have 11 sampling times (every 2 years) instead of 3 (every 10 years). Moreover, the ladder-shaped trees (995/1000 death rate) are easier than the more star-like trees (750/1000), an outcome already observed with real data, for example from human seasonal influenza (ladder-shaped) versus HIV (star-like) epidemics (<xref rid="B22" ref-type="bibr">Grenfell et al. 2004</xref>). However, the global properties and the ranking of the various methods remain similar compared to average analysis (except with BEAST, see above).</p>
      <p>Most results in these simulations were expected. Among distance-based methods, LF* has the most realistic (Poisson) model and obtains the best results; LD* and QPD* use a simplified (normal) version of the LF* model, and their results are not as good as those of LF*, although the difference is not significant in most cases; RTT* is the worst distance method, as expected since its model is too simple and does not account for the fact that the root-to-tip paths are highly correlated (<xref rid="B15" ref-type="bibr">Drummond et al. 2003b</xref>). The main surprise comes from the results of BEAST, expected to be the best due to its sophisticated model, being identical or very close to the data model, but in fact the results on the data sets used here do not suggest this. However, results in <xref ref-type="fig" rid="F2">Figure 2</xref> have to be interpreted with care: first, BEAST in our experiments does not use an outgroup as the best distance approaches do, and thus should be compared to the direct methods (LD, QPD, and RTT); second, BEAST shows a substantial bias with rate estimation that remains to be explained, but performs well (<xref ref-type="fig" rid="F2">Fig. 2</xref>d) to very well (<xref ref-type="fig" rid="F2">Fig. 2</xref>f) with dating.</p>
      <p>Let us conclude these simulations with practical guidelines. Tree rooting is a difficult task; thus, if possible, use an outgroup and compare the results with the direct ones, obtained by assuming some (relaxed) clock model. When having a well-supported and consistent root position, use LF* or QPD*, selecting the latter with large data sets and bootstrap studies. ML trees are preferable to minimize topological errors, but (fast) distance-based trees provide nearly identical rate and date estimates. LD and QPD (resp. LD* and QPD*) have nearly identical accuracy in these simulations. However, LD and LD* violate a substantial number of temporal constraints (∼4% by more than 1 month with 110-taxon trees and RMC), and the advantage of QPD and QPD* will become even more apparent with real (imperfect) influenza data.</p>
    </sec>
  </sec>
  <sec>
    <title>A<sc>pplication to an</sc> I<sc>nfluenza</sc> D<sc>ata</sc> S<sc>et</sc></title>
    <p>To illustrate the results of our algorithms on large data sets, we used a set comprising 1194 strains of influenza A virus subtype H1N1pdm09, which caused the first human influenza pandemic of the 21st century. The first two cases were reported in children from southern California on 21 April 2009. Soon after, other cases were reported, and by 11 June 2009, 27,000 cases of infection had been observed from 74 countries, including 141 deaths. On that date, the World Health Organization (WHO) declared a pandemic, and the end of the pandemic was declared in August 2010 (for details, see <xref rid="B9" ref-type="bibr">Christman et al. 2011</xref>).</p>
    <p>Molecular epidemiology studies on this virus were performed at an early stage of the epidemic, using 242 strains collected between 30 March and 12 July 2009 (<xref rid="B32" ref-type="bibr">Lemey et al. 2009</xref>; <xref rid="B42" ref-type="bibr">Rambaut and Holmes 2009</xref>). These studies indicated that this virus has a high evolutionary rate of <inline-formula><mml:math id="I210"><mml:mrow><mml:mn>4.96</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mtext>-3</mml:mtext></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> [<inline-formula><mml:math id="I211"><mml:mrow><mml:mn>4.10</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mtext>-3</mml:mtext></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="I212"><mml:mrow><mml:mn>5.87</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mtext>-3</mml:mtext></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>] substitutions per site and per year (for concatenated hemagglutinin (HA) and neuraminidase (NA) genes), and the estimated date for the tMRCA was 27 January 2009 [29 December 2008; 22 February 2009]. This MRCA date was confirmed by <xref rid="B26" ref-type="bibr">Hedge et al. (2013)</xref> using 328 whole virus genomes sampled in North America before April 2010. To our knowledge, no other molecular dating study has been published on a more comprehensive set of strains sampled over a longer time period.</p>
    <p>The (1194) strains used here were collected worldwide between 13 March 2009 and 9 June 2011 (see Online Appendix Supplementary Table S5 for further details). The A/Swine/Hong Kong/1110/2006 (subtype H1N2) strain was used as outgroup to root the phylogenetic tree. The HA gene sequences were aligned by codon using MUSCLE in MEGA 5.0 and checked manually, resulting in an alignment of 1194 (+1 outgroup) sequences and 1701 sites. As many sequences were identical but collected at different time points, we retained for each set of identical sequences only one exemplar with a sampling date equal to the average of the dates of the corresponding strains. We thus obtained 891 (+1 outgroup) different sequences, each with a unique sampling date, from which a phylogenetic tree was computed. Note that grouping identical sequences does not impact phylogeny inference (identical sequences are separated by branches of length zero) but accelerates the computations and is consistent with our dating model which has difficulty in dealing with branches of length zero but different dates at both extremities (see Eqs. (<xref ref-type="disp-formula" rid="syv068-M1">1</xref>)–(<xref ref-type="disp-formula" rid="syv068-M4">4</xref>), and notably the variance term). However, this simplification was not used with BEAST, which handles such data due to its coalescent, population genetics model.</p>
    <p>To run our dating algorithms, we first have to infer a phylogenetic tree. Two methods were used, as in our simulation study, with different speed/accuracy tradeoff: (i) a fast distance-based method, namely FastME with the SPR option and distances estimated by DNADIST under F84<inline-formula><mml:math id="I213"><mml:mrow><mml:mo>+</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:math></inline-formula> (the <inline-formula><mml:math id="I214"><mml:mo>Γ</mml:mo></mml:math></inline-formula> parameter was set to 1.0, as in other experiments); (ii) a more accurate but slower ML method, namely PhyML with SPR option and GTR+I<inline-formula><mml:math id="I215"><mml:mrow><mml:mo>+</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:math></inline-formula>4. For both methods we analyzed the ingroup sequences only and considered both the outgroup-based rooted tree, and the unrooted tree obtained by root removal. To compute confidence intervals we used the bootstrap method with 100 replicates generated with SEQBOOT from the PHYLIP package. To improve computational efficiency, the tree topology was kept constant and equal to the topology inferred using the original data set; only the branch lengths were re-estimated from the bootstrap samples.</p>
    <p>We compared the same methods as in the previous sections, using the same options. LD and QPD were run with the “variance” (WLS) option both in the rooted and unrooted settings; they are denoted as LD* and QPD* with rooted trees. Langley-Fitch (LF*) from r8s was run with the rooted tree only, as it has no means to infer the tree root. RTT (our implementation, equivalent to Path-O-Gen v1.3, <xref rid="B40" ref-type="bibr">Rambaut 2007</xref>) was performed with both the unrooted (RTT) and the rooted (RTT*) trees. BEAST was run from the complete, ingroup alignment using GTR+I<inline-formula><mml:math id="I216"><mml:mrow><mml:mo>+</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:math></inline-formula>4, a coalescent constant population size tree prior and two molecular clock models: strict (SMC) and relaxed lognormal (RMC), with normal clock priors (<inline-formula><mml:math id="I217"><mml:mrow><mml:mtext>mean</mml:mtext><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mtext>-3</mml:mtext></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> substitutions per site per year (s/s/y), standard <inline-formula><mml:math id="I218"><mml:mrow><mml:mtext>deviation</mml:mtext><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mtext>-3</mml:mtext></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> s/s/y). Two independent MCMC chains were used per model, with a minimum of 250 million generations each, sampling every 10,000 generations. The first 25 million generations in each run were discarded as burn-in, and the Highest Posterior Density statistics for each parameter were calculated over a posterior sample of 1000 states using Tracer 1.5. Moreover, as we observed a strong discrepancy between BEAST and the other methods regarding substitution rate estimations (see below), we also launched BEAST with the cleaned data set where identical sequences were grouped (891 taxa), and using the PhyML rooted tree topology which was kept constant all along the computations, solely sampling the branch lengths and model parameters. Such use of BEAST seems to be rather uncommon, but corresponds to the way a number of other dating programs proceed, for example, PAML (<xref rid="B43" ref-type="bibr">Rannala and Yang 2007</xref>).</p>
    <p>All methods except BEAST were run on our server (Intel(R) Xeon(R) X5650 @ 2.67GHz, single core, no parallelization), while BEAST was run on a Dell Precision T7500 workstation (Intel(R) Xeon(R) X5687 @ 3.6GHz CPUs, one core per model) using the Beagle library with the SSE, Double Precision, and Dynamic Rescaling options (<xref rid="B3" ref-type="bibr">Ayres et al. 2012</xref>). The computing times (<xref ref-type="table" rid="T1">Table 1</xref>) to obtain point estimates for the substitution rate and all node dates with distance-based approaches are very fast: at most 1 second with rooted trees for LD*, QPD*, and RTT*, and ∼1 min for LF* which is the slowest distance-based method; with unrooted trees, the methods inferring the tree root (LD, QPD, and RTT) are inevitably slower as they have to search all tree branches, but are still fast requiring less than 1 min. To obtain bootstrap intervals the computing times are multiplied by 100 as we have 100 replicates, varying from a few seconds (RTT* and LD*) to ∼1 h (LF*), with QPD* requiring ∼2 min. This shows the advantage brought by our algorithms, since both LF* and QPD* use closely related models and show similar accuracy (<xref ref-type="fig" rid="F2">Fig. 2</xref>). However, the time to build trees has to be accounted for, especially when bootstraps are used. DNADIST+FastME is remarkably fast, requiring ∼1 h to infer the original and 100 bootstrap trees, while PhyML is much slower, requiring ∼4 d for the same task. To get a good posterior sample of time resolved Bayesian phylogenetic trees with the 1194 sequences requires running BEAST for a minimum of 20 d, using at least 250 million MCMC generations at approximately 2 h per million generations. For the 891 cleaned sequence set, using a fixed rooted, PhyML topology in BEAST, only 50 million MCMC generations are needed, taking 5 d at approximately 2.5 h per million generations.
<table-wrap id="T1" orientation="portrait" position="float"><label>Table 1.</label><caption><p>Computing time for the H1N1pdm09 Flu data set</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th align="center" rowspan="1" colspan="1">Original sample</th><th align="center" rowspan="1" colspan="1">100 bootstrap samples</th></tr></thead><tbody align="left"><tr><td colspan="3" align="left" rowspan="1"><italic>Phylogeny inference</italic></td></tr><tr><td align="left" rowspan="1" colspan="1">Distance-based (DNADIST+FastME)</td><td align="center" rowspan="1" colspan="1">127</td><td align="center" rowspan="1" colspan="1">3434</td></tr><tr><td align="left" rowspan="1" colspan="1">ML (PhyML)</td><td align="center" rowspan="1" colspan="1">∼60 h</td><td align="center" rowspan="1" colspan="1">∼35 h</td></tr><tr><td colspan="3" align="left" rowspan="1"><italic>Dates and rate estimation</italic></td></tr><tr><td align="left" rowspan="1" colspan="1">LD</td><td align="center" rowspan="1" colspan="1">31</td><td align="center" rowspan="1" colspan="1">2791</td></tr><tr><td align="left" rowspan="1" colspan="1">LD*</td><td align="center" rowspan="1" colspan="1">&lt;1</td><td align="center" rowspan="1" colspan="1">15</td></tr><tr><td align="left" rowspan="1" colspan="1">QPD</td><td align="center" rowspan="1" colspan="1">38</td><td align="center" rowspan="1" colspan="1">3329</td></tr><tr><td align="left" rowspan="1" colspan="1">QPD*</td><td align="center" rowspan="1" colspan="1">1</td><td align="center" rowspan="1" colspan="1">120</td></tr><tr><td align="left" rowspan="1" colspan="1">Root-to-tip</td><td align="center" rowspan="1" colspan="1">12</td><td align="center" rowspan="1" colspan="1">2765</td></tr><tr><td align="left" rowspan="1" colspan="1">Root-to-tip*</td><td align="center" rowspan="1" colspan="1">&lt;1</td><td align="center" rowspan="1" colspan="1">2</td></tr><tr><td align="left" rowspan="1" colspan="1">Langley–Fitch*</td><td align="center" rowspan="1" colspan="1">54</td><td align="center" rowspan="1" colspan="1">4177</td></tr><tr><td align="left" rowspan="1" colspan="1">BEAST (BSMC and BRMC)</td><td align="center" rowspan="1" colspan="1">∼20 d</td><td align="center" rowspan="1" colspan="1">–</td></tr><tr><td align="left" rowspan="1" colspan="1">BEAST* (BSMC* and BRMC*)</td><td align="center" rowspan="1" colspan="1">∼5 d</td><td align="center" rowspan="1" colspan="1">–</td></tr></tbody></table><table-wrap-foot><fn id="FN2"><p>Note: Time is expressed in seconds, except otherwise specified. With bootstrap samples, only the branch lengths were reoptimized; the tree topology was kept constant and equal to the topology inferred using the original alignment. BEAST was run to infer all model parameters, including the tree topology and tree root, while with BEAST* we used the PhyML rooted tree topology which was kept constant along the computations. The asterrisk (*) denotes methods using out-group based rooted trees.</p></fn></table-wrap-foot></table-wrap></p>
    <p>We see little difference (<xref ref-type="fig" rid="F3">Fig. 3</xref>) between the results obtained with FastME and PhyML trees, especially for the tMRCA where point and interval estimates are nearly the same for every distance-based estimation method (except root-to-tip). This strongly suggests using FastME when the focus is on rates and dates, at least for large data sets, as it is several orders of magnitude faster than PhyML. Moreover, both tree building and dating are then consistently based on similar distance-based approaches.
<fig id="F3" orientation="portrait" position="float"><label>Figure 3.</label><caption><p>Estimations of the substitution rate (panel (a)) and tMRCA (panel (b)) with the H1N1pdm09 Flu data set. Distance-based estimation methods are run with both DNADIST+FastME and PhyML trees. LD, QPD, and RTT (root-to-tip) are run from unrooted trees and search for the best tree root position. LD*, QPD*, LF*, and RTT* are run using outgroup-based rooted trees. BEAST is run from the ingroup sequence alignment, with both a strict molecular clock (BSMC) and a lognormal relaxed clock (BRMC); BSMC and BRMC infer the tree topology and root position, while BSMC* and BRMC* use the fixed, rooted tree topology inferred by PhyML. The box plots represent the median, maximum, minimum, 97.5% and 2.5% quantiles of the bootstrap estimates with distance-based methods, and of the posterior distribution with BEAST. The distance-based point estimates and BEAST posterior means are represented by a dot.</p></caption><graphic xlink:href="syv068f3"/></fig></p>
    <p>Regarding rate estimation (<xref ref-type="fig" rid="F3">Fig. 3</xref>a), all distance-based methods provide similar results, except root-to-tip regression with faster rate estimates and much larger confidence intervals. QPD also shows relatively large intervals, likely due to the fact that it has to infer the tree root and is thus subject to more variability and possible rooting errors. However, the main fact here is that distance-based and BEAST rate estimates (obtained from the complete data set, while optimizing the tree topology) widely differ (<inline-formula><mml:math id="I219"><mml:mrow><mml:mo>~</mml:mo><mml:mn>3.0</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="I220"><mml:mrow><mml:mo>~</mml:mo><mml:mn>6.5</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, respectively, with non-overlapping confidence and credibility intervals). With simulated data we found that BEAST with the specified priors and options may overestimate the substitution rate (Online Appendix Supplementary Tables S2 and S3). We also observed similar discrepancies between both approaches on other biological data sets (results not shown). However, the gap here was so large that we ran BEAST with the cleaned data set and the fixed PhyML rooted tree topology that was used with other approaches. Then, BEAST rate estimates (BSMC* and BRMC* in <xref ref-type="fig" rid="F3">Fig. 3</xref>a) became much closer to the others, being still somewhat faster (<inline-formula><mml:math id="I221"><mml:mrow><mml:mo>~</mml:mo><mml:mn>3.5</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> instead of <inline-formula><mml:math id="I222"><mml:mrow><mml:mo>~</mml:mo><mml:mn>3.0</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) but with mostly overlapping intervals. BEAST (combined with TREEANNOTATOR) infers a tree where ∼2% of the temporal precedence constraints are violated with the complete data set, while with the cleaned data set and the fixed PhyML rooted tree, all constraints are satisfied. The reasons for these findings are still unclear. One explanation could be that with such a large data set (&gt;1000 sequences) BEAST has difficulty in converging on a reasonable rooted tree topology, notably because it does not use any outgroup to root the tree. Such calculations in a Bayesian setting could simply be too heavy, thus supporting the use of simpler PAML-like approaches for estimating dates and rates from fixed rooted tree topologies.</p>
    <p>Paradoxically, no such gap is observed for the date of the MRCA (<xref ref-type="fig" rid="F3">Fig. 3</xref>b): the best distance-based methods, namely QPD* and LF*, find nearly the same point estimates and confidence intervals as BEAST used in a standard free-topology way, at least with a strict molecular clock (BSMC), that is, end of 2008. This date is compatible with <xref rid="B42" ref-type="bibr">Rambaut and Holmes (2009)</xref>, <xref rid="B32" ref-type="bibr">Lemey et al. (2009)</xref> and <xref rid="B26" ref-type="bibr">Hedge et al. (2013)</xref> studies, but slightly older, as expected due to our larger data set incorporating more ancient strains. When using a fixed rooted tree topology, BEAST tMRCA becomes clearly older by 1 year or so, especially with a relaxed clock (BRMC*). However the discrepancy with distance methods involves only the MRCA and a few basal nodes (2 nodes with difference &gt;6 months between QPD* and BSMC*, and 22 with BRMC*), while for most of the nodes the dates are highly similar (Pearson correlation coefficient with all node dates: QPD*/BSMC* ≈ 0.95, QPD*/BRMC* ≈ 0.91). The main difference among distance-based methods is between those using an outgroup to root the tree (LD*, QPD*, LF*, and RTT*) and the others (LD, QPD, and RTT) which infer the root position from the ingroup sequences only. The latter show more variability, larger confidence intervals, and tend to produce older date estimates, around the beginning of 2008 (these intervals and dates, however, are still statistically compatible with those of other methods). Again this larger variability is likely explained by the difficulty of tree rooting. Another factor for LD, and to some extent LD*, is the absence of temporal constraints: we see that their confidence intervals include a few root date estimates that are more recent (mid-2009) than our earliest strains (13 March 2009). This is clearly impossible and shows the advantage of incorporating temporal constraints, as in QPD and QPD*. With this data set, the solution of LD has ∼7% of branches such that the descendant node is older by 1 month or more than its parent (∼1.5% when the time difference is larger than 2 months, and ∼0.5% with 3 months).</p>
    <p>To summarize, while the best distance-based methods (QPD* and LF*, used with FastME) are considerably faster than BEAST (especially QPD*, with negligible computing times), their dating results are quite similar. Regarding substitution rate estimation, we observe a large discrepancy between distance-based methods and BEAST, when used in the usual way estimating all parameters, including the tree topology and its root. However, with the fixed rooted tree topology, BEAST estimates of the substitution rate become similar to those of distance-based approaches.</p>
  </sec>
  <sec>
    <title>D<sc>iscussion and</sc> C<sc>onclusion</sc></title>
    <p>We have described very fast algorithms to estimate rates and dates from serial data. These algorithms are based on a Gaussian noise, least-squares model, simplifying the <xref rid="B30" ref-type="bibr">Langley and Fitch's (1974)</xref> Poisson model implemented in the r8s package (<xref rid="B49" ref-type="bibr">Sanderson 2003</xref>). We showed that this model should be robust to uncorrelated violations of the molecular clock, and our simulation results confirm this theoretical prediction. LD uses a pure linear algebra approach, while QPD accounts for temporal precedence constraints, which appears to be important with real data. Given an input tree with dated tips, our algorithms provide the user with estimates of the substitution rate, the root date and the dates of all internal tree nodes, a task that is not achieved by RTT (also based on a simple, least-squares approach, but not able to date internal nodes). Our algorithms can be used to root the input tree when no outgroup is available, a feature that is not available in the r8s implementation of LF, and would be time consuming in the Poisson setting. Consequently, LD and QPD are also new fast, practical methods for tree rooting, which represent an alternative to the standard midpoint and minimum-variance approaches.</p>
    <p>Computer simulations show that the accuracy of our algorithms is better than RTT's, and just slightly behind LF's with rooted trees. Compared to BEAST, our algorithms (combined with standard tree building methods) have a similar or better accuracy in estimating the substitution rate, while regarding dates the results depend very much on the presence of an outgroup and the way BEAST is used, estimating all parameters including the tree topology and its root, or using a fixed rooted tree topology. Globally, we did not observe any obvious limitation of our algorithms compared to BEAST, with simulated as well as real data sets. Moreover, our results clearly show the importance of having an accurate root position, a difficult goal when no outgroup is available and with relaxed (realistic) molecular clock.</p>
    <p>Our algorithms require (quasi)linear computing times with rooted trees, as a function of <inline-formula><mml:math id="I223"><mml:mi>n</mml:mi></mml:math></inline-formula>, the number of leaves. With unrooted trees, the computing time is (nearly) quadratic in <inline-formula><mml:math id="I224"><mml:mi>n</mml:mi></mml:math></inline-formula>. This is obtained with complex algorithms, exploiting the closeness between least-squares and linear algebra; we also exploit the tree structure which makes it possible to design fast recursive procedures. This speed is important for current applications of phylogenetics. In <xref rid="B34" ref-type="bibr">Mourad et al. (2015)</xref>, we analyzed a tree containing ∼24,000 dated HIV strains; running QPD* required ∼30 min on a standard desktop, while LF from r8s did not return any result after 2 weeks of computation. LSD has also been used by the members of the PANGEA_HIV consortium to study the phylodynamics of HIV epidemics in Africa using very large data sets (Fraser C., Ratmann O., personal communication; <ext-link ext-link-type="uri" xlink:href="http://www.pangea-hiv.org/Projects/#phylodynamic">http://www.pangea-hiv.org/Projects/#phylodynamic</ext-link>, last accessed October 2015).</p>
    <p>Our approach could be developed in several directions. First, we currently use a bootstrap approach to obtain confidence intervals, which is possible due to the speed of the algorithms, but still slow. Much faster approaches could be designed, for example, using the second derivative of the log-likelihood (least-squares) function. Second, we have described here the application of these algorithms to serial phylogenies with dated tips; easy adaptations should make it possible to use the very same approach to deal with phylogenies with time calibration points, attaching dated tips to ancestral nodes and using intervals (constraints) to account for ancestral date uncertainty. Last, an important direction is to implement fast methods that are able to cope with more complex, correlated molecular clock models, typically combining the least-squares framework with penalized criteria, similar to <xref rid="B48" ref-type="bibr">Sanderson (2002)</xref>, or using some of our algorithmic solutions to deal with multi-normal approximations of the likelihood function (<xref rid="B56" ref-type="bibr">Thorne et al. 1998</xref>).</p>
  </sec>
</body>
<back>
  <ack>
    <title>A<sc>cknowledgements</sc></title>
    <p>Thanks to Tanja Stadler, Jessica Hedge, Gabriel Leventhal, Raphaël Mourad, Alexei Drummond, and Romina Yanez for help with BEAST and testing LSD on large data sets, and to David Bryant, Mike Sanderson, Lars Jermin, and Frank Anderson for their comments that greatly helped us to improve the first version of this paper.</p>
  </ack>
  <sec sec-type="materials">
    <title>S<sc>upplementary</sc> M<sc>aterial</sc></title>
    <p>Data available from the Dryad Digital Repository: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.5061/dryad.968t3">http://dx.doi.org/10.5061/dryad.968t3</ext-link>, and from <ext-link ext-link-type="uri" xlink:href="http://www.atgc-montpellier.fr/LSD/">http://www.atgc-montpellier.fr/LSD/</ext-link>.</p>
  </sec>
  <sec>
    <title>F<sc>unding</sc></title>
    <p>This work was supported by ANR project PhyloSpace, Labex NUMEV, VIROGENESIS EU-H2020 project (grant number 634650; O. G.), Wellcome Trust (grant number 092807; S. J. L.).</p>
  </sec>
  <ref-list>
    <title>R<sc>eferences</sc></title>
    <ref id="B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Akerborg</surname><given-names>O.</given-names></name><name><surname>Sennblad</surname><given-names>B.</given-names></name><name><surname>Lagergren</surname><given-names>J.</given-names></name></person-group><year>2008</year><article-title>Birth-death prior on phylogeny and speed dating</article-title>. <source>BMC Evol. Biol.</source><volume>8</volume>:<fpage>77</fpage>.<pub-id pub-id-type="pmid">18318893</pub-id></mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Akerborg</surname><given-names>O.</given-names></name><name><surname>Sennblad</surname><given-names>B.</given-names></name><name><surname>Arvestad</surname><given-names>L.</given-names></name><name><surname>Lagergren</surname><given-names>J.</given-names></name></person-group><year>2009</year><article-title>Simultaneous Bayesian gene tree reconstruction and reconciliation analysis</article-title>. <source>PNAS</source><volume>106</volume>(<issue>14</issue>):<fpage>5714</fpage>–<lpage>5719</lpage>.<pub-id pub-id-type="pmid">19299507</pub-id></mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ayres</surname><given-names>D.L.</given-names></name><name><surname>Darling</surname><given-names>A.</given-names></name><name><surname>Zwickl</surname><given-names>D.J.</given-names></name><name><surname>Beerli</surname><given-names>P.</given-names></name><name><surname>Holder</surname><given-names>M.T.</given-names></name><name><surname>Lewis</surname><given-names>P.O.</given-names></name><name><surname>Huelsenbeck</surname><given-names>J.P.</given-names></name><name><surname>Ronquist</surname><given-names>F.</given-names></name><name><surname>Swofford</surname><given-names>D.L.</given-names></name><name><surname>Cummings</surname><given-names>M.P.</given-names></name><name><surname>Rambaut</surname><given-names>A.</given-names></name><name><surname>Suchard</surname><given-names>M.A.</given-names></name></person-group><year>2012</year><article-title>BEAGLE: an application programming interface and high-performance computing library for statistical phylogenetics</article-title>. <source>Syst. Biol.</source><volume>61</volume>(<issue>1</issue>):<fpage>170</fpage>–<lpage>173</lpage>.<pub-id pub-id-type="pmid">21963610</pub-id></mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Battistuzzi</surname><given-names>F.U.</given-names></name><name><surname>Filipski</surname><given-names>A.</given-names></name><name><surname>Hedges</surname><given-names>S.B.</given-names></name><name><surname>Kumar</surname><given-names>S.</given-names></name></person-group><year>2010</year><article-title>Performance of relaxed-clock methods in estimating evolutionary divergence times and their credibility intervals</article-title>. <source>Mol. Biol. Evol.</source><volume>27</volume>(<issue>6</issue>):<fpage>1289</fpage>–<lpage>1300</lpage>.<pub-id pub-id-type="pmid">20093431</pub-id></mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bello</surname><given-names>G.</given-names></name><name><surname>Passaes</surname><given-names>C.P.</given-names></name><name><surname>Guimarães</surname><given-names>M.L.</given-names></name><name><surname>Lorete</surname><given-names>R.S.</given-names></name><name><surname>Matos Almeida</surname><given-names>S.E.</given-names></name><name><surname>Medeiros</surname><given-names>R.M.</given-names></name><name><surname>Alencastro</surname><given-names>P.R.</given-names></name><name><surname>Morgado</surname><given-names>M.G.</given-names></name></person-group><year>2008</year><article-title>Origin and evolutionary history of HIV-1 subtype C in Brazil</article-title>. <source>AIDS</source><volume>22</volume>:<fpage>1993</fpage>–<lpage>2000</lpage>.<pub-id pub-id-type="pmid">18753928</pub-id></mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Bertsekas</surname><given-names>D.P.</given-names></name></person-group><year>1999</year><source>Nonlinear programming</source>. <publisher-loc>Cambridge, MA</publisher-loc>: <publisher-name>Athena Scientific</publisher-name>,</mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Boyd</surname><given-names>S.</given-names></name><name><surname>Vandenberghe</surname><given-names>L.</given-names></name></person-group><year>2004</year><source>Convex optimization, Chapter 5:244</source>. <publisher-loc>Cambridge</publisher-loc>: <publisher-name>Cambridge University Press</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Britton</surname><given-names>T.</given-names></name><name><surname>Anderson</surname><given-names>C.L.</given-names></name><name><surname>Jacquet</surname><given-names>D.</given-names></name><name><surname>Lundqvist</surname><given-names>S.</given-names></name><name><surname>Bremer</surname><given-names>K.</given-names></name></person-group><year>2007</year><article-title>Estimating divergence times in large phylogenetic trees</article-title>. <source>Syst. Biol.</source><volume>56</volume>(<issue>5</issue>):<fpage>741</fpage>–<lpage>752</lpage>.<pub-id pub-id-type="pmid">17886144</pub-id></mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Christman</surname><given-names>M.C.</given-names></name><name><surname>Kedwaii</surname><given-names>A.</given-names></name><name><surname>Xu</surname><given-names>J.</given-names></name><name><surname>Donis</surname><given-names>R.O.</given-names></name><name><surname>Lu</surname><given-names>G.</given-names></name></person-group><year>2011</year><article-title>Pandemic (H1N1) 2009 virus revisited: an evolutionary retrospective</article-title>. <source>Infect. Genet. Evol.</source><volume>11</volume>:<fpage>803</fpage>–<lpage>811</lpage>.<pub-id pub-id-type="pmid">21382522</pub-id></mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Desper</surname><given-names>R.</given-names></name><name><surname>Gascuel</surname><given-names>O.</given-names></name></person-group><year>2002</year><article-title>Fast and accurate phylogeny reconstruction algorithms based on the minimum-evolution principle</article-title>. <source>J. Comput. Biol.</source><volume>19</volume>(<issue>5</issue>):<fpage>687</fpage>–<lpage>705</lpage>.<pub-id pub-id-type="pmid">12487758</pub-id></mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Douzery</surname><given-names>E.J.</given-names></name><name><surname>Delsuc</surname><given-names>F.</given-names></name><name><surname>Stanhope</surname><given-names>M.J.</given-names></name><name><surname>Huchon</surname><given-names>D.</given-names></name></person-group><year>2003</year><article-title>Local molecular clocks in three nuclear genes: divergence times for rodents and other mammals and incompatibility among fossil calibrations</article-title>. <source>J. Mol. Evol.</source><volume>57</volume>(<issue>1 Suppl</issue>):<fpage>S201</fpage>–<lpage>S213</lpage>.<pub-id pub-id-type="pmid">15008417</pub-id></mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Doyon</surname><given-names>J.P.</given-names></name><name><surname>Ranwez</surname><given-names>V.</given-names></name><name><surname>Daubin</surname><given-names>V.</given-names></name><name><surname>Berry</surname><given-names>V.</given-names></name></person-group><year>2011</year><article-title>Models, algorithms and programs for phylogeny reconciliation</article-title>. <source>Brief. Bioinform.</source><volume>12</volume>(<issue>5</issue>):<fpage>392</fpage>–<lpage>400</lpage>.<pub-id pub-id-type="pmid">21949266</pub-id></mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Drummond</surname><given-names>A.</given-names></name><name><surname>Rodrigo</surname><given-names>A.</given-names></name></person-group><year>2000</year><article-title>Reconstruction genealogies of serial samples under the assumption of a molecular clock using serial-sample UPGMA</article-title>. <source>Mol. Biol. Evol.</source>, <volume>17</volume>(<issue>12</issue>):<fpage>1807</fpage>–<lpage>1815</lpage>.<pub-id pub-id-type="pmid">11110896</pub-id></mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Drummond</surname><given-names>A.J.</given-names></name><name><surname>Pybus</surname><given-names>O.G.</given-names></name><name><surname>Rambaut</surname><given-names>A.</given-names></name><name><surname>Forsberg</surname><given-names>R.</given-names></name><name><surname>Rodrigo</surname><given-names>A.G.</given-names></name></person-group><year>2003a</year><article-title>Measurably evolving populations</article-title>. <source>Trends Ecol. Evol.</source><volume>18</volume>:<fpage>481</fpage>–<lpage>488</lpage>.</mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Drummond</surname><given-names>A.</given-names></name><name><surname>Pybus</surname><given-names>O.G.</given-names></name><name><surname>Rambaut</surname><given-names>A.</given-names></name></person-group><year>2003b</year><article-title>Inference of viral evolutionary rates from molecular sequences</article-title>. <source>Adv. Parasitol.</source><volume>54</volume>:<fpage>331</fpage>–<lpage>358</lpage>.<pub-id pub-id-type="pmid">14711090</pub-id></mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Drummond</surname><given-names>A.J.</given-names></name><name><surname>Ho</surname><given-names>S.Y.W.</given-names></name><name><surname>Phillips</surname><given-names>M.J.</given-names></name><name><surname>Rambaut</surname><given-names>A.</given-names></name></person-group><year>2006</year><article-title>Relaxed phylogenetics and dating with confidence</article-title>. <source>PLoS Biol.</source><volume>4</volume>:<fpage>e88</fpage>.<pub-id pub-id-type="pmid">16683862</pub-id></mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Drummond</surname><given-names>A.J.</given-names></name><name><surname>Rambaut</surname><given-names>A.</given-names></name></person-group><year>2007</year><article-title>BEAST: Bayesian evolutionary analysis by sampling trees</article-title>. <source>BMC Evol. Biol.</source><volume>7</volume>:<fpage>214</fpage>.<pub-id pub-id-type="pmid">17996036</pub-id></mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Drummond</surname><given-names>A.J.</given-names></name><name><surname>Suchard</surname><given-names>M.A.</given-names></name><name><surname>Xie</surname><given-names>D.</given-names></name><name><surname>Rambaut</surname><given-names>A.</given-names></name></person-group><year>2012</year><article-title>Bayesian phylogenetics with BEAUti and the BEAST 1.7</article-title>. <source>Mol. Biol. Evol.</source><volume>29</volume>(<issue>8</issue>):<fpage>1969</fpage>–<lpage>1973</lpage>.<pub-id pub-id-type="pmid">22367748</pub-id></mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Felsenstein</surname><given-names>J.</given-names></name></person-group><year>1989</year><article-title>PHYLIP - phylogeny inference package (Version 3.2)</article-title>. <source>Cladistics</source><volume>5</volume>:<fpage>164</fpage>–<lpage>166</lpage>.</mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fitch</surname><given-names>W.M.</given-names></name><name><surname>Margoliash</surname><given-names>E.</given-names></name></person-group><year>1967</year><article-title>Construction of phylogenetic trees</article-title>. <source>Science</source><volume>155</volume>:<fpage>279</fpage>–<lpage>284</lpage>.<pub-id pub-id-type="pmid">5334057</pub-id></mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gascuel</surname><given-names>O.</given-names></name></person-group><year>1997</year><article-title>BIONJ: an improved version of the NJ algorithm based on a simple model of sequence data</article-title>. <source>Mol. Biol. Evol.</source><volume>14</volume>(<issue>7</issue>):<fpage>685</fpage>–<lpage>695</lpage>.<pub-id pub-id-type="pmid">9254330</pub-id></mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grenfell</surname><given-names>B.T.</given-names></name><name><surname>Pybus</surname><given-names>O.G.</given-names></name><name><surname>Gog</surname><given-names>J.R.</given-names></name><name><surname>Wood</surname><given-names>J.L.</given-names></name><name><surname>Daly</surname><given-names>J.M.</given-names></name><name><surname>Mumford</surname><given-names>J.A.</given-names></name><name><surname>Holmes</surname><given-names>E.C.</given-names></name></person-group><year>2004</year><article-title>Unifying the epidemiological and evolutionary dynamics of pathogens</article-title>. <source>Science</source><volume>303</volume>:<fpage>327</fpage>–<lpage>332</lpage>.<pub-id pub-id-type="pmid">14726583</pub-id></mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guindon</surname><given-names>S.</given-names></name></person-group><year>2010</year><article-title>Bayesian estimation of divergence times from large sequence alignments</article-title>. <source>Mol. Biol. Evol.</source><volume>27</volume>:<fpage>1768</fpage>–<lpage>1781</lpage>.<pub-id pub-id-type="pmid">20194424</pub-id></mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guindon</surname><given-names>S.</given-names></name><name><surname>Gascuel</surname><given-names>O.</given-names></name></person-group><year>2003</year><article-title>A simple, fast and accurate algorithm to infer large phylogenies by maximum-likelihood</article-title>. <source>Syst. Biol.</source><volume>52</volume>(<issue>5</issue>):<fpage>696</fpage>–<lpage>704</lpage>.<pub-id pub-id-type="pmid">14530136</pub-id></mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Guindon</surname><given-names>S.</given-names></name><name><surname>Dufayard</surname><given-names>J.-F.</given-names></name><name><surname>Lefort</surname><given-names>V.</given-names></name><name><surname>Anisimova</surname><given-names>M.</given-names></name><name><surname>Hordijk</surname><given-names>W.</given-names></name><name><surname>Gascuel</surname><given-names>O.</given-names></name></person-group><year>2010</year><article-title>New algorithms and methods to estimate maximum-likelihood phylogenies: assessing the performance of PhyML 3.0</article-title>. <source>Syst. Biol.</source><volume>59</volume>:<fpage>307</fpage>–<lpage>321</lpage>.<pub-id pub-id-type="pmid">20525638</pub-id></mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hedge</surname><given-names>J.</given-names></name><name><surname>Lycett</surname><given-names>S.J.</given-names></name><name><surname>Rambaut</surname><given-names>A.</given-names></name></person-group><year>2013</year><article-title>Real-time characterization of the molecular epidemiology of an influenza pandemic</article-title>. <source>Biol. Lett.</source><volume>9</volume>:<fpage>5 20130331</fpage>.</mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Hedges</surname><given-names>S.B.</given-names></name><name><surname>Kumar</surname><given-names>S.</given-names></name></person-group>, editors. <year>2009</year><source>The timetree of life</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>Oxford University Press</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jetz</surname><given-names>W.</given-names></name><name><surname>Thomas</surname><given-names>G.H.</given-names></name><name><surname>Joy</surname><given-names>J.B.</given-names></name><name><surname>Redding</surname><given-names>D.W.</given-names></name><name><surname>Hartmann</surname><given-names>K.</given-names></name><name><surname>Mooers</surname><given-names>A.O.</given-names></name></person-group><year>2014</year><article-title>Global distribution and conservation of evolutionary distinctness in birds</article-title>. <source>Curr. Biol.</source><volume>24</volume>(<issue>9</issue>):<fpage>919</fpage>–<lpage>930</lpage>.<pub-id pub-id-type="pmid">24726155</pub-id></mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lambert</surname><given-names>D.M.</given-names></name><name><surname>Ritchie</surname><given-names>P.A.</given-names></name><name><surname>Millar</surname><given-names>C.D.</given-names></name><name><surname>Holland</surname><given-names>B.</given-names></name><name><surname>Drummond</surname><given-names>A.J.</given-names></name><name><surname>Baroni</surname><given-names>C.</given-names></name></person-group><year>2002</year><article-title>Rates of evolution in ancient DNA from Adelie penguins</article-title>. <source>Science</source><volume>295</volume>:<fpage>2270</fpage>–<lpage>2273</lpage>.<pub-id pub-id-type="pmid">11910113</pub-id></mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Langley</surname><given-names>C.H.</given-names></name><name><surname>Fitch</surname><given-names>W.</given-names></name></person-group><year>1974</year><article-title>An examination of the constancy of the rate of molecular evolution</article-title>. <source>J. Mol. Evol.</source><volume>3</volume>:<fpage>161</fpage>–<lpage>177</lpage>.<pub-id pub-id-type="pmid">4368400</pub-id></mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lefort</surname><given-names>V.</given-names></name><name><surname>Desper</surname><given-names>R.</given-names></name><name><surname>Gascuel</surname><given-names>O.</given-names></name></person-group><year>2015</year> (forthcoming). <article-title>FastME 2.0: a comprehensive, accurate, and fast distance-based phylogeny inference program</article-title>. <source>Mol. Biol. Evol.</source>
<volume>32</volume>:<fpage>2798</fpage>–<lpage>2800</lpage>.<pub-id pub-id-type="pmid">26130081</pub-id></mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lemey</surname><given-names>P.</given-names></name><name><surname>Suchard</surname><given-names>M.</given-names></name><name><surname>Rambaut</surname><given-names>A.</given-names></name></person-group><year>2009</year><article-title>Reconstructing the initial global spread of a human influenza pandemic: A Bayesian spatial–temporal model for the global spread of H1N1pdm</article-title>. <source>PLoS Curr.</source><volume>1</volume>:<fpage>RRN1031</fpage>.<pub-id pub-id-type="pmid">20029613</pub-id></mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lepage</surname><given-names>T.</given-names></name><name><surname>Bryant</surname><given-names>D.</given-names></name><name><surname>Philippe</surname><given-names>H.</given-names></name><name><surname>Lartillot</surname><given-names>N.</given-names></name></person-group><year>2007</year><article-title>A general comparison of relaxed molecular clock models</article-title>. <source>Mol. Biol. Evol.</source><volume>24</volume>:<fpage>2669</fpage>–<lpage>2680</lpage>.<pub-id pub-id-type="pmid">17890241</pub-id></mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="other">Mourad R., Chevennet F., Dunn D.T. Fearnhill E., Delpech V., Asboe D., Gascuel O., Hue S. 2015. A phylotype-based analysis highlights the role of drug-naive HIV-positive individuals in the transmission of antiretroviral resistance in the UK. AIDS 500:15-00106.</mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Murty</surname><given-names>K.G.</given-names></name></person-group><year>1988</year><article-title>Linear complementarity, linear and nonlinear programming</article-title>. <source>Sigma Series in Applied Mathematics</source>, Vol. <volume>3</volume><publisher-loc>Berlin</publisher-loc>: <publisher-name>Heldermann Verlag</publisher-name> p. <fpage>447</fpage>–<lpage>448</lpage></mixed-citation>
    </ref>
    <ref id="B36">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Nocedal</surname><given-names>J.</given-names></name><name><surname>Wright</surname><given-names>S.J.</given-names></name></person-group><year>2006</year><source>Numerical optimization</source>. <edition>2nd</edition> ed., Chapter 16. <publisher-name>Springer-Verlag</publisher-name>, <publisher-loc>Berlin, New York</publisher-loc> p. <fpage>455</fpage>–<lpage>468</lpage></mixed-citation>
    </ref>
    <ref id="B37">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>O'Meara</surname><given-names>O.T.</given-names></name></person-group><year>2000</year><source>Introduction to quadratic forms</source>. <publisher-loc>Berlin and New York</publisher-loc>: <publisher-name>Springer-Verlag</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Posada</surname><given-names>D.</given-names></name><name><surname>Crandall</surname><given-names>K.A.</given-names></name></person-group><year>2001</year><article-title>Evaluation of methods for detecting recombination from DNA sequences: Computer simulations</article-title>. <source>PNAS</source><volume>98</volume>(<issue>24</issue>):<fpage>13757</fpage>–<lpage>13762</lpage>.<pub-id pub-id-type="pmid">11717435</pub-id></mixed-citation>
    </ref>
    <ref id="B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rambaut</surname><given-names>A.</given-names></name></person-group><year>2000</year><article-title>Estimating the rate of molecular evolution: incorporating non-contemporaneous sequences into maximum likelihood phylogenies</article-title>. <source>Bioinformatics</source><volume>16</volume>(<issue>4</issue>):<fpage>395</fpage>–<lpage>399</lpage>.<pub-id pub-id-type="pmid">10869038</pub-id></mixed-citation>
    </ref>
    <ref id="B40">
      <mixed-citation publication-type="other">Rambaut A. 2007. Path-O-Gen web server: <ext-link ext-link-type="uri" xlink:href="http://tree.bio.ed.ac.uk/software/pathogen/">http://tree.bio.ed.ac.uk/software/pathogen/</ext-link></mixed-citation>
    </ref>
    <ref id="B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rambaut</surname><given-names>A.</given-names></name><name><surname>Grassly</surname><given-names>N.C.</given-names></name></person-group><year>1997</year><article-title>Seq-Gen: an application for the Monte Carlo simulation of DNA sequence evolution along phylogenetic trees</article-title>. <source>Comput. Appl. Biosci.</source><volume>13</volume>:<fpage>235</fpage>–<lpage>238</lpage>.<pub-id pub-id-type="pmid">9183526</pub-id></mixed-citation>
    </ref>
    <ref id="B42">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rambaut</surname><given-names>A.</given-names></name><name><surname>Holmes</surname><given-names>E.</given-names></name></person-group><year>2009</year><article-title>The early molecular epidemiology of the swine-origin A/H1N1 human influenza pandemic</article-title>. <source>PLoS Curr.</source><volume>1</volume>:<fpage>RRN1003</fpage>.<pub-id pub-id-type="pmid">20025195</pub-id></mixed-citation>
    </ref>
    <ref id="B43">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rannala</surname><given-names>B.</given-names></name><name><surname>Yang</surname><given-names>Z.</given-names></name></person-group><year>2007</year><article-title>Inferring speciation times under an episodic molecular clock</article-title>. <source>Syst. Biol.</source><volume>56</volume>(<issue>3</issue>):<fpage>453</fpage>–<lpage>466</lpage>.<pub-id pub-id-type="pmid">17558967</pub-id></mixed-citation>
    </ref>
    <ref id="B44">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rasmussen</surname><given-names>M.D.</given-names></name><name><surname>Kellis</surname><given-names>M.</given-names></name></person-group><year>2012</year><article-title>Unified modeling of gene duplication, loss, and coalescence using a locus tree</article-title>. <source>Genome Res.</source><volume>22</volume>(<issue>4</issue>):<fpage>755</fpage>–<lpage>765</lpage>.<pub-id pub-id-type="pmid">22271778</pub-id></mixed-citation>
    </ref>
    <ref id="B45">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ronquist</surname><given-names>F.</given-names></name><name><surname>Klopfstein</surname><given-names>S.</given-names></name><name><surname>Vilhelmsen</surname><given-names>L.</given-names></name><name><surname>Schulmeister</surname><given-names>S.</given-names></name><name><surname>Murray</surname><given-names>D.L.</given-names></name><name><surname>Rasnitsyn</surname><given-names>A.P.</given-names></name></person-group><year>2012</year><article-title>A total-evidence approach to dating with fossils, applied to the early radiation of the hymenoptera</article-title>. <source>Syst. Biol.</source><volume>61</volume>(<issue>6</issue>):<fpage>973</fpage>–<lpage>999</lpage>.<pub-id pub-id-type="pmid">22723471</pub-id></mixed-citation>
    </ref>
    <ref id="B46">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Saitou</surname><given-names>N.</given-names></name><name><surname>Nei</surname><given-names>M.</given-names></name></person-group><year>1987</year><article-title>The neighbor-joining method: a new method for reconstructing phylogenetic trees</article-title>. <source>Mol. Biol. Evol.</source><volume>4</volume>(<issue>4</issue>):<fpage>406</fpage>–<lpage>425</lpage>.<pub-id pub-id-type="pmid">3447015</pub-id></mixed-citation>
    </ref>
    <ref id="B47">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sanderson</surname><given-names>M.J.</given-names></name></person-group><year>1997</year><article-title>A nonparametric approach to estimating divergence times in the absence of rate constancy</article-title>. <source>Mol. Biol. Evol.</source><volume>14</volume>:<fpage>1218</fpage>–<lpage>1231</lpage>.</mixed-citation>
    </ref>
    <ref id="B48">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sanderson</surname><given-names>M.J.</given-names></name></person-group><year>2002</year><article-title>Estimating absolute rates of molecular evolution and divergence times: a penalized likelihood approach</article-title>. <source>Mol. Biol. Evol.</source><volume>19</volume>:<fpage>101</fpage>–<lpage>109</lpage>.<pub-id pub-id-type="pmid">11752195</pub-id></mixed-citation>
    </ref>
    <ref id="B49">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sanderson</surname><given-names>M.J.</given-names></name></person-group><year>2003</year><article-title>r8s: inferring absolute rates of molecular evolution and divergence times in the absence of a molecular clock</article-title>. <source>Bioinformatics.</source><volume>19</volume>(<issue>2</issue>):<fpage>301</fpage>–<lpage>302</lpage>.<pub-id pub-id-type="pmid">12538260</pub-id></mixed-citation>
    </ref>
    <ref id="B50">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Shankarappa</surname><given-names>R.</given-names></name><name><surname>Margolick</surname><given-names>J. B.</given-names></name><name><surname>Gange</surname><given-names>S. J.</given-names></name><name><surname>Rodrigo</surname><given-names>A. G.</given-names></name><name><surname>Upchurch</surname><given-names>D.</given-names></name><name><surname>Farzadegan</surname><given-names>H.</given-names></name><name><surname>Gupta</surname><given-names>P.</given-names></name><name><surname>Rinaldo</surname><given-names>C. R.</given-names></name><name><surname>Learn</surname><given-names>G. H.</given-names></name><name><surname>He</surname><given-names>X.</given-names></name><name><surname>Huang</surname><given-names>X.L.</given-names></name><name><surname>Mullins</surname><given-names>J.I.</given-names></name></person-group><year>1999</year><article-title>Consistent viral evolutionary changes associated with the progression of human immunodeficiency virus type 1 infection</article-title>. <source>J. Virol.</source><volume>73</volume>:<fpage>10489</fpage>–<lpage>10502</lpage>.<pub-id pub-id-type="pmid">10559367</pub-id></mixed-citation>
    </ref>
    <ref id="B51">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Smith</surname><given-names>S. A.</given-names></name><name><surname>O'Meara</surname><given-names>B.C.</given-names></name></person-group><year>2012</year><article-title>treePL: divergence time estimation using penalized likelihood for large phylogenies</article-title>. <source>Bioinformatics</source><volume>28</volume>:<fpage>2689</fpage>–<lpage>2690</lpage>.<pub-id pub-id-type="pmid">22908216</pub-id></mixed-citation>
    </ref>
    <ref id="B52">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sokal</surname><given-names>R.</given-names></name><name><surname>Michener</surname><given-names>C.</given-names></name></person-group><year>1958</year><article-title>A statistical method for evaluating systematic relationships</article-title>. <source>Kans. Univ. Sci. Bull.</source><volume>38</volume>:<fpage>1409</fpage>–<lpage>1438</lpage>.</mixed-citation>
    </ref>
    <ref id="B53">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stadler</surname><given-names>T.</given-names></name></person-group><year>2010</year><article-title>Sampling-through-time in birth-death trees</article-title>. <source>J. Theor. Biol.</source><volume>267</volume>:<fpage>396</fpage>–<lpage>404</lpage>.<pub-id pub-id-type="pmid">20851708</pub-id></mixed-citation>
    </ref>
    <ref id="B54">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Tarjan</surname><given-names>R. E.</given-names></name></person-group><year>1983</year><source>Data structures and network algorithms</source>. <publisher-loc>Philadelphia</publisher-loc>: <publisher-name>SIAM</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B55">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tamura</surname><given-names>K.</given-names></name><name><surname>Battistuzzi</surname><given-names>F.U.</given-names></name><name><surname>Billing-Ross</surname><given-names>P.</given-names></name><name><surname>Murillo</surname><given-names>O.</given-names></name><name><surname>Filipski</surname><given-names>A.</given-names></name><name><surname>Kumar</surname><given-names>S.</given-names></name></person-group><year>2012</year><article-title>Estimating divergence times in large molecular phylogenies</article-title>. <source>PNAS</source><volume>109</volume>:<fpage>19333</fpage>–<lpage>19338</lpage>.<pub-id pub-id-type="pmid">23129628</pub-id></mixed-citation>
    </ref>
    <ref id="B56">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Thorne</surname><given-names>J.L.</given-names></name><name><surname>Kishino</surname><given-names>H.</given-names></name><name><surname>Painter</surname><given-names>S.</given-names></name></person-group><year>1998</year><article-title>Estimating the rate of evolution of the rate of molecular evolution</article-title>. <source>Mol. Biol. Evol.</source><volume>15</volume>(<issue>12</issue>):<fpage>1647</fpage>–<lpage>1657</lpage>.<pub-id pub-id-type="pmid">9866200</pub-id></mixed-citation>
    </ref>
    <ref id="B57">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Thorne</surname><given-names>J.L.</given-names></name><name><surname>Kishino</surname><given-names>H.</given-names></name></person-group><year>2002</year><article-title>Divergence time and evolutionary rate estimation with multilocus data</article-title>. <source>Syst. Biol.</source><volume>51</volume>(<issue>5</issue>):<fpage>689</fpage>–<lpage>702</lpage>.<pub-id pub-id-type="pmid">12396584</pub-id></mixed-citation>
    </ref>
    <ref id="B58">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Volz</surname><given-names>E.M.</given-names></name><name><surname>Koelle</surname><given-names>K.</given-names></name><name><surname>Bedford</surname><given-names>T.</given-names></name></person-group><year>2013</year><article-title>Viral phylodynamics</article-title>. <source>PLoS Comput. Biol.</source><volume>9</volume>:<fpage>e1002947</fpage>.<pub-id pub-id-type="pmid">23555203</pub-id></mixed-citation>
    </ref>
    <ref id="B59">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xia</surname><given-names>X.</given-names></name><name><surname>Yang</surname><given-names>Q.</given-names></name></person-group><year>2011</year><article-title>A distance-based least-square method for dating speciation events</article-title>. <source>Mol. Phylogenet. Evol.</source><volume>59</volume>:<fpage>342</fpage>–<lpage>353</lpage>.<pub-id pub-id-type="pmid">21320613</pub-id></mixed-citation>
    </ref>
    <ref id="B60">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>Z.</given-names></name><name><surname>O'Brien</surname><given-names>J.D.</given-names></name><name><surname>Zheng</surname><given-names>X.</given-names></name><name><surname>Zhu</surname><given-names>H.Q.</given-names></name><name><surname>She</surname><given-names>Z.S.</given-names></name></person-group><year>2007</year><article-title>Tree and rate estimation by local evaluation of heterochronous nucleotide data</article-title>. <source>Bioinformatics</source><volume>23</volume>(<issue>2</issue>):<fpage>169</fpage>–<lpage>176</lpage>.<pub-id pub-id-type="pmid">17110369</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
