<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6694608</article-id>
    <article-id pub-id-type="publisher-id">3015</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-019-3015-y</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>FQStat: a parallel architecture for very high-speed assessment of sequencing quality metrics</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Chanumolu</surname>
          <given-names>Sree K.</given-names>
        </name>
        <address>
          <email>sree-krishna.chanumolu@unl.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Albahrani</surname>
          <given-names>Mustafa</given-names>
        </name>
        <address>
          <email>mealbahrani@gmail.com</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-9253-8152</contrib-id>
        <name>
          <surname>Otu</surname>
          <given-names>Hasan H.</given-names>
        </name>
        <address>
          <email>hotu2@unl.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1937 0060</institution-id><institution-id institution-id-type="GRID">grid.24434.35</institution-id><institution>Department of Electrical and Computer Engineering, </institution><institution>University of Nebraska-Lincoln, </institution></institution-wrap>Lincoln, NE 68588 USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>15</day>
      <month>8</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>15</day>
      <month>8</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>424</elocation-id>
    <history>
      <date date-type="received">
        <day>12</day>
        <month>5</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>30</day>
        <month>7</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s). 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">High throughput DNA/RNA sequencing has revolutionized biological and clinical research. Sequencing is widely used, and generates very large amounts of data, mainly due to reduced cost and advanced technologies. Quickly assessing the quality of giga-to-tera base levels of sequencing data has become a routine but important task. Identification and elimination of low-quality sequence data is crucial for reliability of downstream analysis results. There is a need for a high-speed tool that uses optimized parallel programming for batch processing and simply gauges the quality of sequencing data from multiple datasets independent of any other processing steps.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">FQStat is a stand-alone, platform-independent software tool that assesses the quality of FASTQ files using parallel programming. Based on the machine architecture and input data, FQStat automatically determines the number of cores and the amount of memory to be allocated per file for optimum performance. Our results indicate that in a core-limited case, core assignment overhead exceeds the benefit of additional cores. In a core-unlimited case, there is a saturation point reached in performance by increasingly assigning additional cores per file. We also show that memory allocation per file has a lower priority in performance when compared to the allocation of cores. FQStat’s output is summarized in HTML web page, tab-delimited text file, and high-resolution image formats. FQStat calculates and plots read count, read length, quality score, and high-quality base statistics. FQStat identifies and marks low-quality sequencing data to suggest removal from downstream analysis. We applied FQStat on real sequencing data to optimize performance and to demonstrate its capabilities. We also compared FQStat’s performance to similar quality control (QC) tools that utilize parallel programming and attained improvements in run time.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">FQStat is a user-friendly tool with a graphical interface that employs a parallel programming architecture and automatically optimizes its performance to generate quality control statistics for sequencing data. Unlike existing tools, these statistics are calculated for multiple datasets and separately at the “lane,” “sample,” and “experiment” level to identify subsets of the samples with low quality, thereby preventing the loss of complete samples when reliable data can still be obtained.</p>
      </sec>
      <sec>
        <title>Electronic supplementary material</title>
        <p>The online version of this article (10.1186/s12859-019-3015-y) contains supplementary material, which is available to authorized users.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Sequence quality</kwd>
      <kwd>FASTQ</kwd>
      <kwd>Parallel programming</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>National Institutes of Health</institution>
        </funding-source>
        <award-id>R21LM012759</award-id>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p id="Par11">High throughput DNA/RNA sequencing has revolutionized our understanding of and approach to biological and clinical research. Advancements in its technology and reduced cost have made sequencing available to a broad research and industry base [<xref ref-type="bibr" rid="CR1">1</xref>]. Be it RNAseq, ChIPseq, de novo genome sequencing, resequencing, or metagenomics, sequencing data in the range of giga-to-tera base throughput per experiment is typically generated by an average-sized research lab or company. The National Center for Biotechnology Information’s (NCBI) Sequence Read Archive (SRA) database [<xref ref-type="bibr" rid="CR2">2</xref>], one of the major publicly available molecular sequencing databases, has increased in size from about 20 G bases (Gb) to 20 peta bases (Pb) in approximately ten years. We have seen sequencing efforts across the board in the evolutionary tree, starting with viruses and bacteria and continuing all the way to humans resulting in thousands of datasets [<xref ref-type="bibr" rid="CR3">3</xref>, <xref ref-type="bibr" rid="CR4">4</xref>]. Hence, there is a constant need across a wide spectrum of biotechnology stakeholders for improved data storage and analysis methods that are able to handle large datasets in a reasonable amount of time.</p>
    <p id="Par12">From the early Sanger-based sequencing methods to the present next-generation sequencing (NGS) and beyond, sequencing has targeted the reconstruction of whole genomes and understanding the dynamics of molecules in a variety of biological samples, including specific model organisms, nonmodel organisms [<xref ref-type="bibr" rid="CR5">5</xref>], and clinical samples [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR7">7</xref>]. With the availability of huge sequencing repositories, higher-level studies have emerged, such as meta-analysis (large-scale, integrated analysis on multiple datasets) [<xref ref-type="bibr" rid="CR8">8</xref>], multiparameter combinatorial approaches, both in terms of the environment and the organism, and translational medicine efforts [<xref ref-type="bibr" rid="CR9">9</xref>]. On the other hand, the decrease in sequencing cost has far outpaced Moore’s Law [<xref ref-type="bibr" rid="CR10">10</xref>], rendering significant challenges to data storage and computational analysis. Therefore, whether it is an experiment generating new sequencing data or a study that attempts to analyze existing sequencing datasets, it is not atypical to be required to analyze hundreds or thousands of sequencing data samples. As a result, approaches making use of high computing clusters, such as parallel computing, have been an important aspect of dealing with increased sequencing data analysis and storage needs [<xref ref-type="bibr" rid="CR11">11</xref>, <xref ref-type="bibr" rid="CR12">12</xref>].</p>
    <p id="Par13">One of the critical steps of sequencing data analysis workflows is the quality control (QC). Eliminating low-quality data samples based on QC analysis vastly improves the accuracy and reliability of the downstream data analysis results [<xref ref-type="bibr" rid="CR13">13</xref>]. Furthermore, identifying data quality problems and carefully inspecting them provides feedback on the experimental procedures to pinpoint the aspects of the protocol that have led to quality problems. Projects that involve new datasets or reanalysis of existing datasets and large research and sequencing centers need to quickly assess the QC of hundreds or thousands of samples. Several sequencing QC tools have been developed using either serial [<xref ref-type="bibr" rid="CR14">14</xref>–<xref ref-type="bibr" rid="CR21">21</xref>] or parallel [<xref ref-type="bibr" rid="CR22">22</xref>–<xref ref-type="bibr" rid="CR28">28</xref>] architecture. However, the QC tools with parallel architecture do not optimize system performance by dynamic core or thread assignment; they just assign one core per file if multiple cores are available or divide a file into multiple cores and process the files sequentially. These approaches do not optimize memory assignment per file, nor do they process multiple files in parallel where each file is analyzed by multiple processors. We have improved on this facet in FQStat by probing system architecture and automatically optimizing the core/memory assignment per file in a dynamic fashion.</p>
    <p id="Par14">Most of the existing QC tools provide more capabilities than just QC assessment, such as variant reporting [<xref ref-type="bibr" rid="CR14">14</xref>, <xref ref-type="bibr" rid="CR23">23</xref>], adapter detection [<xref ref-type="bibr" rid="CR15">15</xref>], fusion transcript detection [<xref ref-type="bibr" rid="CR16">16</xref>], integration of different NGS data [<xref ref-type="bibr" rid="CR17">17</xref>], trimming [<xref ref-type="bibr" rid="CR27">27</xref>], or read alignment [<xref ref-type="bibr" rid="CR24">24</xref>, <xref ref-type="bibr" rid="CR28">28</xref>]. Although these approaches are helpful, they force the users to commit to analysis steps other than QC assessment to calculate simple QC parameters. In order to assess the QC of the sequencing data, the user needs to use the tool’s sequence processing steps and obtain the QC statistics for the processed data obtained using the tool. Furthermore, these programs lack the ability to take more than one dataset (e.g., raw and trimmed) as input and compare their respective QC parameters. This feature, for example, comes in handy when the quality of two different experiments is compared or when data trimming and filtering demonstrate improvement. FQStat can take two datasets as input and focus only on a comparative QC assessment of the two datasets, independent from any other sequence processing steps.</p>
    <p id="Par15">In a typical sequencing project, a sample is run on multiple lanes; and the reads coming from different lanes are combined [<xref ref-type="bibr" rid="CR29">29</xref>]. The reason for this is to still be able to obtain reliable data even if one or more lanes have failed. None of the aforementioned QC tools provide lane-level statistics to let the user pick and choose among the lanes that have performed satisfactorily. This becomes critical when sample-level statistics might warrant discarding the complete sequencing data for the sample, whereas lane-level statistics may identify lanes with reliable data that may be combined to represent the sample. Furthermore, in some analysis settings, experiment-level, not sample-level QC assessment is required. Most of the QC tools cited provide sample-level analysis and do not provide a “big picture,” experiment-level assessment; and those tools that do provide experiment-level assessment, do not provide sample-level analysis results. Finally, samples that have low QC parameters are not flagged in the existing QC tools to warn the user of potential samples to be discarded. Therefore, there is a need for a quick QC assessment tool that is not tied to other sequence processing steps, simply assesses the QC parameters for one or more datasets, automatically optimizes parallel architecture, provides lane and experiment level statistics, and flags low-quality lanes and/or samples. We believe FQStat fills this gap. A feature comparison with similar QC tools is provided in Table <xref rid="Tab1" ref-type="table">1</xref>.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Feature comparison between FQStat and similar QC tools</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Feature\Tool</th><th>FQStat</th><th>FaQCs</th><th>NGS QC Box</th><th>NGS QC ToolKit</th><th>RNA-QC-Chain</th><th>ClinQC</th></tr></thead><tbody><tr><td>Lane-level statistics</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Experiment-level statistics</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Trimming and filtering</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Comparison of multiple datasets</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Sample flagging</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Parallel programing</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Support compressed files</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>Graphical output</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Multithreading</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>Multiple processing for a single file (MPSF)</td><td>Yes</td><td>Yes/No*</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>Multiple processing for multiple files (MPMF)</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>Concurrent implementation of MPSF and MPMF</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Memory requirement</td><td>No</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Memory optimization</td><td>Yes</td><td>No</td><td>N/A</td><td>N/A</td><td>Yes</td><td>Yes</td></tr><tr><td>Automated resource optimization</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr></tbody></table><table-wrap-foot><p>*FaQCs divides a single file into split files and each split file is run on different processors but if the number of processors is more than the number of split files, then a split file is not processed by multiple processes</p></table-wrap-foot></table-wrap></p>
    <sec id="Sec2">
      <title>Implementation</title>
      <p id="Par16">FQStat is coded in Python 3.7.3® (<ext-link ext-link-type="uri" xlink:href="http://www.python.org">http://www.python.org</ext-link>) using the multiprocessing package and has a graphical user interface (GUI) where input/output files and program parameters can be configured. In order to avoid any mix-up from the outputs of different processes, FQStat uses lock protection on threads, the outputs of which are then assembled to generate FQStat’s final results. FQStat can also be executed using the command-line, enabling its use as part of scripts that handle batch processing. FQStat works with both single-end and paired-end FASTQ sequencing data, processes samples run on multiple lanes, and accepts one or two datasets (e.g., raw and trimmed) as input that involve the same samples. This information is conveyed to FQStat by arranging the sequencing files in a certain folder structure and by following a specific file naming convention as explained in the online tutorial. In consideration of the ever-increasing sequencing file sizes and numbers, we have implemented FQStat to handle both regular and compressed files. FQStat calculates and plots read count, read length, quality score, and high-quality base statistics. These statistics are calculated at the lane, sample, and experiment (dataset) levels; and the percent difference between the two datasets is noted. Experiment-level statistics are calculated in two ways: (i) lane resolution, where lane-level data are assumed to form the experiment; and (ii) sample resolution, where sample-level data are assumed to form the experiment. A high-quality base is defined as a base with a quality score above Q, which is a parameter that can be adjusted by the user. The default value for Q is 25.</p>
      <p id="Par17">The results of FQStat are stored in an HTML file. The tables and graphs shown in the HTML file are also saved as tab-delimited text files and high-resolution images, respectively. Image resolution can be adjusted by the user. FQStat identifies and marks low-quality sequencing data to suggest removal from downstream analysis. For each calculated statistic, lane- or sample-level sequencing data with an absolute z-score above 1.5 are flagged to warrant further inspection by the user. The 1.5 z-score cut-off can be changed by the user as an input parameter. In order to optimize system performance, FQStat probes its environment to obtain the number of available cores, available memory, and the number and size of input files to be analyzed. The simulations reported in this report were run on a single rack server with 768 GB of RAM and dual Intel® Xeon® E7–8870 CPU with 144 cores.</p>
    </sec>
    <sec id="Sec3">
      <title>Workflow</title>
      <p id="Par18">The overall workflow of FQStat is shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref>. The choice of core and memory allocations described in this section is based on our experiments, which are explained in the subsequent sections of this manuscript. FQStat first compares the number of files with the number of available cores. If the former is larger, it assigns one file per core and iteratively processes the files until all of the files are analyzed. If the latter is larger, the cores are divided among the files as evenly as possible as long as the number of cores assigned to a file does not exceed <italic>max_core</italic>. The <italic>max_core</italic> is a parameter that defines the number of cores above which core assignment to a file decreases the overall run time for the file. The default value for <italic>max_core</italic> is 55, but this value can be adjusted by the user.
<fig id="Fig1"><label>Fig. 1</label><caption><p>Overall workflow of FQStat. FQStat automatically optimizes the number of cores assigned to a file and the file split size (segments). System resources regarding the available cores and memory are utilized to full capacity</p></caption><graphic xlink:href="12859_2019_3015_Fig1_HTML" id="MO1"/></fig></p>
      <p id="Par19">If the available memory is less than the total file size to be analyzed, each file is split into segments such that the sum of the total segment size for each file (analyzed at a given instance by all the cores) equals the available memory. At each iteration, only the segment size of the file is read into the memory prior to processing. This way, FQStat is free from any memory requirements and can handle large file sizes and large numbers of files with limited memory resources. Here, we present three examples of core/memory assignment where <bold>F</bold> is the total number of files, <bold>C</bold> is the total number of available cores, <bold>S</bold> is the file size, and <bold>M</bold> is the available memory. Although file size may change from file to file and FQStat calculates the size of individual files for automatic performance optimization, we assume each FASTQ file has the same size, <bold>S</bold>, for the purpose of these examples.</p>
      <p id="Par20"><italic>Example Case 1</italic>, <bold>F</bold> = 30, <bold>C</bold> = 100, <bold>S</bold> = 2GB, <bold>M</bold> = 128GB: 20 files are assigned to 3 cores and 10 files are assigned to 4 cores. Each file is read (processed) in its entirety.</p>
      <p id="Par21"><italic>Example Case 2</italic>, <bold>F</bold> = 250, <bold>C</bold> = 40, <bold>S</bold> = 2GB, <bold>M</bold> = 128GB: Each file is assigned to 1 core, and each file is read in its entirety. After this is repeated for 6 iterations (6 × 40 = 240), the remaining (250–240 = 10) files in the following (final) iteration are assigned to 4 cores each; and each file is read in its entirety.</p>
      <p id="Par22"><italic>Example Case 3</italic>, <bold>F</bold> = 250, <bold>C</bold> = 100, <bold>S</bold> = 2GB, <bold>M</bold> = 60GB: Each file is assigned to 1 core, and each file is split into 4 segments such that the first three segments are 30% and the last segment is 10% of the total file size. This way, all 60GB of the available memory are used in the first three iterations. This whole procedure is repeated 2 times (2 × 100 = 200); and in the following (last) iteration, the remaining (250–200 = 50) files are assigned to 2 cores each. In this last iteration, each file is split into two segments such that the first segment is 60% of the file size, and the second segment is 40% of the file size.</p>
    </sec>
  </sec>
  <sec id="Sec4">
    <title>Results</title>
    <sec id="Sec5">
      <title>Effect of file split size and number of cores per file</title>
      <p id="Par23">In order to determine the effect of segment size (into which a FASTQ file is split) and the number of cores assigned to a file on run time, we used a test FASTQ file with 10 million reads from a real RNA-seq experiment that has targeted a read length of 75 bp. The file is either read in its entirety (segment size = 1 × 10<sup>7</sup> reads) or split into segments of 5 × 10<sup>6</sup>, 2 × 10<sup>6</sup>, 1 × 10<sup>6</sup>, 5 × 10<sup>5</sup>, 2 × 10<sup>5</sup>, and 1 × 10<sup>5</sup> reads. That is, when the segment size is 2 × 10<sup>6</sup> reads, for example, the file is split into 5 segments, each segment is processed in parallel using the C cores assigned to the file, and the 5 segments are iteratively analyzed. The results summarized in Fig. <xref rid="Fig2" ref-type="fig">2</xref> show that when a file is read in its entirety (i.e., segment size = file size), irrespective of the number of cores assigned to a file, the optimum performance was achieved. This is expected as splitting a file into segments and consolidating the results provides a time overhead compared to reading a file in its entirety.
<fig id="Fig2"><label>Fig. 2</label><caption><p>Time performance of FQStat using a test file with 10<sup>7</sup> reads (~ 75 bp read length). The performance is shown as a function of file split (segment) size and the number of cores assigned to the file. FQStat performs better with increased segment size, and the improvement in performance due to increased core assignment reaches a saturation point beyond which additional core assignment deteriorates program performance</p></caption><graphic xlink:href="12859_2019_3015_Fig2_HTML" id="MO2"/></fig></p>
      <p id="Par24">Increasing the number of cores assigned to a file, irrespective of the segment size, decreases the run time of the program until a certain point beyond which additional core assignment works against program performance. The time overhead incurred in parallel programming by using multiple cores involve task start-up and task termination times, synchronization, data communications, etc. Our results indicate that increased core assignment provides, at some point, enough time overhead that erases the performance benefit obtained by having more cores. For each segment size, the time required to analyze the test file follows a valley pattern (Fig. <xref rid="Fig2" ref-type="fig">2</xref>). The minimum point, that is the optimum number of cores assigned to a file, is reached between 50 and 60 cores. Therefore, we picked the <italic>max_core</italic> parameter in FQStat to be 55, which can be adjusted by the user. Although this limit is unlikely to be reached in real-life applications, FQStat still provides protection against performance deterioration by assigning too many cores per file. Also evident from Fig. <xref rid="Fig2" ref-type="fig">2</xref> is the fact that the degree of performance deterioration by increased core assignment is more pronounced as the file is split into smaller segments. For example, when 140 cores are assigned to the test file using a 1 × 10<sup>5</sup>-read segment size, the run time is ~ 86% of the one-core case. On the other hand, when the file is read in its entirety, the 140-core case takes only ~ 19% as much as that of the one-core case to run.</p>
      <p id="Par25">In addition to the case shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>, we have run additional simulations where the file size ranged from 10<sup>6</sup> to 10<sup>8</sup> reads, the segment size ranged from 10<sup>5</sup> to 10<sup>8</sup> reads, the number of available cores ranged from 10 to 140, and each case tried for read lengths of 75 bp, 100 bp, and 150 bp. Our results show that the conclusions attained in the case for Fig. <xref rid="Fig2" ref-type="fig">2</xref> remains true for the different combinations of files size, segment size, number of cores, and average read length. Despite showing slight variations among different combinations, run-times worsen after the number of cores assigned to a file exceed a threshold. These results are summarized in Additional files <xref rid="MOESM1" ref-type="media">1</xref>, <xref rid="MOESM2" ref-type="media">2</xref>, <xref rid="MOESM3" ref-type="media">3</xref>.</p>
    </sec>
    <sec id="Sec6">
      <title>Performance gain per assigned core</title>
      <p id="Par26">In order to see the degree of performance increase by additional core assignment, we defined the term “performance gain” (PG) using the one-core case as the baseline. The PG for the case when C cores are assigned to a file is defined as the ratio of the “time to process the file with one core” to “C times the time to process the file with C cores.” For example, if C = 2 and we use exactly half of the time it takes to analyze the file with one core, then PG = 1. However, if the time to analyze the file with two cores is less than half of the time it takes to analyze the file with one core, then PG &gt; 1, otherwise PG &lt; 1. When PG &gt; 1, it implies improved gains in performance with respect to the one-core case; and the larger the PG, the better the improvement in performance.</p>
      <p id="Par27">We used the same test file (10<sup>7</sup> reads with ~ 75 bp per read) and segment sizes, as described in the previous subsection, to calculate the PG for varying core assignments. The results, summarized in Fig. <xref rid="Fig3" ref-type="fig">3</xref>, show that the performance gain due to increased core assignment is always less than 1 and inversely proportional to the number of assigned cores. This is somewhat expected as the benefit obtained by additional cores is undermined by the overhead incurred by core assignment and data consolidation. Another outcome of this exercise was the reassurance of the benefit obtained by increased segment size. For almost all core assignment cases, the highest PG is obtained when the segment size equals the file size; and PGs show a monotonically decreasing behavior with decreasing segment size, i.e., more splits of the file.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Performance Gain (PG) with increased core assignment. The PG for the test file (10<sup>7</sup> reads, ~ 75 bp read length) as a function of the number of assigned cores and segment size. A PG less than 1 implies that the run time using C cores is more than 1/C of the one-core run time. Additional core assignments do not achieve at par PGs and loss in PG becomes worse with decreased segment size</p></caption><graphic xlink:href="12859_2019_3015_Fig3_HTML" id="MO3"/></fig></p>
      <p id="Par28">The two reported experiments imply that if the number of files exceeds the number of cores, then we should assign one core per file and process the files in groups until all files are analyzed. On the other hand, if there are more cores than files, then the cores should be divided among the files as evenly as possible. Furthermore, if there is sufficient available memory, then the files should be read in their entirety for processing (no splits). If the system memory is not large enough to read the files in full, then the segment size into which the files are split should be as large as possible, constrained by the memory limitations. For example, if we have 20 files and 5 cores, our results suggest that it does not help to analyze the files one at a time, processed in parallel across the 5 cores; but rather the files should be analyzed 5 at a time, each assigned to one core, processed in parallel.</p>
      <p id="Par29">Similar to the previous subsection, we repeated the simulation shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref> for the aforementioned varying levels of file size, segment size, number of cores, and read length. For each combination, our simulation results indicate that the conclusions based on Fig. <xref rid="Fig3" ref-type="fig">3</xref> hold true (Additional files <xref rid="MOESM4" ref-type="media">4</xref>, <xref rid="MOESM5" ref-type="media">5</xref>, <xref rid="MOESM6" ref-type="media">6</xref>), i.e., PG decreases with additional core assignment.</p>
      <p id="Par30">There still remains the question, “Does the performance loss due to additional core assignment exceed the performance loss due the file splits?” We emphasize that “performance loss due to additional core assignment” does not mean longer run times with the additional core assignment (as long as they are less than <italic>max_core</italic>, run times are always improved with additional cores), but we mean the observed PGs that are &lt; 1 (Fig. <xref rid="Fig2" ref-type="fig">2</xref>). On the other hand, we know that splitting the files deteriorates program performance as well. However, if we have to split files, is it better to assign multiple cores per file without splitting the file than to assign one core per file and split it? For example, if we have 20 files, 4 cores, 2GB per file, and 4 GB of available memory, should we still use one core per file and split the files into two segments of 50%; or should we use two cores per file and read the files in their entirety? We know that using two cores per file does not improve the run time by a factor of two, but we also know that splitting the files deteriorates program performance. We try to answer this question in the next subsection.</p>
    </sec>
    <sec id="Sec7">
      <title>File split versus core assignment</title>
      <p id="Par31">In order to determine the trade-off between a file split and a decrease in PG with increased core assignment in a core-limited and/or memory-limited case, we constructed the following experiment. We generated 100 files of 2 GB each and limited the resources available to FQStat to 40 cores and 20 GB. This way, even if we assign one core per file, we cannot read all of the files in their entirety, as that would require 80 GB of available memory. Therefore, we devised three analysis approaches where either one core per file is assigned (and the files are spilt), or the files are read in their entirety (but assigned to multiple cores), or a compromise is made between the two cases. This simulation was repeated for read lengths of 75 bp, 100 bp, and 150 bp.</p>
      <p id="Par32">The results of this experiment are shown in Table <xref rid="Tab2" ref-type="table">2</xref>. When we assigned 1 core per file, it was necessary to read the files in 4 splits (i.e., each segment size was 25% of the file size). Similarly, when we assigned 2 cores per file, the files needed to be processed in segment sizes of 50%. Finally, assigning 4 cores per file let us read the files in their entirety. Our results suggest that irrespective of the read length, the overhead incurred by splitting the files is less than that of core assignment as the fastest performance was achieved when one processor per file was assigned despite splitting the files into four segments for processing (due to memory limitations). Therefore, in a core- and memory-limited case, FQStat assigns one core per file and splits the files based on memory limitations (Fig. <xref rid="Fig1" ref-type="fig">1</xref>).
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Assessing the file split versus core assignment trade-off </p></caption><table frame="hsides" rules="groups"><thead><tr><th colspan="4">Time (sec)</th></tr><tr><th>Strategy</th><th>1 core per file 25% segment size</th><th>2 cores per file 50% segment size</th><th>4 cores per file 100% segment size</th></tr></thead><tbody><tr><td colspan="4">Read Length</td></tr><tr><td> 75 bp</td><td>2253</td><td>2625</td><td>2922</td></tr><tr><td> 100 bp</td><td>2262</td><td>2684</td><td>2931</td></tr><tr><td> 150 bp</td><td>2363</td><td>2851</td><td>2986</td></tr></tbody></table><table-wrap-foot><p>The input to FQStat was 100 FASTQ files each with 2 GB of size. These 100 files were generated using three different read lengths: 75 bp, 100 bp, 150 bp. The available resources were kept at 40 cores and 40 GB of memory. For each read length/analysis strategy combination, the total run time is shown in seconds</p></table-wrap-foot></table-wrap></p>
      <p id="Par33">Following the results of our experiments for performance optimization, we set up the FQStat processing strategy, as described in Fig. <xref rid="Fig1" ref-type="fig">1</xref>.</p>
    </sec>
  </sec>
  <sec id="Sec8">
    <title>Discussion</title>
    <p id="Par34">Given the volume of newly generated and reanalyzed sequencing data and the importance of QC analysis, FQStat uses a parallel programming architecture to introduce the following improvements: (i) automatic configuration of system parameters (e.g., core assignment and file segmentation) for optimum performance; (ii) analysis of multiple data sets for comparative assessment of QC parameters; (iii) not being coupled with other preprocessing steps (e.g., read mapping or low quality base trimming) for an easy-to-use, simple, and fast calculation of QC parameters only; (iv) generating analysis results separately at the lane-, sample-, and experiment-level so the users can pick and choose high quality subsets of the sample and/or experiment data; (v) flagging low quality lanes and/or samples that warrant further analysis; (vi) generating publication quality output figures and tables. FQStat handles both paired-end and single-end sequencing data run on single or multiple lanes. Such input data options and parameters are described by the user either using the GUI or the command-line version of FQStat. The former version is intended for a single experiment analysis providing the user a friendly interface whereas the latter is intended to be included in more complex workflows or batch processing. The details of the installation and usage of FQStat along with step-by-step screenshots of each process are included in the online tutorial.</p>
    <sec id="Sec9">
      <title>Sample output</title>
      <p id="Par35">We tried FQStat on real RNA-seq data available at NCBI’s SRA database with BioProject ID: PRJNA492713. The RNA-seq portion of this data set was comprised of 8 samples where each sample was run on 4 lanes using the Illumina NextSeq 500® platform. The target read length in the data set was 75 bp and the experiment was performed using paired-end sequencing. We processed the raw data using FASTQC (v. 0.11.5) [<xref ref-type="bibr" rid="CR30">30</xref>] and Trimmomatic (v 0.38) [<xref ref-type="bibr" rid="CR31">31</xref>]. This way, we obtained two datasets to be used in FQStat: “raw” (the dataset as downloaded from SRA) and “trimmed” (FASTQ files processed using FASTQC and Trimmomatic). We applied FASTQC separately for each lane of a sample and identified overrepresented sequences and other adapter and similar technical sequences, which were subsequently removed by Trimmomatic (v 0.38) in the palindrome mode, based on default alignment detection and scoring parameters. Maximum information quality filtering followed by a minimum average read quality threshold of 25 was used in Trimmomatic for low quality base filtering. Following technical sequence and low-quality base removal, reads that were shorter than 40 bp were filtered out.</p>
      <p id="Par36">On the FQStat web page (<ext-link ext-link-type="uri" xlink:href="http://otulab.unl.edu/FQStat">http://otulab.unl.edu/FQStat</ext-link>) we provide the full results of FQStat analysis on 2 samples from the described RNA-seq dataset. In Fig. <xref rid="Fig4" ref-type="fig">4</xref>, we provide a sample plot of FQStat for demonstration purposes. We chose to us the “high-quality bp %” feature of FQStat as this feature is rarely observed in existing QC tools and nicely demonstrates the improvements attained by the trimming and filtering step. We used default parameters in FQStat, and hence reported the percentage of bps that exceeded the quality score of 25 in both “raw” and “trimmed” FASTQ files. The results indicate that our trimming and filtering strategy has improved the high-quality bp percentage by about 1.5% on average for both samples on the forward reads (R1). However, for the reverse reads (R2), sample 1 (S1) has shown about 4.3% increase in high quality bp percentage, whereas this increase jumps up to about 8.6% for sample 2 (S2) R2 reads, following trimming and filtering. The starting high quality bp percentage (raw) for both samples in R2 is low (~ 90% in S1 and 83% in S2), which probably results in higher % increases due to trimming; and warrants a more careful look at the R2 data, providing feedback to the experimental phase of the project.
<fig id="Fig4"><label>Fig. 4</label><caption><p>Sample FQStat output displaying high-quality bp %. The percentage of bps that exceeds the default high-quality bp score of 25 are displayed for “raw” and “trimmed” FASTQ files. The percent difference between the two datasets is shown in the secondary y-axis. The results are shown for two samples (S1 and S2), for both forward and reverse reads (R1 and R2), for all four lanes (a, b, c, and d)</p></caption><graphic xlink:href="12859_2019_3015_Fig4_HTML" id="MO4"/></fig></p>
    </sec>
    <sec id="Sec10">
      <title>Comparison with other QC tools</title>
      <p id="Par37">We assessed FQStat’s performance in comparison with the five QC tools listed in Table <xref rid="Tab1" ref-type="table">1</xref> using the aforementioned test RNA-seq dataset that consisted of 100 2GB fastq files. In order to have a large dataset size, we multiplexed these files to be used as their paired-end counterparts, as well as the trimmed and filtered versions, resulting in 400 files. The test files used in this manuscript can be found on the FQStat website (<ext-link ext-link-type="uri" xlink:href="http://otulab.unl.edu/FQStat">http://otulab.unl.edu/FQStat</ext-link>). All of the tools used in our simulations implemented a parallel programming architecture and provided basic QC parameters. The test was done using two configurations. The first configuration was 140 cores with 768 GB of available memory aimed at mimicking a medium-to-high resource. The second configuration represented a more typical, low-to-medium resource and had 16 cores with 128 GB of available memory. As shown in Table <xref rid="Tab3" ref-type="table">3</xref>, FQStat outperforms most other QC tools that utilize a parallel architecture.
<table-wrap id="Tab3"><label>Table 3</label><caption><p>Run time for QC tools with parallel architecture using the test RNA-seq dataset</p></caption><table frame="hsides" rules="groups"><thead><tr><th colspan="7">Time (sec)</th></tr><tr><th>Resource\Tool</th><th>FQStat</th><th>FaQCs</th><th>NGS QC Box</th><th>NGS QC ToolKit</th><th>RNA-QC-Chain</th><th>ClinQC</th></tr></thead><tbody><tr><td>140 cores, 768 GB memory</td><td>1811</td><td>13,519</td><td>1560</td><td>13,051</td><td>8273</td><td>39,270</td></tr><tr><td>16 cores, 128 GB memory</td><td>6272</td><td>18,200</td><td>3668</td><td>62,371</td><td>15,980</td><td>94,882</td></tr></tbody></table></table-wrap></p>
      <p id="Par38">Where applicable, we used only the quality control aspect of the programs, omitting other processing steps (e.g., trimming and filtering) that would increase run time. NGS QC Box was the only program that outperformed our program, FQStat. However, NGS QC Box (run in “quick mode” in our simulations) did not generate QC statistics at the sample level but rather generated these statistics at the experiment level. In other words, while FQStat generated detailed statistics for each of the 400 files, NGS QC Box generated 4 values for each statistic, one for each “experiment”: Raw Pair1, Raw Pair2, Trimmed Pair1, and Trimmed Pair2. As generating an ensemble statistic for the entire 400 files requires dramatically less time than generating individual statistics for each of the 400 files, we believe FQStat’s effective performance is better than that of NGS QC Box. We also note that compared to NGS QC Box, FQStat attains a higher ratio of reduction in run-time when the system resources are improved (~ 3.5 vs. ~ 2.4), which may be attributable FQStat’s ability to optimize system resources.</p>
    </sec>
  </sec>
  <sec id="Sec11">
    <title>Conclusions</title>
    <p id="Par39">Despite the popularity of DNA/RNA sequencing, there is still need for a high-speed tool that uses parallel programming to gauge the quality of the data without committing to other sequence processing steps, automatically optimizes system performance, processes more than one dataset comparatively, and analyzes the data at lane-, sample-, and experiment-levels. We developed FQStat to address these issues and provide this platform-independent tool with a graphical user interface that is easy to use. FQStat works faster than similar QC tools and identifies and marks low-quality data to be further inspected by the user. The output can be easily monitored through two HTML files (one for graphs and one for tables), and the results are also stored in tab-delimited text files and publication-ready figure formats. We believe FQStat can be used by any sequencing pipeline to assist with experimental and analysis workflows, and we plan to continuously improve FQStat by incorporating additional QC parameters in its analysis core.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Additional files</title>
    <sec id="Sec12">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="12859_2019_3015_MOESM1_ESM.pdf">
            <label>Additional file 1:</label>
            <caption>
              <p>Effect of file split size and number of cores per file. Read Length = 75 bp (PDF 1417 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM2">
          <media xlink:href="12859_2019_3015_MOESM2_ESM.pdf">
            <label>Additional file 2:</label>
            <caption>
              <p>Effect of file split size and number of cores per file. Read Length = 100 bp (PDF 1424 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM3">
          <media xlink:href="12859_2019_3015_MOESM3_ESM.pdf">
            <label>Additional file 3:</label>
            <caption>
              <p>Effect of file split size and number of cores per file. Read Length = 150 bp (PDF 1462 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM4">
          <media xlink:href="12859_2019_3015_MOESM4_ESM.pdf">
            <label>Additional file 4:</label>
            <caption>
              <p>Performance gain per assigned core. Read Length = 75 bp (PDF 1079 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM5">
          <media xlink:href="12859_2019_3015_MOESM5_ESM.pdf">
            <label>Additional file 5:</label>
            <caption>
              <p>Performance gain per assigned core. Read Length = 100 bp (PDF 1082 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM6">
          <media xlink:href="12859_2019_3015_MOESM6_ESM.pdf">
            <label>Additional file 6:</label>
            <caption>
              <p>Performance gain per assigned core. Read Length = 150 bp (PDF 1083 kb)</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>CPU</term>
        <def>
          <p id="Par4">Central processing unit</p>
        </def>
      </def-item>
      <def-item>
        <term>HTML</term>
        <def>
          <p id="Par5">Hypertext markup language</p>
        </def>
      </def-item>
      <def-item>
        <term>Mac</term>
        <def>
          <p id="Par6">Macintosh</p>
        </def>
      </def-item>
      <def-item>
        <term>NCBI</term>
        <def>
          <p id="Par7">National Center for Biotechnology Information</p>
        </def>
      </def-item>
      <def-item>
        <term>NGS</term>
        <def>
          <p id="Par8">Next generation sequencing</p>
        </def>
      </def-item>
      <def-item>
        <term>QC</term>
        <def>
          <p id="Par9">Quality control</p>
        </def>
      </def-item>
      <def-item>
        <term>SRA</term>
        <def>
          <p id="Par10">Sequence read archive</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>Not applicable.</p>
    <sec id="FPar1">
      <title>Availability and requirements</title>
      <p id="Par40"><bold>Project name:</bold> FQStat.</p>
      <p id="Par41">
        <bold>Home page:</bold>
        <ext-link ext-link-type="uri" xlink:href="http://otulab.unl.edu/FQStat">http://otulab.unl.edu/FQStat</ext-link>
      </p>
      <p id="Par42"><bold>Operating systems:</bold> Linux, Windows, and Mac.</p>
      <p id="Par43"><bold>Programing Languages:</bold> Python 3.7.3.</p>
      <p id="Par44"><bold>Other requirements:</bold> Python tkinter and multiprocessing modules.</p>
      <p id="Par45"><bold>License:</bold> GNU public license.</p>
      <p id="Par46"><bold>Any restriction to use by non-academic users:</bold> Contact users.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>HHO conceived and designed the project; MA implemented the workflow, SKC wrote the code, and conducted the experiments, and analysis; HHO and SKC drafted the manuscript. All authors have tested the pipeline, read, and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>Research reported in this publication was supported by the National Library of Medicine (NLM) of the National Institutes of Health (NIH) under award number <bold>R21LM012759</bold>. The funding body was not involved in the design of the study and collection, analysis, and interpretation of data and in writing the manuscript.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>The software and data used in this publication are available at: <ext-link ext-link-type="uri" xlink:href="http://otulab.unl.edu/FQStat">http://otulab.unl.edu/FQStat</ext-link></p>
  </notes>
  <notes>
    <title>Ethics approval and consent to participate</title>
    <p id="Par47">Not applicable.</p>
  </notes>
  <notes>
    <title>Consent for publication</title>
    <p id="Par48">Not applicable.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p id="Par49">The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goodwin</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>McPherson</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>McCombie</surname>
            <given-names>WR</given-names>
          </name>
        </person-group>
        <article-title>Coming of age: ten years of next-generation sequencing technologies</article-title>
        <source>Nat Rev Genet</source>
        <year>2016</year>
        <volume>17</volume>
        <issue>6</issue>
        <fpage>333</fpage>
        <lpage>351</lpage>
        <pub-id pub-id-type="doi">10.1038/nrg.2016.49</pub-id>
        <pub-id pub-id-type="pmid">27184599</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kodama</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Shumway</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Leinonen</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>International nucleotide sequence database C: the sequence read archive: explosive growth of sequencing data</article-title>
        <source>Nucleic Acids Res</source>
        <year>2012</year>
        <volume>40</volume>
        <issue>Database issue</issue>
        <fpage>D54</fpage>
        <lpage>D56</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkr854</pub-id>
        <pub-id pub-id-type="pmid">22009675</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Park</surname>
            <given-names>ST</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Trends in next-generation sequencing and a new era for whole genome sequencing</article-title>
        <source>Int Neurourol J</source>
        <year>2016</year>
        <volume>20</volume>
        <issue>Suppl 2</issue>
        <fpage>S76</fpage>
        <lpage>S83</lpage>
        <pub-id pub-id-type="doi">10.5213/inj.1632742.371</pub-id>
        <pub-id pub-id-type="pmid">27915479</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tagu</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Colbourne</surname>
            <given-names>JK</given-names>
          </name>
          <name>
            <surname>Negre</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Genomic data integration for ecological and evolutionary traits in non-model organisms</article-title>
        <source>BMC Genomics</source>
        <year>2014</year>
        <volume>15</volume>
        <fpage>490</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2164-15-490</pub-id>
        <pub-id pub-id-type="pmid">25047861</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>da Fonseca</surname>
            <given-names>RR</given-names>
          </name>
          <name>
            <surname>Albrechtsen</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Themudo</surname>
            <given-names>GE</given-names>
          </name>
          <name>
            <surname>Ramos-Madrigal</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Sibbesen</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Maretty</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Zepeda-Mendoza</surname>
            <given-names>ML</given-names>
          </name>
          <name>
            <surname>Campos</surname>
            <given-names>PF</given-names>
          </name>
          <name>
            <surname>Heller</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Pereira</surname>
            <given-names>RJ</given-names>
          </name>
        </person-group>
        <article-title>Next-generation biology: sequencing and data analysis approaches for non-model organisms</article-title>
        <source>Mar Genomics</source>
        <year>2016</year>
        <volume>30</volume>
        <fpage>3</fpage>
        <lpage>13</lpage>
        <pub-id pub-id-type="doi">10.1016/j.margen.2016.04.012</pub-id>
        <pub-id pub-id-type="pmid">27184710</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gullapalli</surname>
            <given-names>RR</given-names>
          </name>
          <name>
            <surname>Desai</surname>
            <given-names>KV</given-names>
          </name>
          <name>
            <surname>Santana-Santos</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Kant</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Becich</surname>
            <given-names>MJ</given-names>
          </name>
        </person-group>
        <article-title>Next generation sequencing in clinical medicine: challenges and lessons for pathology and biomedical informatics</article-title>
        <source>J Pathol Inform</source>
        <year>2012</year>
        <volume>3</volume>
        <fpage>40</fpage>
        <pub-id pub-id-type="doi">10.4103/2153-3539.103013</pub-id>
        <pub-id pub-id-type="pmid">23248761</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Motro</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Moran-Gilad</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Next-generation sequencing applications in clinical bacteriology</article-title>
        <source>Biomol Detect Quantif</source>
        <year>2017</year>
        <volume>14</volume>
        <fpage>1</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="doi">10.1016/j.bdq.2017.10.002</pub-id>
        <pub-id pub-id-type="pmid">29255684</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <mixed-citation publication-type="other">Manini TM, Buford TW, Kairalla JA, McDermott MM, Vaz Fragoso CA, Fielding RA, Hsu FC, Johannsen N, Kritchevsky S, Harris TB, et al. Meta-analysis identifies mitochondrial DNA sequence variants associated with walking speed. Geroscience. 2018.</mixed-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Beigh</surname>
            <given-names>Mohammad</given-names>
          </name>
        </person-group>
        <article-title>Next-Generation Sequencing: The Translational Medicine Approach from “Bench to Bedside to Population”</article-title>
        <source>Medicines</source>
        <year>2016</year>
        <volume>3</volume>
        <issue>2</issue>
        <fpage>14</fpage>
        <pub-id pub-id-type="doi">10.3390/medicines3020014</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Wetterstrand</surname>
            <given-names>KA</given-names>
          </name>
        </person-group>
        <source>DNA sequencing costs: data from the NHGRI genome sequencing program (GSP). In: <italic>wwwgenomegov/sequencingcostsdata</italic></source>
        <year>2018</year>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <mixed-citation publication-type="other">Dahlo M, Scofield DG, Schaal W, Spjuth O. Tracking the NGS revolution: managing life science research on shared high-performance computing clusters. Gigascience. 2018;7(5).</mixed-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Muir</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Lou</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Spakowicz</surname>
            <given-names>DJ</given-names>
          </name>
          <name>
            <surname>Salichos</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Weinstock</surname>
            <given-names>GM</given-names>
          </name>
          <name>
            <surname>Isaacs</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Rozowsky</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The real cost of sequencing: scaling computation to keep pace with data generation</article-title>
        <source>Genome Biol</source>
        <year>2016</year>
        <volume>17</volume>
        <fpage>53</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-016-0917-0</pub-id>
        <pub-id pub-id-type="pmid">27009100</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Merino</surname>
            <given-names>GA</given-names>
          </name>
          <name>
            <surname>Fresno</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Netto</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Netto</surname>
            <given-names>ED</given-names>
          </name>
          <name>
            <surname>Pratto</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Fernández</surname>
            <given-names>EA</given-names>
          </name>
        </person-group>
        <article-title>The impact of quality control in RNA-seq experiments</article-title>
        <source>J Phys Conf Ser</source>
        <year>2016</year>
        <volume>705</volume>
        <issue>1</issue>
        <fpage>012003</fpage>
        <pub-id pub-id-type="doi">10.1088/1742-6596/705/1/012003</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shcherbina</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>FASTQSim: platform-independent data characterization and in silico read generation for NGS datasets</article-title>
        <source>BMC Res Notes</source>
        <year>2014</year>
        <volume>7</volume>
        <fpage>533</fpage>
        <pub-id pub-id-type="doi">10.1186/1756-0500-7-533</pub-id>
        <pub-id pub-id-type="pmid">25123167</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Davis</surname>
            <given-names>MP</given-names>
          </name>
          <name>
            <surname>van Dongen</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Abreu-Goodger</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Bartonicek</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Enright</surname>
            <given-names>AJ</given-names>
          </name>
        </person-group>
        <article-title>Kraken: a set of tools for quality control and analysis of high-throughput sequence data</article-title>
        <source>Methods</source>
        <year>2013</year>
        <volume>63</volume>
        <issue>1</issue>
        <fpage>41</fpage>
        <lpage>49</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ymeth.2013.06.027</pub-id>
        <pub-id pub-id-type="pmid">23816787</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kalari</surname>
            <given-names>KR</given-names>
          </name>
          <name>
            <surname>Nair</surname>
            <given-names>AA</given-names>
          </name>
          <name>
            <surname>Bhavsar</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>O'Brien</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>Davila</surname>
            <given-names>JI</given-names>
          </name>
          <name>
            <surname>Bockol</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Nie</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Baheti</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Doughty</surname>
            <given-names>JB</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>MAP-RSeq: Mayo analysis pipeline for RNA sequencing</article-title>
        <source>BMC Bioinformatics</source>
        <year>2014</year>
        <volume>15</volume>
        <fpage>224</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-15-224</pub-id>
        <pub-id pub-id-type="pmid">24972667</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lavender</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Shapiro</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Burkholder</surname>
            <given-names>AB</given-names>
          </name>
          <name>
            <surname>Bennett</surname>
            <given-names>BD</given-names>
          </name>
          <name>
            <surname>Adelman</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Fargo</surname>
            <given-names>DC</given-names>
          </name>
        </person-group>
        <article-title>ORIO (online resource for integrative omics): a web-based platform for rapid integration of next generation sequencing data</article-title>
        <source>Nucleic Acids Res</source>
        <year>2017</year>
        <volume>45</volume>
        <issue>10</issue>
        <fpage>5678</fpage>
        <lpage>5690</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkx270</pub-id>
        <pub-id pub-id-type="pmid">28402545</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Aevermann</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>McCorrison</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Venepally</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Hodge</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Bakken</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Novotny</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tran</surname>
            <given-names>DN</given-names>
          </name>
          <name>
            <surname>Diezfuertes</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Christiansen</surname>
            <given-names>L</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Production of a preliminary quality control pipeline for single nuclei Rna-Seq and its application in the analysis of cell type diversity of post-mortem human brain neocortex</article-title>
        <source>Pac Symp Biocomput</source>
        <year>2017</year>
        <volume>22</volume>
        <fpage>564</fpage>
        <lpage>575</lpage>
        <?supplied-pmid 27897007?>
        <pub-id pub-id-type="pmid">27897007</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>Bingshan</given-names>
          </name>
          <name>
            <surname>Zhan</surname>
            <given-names>Xiaowei</given-names>
          </name>
          <name>
            <surname>Wing</surname>
            <given-names>Mary-Kate</given-names>
          </name>
          <name>
            <surname>Anderson</surname>
            <given-names>Paul</given-names>
          </name>
          <name>
            <surname>Kang</surname>
            <given-names>Hyun Min</given-names>
          </name>
          <name>
            <surname>Abecasis</surname>
            <given-names>Goncalo R.</given-names>
          </name>
        </person-group>
        <article-title>QPLOT: A Quality Assessment Tool for Next Generation Sequencing Data</article-title>
        <source>BioMed Research International</source>
        <year>2013</year>
        <volume>2013</volume>
        <fpage>1</fpage>
        <lpage>4</lpage>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cabanski</surname>
            <given-names>CR</given-names>
          </name>
          <name>
            <surname>Cavin</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Bizon</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Wilkerson</surname>
            <given-names>MD</given-names>
          </name>
          <name>
            <surname>Parker</surname>
            <given-names>JS</given-names>
          </name>
          <name>
            <surname>Wilhelmsen</surname>
            <given-names>KC</given-names>
          </name>
          <name>
            <surname>Perou</surname>
            <given-names>CM</given-names>
          </name>
          <name>
            <surname>Marron</surname>
            <given-names>JS</given-names>
          </name>
          <name>
            <surname>Hayes</surname>
            <given-names>DN</given-names>
          </name>
        </person-group>
        <article-title>ReQON: a Bioconductor package for recalibrating quality scores from next-generation sequencing data</article-title>
        <source>BMC Bioinformatics</source>
        <year>2012</year>
        <volume>13</volume>
        <fpage>221</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-13-221</pub-id>
        <pub-id pub-id-type="pmid">22946927</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Peng</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Maxwell</surname>
            <given-names>AS</given-names>
          </name>
          <name>
            <surname>Barker</surname>
            <given-names>ND</given-names>
          </name>
          <name>
            <surname>Laird</surname>
            <given-names>JG</given-names>
          </name>
          <name>
            <surname>Kennedy</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Gong</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>SeqAssist: a novel toolkit for preliminary analysis of next-generation sequencing data</article-title>
        <source>BMC Bioinformatics</source>
        <year>2014</year>
        <volume>15</volume>
        <issue>Suppl 11</issue>
        <fpage>S10</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-15-S11-S10</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hong</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Manimaran</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>WE</given-names>
          </name>
        </person-group>
        <article-title>PathoQC: computationally efficient read preprocessing and quality control for high-throughput sequencing data sets</article-title>
        <source>Cancer Inform</source>
        <year>2014</year>
        <volume>13</volume>
        <issue>Suppl 1</issue>
        <fpage>167</fpage>
        <lpage>176</lpage>
        <?supplied-pmid 25983538?>
        <pub-id pub-id-type="pmid">25983538</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Katta</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Khan</surname>
            <given-names>AW</given-names>
          </name>
          <name>
            <surname>Doddamani</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Thudi</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Varshney</surname>
            <given-names>RK</given-names>
          </name>
        </person-group>
        <article-title>NGS-QCbox and raspberry for parallel, automated and rapid quality control analysis of large-scale next generation sequencing (Illumina) data</article-title>
        <source>PLoS One</source>
        <year>2015</year>
        <volume>10</volume>
        <issue>10</issue>
        <fpage>e0139868</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0139868</pub-id>
        <pub-id pub-id-type="pmid">26460497</pub-id>
      </element-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Knowles</surname>
            <given-names>DG</given-names>
          </name>
          <name>
            <surname>Roder</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Merkel</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Guigo</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Grape RNA-Seq analysis pipeline environment</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <issue>5</issue>
        <fpage>614</fpage>
        <lpage>621</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btt016</pub-id>
        <pub-id pub-id-type="pmid">23329413</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lo</surname>
            <given-names>CC</given-names>
          </name>
          <name>
            <surname>Chain</surname>
            <given-names>PS</given-names>
          </name>
        </person-group>
        <article-title>Rapid evaluation and quality control of next generation sequencing data with FaQCs</article-title>
        <source>BMC Bioinformatics</source>
        <year>2014</year>
        <volume>15</volume>
        <fpage>366</fpage>
        <pub-id pub-id-type="doi">10.1186/s12859-014-0366-2</pub-id>
        <pub-id pub-id-type="pmid">25408143</pub-id>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pandey</surname>
            <given-names>RV</given-names>
          </name>
          <name>
            <surname>Pabinger</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kriegner</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Weinhausel</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>ClinQC: a tool for quality control and cleaning of sanger and NGS data in clinical research</article-title>
        <source>BMC Bioinformatics</source>
        <year>2016</year>
        <volume>17</volume>
        <fpage>56</fpage>
        <pub-id pub-id-type="doi">10.1186/s12859-016-0915-y</pub-id>
        <pub-id pub-id-type="pmid">26830926</pub-id>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Patel</surname>
            <given-names>RK</given-names>
          </name>
          <name>
            <surname>Jain</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>NGS QC toolkit: a toolkit for quality control of next generation sequencing data</article-title>
        <source>PLoS One</source>
        <year>2012</year>
        <volume>7</volume>
        <issue>2</issue>
        <fpage>e30619</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0030619</pub-id>
        <pub-id pub-id-type="pmid">22312429</pub-id>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhou</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Su</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Jing</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ning</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>RNA-QC-chain: comprehensive and fast quality control for RNA-Seq data</article-title>
        <source>BMC Genomics</source>
        <year>2018</year>
        <volume>19</volume>
        <issue>1</issue>
        <fpage>144</fpage>
        <pub-id pub-id-type="doi">10.1186/s12864-018-4503-6</pub-id>
        <pub-id pub-id-type="pmid">29444661</pub-id>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Auer</surname>
            <given-names>PL</given-names>
          </name>
          <name>
            <surname>Doerge</surname>
            <given-names>RW</given-names>
          </name>
        </person-group>
        <article-title>Statistical design and analysis of RNA sequencing data</article-title>
        <source>Genetics</source>
        <year>2010</year>
        <volume>185</volume>
        <issue>2</issue>
        <fpage>405</fpage>
        <lpage>416</lpage>
        <pub-id pub-id-type="doi">10.1534/genetics.110.114983</pub-id>
        <pub-id pub-id-type="pmid">20439781</pub-id>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30.</label>
      <mixed-citation publication-type="other">Andrews S: FastQC: a quality control tool for high throughput sequence data. Reference Source; 2010. <ext-link ext-link-type="uri" xlink:href="https://www.bioinformatics.babraham.ac.uk/projects/fastqc/">https://www.bioinformatics.babraham.ac.uk/projects/fastqc/</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR31">
      <label>31.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bolger</surname>
            <given-names>AM</given-names>
          </name>
          <name>
            <surname>Lohse</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Usadel</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Trimmomatic: a flexible trimmer for Illumina sequence data</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <issue>15</issue>
        <fpage>2114</fpage>
        <lpage>2120</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu170</pub-id>
        <pub-id pub-id-type="pmid">24695404</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
