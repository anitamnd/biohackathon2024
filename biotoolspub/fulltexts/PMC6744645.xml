<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genome Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genome Biol</journal-id>
    <journal-title-group>
      <journal-title>Genome Biology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1474-7596</issn>
    <issn pub-type="epub">1474-760X</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6744645</article-id>
    <article-id pub-id-type="publisher-id">1809</article-id>
    <article-id pub-id-type="doi">10.1186/s13059-019-1809-x</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Review</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>When the levee breaks: a practical guide to sketching algorithms for processing the flood of genomic data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-0384-4463</contrib-id>
        <name>
          <surname>Rowe</surname>
          <given-names>Will P. M.</given-names>
        </name>
        <address>
          <email>w.rowe@bham.ac.uk</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1936 7486</institution-id><institution-id institution-id-type="GRID">grid.6572.6</institution-id><institution>Institute of Microbiology and Infection, School of Biosciences, University of Birmingham, </institution></institution-wrap>Birmingham, B15 2TT UK </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="GRID">grid.14467.30</institution-id><institution>Scientific Computing Department, </institution><institution>The Hartree Centre, STFC Daresbury Laboratory, </institution></institution-wrap>Warrington, WA4 4AD UK </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>13</day>
      <month>9</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>13</day>
      <month>9</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>199</elocation-id>
    <history>
      <date date-type="received">
        <day>12</day>
        <month>4</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>2</day>
        <month>9</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s). 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p id="Par1">Considerable advances in genomics over the past decade have resulted in vast amounts of data being generated and deposited in global archives. The growth of these archives exceeds our ability to process their content, leading to significant analysis bottlenecks. Sketching algorithms produce small, approximate summaries of data and have shown great utility in tackling this flood of genomic data, while using minimal compute resources. This article reviews the current state of the field, focusing on how the algorithms work and how genomicists can utilize them effectively. References to interactive workbooks for explaining concepts and demonstrating workflows are included at <ext-link ext-link-type="uri" xlink:href="https://github.com/will-rowe/genome-sketching">https://github.com/will-rowe/genome-sketching</ext-link>.</p>
    </abstract>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>Hartree Centre</institution>
        </funding-source>
        <award-id>-</award-id>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Introduction</title>
    <p id="Par2">To gain biological insight from genomic data, a genomicist must design experiments, run bioinformatic software and evaluate the results. This process is repeated, refined or augmented as new insight is gained. Typically, given the size of genomic data, this process is performed using high performance computing (HPC) in the form of local compute clusters, high-memory servers or cloud services. HPC offers fast disk-access, a large number of processors and high-memory. But HPC resources are in demand, with researchers queuing to use them, or having limited funds to access them. Worse yet, what happens when an experiment has too much data to be realistically stored or analyzed using these resources? Similarly, given the advent of real-time sequencing technologies, what if researchers want to ask questions of data as they are being generated or cannot wait for HPC to become available?</p>
    <p id="Par3">As genomics continues to thrive, from basic research through to personalized genome services, data continue to flood into genome archives and databases. One of the many consequences of this has been that genomicists now have a wealth of data to choose from when they design their experiments. This requires sampling considerations to be made, such as the quantity, quality and distribution of data. In an ideal world, most genomicists would elect to include all available data but this is growing harder to achieve as the amount of data drives up runtimes and costs.</p>
    <p id="Par4">In response to being unable to analyze <italic>all the things</italic>, genomicists are turning to analytics solutions from the wider data science field in order to process data quickly and efficiently [<xref ref-type="bibr" rid="CR1">1</xref>–<xref ref-type="bibr" rid="CR4">4</xref>]. In particular, the model of streaming data processing is proving incredibly effective in minimizing the resource usage of genomic analysis. Rather than capturing, sorting and indexing every piece of data, streaming data processing instead quickly looks at each piece of data as it is received and uses this information to summarize the current state. Once a piece of data has been processed it is no longer accessible; only the overall summary is kept [<xref ref-type="bibr" rid="CR5">5</xref>]. This summary is termed a sketch and serves as an approximation of the data that was processed (Table <xref rid="Tab1" ref-type="table">1</xref>).
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Glossary of terms</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Bit-pattern observable</td><td>The run of 0 s in a binary string</td></tr><tr><td>Bit vector</td><td>An array data structure that holds bits</td></tr><tr><td>Canonical k-mer</td><td>The smallest hash value between a k-mer and its reverse complement</td></tr><tr><td>Hash function</td><td>A function that takes input data of arbitrary size and maps it to a bit string that is of fixed size and typically smaller than the input</td></tr><tr><td>Jaccard similarity</td><td>A similarity measure defined as the intersection of sets, divided by their union</td></tr><tr><td>K-mer decomposition</td><td>The process of extracting all sub-sequences of length k from a sequence</td></tr><tr><td>Minimizer</td><td>The smallest hash value in a set</td></tr><tr><td>Multiset</td><td>A set that allows for multiple instances of each of its elements (i.e. element frequency)</td></tr><tr><td>Register</td><td>A quickly accessible bit vector used to hold information</td></tr><tr><td>Sketch</td><td>A compact data structure that approximates a data set</td></tr><tr><td>Stochastic averaging</td><td>A process used to reduce the variance of an estimator</td></tr></tbody></table></table-wrap></p>
    <p id="Par5">Sketch data structures are relatively small so fit entirely in memory; they need only a single pass of the data and you can use a sketch before the underlying data stream has terminated [<xref ref-type="bibr" rid="CR6">6</xref>]. This makes sketching faster and more efficient than high latency alternatives; you do not have to store an entire data stream and you can analyze data in real-time [<xref ref-type="bibr" rid="CR4">4</xref>, <xref ref-type="bibr" rid="CR7">7</xref>]. Another major advantage of sketch data structures is that they can be used to estimate averages; which in the case of genomics can be used to approximate the similarity of genomes without using all the sequence data [<xref ref-type="bibr" rid="CR1">1</xref>].</p>
    <p id="Par6">The next section outlines some properties of sketches and how they can be used to approximate the underlying data. In subsequent sections, the core sketching algorithms are described, detailing their uses, advantages, variants and current implementations for genomics. Interactive workbooks to demonstrate key concepts and workflows that utilize sketching to tackle real-world genomics problems are provided (see <bold>“</bold>Availability of data and material” section) [<xref ref-type="bibr" rid="CR8">8</xref>].</p>
  </sec>
  <sec id="Sec2">
    <title>What is sketching</title>
    <p id="Par7">The concept of data sketching has been around for several decades, originating with probabilistic counting algorithms that can estimate the number of distinct elements within a dataset on disk [<xref ref-type="bibr" rid="CR9">9</xref>]. Sketching has more recently been used to summarize data streams; first applications provided an ephemeral overview of data and more recently have offered persistent summaries of data streams [<xref ref-type="bibr" rid="CR10">10</xref>].</p>
    <p id="Par8">Put simply, sketching is the process of generating an approximate, compact summary of data. A sketch supports a set of predetermined query and update operations, which are used to approximate the original data. Compared with non-probabilistic algorithms, sketching requires less memory and has constant query time [<xref ref-type="bibr" rid="CR5">5</xref>].</p>
    <p id="Par9">To be considered a sketching algorithm, several requirements must be satisfied. Cormode et al. [<xref ref-type="bibr" rid="CR6">6</xref>] state that sketch updates must be consistent, irrespective of sketch history or the current sketch state. The sketching process results in a probabilistic data structure (the sketch) that is a linear transform of the input data. Sketches typically implement four key methods: create, update, merge and query. The ability to update and merge means parallelization is often achievable.</p>
    <p id="Par10">It should be stressed that sketching is not sampling. Although both allow for data to be summarized, sampling does not allow certain questions to be asked of the data, e.g. set membership. Sketching can yield better estimates than sampling. Standard error of a sample of size <italic>s</italic> is <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \frac{1}{\sqrt{s}} $$\end{document}</tex-math><mml:math id="M2" display="inline"><mml:mfrac><mml:mn>1</mml:mn><mml:msqrt><mml:mi>s</mml:mi></mml:msqrt></mml:mfrac></mml:math><inline-graphic xlink:href="13059_2019_1809_Article_IEq1.gif"/></alternatives></inline-formula>, whereas sketches of size <italic>s</italic> can guarantee error that is proportional to <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \frac{1}{s} $$\end{document}</tex-math><mml:math id="M4" display="inline"><mml:mfrac><mml:mn>1</mml:mn><mml:mi>s</mml:mi></mml:mfrac></mml:math><inline-graphic xlink:href="13059_2019_1809_Article_IEq2.gif"/></alternatives></inline-formula> [<xref ref-type="bibr" rid="CR5">5</xref>].</p>
    <p id="Par11">Sketching effectively compresses data, resulting in low memory requirements, queries in linear-time and reduced bandwidth requirements in distributed systems. Consequently, sketching has applications in data analytics, signal processing and dimensionality reduction. So if you can accept an approximate answer and need it quickly, sketching algorithms fit the bill. Which particular algorithm to use depends on the nature of the question you want to ask.</p>
  </sec>
  <sec id="Sec3">
    <title>Sketching algorithms and implementations</title>
    <sec id="Sec4">
      <title>Set similarity with MinHash</title>
      <sec id="Sec5">
        <title>Set similarity</title>
        <p id="Par12">Say we wish to compare two music collections, each containing 100 records. Each collection is a set and we can use Jaccard similarity, defined as the size of the intersection of two sets, divided by the size of their union, to measure their similarity. If our two collections have 60 records in common, then the Jaccard similarity is 60 divided by the number of distinct records 140, giving 0.429.</p>
        <p id="Par13">Jaccard similarity is regularly used in data science, for tasks such as document aggregation and duplicate detection [<xref ref-type="bibr" rid="CR11">11</xref>]. Document similarity can be based simply on the number of shared words (a “bag of words” model), but to also take into account document structure, it may be better to represent the document as a set of overlapping groups of words (termed “n-grams”). For instance, the following sentence “We come from the land of the ice and snow” can be broken into five n-grams (where <italic>n</italic> = 6): “We come from the land of”, “come from the land of the”, “from the land of the ice”, “the land of the ice and” and “land of the ice and snow”. Now, compare that with another sentence: “The hammer of the gods will drive our ships to new land”. Both of these sentences share the words “of”, “the” and “land” but not in the same n-gram context, so they do not have any similarity when you account for document structure. The Jaccard similarity is 0.176 using a bag of words model, but 0 using a bag of n-grams model (where <italic>n</italic> = 6), which retains some structure.</p>
        <p id="Par14">Looking at this example, you can tell it is a bit impractical to use the groups of words as they are; a 10-word sentence turns into five 6-word groups. Instead, we can <italic>hash</italic> these groups. Hash functions take large input data of arbitrary size and map it to a bit string of fixed size (called a hash value). So, each of these groups of words would be mapped to a hash value, and documents are compared by calculating the Jaccard similarity between the sets of hash values.</p>
        <p id="Par15">Even when using sets of hash values, you can see that Jaccard similarity calculations will get harder to compute as the sets get bigger, or the number of sets increases. In fact, in a worse-case scenario, pairwise similarity calculations scale quadratically in terms of time and space complexity. To perform set similarity queries efficiently on large datasets, we could accept approximate answers and look to sketching algorithms.</p>
      </sec>
      <sec id="Sec6">
        <title>MinHash algorithm</title>
        <p id="Par16">The MinHash algorithm generates a sketch that is designed to allow scalable approximation of the Jaccard similarity between sets. It was originally developed for detection of near-duplicate web pages and images [<xref ref-type="bibr" rid="CR12">12</xref>].</p>
        <p id="Par17">MinHash, as with other sketching algorithms, relies on hash functions. The hash functions used in sketching algorithms should be uniform and deterministic, i.e. input values should map evenly across an output range and a given input should always produce the same hash value. By applying a hash function to every element in a set and sorting the set by the resulting hash values, a pseudo-random permutation of the set is achieved. Taking this idea a step further, if the same hash function is applied to two sets, the chance of both sets having the same minimal hash value is going to be equal to the ratio of the number of common elements to the size of the union, i.e. the Jaccard similarity. Broder [<xref ref-type="bibr" rid="CR12">12</xref>, <xref ref-type="bibr" rid="CR13">13</xref>] first demonstrated this concept in his seminal work on MinHash.</p>
        <p id="Par18">The MinHash sketch data structure is a vector of hash values, plus some extra information describing how the sketch was made (e.g. which hash function). There are several different MinHash “flavors”, such as k-hash functions (KHFs) sketch, k-minimum values (KMVs) sketch and the k-partition sketch [<xref ref-type="bibr" rid="CR13">13</xref>–<xref ref-type="bibr" rid="CR19">19</xref>].</p>
        <p id="Par19">For now, let us focus on MinHash KHF sketches as this is the classic example of MinHash. As the name suggests, this flavor of MinHash uses <italic>K</italic> hash functions to generate <italic>K</italic> permutations of the set. For each permutation, the minimum value is added to the sketch and all other values are ignored (Algorithm 1).</p>
        <graphic position="anchor" xlink:href="13059_2019_1809_Figa_HTML" id="MO1"/>
        <p id="Par20">To estimate the Jaccard similarity of two sets using their KMV sketches, we compare the values in each position of the sketches and increment a counter if they match. The counter is then divided by sketch length, yielding the Jaccard similarity estimate. As this is probabilistic, we can increase the accuracy by increasing the number of random permutations sampled; the longer the sketch, the better the Jaccard similarity estimate. However, as having lots of unique hash functions is expensive, KHF sketching often uses K min-wise, independent permutations and a strong universal hash function that maps one hash value onto several other hash values.</p>
        <p id="Par21">An alternative to this approach is to have just one hash function, instead sampling K minimum values from the set. This is KMV sketching (also known as bottom-K sketching) and has the advantage that the sketch only needs to be updated if a new hash value is encountered that is smaller than the maximum value currently in the sketch. This means that KMV sketches can be straightforward to implement using a priority queue, allowing quick evaluation of a new hash value against the largest value currently in the queue. Another advantage with KMV sketching is that accuracy increases linearly with K; so for a set of N elements, when K ≥ N, accuracy = 1 as all elements will be in the sketch. This accuracy scaling is not guaranteed by a KHF sketch.</p>
        <p id="Par22">It is important to remember that when comparing MinHash sketches, they must have been constructed using the same MinHash algorithm, as well as with the same hash functions so that shared elements will yield the same hash values.</p>
      </sec>
      <sec id="Sec7">
        <title>MinHash implementations for genomics</title>
        <p id="Par23">To apply MinHash to a genomic data stream, we rely on the bioinformatic workhorse of k-mer decomposition. This involves breaking down a sequence into a set of overlapping subsequences of length <italic>k</italic>, termed k-mers, equivalent to the word groups in our earlier example (Fig. <xref rid="Fig1" ref-type="fig">1</xref>a). We do not need to differentiate between k-mers and their reverse complement, so we hash them both and keep only the smaller of the two hash values (the canonical k-mer).
<fig id="Fig1"><label>Fig. 1</label><caption><p><bold>a</bold> Sketching applied to a genomic data stream. The genomic data stream is viewed via a window; the window size may be equivalent to the length of a sequence read, a genome or some other arbitrary length. The sequence within the window is decomposed into a set of constituent k-mers; each k-mer can be evaluated against its reverse complement to keep only the canonical k-mer. As k-mers are generated, they are sketched and the sketch data structure may be updated. The sketch can be evaluated and allow feedback to the data stream process. <bold>b</bold> Common sketching algorithms applied to a single k-mer from a set, using example parameters. MinHash KHF: the k-mer is hashed by three functions, giving three values (<italic>green</italic>, <italic>blue</italic>, <italic>purple</italic>). The number of hash functions corresponds to the length of the sketch. Each value is evaluated against the corresponding position in the sketch; i.e. <italic>green</italic> compared against the first value, <italic>blue</italic> against the second, and <italic>purple</italic> against the third. The sketch updates with any new minimum; e.g. the <italic>blue</italic> value is smaller than the existing one in this position (3 &lt; 66), so replaces it. Bloom filter: the k-mer is hashed by two functions; giving two values (<italic>red</italic> and <italic>orange</italic>). The output range of the hash functions corresponds to the length of the sketch, here 0–3. The hash values are used to set bits to 1 at the corresponding positions. CountMin sketch: the k-mer is hashed by two functions; giving two values (<italic>red</italic> and <italic>brown</italic>). The number of functions corresponds to a row in the sketch, here 0 or 1, and the output range of the functions corresponds to the length of the rows, here 0–2. So the first hash value (<italic>red</italic>) gives matrix position 0,0 and the second gives 1,1. The counters held at these positions in the matrix are incremented. HyperLogLog: the k-mer is hashed by one function; giving a single value (10011). The prefix (<italic>brown</italic>) corresponds to a register, and the suffix (<italic>blue</italic>) corresponds to the bit-pattern observable. The suffix is compared to the existing value in register 1, is found to have more leading zeros and so replaces the existing value in register 1</p></caption><graphic xlink:href="13059_2019_1809_Fig1_HTML" id="MO2"/></fig></p>
        <p id="Par24">Some of the earliest implementations of MinHash for genomic applications were MHAP and MC-MinH, which applied MinHash sketching to genome assembly and metagenome sequence clustering, respectively [<xref ref-type="bibr" rid="CR20">20</xref>, <xref ref-type="bibr" rid="CR21">21</xref>]. These ideas were taken further with MASH, where the authors demonstrated that KMV MinHash sketches facilitate fast, approximate sequence similarity searches and provide an efficient method of sequence compression [<xref ref-type="bibr" rid="CR1">1</xref>]. The MASH authors extended MinHash to incorporate a pairwise mutation distance and <italic>P</italic> value significance test. MASH is able to accurately cluster genome and metagenome data, as well as perform real-time sequence database search. Since MASH, other multipurpose and well-documented MinHash libraries for genomics have been developed, such as sourmash, Finch and BBSketch (part of BBMap) [<xref ref-type="bibr" rid="CR22">22</xref>–<xref ref-type="bibr" rid="CR24">24</xref>].</p>
        <p id="Par25">As well as these libraries, several bioinformatic programs utilize the MinHash algorithm to provide fast and efficient answers for common genomics workflows (Table <xref rid="Tab2" ref-type="table">2</xref>). These include GROOT, which uses KHF sketching for variant detection in metagenome samples [<xref ref-type="bibr" rid="CR25">25</xref>], mashtree, which uses KMV sketching for phylogenetic tree construction [<xref ref-type="bibr" rid="CR26">26</xref>], and MashMap, which uses KMV sketching for long read alignment [<xref ref-type="bibr" rid="CR27">27</xref>, <xref ref-type="bibr" rid="CR41">41</xref>]. MashMap now also uses minimizers, which is a concept closely related to MinHash. By sliding a window across a sequence and decomposing windows to k-mers, the smallest hashed k-mer is the minimizer for that window. The minimizers from each window make up the sketch. Minimizers were proposed by Roberts et al. [<xref ref-type="bibr" rid="CR42">42</xref>] as a sequence compression method, and have been popularized by the MiniMap read aligner [<xref ref-type="bibr" rid="CR28">28</xref>, <xref ref-type="bibr" rid="CR43">43</xref>].
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Examples of bioinformatic software utilizing sketching algorithms</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Software</th><th>Purpose</th><th>Sketching algorithm</th></tr></thead><tbody><tr><td>GROOT [<xref ref-type="bibr" rid="CR25">25</xref>]</td><td>Variant detection in metagenomes</td><td>MinHash (KHF)</td></tr><tr><td>mashtree [<xref ref-type="bibr" rid="CR26">26</xref>]</td><td>Phylogenetic tree construction</td><td>MinHash (KMV)</td></tr><tr><td>MashMap [<xref ref-type="bibr" rid="CR27">27</xref>]</td><td>Long read alignment</td><td>Minimizer/MinHash (KMV)</td></tr><tr><td>MASH [<xref ref-type="bibr" rid="CR1">1</xref>]</td><td>Sequence analysis</td><td>MinHash (KMV)</td></tr><tr><td>sourmash [<xref ref-type="bibr" rid="CR22">22</xref>]</td><td>Sequence analysis</td><td>MinHash (KMV)</td></tr><tr><td>finch [<xref ref-type="bibr" rid="CR23">23</xref>]</td><td>Sequence analysis</td><td>MinHash (KMV)</td></tr><tr><td>MiniMap2 [<xref ref-type="bibr" rid="CR28">28</xref>]</td><td>Read alignment</td><td>Minimizer</td></tr><tr><td>ABySS [<xref ref-type="bibr" rid="CR29">29</xref>]</td><td>Genome assembly</td><td>Bloom filter</td></tr><tr><td>Lighter [<xref ref-type="bibr" rid="CR30">30</xref>]</td><td>Sequencing error correction</td><td>Bloom filter</td></tr><tr><td>BIGSI [<xref ref-type="bibr" rid="CR31">31</xref>]</td><td>Sequence index and search</td><td>Bloom filter</td></tr><tr><td>khmer [<xref ref-type="bibr" rid="CR32">32</xref>]</td><td>Sequence analysis</td><td>Count-Min sketch</td></tr><tr><td>FastEtch [<xref ref-type="bibr" rid="CR33">33</xref>]</td><td>Genome assembly</td><td>Count-Min sketch</td></tr><tr><td>dashing [<xref ref-type="bibr" rid="CR2">2</xref>]</td><td>Sequence analysis</td><td>HyperLogLog</td></tr><tr><td>krakenUniq [<xref ref-type="bibr" rid="CR34">34</xref>]</td><td>Metagenome classification</td><td>HyperLogLog</td></tr><tr><td>HULK [<xref ref-type="bibr" rid="CR4">4</xref>]</td><td>Sequence analysis</td><td>Histosketch</td></tr><tr><td>ntCard [<xref ref-type="bibr" rid="CR35">35</xref>]</td><td>Sequence analysis</td><td>ntCard</td></tr><tr><td>BBsketch [<xref ref-type="bibr" rid="CR24">24</xref>]</td><td>Sequence analysis</td><td>MinHash</td></tr><tr><td>MHAP [<xref ref-type="bibr" rid="CR21">21</xref>]</td><td>Genome assembly</td><td>MinHash</td></tr><tr><td>MC-MinH [<xref ref-type="bibr" rid="CR20">20</xref>]</td><td>Sequence clustering</td><td>MinHash</td></tr><tr><td>KmerGenie [<xref ref-type="bibr" rid="CR36">36</xref>]</td><td>Sequence analysis</td><td>Count-Min sketch variant</td></tr><tr><td>Squeakr [<xref ref-type="bibr" rid="CR37">37</xref>]</td><td>Sequence analysis</td><td>Counting Quotient Filter</td></tr><tr><td>Mantis [<xref ref-type="bibr" rid="CR38">38</xref>]</td><td>Sequence index and search</td><td>Counting Quotient Filter</td></tr><tr><td>kssd [<xref ref-type="bibr" rid="CR39">39</xref>]</td><td>Sequence analysis</td><td>K-mer Substring Space Decomposition</td></tr></tbody></table><table-wrap-foot><p>An up-to-date list is provided in [<xref ref-type="bibr" rid="CR40">40</xref>]</p></table-wrap-foot></table-wrap></p>
      </sec>
      <sec id="Sec8">
        <title>Considerations and variations</title>
        <p id="Par26">MinHash is an efficient way to estimate Jaccard similarity between sets. It was described above that Jaccard similarity is based on the union and intersection of sets, and that in genomics we consider k-mers as set elements in order to account for sequence structure. However, Jaccard similarity does not take into account element frequency within a set (referred to as a multiset). In genomics, we may want to include k-mer frequency in our similarity estimates, particularly when dealing with metagenomes. Several MinHash implementations have provision for multisets. For example, sourmash keeps a record of k-mer frequencies if requested (−-<italic>track-abundance</italic>) [<xref ref-type="bibr" rid="CR22">22</xref>], and Finch has a clever <italic>over-sketching</italic> method, which creates a parent sketch with tracked k-mer abundance which is used to populate a smaller child sketch with dynamic filtering [<xref ref-type="bibr" rid="CR23">23</xref>].</p>
        <p id="Par27">Another consideration is how to handle sets of different size; MinHash performance degrades with increasing difference in set size [<xref ref-type="bibr" rid="CR44">44</xref>]; for instance, using MinHash to find a genome within a metagenome. One solution is to combine MinHash with other data structures and utilize a containment index; set intersection is divided by the size of one of the sets to normalize for imbalance. This approach is now offered by sourmash, Finch and MASH [<xref ref-type="bibr" rid="CR22">22</xref>, <xref ref-type="bibr" rid="CR23">23</xref>, <xref ref-type="bibr" rid="CR45">45</xref>]. Sourmash also features several interesting alternatives, such as k-mer binning and greedy partitioning (see <italic>lca</italic> and <italic>gather</italic> sub-commands) [<xref ref-type="bibr" rid="CR22">22</xref>].</p>
        <p id="Par28">As well as the MinHash libraries discussed already, several recent algorithm variations deserve mentioning. BinDash [<xref ref-type="bibr" rid="CR46">46</xref>] is an implementation of binwise densified MinHash, offering improved speed, precision and compression performance over KMV sketching implementations. Order MinHash [<xref ref-type="bibr" rid="CR47">47</xref>] is a variant that considers the relative order of k-mers within sequences, enabling estimation of edit distance between sequences. HyperMinHash and b-Bit MinHash are MinHash variants that offer compressed sketches, and are typically a trade-off between accuracy, speed and storage cost [<xref ref-type="bibr" rid="CR17">17</xref>, <xref ref-type="bibr" rid="CR48">48</xref>].</p>
      </sec>
    </sec>
    <sec id="Sec9">
      <title>Set membership with Bloom filters</title>
      <sec id="Sec10">
        <title>Set membership</title>
        <p id="Par29">From our earlier example of set similarity, we know that we have similar taste in music. Let us say that you now want to listen to the records in my collection that you have not got in yours. This is a set membership query and, in a worst-case scenario, will require a loop through your collection for each record in my collection.</p>
        <p id="Par30">This worst-case scenario can be improved upon. For example our record collections could (or should!) be sorted alphabetically, meaning if I had “AC/DC - Powerage” and went through all the As in your collection without finding it, I would not need to continue looking and could play the record. We could also improve our search by remembering the entirety of your collection, bypassing the need to loop through your collection for each record in mine.</p>
        <p id="Par31">However, sorting sets can take time and memorizing sets can be difficult or impossible; our example would not scale well if we had millions of records. Fortunately, sketching algorithms allow us to approximate set membership queries and return answers quickly.</p>
      </sec>
      <sec id="Sec11">
        <title>Bloom filter algorithm</title>
        <p id="Par32">The Bloom filter algorithm produces a sketch for set membership queries; telling us if an element is possibly in a set, or if it is definitely not in the set (i.e. it allows false positives but no false negatives). Once you add an element to a Bloom filter, a subsequent query using the same element will tell you that you have probably seen it before. Elements cannot be removed from a Bloom filter and the more elements you add, the larger the probability of false positives [<xref ref-type="bibr" rid="CR49">49</xref>].</p>
        <p id="Par33">The Bloom filter algorithm uses hash functions to populate a bit vector (the sketch), which is essentially a row of bits that can be set to 0 or 1 (Algorithm 2). To begin, all bits are set to 0. When adding an element to the sketch, multiple hash functions are used to map the element to several positions in the sketch. At each mapped position, the bit is changed to a 1 if not already set, and cannot be changed back during the life of the sketch.</p>
        <graphic position="anchor" xlink:href="13059_2019_1809_Figb_HTML" id="MO3"/>
        <p id="Par34">To perform a set membership query, the query is hashed using the same functions used to create the Bloom filter. Each of the returned sketch positions is checked; if all bits are set to 1 then the element has probably been seen before. If one or more bits are set to 0, the element has definitely not been seen before. This is thanks to the deterministic property of the hash functions, meaning that an element will always be hashed to the same value.</p>
        <p id="Par35">To calibrate a Bloom filter, the false-positive rate is inversely proportional to the sketch length (the number of bits). The longer the sketch, the greater the number of possible hash values and the lower the chance of different elements hashing to the same value (a false positive); this is known as a hash collision. The more hash functions a Bloom filter uses the slower it will be, but using too few functions or too many will result in more false positives. A simple calculation computes the optimal number of hash functions for a given size of Bloom filter, but requires knowing an estimate of the number of distinct elements (Eq. <xref rid="Equ1" ref-type="">1</xref>).</p>
        <p id="Par36">The optimal number of hash functions (<italic>k</italic>) to minimize the false-positive rate for a Bloom filter of size m, for an estimated number of distinct elements (<italic>n</italic>)
<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ k=\frac{m}{n}\ \mathit{\ln}\ 2 $$\end{document}</tex-math><mml:math id="M6" display="block"><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi>m</mml:mi><mml:mi>n</mml:mi></mml:mfrac><mml:mspace width="0.25em"/><mml:mo mathvariant="italic">ln</mml:mo><mml:mspace width="0.25em"/><mml:mn>2</mml:mn></mml:math><graphic xlink:href="13059_2019_1809_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula></p>
        <p id="Par37">To decide how long to make the sketch and how many hash functions to use, optimization calculations can be performed to parameterize the sketch to give approximations within specified error bounds [<xref ref-type="bibr" rid="CR50">50</xref>].</p>
      </sec>
      <sec id="Sec12">
        <title>Bloom filter implementations for genomics</title>
        <p id="Par38">To apply a Bloom filter to a genomic data stream, we again use k-mer decomposition. The canonical form of each k-mer is passed through a Bloom filter; if the k-mer has not been seen before then it is added to the sketch (Fig. <xref rid="Fig1" ref-type="fig">1</xref>b). This can have several uses, such as approximating k-mer counts (using an additional hash table to track counts), or excluding unique k-mers from analyzes.</p>
        <p id="Par39">Although Bloom filters were first used in bioinformatics around 2007, one of the first genomics applications was BFCounter in 2011 [<xref ref-type="bibr" rid="CR51">51</xref>]. BFCounter used a Bloom filter to track k-mer counts; it used this sketch to give an approximation of k-mer abundance, or generated exact counts by combining the sketch with a hash table and performing a second pass of the data.</p>
        <p id="Par40">K-mer counting is a very common component in many genomic processes, such as sequence assembly, compression and error correction. Software that utilize Bloom filters for these processes include Minia, ABySS, Xander and dnaasm for assembly [<xref ref-type="bibr" rid="CR44">44</xref>, <xref ref-type="bibr" rid="CR52">52</xref>–<xref ref-type="bibr" rid="CR54">54</xref>], Quip for compression [<xref ref-type="bibr" rid="CR55">55</xref>], and Musket, BLESS and Lighter for error correction [<xref ref-type="bibr" rid="CR45">45</xref>, <xref ref-type="bibr" rid="CR56">56</xref>, <xref ref-type="bibr" rid="CR57">57</xref>]. Bloom filters are also used in conjunction with other sketching algorithms, such as by MASH to prevent singleton k-mers (which often arise from sequencing error) from being added to the MinHash sketch [<xref ref-type="bibr" rid="CR1">1</xref>].</p>
      </sec>
      <sec id="Sec13">
        <title>Considerations and variations</title>
        <p id="Par41">Although Bloom filters offer many performance advantages over non-sketching algorithms for set membership queries, as illustrated by their ubiquity in data science and genomics, they have several shortcomings which must be considered prior to their use. Limitations include the inability to remove elements, dynamically resize the sketch or count the number of occurrences of each item. Several variants of the Bloom filter algorithm aim to improve on these shortcomings, including counting, multistage and spectral Bloom filters [<xref ref-type="bibr" rid="CR3">3</xref>, <xref ref-type="bibr" rid="CR58">58</xref>], Cuckoo filters [<xref ref-type="bibr" rid="CR59">59</xref>] and counting quotient filters [<xref ref-type="bibr" rid="CR60">60</xref>].</p>
        <p id="Par42">In addition to these variants, Bloom filters have been used as building blocks in several algorithms for genomic indexing problems. One example is sequence bloom trees, which are a hierarchy of compressed Bloom filters with each one containing a subset of the items being indexed [<xref ref-type="bibr" rid="CR61">61</xref>]. Sequence bloom trees have been combined with MinHash to allow disk-based search of sketches [<xref ref-type="bibr" rid="CR22">22</xref>].</p>
        <p id="Par43">A recent indexing algorithm, the Bit-sliced Genomic Signature Index (BIGSI) [<xref ref-type="bibr" rid="CR31">31</xref>], utilizes a set of indexed Bloom filters for real-time sequence search. BIGSI improves upon other methods, including sequence bloom trees, which suffer from a performance drop when indexing diverse sequences (i.e. a scaling dependence on the total number of k-mers in the union of sequences being indexed). To create a BIGSI index, each sequence (e.g. genome assembly) is decomposed to k-mers, hashed <italic>N</italic> times and sketched using a Bloom filter; each Bloom filter is stored as a column in a matrix (the index). To query the index a k-mer is hashed <italic>N</italic> times to give <italic>N</italic> row indices; the corresponding row (a bit-slice) is returned for each. By performing a bitwise AND operation on the bit-slices, the returned column indices indicate samples containing the query k-mer. Not only is BIGSI exceptionally elegant and simple, it shows that a sketching algorithm that has been around for decades can still be adapted to create novel and high-performance genomics applications.</p>
      </sec>
    </sec>
    <sec id="Sec14">
      <title>Element frequency with count-min sketch</title>
      <sec id="Sec15">
        <title>Element frequency</title>
        <p id="Par44">To continue with our record collection analogy, you are busy enjoying the AC/DC back catalogue but are now wondering how many times they have used that same chord progression. This is an element frequency query and, in a worst-case scenario, requires you to create a list of every chord progression used in all the songs and count the number of times each occurs.</p>
        <p id="Par45">Element frequency queries get harder when you have massive and diverse sets, where the list of counts might become too large to process or hold in memory. For example, keeping count of all k-mers observed in a genome is memory intensive. This is where the Count-Min sketch comes in.</p>
      </sec>
      <sec id="Sec16">
        <title>Count-min sketch algorithm</title>
        <p id="Par46">The Count-Min sketch algorithm produces a sketch that is a two-dimensional matrix (<italic>d</italic> * <italic>w</italic>) which is used to approximate element frequency queries [<xref ref-type="bibr" rid="CR62">62</xref>]. The matrix size is parameterized by two factors, epsilon and delta, where the error in answering a query is within a factor of epsilon with a probability of delta.</p>
        <p id="Par47">To add an element to a Count-Min sketch, the element is hashed by <italic>d</italic> pairwise independent hash functions, where each hash function maps an element to a position in the range of 1..<italic>w</italic>. For each position, the counter in the matrix is incremented (Algorithm 3). The requirement of hash functions to exhibit pairwise independence minimizes hash collisions. The Count-Min sketch accommodates multisets as the counters in the matrix can be incremented by values greater than one.</p>
        <graphic position="anchor" xlink:href="13059_2019_1809_Figc_HTML" id="MO4"/>
        <p id="Par48">To query a Count-Min sketch and obtain a frequency estimate, an element is hashed as though it is being added to the sketch. Instead of incrementing the counter in each matrix position, the counters are evaluated and the minimum value is returned as the estimate.</p>
      </sec>
      <sec id="Sec17">
        <title>Count-min sketch implementations for genomics</title>
        <p id="Par49">Similar to MinHash and Bloom filters, a Count-Min sketch is implemented for genomics by considering k-mers as set elements. Each k-mer is added to the sketch and the counter incremented by the k-mer frequency (Fig. <xref rid="Fig1" ref-type="fig">1</xref>b).</p>
        <p id="Par50">Khmer [<xref ref-type="bibr" rid="CR3">3</xref>, <xref ref-type="bibr" rid="CR32">32</xref>] is a multipurpose software library for working with genomic data; at its core is a Count-Min sketch implementation for recording k-mer frequencies. Khmer also features a Bloom filter implementation for presence–absence queries. Some of the functionality of Khmer includes: read coverage normalization, read partitioning, read filtering and trimming. Count-Min Sketching is also utilized by the genome histosketching method, where k-mer spectra are represented by Count-Min sketches and the frequency estimates are utilized to populate a histosketch [<xref ref-type="bibr" rid="CR4">4</xref>]. The Count-Min sketch has also been used for de Bruijn graph approximation during de novo genome assembly; reducing the runtime and memory overheads associated with construction of the full graph and the subsequent pruning of low-quality edges [<xref ref-type="bibr" rid="CR33">33</xref>].</p>
      </sec>
      <sec id="Sec18">
        <title>Considerations and variations</title>
        <p id="Par51">The Count-Min sketch is a biased estimator of element frequency, due to the possibility of counts being overestimated but not underestimated. Overestimates occur when hash collisions result in the same position in the matrix being incremented by different elements. This is mitigated by increasing the size of the sketch to reduce hash collisions, although this cannot be performed when the sketch is in use (although dynamic sketches are a possibility). Another option is to use Bayesian statistics to characterize uncertainty in the Count-Min sketch frequency approximations [<xref ref-type="bibr" rid="CR63">63</xref>].</p>
        <p id="Par52">One variant of the Count-Min sketch involves scaling the counters during the lifetime of the sketch, allowing outdated elements to be gradually forgotten. This is an effective way of handling concept drift, whereby the distribution of the underlying data changes over time [<xref ref-type="bibr" rid="CR7">7</xref>]. Other variants of the Count-Min sketch exist, mostly aimed at improving the performance of the sketch when it needs to be kept on disk [<xref ref-type="bibr" rid="CR64">64</xref>].</p>
      </sec>
    </sec>
    <sec id="Sec19">
      <title>Set cardinality with HyperLogLog</title>
      <sec id="Sec20">
        <title>Set cardinality</title>
        <p id="Par53">Suppose we want to count how many different songs you have in your record collection. You simply count all the songs by title. If you had multiple copies of a song (e.g. live recordings), you only count them once. This is a set cardinality problem (counting distinct set elements). Set cardinality problems get harder to compute when the set size grows. The classic example is counting unique website views. Counting every unique IP address to visit a website using a hash table or database needs each address to be stored, which for websites with massive traffic requires lots of memory.</p>
      </sec>
      <sec id="Sec21">
        <title>HyperLogLog algorithm</title>
        <p id="Par54">HyperLogLog is a sketching algorithm designed to estimate the number of distinct elements in large datasets [<xref ref-type="bibr" rid="CR65">65</xref>]. Unlike the sketch algorithms looked at so far, which use the ordering of hash values, HyperLogLog is based on bit-pattern observables. The bit-pattern observable is the number of bits until the leftmost 1 is encountered. For example, 0001010 has three leading 0 s before the leftmost 1, so the bit-pattern observable value is 4. We use bit-pattern observable probabilities to estimate set cardinality. The process is akin to flipping a coin; the odds of getting a run of two heads before tails is ½ * ½ * ½, which is <inline-graphic xlink:href="13059_2019_1809_Figd_HTML.gif" id="d29e1216"/> (12.5%). The odds of a run of three heads before tails is 6.25%. The odds of getting a run of <italic>N</italic> heads followed by a tails is 1/2<sup><italic>N</italic> + 1</sup>. Rather than a sequence of heads or tails, think of a binary string (e.g. 0001010). The chance of seeing <italic>N</italic> 0 s followed by a 1 is 1/2<sup><italic>N</italic> + 1</sup>.</p>
        <p id="Par55">The key idea behind the HyperLogLog algorithm is that by applying a uniform and deterministic hash function to get a set permutation (à la MinHash), you use bit-pattern observables of the hash values to estimate the number of unique values in the set [<xref ref-type="bibr" rid="CR9">9</xref>]. If you encounter the hash value 0001010, which has a bit-pattern observable of 4, you can estimate you’ve seen 2<sup>4</sup> distinct values. We use this logic to estimate set cardinality by finding the longest run of 0 s. If the longest is <italic>N</italic> 0 s and then a 1, you have probably seen around 2<sup><italic>N</italic> + 1</sup> elements in your set. However, because this process is stochastic (you might have one element but its hash is 000001, giving an estimated 2<sup>6</sup> elements), we need to average multiple estimates.</p>
        <p id="Par56">To take multiple estimates we use the concept of registers. The HyperLogLog sketch is an array of registers; each records a count and is addressable with a unique identifier. By taking multiple estimates and then using stochastic averaging to reduce variance, HyperLogLog gives a cardinality estimate within defined error bounds.</p>
        <p id="Par57">To add an element to the sketch, it is hashed and the prefix (first <italic>A</italic> bits) of this value is removed and used to lookup a register in the sketch. The remainder of the hash value (the suffix) is used for the bit-pattern observable; the register is updated if the new bit-pattern observable is greater than the current one (Algorithm 4). To obtain a cardinality estimate from this sketch, the harmonic mean is calculated across all sketch registers and this is the approximate number of distinct elements in the set.</p>
        <graphic position="anchor" xlink:href="13059_2019_1809_Fige_HTML" id="MO5"/>
      </sec>
      <sec id="Sec22">
        <title>HyperLogLog implementations for genomics</title>
        <p id="Par58">HyperLogLog can estimate the number of distinct k-mers in a set (Fig. <xref rid="Fig1" ref-type="fig">1</xref>b). HyperLogLog has recently been implemented in the Dashing software for estimation of genomic distances [<xref ref-type="bibr" rid="CR2">2</xref>]. Similar to MinHash methods, Dashing uses sketches to summarize genomes and calculates pairwise distances based on k-mer set cardinality. HyperLogLog generally results in faster sketching and greater accuracy compared to MinHash-based methods [<xref ref-type="bibr" rid="CR2">2</xref>]. In addition, HyperLogLog does not suffer from the same performance degradation as MinHash when dealing with varying set size. However, for distance estimations HyperLogLog can be slower (compared with BinDash). Another limitation is that Dashing cannot report intersections (k-mers common between sets).</p>
        <p id="Par59">HyperLogLog is used by Khmer for counting distinct k-mers in samples [<xref ref-type="bibr" rid="CR32">32</xref>]. It has also been used by krakenUniq for metagenome classification, specifically to approximate how many unique k-mers are covered by reads [<xref ref-type="bibr" rid="CR25">25</xref>]. This improves upon the original classifier by enabling distinction between false-positive and true-positive database matches. The Meraculous assembler is another example of bioinformatic software that has been optimized using HyperLogLog; in this case, estimating k-mer cardinality for informing Bloom filter size [<xref ref-type="bibr" rid="CR66">66</xref>].</p>
      </sec>
      <sec id="Sec23">
        <title>Considerations and variations</title>
        <p id="Par60">As already mentioned, the main limitation of HyperLogLog is that it cannot accurately perform set intersection or difference operations. These operations are better suited to algorithms such as MinHash.</p>
        <p id="Par61">HyperLogLog currently has only a few implementations in genomics, with no variants that the author is aware of. In the wider data science field there are variants such as HyperLogLog++, which has an updated bias correction scheme [<xref ref-type="bibr" rid="CR67">67</xref>], and the sliding HyperLogLog, which is designed to operate on data streams [<xref ref-type="bibr" rid="CR68">68</xref>].</p>
      </sec>
    </sec>
    <sec id="Sec24">
      <title>Other algorithms</title>
      <p id="Par62">Several common set queries and the sketching algorithms designed to approximate them have now been covered. There are many more algorithms not covered which are already used in genomic research. For instance, histogram similarity using histoksetch can classify microbiomes based on incomplete data streams [<xref ref-type="bibr" rid="CR4">4</xref>]. Another histogram-based sketch is ntCard [<xref ref-type="bibr" rid="CR35">35</xref>], which uses a multiplicity table of hashed k-mers for estimating k-mer coverage frequencies.</p>
      <p id="Par63">The Counting Quotient Filter [<xref ref-type="bibr" rid="CR60">60</xref>] is a sketch for approximate membership and counting queries, with space usage as good or better than CountMin sketch. The Counting Quotient Filter is used by the Mantis software to index and search sequence collections; the index being smaller and faster than a sequence bloom tree [<xref ref-type="bibr" rid="CR38">38</xref>]. It can also be used for constructing weighted de Bruijn graphs [<xref ref-type="bibr" rid="CR69">69</xref>].</p>
      <p id="Par64">K-mer substring space decomposition (KSSD) is a recently proposed alternative to locality sensitive hashing schemes (such as MinHash), which uses random k-mer substring space sampling to generate sketches of genomic sequences [<xref ref-type="bibr" rid="CR39">39</xref>]. KSSD offers significant improvements (both in terms of accuracy and resource usage) over MASH screen for containment analysis but is currently restricted to use with long sequences (&gt; 10 kbp) as shorter sequences cannot undergo KSSD dimensionality reduction and still yield an informative sketch.</p>
      <p id="Par65">The field is constantly being augmented with new algorithms and implementations. In an effort to keep a current list of sketching algorithms for genomics, please refer to the accompanying repository and file a pull request if tools are missing [<xref ref-type="bibr" rid="CR40">40</xref>].</p>
    </sec>
  </sec>
  <sec id="Sec25">
    <title>Workflows for genomics</title>
    <p id="Par66">Several workflows for genomics that utilize sketching algorithms have been included in this article. These are available (see “Availability of data and material” section) and can be run interactively via Binder [<xref ref-type="bibr" rid="CR8">8</xref>, <xref ref-type="bibr" rid="CR70">70</xref>]. These workflows tackle the various stages of an outbreak investigation from a paper by Reuter et al. [<xref ref-type="bibr" rid="CR71">71</xref>], which compared whole genome sequence analysis of bacterial isolates with standard clinical microbiology practice. They demonstrated that genomics enhanced diagnostic capabilities in the context of investigating nosocomial outbreaks caused by multidrug-resistant bacteria. However, the authors relied on intensive analyses such as genome assembly and phylogenetic tree construction. Here, it is shown that sketching algorithms can replicate their analyses in several minutes, using just 1 GB of memory and not needing to store data on disk.</p>
    <p id="Par67">Workflow 1 demonstrates the use of Count-Min sketches and Bloom filters for checking and improving sequence read quality [<xref ref-type="bibr" rid="CR30">30</xref>, <xref ref-type="bibr" rid="CR32">32</xref>], as well as showing how MinHash sketches can be used to classify sequence data [<xref ref-type="bibr" rid="CR22">22</xref>]. Workflow 2 performs resistome profiling of bacterial isolates using MinHash and Minimizers while sequence data are read from online repositories [<xref ref-type="bibr" rid="CR25">25</xref>, <xref ref-type="bibr" rid="CR28">28</xref>]. Workflow 3 replicates the outbreak surveillance of Reuter et al. [<xref ref-type="bibr" rid="CR71">71</xref>] using MinHash distances to build a Newick tree that shared the same topology as the phylogeny from the paper [<xref ref-type="bibr" rid="CR1">1</xref>, <xref ref-type="bibr" rid="CR26">26</xref>]. Workflow 4 augments the analysis from the original paper by using the Bloom filter-based BIGSI to identify additional isolates matching the resistome profile of the outbreak bacteria [<xref ref-type="bibr" rid="CR31">31</xref>].</p>
  </sec>
  <sec id="Sec26">
    <title>Conclusions and future directions</title>
    <p id="Par68">Sketching clearly offers many benefits for genomic research. It has been shown how sketches can compress, index and search data, using a fraction of the resources needed by other classes of algorithms. Sketching algorithms are therefore a great approach for processing huge amounts of genomic data while using basic hardware (e.g. laptops). Sketching also has applications for data privacy, whereby sketching effectively anonymizes confidential data and enables remote analytics. For example, Balaur is a read aligner that sketches data to preserve privacy before outsourcing alignments to cloud compute [<xref ref-type="bibr" rid="CR72">72</xref>].</p>
    <p id="Par69">Many exciting genomics applications for sketching are beginning to be realized. As sketches are relatively stable and very compact, they are excellent candidates for database indexing and compression. This functionality is already being used by projects such as sourmash, which are able to provide indexed collections of reference sequences that are ready to be interrogated using user-defined sketches [<xref ref-type="bibr" rid="CR22">22</xref>]. This could allow you to download any genome collection, sketching the download in real-time and using this information to inform downstream analysis, e.g. what genomes to write to disk or to analyze on HPC. This real-time usability of sketches lends them to machine learning applications. We recently showed their utility as succinct representations of microbiome data streams that can be used to predict information about the samples [<xref ref-type="bibr" rid="CR4">4</xref>, <xref ref-type="bibr" rid="CR73">73</xref>]. Sketching has clear potential in real-time analytics, such as for monitoring sequencing progress.</p>
    <p id="Par70">In response to the recent adoption of sketching algorithms for genomics, this review has set out to cover how these algorithms can be used to address some of the challenges we are encountering as genomic data sources continue to grow. Hopefully it has provided an understanding of how sketching algorithms work, their benefits and limitations and how sketching can be applied to existing genomic workflows. If you wish to continue reading more on the topic of sketching algorithms, the excellent review that was recently published by Marçais et al. [<xref ref-type="bibr" rid="CR74">74</xref>] is recommended.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary information</title>
    <sec id="Sec27">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="13059_2019_1809_MOESM1_ESM.docx">
            <label>Additional file 1:</label>
            <caption>
              <p>Review history.(DOCX 25 kb)</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Electronic supplementary material</title>
    <p>The online version of this article (10.1186/s13059-019-1809-x) contains supplementary material, which is available to authorized users.</p>
  </sec>
  <ack>
    <title>Acknowledgements</title>
    <p>The author is grateful to Martyn Winn at the STFC for his continued guidance and his feedback on this manuscript.</p>
    <sec id="FPar1">
      <title>Review History</title>
      <p id="Par71">The review history is available as Additional file <xref rid="MOESM1" ref-type="media">1</xref>.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Author’s contributions</title>
    <p>WPMR conceived and wrote the review. WPMR coded and tested the notebooks. The author read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>This work was supported in part by the STFC Hartree Centre’s Innovation Return on Research programme, funded by the Department for Business, Energy and Industrial Strategy.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>The source code for the notebooks is available under an MIT License (at <ext-link ext-link-type="uri" xlink:href="https://github.com/will-rowe/genome-sketching">https://github.com/will-rowe/genome-sketching</ext-link>) and the live notebooks are available via Binder [<xref ref-type="bibr" rid="CR8">8</xref>, <xref ref-type="bibr" rid="CR70">70</xref>]. The genome data used in the notebooks is available from the ENA under BioProject PRJEB3353 [<xref ref-type="bibr" rid="CR74">74</xref>].</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p id="Par72">The author declares that he has no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ondov</surname>
            <given-names>BD</given-names>
          </name>
          <name>
            <surname>Treangen</surname>
            <given-names>TJ</given-names>
          </name>
          <name>
            <surname>Melsted</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Mallonee</surname>
            <given-names>AB</given-names>
          </name>
          <name>
            <surname>Bergman</surname>
            <given-names>NH</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mash: fast genome and metagenome distance estimation using MinHash</article-title>
        <source>Genome Biol</source>
        <year>2016</year>
        <volume>17</volume>
        <fpage>132</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-016-0997-x</pub-id>
        <pub-id pub-id-type="pmid">27323842</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <mixed-citation publication-type="other">Baker DN, Langmead B. Dashing: fast and accurate genomic distances with HyperLogLog. bioRxiv. 2019:501726.</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Pell</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Canino-Koning</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Howe</surname>
            <given-names>AC</given-names>
          </name>
          <name>
            <surname>Brown</surname>
            <given-names>CT</given-names>
          </name>
        </person-group>
        <article-title>These are not the K-mers you are looking for: efficient online K-mer counting using a probabilistic data structure</article-title>
        <source>PLoS One</source>
        <year>2014</year>
        <volume>9</volume>
        <fpage>e101271</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0101271</pub-id>
        <pub-id pub-id-type="pmid">25062443</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rowe</surname>
            <given-names>WPM</given-names>
          </name>
          <name>
            <surname>Carrieri</surname>
            <given-names>AP</given-names>
          </name>
          <name>
            <surname>Alcon-Giner</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Caim</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Shaw</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Sim</surname>
            <given-names>K</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Streaming histogram sketching for rapid microbiome analytics</article-title>
        <source>Microbiome.</source>
        <year>2019</year>
        <volume>7</volume>
        <fpage>40</fpage>
        <pub-id pub-id-type="doi">10.1186/s40168-019-0653-2</pub-id>
        <pub-id pub-id-type="pmid">30878035</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cormode</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Data sketching</article-title>
        <source>Commun ACM</source>
        <year>2017</year>
        <volume>60</volume>
        <fpage>48</fpage>
        <lpage>55</lpage>
        <pub-id pub-id-type="doi">10.1145/3080008</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cormode</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Garofalakis</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Haas</surname>
            <given-names>PJ</given-names>
          </name>
          <name>
            <surname>Jermaine</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Synopses for massive data: samples, histograms, wavelets, sketches</article-title>
        <source>Found Trends Databases</source>
        <year>2011</year>
        <volume>4</volume>
        <fpage>1</fpage>
        <lpage>294</lpage>
        <pub-id pub-id-type="doi">10.1561/1900000004</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Yang</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Rettig</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Cudre-Mauroux</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>HistoSketch: fast similarity-preserving sketching of streaming histograms with concept drift</article-title>
        <source>2017 IEEE International Conference on Data Mining (ICDM)</source>
        <year>2017</year>
        <publisher-loc>Piscataway</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>545</fpage>
        <lpage>554</lpage>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <mixed-citation publication-type="other">Rowe WPM. Genome sketching. Github. 2019. 10.5281/zenodo.2637740.</mixed-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Flajolet</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Nigel</surname>
            <given-names>MG</given-names>
          </name>
        </person-group>
        <article-title>Probabilistic counting algorithms for data base applications</article-title>
        <source>J Comput Syst Sci</source>
        <year>1985</year>
        <volume>31</volume>
        <fpage>182</fpage>
        <lpage>209</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-0000(85)90041-8</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Wei</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Luo</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Yi</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Du</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Wen</surname>
            <given-names>J-R</given-names>
          </name>
        </person-group>
        <article-title>Persistent data sketching</article-title>
        <source>Proceedings of the 2015 ACM SIGMOD international conference on Management of Data</source>
        <year>2015</year>
        <publisher-loc>Melbourne</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>795</fpage>
        <lpage>810</lpage>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gomaa</surname>
            <given-names>WH</given-names>
          </name>
          <name>
            <surname>Fahmy</surname>
            <given-names>AA</given-names>
          </name>
        </person-group>
        <article-title>A survey of text similarity approaches</article-title>
        <source>Int J Comput Appl</source>
        <year>2013</year>
        <volume>68</volume>
        <fpage>13</fpage>
        <lpage>18</lpage>
        <pub-id pub-id-type="doi">10.5120/11638-7118</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <mixed-citation publication-type="other">Broder AZ. On the resemblance and containment of documents. In: Proceedings. Compression and complexity of sequences 1997. Piscataway: IEEE. 10.1109/SEQUEN.1997.666900.</mixed-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Broder</surname>
            <given-names>AZ</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Sankoff</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Identifying and filtering near-duplicate documents</article-title>
        <source>Comb pattern matching</source>
        <year>2000</year>
        <publisher-loc>Berlin, Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>1</fpage>
        <lpage>10</lpage>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Bar-Yossef</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Jayram</surname>
            <given-names>TS</given-names>
          </name>
          <name>
            <surname>Kumar</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Sivakumar</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Trevisan</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Rolim</surname>
            <given-names>JDP</given-names>
          </name>
          <name>
            <surname>Vadhan</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Counting distinct elements in a data stream</article-title>
        <source>Randomization and approximation techniques in computer science</source>
        <year>2002</year>
        <publisher-loc>Berlin, Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>1</fpage>
        <lpage>10</lpage>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cohen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Size-estimation framework with applications to transitive closure and reachability</article-title>
        <source>J Comput Syst Sci</source>
        <year>1997</year>
        <volume>55</volume>
        <fpage>441</fpage>
        <lpage>453</lpage>
        <pub-id pub-id-type="doi">10.1006/jcss.1997.1534</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Cohen</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Kaplan</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Summarizing data using bottom-k sketches</article-title>
        <source>Proceedings of the twenty-sixth annual ACM symposium on principles of distributed computing</source>
        <year>2007</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>225</fpage>
        <lpage>234</lpage>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <mixed-citation publication-type="other">Yu YW, Weber GM. HyperMinHash: MinHash in LogLog space. ArXiv171008436 Cs. 2017. <ext-link ext-link-type="uri" xlink:href="http://arxiv.org/abs/1710.08436">http://arxiv.org/abs/1710.08436</ext-link>. Accessed 19 Aug 2019.</mixed-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Beyer</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Haas</surname>
            <given-names>PJ</given-names>
          </name>
          <name>
            <surname>Reinwald</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Sismanis</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Gemulla</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>On synopses for distinct-value estimation under multiset operations</article-title>
        <source>Proceedings of the 2007 ACM SIGMOD international conference on management of data</source>
        <year>2007</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>199</fpage>
        <lpage>210</lpage>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Owen</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Pereira</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Burges</surname>
            <given-names>CJC</given-names>
          </name>
          <name>
            <surname>Bottou</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Weinberger</surname>
            <given-names>KQ</given-names>
          </name>
        </person-group>
        <article-title>One permutation hashing</article-title>
        <source>Advances in neural information processing system 25</source>
        <year>2012</year>
        <publisher-loc>Red Hook</publisher-loc>
        <publisher-name>Curran Associates</publisher-name>
        <fpage>3113</fpage>
        <lpage>3121</lpage>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <mixed-citation publication-type="other">Rasheed Z, Rangwala H. MC-MinH: Metagenome Clustering using Minwise based Hashing. In: Proceedings of the 2013 SIAM International Conference on Data Mining: Society for Industrial and Applied Mathematics; 2013. p. 677–85. 10.1137/1.9781611972832.75. Accessed 19 August 2019.</mixed-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Berlin</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Chin</surname>
            <given-names>C-S</given-names>
          </name>
          <name>
            <surname>Drake</surname>
            <given-names>JP</given-names>
          </name>
          <name>
            <surname>Landolin</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <article-title>Assembling large genomes with single-molecule sequencing and locality-sensitive hashing</article-title>
        <source>Nat Biotechnol</source>
        <year>2015</year>
        <volume>33</volume>
        <fpage>623</fpage>
        <lpage>630</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.3238</pub-id>
        <pub-id pub-id-type="pmid">26006009</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <mixed-citation publication-type="other">Brown CT, Irber L. sourmash: a library for MinHash sketching of DNA. J Open Source Softw. 2016; <ext-link ext-link-type="uri" xlink:href="http://joss.theoj.org">http://joss.theoj.org</ext-link>. Accessed 19 Aug 2019.</mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <mixed-citation publication-type="other">Bovee R, Greenfield N. Finch: a tool adding dynamic abundance filtering to genomic MinHashing. J Open Source Softw. 2018; <ext-link ext-link-type="uri" xlink:href="http://joss.theoj.org">http://joss.theoj.org</ext-link>. Accessed 19 Aug 2019.</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <mixed-citation publication-type="other">Bushnell B. BBMap: A fast, accurate, splice-aware aligner. In: 9th Annual Genomics of Energy and Environment Meeting, Walnut Creek, CA, USA, 17–20 March 2014. <ext-link ext-link-type="uri" xlink:href="https://www.osti.gov/biblio/1241166-bbmap-fast-accurate-splice-aware-aligner">https://www.osti.gov/biblio/1241166-bbmap-fast-accurate-splice-aware-aligner</ext-link>. Accessed 19 Aug 2019.</mixed-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rowe</surname>
            <given-names>WPM</given-names>
          </name>
          <name>
            <surname>Winn</surname>
            <given-names>MD</given-names>
          </name>
        </person-group>
        <article-title>Indexed variation graphs for efficient and accurate resistome profiling</article-title>
        <source>Bioinformatics.</source>
        <year>2018</year>
        <volume>34</volume>
        <fpage>3601</fpage>
        <lpage>3608</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty387</pub-id>
        <pub-id pub-id-type="pmid">29762644</pub-id>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Katz</surname>
            <given-names>LS</given-names>
          </name>
          <name>
            <surname>Griswold</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Carleton</surname>
            <given-names>HA</given-names>
          </name>
        </person-group>
        <source>Generating WGS Trees with Mashtree</source>
        <year>2017</year>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Jain</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Dilthey</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Aluru</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Sahinalp</surname>
            <given-names>SC</given-names>
          </name>
        </person-group>
        <article-title>A fast approximate algorithm for mapping long reads to large reference databases</article-title>
        <source>Research in computational molecular biology</source>
        <year>2017</year>
        <publisher-loc>Berlin</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>66</fpage>
        <lpage>81</lpage>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>
        <source>Bioinformatics.</source>
        <year>2018</year>
        <volume>34</volume>
        <fpage>3094</fpage>
        <lpage>3100</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty191</pub-id>
        <pub-id pub-id-type="pmid">29750242</pub-id>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jackman</surname>
            <given-names>SD</given-names>
          </name>
          <name>
            <surname>Vandervalk</surname>
            <given-names>BP</given-names>
          </name>
          <name>
            <surname>Mohamadi</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Chu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Yeo</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Hammond</surname>
            <given-names>SA</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ABySS 2.0: resource-efficient assembly of large genomes using a Bloom filter</article-title>
        <source>Genome Res</source>
        <year>2017</year>
        <volume>27</volume>
        <fpage>768</fpage>
        <lpage>777</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.214346.116</pub-id>
        <pub-id pub-id-type="pmid">28232478</pub-id>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Song</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Florea</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Lighter: fast and memory-efficient sequencing error correction without counting</article-title>
        <source>Genome Biol</source>
        <year>2014</year>
        <volume>15</volume>
        <fpage>509</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-014-0509-9</pub-id>
        <pub-id pub-id-type="pmid">25398208</pub-id>
      </element-citation>
    </ref>
    <ref id="CR31">
      <label>31.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bradley</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>den Bakker</surname>
            <given-names>HC</given-names>
          </name>
          <name>
            <surname>Rocha</surname>
            <given-names>EPC</given-names>
          </name>
          <name>
            <surname>McVean</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Iqbal</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>Ultrafast search of all deposited bacterial and viral genomic data</article-title>
        <source>Nat Biotechnol</source>
        <year>2019</year>
        <volume>37</volume>
        <fpage>152</fpage>
        <pub-id pub-id-type="doi">10.1038/s41587-018-0010-1</pub-id>
        <pub-id pub-id-type="pmid">30718882</pub-id>
      </element-citation>
    </ref>
    <ref id="CR32">
      <label>32.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Crusoe</surname>
            <given-names>MR</given-names>
          </name>
          <name>
            <surname>Alameldin</surname>
            <given-names>HF</given-names>
          </name>
          <name>
            <surname>Awad</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Boucher</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Caldwell</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Cartwright</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The khmer software package: enabling efficient nucleotide sequence analysis</article-title>
        <source>F1000Res</source>
        <year>2015</year>
        <volume>4</volume>
        <fpage>900</fpage>
        <pub-id pub-id-type="doi">10.12688/f1000research.6924.1</pub-id>
        <pub-id pub-id-type="pmid">26535114</pub-id>
      </element-citation>
    </ref>
    <ref id="CR33">
      <label>33.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ghosh</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Kalyanaraman</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>FastEtch: a fast sketch-based assembler for genomes</article-title>
        <source>IEEE/ACM Trans Comput Biol Bioinform</source>
        <year>2019</year>
        <volume>16</volume>
        <fpage>1091</fpage>
        <lpage>1106</lpage>
        <?supplied-pmid 28910776?>
        <pub-id pub-id-type="pmid">28910776</pub-id>
      </element-citation>
    </ref>
    <ref id="CR34">
      <label>34.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Breitwieser</surname>
            <given-names>FP</given-names>
          </name>
          <name>
            <surname>Baker</surname>
            <given-names>DN</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>KrakenUniq: confident and fast metagenomics classification using unique k-mer counts</article-title>
        <source>Genome Biol</source>
        <year>2018</year>
        <volume>19</volume>
        <fpage>198</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-018-1568-0</pub-id>
        <pub-id pub-id-type="pmid">30445993</pub-id>
      </element-citation>
    </ref>
    <ref id="CR35">
      <label>35.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mohamadi</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Khan</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Birol</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <article-title>ntCard: a streaming algorithm for cardinality estimation in genomics data</article-title>
        <source>Bioinforma Oxf Engl</source>
        <year>2017</year>
        <volume>33</volume>
        <fpage>1324</fpage>
        <lpage>1330</lpage>
      </element-citation>
    </ref>
    <ref id="CR36">
      <label>36.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Medvedev</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Informed and automated k-mer size selection for genome assembly</article-title>
        <source>Bioinformatics.</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>31</fpage>
        <lpage>37</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btt310</pub-id>
        <pub-id pub-id-type="pmid">23732276</pub-id>
      </element-citation>
    </ref>
    <ref id="CR37">
      <label>37.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pandey</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Bender</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Patro</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Squeakr: an exact and approximate k-mer counting system</article-title>
        <source>Bioinformatics.</source>
        <year>2018</year>
        <volume>34</volume>
        <fpage>568</fpage>
        <lpage>575</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btx636</pub-id>
        <pub-id pub-id-type="pmid">29444235</pub-id>
      </element-citation>
    </ref>
    <ref id="CR38">
      <label>38.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pandey</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Almodaresi</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Bender</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Ferdman</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Patro</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Mantis: A fast, small, and exact large-scale sequence-search index</article-title>
        <source>Cell Syst</source>
        <year>2018</year>
        <volume>7</volume>
        <fpage>201</fpage>
        <lpage>207.e4</lpage>
        <pub-id pub-id-type="doi">10.1016/j.cels.2018.05.021</pub-id>
        <pub-id pub-id-type="pmid">29936185</pub-id>
      </element-citation>
    </ref>
    <ref id="CR39">
      <label>39.</label>
      <mixed-citation publication-type="other">Yi H, Lin Y, Jin W. Sequences dimensionality-reduction by k-mer substring space sampling enables effective resemblance- and containment-analysis for large-scale omics-data. bioRxiv. 2019:729665.</mixed-citation>
    </ref>
    <ref id="CR40">
      <label>40.</label>
      <mixed-citation publication-type="other">Rowe WPM. Genome sketching. 2019. <ext-link ext-link-type="uri" xlink:href="https://github.com/will-rowe/genome-sketching/blob/master/references.md">github.com/will-rowe/genome-sketching/blob/master/references.md</ext-link>. Accessed 19 Aug 2019.</mixed-citation>
    </ref>
    <ref id="CR41">
      <label>41.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jain</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Dilthey</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
          <name>
            <surname>Aluru</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>A fast adaptive algorithm for computing whole-genome homology maps</article-title>
        <source>Bioinformatics.</source>
        <year>2018</year>
        <volume>34</volume>
        <fpage>i748</fpage>
        <lpage>i756</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty597</pub-id>
        <pub-id pub-id-type="pmid">30423094</pub-id>
      </element-citation>
    </ref>
    <ref id="CR42">
      <label>42.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roberts</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hayes</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Hunt</surname>
            <given-names>BR</given-names>
          </name>
          <name>
            <surname>Mount</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Yorke</surname>
            <given-names>JA</given-names>
          </name>
        </person-group>
        <article-title>Reducing storage requirements for biological sequence comparison</article-title>
        <source>Bioinformatics.</source>
        <year>2004</year>
        <volume>20</volume>
        <fpage>3363</fpage>
        <lpage>3369</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bth408</pub-id>
        <pub-id pub-id-type="pmid">15256412</pub-id>
      </element-citation>
    </ref>
    <ref id="CR43">
      <label>43.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Minimap and miniasm: fast mapping and de novo assembly for noisy long sequences</article-title>
        <source>Bioinformatics.</source>
        <year>2016</year>
        <volume>32</volume>
        <fpage>2103</fpage>
        <lpage>2110</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btw152</pub-id>
        <pub-id pub-id-type="pmid">27153593</pub-id>
      </element-citation>
    </ref>
    <ref id="CR44">
      <label>44.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Koslicki</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Zabeti</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Improving MinHash via the containment index with applications to metagenomic analysis</article-title>
        <source>Appl Math Comput</source>
        <year>2019</year>
        <volume>354</volume>
        <fpage>206</fpage>
        <lpage>215</lpage>
      </element-citation>
    </ref>
    <ref id="CR45">
      <label>45.</label>
      <mixed-citation publication-type="other">Ondov BD, Starrett GJ, Sappington A, Kostic A, Koren S, Buck CB, et al. Mash Screen: high-throughput sequence containment estimation for genome discovery. bioRxiv. 2019:557314.</mixed-citation>
    </ref>
    <ref id="CR46">
      <label>46.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhao</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>BinDash, software for fast genome distance estimation on a typical personal laptop</article-title>
        <source>Bioinformatics.</source>
        <year>2018</year>
        <volume>35</volume>
        <fpage>671</fpage>
        <lpage>673</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty651</pub-id>
      </element-citation>
    </ref>
    <ref id="CR47">
      <label>47.</label>
      <mixed-citation publication-type="other">Marcais G, DeBlasio D, Pandey P, Kingsford C. Locality sensitive hashing for the edit distance. bioRxiv. 2019:534446.</mixed-citation>
    </ref>
    <ref id="CR48">
      <label>48.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>König</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <source>b-Bit minwise hashing. In: Proceedings of the 19th international conference on world wide web</source>
        <year>2010</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>671</fpage>
        <lpage>680</lpage>
      </element-citation>
    </ref>
    <ref id="CR49">
      <label>49.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bloom</surname>
            <given-names>BH</given-names>
          </name>
        </person-group>
        <article-title>Space/time trade-offs in hash coding with allowable errors</article-title>
        <source>Commun ACM</source>
        <year>1970</year>
        <volume>13</volume>
        <fpage>422</fpage>
        <lpage>426</lpage>
        <pub-id pub-id-type="doi">10.1145/362686.362692</pub-id>
      </element-citation>
    </ref>
    <ref id="CR50">
      <label>50.</label>
      <mixed-citation publication-type="other">Kirsch A, Mitzenmacher M. Less hashing, same performance: building a better bloom filter. In: ESA 2006, Proceedings of the 14th Annual European Symposium, Zurich, Switzerland, 11–13 September 2006. p. 456–67.</mixed-citation>
    </ref>
    <ref id="CR51">
      <label>51.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Melsted</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Pritchard</surname>
            <given-names>JK</given-names>
          </name>
        </person-group>
        <article-title>Efficient counting of k-mers in DNA sequences using a bloom filter</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>333</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-12-333</pub-id>
        <pub-id pub-id-type="pmid">21831268</pub-id>
      </element-citation>
    </ref>
    <ref id="CR52">
      <label>52.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Fish</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Gilman</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Sun</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Brown</surname>
            <given-names>CT</given-names>
          </name>
          <name>
            <surname>Tiedje</surname>
            <given-names>JM</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Xander: employing a novel method for efficient gene-targeted metagenomic assembly</article-title>
        <source>Microbiome.</source>
        <year>2015</year>
        <volume>3</volume>
        <fpage>32</fpage>
        <pub-id pub-id-type="doi">10.1186/s40168-015-0093-6</pub-id>
        <pub-id pub-id-type="pmid">26246894</pub-id>
      </element-citation>
    </ref>
    <ref id="CR53">
      <label>53.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kuśmirek</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Nowak</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>De novo assembly of bacterial genomes with repetitive DNA regions by dnaasm application</article-title>
        <source>BMC Bioinformatics.</source>
        <year>2018</year>
        <volume>19</volume>
        <fpage>273</fpage>
        <pub-id pub-id-type="doi">10.1186/s12859-018-2281-4</pub-id>
        <pub-id pub-id-type="pmid">30021513</pub-id>
      </element-citation>
    </ref>
    <ref id="CR54">
      <label>54.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Rizk</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Space-efficient and exact de Bruijn graph representation based on a Bloom filter</article-title>
        <source>Algorithms Mol Biol</source>
        <year>2013</year>
        <volume>8</volume>
        <fpage>22</fpage>
        <pub-id pub-id-type="doi">10.1186/1748-7188-8-22</pub-id>
        <pub-id pub-id-type="pmid">24040893</pub-id>
      </element-citation>
    </ref>
    <ref id="CR55">
      <label>55.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jones</surname>
            <given-names>DC</given-names>
          </name>
          <name>
            <surname>Ruzzo</surname>
            <given-names>WL</given-names>
          </name>
          <name>
            <surname>Peng</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Katze</surname>
            <given-names>MG</given-names>
          </name>
        </person-group>
        <article-title>Compression of next-generation sequencing reads aided by highly efficient de novo assembly</article-title>
        <source>Nucleic Acids Res</source>
        <year>2012</year>
        <volume>40</volume>
        <fpage>e171</fpage>
        <pub-id pub-id-type="doi">10.1093/nar/gks754</pub-id>
        <pub-id pub-id-type="pmid">22904078</pub-id>
      </element-citation>
    </ref>
    <ref id="CR56">
      <label>56.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Schröder</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Musket: a multistage k-mer spectrum-based error corrector for Illumina sequence data</article-title>
        <source>Bioinformatics.</source>
        <year>2013</year>
        <volume>29</volume>
        <fpage>308</fpage>
        <lpage>315</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts690</pub-id>
        <pub-id pub-id-type="pmid">23202746</pub-id>
      </element-citation>
    </ref>
    <ref id="CR57">
      <label>57.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Heo</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>X-L</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Ma</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Hwu</surname>
            <given-names>W-M</given-names>
          </name>
        </person-group>
        <article-title>BLESS: Bloom filter-based error correction solution for high-throughput sequencing reads</article-title>
        <source>Bioinformatics.</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>1354</fpage>
        <lpage>1362</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu030</pub-id>
        <pub-id pub-id-type="pmid">24451628</pub-id>
      </element-citation>
    </ref>
    <ref id="CR58">
      <label>58.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Fan</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Cao</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Almeida</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Broder</surname>
            <given-names>AZ</given-names>
          </name>
        </person-group>
        <article-title>Summary cache: a scalable wide-area web cache sharing protocol</article-title>
        <source>IEEE/ACM Trans Netw</source>
        <year>2000</year>
        <volume>8</volume>
        <fpage>281</fpage>
        <lpage>293</lpage>
        <pub-id pub-id-type="doi">10.1109/90.851975</pub-id>
      </element-citation>
    </ref>
    <ref id="CR59">
      <label>59.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Fan</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Andersen</surname>
            <given-names>DG</given-names>
          </name>
          <name>
            <surname>Kaminsky</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Mitzenmacher</surname>
            <given-names>MD</given-names>
          </name>
        </person-group>
        <article-title>Cuckoo filter: practically better than Bloom</article-title>
        <source>Proceedings of the 10th ACM international on conference on emerging networking experiments and technologies</source>
        <year>2014</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>75</fpage>
        <lpage>88</lpage>
      </element-citation>
    </ref>
    <ref id="CR60">
      <label>60.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Pandey</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Bender</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Patro</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>A general-purpose counting filter: making every bit count</article-title>
        <source>Proceedings of the 2017 ACM international conference on Management of Data</source>
        <year>2017</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>775</fpage>
        <lpage>787</lpage>
      </element-citation>
    </ref>
    <ref id="CR61">
      <label>61.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Solomon</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Kingsford</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Fast search of thousands of short-read sequencing experiments</article-title>
        <source>Nat Biotechnol</source>
        <year>2016</year>
        <volume>34</volume>
        <fpage>300</fpage>
        <lpage>302</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.3442</pub-id>
        <pub-id pub-id-type="pmid">26854477</pub-id>
      </element-citation>
    </ref>
    <ref id="CR62">
      <label>62.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cormode</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Muthukrishnan</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>An improved data stream summary: the count-min sketch and its applications</article-title>
        <source>J Algorithms</source>
        <year>2005</year>
        <volume>55</volume>
        <fpage>58</fpage>
        <lpage>75</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jalgor.2003.12.001</pub-id>
      </element-citation>
    </ref>
    <ref id="CR63">
      <label>63.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Cai</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Mitzenmacher</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Adams</surname>
            <given-names>RP</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Bengio</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Wallach</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Larochelle</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Grauman</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Cesa-Bianchi</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Garnett</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>A Bayesian nonparametric view on count-min sketch</article-title>
        <source>Advances in neural information processing systems 31</source>
        <year>2018</year>
        <publisher-loc>Red Hook</publisher-loc>
        <publisher-name>Curran Associates</publisher-name>
        <fpage>8768</fpage>
        <lpage>8777</lpage>
      </element-citation>
    </ref>
    <ref id="CR64">
      <label>64.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Eydi</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Medjedovic</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Mekic</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Selmanovic</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Hadžikadić</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Avdaković</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Buffered count-min sketch</article-title>
        <source>Advanced technologies, systems, and applications II</source>
        <year>2018</year>
        <publisher-loc>Berlin</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>249</fpage>
        <lpage>255</lpage>
      </element-citation>
    </ref>
    <ref id="CR65">
      <label>65.</label>
      <mixed-citation publication-type="other">Flajolet P, Fusy É, Gandouet O, et al. Hyperloglog: The analysis of a near-optimal cardinality estimation algorithm. In: AofA '07: Proceedings of the 2007 International Conference on Analysis of Algorithms, Juan des Pins, France, 17–22 June 2007.</mixed-citation>
    </ref>
    <ref id="CR66">
      <label>66.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Georganas</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Buluç</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Chapman</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Oliker</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Rokhsar</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Yelick</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Parallel De Bruijn graph construction and traversal for de novo genome assembly</article-title>
        <source>Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis, 16–21 November 2014</source>
        <year>2014</year>
        <publisher-loc>Piscataway</publisher-loc>
        <publisher-name>IEEE Press</publisher-name>
        <fpage>437</fpage>
        <lpage>448</lpage>
      </element-citation>
    </ref>
    <ref id="CR67">
      <label>67.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Heule</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Nunkesser</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hall</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>HyperLogLog in practice: algorithmic engineering of a state of the art cardinality estimation algorithm</article-title>
        <source>Proceedings of the 16th international conference on extending database technology, Genoa, Italy, 18–22 march 2013</source>
        <year>2013</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>ACM Press</publisher-name>
        <fpage>683</fpage>
        <lpage>692</lpage>
      </element-citation>
    </ref>
    <ref id="CR68">
      <label>68.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Chabchoub</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Hebrail</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Sliding HyperLogLog: estimating cardinality in a data stream over a sliding window</article-title>
        <source>2010 IEEE International Conference on Data Mining Worshop</source>
        <year>2010</year>
        <publisher-loc>Piscataway</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>1297</fpage>
        <lpage>1303</lpage>
      </element-citation>
    </ref>
    <ref id="CR69">
      <label>69.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pandey</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Bender</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Patro</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>deBGR: an efficient and near-exact representation of the weighted de Bruijn graph</article-title>
        <source>Bioinformatics</source>
        <year>2017</year>
        <volume>33</volume>
        <fpage>i133</fpage>
        <lpage>i141</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btx261</pub-id>
        <pub-id pub-id-type="pmid">28881995</pub-id>
      </element-citation>
    </ref>
    <ref id="CR70">
      <label>70.</label>
      <mixed-citation publication-type="other">Bussonnier M, Freeman J, Granger B, Head T, Holdgraf C, Kelley K, et al. Binder 2.0 – Reproducible, interactive, sharable environments for science at scale. In: Proceedings of the Python in Science Conference, Austin, Texas, 9–15 July 2018. p. 113–20.</mixed-citation>
    </ref>
    <ref id="CR71">
      <label>71.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Reuter</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ellington</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Cartwright</surname>
            <given-names>EJP</given-names>
          </name>
          <name>
            <surname>Köser</surname>
            <given-names>CU</given-names>
          </name>
          <name>
            <surname>Török</surname>
            <given-names>ME</given-names>
          </name>
          <name>
            <surname>Gouliouris</surname>
            <given-names>T</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Rapid bacterial whole-genome sequencing to enhance diagnostic and public health microbiology</article-title>
        <source>JAMA Intern Med</source>
        <year>2013</year>
        <volume>173</volume>
        <fpage>1397</fpage>
        <lpage>1404</lpage>
        <pub-id pub-id-type="doi">10.1001/jamainternmed.2013.7734</pub-id>
        <pub-id pub-id-type="pmid">23857503</pub-id>
      </element-citation>
    </ref>
    <ref id="CR72">
      <label>72.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Popic</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Batzoglou</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>A hybrid cloud read aligner based on MinHash and kmer voting that preserves privacy</article-title>
        <source>Nat Commun</source>
        <year>2017</year>
        <volume>8</volume>
        <fpage>15311</fpage>
        <pub-id pub-id-type="doi">10.1038/ncomms15311</pub-id>
        <pub-id pub-id-type="pmid">28508884</pub-id>
      </element-citation>
    </ref>
    <ref id="CR73">
      <label>73.</label>
      <mixed-citation publication-type="other">Carrieri AP, Rowe WPM, Winn MD, Pyzer-Knapp EO. A fast machine learning workflow for rapid phenotype prediction from whole shotgun metagenomes. Innov Appl Artif Intell. (in press).</mixed-citation>
    </ref>
    <ref id="CR74">
      <label>74.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Marçais</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Solomon</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Patro</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Kingsford</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Sketching and sublinear data structures in genomics</article-title>
        <source>Annu Rev Biomed Data Sci</source>
        <year>2019</year>
        <volume>2</volume>
        <fpage>93</fpage>
        <lpage>118</lpage>
        <pub-id pub-id-type="doi">10.1146/annurev-biodatasci-072018-021156</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
