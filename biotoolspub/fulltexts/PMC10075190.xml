<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10075190</article-id>
    <article-id pub-id-type="pmid">36752504</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad084</article-id>
    <article-id pub-id-type="publisher-id">btad084</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Phylogenetics</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>DaTeR: error-correcting phylogenetic chronograms using relative time constraints</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Mondal</surname>
          <given-names>Abhijit</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, University of Connecticut</institution>, Storrs, CT 06269, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Rangel</surname>
          <given-names>L Thiberio</given-names>
        </name>
        <aff><institution>Department of Earth, Atmospheric and Planetary Sciences, Massachusetts Institute of Technology</institution>, Cambridge, MA 02139, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Payette</surname>
          <given-names>Jack G</given-names>
        </name>
        <aff><institution>Department of Earth, Atmospheric and Planetary Sciences, Massachusetts Institute of Technology</institution>, Cambridge, MA 02139, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Fournier</surname>
          <given-names>Gregory P</given-names>
        </name>
        <aff><institution>Department of Earth, Atmospheric and Planetary Sciences, Massachusetts Institute of Technology</institution>, Cambridge, MA 02139, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-0039-2596</contrib-id>
        <name>
          <surname>Bansal</surname>
          <given-names>Mukul S</given-names>
        </name>
        <aff><institution>Department of Computer Science and Engineering, University of Connecticut</institution>, Storrs, CT 06269, <country country="US">USA</country></aff>
        <aff><institution>Institute for Systems Genomics, University of Connecticut</institution>, Storrs, CT 06269, <country country="US">USA</country></aff>
        <xref rid="btad084-cor1" ref-type="corresp"/>
        <!--mukul.bansal@uconn.edu-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Schwartz</surname>
          <given-names>Russell</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad084-cor1">To whom correspondence should be addressed. <email>mukul.bansal@uconn.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-02-08">
      <day>08</day>
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>08</day>
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>2</issue>
    <elocation-id>btad084</elocation-id>
    <history>
      <date date-type="received">
        <day>16</day>
        <month>7</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>07</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>05</day>
        <month>2</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>07</day>
        <month>2</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>22</day>
        <month>2</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad084.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>A <italic toggle="yes">chronogram</italic> is a dated phylogenetic tree whose branch lengths have been scaled to represent time. Such chronograms are computed based on available date estimates (e.g. from dated fossils), which provide absolute time constraints for one or more nodes of an input undated phylogeny, coupled with an appropriate underlying model for evolutionary rates variation along the branches of the phylogeny. However, traditional methods for phylogenetic dating cannot take into account <italic toggle="yes">relative</italic> time constraints, such as those provided by inferred horizontal transfer events. In many cases, chronograms computed using only absolute time constraints are inconsistent with known relative time constraints.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this work, we introduce a new approach, Dating Trees using Relative constraints (<italic toggle="yes">DaTeR</italic>), for phylogenetic dating that can take into account both absolute and relative time constraints. The key idea is to use existing Bayesian approaches for phylogenetic dating to sample posterior chronograms satisfying desired absolute time constraints, minimally adjust or ‘error-correct’ these sampled chronograms to satisfy all given relative time constraints, and aggregate across all error-corrected chronograms. DaTeR uses a constrained optimization framework for the error-correction step, finding minimal deviations from previously assigned dates or branch lengths. We applied DaTeR to a biological dataset of 170 Cyanobacterial taxa and a reliable set of 24 transfer-based relative constraints, under six different molecular dating models. Our extensive analysis of this dataset demonstrates that DaTeR is both highly effective and scalable and that its application can significantly improve estimated chronograms.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>Freely available from <ext-link xlink:href="https://compbio.engr.uconn.edu/software/dater/" ext-link-type="uri">https://compbio.engr.uconn.edu/software/dater/</ext-link></p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <label>1</label>
    <title>Introduction</title>
    <p>The inference of dated phylogenies, also referred to as <italic toggle="yes">time trees</italic> or <italic toggle="yes">chronograms</italic>, is an important problem with many applications in evolutionary biology. Given an undated phylogenetic tree, with branch lengths expressed in terms of the average number of substitutions per site, along with estimated dates for a subset of nodes on the phylogeny, the phylogenetic dating problem seeks to assign a date to each node on the phylogeny representing the ‘best estimate’ dating for the species divergence represented by that node. Existing methods for phylogenetic dating are based on the idea of a ‘molecular clock’. Specifically, phylogenetic dating methods make use of available date estimates (e.g. from dated fossils), which provide time calibrations for one or more nodes of an input undated phylogeny, and combine these known calibrations with an underlying model for evolutionary rates variation along the branches of the phylogeny to estimate a date for every internal node of the phylogeny.</p>
    <p>The first methods for phylogenetic dating were based on the idea of a ‘strict’ molecular clock, implying a uniform rate of evolution along different lineages (<xref rid="btad084-B9" ref-type="bibr">Langley and Fitch, 1974</xref>; <xref rid="btad084-B28" ref-type="bibr">Zuckerkandl and Pauling, 1962</xref>). However, researchers soon observed that different lineages in a species phylogeny can evolve at different rates and more complex methods based on ‘relaxed’ or ‘local’ molecular clock models were introduced to address this gap (<xref rid="btad084-B3" ref-type="bibr">Dos Reis <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btad084-B4" ref-type="bibr">Drummond <italic toggle="yes">et al.</italic>, 2006</xref>; <xref rid="btad084-B14" ref-type="bibr">Rambaut and Bromham, 1998</xref>; <xref rid="btad084-B16" ref-type="bibr">Renner <italic toggle="yes">et al.</italic>, 2008</xref>; <xref rid="btad084-B17" ref-type="bibr">Sanderson, 2002</xref>; <xref rid="btad084-B19" ref-type="bibr">Tamura <italic toggle="yes">et al.</italic>, 2012</xref>; <xref rid="btad084-B20" ref-type="bibr">Thorne <italic toggle="yes">et al.</italic>, 1998</xref>; <xref rid="btad084-B24" ref-type="bibr">Volz and Frost, 2017</xref>; <xref rid="btad084-B26" ref-type="bibr">Yang and Rannala, 2006</xref>; <xref rid="btad084-B27" ref-type="bibr">Yoder and Yang, 2000</xref>). Among all existing methods for phylogenetic dating, Bayesian approaches are generally believed to be the most accurate (<xref rid="btad084-B1" ref-type="bibr">Bouckaert <italic toggle="yes">et al.</italic>, 2014</xref>; <xref rid="btad084-B3" ref-type="bibr">Dos Reis <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btad084-B4" ref-type="bibr">Drummond <italic toggle="yes">et al.</italic>, 2006</xref>; <xref rid="btad084-B10" ref-type="bibr">Lartillot and Philippe, 2004</xref>; <xref rid="btad084-B26" ref-type="bibr">Yang and Rannala, 2006</xref>). Such Bayesian approaches are widely used due to their ability to implement more complex evolutionary models and account for inference uncertainty by sampling from the posterior. Recently, approaches based on an error-correction approach, rather than on an explicit relaxed molecular clock model, have also been proposed (<xref rid="btad084-B13" ref-type="bibr">Mai and Mirarab, 2020</xref>; <xref rid="btad084-B21" ref-type="bibr">To <italic toggle="yes">et al.</italic>, 2016</xref>). Such approaches aim to compute minimum deviations from the strict molecular clock model along tree edges to infer a chronogram satisfying given time calibrations.</p>
    <p>A key limitation of all of these phylogenetic dating methods is that they can only take <italic toggle="yes">absolute</italic> time calibrations into consideration. An absolute time calibration is one that constrains the date of a particular node of the phylogeny, generally based on the fossil record. Such constraints typically take the form of lower and/or upper bounds on the dating for one or more of the nodes in the phylogeny; for example, an absolute time calibration might be that a particular internal node <italic toggle="yes">x</italic> should be dated to between 100 and 120 million years ago (mya). Thus, these methods cannot take into account <italic toggle="yes">relative</italic> time calibrations that impose relative temporal orderings on two or more nodes of the phylogeny; for example, a relative time calibration might be that a node <italic toggle="yes">x</italic> must be dated to be older than a node <italic toggle="yes">y</italic> (where <italic toggle="yes">x</italic> is not an ancestor of <italic toggle="yes">y</italic>). However, using relative time calibrations is important when dating microbial phylogenies. This is primarily due to two reasons: First, microbial fossil data are extremely rare, making it difficult to use only absolute time calibrations to reliably date microbial phylogenies. Second, widespread horizontal gene transfer (HGT or transfer for short) between microbes makes it possible to obtain reliable relative time calibrations in many cases (e.g. <xref rid="btad084-B2" ref-type="bibr">Davín <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btad084-B6" ref-type="bibr">Gogarten <italic toggle="yes">et al.</italic>, 1999</xref>; <xref rid="btad084-B12" ref-type="bibr">Magnabosco <italic toggle="yes">et al.</italic>, 2018</xref>). Specifically, a transfer from edge (<italic toggle="yes">a</italic>, <italic toggle="yes">b</italic>) to edge (<italic toggle="yes">c</italic>, <italic toggle="yes">d</italic>) in the phylogeny, where <italic toggle="yes">a</italic> is the parent of <italic toggle="yes">b</italic> and <italic toggle="yes">c</italic> is the parent of <italic toggle="yes">d</italic>, can only occur if <italic toggle="yes">a</italic> is older than <italic toggle="yes">d</italic>. This is illustrated in <xref rid="btad084-F1" ref-type="fig">Figure 1</xref>.</p>
    <fig position="float" id="btad084-F1">
      <label>Fig. 1.</label>
      <caption>
        <p>Chronograms and relative time calibrations. The figure shows two distinct chronograms for the same underlying phylogenetic tree. Each chronogram is dated backward in time, with the six leaves (tips) representing contemporary nodes. Dates assigned to internal nodes are shown italicized within parentheses and are in units of ‘mya’. Implied branch lengths are shown italicized in blue along edges. The dotted red line in each chronogram represents a known HGT event from the edge (<italic toggle="yes">y</italic>, <italic toggle="yes">z</italic>) to the edge (<italic toggle="yes">v</italic>, <italic toggle="yes">w</italic>). This horizontal transfer provides a relative time calibration, implying that node <italic toggle="yes">y</italic> must be older than node <italic toggle="yes">w</italic>. The chronogram on the left is not consistent with this relative time calibration while the chronogram on the right is</p>
      </caption>
      <graphic xlink:href="btad084f1" position="float"/>
    </fig>
    <p>Related previous work. It has been observed that chronograms constructed using only absolute time calibrations often violate known (high-confidence/hand-curated) relative time calibrations. This has motivated the development of some recent approaches (<xref rid="btad084-B2" ref-type="bibr">Davín <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic>, 2021</xref>; <xref rid="btad084-B7" ref-type="bibr">Gruen <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btad084-B12" ref-type="bibr">Magnabosco <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btad084-B25" ref-type="bibr">Wolfe and Fournier, 2018</xref>) for using transfer-based relative time calibrations to improve phylogenetic dating. <xref rid="btad084-B2" ref-type="bibr">Davín <italic toggle="yes">et al.</italic> (2018)</xref> explored the potential of using large numbers of computationally inferred transfer events to relatively order all nodes of a phylogeny by time and found that relative orderings computed this way were largely consistent with estimates from relaxed molecular clock models. <xref rid="btad084-B7" ref-type="bibr">Gruen <italic toggle="yes">et al.</italic> (2019)</xref> and <xref rid="btad084-B25" ref-type="bibr">Wolfe and Fournier (2018)</xref> demonstrated an alternative approach, directly calibrating gene trees in the presence of HGT, so that fossils from distantly related groups were able to place active constraints on HGT donor and recipient lineages. However, due to a dependence upon calibrations being available for groups directly involved in HGT, and the limited sequence information for dating within individual gene trees, this approach is likely only useful for dating a small subset of microbial groups. More recently, <xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic> (2021)</xref> developed a distinct relative dating approach, first applying standard Bayesian molecular clock analysis based on appropriate absolute calibrations, and then incorporating knowledge of relative calibrations by only sampling those chronograms from the posterior that satisfy all or most of the relative calibrations. However, with such a Bayesian rejection-sampling approach, it is possible that none of the sampled chronograms are compatible with all (or even most) of the relative calibrations. Therefore, this approach is only useful when the posterior space explored includes a robust sampling of HGT-consistent chronogram solutions, which may not be the case if some lineages are evolving at widely differing rates, unconstrained by local fossil calibrations. Finally, in recently published independent work, <xref rid="btad084-B18" ref-type="bibr">Szollosi <italic toggle="yes">et al.</italic> (2022)</xref> introduced a Bayesian approach that combines absolute and relative time calibrations into a single phylogenetic dating framework, allowing for the sampling of chronograms satisfying both absolute and relative time calibrations. While the work of <xref rid="btad084-B18" ref-type="bibr">Szollosi <italic toggle="yes">et al.</italic> (2022)</xref> has the same overarching goal as our proposed approach, the two approaches are methodologically distinct. We discuss the implications of these methodological differences in detail in Section 5.</p>
    <p>Our contribution. We propose a novel approach, called DaTeR (short for Dating Trees using Relative constraints), for dating microbial species trees that address the limitations of existing approaches. In a sense, DaTeR is inspired by the Bayesian rejection-sampling idea of <xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic> (2021)</xref>: instead of rejecting sampled chronograms that are incompatible with the given relative calibrations, DaTeR minimally ‘error-corrects’ each sample to ensure compatibility with all relative time calibrations. Specifically, we use a constrained optimization framework where we compute a minimal deviation from assigned node dates or branch lengths (representing time), under several appropriately designed objective functions, for the posterior chronogram sample such that all relative constraints are satisfied. We propose three different objective functions to appropriately measure deviation from an input chronogram: the first minimizes the weighted sum of squared differences between corresponding branch lengths in the input and error-corrected chronograms, the second minimizes the weighted sum of squared log ratios of the corresponding branch lengths and the third minimizes the weighted sum of squared differences between corresponding internal node dates. We evaluated our approach on a real biological dataset of 170 microbial species (mainly Cyanobacteria) and a reliable set of 24 transfer-based relative time calibrations used in a previous study (<xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic>, 2021</xref>), under six different molecular dating models. Among other findings, we observed that (i) chronograms constructed without considering relative time calibrations often violate several relative constraints, (ii) DaTeR is able to satisfy all relative constraints by making minor adjustments to the input chronograms, (iii) the different objective functions implemented in DaTeR can help fine-tune DaTeR to the characteristics of the dataset being analyzed, (iv) DaTeR can be used to help select the most appropriate molecular dating model to use to compute the most accurate initial posterior chronogram estimates, (v) DaTeR substantially improves upon the Bayesian rejection-sampling approach and (vi) DaTeR is highly scalable, requiring less than second on each input chronogram sample under two of the three objective functions. Overall, our results demonstrate that DaTeR is effective and scalable and that its application can have a significant impact on inferred dates.</p>
    <p>The remainder of this article is organized as follows: basic definitions and preliminaries appear in Section 2, DaTeR is described in Section 3, experimental results are shown in Section 4 and concluding remarks appear in Section 5.</p>
  </sec>
  <sec>
    <label>2</label>
    <title>Definitions and preliminaries</title>
    <p>A <italic toggle="yes">chronogram</italic> is a rooted binary tree in which each node of the tree has an assigned date. (Equivalently, a chronogram may be viewed as a rooted binary tree in which branch lengths represent time units. These branch lengths immediately imply a date for each internal node of the tree.) We assume that nodes are dated backward in time from the leaves (i.e. tips, representing terminal taxa) of the tree to the root. Such dates are often expressed in units of ‘mya’ and represent either known sampling times or estimated divergence times. In most cases, the leaves of the tree represent contemporary species and are assigned a date of 0. An illustration appears in <xref rid="btad084-F1" ref-type="fig">Figure 1</xref>.</p>
    <p>Given a chronogram <italic toggle="yes">T</italic> on <italic toggle="yes">n</italic> leaves, we label the internal nodes of <italic toggle="yes">T</italic>, starting from the root, as <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> and then label the leaves as <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>. The date of node <italic toggle="yes">i</italic>, where <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, is then denoted by <italic toggle="yes">t<sub>i</sub></italic>. We use <italic toggle="yes">p</italic>(<italic toggle="yes">i</italic>) to denote the parent node of <italic toggle="yes">i</italic> in <italic toggle="yes">T</italic>. We can also assign a branch length to each edge of <italic toggle="yes">T</italic> representing the time span between its two end points: For any <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> (i.e. for any non-root node <italic toggle="yes">i</italic>), we denote the branch length of edge <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by <italic toggle="yes">b<sub>i</sub></italic> where <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    <p>Constraints on chronograms. The following three types of constraints can be imposed on dates assigned to nodes in a chronogram.
</p>
    <list list-type="order">
      <list-item>
        <p>Topological temporal constraints. These constraints require that the parent of a node <italic toggle="yes">i</italic> must be dated to be at least as old as the node <italic toggle="yes">i</italic> itself, that is, <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Any valid chronogram must, at a minimum, satisfy all such constraints.</p>
      </list-item>
      <list-item>
        <p>Absolute time constraints. This type of constraint is generally obtained from fossil data and imposes an upper and/or lower bound on the date assigned to a specific node in the chronogram. Such constraints may be available for one or more of the nodes in the phylogeny and, if imposed, the corresponding chronogram is required to satisfy all such constraints.</p>
      </list-item>
      <list-item>
        <p>Relative time constraints. This type of constraint imposes a relative temporal ordering between two nodes not directly related by an ancestor–descendant relationship. For example, such a constraint may require that a node <italic toggle="yes">i</italic> be dated to be at least as old as another node <italic toggle="yes">j</italic>, even though <italic toggle="yes">i</italic> is not an ancestor of <italic toggle="yes">j</italic> in the phylogeny. Such constraints are generally based on known or inferred HGT events and several such constraints, each constraining the relative dating of two nodes, may be available for the phylogeny being dated. <xref rid="btad084-F1" ref-type="fig">Figure 1</xref> depicts an example of a relative constraint.</p>
      </list-item>
    </list>
    <p>Dating using both absolute and relative time constraints. Recall that traditional methods for phylogenetic dating are unable to use relative time constraints and that recently proposed approaches for incorporating information from relative time constraints into phylogenetic dating have some fundamental limitations. Our new approach, DaTeR, addresses these limitations and allows for the use of both absolute and relative time constraints for improved phylogenetic dating.</p>
    <p>DaTeR uses a two-step approach that first leverages existing methods for phylogenetic dating using absolute time constraints to construct an initial sample of chronograms and then minimally error-corrects those chronograms to make them compatible with all given relative time constraints. Such a two-step approach has the advantage that it can leverage any current or future framework for dating with absolute time constraints, allowing for the use of the most appropriate and/or most sophisticated dating models for constructing the initial chronogram estimates. The error-correction-based framework of DaTeR is inspired by recently developed approaches for phylogenetic dating that view the problem as one of error-correcting the branch lengths to make the inferred chronogram compatible with all given absolute time constraints (<xref rid="btad084-B13" ref-type="bibr">Mai and Mirarab, 2020</xref>; <xref rid="btad084-B21" ref-type="bibr">To <italic toggle="yes">et al.</italic>, 2016</xref>). In DaTeR, we apply error-correction in the context of relative time constraints rather than absolute time constraints.</p>
  </sec>
  <sec>
    <label>3</label>
    <title>Methodological details</title>
    <sec>
      <label>3.1</label>
      <title>Overview of DaTeR</title>
      <p>DaTeR takes as input a collection of chronograms sampled from the posterior using any standard Bayesian phylogenetic dating approach under a suitable evolutionary model calibrated using suitable absolute time constraints. Thus, these sampled chronograms represent best estimates based on using only absolute time constraints. (We point out that an absolute constraint need not always take the form of a strict lower and/or upper bound and can instead take the form of some probability distribution on node dates. Any such existing model of time calibration using absolute constraints can be used when computing input chronogram samples.) In addition to these sampled chronograms, DaTeR also takes as input a set of relative time constraints. We use <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to denote the <italic toggle="yes">m</italic> input chronograms and <italic toggle="yes">R</italic> to denote the set of relative time constraints. DaTeR then minimally error-corrects each input chronogram to make it compatible with all given relative temporal constraints. DaTeR implements three different <italic toggle="yes">objective functions</italic> to define and compute ‘minimally’ error-corrected chronograms: the first minimizes the sum of deviations of internal node dates between the input and error-corrected dating, the second minimizes the sum of squared deviations of branch lengths and the third minimizes the sum of squared log ratios of branch lengths. Once all input chronograms have been error-corrected under the chosen objective function, a single representative chronogram is computed by aggregating across all error-corrected chronograms.<boxed-text id="btad084-BOX1" position="float"><label>Algorithm.</label><caption><p>DaTeR (<inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula>)</p></caption><p>1: Verify that all relative constraints in <italic toggle="yes">R</italic> are temporally consistent.</p><p>2: Let <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mi mathvariant="script" class="calligraphy">O</mml:mi></mml:math></inline-formula> denote the objective function to be used.</p><p>3: <bold>for</bold> each <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><bold>do</bold></p><p>4:  Let <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the chronogram obtained by minimally error-correcting <italic toggle="yes">T<sub>k</sub></italic> with respect to objective function <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mi mathvariant="script" class="calligraphy">O</mml:mi></mml:math></inline-formula> such that <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> satisfies all relative constraints in <italic toggle="yes">R</italic>.</p><p>5: <bold>end for</bold></p><p>6: Compute a final chronogram <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>OPT</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> by averaging dates across all error-corrected chronograms. Specifically, for a node <italic toggle="yes">i</italic> of <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>OPT</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we assign the average of dates assigned to node <italic toggle="yes">i</italic> across all <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p><p>7: <bold>return</bold><inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>OPT</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></boxed-text>Observe that DaTeR first ensures (Step 1) that the relative constraints provided in <italic toggle="yes">R</italic> are compatible with each other. This can be verified efficiently by checking for the presence of a directed cycle (indicating temporal conflict) in the graph representation of the constraints (<xref rid="btad084-B22" ref-type="bibr">Tofigh <italic toggle="yes">et al.</italic>, 2011</xref>). Note that DaTeR can be used not only to compute a single aggregate dating <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>OPT</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, but also to obtain distributions of dates for each node based on the error-corrected chronograms <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <p>Next, we describe the three objective functions implemented in DaTeR.</p>
    </sec>
    <sec>
      <label>3.2</label>
      <title>Objective functions</title>
      <p>Given an input chronogram <italic toggle="yes">T</italic> and the set of relative constraints <italic toggle="yes">R</italic>, the proposed objective functions seek to compute a minimal deviation from chronogram <italic toggle="yes">T</italic> such that all relative constraints in <italic toggle="yes">R</italic> are satisfied, as described below.</p>
      <p>Minimum squared branch length deviation (SBD). In the SBD objective function, the goal is to minimize the weighted sum of squared deviations of branch lengths between the input and output chronograms. Let <italic toggle="yes">T</italic> and <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> denote the input and output chronograms, respectively, on <italic toggle="yes">n</italic> leaves. Let <italic toggle="yes">t<sub>i</sub></italic> represent the date assigned to node <italic toggle="yes">i</italic> in <italic toggle="yes">T</italic> and <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denote date assigned to node <italic toggle="yes">i</italic> in <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, for each <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Then, the deviation of branch lengths for the edge <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is given by <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. The SBD objective function minimizes the weighted sum of SBDs across all edges of the input chronogram. We weight each term in this summation by the inverse of the input branch length <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. This weighting scheme helps minimize large deviations across short branches; that is, it helps ensure that the same magnitude of deviation can occur more easily along longer branches than shorter ones. This SBD objective function is similar to the objective function used in the LSD method (<xref rid="btad084-B21" ref-type="bibr">To <italic toggle="yes">et al.</italic>, 2016</xref>) in the context of absolute time constraints. Formally, the SBD objective function seeks to minimize the following:
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Minimum squared log ratio of branch lengths (SLRB). Instead of considering differences between branch lengths, as in SBD, the SLRB objective function considers the squared log of the ratio of the two branch lengths, that is, <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. Considering the ratio of branch lengths makes intuitive sense since it is robust to actual edge lengths and instead captures the change in evolutionary rate along an edge. Taking the square of the log of this ratio ensures that the same cost is applied irrespective of whether the new branch length is larger or smaller (multiplied or divided by the same scalar value). The SLRB objective function minimizes the weighted sum of squared log ratios across all edges of the input chronogram. This objective function is inspired by the LogDate method of <xref rid="btad084-B13" ref-type="bibr">Mai and Mirarab (2020)</xref> for dating with absolute time constraints and, like in LogDate, we weight each term in this summation by the square root of the input branch length <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msqrt><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msqrt></mml:mrow></mml:math></inline-formula>. Formally, the SLRB objective function seeks to minimize the following:
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:msqrt><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msqrt></mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mfrac><mml:mrow><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Minimum squared date deviation (SDD). The two previous objective functions consider changes in branch lengths. In contrast, the SDD objective function directly considers deviation in dates assigned to nodes in the input and output chronograms. The deviation in dates assigned to node <italic toggle="yes">i</italic> is given by <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> and the SDD objective function minimizes the weighted sum of SDDs across all internal nodes of the input chronogram. We weight each term in this summation by the inverse of the date in the input chronogram <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. This weighting scheme helps ensure that larger date deviations occur more easily along older nodes of the chronogram than along more recent nodes. Formally, the SDD objective function seeks to minimize the following:
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p><xref rid="btad084-F2" ref-type="fig">Figure 2</xref> illustrates the application of these three objective functions and demonstrates how, given the same input chronogram, they can result in substantially different output chronograms. <xref rid="btad084-F2" ref-type="fig">Figure 2</xref> also illustrates how, when error-correcting a single input chronogram, DaTeR has a tendency to just barely satisfy each relative time constraint. Specifically, if a relative constraint that is initially violated in the input chronogram requires that node <italic toggle="yes">i</italic> be dated to be at least as old as node <italic toggle="yes">j</italic>, then the output, error-corrected chronogram may assign the same date to nodes <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic>, so that the required constraint is just barely satisfied. However, as we demonstrate later, this tendency is suppressed when multiple chronograms are taken as input and results are aggregated across all the corresponding error-corrected chronograms. This is because different input chronogram samples vary in the specific rates and resulting time intervals assigned to branches. Consequently, different chronogram samples often violate different sets of constraints. Conversely, for any relative constraint, there are likely many input chronograms that already satisfy that constraint and will be included in the posterior sampling as unequal ages. This allows for the two nodes involved in such a constraint to have different date assignments in DaTeR’s final aggregated output. We point out, however, that if a relative time constraint is violated by all input chronograms, then the two nodes involved in that constraint may be assigned the same dates even in the aggregated output.</p>
      <fig position="float" id="btad084-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>Illustration of objective functions implemented in DaTeR. (<bold>a</bold>) An input chronogram which is not consistent with the depicted horizontal transfer event (dotted red line) implying that <italic toggle="yes">y</italic> should be dated to be at least as old as <italic toggle="yes">w</italic>. The chronograms shown in parts (<bold>b</bold>), (<bold>c</bold>), and (<bold>d</bold>) are obtained by error-correcting the chronogram in (a) using DaTeR under SBD, SLRB and SDD objective functions, respectively. Observe that each error-corrected chronogram satisfies the relative constraint and that each of the three objective functions results in a slightly different chronogram</p>
        </caption>
        <graphic xlink:href="btad084f2" position="float"/>
      </fig>
    </sec>
    <sec>
      <label>3.3</label>
      <title>Formulation as a constrained optimization problem</title>
      <p>DaTer uses a constrained optimization framework to compute error-corrected chronograms, that is, to implement Step 4 of <xref rid="btad084-BOX1" ref-type="boxed-text">Algorithm DaTeR</xref>, under the three objective functions described above.</p>
      <p>Constrained optimization objective. Given a single input chronogram <italic toggle="yes">T</italic> and set <italic toggle="yes">R</italic> of relative time constraints, DaTeR seeks to find the arguments <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> that minimize <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mo>ϕ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> under the selected function (<xref rid="E1" ref-type="disp-formula">Equations 1</xref>, <xref rid="E2" ref-type="disp-formula">2</xref> or <xref rid="E3" ref-type="disp-formula">3</xref>).</p>
      <p>Constraints. There are three categories of constraints as listed below.
</p>
      <list list-type="order">
        <list-item>
          <p>For each non-root node <italic toggle="yes">i</italic>, where <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, we include the following topological temporal constraint: <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p>For each relative time constraint from <italic toggle="yes">R</italic> requiring that node <italic toggle="yes">i</italic> be dated at least as old as node <italic toggle="yes">j</italic>, we include the following constraint: <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p>Finally, we assume, by default, that the dates of the leaf nodes in the chronogram are known and therefore fixed. This results in the following constraint for each leaf node <italic toggle="yes">i</italic>, where <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>: <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
      </list>
      <p>Optional constraints. If desired, constraints can also be added corresponding to known absolute time constraints used when inferring the input chronogram <italic toggle="yes">T</italic>. By default, we do not include any absolute time constraints in the constrained optimization framework since the addition of such constraints can, in principle, make it impossible to also simultaneously satisfy all relative time constraints.</p>
      <p>Computing optimal solutions. To solve the above non-linear programming formulations, DaTeR uses IBM ILOG CPLEX Optimization Studio through DOcplex API version 2.23 for Python to implement SBD and SDD. Since CPLEX does not support the <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow></mml:math></inline-formula> operation as required by SLRB, DaTeR uses the ‘trust-constr’ method implemented in SciPy (<xref rid="btad084-B23" ref-type="bibr">Virtanen <italic toggle="yes">et al.</italic>, 2020</xref>) to implement SLRB. We note that the SBD and SDD problem formulations are expected to be convex, as with LSD (<xref rid="btad084-B21" ref-type="bibr">To <italic toggle="yes">et al.</italic>, 2016</xref>). However, as with LogDate (<xref rid="btad084-B13" ref-type="bibr">Mai and Mirarab, 2020</xref>), SLRB is expected to be non-convex.</p>
    </sec>
    <sec>
      <label>3.4</label>
      <title>Aggregating over all input chronograms</title>
      <p>DaTeR takes as input <italic toggle="yes">m</italic> chronogram estimates and computes a final chronogram, <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>OPT</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, by aggregating across all <italic toggle="yes">m</italic> corresponding error-corrected chronograms (Step 6 of <xref rid="btad084-BOX1" ref-type="boxed-text">Algorithm DaTer</xref>). Specifically, for a node <italic toggle="yes">i</italic> of <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>OPT</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we assign the average of dates assigned to node <italic toggle="yes">i</italic> across all <italic toggle="yes">m</italic> error-corrected chronograms <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. A similar aggregation is often performed when aggregating across multiple chronogram samples from the posterior of a Bayesian analysis and it is easy to see that the result of aggregating multiple chronograms of the same underlying phylogenetic tree must itself be a valid chronogram. Importantly, it can also be shown that if the error-corrected chronograms <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are each consistent with the given relative time constraints, then so must the aggregated chronogram <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>OPT</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. We formally state this claim below. Its proof appears in the Supplement.<statement id="mthst1"><label>Lemma 3.1.</label><p><italic toggle="yes">If</italic> <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">each satisfy all relative constraints in R then</italic> <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>OPT</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">satisfies all relative constraints in R.</italic></p></statement></p>
      <p>We point out that this result holds true for any summarization function (not just for <italic toggle="yes">average</italic>, as in the lemma above) which has the following monotonicity property: If two lists, <italic toggle="yes">A</italic> and <italic toggle="yes">B</italic>, of numbers have the same length and each entry of list <italic toggle="yes">A</italic> is no less than the corresponding entry in list <italic toggle="yes">B</italic>, then the summarization function applied to <italic toggle="yes">A</italic> yields a value that is no less than the value obtained by applying the same summarization function to <italic toggle="yes">B</italic>. Examples of such functions include <italic toggle="yes">average</italic>, <italic toggle="yes">median</italic>, <italic toggle="yes">min</italic>, <italic toggle="yes">max</italic>, etc.</p>
    </sec>
  </sec>
  <sec>
    <label>4</label>
    <title>Results</title>
    <sec>
      <label>4.1</label>
      <title>Dataset description</title>
      <p>We applied DaTeR to a large, recently published dataset consisting of 170 Cyanobacterial genomes (<xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic>, 2021</xref>). This set of 170 Cyanobacteria genomes were manually curated for best representation of extant cyanobacterial diversity and a species tree topology was determined from a maximum-likelihood tree made using RAxML from a concatenated alignment of 30 ribosomal proteins, which was then used in our molecular clock analysis (<xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic>, 2021</xref>). This dataset consists of 1000 posterior chronogram samples for the species tree, computed using PhyloBayes (<xref rid="btad084-B10" ref-type="bibr">Lartillot and Philippe, 2004</xref>) under each of six different molecular dating models (for a total of 6000 chronogram samples). The six molecular dating models used are: (i) uncorrelated gamma multipliers model (<xref rid="btad084-B4" ref-type="bibr">Drummond <italic toggle="yes">et al.</italic>, 2006</xref>) with birth–death priors (UGAM_bd), (ii) uncorrelated gamma multipliers model with uniform tree priors (UGAM_nobd), (iii) lognormal autocorrelated model (<xref rid="btad084-B20" ref-type="bibr">Thorne <italic toggle="yes">et al.</italic>, 1998</xref>) with birth–death priors (LN_bd), (iv) lognormal autocorrelated model with uniform tree priors (LN_nobd), (v) Cox–Ingersoll–Ross process model (<xref rid="btad084-B11" ref-type="bibr">Lepage <italic toggle="yes">et al.</italic>, 2007</xref>) with birth–death priors (CIR_bd) and (vi) Cox–Ingersoll–Ross process model with uniform tree priors (CIR_nobd). Further details on the construction of these initial 6000 chronograms appear in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>.</p>
      <p>The dataset also includes 24 relative time constraints for the Cyanobacterial species tree. These relative time constraints were obtained from a set of 24 manually curated HGTs (<xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic>, 2021</xref>). Further details on these relative constraints appear in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>.</p>
      <p>Basic statistics. None of the chronograms sampled under CIR_bd, LN_nobd, LN_bd, UGAM_nobd, and UGAM_bd, and only 5 of the 1000 trees sampled under CIR-nobd, are compatible with all 24 relative constraints. <xref rid="btad084-T1" ref-type="table">Table 1</xref> shows the average number of relative constraints violated by the 1000 sampled chronograms under each of the six different molecular dating models, along with the numbers of samples satisfying at least 23 of the 24 constraints. As the table shows, chronograms estimated under the CIR-nobd model are, on average, the most compatible with the 24 relative constraints, with 122 of the 1000 samples compatible with at least 23 of the 24 relative constraints. In contrast, chronograms estimated under the LN-bd model are the least compatible, violating, on average 9.14 relative constraints and with none of the 1000 chronograms compatible with at least 23 of the relative constraints. All models dated the root node to between 3885.80 and 3900.85 mya, on average.</p>
      <table-wrap position="float" id="btad084-T1">
        <label>Table 1.</label>
        <caption>
          <p>Basic statistics for input chronograms</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Model</th>
              <th align="center" rowspan="1" colspan="1">Average number of relative constraints violated</th>
              <th align="center" rowspan="1" colspan="1">Number of samples satisfying <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mo>≥</mml:mo></mml:math></inline-formula>23 relative constraints</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">CIR_nobd</td>
              <td rowspan="1" colspan="1">3.45</td>
              <td rowspan="1" colspan="1">122</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">CIR_bd</td>
              <td rowspan="1" colspan="1">5.808</td>
              <td rowspan="1" colspan="1">6</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">LN_nobd</td>
              <td rowspan="1" colspan="1">6.74</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">LN_bd</td>
              <td rowspan="1" colspan="1">9.14</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UGAM_nobd</td>
              <td rowspan="1" colspan="1">7.25</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UGAM_bd</td>
              <td rowspan="1" colspan="1">6.78</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Notes</italic>: The table shows two different measures of compatibility for the 1000 chronograms sampled under each of the six molecular dating models with the 24 relative constraints.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>Error-correction using DaTeR. We used all 24 relative time constraints and applied DaTeR to the 1000 chronogram samples from each of the six molecular dating models. For each molecular dating model, we used each of the three objective functions implemented in DaTeR, so that 18 000 chronograms were error-corrected in total. We refer to these chronograms as DaTeR-corrected chronograms. Thus, after aggregation across the 1000 DaTeR-corrected chronograms for each dating model and objective function, we obtained 18 final DaTeR-corrected chronograms (three for each of the six molecular dating models).</p>
    </sec>
    <sec>
      <label>4.2</label>
      <title>Impact of DaTeR on inferred node ages</title>
      <p>To assess the impact of DaTeR on chronogram estimation, we compared the DaTeR-corrected chronograms against the uncorrected input chronograms. As expected, each of the 18 000 DaTeR-corrected chronograms was compatible with all 24 relative constraints. To assess the change in node dates pre- and post-error-correction, we compared the six aggregated input chronograms against the 18 aggregated DaTeR-corrected chronograms. <xref rid="btad084-F3" ref-type="fig">Figure 3</xref> shows the average gap (difference in dates) between pairs of nodes corresponding to violated relative constraints in the aggregated input chronograms. As the figure shows, the substantial negative gap for the input chronograms, under all six models, is corrected and reversed by DaTeR under each molecular dating model and each objective function. The average correction for these node pairs is slightly under 250 million years under the CIR_nobd model and over 600 million years under the UGAM_bd model.</p>
      <fig position="float" id="btad084-F3">
        <label>Fig. 3.</label>
        <caption>
          <p>Average date gap for violated relative constraints. The figure shows the average difference in assigned dates for pairs of nodes corresponding to violated relative constraints in the aggregated input chronograms. A negative difference mean that the constraint is violated (i.e. that the difference in dates is in the wrong direction). Positive differences mean that the constraints are satisfied and the differences in assigned dates are in the correct direction. Results are shown for the aggregated input chronograms and the aggregated chronograms computed using the three objective functions implemented in DaTeR, for each of the six dating models</p>
        </caption>
        <graphic xlink:href="btad084f3" position="float"/>
      </fig>
      <p>We also assessed the overall change in node dates and branch lengths between the input and DaTeR-corrected chronograms. <xref rid="btad084-T2" ref-type="table">Table 2</xref> shows the results of this analysis. As the table shows, the average change in assigned node dates and branch lengths remains low across all three objective functions under the CIR_nobd model, but is substantially higher under the UGAM_bd and LN_bd models. Overall, these results demonstrate that, under appropriate models of molecular dating such as CIR_nobd, DaTeR can achieve compatibility with all relative constraints with only minor adjustments to node dates and branch lengths.</p>
      <table-wrap position="float" id="btad084-T2">
        <label>Table 2.</label>
        <caption>
          <p>Average differences in node dates and branch lengths</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Model</th>
              <th colspan="3" align="center" rowspan="1">Node date deviation<hr/></th>
              <th colspan="3" align="center" rowspan="1">Branch length deviation<hr/></th>
            </tr>
            <tr>
              <th align="center" rowspan="1" colspan="1"/>
              <th align="center" rowspan="1" colspan="1">SBD</th>
              <th align="center" rowspan="1" colspan="1">SLRB</th>
              <th align="center" rowspan="1" colspan="1">SDD</th>
              <th align="center" rowspan="1" colspan="1">SBD</th>
              <th align="center" rowspan="1" colspan="1">SLRB</th>
              <th align="center" rowspan="1" colspan="1">SDD</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">CIR_nobd</td>
              <td rowspan="1" colspan="1">18.67</td>
              <td rowspan="1" colspan="1">19.37</td>
              <td rowspan="1" colspan="1">
                <bold>5.09</bold>
              </td>
              <td rowspan="1" colspan="1">12.99</td>
              <td rowspan="1" colspan="1">13.43</td>
              <td rowspan="1" colspan="1">
                <bold>6.48</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">CIR_bd</td>
              <td rowspan="1" colspan="1">31.1</td>
              <td rowspan="1" colspan="1">29.81</td>
              <td rowspan="1" colspan="1">
                <bold>11.05</bold>
              </td>
              <td rowspan="1" colspan="1">21.2</td>
              <td rowspan="1" colspan="1">20.48</td>
              <td rowspan="1" colspan="1">
                <bold>12.83</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">LN_nobd</td>
              <td rowspan="1" colspan="1">37.52</td>
              <td rowspan="1" colspan="1">39.44</td>
              <td rowspan="1" colspan="1">
                <bold>13.06</bold>
              </td>
              <td rowspan="1" colspan="1">25.73</td>
              <td rowspan="1" colspan="1">26.57</td>
              <td rowspan="1" colspan="1">
                <bold>14.98</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">LN_bd</td>
              <td rowspan="1" colspan="1">65.27</td>
              <td rowspan="1" colspan="1">70.32</td>
              <td rowspan="1" colspan="1">
                <bold>24.15</bold>
              </td>
              <td rowspan="1" colspan="1">40.44</td>
              <td rowspan="1" colspan="1">42.29</td>
              <td rowspan="1" colspan="1">
                <bold>25.57</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UGAM_nobd</td>
              <td rowspan="1" colspan="1">59.85</td>
              <td rowspan="1" colspan="1">58.49</td>
              <td rowspan="1" colspan="1">
                <bold>23.79</bold>
              </td>
              <td rowspan="1" colspan="1">40.0</td>
              <td rowspan="1" colspan="1">39.02</td>
              <td rowspan="1" colspan="1">
                <bold>26.28</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UGAM_bd</td>
              <td rowspan="1" colspan="1">67.36</td>
              <td rowspan="1" colspan="1">58.08</td>
              <td rowspan="1" colspan="1">
                <bold>28.12</bold>
              </td>
              <td rowspan="1" colspan="1">42.93</td>
              <td rowspan="1" colspan="1">39.58</td>
              <td rowspan="1" colspan="1">
                <bold>29.01</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic toggle="yes">Notes</italic>: Average differences between assigned node dates and branch lengths are shown between aggregated input chronograms and corresponding DaTeR-corrected chronograms. Results are shown for all three objective functions implemented in DaTeR and for all six molecular dating models. Node date deviation results are averaged over the 169 internal nodes in each chronogram and branch length deviation results are averaged over all 338 edges in each chronogram. Bold text indicates lowest (best) values.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <label>4.3</label>
      <title>Comparison across objective functions</title>
      <p>As <xref rid="btad084-T2" ref-type="table">Table 2</xref> shows, the three objective functions implemented in DaTeR result in different chronogram estimates. In particular, DaTeR with the SDD objective function results in significantly smaller deviations for both node dates and branch lengths compared with the SBD and SLRB objective functions. However, this does not necessarily imply that the SDD objective function results in more accurate chronograms. Specifically, an error-corrected chronogram in which input branch lengths are only minimally rescaled may be preferable to an error-corrected chronogram with lower overall node date or branch length deviation but greater branch-length rescaling. For instance, in many cases, it may be preferable to rescale a length 10 edge to length 12 (corresponding to a 20% change) instead of rescaling a length 2 edge to length 3 (corresponding to a 50% change). We therefore computed the average percent change in branch lengths for DaTeR-corrected chronograms under the three different objective functions and the left half of <xref rid="btad084-T3" ref-type="table">Table 3</xref> shows these results. We find that the percent change is smallest for SLRB under all models and is largest for SDD under four of the six dating models. For example, under the CIR_nobd model, SLRB shows an average change of 1.69% while SBD and SDD show percent changes of 2.17% and 2.62%, respectively. A more fine-grained analysis appears in <xref rid="btad084-F4" ref-type="fig">Figure 4</xref>, which shows how, for CIR_nobd, the majority of edges are rescaled only minimally, how SBD and SLRB do not rescale any edge by more than 40% (and SLRB rescales only 2 edges more than 20%) and how using SDD results in far more extreme rescaling of branch lengths for multiple edges. Thus, SLRB performs best under this measure despite resulting in larger overall changes in node dates and branch lengths.</p>
      <fig position="float" id="btad084-F4">
        <label>Fig. 4.</label>
        <caption>
          <p>Bar chart of percent change in branch lengths. The number of edges within various percent ranges is shown for aggregated DaTeR-corrected chronograms under the three different objective functions for the CIR_nobd model. All intervals are left-closed and right-open, and a log scale is used for the <italic toggle="yes">Y</italic>-axis. The total number of edges is 338</p>
        </caption>
        <graphic xlink:href="btad084f4" position="float"/>
      </fig>
      <table-wrap position="float" id="btad084-T3">
        <label>Table 3.</label>
        <caption>
          <p>Percent change in branch lengths and pairwise node date deviations for different objective functions</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Model</th>
              <th rowspan="1" colspan="1">SBD (%)</th>
              <th rowspan="1" colspan="1">SLRB (%)</th>
              <th rowspan="1" colspan="1">SDD (%)</th>
              <th rowspan="1" colspan="1">SBD versus SLRB</th>
              <th rowspan="1" colspan="1">SDD versus SBD</th>
              <th rowspan="1" colspan="1">SDD versus SLRB</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">CIR_nobd</td>
              <td rowspan="1" colspan="1">2.17</td>
              <td rowspan="1" colspan="1">
                <bold>1.69</bold>
              </td>
              <td rowspan="1" colspan="1">2.62</td>
              <td rowspan="1" colspan="1">
                <bold>7.77</bold>
              </td>
              <td rowspan="1" colspan="1">13.13</td>
              <td rowspan="1" colspan="1">13.94</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">CIR_bd</td>
              <td rowspan="1" colspan="1">4.18</td>
              <td rowspan="1" colspan="1">
                <bold>3.0</bold>
              </td>
              <td rowspan="1" colspan="1">4.73</td>
              <td rowspan="1" colspan="1">
                <bold>14.63</bold>
              </td>
              <td rowspan="1" colspan="1">20.42</td>
              <td rowspan="1" colspan="1">22.03</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">LN_nobd</td>
              <td rowspan="1" colspan="1">3.99</td>
              <td rowspan="1" colspan="1">
                <bold>3.11</bold>
              </td>
              <td rowspan="1" colspan="1">4.95</td>
              <td rowspan="1" colspan="1">
                <bold>19.6</bold>
              </td>
              <td rowspan="1" colspan="1">24.56</td>
              <td rowspan="1" colspan="1">28.92</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">LN_bd</td>
              <td rowspan="1" colspan="1">7.34</td>
              <td rowspan="1" colspan="1">
                <bold>6.15</bold>
              </td>
              <td rowspan="1" colspan="1">8.85</td>
              <td rowspan="1" colspan="1">
                <bold>28.34</bold>
              </td>
              <td rowspan="1" colspan="1">41.22</td>
              <td rowspan="1" colspan="1">53.17</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UGAM_nobd</td>
              <td rowspan="1" colspan="1">6.68</td>
              <td rowspan="1" colspan="1">
                <bold>5.5</bold>
              </td>
              <td rowspan="1" colspan="1">5.82</td>
              <td rowspan="1" colspan="1">
                <bold>32.89</bold>
              </td>
              <td rowspan="1" colspan="1">37.33</td>
              <td rowspan="1" colspan="1">43.35</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UGAM_bd</td>
              <td rowspan="1" colspan="1">8.16</td>
              <td rowspan="1" colspan="1">
                <bold>7.28</bold>
              </td>
              <td rowspan="1" colspan="1">7.34</td>
              <td rowspan="1" colspan="1">
                <bold>37.83</bold>
              </td>
              <td rowspan="1" colspan="1">40.65</td>
              <td rowspan="1" colspan="1">41.67</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn3">
            <p><italic toggle="yes">Notes:</italic> The left half shows the average percent change in branch lengths for aggregated DaTeR-corrected chronograms under the three different objective functions. The percent change in the branch length for an edge <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is calculated as <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>×</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">t<sub>j</sub></italic> and <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> refer to the dates assigned to node <italic toggle="yes">j</italic> in the aggregated input chronogram and corresponding DaTeR-corrected chronogram, respectively. The right half shows average differences between assigned node dates between pairs of DaTeR-corrected aggregated chronograms computed using different objective functions. Results are shown for all six molecular dating models. Bold text indicates lowest (best) values.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>We also assessed the overall pairwise similarities of the aggregated chronograms resulting from DaTeR-correction under the three objectives. As the right half of <xref rid="btad084-T3" ref-type="table">Table 3</xref> shows, chronograms constructed using SBD and SLRB show significantly greater pairwise similarity to each other than they show to chronograms constructed using SDD.</p>
      <p>Further assessment using simulated data. To gain further insight into the behavior of these objective functions, we applied DaTeR to simulated datasets with known node dates. We used the phylogenetic simulation software SaGePhy (<xref rid="btad084-B8" ref-type="bibr">Kundu and Bansal, 2019</xref>) to first generate 20 simulated ultrametric species trees, each with 100 leaves and height 1 and evolved under a birth–death model, and then relaxed the branches of these species trees using autocorrelated lognormal rate scaling under the model of <xref rid="btad084-B15" ref-type="bibr">Rannala and Yang (2007)</xref>. For 10 of the 20 species trees, we performed this scaling using a start rate of 1 and <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mn>0.25</mml:mn></mml:mrow></mml:math></inline-formula>, and for the remaining 10 species trees we used a start rate of 1 and <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:math></inline-formula>. This resulted in two sets of scaled species trees, each consisting of 10 trees.</p>
      <p>We then used the phylogenetic dating method LogDate (<xref rid="btad084-B13" ref-type="bibr">Mai and Mirarab, 2020</xref>) with default parameters, together with a single absolute time constraint specifying the age of the root node to be 1, to infer a single chronogram from each of the 20 scaled species trees. These chronograms were then error-corrected using additional relative time constraints under each of the three objective functions implemented in DaTeR, and the assigned node dates were compared with the node dates in the corresponding original ultrametric species tree. We used randomly generated HGTs to obtain the relative time constraints used with each input chronogram when error-corrected using DaTeR. Specifically, we used SaGePhy (<xref rid="btad084-B8" ref-type="bibr">Kundu and Bansal, 2019</xref>) to generate a ‘gene’ tree with randomly invoked HGTs for each of the 20 original ultrametric species trees. This resulted in several relative time constraints per species tree, some of which were violated in the corresponding LogDate chronogram. We used these violated relative time constraints when error-correcting the LogDate chronograms with DaTeR, ensuring that there were at least three violated relative time constraints for each LogDate chronogram. On average, we used 3.85 relative time constraints to error-correct each LogDate chronogram. The specific SaGePhy commands used to generate the initial ultrametric species trees, rescale their branch lengths and generate gene trees with HGTs are given in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>.</p>
      <p>We compared the accuracies of assigned node dates in the error-corrected chronograms inferred using the three objective functions. On the 10 species trees scaled using parameters <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0.25</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, the scaled trees, LogDate chronograms, SDD chronograms, SBD chronograms and SLRB chronograms showed total node date deviations of 7.8, 5.2, 4.84, 4.45 and 4.4, respectively, on average per tree. On the 10 species trees scaled using parameters <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, the scaled trees, LogDate chronograms, SDD chronograms, SBD chronograms and SLRB chronograms showed total node date deviations of 15.25, 7.67, 7.19, 6.475 and 6.52, respectively, on average per tree. These results show that while all three objective functions are able to improve upon the LogDate tree, these improvements are, as expected, greatest for the SBD and SLRB objective functions.</p>
      <p>Overall, the above experimental results using both real and simulated data suggest that (i) SBD and SLRB may be preferable to SDD in many cases and that SLRB is a good ‘default’ objective function for DaTeR, (ii) the three objective functions result in non-identical chronogram estimates but SBD and SLRB generally result in similar chronograms and (iii) SDD can result in more distinct chronograms and may be preferable under certain scenarios, for example, when the goal is to minimize overall change in node dates or branch lengths.</p>
    </sec>
    <sec>
      <label>4.4</label>
      <title>Application to model selection</title>
      <p>A key consideration in phylogenetic dating is the choice of molecular dating model to use. As can be seen above (<xref rid="btad084-T1" ref-type="table">Tables 1</xref> and <xref rid="btad084-T2" ref-type="table">2</xref> and <xref rid="btad084-F3" ref-type="fig">Fig. 3</xref>), the choice of molecular dating model directly impacts chronogram estimation. However, it can often be difficult to identify the most appropriate molecular dating model to use with a given dataset. Checking for compatibility with known relative constraints and assessing the magnitude of node date or branch length deviation required by DaTeR on chronograms estimated under different molecular dating models can help address this difficulty.</p>
      <p>Indeed, using the results shown in <xref rid="btad084-T2" ref-type="table">Tables 2</xref> and <xref rid="btad084-T3" ref-type="table">3</xref>, we can easily identify CIR_nobd as the most appropriate molecular dating model for our dataset. Importantly, the superiority of CIR_nobd for this dataset is consistently identified under all three of DaTeR’s objective functions and all reported measures of deviation (node deviation, branch length deviation or percent change in branch lengths). All objective functions and measures of deviation also clearly identify UGAM_bd and LN_bd as the least appropriate models to use for this dataset. These insights are also compatible with the statistics on average numbers of relative constraints violated under each molecular dating model, where we find that CIR_nobd violates the fewest relative constraints and LN_bd violates the most. Thus, in addition to chronogram estimation under a given molecular dating model, DaTeR can be used to help select the most appropriate molecular dating model to use among the candidates under consideration.</p>
    </sec>
    <sec>
      <label>4.5</label>
      <title>Comparison against rejection-sampling approach</title>
      <p><xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic> (2021)</xref> previously analyzed this Cyanobacterial dataset to assess the impact of using relative time constraints on phylogenetic dating. They employed a Bayesian rejection-sampling approach where posterior chronogram chronograms samples (1000 chronograms sampled from the posterior using PhyloBayes, under six different molecular dating models) that did not satisfy at least a certain fraction of the 24 relative constraints were rejected (<xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic>, 2021</xref>). Recall that only 5 of the total of 6000 input chronogram samples, across all six models, are compatible with all 24 relative constraints (see also <xref rid="btad084-T1" ref-type="table">Table 1</xref>). Thus, <xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic> (2021)</xref> used lower relative constraint compatibility cutoffs in their analysis, balancing the need for sufficiently many chronogram samples with other considerations for the different models. For our comparative analysis, we applied Bayesian rejection sampling by rejecting those samples that satisfied fewer than 21 relative constraints. This resulted in a subset of chronogram samples that was large enough to reasonably estimate age distributions under most of the molecular dating models: 709 samples for CIR_nobd, 203 for CIR_bd, 57 for LN_nobd, 8 for LN_bd, 13 for UGAM_nobd and 8 for UGAM_bd.</p>
      <p>We compared the final aggregated chronograms computed using DaTeR with those computed using this Bayesian rejection-sampling approach. As <xref rid="btad084-T4" ref-type="table">Table 4</xref> shows, all Bayesian rejection-sampling aggregated chronograms violate between two and four relative constraints, with the chronogram computed under CIR_nobd violating the fewest. As the table shows, the constraints violated in these aggregated chronograms also show large average date gaps (in the sense of <xref rid="btad084-F3" ref-type="fig">Fig. 3</xref>), with an average date gap of −224.01 under CIR_nobd. As with DaTeR (<xref rid="btad084-T2" ref-type="table">Table 2</xref>), we also computed average differences between assigned node dates and branch lengths between aggregated input chronograms and corresponding Bayesian rejection-sampling chronograms. As <xref rid="btad084-T4" ref-type="table">Table 4</xref> shows, Bayesian rejection-sampling chronograms show significantly higher node date deviations and branch length deviations than DaTeR (under all objective functions) for five out of the six molecular dating models. This highlights DaTeR’s ability to satisfy more (all) relative constraints with less node date and branch length deviation.</p>
      <table-wrap position="float" id="btad084-T4">
        <label>Table 4.</label>
        <caption>
          <p>Results of applying Bayesian rejection sampling</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Model</th>
              <th colspan="4" align="center" rowspan="1">Rejection-sampling chronograms<hr/></th>
            </tr>
            <tr>
              <th align="center" rowspan="1" colspan="1"/>
              <th align="center" rowspan="1" colspan="1">Relative constraints violated</th>
              <th align="center" rowspan="1" colspan="1">Average date gap</th>
              <th align="center" rowspan="1" colspan="1">Node date deviation</th>
              <th align="center" rowspan="1" colspan="1">Branch length deviation</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">CIR_nobd</td>
              <td rowspan="1" colspan="1">2</td>
              <td rowspan="1" colspan="1">−224.01</td>
              <td rowspan="1" colspan="1">7.23</td>
              <td rowspan="1" colspan="1">5.25</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">CIR_bd</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">−243.77</td>
              <td rowspan="1" colspan="1">34.77</td>
              <td rowspan="1" colspan="1">21.82</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">LN_nobd</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">−238.85</td>
              <td rowspan="1" colspan="1">77.05</td>
              <td rowspan="1" colspan="1">47.2</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">LN_bd</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">−134.17</td>
              <td rowspan="1" colspan="1">154.75</td>
              <td rowspan="1" colspan="1">93.02</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UGAM_nobd</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">−343.82</td>
              <td rowspan="1" colspan="1">70.11</td>
              <td rowspan="1" colspan="1">53.18</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UGAM_bd</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">−915.23</td>
              <td rowspan="1" colspan="1">69.24</td>
              <td rowspan="1" colspan="1">47.29</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn4">
            <p><italic toggle="yes">Notes</italic>: Basic summary statistics are shown for aggregated chronograms computed using the Bayesian rejection-sampling approach with a relative constraint cutoff of <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mo>≥</mml:mo></mml:math></inline-formula>21. The table shows the number of violated relative constraints, average difference in assigned dates for pairs of nodes corresponding to the violated relative constraints (as in <xref rid="btad084-F3" ref-type="fig">Fig. 3</xref>) and average differences between assigned node dates and branch lengths between aggregated input chronograms and corresponding aggregated Bayesian rejection-sampling chronograms (compare with <xref rid="btad084-T2" ref-type="table">Table 2</xref>).</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>We also compared how assigned node dates differ between aggregated DaTeR-corrected chronograms, using the SLRB objective function, and corresponding Bayesian rejection-sampling chronograms. <xref rid="sup1" ref-type="supplementary-material">Supplementary Figures S1–S6</xref> show the results for all six molecular dating models. We find that DaTeR and Bayesian rejection sampling show significant differences in assigned node dates for several nodes under all molecular dating models except CIR_nobd. Under the CIR_nobd model (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref>), both DaTeR and Bayesian rejection sampling assign similar dates for the majority of nodes (generally identical to input node dates), but DaTeR shows substantially higher deviation from input dates for a small subset of the nodes.</p>
      <p>Finally, we compared the distribution of dates for each node reported by the two methods for each of the six molecular dating models. Recall that the input chronograms, DaTeR-corrected chronograms and Bayesian rejection-sampling chronograms all yield associated distributions of dates for each node (in addition to the mean/aggregated date for each node used in our analysis thus far). <xref rid="sup1" ref-type="supplementary-material">Supplementary Figures S7–S12</xref> plot standard deviations for node dates for the six molecular dating models. As the plots show standard deviations for DaTeR-corrected chronograms are similar overall to those for the input chronograms but can vary from node to node, showing higher deviation compared with the input for some nodes and identical or lower for others.</p>
    </sec>
    <sec>
      <label>4.6</label>
      <title>Running time and scalability</title>
      <p>DaTeR is fast and scalable and has minimal computational requirements. <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref> shows average running times of DaTeR per chronogram (averaged over the 1000 input chronogram samples) on a commodity desktop computer (Intel Core i5 3.2 GHz processor and 8 GB main memory) for each of the six molecular dating models. As the table shows, each run of DaTeR using the SBD or SDD objective function required less than a second per chronogram on our dataset (i.e. on chronograms with 170 leaves) for all six dating models. However, running times are significantly longer for SLRB, requiring an average of 33 min for each CIR_nobd chronogram and up to almost 2 h for each UGAM_bd chronogram. This drastic discrepancy in running time for SLRB versus the other two objective functions is likely due to the fact that DaTeR is able to use the highly optimized IBM ILOG CPLEX Optimization Studio to implement the SBD and SDD objective functions but uses the less optimized ‘trust-constr’ method implemented in SciPy (<xref rid="btad084-B23" ref-type="bibr">Virtanen <italic toggle="yes">et al.</italic>, 2020</xref>) to implement the SLRB objective function.</p>
      <p>These results demonstrate how DaTeR, using SBD or SDD, can be used to error-correct and aggregate over hundreds or thousands of large chronograms in a matter of minutes. They also show how DaTeR can be feasibly applied to large chronograms, error-correcting and aggregating over hundreds of chronogram samples, within a few days even under the SLRB objective function. In fact, if multiple cores are available then this running time can be proportionally reduced through trivial parallelization (error-correcting different chronogram samples independently in parallel). Furthermore, if SLRB requires excessive running time, our previous results show that the similar and highly scalable SBD objective function can be used instead (<xref rid="btad084-T3" ref-type="table">Table 3</xref>).</p>
    </sec>
  </sec>
  <sec>
    <label>5</label>
    <title>Discussion and conclusion</title>
    <p>In this work, we introduced a novel, error-correction-based approach, DaTeR, for estimating chronograms based on both absolute and relative time calibrations. Our extensive experimental analysis using a large empirical dataset, supplemented by a simulation study, demonstrates the potential of DaTeR for improved phylogenetic dating. We found that chronograms constructed using conventional approaches often violate known relative constraints and that DaTeR is able to satisfy all relative constraints by making minor adjustments to the input chronograms. We also found that DaTeR can be used to help select the most appropriate molecular dating model for computing initial posterior chronogram estimates and that DaTeR substantially improves upon the previously developed Bayesian rejection-sampling approach. Importantly, DaTeR is not only effective but also scalable, requiring less than a second on each input chronogram sample under two of the three objective functions. By allowing for the easy incorporation of relative time constraints, DaTeR will enable more accurate chronogram construction for microbial species.</p>
    <p>DaTeR offers several advantages compared with the recently developed Bayesian approach of <xref rid="btad084-B18" ref-type="bibr">Szollosi <italic toggle="yes">et al.</italic> (2022)</xref>. For example, a frequent challenge with Bayesian tree space exploration is that this space can be very small, or even non-existent, due to incompatibility with rate models or fossil calibrations or both. The method of <xref rid="btad084-B18" ref-type="bibr">Szollosi <italic toggle="yes">et al.</italic> (2022)</xref> cannot be used if one or more relative constraints are incompatible with the given node age calibrations, but DaTeR can rein in branch length behavior impacted by spurious or dubious by fossil calibrations and improve age estimates even in cases of incompatibility with fossil calibrations or rate models. Importantly, DaTeR can also be used with any molecular dating software and any dating model, approach or existing chronogram dataset, as well as dating models and approaches that have not yet been developed. In contrast, the method of <xref rid="btad084-B18" ref-type="bibr">Szollosi <italic toggle="yes">et al.</italic> (2022)</xref> relies upon a single implementation and is limited by the models and functionality available in RevBayes. Another key advantage of DaTeR is that it can be used to determine the best molecular clock branch rate model. The extent of error-correction needed to satisfy relative constraints can be used as a metric to assess the fitness of different molecular clock rate models. This novel <italic toggle="yes">post hoc</italic> assessment of molecular clock models helps address model fit and biases and can independently determine the most accurate model to use for retrieval of date estimates, which is a key issue in employing molecular clock models. Finally, DaTeR makes it quick and easy to assess the impact of adding or removing different relative constraints since the Bayesian molecular clock analysis does not need to be rerun. This allows for flexibility in the analysis as well as greater scalability.</p>
    <p>DaTeR could be further improved in several different ways. Under the current formulation, when applying DaTeR to a single chronogram sample, the two nodes involved in a violated relative constraint are often assigned identical dates (i.e. a zero or almost zero date gap) in the resulting error-corrected chronogram. Thus, while DaTeR can also be used to error-correct single chronograms, such as those computed using fast phylogenetic dating methods like LSD (<xref rid="btad084-B21" ref-type="bibr">To <italic toggle="yes">et al.</italic>, 2016</xref>) or LogDate (<xref rid="btad084-B13" ref-type="bibr">Mai and Mirarab, 2020</xref>), the resulting error-corrected chronogram would exhibit a strong bias toward having fewer unique node date assignments (i.e. divergence times). Even when applying DaTeR to a collection of input chronograms and aggregating over the results, the resulting aggregated chronogram is biased toward having several pairs of nodes with similar node date assignments. Thus, chronograms estimated using DaTeR, though more accurate, show a particular bias in assigned dates. It would be useful to address this bias and enable larger date gaps between nodes corresponding to HGT-derived relative constraints. In addition, it may be beneficial to extend the framework to allow for a small number of relative constraints to be violated if satisfying such constraints requires large deviations from input dates or extreme rescaling of branch lengths. This could help account for any uncertainty or error in the utilized relative constraints. One approach to implementing the above improvements is to use ‘soft bounds’ for relative constraints. Such soft bounds methods exist for traditional phylogenetic dating and they allow for age estimates to slightly violate constraints based on a probability model (<xref rid="btad084-B1" ref-type="bibr">Bouckaert <italic toggle="yes">et al.</italic>, 2014</xref>; <xref rid="btad084-B26" ref-type="bibr">Yang and Rannala, 2006</xref>). This allows such methods to account for uncertainty/error in fossil calibrations and a similar idea could be applied to relative constraints. Finally, DaTeR’s underlying framework could be extended to simultaneously error-correct with respect to all given input chronogram samples and compute a single, globally optimal error-corrected chronogram, instead of aggregating across multiple error-corrected chronograms as in the current approach.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad084_Supplementary_Data</label>
      <media xlink:href="btad084_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the US National Science Foundation [EAR 1615573 to M.S.B. and EAR 1615426 to G.P.F.].</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The Cyanobacterial dataset analyzed in this work is publicly available (<xref rid="btad084-B5" ref-type="bibr">Fournier <italic toggle="yes">et al.</italic>, 2021</xref>). The specific commands used to generate simulated data are available in the Supplement. DaTeR software is freely available from <ext-link xlink:href="https://compbio.engr.uconn.edu/software/dater/" ext-link-type="uri">https://compbio.engr.uconn.edu/software/dater/</ext-link>.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad084-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bouckaert</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2014</year>) <article-title>Beast 2: A software platform for Bayesian evolutionary analysis</article-title>. <source>PLoS Comput. Biol</source>., <volume>10</volume>, <fpage>e1003537</fpage>.<pub-id pub-id-type="pmid">24722319</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Davín</surname><given-names>A.A.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Gene transfers can date the tree of life</article-title>. <source>Nat. Ecol. Evol</source>., <volume>2</volume>, <fpage>904</fpage>–<lpage>909</lpage>.<pub-id pub-id-type="pmid">29610471</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dos Reis</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2016</year>) <article-title>Bayesian molecular clock dating of species divergences in the genomics era</article-title>. <source>Nat. Rev. Genet</source>., <volume>17</volume>, <fpage>71</fpage>–<lpage>80</lpage>.<pub-id pub-id-type="pmid">26688196</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Drummond</surname><given-names>A.J.</given-names></string-name></person-group><etal>et al</etal> (<year>2006</year>) <article-title>Relaxed phylogenetics and dating with confidence</article-title>. <source>PLoS Biol</source>., <volume>4</volume>, <fpage>e88</fpage>.<pub-id pub-id-type="pmid">16683862</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fournier</surname><given-names>G.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>The Archean origin of oxygenic photosynthesis and extant cyanobacterial lineages</article-title>. <source>Proc. R. Soc. B</source>, <volume>288</volume>, <fpage>20210675</fpage>.</mixed-citation>
    </ref>
    <ref id="btad084-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gogarten</surname><given-names>J.P.</given-names></string-name></person-group><etal>et al</etal> (<year>1999</year>) <article-title>Horizontal gene transfer: Pitfalls and promises</article-title>. <source>Biol. Bull</source>., <volume>196</volume>, <fpage>359</fpage>–<lpage>362</lpage>.<pub-id pub-id-type="pmid">10390834</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gruen</surname><given-names>D.S.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Paleozoic diversification of terrestrial chitin-degrading bacterial lineages</article-title>. <source>BMC Evol. Biol</source>., <volume>19</volume>, <fpage>1</fpage>–<lpage>19</lpage>.<pub-id pub-id-type="pmid">30606099</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kundu</surname><given-names>S.</given-names></string-name>, <string-name><surname>Bansal</surname><given-names>M.S.</given-names></string-name></person-group> (<year>2019</year>) <article-title>SaGePhy: An improved phylogenetic simulation framework for gene and subgene evolution</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>3496</fpage>–<lpage>3498</lpage>.<pub-id pub-id-type="pmid">30715213</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Langley</surname><given-names>C.H.</given-names></string-name>, <string-name><surname>Fitch</surname><given-names>W.M.</given-names></string-name></person-group> (<year>1974</year>) <article-title>An examination of the constancy of the rate of molecular evolution</article-title>. <source>J. Mol. Evol</source>., <volume>3</volume>, <fpage>161</fpage>–<lpage>177</lpage>.<pub-id pub-id-type="pmid">4368400</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lartillot</surname><given-names>N.</given-names></string-name>, <string-name><surname>Philippe</surname><given-names>H.</given-names></string-name></person-group> (<year>2004</year>) <article-title>A Bayesian mixture model for across-site heterogeneities in the amino-acid replacement process</article-title>. <source>Mol. Biol. Evol</source>., <volume>21</volume>, <fpage>1095</fpage>–<lpage>1109</lpage>.<pub-id pub-id-type="pmid">15014145</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lepage</surname><given-names>T.</given-names></string-name></person-group><etal>et al</etal> (<year>2007</year>) <article-title>A general comparison of relaxed molecular clock models</article-title>. <source>Mol. Biol. Evol</source>., <volume>24</volume>, <fpage>2669</fpage>–<lpage>2680</lpage>.<pub-id pub-id-type="pmid">17890241</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Magnabosco</surname><given-names>C.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Dating phototrophic microbial lineages with reticulate gene histories</article-title>. <source>Geobiology</source>, <volume>16</volume>, <fpage>179</fpage>–<lpage>189</lpage>.<pub-id pub-id-type="pmid">29384268</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Mai</surname><given-names>U.</given-names></string-name>, <string-name><surname>Mirarab</surname><given-names>S.</given-names></string-name></person-group> (<year>2020</year>). Log transformation improves dating of phylogenies. In: <italic toggle="yes">International Conference on Research in Computational Molecular Biology</italic>. Springer, pp. <fpage>264</fpage>–<lpage>265</lpage>.</mixed-citation>
    </ref>
    <ref id="btad084-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rambaut</surname><given-names>A.</given-names></string-name>, <string-name><surname>Bromham</surname><given-names>L.</given-names></string-name></person-group> (<year>1998</year>) <article-title>Estimating divergence dates from molecular sequences</article-title>. <source>Mol. Biol. Evol</source>., <volume>15</volume>, <fpage>442</fpage>–<lpage>448</lpage>.<pub-id pub-id-type="pmid">9549094</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rannala</surname><given-names>B.</given-names></string-name>, <string-name><surname>Yang</surname><given-names>Z.</given-names></string-name></person-group> (<year>2007</year>) <article-title>Inferring speciation times under an episodic molecular clock</article-title>. <source>Syst. Biol</source>., <volume>56</volume>, <fpage>453</fpage>–<lpage>466</lpage>.<pub-id pub-id-type="pmid">17558967</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Renner</surname><given-names>S.S.</given-names></string-name></person-group><etal>et al</etal> (<year>2008</year>) <article-title>Rooting and dating maples (Acer) with an uncorrelated-rates molecular clock: Implications for North American/Asian disjunctions</article-title>. <source>Syst. Biol</source>., <volume>57</volume>, <fpage>795</fpage>–<lpage>808</lpage>.<pub-id pub-id-type="pmid">18853365</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sanderson</surname><given-names>M.J.</given-names></string-name></person-group> (<year>2002</year>) <article-title>Estimating absolute rates of molecular evolution and divergence times: A penalized likelihood approach</article-title>. <source>Mol. Biol. Evol</source>., <volume>19</volume>, <fpage>101</fpage>–<lpage>109</lpage>.<pub-id pub-id-type="pmid">11752195</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Szollosi</surname><given-names>G.J.</given-names></string-name></person-group><etal>et al</etal> (<year>2022</year>) <article-title>Relative time constraints improve molecular dating</article-title>. <source>Syst. Biol</source>., <volume>71</volume>, <fpage>797</fpage>–<lpage>809</lpage>.<pub-id pub-id-type="pmid">34668564</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tamura</surname><given-names>K.</given-names></string-name></person-group><etal>et al</etal> (<year>2012</year>) <article-title>Estimating divergence times in large molecular phylogenies</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>109</volume>, <fpage>19333</fpage>–<lpage>19338</lpage>.<pub-id pub-id-type="pmid">23129628</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Thorne</surname><given-names>J.L.</given-names></string-name></person-group><etal>et al</etal> (<year>1998</year>) <article-title>Estimating the rate of evolution of the rate of molecular evolution</article-title>. <source>Mol. Biol. Evol</source>., <volume>15</volume>, <fpage>1647</fpage>–<lpage>1657</lpage>.<pub-id pub-id-type="pmid">9866200</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>To</surname><given-names>T.-H.</given-names></string-name></person-group><etal>et al</etal> (<year>2016</year>) <article-title>Fast dating using least-squares criteria and algorithms</article-title>. <source>Syst. Biol</source>., <volume>65</volume>, <fpage>82</fpage>–<lpage>97</lpage>.<pub-id pub-id-type="pmid">26424727</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tofigh</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2011</year>) <article-title>Simultaneous identification of duplications and lateral gene transfers</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinform</source>., <volume>8</volume>, <fpage>517</fpage>–<lpage>535</lpage>.<pub-id pub-id-type="pmid">21233529</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Virtanen</surname><given-names>P.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>Scipy 1.0: Fundamental algorithms for scientific computing in python</article-title>. <source>Nat. Methods</source>, <volume>17</volume>, <fpage>261</fpage>–<lpage>272</lpage>.<pub-id pub-id-type="pmid">32015543</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Volz</surname><given-names>E.</given-names></string-name>, <string-name><surname>Frost</surname><given-names>S.</given-names></string-name></person-group> (<year>2017</year>) <article-title>Scalable relaxed clock phylogenetic dating</article-title>. <source>Virus Evol</source>., <volume>3</volume>(<issue>2</issue>), vex025.</mixed-citation>
    </ref>
    <ref id="btad084-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wolfe</surname><given-names>J.M.</given-names></string-name>, <string-name><surname>Fournier</surname><given-names>G.P.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Horizontal gene transfer constrains the timing of methanogen evolution</article-title>. <source>Nat. Ecol. Evol</source>., <volume>2</volume>, <fpage>897</fpage>–<lpage>903</lpage>.<pub-id pub-id-type="pmid">29610466</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yang</surname><given-names>Z.</given-names></string-name>, <string-name><surname>Rannala</surname><given-names>B.</given-names></string-name></person-group> (<year>2006</year>) <article-title>Bayesian estimation of species divergence times under a molecular clock using multiple fossil calibrations with soft bounds</article-title>. <source>Mol. Biol. Evol</source>., <volume>23</volume>, <fpage>212</fpage>–<lpage>226</lpage>.<pub-id pub-id-type="pmid">16177230</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yoder</surname><given-names>A.D.</given-names></string-name>, <string-name><surname>Yang</surname><given-names>Z.</given-names></string-name></person-group> (<year>2000</year>) <article-title>Estimation of primate speciation dates using local molecular clocks</article-title>. <source>Mol. Biol. Evol</source>., <volume>17</volume>, <fpage>1081</fpage>–<lpage>1090</lpage>.<pub-id pub-id-type="pmid">10889221</pub-id></mixed-citation>
    </ref>
    <ref id="btad084-B28">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Zuckerkandl</surname><given-names>E.</given-names></string-name>, <string-name><surname>Pauling</surname><given-names>L.</given-names></string-name></person-group> (<year>1962</year>) <article-title>Molecular disease, evolution, and genetic heterogeneity</article-title>. In: Kasha, M. and Pullman, B., (Eds.), <italic toggle="yes">Horizons in Biochemistry.</italic> Academic Press, New York, pp. <fpage>189</fpage>–<lpage>225</lpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
