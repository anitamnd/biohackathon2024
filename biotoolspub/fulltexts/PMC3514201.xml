<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3514201</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-13-48</article-id>
    <article-id pub-id-type="pmid">22443449</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-13-48</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Mapsembler, targeted and micro assembly of large NGS datasets on a desktop computer</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Peterlongo</surname>
          <given-names>Pierre</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>pierre.peterlongo@inria.fr</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Chikhi</surname>
          <given-names>Rayan</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>rayan.chikhi@irisa.fr</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>INRIA Rennes - Bretagne Atlantique, EPI Symbiose, Rennes, France</aff>
    <aff id="I2"><label>2</label>ENS Cachan/IRISA, EPI Symbiose, Rennes, France</aff>
    <pub-date pub-type="collection">
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>23</day>
      <month>3</month>
      <year>2012</year>
    </pub-date>
    <volume>13</volume>
    <fpage>48</fpage>
    <lpage>48</lpage>
    <history>
      <date date-type="received">
        <day>2</day>
        <month>9</month>
        <year>2011</year>
      </date>
      <date date-type="accepted">
        <day>24</day>
        <month>2</month>
        <year>2012</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright ©2012 Peterlongo and Chikhi; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2012</copyright-year>
      <copyright-holder>Peterlongo and Chikhi; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (
<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/13/48"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>The analysis of next-generation sequencing data from large genomes is a timely research topic. Sequencers are producing billions of short sequence fragments from newly sequenced organisms. Computational methods for reconstructing whole genomes/transcriptomes (<italic>de novo</italic> assemblers) are typically employed to process such data. However, these methods require large memory resources and computation time. Many basic biological questions could be answered targeting specific information in the reads, thus avoiding complete assembly.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We present <sc>Mapsembler</sc>, an iterative micro and targeted assembler which processes large datasets of reads on commodity hardware. <sc>Mapsembler</sc> checks for the presence of given regions of interest that can be constructed from reads and builds a short assembly around it, either as a plain sequence or as a graph, showing contextual structure. We introduce new algorithms to retrieve approximate occurrences of a sequence from reads and construct an extension graph. Among other results presented in this paper, <sc>Mapsembler</sc> enabled to retrieve previously described human breast cancer candidate fusion genes, and to detect new ones not previously known.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p><sc>Mapsembler</sc> is the first software that enables <italic>de novo</italic> discovery around a region of interest of repeats, SNPs, exon skipping, gene fusion, as well as other structural events, directly from raw sequencing reads. As indexing is localized, the memory footprint of <sc>Mapsembler</sc> is negligible. <sc>Mapsembler</sc> is released under the CeCILL license and can be freely downloaded from
<ext-link ext-link-type="uri" xlink:href="http://alcovna.genouest.org/mapsembler/">http://alcovna.genouest.org/mapsembler/</ext-link>.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Genomics witnessed an unprecedentedly deep change a few years ago with the arrival of the Next Generation Sequencers (NGS) also known as High Throughput Sequencing (HTS). These technologies enable sequencing of biological material (DNA and RNA) at much higher throughput and at cost that is now affordable to most academic labs. These new technologies generate gigabyte- or terabyte-scale datasets. The size of datasets is one of the two main bottlenecks for NGS. The other bottleneck is the analysis of generated data. Current technologies cannot output the entire sequence of a DNA molecule, instead they return small sequence fragments (<italic>reads</italic>) of length around a few hundred base pairs. Without a reference genome, reconstructing the entire sequence from these fragments (<italic>de novo assembly</italic> process) is challenging, especially in terms of computational resources. For instance, whole genome assembly of sequencing data from a mammalian genome requires hundreds of gigabytes of memory and several CPU weeks of computation
[<xref ref-type="bibr" rid="B1">1</xref>-<xref ref-type="bibr" rid="B3">3</xref>].</p>
    <p>With sequencing costs falling, sequencing efforts are no longer limited to the main species of interest (human and other primates, mouse, rat, <italic>E. coli</italic>, yeast, drosophila, …). Thus, biologists are increasingly working on data for which they do not have any close reference genome. In such situations, <italic>de novo</italic> assembly of reads is often carried out as a preliminary step. However, complete assembly is not always feasible, either because sequencing data is not adequate (insufficient coverage, genome too complex or many genomes present) or computational resources are too costly. Moreover, it should also be noted that assembly algorithms perform heuristics that lead to suboptimal reconstruction of the original sequence, possibly generating incomplete or erroneous fragments
[<xref ref-type="bibr" rid="B2">2</xref>,<xref ref-type="bibr" rid="B3">3</xref>]. Especially, highly-similar occurrences of a repeated sequence can be collapsed into a single fragment.</p>
    <p>We seek to establish that many biological questions can be answered by analyzing unassembled reads. In particular, the user may possess <italic>a priori</italic> information on which he wants to focus. In this spirit, we present the <sc>Mapsembler</sc> software. <sc>Mapsembler</sc> checks if a known piece of information - a sequence fragment called a <italic>starter</italic> - is present with a bounded number of substitutions in a set of reads. The starter can be shorter, longer or equal to the read length. If the starter is indeed present, <sc>Mapsembler</sc> constructs an assembly around the starter, either as a plain sequence, or as a graph showing divergences and convergences in the neighborhood structure. The read coverage per position is provided. The aim of <sc>Mapsembler</sc> is not to produce contigs as long as possible, hence it should not be used as a <italic>de novo</italic> assembler nor be directly compared with such software. Its aim, after the detection of the presence of approximate occurrences of a starter, is to output their neighborhoods on some hundreds or thousands of nucleotides, providing pieces of information about the starter context(s). As presented in the results section, these <italic>micro</italic> targeted assemblies provide relevant biological information such as the occurrences of elements known to be repeated, SNPs, gene fusions, alternative splicing events…</p>
    <p><sc>Mapsembler</sc> includes a simple yet effective error correction step removing most substitution errors present in the reads. As insertions and deletion errors are not corrected, <sc>Mapsembler</sc> performs better on reads provided by technologies generating a small amount of such errors as Illumina technology for instance.</p>
    <p>Another key aspect of <sc>Mapsembler</sc> is that its memory usage is independent from the size of the read sets. This enables <sc>Mapsembler</sc> to analyze huge sets of reads on a simple desktop computer.</p>
    <p><sc>Mapsembler</sc> inputs are a sequence fragment or a set of fragments called the <italic>starter(s)</italic>, and a set of reads. Applications of <sc>Mapsembler</sc> cover a broad range of biological questions, including but not limited to: </p>
    <p>• For a known biological event, e.g. a SNP (*), a splicing event (*) or a gene fusion (*), <sc>Mapsembler</sc> can be used to check its presence in a set of reads, and to provide abundances in each case. This is done by using as starter a fragment localizing the event.</p>
    <p>• Do these genes have close homologs in this set of reads (*)? Similarly, do these enzymes exist in this metagenomic set, or do these exons expressed in this [meta]transcriptomic set? Using genes or the enzymes or exons as starters, <sc>Mapsembler</sc> detects their presence and their approximate copies, and also reconstructs the genomic context for each copy. The exact coverage per position is provided both for the copies and for their contexts.</p>
    <p>• In case of complex genomes, one may be interested in finding approximate repeated occurrences of known sequence fragments (*). Using such sequence fragments as starters, their occurrences within a fixed Hamming distance are found and their flanking regions are recovered as a graph.Note that this approach is limited to a small number of slightly differing occurrences. Indeed, graph-based <sc>Mapsembler</sc> results are mainly designed to be visually inspected.</p>
    <p>•<sc>Mapsembler</sc> can be used to detect all reads corresponding to known contaminant organelles, or symbionts. This enables for instance to remove such reads from a dataset before further analysis.</p>
    <p>The symbol (*) indicates that an example of this use case is given in the Results section. Furthermore, it is important to note that <sc>Mapsembler</sc> operates without a reference genome.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>The <sc>Mapsembler</sc> algorithm can be divided into two main phases: </p>
    <p>1. <bold>Mapping</bold>. <sc>Mapsembler</sc> detects which starters correspond to consensuses of reads, subject to coverage constraints and up to a bounded number of substitutions. Such starters are said to be read coherent (see Section “Sub-starter generation and read coherence”).</p>
    <p>2. <bold>De novo assembly</bold>. Each read coherent starter is extended in both directions. In accordance to user choice: </p>
    <p>(a) the extension process is stopped as soon as several divergent extensions are detected. In this case, the output is a FASTA file containing the consensus assembly around each starter;</p>
    <p>(b) the extension process continues even in the case of several divergent possibilities. Extensions are represented as a directed graph. Each node stores a sequence fragment and its read coverage per position. This graph, is output in <italic>xgmml</italic> or <italic>graphml</italic> format. Several tools, including Gephi
[<xref ref-type="bibr" rid="B4">4</xref>], Cytoscape
[<xref ref-type="bibr" rid="B5">5</xref>], and Cobweb
[<xref ref-type="bibr" rid="B6">6</xref>] can be used to display such graph formats.</p>
    <p><sc>Mapsembler</sc> presents the advantage of not indexing reads but only starters (see next section for algorithmic explanations). In practice, independently of the size of the read file (even terabyte-sized), it is possible to run <sc>Mapsembler</sc> on any desktop or laptop computer, not requiring large memory facilities.</p>
    <p>The mapping phase performs several tasks. A maximum number <italic>d</italic>≥0 of substitutions (Hamming distance) is authorized between a starter and each read. Consequently, for a single starter <italic>s</italic>, several distinct read subsets that align to <italic>s</italic> yield distinct consensus sequences. These sequences are called sub-starters (see Section “Sub-starter generation and read coherence” for a formal definition), see Figure
<xref ref-type="fig" rid="F1">1</xref>a for an example. We discard sub-starters for which the distance to <italic>s</italic> exceeds <italic>d</italic>. A local assembly is initiated from the extremities of each sub-starter.</p>
    <fig id="F1" position="float">
      <label>Figure 1</label>
      <caption>
        <p><bold>Algorithm overview.</bold> Overview of the algorithm steps with reads of length 7, a minimal coverage of 2 and k-mers of length <italic>k</italic>=3. <bold>a)</bold> Representation of the sub-starter generation step. A set of reads is mapped to the starter <italic>s</italic>. First, reads are error-corrected according to a voting procedure (see lower right read for instance). Then, each sub-starter (<italic>s</italic><sub>1 </sub> and <italic>s</italic><sub>2</sub>) is computed from each perfect multiple read alignment. The Hamming distance between each sub-starter and <italic>s</italic> is required to be below a certain threshold. <bold>b)</bold> Representation of an extension. Three reads have prefix of length at least <italic>k</italic> mapping perfectly to the suffix of an extension <italic>s</italic>. All fragments of these reads longer than extension <italic>s</italic> are used for generating extension of <italic>s</italic>. As minimal coverage is 2, the last character of the first extending reads (<italic>T</italic>) is not stored for generating extension of <italic>s</italic>. The generated extension of <italic>s</italic> (<italic>ACT</italic>) is stored in a new node linked to extension <italic>s</italic>. Note that suffix of length <italic>k</italic>−1 of extension <italic>s</italic> (<italic>TC</italic>) is stored as prefix of extension of <italic>s</italic> (then called enriched extension). This avoids to omit overlapping <italic>k</italic>-mers between extensions such as <italic>TCA</italic> or <italic>CAC</italic> while mapping reads on extension of <italic>s</italic>.</p>
      </caption>
      <graphic xlink:href="1471-2105-13-48-1"/>
    </fig>
    <sec>
      <title>Definitions</title>
      <p>We first introduce some notations and definitions used throughout the paper. A sequence ∈<italic>Σ</italic><sup>∗</sup> is a concatenation of zero or more characters from an alphabet <italic>Σ</italic>. A sequence <italic>s</italic> of length <italic>n</italic> on <italic>Σ </italic> is represented by <italic>s</italic>[0]<italic>s</italic>[1]…<italic>s</italic>[<italic>n</italic>−1], where <italic>s</italic>[<italic>i</italic>]∈ <italic>Σ </italic> ∀ 0≤<italic>i</italic>&lt;<italic>n</italic>(if <italic>i</italic>&lt;0 or <italic>i</italic>≥<italic>n</italic> then <italic>s</italic>[<italic>i</italic>]=<italic>ε</italic>, the empty string). We denote by <italic>s</italic>[<italic>i</italic>,<italic>j</italic>] (<italic>j</italic>≥<italic>i</italic>) the sequence <italic>s</italic>[<italic>i</italic>]<italic>s</italic>[<italic>i</italic> + 1]…<italic>s</italic>[<italic>j</italic>] of <italic>s</italic>. The sequence <italic>s</italic>[<italic>i</italic>,<italic>j</italic>] occurs position <italic>i</italic> in <italic>s</italic>. Its length, denoted by [<italic>s</italic>[<italic>i</italic>,<italic>j</italic>]], is equal to <italic>j</italic>−<italic>i</italic> + 1. The Hamming distance <italic>d</italic><sub><italic>H</italic></sub>(<italic>ω</italic><sub>1</sub>,<italic>ω</italic><sub>2</sub>) between two sequences <italic>ω</italic><sub>1 </sub> and <italic>ω</italic><sub>2 </sub> of equal length is the number of positions at which the corresponding characters are different: </p>
      <p>
        <disp-formula id="bmcM1">
          <label>(1)</label>
          <mml:math id="M1" name="1471-2105-13-48-i1" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>d</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>H</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>(</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>ω</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:msub>
              <mml:mo>,</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>ω</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msub>
              <mml:mo>)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munderover>
                <mml:mrow>
                  <mml:mo mathsize="big">∑</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>0</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>&lt;</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>ω</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>|</mml:mo>
                </mml:mrow>
              </mml:munderover>
              <mml:mfenced open="{">
                <mml:mrow>
                  <mml:mtable>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mn>1</mml:mn>
                        <mml:mspace width="0.3em"/>
                        <mml:mtext>if</mml:mtext>
                        <mml:mspace width="2.77695pt"/>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>ω</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>[</mml:mo>
                        <mml:mspace width="0.3em"/>
                        <mml:mi>i</mml:mi>
                        <mml:mo>]</mml:mo>
                        <mml:mo>≠</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>ω</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>[</mml:mo>
                        <mml:mspace width="0.3em"/>
                        <mml:mi>i</mml:mi>
                        <mml:mo>]</mml:mo>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mn>0</mml:mn>
                        <mml:mspace width="0.3em"/>
                        <mml:mtext>else</mml:mtext>
                        <mml:mspace width="0.3em"/>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mrow>
              </mml:mfenced>
              <mml:mi>.</mml:mi>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <sec>
        <title>Definition 1 (<bold><italic>Hamming distance for overlapping sequences</italic></bold>)</title>
        <p>Given two sequences <italic>ω</italic><sub>1</sub> and <italic>ω</italic><sub>2</sub>∈<italic>Σ</italic><sup>∗</sup>, and
<inline-formula><mml:math id="M2" name="1471-2105-13-48-i2" overflow="scroll"><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:math></inline-formula>, we define <italic>d</italic><sub><italic>H</italic></sub>(<italic>ω</italic><sub>1</sub>,<italic>i</italic>,<italic>ω</italic><sub>2</sub>) as the hamming distance of the overlapping part between <italic>ω</italic><sub>1</sub> and <italic>ω</italic><sub>2</sub>, considering the first character of <italic>ω</italic><sub>2</sub> aligned to position <italic>i</italic> on <italic>ω</italic><sub>1</sub>. Formally,
<inline-formula><mml:math id="M3" name="1471-2105-13-48-i3" overflow="scroll"><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>ω</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ω</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>ω</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:munderover><mml:mi>d</mml:mi><mml:mfenced open="(" close=")"><mml:mrow><mml:msub><mml:mrow><mml:mi>ω</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mfenced open="[" close="]"><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ω</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>[</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mfenced></mml:math></inline-formula>, where
<inline-formula><mml:math id="M4" name="1471-2105-13-48-i4" overflow="scroll"><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>α</mml:mi><mml:mo>,</mml:mo><mml:mi>β</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfenced open="{"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn><mml:mspace width="2.83864pt"/><mml:mtext>if</mml:mtext><mml:mspace width="2.83864pt"/><mml:mi>α</mml:mi><mml:mspace width="2.83864pt"/><mml:mo>=</mml:mo><mml:mspace width="2.83864pt"/><mml:mi>β</mml:mi><mml:mspace width="2.83864pt"/><mml:mtext>or</mml:mtext><mml:mspace width="2.83864pt"/><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mi>ε</mml:mi><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn><mml:mspace width="2.83864pt"/><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:math></inline-formula>. The character <italic>ω</italic><sub>1</sub>[<italic>i</italic> + <italic>j</italic>] is equal to <italic>ε</italic>if a prefix of <italic>ω</italic><sub>2 </sub> is not aligned with <italic>ω</italic><sub>1</sub>(<italic>i</italic> + <italic>j</italic>&lt;0) and/or if a suffix of <italic>ω</italic><sub>2 </sub> is not aligned with <italic>ω</italic><sub>1</sub>(<italic>i</italic> + <italic>j</italic>≥|<italic>ω</italic><sub>1</sub>|).</p>
      </sec>
      <sec>
        <title>Definition 2 (<bold><italic>Mapped read</italic></bold>)</title>
        <p>Given a sequence <italic>s</italic>∈Σ<sup>∗</sup>, a read <italic>r</italic>∈Σ<sup>∗ </sup> is said to be mapped to <italic>s</italic> at position <italic>i </italic><italic>iff </italic><italic>d</italic><sub><italic>H</italic></sub>(<italic>s</italic>,<italic>i</italic>,<italic>r</italic>)≤<italic>d</italic>, where <italic>d</italic> is a fixed threshold.</p>
        <p>The notation
<inline-formula><mml:math id="M5" name="1471-2105-13-48-i5" overflow="scroll"><mml:mi>s</mml:mi><mml:msubsup><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msubsup><mml:mi>r</mml:mi></mml:math></inline-formula> denotes that <italic>r</italic> maps on <italic>s</italic> at position <italic>i</italic>, with threshold <italic>d</italic>.</p>
      </sec>
      <sec>
        <title>Example 1 (<bold><italic>Mapped read</italic></bold>)</title>
        <p>Given <italic>s</italic>=<italic>ATTCGGA</italic>, <italic>r</italic>=<italic>GAATGCG</italic> and threshold <italic>d</italic>=1,
<inline-formula><mml:math id="M6" name="1471-2105-13-48-i6" overflow="scroll"><mml:mi>s</mml:mi><mml:msubsup><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mi>r</mml:mi></mml:math></inline-formula> is true as <italic>d</italic><sub><italic>H</italic></sub>(<italic>s</italic>,−2,<italic>r</italic>)=1: </p>
        <p>
          <disp-formula id="bmcM2">
            <label>(2)</label>
            <mml:math id="M7" name="1471-2105-13-48-i7" overflow="scroll">
              <mml:mtable class="array" columnalign="left">
                <mml:mtr>
                  <mml:mtd>
                    <mml:mo>−</mml:mo>
                    <mml:mn>2</mml:mn>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mn>0</mml:mn>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mn>1</mml:mn>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mn>2</mml:mn>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mn>3</mml:mn>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mn>4</mml:mn>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mn>5</mml:mn>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mn>6</mml:mn>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:mi>s</mml:mi>
                    <mml:mo>=</mml:mo>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>A</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>T</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>G</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>C</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>G</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>G</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>A</mml:mi>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:mo>|</mml:mo>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mo>|</mml:mo>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mo>·</mml:mo>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mo>|</mml:mo>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mo>|</mml:mo>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:mi>r</mml:mi>
                    <mml:mo>=</mml:mo>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>G</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>A</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>A</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>T</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>T</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>C</mml:mi>
                  </mml:mtd>
                  <mml:mtd>
                    <mml:mi>G</mml:mi>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
      </sec>
    </sec>
    <sec>
      <title>Algorithm</title>
      <p>An overview of the whole process is presented in Algorithm 1. In a few words, the algorithm is divided into two main phases: the <bold>mapping phase</bold> (Steps 1 to 4 of Algorithm 1). This first phase is similar to seed-based mapping algorithms such as <sc>Gassst</sc>[<xref ref-type="bibr" rid="B7">7</xref>]. However, sub-starter generation (Step 4) is a novel algorithm presented in Section “Sub-starter generation and read coherence”. The second phase is the <bold>targeted</bold><bold><italic>de novo</italic></bold><bold>assembly phase</bold> (Steps 6 to 14). This phase extends sub-starter sequences similarly to greedy <italic>de novo</italic> assembly algorithms, such as SSAKE
[<xref ref-type="bibr" rid="B8">8</xref>]. Extensions are stored in a graph using a novel procedure (Steps 12 and 15) presented in Section “Graph management”.</p>
    </sec>
    <sec>
      <title>Algorithm 1: Mapsembler overview</title>
      <p><bold>Requires:</bold> Set of reads <italic>R</italic>, set of starters <italic>S</italic>, integer value <italic>k</italic>; <bold>Ensure:</bold> For each starter in <italic>S</italic>, the sub-starters and extensions </p>
      <p>1: Index the <italic>k</italic>-mers of <italic>S</italic></p>
      <p>2: Map reads <italic>R</italic> to each starter from <italic>S</italic>, using the <italic>k</italic>-mer index</p>
      <p>3: <bold>for all</bold><italic>s </italic> ∈ <italic>S </italic><bold>do</bold></p>
      <p>4: Using reads mapped to <italic>s</italic>, generate sub-startersof <italic>s</italic>.</p>
      <p>5: Add new sub-starters to <italic>Ex</italic><italic>t</italic><sub>0</sub>.</p>
      <p>6: <italic>i</italic>=0</p>
      <p>7: <bold>while</bold><italic>Ex</italic><italic>t</italic><sub><italic>i</italic></sub>≠<italic>∅</italic><bold>do</bold></p>
      <p>8: Free previous index, index <italic>Ex</italic><italic>t</italic><sub><italic>i </italic></sub> with <italic>k</italic>-mers</p>
      <p>9: Map reads <italic>R</italic> to sequences of <italic>Ex</italic><italic>t</italic><sub><italic>i</italic></sub>, using the<italic>k</italic>-mer index</p>
      <p>10: <bold>for all</bold><italic>s </italic> ∈ <italic> Ex</italic><italic>t</italic><sub><italic>i</italic></sub><bold>do</bold></p>
      <p>11: Using reads mapped to <italic>s</italic>, generate extensions of <italic>s</italic>.</p>
      <p>12: Create nodes containing the extensions &amp;manage graph</p>
      <p>13: Store all novel extensions in <italic>Ex</italic><italic>t</italic><sub><italic>i</italic> + 1</sub></p>
      <p>14: <italic>i </italic> = <italic> i </italic> + 1</p>
      <p>15: Simplify the created graphs</p>
      <p>16: For each starter in <italic>S</italic>, output its sub-starters and their extensions</p>
    </sec>
    <sec>
      <title>Explanation of Algorithm 1 steps</title>
      <p>• Step 1: An index of all <italic>k</italic>-mers that appear in the initial starter set <italic>S</italic> is created. For each sequence <italic>s</italic><sub><italic>id </italic></sub> belonging to the indexed set, and for each <italic>k</italic>-mer in <italic>s</italic><sub><italic>id</italic></sub>, a list of couples (<italic>s</italic><sub><italic>id</italic></sub>,<italic>p</italic><sub><italic>id</italic></sub>) is stored, with <italic>p</italic><sub><italic>id </italic></sub> being a position where the <italic>k</italic>-mer occurs in <italic>s</italic><sub><italic>id</italic></sub>. Note that, as a <italic>k</italic>-mer may occur more than once in a sequence <italic>s</italic><sub><italic>id</italic></sub>, several distinct couples may be stored for a given <italic>k</italic>-mer and a given <italic>s</italic><sub><italic>id</italic></sub>. All couples (<italic>s</italic><sub><italic>id</italic></sub>,<italic>p</italic><sub><italic>id</italic></sub>) of a given <italic>k</italic>-mer can be accessed in constant time using a hash table with the <italic>k</italic>-mer as key.</p>
      <p>• Step 2: input reads (and their reverse complement) are processed on the fly, only mapped reads are stored in memory. The mapping process is as follows. All <italic>k</italic>-mers of each read are used as seeds to attempt to map the read to the indexed sequences. After the entire set of reads is processed, an error correction step (described in the next paragraph) removes sequencing errors from mapped reads. Each error-corrected mapped read <italic>r</italic> (∃<italic>i</italic>such that
<inline-formula><mml:math id="M8" name="1471-2105-13-48-i8" overflow="scroll"><mml:mi>s</mml:mi><mml:msubsup><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msubsup><mml:mi>r</mml:mi></mml:math></inline-formula>) is stored in the set
<inline-formula><mml:math id="M9" name="1471-2105-13-48-i9" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
      <p>• Steps 8 and 9: Indexing of extensions <italic>Ex</italic><italic>t</italic><sub><italic>i </italic></sub> and read mapping are performed similarly to Steps 1 and 2. During these steps, reads have to perfectly agree with the extensions, hence read mapping is done with distance threshold <italic>d</italic>=0.</p>
      <p>• Step 11: For each sub-starter, extensions are always stored in a rooted directed string graph, each node containing a sequence fragment. A node storing a sequence <italic>s</italic> is denoted by <italic>N</italic><sub><italic>s</italic></sub>. The node storing the sub-starter itself is the root of the graph. For each sequence <italic>s </italic> ∈ <italic> Ex</italic><italic>t</italic><sub><italic>i</italic></sub>, using all error-corrected mapped reads
<inline-formula><mml:math id="M10" name="1471-2105-13-48-i10" overflow="scroll"><mml:msub><mml:mrow><mml:mi mathvariant="script">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>, detect those whose suffix stops after <italic>s</italic> ends (see Figure
<xref ref-type="fig" rid="F1">1</xref>b for an example). Those reads are used to compute the extension(s) of <italic>s</italic>, yielding three cases: </p>
      <p>1. An empty extension is found.</p>
      <p>2. Exactly one extension <italic>e</italic> is larger than <italic>s</italic>. Create a node <italic>N</italic><sub><italic>e</italic></sub>, and link the node <italic>N</italic><sub><italic>s </italic></sub> to the node <italic>N</italic><sub><italic>e</italic></sub>. Store the fragment <italic>e</italic> in <italic>Ex</italic><italic>t</italic><sub><italic>i</italic> + 1</sub>.</p>
      <p>3. Several extensions {<italic>e</italic><sub>1</sub>,<italic>e</italic><sub>2</sub>,…,<italic>e</italic><sub><italic>n</italic></sub>} are found, then: </p>
      <p>For simple sequence output, the longest common prefix <italic>p</italic> of all <italic>e</italic><sub><italic>i </italic></sub> is stored in a new node <italic>N</italic><sub><italic>p</italic></sub>. Link <italic>N</italic><sub><italic>s </italic></sub> to <italic>N</italic><sub><italic>p </italic></sub> for output purpose. As <italic>p</italic> is not stored in <italic>Ex</italic><italic>t</italic><sub><italic>i</italic> + 1</sub>, its extension stops.</p>
      <p>For graph output, link <italic>N</italic><sub><italic>s </italic></sub> to <italic>n</italic> new extending nodes each storing an extending fragment. All fragments in {<italic>e</italic><sub>1</sub>,<italic>e</italic><sub>2</sub>,…,<italic>e</italic><sub><italic>n</italic></sub>} are stored in <italic>Ex</italic><italic>t</italic><sub><italic>i</italic> + 1</sub>.</p>
      <p>• Step 12: Generate enriched extensions by adding suffix of <italic>s</italic> of length <italic>k</italic>−1 as prefix of each extension of <italic>s</italic> (see Figure
<xref ref-type="fig" rid="F1">1</xref>b). By adding such a prefix, we ensure that each node stores a sequence long enough (at least <italic>k</italic>) to be indexed and then exploited for next extensions and that each <italic>k</italic>-mer, including those overlapping nodes are considered as seeds.</p>
      <p>Step 13: Novel extensions are those corresponding to nodes which are not already present in the graph (see Section “Graph management”).</p>
      <p>Step 16: In case of simple sequence format, the extensions graph of each sub-starter do not contain branching nodes. A simple traversal provides the consensus sequence of the contig containing the sub-starter.</p>
      <sec>
        <title>Error correction</title>
        <p>Actual sequencing reads are error-prone, therefore error correction mechanisms are implemented inside the mapping phase. At Steps 2 and 9, error-prone reads are mapped to starters. An error correction phase is performed immediately after both of these steps, by taking advantage of the multiple read alignments. This procedure is based on nucleotide votes, similarly to greedy assemblers
[<xref ref-type="bibr" rid="B8">8</xref>], under the assumption that erroneous nucleotides are less represented than correct nucleotides. Specifically, at each position relative to the starter, the count of each nucleotide is recorded. Given a threshold <italic>t</italic>, a read position is considered to be correct if the corresponding nucleotide at this position is seen at least <italic>t</italic> times. Otherwise, if only one other nucleotide appears over <italic>t</italic> times at this position, the read position is corrected by assigning this other nucleotide (Figure
<xref ref-type="fig" rid="F1">1</xref>a, circled position). In the remaining case, where many possible nucleotides can possibly correct a read position, no correction occurs, and the read is truncated before this position.</p>
        <p>We now provide deeper algorithmic explanations for sub-starter generation (Step 4) and the graph management (Steps 12 and 15). The remaining steps (read mapping and greedy sequence extensions) are classically well known
[<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B8">8</xref>].</p>
      </sec>
    </sec>
    <sec>
      <title>Sub-starter generation and read coherence</title>
      <p>The sub-starter generation and read coherence step take place immediately after the mapping phase (Step 4). Given a starter <italic>s</italic> and mapped reads <italic>R</italic>, this step generates a finite set (<italic>s</italic><sub><italic>i</italic></sub>) of sequences (called <italic>sub-starters</italic>) which: </p>
      <p>originate from the reads, i.e. each <italic>s</italic><sub><italic>i</italic></sub> is a consensus sequence of a subset of reads from <italic>R</italic>,</p>
      <p>are coherent with the starter <italic>s</italic>, i.e. the Hamming distance between <italic>s</italic> and <italic>s</italic><sub><italic>i </italic></sub> is at most <italic>d</italic>.</p>
      <p>are significantly represented, i.e. each position of <italic>s</italic><sub><italic>i </italic></sub> is covered by at least <italic>c</italic> reads.</p>
      <p>A starter is <italic>read coherent</italic> if it yields at least one sub-starter. We are interested in retrieving the largest set of sub-starters for each starter <italic>s</italic>. This can be formulated as the following computational problem. To simplify the presentation, reads are assumed to contain no errors. In practice, the read correction step (previous paragraph) effectively corrects or discards erroneous reads.</p>
      <sec>
        <title>Problem 1 (<bold><italic>Multiple consensuses from read alignments</italic></bold>)</title>
        <p>Given a starter <italic>s</italic>, two parameters <italic>c</italic>, <italic> d </italic> ≥ 0 and a set of error-free mapped reads
<inline-formula><mml:math id="M11" name="1471-2105-13-48-i11" overflow="scroll"><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mspace width="2.83864pt"/><mml:mtext>such that s</mml:mtext><mml:msubsup><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:math></inline-formula> (each read <italic>r</italic><sub><italic>i </italic></sub> is aligned to <italic>s</italic> at a position <italic>p</italic><sub><italic>i </italic></sub> with at most <italic>d</italic> substitutions), find all maximal (with respect to the inclusion order) subsets <italic>S</italic><sub><italic>i </italic></sub> of <italic>R</italic> satisfying: </p>
        <p>1. each subset <italic>S</italic><sub><italic>i </italic></sub> admits a perfect consensus <italic>s</italic><sub><italic>i</italic></sub>, i.e. each read <italic>r</italic><sub><italic>i </italic></sub> aligns to <italic>s</italic><sub><italic>i </italic></sub> at position <italic>p</italic><sub><italic>i </italic></sub> (relative to <italic>s</italic>) with no mismatch:
<inline-formula><mml:math id="M12" name="1471-2105-13-48-i12" overflow="scroll"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>,</p>
        <p>2. the consensus <italic>s</italic><sub><italic>i </italic></sub> aligns <italic>s</italic> with at most <italic>d</italic> mismatches:
<inline-formula><mml:math id="M13" name="1471-2105-13-48-i13" overflow="scroll"><mml:mi>s</mml:mi><mml:msubsup><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>,</p>
        <p>3. each position of <italic>s</italic> is covered by at least <italic>c</italic> reads in <italic>S</italic><sub><italic>i</italic></sub>.</p>
        <p>A trivial (exponential) solution is (i) to generate the power set (all possible subsets) of <italic>R</italic>, (ii) remove sets which do no satisfy one of the propositions above, and (iii) keep only maximal sets (ordered by inclusion). The exponential complexity of this solution clearly comes from step (i). In Algorithm 2, we give a polynomial time (in the number of mapped reads) procedure which subsumes (i), as it generates a solution which includes all the correct subsets.</p>
        <p>The completeness proof that Algorithm 2 finds all maximal subsets corresponding to correct sub-starters is as follows. The proof is by contradiction: let <italic>s</italic> be a correct sub-starter not found by the algorithm. Let <italic>r</italic><sub>1</sub>,…,<italic>r</italic><sub><italic>n</italic></sub> be the maximal subset of reads which yields <italic>s</italic>, sorted by increasing mapping positions to <italic>f</italic>. We show by induction that the algorithm returns a subset which includes <italic>r</italic><sub>1</sub>,…,<italic>r</italic><sub><italic>k</italic></sub>, for <italic>k</italic>∈[1<italic>.n</italic>]. For <italic>k</italic>=1, notice that a subset is assigned to each read. Assuming <italic>r</italic><sub>1</sub>,…,<italic>r</italic><sub><italic>k </italic></sub> is part of a returned subset <italic>S</italic><sub>0</sub>, we show that <italic>r</italic><sub>1</sub>,…,<italic>r</italic><sub><italic>k</italic> + 1</sub> is also returned. Since <italic>r</italic><sub><italic>k</italic> + 1</sub> is part of a subset which yields <italic>s</italic>, it overlaps perfectly with <italic>r</italic><sub><italic>k</italic></sub>. However, <italic>r</italic><sub><italic>k</italic> + 1</sub> does not necessarily belong to <italic>S</italic><sub>0</sub>. Let
<inline-formula><mml:math id="M14" name="1471-2105-13-48-i14" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> be the read which follows <italic>r</italic><sub><italic>k</italic></sub> in <italic>S</italic><sub>0</sub>. In the ordering of the reads by increasing position, if the read <italic>r</italic><sub><italic>k</italic> + 1</sub>is seen before
<inline-formula><mml:math id="M15" name="1471-2105-13-48-i15" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula>, then the algorithm selects
<inline-formula><mml:math id="M16" name="1471-2105-13-48-i16" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula>. Else, as <italic>r</italic><sub><italic>k</italic> + 1</sub> perfectly overlaps with <italic>r</italic><sub><italic>k</italic></sub>, a new subset is created from <italic>S</italic><sub>0</sub>, which contains exactly <italic>r</italic><sub>1</sub>,…,<italic>r</italic><sub><italic>k</italic> + 1</sub>. Eventually, from the induction, a subset which contains <italic>r</italic><sub>1</sub>,…,<italic>r</italic><sub><italic>n</italic></sub> is constructed. Since <italic>r</italic><sub>1</sub>,…,<italic>r</italic><sub><italic>n</italic></sub> is itself maximal, the subset found by the algorithm is exactly <italic>r</italic><sub>1</sub>,…,<italic>r</italic><sub><italic>n</italic></sub>.</p>
        <p>Note that Algorithm 2 may return subsets which do not satisfy all the three conditions (e.g. coverage of <italic>s</italic> after the last aligned read position <italic>p</italic> is not checked), hence steps (ii) and (iii) are still required. The running time of the algorithm is now analyzed. Observe that during the algorithm execution, each intermediate subset in <italic>S</italic> is included in a distinct final maximal subset. There are at most |<italic>Σ</italic>|<sup><italic>d</italic></sup> maximal subsets, one for each combination of substitutions with <italic>s</italic>. Hence, there are <italic>O</italic>(|<italic>Σ</italic>|<sup><italic>d</italic></sup>) intermediate subsets at any time. Assuming that the read length is bounded by a constant, the overlap detection steps 4 and 7 can be performed in <italic>O</italic>(|<italic>R</italic>|) time. Hence, the time complexity of Algorithm 2 is <italic>O</italic>(|<italic>Σ</italic>|<sup><italic>d</italic></sup>|<italic>R</italic>|<sup>2</sup>), where in practice <italic>d</italic> is a small constant, and |<italic>Σ</italic>|=4 on genomic sequences.</p>
      </sec>
    </sec>
    <sec>
      <title>Algorithm 2: Generating candidate subsets <italic>S</italic><sub><italic>i </italic></sub> for solving the multiple consensuses from read alignments problem</title>
      <p><bold>Requires:</bold> Set of reads <italic>R</italic>, starter <italic>s</italic>, minimum consensus <italic>c</italic>≥0, distance threshold <italic>d</italic>≥0; <bold>Ensure:</bold> Set <italic>S</italic> of candidate subsets. </p>
      <p>1: <italic>S</italic>=<italic>∅</italic>.</p>
      <p>2: <bold>for</bold> each read (<italic>r</italic>,<italic>p</italic>) in <italic>R</italic> ordered by alignment position <bold>do</bold></p>
      <p>3: <bold>for</bold> each subset <italic>S</italic><sub><italic>i </italic></sub> in <italic>S</italic><bold>do</bold></p>
      <p>4: <bold>if</bold> r overlaps without substitutions with the lastread of <italic>S</italic><sub><italic>i </italic></sub><bold>then</bold></p>
      <p>5: Add <italic>r</italic> to <italic>S</italic><sub><italic>i</italic></sub>.</p>
      <p>6: <bold>else</bold></p>
      <p>7: <bold>if</bold><italic>r</italic> overlaps without substitutions with oneof the reads of <italic>S</italic><sub><italic>i </italic></sub><bold>then</bold></p>
      <p>8: Let (<italic>r</italic><sup><italic>′</italic></sup>, <italic>p</italic><sup><italic>′</italic></sup>) be the last read of <italic>S</italic><sub><italic>i </italic></sub> overlapping with <italic>r</italic>.</p>
      <p>9: Let <italic>T</italic> be the subset of <italic>S</italic><sub><italic>i</italic></sub> of all reads up to(<italic>r</italic><sup><italic>′</italic></sup>,<italic>p</italic><sup><italic>′</italic></sup>).</p>
      <p>10: Create a new subset <italic>S</italic><sup><italic>′</italic></sup>=<italic>T</italic>∪{<italic>r</italic>}.</p>
      <p>11: Insert <italic>S</italic><sup><italic>′</italic></sup> into <italic>S</italic>.</p>
      <p>12: <bold>if</bold><italic>r</italic> was not appended to any subset <bold>then</bold></p>
      <p>13: Create a new subset with <italic>r</italic> and insert it into <italic>S</italic>.</p>
      <p>14: Remove any subset from <italic>S</italic> if its consensus hasmore than <italic>d</italic> differences with <italic>s</italic>, or a position before <italic>p</italic> is covered by less than <italic>c</italic> reads.</p>
      <p>15: <bold>return </bold><italic>S</italic>.</p>
    </sec>
    <sec>
      <title>Graph management</title>
      <sec>
        <title>Adding a node</title>
        <p>Several biological events such as a SNP, an indel, or exon skipping, create two or more distinct paths in the extension graph. These paths eventually converge and continue with an identical sequence. Consequently, path convergence is checked during the iterative assembly phase (Algorithm 1, Step 12). When a sequence <italic>s</italic> is extended with extension <italic>e</italic>, the algorithm checks if <italic>e</italic> is not already present in the graph in a node
<inline-formula><mml:math id="M17" name="1471-2105-13-48-i17" overflow="scroll"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:math></inline-formula>. To do this, the last <italic>k</italic>-mer of the sequence of each node is indexed in a hash table. Checking if <italic>e</italic> is already present in the graph is done using <italic>k</italic>-mers of <italic>e</italic> and this last index as seeds for mapping. If the overlap of <italic>e</italic> on the sequence of a node
<inline-formula><mml:math id="M18" name="1471-2105-13-48-i18" overflow="scroll"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:math></inline-formula> is perfect (<italic>i.e.</italic><inline-formula><mml:math id="M19" name="1471-2105-13-48-i19" overflow="scroll"><mml:mo>∃</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.3em"/><mml:msup><mml:mrow><mml:mtext>such that s</mml:mtext></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:msubsup><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msubsup><mml:mi>e</mml:mi></mml:math></inline-formula>) then <italic>N</italic><sub><italic>s</italic></sub> is linked to
<inline-formula><mml:math id="M20" name="1471-2105-13-48-i20" overflow="scroll"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:math></inline-formula>. If <italic>i</italic>&lt;0, an intermediate node containing the prefix of <italic>e</italic> not mapped on <italic>s</italic><sup><italic>′</italic></sup> is added between <italic>N</italic><sub><italic>s</italic></sub> and
<inline-formula><mml:math id="M21" name="1471-2105-13-48-i21" overflow="scroll"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:math></inline-formula>. If <italic>i</italic>&gt;0, the suffix of length <italic>i</italic> of <italic>s</italic> is pruned from node <italic>N</italic><sub><italic>s</italic></sub> as it is already present in node
<inline-formula><mml:math id="M22" name="1471-2105-13-48-i22" overflow="scroll"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <title>Graph simplification</title>
        <p>Once extensions are finished, each graph is simplified as follows: </p>
        <p>As presented in Figure
<xref ref-type="fig" rid="F2">2</xref>a-b, enriched extensions are transformed into extensions, by removing the first <italic>k</italic>−1 characters of each internal node except the root. This removes redundant information in nodes.</p>
        <p>Two nodes <italic>N</italic><sub><italic>s</italic></sub> and
<inline-formula><mml:math id="M23" name="1471-2105-13-48-i23" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> are merged into node
<inline-formula><mml:math id="M24" name="1471-2105-13-48-i24" overflow="scroll"><mml:mtext mathvariant="italic">Ns.</mml:mtext><mml:mo>.</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> if and only if <italic>N</italic><sub><italic>s</italic></sub> has only
<inline-formula><mml:math id="M25" name="1471-2105-13-48-i25" overflow="scroll"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:math></inline-formula> as successor while
<inline-formula><mml:math id="M26" name="1471-2105-13-48-i26" overflow="scroll"><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:math></inline-formula> has only <italic>N</italic><sub><italic>s</italic></sub> as predecessor. This is a classical concatenation of simple paths. See Figure
<xref ref-type="fig" rid="F2">2</xref>a-b for an example.</p>
        <p>For all nodes successors of a node <italic>N</italic><sub><italic>s</italic></sub> having only <italic>N</italic><sub><italic>s</italic></sub> as predecessor, their longest common prefix <italic>pre</italic> is pruned and factorized as suffix of the sequence stored in <italic>N</italic><sub><italic>s</italic></sub>, thus generating node <italic>N</italic><sub><italic>s.pre</italic></sub>. Similarly, for all nodes predecessors of a node <italic>N</italic><sub><italic>s</italic></sub> having only <italic>N</italic><sub><italic>s</italic></sub> as successor, their longest common suffix <italic>suf</italic> is pruned and factorized as prefix of the sequence stored in <italic>N</italic><sub><italic>s</italic></sub>, thus generating node <italic>N</italic><sub><italic>suf.s</italic></sub>. This simplification relocates branching in the graph, to the exact position where sequences diverge and converge. See Figure
<xref ref-type="fig" rid="F2">2</xref>c for an example.</p>
        <fig id="F2" position="float">
          <label>Figure 2</label>
          <caption>
            <p><bold>Graph simplification.</bold> Graph simplification (Algorithm 1, Step 15). <bold>a)</bold> the graph before simplification. <bold>b)</bold> After removing the first <italic>k</italic>−1 characters of each internal node and after merging non branching nodes. <bold>c)</bold> After common prefix and suffix factorizations.</p>
          </caption>
          <graphic xlink:href="1471-2105-13-48-2"/>
        </fig>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Availability and requirements</title>
    <p><sc>Mapsembler</sc> is released under CeCILL License. It can be downloaded from
<ext-link ext-link-type="uri" xlink:href="http://alcovna.genouest.org/mapsembler/">http://alcovna.genouest.org/mapsembler/</ext-link>website. The download comes with documentation about installation and usage. A <sc>Mapsembler</sc> newsletter is also available from this address.</p>
  </sec>
  <sec sec-type="results">
    <title>Results</title>
    <p>All presented results were obtained on a 2.66 Ghz dual-core laptop with 3 MB cache and 4 GB RAM memory.</p>
    <p>For each experiments presented in this manuscript, details about datasets, <sc>Mapsembler</sc> commands and results are packed in Additional file
<xref ref-type="supplementary-material" rid="S1">1</xref>. When read datasets are public, a link to a download address is provided in the archive. When they are not, only reads used by <sc>Mapsembler</sc> during mapping and assembly phases are provided.</p>
    <p>In Figures representing graphs, the node size indicates average read coverage in the sequence and the node border size indicates the length of the sequence.</p>
    <p>Note that <sc>Mapsembler</sc> is not designed to be a whole genome assembler, thus classical assembly statistics (N50, genome coverage, …) do not apply. Apart from nucleotide accuracy and rate of misjoins, quality measures for <italic>de novo</italic> targeted genome assembly are, to the best of our knowledge, not defined.</p>
    <sec>
      <title>Mapsembler and the state of the art</title>
      <p>Targeted assembly should not be confused with Sanger-generation, localized BAC-by-BAC assembly methods (e.g. Atlas
[<xref ref-type="bibr" rid="B9">9</xref>]). BAC-by-BAC sequencing is typically not performed anymore in second-generation sequencing. <sc>Mapsembler</sc> computes targeted assemblies within a whole-genome set of short reads, i.e. without any localized sequencing process. To date, we are aware of only one related targeted assembly method in the literature, <sc>Tasr</sc>[<xref ref-type="bibr" rid="B10">10</xref>].</p>
      <p><sc>Tasr</sc> is based on the <sc>Ssake</sc> assembler
[<xref ref-type="bibr" rid="B8">8</xref>]. It maps a set of reads on targets (starters) using seeds of length 15. Mapping between a read and a target is tested if at least one sequence of length 15 exactly matches both. <sc>Tasr</sc> outputs the result of this mapping, including extensions obtained from reads mapped to extremities of starters. Similarly to <sc>Mapsembler</sc>, <sc>Tasr</sc> indexes only targets, hence memory requirements do not depend on the size of the read file. <sc>Mapsembler</sc> significantly differs from <sc>Tasr</sc> as it offers the following novel features: </p>
      <p>sub-starters retrieval;</p>
      <p>multiple iterations to extend starters as far as possible. This is equivalent to re-running <sc>Tasr</sc> multiple times, using its results as starters;</p>
      <p>graph output of the left and right neighborhood of starters.</p>
      <p>We compared <sc>Tasr</sc> and <sc>Mapsembler</sc> time and memory performances using a set of 6.5 millions of short reads of length 36 (unpublished Illumina aphid RNA-seq). We ran <sc>Mapsembler</sc> without iterative extensions and set seeds length to 15, to match <sc>Tasr</sc> behavior.</p>
      <p>Using a unique randomly selected read as starter, <sc>Mapsembler</sc> finished in 40 seconds, using 2.15 MB of memory, while <sc>Tasr</sc> finished in 165 seconds using 4.21 MB of memory. On a larger set of 500 starters randomly selected from reads, <sc>Mapsembler</sc> finished in 59 seconds using 23.8 MB of memory. <sc>Tasr</sc> was stopped after 10 hours, while using 287 MB of memory. Note that in both cases, <sc>Mapsembler</sc> produces strictly more results than <sc>Tasr</sc> as it detects and extends all the sub-starters of each starter.</p>
      <p>The iterative mapping and assembly strategies are also used in the IMAGE approach
[<xref ref-type="bibr" rid="B11">11</xref>], although in a different context. IMAGE maps paired-end reads to a pre-assembled set of contigs in order to extend contig lengths and close gaps. <sc>Mapsembler</sc> could theoretically be used to extend contigs with unpaired reads, but does not perform automated gap closing. In practice <sc>Mapsembler</sc> is an orthogonal approach to IMAGE, as it aims to replace whole-genome assembly for a subset of biological questions.</p>
    </sec>
    <sec>
      <title>Assembly accuracy</title>
      <p>The accuracy of <sc>Mapsembler</sc> targeted assemblies is assessed. We performed targeted assembly of 50 starters of length 37 nt sampled uniformly from the <italic>E. coli</italic> genome. These starters were assembled using 20.8 M raw Illumina reads (SRA: SRX000429). Mapsembler was run with default parameters and <italic>d</italic>=0, to discard sub-starters which do not correspond exactly to starters. Using 40 iterations, <sc>Mapsembler</sc> returned 50 extended sub-starters of average length 812 nt. We computed global alignments between Mapsembler extensions and the reference genome. For each alignment, the reported accuracy corresponds to the ratio of the number of substitutions and mismatches over the number aligned bases. Each targeted assembly aligns with more than 99% accuracy, and no misjoin was produced. Specifically, 97.8% of the extensions were perfectly aligned. This level of accuracy is consistent with that of whole-genome <italic>de novo</italic> assemblers. For instance, 96.5% of the contigs from a SOAPdenovo
[<xref ref-type="bibr" rid="B12">12</xref>] whole-genome assembly of the same dataset align perfectly to the reference.</p>
    </sec>
    <sec>
      <title>Dealing with large data sets</title>
      <p>In this section, we focus exclusively on <sc>Mapsembler</sc> time and memory requirements. From the NCBI Sequence Read Archive, we downloaded a human NA12878 Illumina run containing 105 million reads of length 101 (SRR068330, total 10.6 Gbases). Five subsets, <italic>S</italic><sub>10<italic>K</italic></sub>, <italic>S</italic><sub>100<italic>K</italic></sub>, <italic>S</italic><sub>1<italic>M</italic></sub>, <italic>S</italic><sub>10<italic>M</italic></sub>, and <italic>S</italic><sub>100<italic>M</italic></sub>, were generated by random sampling of 10<sup>5</sup>, 10<sup>6</sup>, 10<sup>7</sup>, 10<sup>8</sup> and 10<sup>9</sup> reads. A targeted assembly of 10 randomly selected reads as starters was performed using <sc>Mapsembler</sc> with default options.</p>
      <p>Results summarized in Table
<xref ref-type="table" rid="T1">1</xref> show that memory requirement does not depend on the read file size. Note that a read file containing 9.9 Gbases (<italic>S</italic><sub>100<italic>M</italic></sub> data set) was analyzed using &lt;1.5 MB of memory. These results also show that computation time is reasonable even on such large data sets as time linearly increases with the number of starters. On average on the <italic>S</italic><sub>100<italic>M</italic></sub> data set, checking read coherence of all starters took 1813 seconds while one extension of all sequence fragments took 903 seconds. <sc>Mapsembler</sc> computation time grows linearly with respect to the number of input starters and the number of computed extensions. Note that an option enables to limit the number of extensions, and note that if manually stopped, <sc>Mapsembler</sc> outputs results obtained so far.</p>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p>Mapsembler time and memory requirements on large data-sets</p>
        </caption>
        <table frame="hsides" rules="groups" border="1">
          <colgroup>
            <col align="left"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
            <col align="center"/>
          </colgroup>
          <thead valign="top">
            <tr>
              <th align="left">
                <bold>Reads data set</bold>
              </th>
              <th align="left">
                <bold>Mapping time (s)</bold>
              </th>
              <th align="left">
                <bold>Assembly time (s)</bold>
              </th>
              <th align="left">
                <bold>Total time (s)</bold>
              </th>
              <th align="left">
                <bold>Memory (MB)</bold>
              </th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" valign="bottom">
                <italic>S</italic>
                <sub>10<italic>K</italic></sub>
                <hr/>
              </td>
              <td align="center" valign="bottom">&lt;1<hr/></td>
              <td align="center" valign="bottom">&lt;1<hr/></td>
              <td align="center" valign="bottom">1<hr/></td>
              <td align="center" valign="bottom">&lt;1.5<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">
                <italic>S</italic>
                <sub>100<italic>K</italic></sub>
                <hr/>
              </td>
              <td align="center" valign="bottom">1<hr/></td>
              <td align="center" valign="bottom">2<hr/></td>
              <td align="center" valign="bottom">5<hr/></td>
              <td align="center" valign="bottom">&lt;1.5<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">
                <italic>S</italic>
                <sub>1<italic>M</italic></sub>
                <hr/>
              </td>
              <td align="center" valign="bottom">14<hr/></td>
              <td align="center" valign="bottom">6<hr/></td>
              <td align="center" valign="bottom">40<hr/></td>
              <td align="center" valign="bottom">&lt;1.5<hr/></td>
            </tr>
            <tr>
              <td align="left" valign="bottom">
                <italic>S</italic>
                <sub>10<italic>M</italic></sub>
                <hr/>
              </td>
              <td align="center" valign="bottom">170<hr/></td>
              <td align="center" valign="bottom">95<hr/></td>
              <td align="center" valign="bottom">442<hr/></td>
              <td align="center" valign="bottom">&lt;1.5<hr/></td>
            </tr>
            <tr>
              <td align="left">
                <italic>S</italic>
                <sub>100<italic>M</italic></sub>
              </td>
              <td align="center">1813</td>
              <td align="center">903</td>
              <td align="center">3983</td>
              <td align="center">&lt;1.5</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Time and memory requirements for targeted assembly of 10 starters using increasingly large human genome read data sets. Mapping time corresponds to the mapping phase (Algorithm 1, Steps 1 to 5). Assembly time corresponds to the assembly phase (Steps 18 to 14) per iteration.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>Recovering environments of repeat occurrences</title>
      <p>We analyzed a dataset of 20.8 M raw Illumina reads (SRA: SRX000429) from <italic>E. coli K12</italic> using as starter a sub-sequence of the reference genome (chr:15,387-16,731) containing Inserted Sequences IS186 and IS421 transposase. This fragment has six exact occurrences on the reference genome. Using 3 iterations, <sc>Mapsembler</sc> needed 202 seconds and 1.5 MB of memory to produce the graph presented in Figure
<xref ref-type="fig" rid="F3">3</xref>. The graph yields neighbor sequences of all occurrences of this repeat. The six occurrences were exactly recovered by <sc>Mapsembler</sc>. Where classical whole genome assemblers interrupt an assembly, <sc>Mapsembler</sc> retrieves the environments of the occurrences of a repeat. In this case, the exact number of occurrences can be directly inferred from <sc>Mapsembler</sc> graph structure.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Repeated starter.</bold> Graph obtained using a repeat occurrence as starter. To be readable the prefixes of left extensions and the suffixes of right extensions, as well as the core or the starter are truncated.</p>
        </caption>
        <graphic xlink:href="1471-2105-13-48-3"/>
      </fig>
    </sec>
    <sec>
      <title>Detecting AluY sub-families in a personal genome</title>
      <p><italic>Alu</italic> elements are a family of highly-repeated, ≈300 bp sequences found in primate genomes. Sub-families of the AluY family are characterized by known evolutionary mutations. We demonstrate how <sc>Mapsembler</sc> can be used to detect the AluY sub-families present in a set of reads.</p>
      <p>We downloaded a dataset of high-coverage, NA12878 chromosome 19 reads from the 1000 Genomes project. We selected bases 60-120 of the RepBase
[<xref ref-type="bibr" rid="B13">13</xref>] consensus sequence of AluY as a starter, as prior knowledge indicates that no indel occurs inside this region. <sc>Mapsembler</sc> then processed on the whole dataset (65 M reads) to recover sub-starters, without extending them. <sc>Mapsembler</sc> error and coverage thresholds were increased according to the coverage of the dataset, and 5 substitutions were allowed between the starter and each sub-starter.</p>
      <p>A total of 58,656 reads mapped to the 60 bp starter and 8 sub-starters were constructed by <sc>Mapsembler</sc>. We examine the specificity of <sc>Mapsembler</sc> by verifying that sub-starters correspond to known consensus sequences. We annotated each sub-starter using sub-families consensus sequences
[<xref ref-type="bibr" rid="B14">14</xref>] and the NA12878 reference sequence
[<xref ref-type="bibr" rid="B15">15</xref>].<monospace>starter TCACGAGGTCAGGAGATCGAGACCATCCTGGCTAACACGGTGAAACCCCGTCTCTACTAA AluY substarter_0 ---CG---------------------------C---------------CG---------- AluSgsubstarter_1 ---CA---------------------------T---------------CA---------- substarter_2 ---CG---------------------------T---------------CA---------- chr19_maternal 517189substarter_3 ---TG---------------------------T---------------CA---------- substarter_4 ---CG---------------------------T---------------TG---------- chr19_maternal 887598substarter_5 ---CG---------------------------T---------------CG---------- AluY (starter)substarter_6 ---CA---------------------------T---------------CG---------- chr19_maternal 461151substarter_7 ---TG---------------------------T---------------CG---------- AluYb8</monospace></p>
      <p>Several sub-starters (1, 2, 3, 4 and 6) did not exactly correspond to a known Alu consensus sequence. We manually verified that all these sub-starters are valid as follows. Sub-starters 2, 4, 5 and 6 (resp. 2, 4 and 5) align perfectly to the NA12878 maternal (resp. paternal) reference. Mutations of sub-starters 2 and 4 (bases 50 and 49 respectively) are also found in Alu Ya5
[<xref ref-type="bibr" rid="B16">16</xref>]. As further evidence, sub-sequences specific to each substarters (bases 3 to 50) are abundantly present as exact substrings in the reads. For instance, bases 3 to 50 of the remaining unidentified sub-starters (1 and 3) are present in respectively 73 and 76 reads. Consequently, the possibility that sub-starters 1 and 3 are artifacts was ruled out.</p>
    </sec>
    <sec>
      <title>Gene detection in a different strain</title>
      <p>The folA gene (dihydrofolate reductase) is present in several strains of <italic>E. coli</italic>, including <italic>K12</italic> (chr:49,823-50,302) and O157:H7 (chr:54,238-54,717). The sequence of this gene is not exactly similar between the K-12 and O157:H7 strains (10 single-nucleotide mutations across 479 bp). We attempted to recover the O157:H7 gene sequence of the folA gene, using only sequencing reads and prior knowledge of the K-12 sequence. To this end, we analyzed a dataset of 15.7 M raw reads of length 70 bp (SRA:ERR018562) from <italic>E. coli O157:H7</italic>. The K-12 allele of the folA gene (length 479 bp, NCBI ID:944790) was used as the starter. The sub-starter generation module of <sc>Mapsembler</sc> confirmed the presence of the gene, and furthermore recovered the exact O157:H7 gene sequence of folA from the reads (100% identity with O157:H7 reference). <sc>Mapsembler</sc> performed this experiment in 572 seconds and using 1.5 MB of memory.</p>
    </sec>
    <sec>
      <title>Detection of known biological events in <italic>Drosophila</italic></title>
      <p>In this section, one Illumina HiSeq2000 RNA-Seq run of 22.5 million reads of length 70 nt from Drosophila Melanogaster is analyzed (data not published). As presented in upcoming sections, <sc>Mapsembler</sc> enables to check for the presence or absence of a putative biological event for which one has an a priori knowledge, and to provide additional information in case of presence. Recall that the tool is not dedicated for calling blindly all such events in a high throughput sequencing dataset.</p>
      <sec>
        <title>Exon skipping</title>
        <p>We chose a starter located close to a known exon fragment (Chr4:488,592-488,620 BDGP R5/dm3). Using less than one megabyte of memory and in 33 minutes, <sc>Mapsembler</sc> confirmed the presence of this exon fragment. The corresponding part of the obtained graph is presented in Figure
<xref ref-type="fig" rid="F4">4</xref>, while a visualization of the Blat
[<xref ref-type="bibr" rid="B17">17</xref>] result is presented Figure
<xref ref-type="fig" rid="F5">5</xref>.</p>
        <fig id="F4" position="float">
          <label>Figure 4</label>
          <caption>
            <p><bold>Drosophila exon.</bold> Visualization of <sc>Mapsembler</sc> results on a drosophila read data set. Red characters correspond to splice sites found by mapping using Blat
[<xref ref-type="bibr" rid="B17">17</xref>], while the circled characters is a codon stop.</p>
          </caption>
          <graphic xlink:href="1471-2105-13-48-4"/>
        </fig>
        <fig id="F5" position="float">
          <label>Figure 5</label>
          <caption>
            <p><bold>Drosophila exon - blat result.</bold> Visualization of Blat results on sequences obtained from graph presented Figure
<xref ref-type="fig" rid="F4">4</xref>. Shorter path corresponds to the concatenation of the sequences from starter node (blue node) and from the lowest node, while longer path corresponds to the concatenation of the sequences from starter node, left most node and lowest node. The central node includes, but is not limited to a known EST CO332306.</p>
          </caption>
          <graphic xlink:href="1471-2105-13-48-5"/>
        </fig>
      </sec>
      <sec>
        <title>Visualizing SNPs</title>
        <p>On the same read data set, we used a fragment (chrX:17,783,737-17,783,812 BDGP R5/dm3) for which neighboring genes are known. We applied <sc>Mapsembler</sc> using this fragment as starter and obtained results in less than 1 megabyte of memory and less than 110 minutes of execution (40 iterations). The results presented in Figure
<xref ref-type="fig" rid="F6">6</xref> enable to visualize the SNPs. Note that these results do not bring phasing SNP information.</p>
        <fig id="F6" position="float">
          <label>Figure 6</label>
          <caption>
            <p><bold>Drosophila SNPs.</bold> Visualization of <sc>Mapsembler</sc> results on a drosophila read data sets, looking for known SNPs. On this graph, 2 SNPs (circled nodes) in the right extensions are shown. Full sequences are truncated.</p>
          </caption>
          <graphic xlink:href="1471-2105-13-48-6"/>
        </fig>
      </sec>
    </sec>
    <sec>
      <title>Detection of fusion genes in breast cancer</title>
      <p>Recent work from Edgren <italic>et. al.</italic>[<xref ref-type="bibr" rid="B18">18</xref>] uses paired reads from RNA-seq experiments (SRA: SRP003186) to detect fusion genes using a reference genome (Ensembl version 55). <sc>Mapsembler</sc> enabled to retrieve these fusion genes and enabled to detect new candidate fusion genes implicated in human breast cancer. Here, we present results for cell line BT-474, for which we downloaded the short reads used in
[<xref ref-type="bibr" rid="B18">18</xref>] (merging runs SRR064438 and SRR064439). This data set contains ≈ 43 million reads of average length 51bp. Using extremities of fusions as starters, in 1 hour and 36 minutes, using ≈ 70 MB of memory, <sc>Mapsembler</sc> retrieved in 25 iterations fusions genes detected in
[<xref ref-type="bibr" rid="B18">18</xref>].</p>
      <p>It is of particular interest to notice that <sc>Mapsembler</sc> retrieved these fusion genes without making use of a reference genome nor information between read pairs. As shown Figures
<xref ref-type="fig" rid="F7">7</xref> and
<xref ref-type="fig" rid="F8">8</xref>, for junction <italic>VAPB-IKZF3</italic>, <sc>Mapsembler</sc> enabled to retrieve the fusion gene described in
[<xref ref-type="bibr" rid="B18">18</xref>] and additionally detected two other fusions between genes <italic>VAPB</italic> and <italic>IKZF3</italic>, on different exons than those previously described. Moreover, as this is usually the case while applying <sc>Mapsembler</sc> on RNA-seq data, the graph output enables to retrieve the exon structure in the extensions.</p>
      <fig id="F7" position="float">
        <label>Figure 7</label>
        <caption>
          <p><bold>Gene fusion in human breast cancer.</bold> Extension graph of an extremity of an exon from the VAPB human gene located on chromosome 20. <bold>a)</bold>: the raw graph produced by <sc>Mapsembler</sc>. <bold>b)</bold>: the same graph manually curated by mapping the sequence of each node on the human genome. Nodes where moved in order to reflect their relative mapping position on the chromosomes. Nodes from the raw graph having sequences mapping at the same position where merged. For each node, the start and stop positions of the mapping are indicated. The presence of two start and stop positions reflects the presence of a central intron. Except for the purple node having multiple hits among the genome, 100% of the sequence of each node was mapped, either to an exon from gene VAPB on chromosome 20 or from gene IKZF3 on chromosome 17. The bold edge corresponds to the gene fusion found in
[<xref ref-type="bibr" rid="B18">18</xref>], while the two other edges starting from the starter and targeting a chromosome 17 exon are new gene fusions.</p>
        </caption>
        <graphic xlink:href="1471-2105-13-48-7"/>
      </fig>
      <fig id="F8" position="float">
        <label>Figure 8</label>
        <caption>
          <p><bold>Gene fusion in human breast cancer - Blat results.</bold> Blat
[<xref ref-type="bibr" rid="B17">17</xref>] results obtained after mapping paths from the starter to a leaf of the graph presented Figure
<xref ref-type="fig" rid="F7">7</xref>. Succession of nodes of each mapped path (black lines) are indicated by their identifiers (red letters in Figure
<xref ref-type="fig" rid="F7">7</xref>). Path belonging to gene VAPB chromosome 20 are represented on the upper part of the figure (S_A_B_C_D, S_A_F_G_D and S_A_E) while those belonging to gene IKZF3 on chromosome 20 (H, I_J and K_J) are represented on the lower part. Note that the starter is not mapped on gene IKZF3 as it appears only on chromosome 17 on the genome. However, it is concatenated to rightmost exons of each of the three paths (H, I_J and K_J) in the transcripts.</p>
        </caption>
        <graphic xlink:href="1471-2105-13-48-8"/>
      </fig>
    </sec>
  </sec>
  <sec sec-type="discussion">
    <title>Discussion</title>
    <p>We presented <sc>Mapsembler</sc>, a new tool for targeting specific pieces of information from a possible huge set of reads, on a simple desktop computer. Presented results show that such software has great potential for querying information from next generation sequencer reads. It enables to confirm the presence of a region of interest and retrieve information about surrounding sequence context. This approach presents the advantage to avoid a costly and approximative
[<xref ref-type="bibr" rid="B2">2</xref>] full <italic>de novo</italic> assembly. However, <sc>Mapsembler</sc> presents some limitations discussed in this section.</p>
    <sec>
      <title>Homology/similarity distance</title>
      <p><sc>Mapsembler</sc> allows <italic>d</italic> substitutions between each starter its sub-starters. Hence, this homology distance is limited to a few percent of the starter length. Thus <sc>Mapsembler</sc> can not be used for searching homologous genes having less than, say, 90% of similarity.</p>
      <p>Furthermore, setting a large <italic>d</italic> is not recommended for two reasons. Firstly, in the worst case, there are <italic>O</italic>(|<italic>Σ</italic>|<sup><italic>d</italic></sup>) sub-starters having at most <italic>d</italic> substitutions with a starter <italic>s</italic>. To avoid dealing with an arbitrarily large number of sub-starters, <sc>Mapsembler</sc> implements a limit of 100 sub-starters per starter.</p>
      <p>Secondly, <sc>Mapsembler</sc> output sub-starters which may contain uncorrelated mutations, i.e. false positives. Consider a starter which contains two SNPs A/B and C/D sufficiently far away, so that are not spanned by any read. <sc>Mapsembler</sc> would reconstruct 4 sub-starters, corresponding to AC, AD, BC, and BD, even if only two of them were actually present in the sequenced organism.</p>
    </sec>
    <sec>
      <title>Paired reads vs. single reads</title>
      <p>The <sc>Mapsembler</sc> algorithm does not use the paired reads information. Such information is difficult to incorporate in the iterative micro assembly process. We chose to discard it to keep the algorithm simple and applicable to any kind of data. However, in the case of the graph output, paired reads would enable to provide more information, for instance in splicing events. The graph constructed from single reads contains all possible junctions. Paired reads can be used to eliminate paths with two or more branching junctions which do not correspond to true isoforms.</p>
      <p>Instead of injecting the paired read information in the algorithm, we believe that it is simpler to run <sc>Mapsembler</sc>, then use a third party algorithm (such as <sc>Blastree</sc>[<xref ref-type="bibr" rid="B19">19</xref>]) to map paired reads to the graph and output pairs-coherent paths.</p>
    </sec>
    <sec>
      <title>Micro assembly vs. full contigs assembly</title>
      <p>One key aspect of <sc>Mapsembler</sc> is to be usable on a simple desktop computer, not requiring large memory facilities. This is achieved by an iterative algorithm which avoids indexing the read set. However, as shown Table
<xref ref-type="table" rid="T1">1</xref>, on common datasets generated by a run of an existing NGS platform, each iteration can take hundreds of seconds. Depending on the length of the reads, each iteration extends sub-starters by a few dozens nucleotides.</p>
      <sec>
        <title>Does contig length matter?</title>
        <p>If feasible on the data, using <sc>Mapsembler</sc> for the creation of contigs of length around 100kb or more would take weeks on a classical desktop computer. Consequently the user should specify a maximal number of iterations, or manually stop the process after a while.</p>
        <p>We argue that short contigs provide sufficient biological information for our purpose. As presented in the results section, we retrieved SNPs, different isoforms and gene fusions using short contigs. For instance, the graph presented Figure
<xref ref-type="fig" rid="F7">7</xref>, created in 1h36 after 25 iterations, stores a path of length 422 nucleotides. This whole graph is sufficient to detect the presence of 11 exons spread over two genes.</p>
      </sec>
      <sec>
        <title>Sensitivity to SNPs</title>
        <p>Similarly to greedy assemblers, in the simple sequence output mode, <sc>Mapsembler</sc> aborts sequence extension as soon as more than as one extension are found. This mechanism typically yields short neighbors, in particular in sequences containing SNPs. Thus we implemented an option to allow merging of multiple extensions having the same sequence except for one substitution. In this case, the substitution position is replaced by the nucleotide having the largest coverage. This effectively resolves ambiguities due to SNPs and generate longer extensions.</p>
      </sec>
      <sec>
        <title>Starter selection</title>
        <p>The input starters are sequence fragments on which reads will be mapped. They can be of any length, however very long starters (over 10<sup>4</sup>nt) are discouraged, as the sub-starters generation step is quadratic in the number of aligned reads. Furthermore, Mapsembler verifies that starters are read-coherent, hence longer starters are more likely to contain regions where the coverage is too low. Also, as previously mentioned, long starters may lead to false positive sub-starters.</p>
        <p>Mapsembler discards read alignments which contain an indel. Hence, it is advised to input small, well-conserved starters. However, indels in the extensions are retained in the graph structure. Starters are typically constructed from an external source of information, such as sequence information from a related species, a known conserved gene, or an existing collapsed assembly.</p>
      </sec>
      <sec>
        <title>Full biological events calling versus <sc>Mapsembler</sc></title>
        <p><sc>Mapsembler</sc> was clearly not designed for calling broadly biological events. It should not be used for this purpose. Its usage should then be limited to cases where user has a piece of priori knowledge she wants to validate and extend, without making use of heavy and heuristics approaches.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p><sc>Mapsembler</sc> is a simple yet powerful, non-specific tool for extracting targeted pieces of information from newly sequenced, non-assembled genomes or transcriptomes. Technically, <sc>Mapsembler</sc> retrieves the approximate occurrences of a region of interest and performs targeted assembly through repeated iterations of read mapping. It also provides the possibility of visualizing the genomic context of assembled sequences as a graph. <sc>Mapsembler</sc> is not a whole-genome assembly software, instead it focuses on specific targets and assemble their contexts over a few hundreds of nucleotides. <sc>Mapsembler</sc> can be executed on a classical desktop computer; without cleaning the data and without a reference genome. Usage possibilities are numerous and fit the actual trend of sequencing, as more and more species, including meta-genomes, are sequenced without reference genomes.</p>
    <p>We presented the main <sc>Mapsembler</sc> features and algorithmic ingredients. We have shown a selected overview of <sc>Mapsembler</sc> applications, among which one enabled to detect novel fusion genes. Benchmarks were ran on very large amounts of biologically relevant data. With respect to other comparable method, <sc>Mapsembler</sc> runs consistently faster and consumes less memory. More importantly, <sc>Mapsembler</sc> has several novel features, such as sub-starters retrieval, iterative extensions and graph visualization.</p>
    <p>There is much room for future work. Currently the error correction is based on substitutions only. For opening <sc>Mapsembler</sc> to broader technologies like Roche 454 System, insertions and deletions will be taken into account during read correction.</p>
    <p>To finish, its simplicity and its power make <sc>Mapsembler</sc> a good candidate for ambitious future NGS applications. In particular, even if it was not initially designed in this spirit, <sc>Mapsembler</sc> is highly parallelizable and can be adapted to a <italic>“zero memory”</italic> whole genome <italic>de novo</italic> assembly tool.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Author’s contributions</title>
    <p>PP initiated the work and PP and RC designed the algorithms. RC developed the sub-starter generation and read coherence algorithms, while PP developed the other parts. RC and PP performed the experiments and wrote the paper. Both authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p>
          <bold>Material and</bold>
          <sc>
            <bold>Mapsembler</bold>
          </sc>
          <bold>commands and results.</bold>
        </p>
      </caption>
      <media xlink:href="1471-2105-13-48-S1.zip" mimetype="application" mime-subtype="x-zip-compressed">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>Authors warmly thank Vincent Lacroix, Claire Lemaitre, Delphine Naquin, Hélène Falentin and Fabrice Legeai for their participation to discussions. This work was supported by the INRIA “action de recherche collaborative” ARC Alcovna and by the MAPPI ANR.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Zhu</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Qian</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Fang</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Shi</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Shan</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <etal/>
        <article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title>
        <source>Genome Res</source>
        <year>2010</year>
        <volume>20</volume>
        <issue>2</issue>
        <fpage>265</fpage>
        <pub-id pub-id-type="doi">10.1101/gr.097261.109</pub-id>
        <pub-id pub-id-type="pmid">20019144</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Alkan</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Sajjadian</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Eichler</surname>
          <given-names>EE</given-names>
        </name>
        <article-title>Limitations of next-generation genome sequence assembly</article-title>
        <source>Nat Meth</source>
        <year>2011</year>
        <volume>8</volume>
        <fpage>61</fpage>
        <lpage>65</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth.1527">http://dx.doi.org/10.1038/nmeth.1527</ext-link>], [
<ext-link ext-link-type="uri" xlink:href="http://www.nature.com/nmeth/journal/v8/n1/abs/nmeth.1527.html∖#supplementary-information">http://www.nature.com/nmeth/journal/v8/n1/abs/nmeth.1527.html∖#supplementary-information</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1038/nmeth.1527</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Lin</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Shen</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Papasian</surname>
          <given-names>CJ</given-names>
        </name>
        <name>
          <surname>Deng</surname>
          <given-names>HW</given-names>
        </name>
        <article-title>Comparative Studies of de novo Assembly Tools for Next-generation Sequencing Technologies</article-title>
        <source>Bioinformatics (Oxford, England)</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>15</issue>
        <fpage>2031</fpage>
        <lpage>2037</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/pubmed/21636596">http://www.ncbi.nlm.nih.gov/pubmed/21636596</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr319</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="other">
        <name>
          <surname>Bastian</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Heymann</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Jacomy</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Gephi: An open source software for exploring and manipulating networks</article-title>
        <source>International AAAI Conference on Weblogs and Social Media</source>
        <year>2009</year>
        <fpage>361</fpage>
        <lpage>362</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.aaai.org/ocs/index.php/ICWSM/09/paper/download/154/1009">http://www.aaai.org/ocs/index.php/ICWSM/09/paper/download/154/1009</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Cline</surname>
          <given-names>MS</given-names>
        </name>
        <etal/>
        <article-title>Integration of biological networks and gene expression data using Cytoscape</article-title>
        <source>Nat Protoc</source>
        <year>2007</year>
        <volume>2</volume>
        <issue>10</issue>
        <fpage>2366</fpage>
        <lpage>2382</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nprot.2007.324">http://dx.doi.org/10.1038/nprot.2007.324</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1038/nprot.2007.324</pub-id>
        <pub-id pub-id-type="pmid">17947979</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="other">
        <name>
          <surname>von Eichborn</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Bourne</surname>
          <given-names>PE</given-names>
        </name>
        <name>
          <surname>Preissner</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Cobweb: a Java applet for network exploration and visualisation</article-title>
        <source>Bioinformatics (Oxford, England)</source>
        <year>2011</year>
        <fpage>2</fpage>
        <lpage>4</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/pubmed/21486937">http://www.ncbi.nlm.nih.gov/pubmed/21486937</ext-link>]</comment>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rizk</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Lavenier</surname>
          <given-names>D</given-names>
        </name>
        <article-title>GASSST: Global Alignment Short Sequence Search Tool</article-title>
        <source>Bioinformatics (Oxford, England)</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>20</issue>
        <fpage>2534</fpage>
        <lpage>2540</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/pubmed/20739310">http://www.ncbi.nlm.nih.gov/pubmed/20739310</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq485</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Warren</surname>
          <given-names>RL</given-names>
        </name>
        <name>
          <surname>Sutton</surname>
          <given-names>GG</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>SJM</given-names>
        </name>
        <name>
          <surname>Holt</surname>
          <given-names>RA</given-names>
        </name>
        <article-title>Assembling millions of short DNA sequences using SSAKE</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <issue>4</issue>
        <fpage>500</fpage>
        <lpage>501</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/btl629">http://dx.doi.org/10.1093/bioinformatics/btl629</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl629</pub-id>
        <pub-id pub-id-type="pmid">17158514</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Havlak</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>KJ</given-names>
        </name>
        <name>
          <surname>Egan</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Ren</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Song</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Weinstock</surname>
          <given-names>GM</given-names>
        </name>
        <name>
          <surname>Gibbs</surname>
          <given-names>RA</given-names>
        </name>
        <article-title>The atlas genome assembly system</article-title>
        <source>Genome Res</source>
        <year>2004</year>
        <volume>14</volume>
        <issue>4</issue>
        <fpage>721</fpage>
        <lpage>732</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/14/4/721.abstract">http://genome.cshlp.org/content/14/4/721.abstract</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1101/gr.2264004</pub-id>
        <pub-id pub-id-type="pmid">15060016</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Warren</surname>
          <given-names>RL</given-names>
        </name>
        <name>
          <surname>Holt</surname>
          <given-names>RA</given-names>
        </name>
        <article-title>Targeted assembly of short sequence reads</article-title>
        <source>PLoS ONE</source>
        <year>2011</year>
        <volume>6</volume>
        <issue>5</issue>
        <fpage>e19816</fpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371">http://dx.doi.org/10.1371</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0019816</pub-id>
        <pub-id pub-id-type="pmid">21589938</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Tsai</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Otto</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Berriman</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Improving draft assemblies by iterative mapping and assembly of short reads to eliminate gaps</article-title>
        <source>Genome Biol</source>
        <year>2010</year>
        <volume>11</volume>
        <issue>4</issue>
        <fpage>R41</fpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://genomebiology.com/2010/11/4/R41">http://genomebiology.com/2010/11/4/R41</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1186/gb-2010-11-4-r41</pub-id>
        <pub-id pub-id-type="pmid">20388197</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Zhu</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Qian</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Fang</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Shi</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Shan</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Yang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title>
        <source>Genome Res</source>
        <year>2010</year>
        <volume>20</volume>
        <issue>2</issue>
        <fpage>265</fpage>
        <lpage>272</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=2813482∖&amp;amp;tool=pmcentrez∖&amp;amp;rendertype=abstract">http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=2813482∖&amp;amp;tool=pmcentrez∖&amp;amp;rendertype=abstract</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1101/gr.097261.109</pub-id>
        <pub-id pub-id-type="pmid">20019144</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Jurka</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Kapitonov</surname>
          <given-names>VV</given-names>
        </name>
        <name>
          <surname>Pavlicek</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Klonowski</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Kohany</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Walichiewicz</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Repbase Update, a database of eukaryotic repetitive elements</article-title>
        <source>Cytogenetic and Genome Res</source>
        <year>2005</year>
        <volume>110</volume>
        <issue>1-4</issue>
        <fpage>462</fpage>
        <lpage>467</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.karger.com/doi/10.1159/000084979">http://www.karger.com/doi/10.1159/000084979</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1159/000084979</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Batzer</surname>
          <given-names>MA</given-names>
        </name>
        <name>
          <surname>Deininger</surname>
          <given-names>PL</given-names>
        </name>
        <article-title>Alu repeats and human genomic diversity</article-title>
        <source>Nat Rev Genet</source>
        <year>2002</year>
        <volume>3</volume>
        <issue>5</issue>
        <fpage>370</fpage>
        <lpage>379</lpage>
        <pub-id pub-id-type="doi">10.1038/nrg798</pub-id>
        <pub-id pub-id-type="pmid">11988762</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rozowsky</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Abyzov</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Alves</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Raha</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Harmanci</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Leng</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Bjornson</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Kong</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Kitabayashi</surname>
          <given-names>N</given-names>
        </name>
        <article-title>AlleleSeq: analysis of allele-specific expression and binding in a network framework</article-title>
        <source>Mol Syst Biol</source>
        <year>2011</year>
        <volume>7</volume>
        <fpage>522</fpage>
        <lpage>536</lpage>
        <pub-id pub-id-type="pmid">21811232</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Arcot</surname>
          <given-names>SS</given-names>
        </name>
        <name>
          <surname>Adamson</surname>
          <given-names>AW</given-names>
        </name>
        <name>
          <surname>Risch</surname>
          <given-names>GW</given-names>
        </name>
        <name>
          <surname>LaFleur</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Robichaux</surname>
          <given-names>MB</given-names>
        </name>
        <name>
          <surname>Lamerdin</surname>
          <given-names>JE</given-names>
        </name>
        <name>
          <surname>Carrano</surname>
          <given-names>AV</given-names>
        </name>
        <name>
          <surname>Batzer</surname>
          <given-names>MA</given-names>
        </name>
        <article-title>High-resolution cartography of recently integrated human chromosome 19-specific Alu fossils1</article-title>
        <source>J Mol Biol</source>
        <year>1998</year>
        <volume>281</volume>
        <issue>5</issue>
        <fpage>843</fpage>
        <lpage>856</lpage>
        <pub-id pub-id-type="doi">10.1006/jmbi.1998.1984</pub-id>
        <pub-id pub-id-type="pmid">9719639</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kent</surname>
          <given-names>WJ</given-names>
        </name>
        <article-title>BLAT—The BLAST-Like Alignment Tool</article-title>
        <source>Genome Res</source>
        <year>2002</year>
        <volume>12</volume>
        <issue>4</issue>
        <fpage>656</fpage>
        <lpage>664</lpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://www.genome.org/cgi/doi/10.1101/gr.229202">http://www.genome.org/cgi/doi/10.1101/gr.229202</ext-link>]</comment>
        <pub-id pub-id-type="pmid">11932250</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Edgren</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Murumaegi</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Kangaspeska</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Nicorici</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Hongisto</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Kleivi</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Rye</surname>
          <given-names>IH</given-names>
        </name>
        <name>
          <surname>Nyberg</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Wolf</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Boerresen-Dale</surname>
          <given-names>AL</given-names>
        </name>
        <name>
          <surname>Kallioniemi</surname>
          <given-names>O</given-names>
        </name>
        <article-title>Identification of fusion genes in breast cancer by paired-end RNA-sequencing</article-title>
        <source>Genome Biol</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>R6</fpage>
        <comment>[
<ext-link ext-link-type="uri" xlink:href="http://genomebiology.com/2011/12/1/R6">http://genomebiology.com/2011/12/1/R6</ext-link>]</comment>
        <pub-id pub-id-type="doi">10.1186/gb-2011-12-1-r6</pub-id>
        <pub-id pub-id-type="pmid">21247443</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="other">
        <name>
          <surname>Holley</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Peterlongo</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Blastree: intensive approximate pattern matching in a string graph</article-title>
        <source>ICCEB - International Conference on Computer Engineering and Bioinformatics</source>
        <comment>2011:to appear, [
<ext-link ext-link-type="uri" xlink:href="http://alcovna.genouest.org/blastree/">http://alcovna.genouest.org/blastree/</ext-link>]</comment>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
