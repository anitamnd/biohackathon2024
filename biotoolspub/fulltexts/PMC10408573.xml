<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Digit Discov</journal-id>
    <journal-id journal-id-type="iso-abbrev">Digit Discov</journal-id>
    <journal-id journal-id-type="publisher-id">DD</journal-id>
    <journal-id journal-id-type="coden">DDIIAI</journal-id>
    <journal-title-group>
      <journal-title>Digital Discovery</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2635-098X</issn>
    <publisher>
      <publisher-name>RSC</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10408573</article-id>
    <article-id pub-id-type="publisher-id">d3dd00044c</article-id>
    <article-id pub-id-type="doi">10.1039/d3dd00044c</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Chemistry</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Recent advances in the self-referencing embedded strings (SELFIES) library</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-1744-1446</contrib-id>
        <name>
          <surname>Lo</surname>
          <given-names>Alston</given-names>
        </name>
        <xref rid="affa" ref-type="aff">a</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8836-6266</contrib-id>
        <name>
          <surname>Pollice</surname>
          <given-names>Robert</given-names>
        </name>
        <xref rid="affa" ref-type="aff">a</xref>
        <xref rid="affb" ref-type="aff">b</xref>
        <xref rid="affc" ref-type="aff">c</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Nigam</surname>
          <given-names>AkshatKumar</given-names>
        </name>
        <xref rid="affd" ref-type="aff">d</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-6647-3965</contrib-id>
        <name>
          <surname>White</surname>
          <given-names>Andrew D.</given-names>
        </name>
        <xref rid="affe" ref-type="aff">e</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Krenn</surname>
          <given-names>Mario</given-names>
        </name>
        <xref rid="afff" ref-type="aff">f</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Aspuru-Guzik</surname>
          <given-names>Alán</given-names>
        </name>
        <xref rid="affa" ref-type="aff">a</xref>
        <xref rid="affb" ref-type="aff">b</xref>
        <xref rid="affg" ref-type="aff">g</xref>
        <xref rid="affh" ref-type="aff">h</xref>
      </contrib>
      <aff id="affa">
        <label>a</label>
        <institution>Department of Computer Science, University of Toronto</institution>
        <country>Canada</country>
        <email>alston.lo@mail.utoronto.ca</email>
        <email>r.pollice@rug.nl</email>
        <email>alan@aspuru.com</email>
      </aff>
      <aff id="affb">
        <label>b</label>
        <institution>Chemical Physics Theory Group, Department of Chemistry, University of Toronto</institution>
        <country>Canada</country>
      </aff>
      <aff id="affc">
        <label>c</label>
        <institution>Stratingh Institute for Chemistry, University of Groningen</institution>
        <country>The Netherlands</country>
      </aff>
      <aff id="affd">
        <label>d</label>
        <institution>Department of Computer Science, Stanford University</institution>
        <state>California</state>
        <country>USA</country>
      </aff>
      <aff id="affe">
        <label>e</label>
        <institution>Department of Chemical Engineering, University of Rochester</institution>
        <country>USA</country>
      </aff>
      <aff id="afff">
        <label>f</label>
        <institution>Max Planck Institute for the Science of Light (MPL)</institution>
        <city>Erlangen</city>
        <country>Germany</country>
      </aff>
      <aff id="affg">
        <label>g</label>
        <institution>Vector Institute for Artificial Intelligence</institution>
        <city>Toronto</city>
        <country>Canada</country>
      </aff>
      <aff id="affh">
        <label>h</label>
        <institution>Canadian Institute for Advanced Research (CIFAR) Lebovic Fellow</institution>
        <city>Toronto</city>
        <country>Canada</country>
      </aff>
    </contrib-group>
    <pub-date publication-format="electronic" date-type="pub" iso-8601-date="2023-07-01">
      <day>1</day>
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <pub-date publication-format="electronic" date-type="collection" iso-8601-date="2023-08-08">
      <day>8</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>1</day>
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <!--PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>.-->
    <volume>2</volume>
    <issue>4</issue>
    <fpage>897</fpage>
    <lpage>908</lpage>
    <history>
      <date date-type="received" iso-8601-date="2023-03-17">
        <day>17</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="accepted" iso-8601-date="2023-06-23">
        <day>23</day>
        <month>6</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>This journal is © The Royal Society of Chemistry</copyright-statement>
      <copyright-year>2023</copyright-year>
      <copyright-holder>RSC</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense" start_date="2023-07-01">https://creativecommons.org/licenses/by/3.0/</ali:license_ref>
      </license>
    </permissions>
    <abstract>
      <p>String-based molecular representations play a crucial role in cheminformatics applications, and with the growing success of deep learning in chemistry, have been readily adopted into machine learning pipelines. However, traditional string-based representations such as SMILES are often prone to syntactic and semantic errors when produced by generative models. To address these problems, a novel representation, SELF-referencing embedded strings (SELFIES), was proposed that is inherently 100% robust, alongside an accompanying open-source implementation called selfies. Since then, we have generalized SELFIES to support a wider range of molecules and semantic constraints, and streamlined its underlying grammar. We have implemented this updated representation in subsequent versions of selfies, where we have also made major advances with respect to design, efficiency, and supported features. Hence, we present the current status of selfies (version 2.1.1) in this manuscript. Our library, selfies, is available at GitHub (<uri xlink:href="https://github.com/aspuru-guzik-group/selfies">https://github.com/aspuru-guzik-group/selfies</uri>).</p>
    </abstract>
    <abstract abstract-type="toc">
      <p>We describe the current state of the SELFIES library (version 2.1.1), and, in particular, the advances and improvements we have made in its underlying algorithms, design, and API.<graphic xlink:href="d3dd00044c-ga.jpg" id="ga" position="float"/></p>
    </abstract>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution>Stanford Bio-X</institution>
            <institution-id institution-id-type="doi">10.13039/100011098</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>Bio-X SIGF</award-id>
      </award-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution>Schweizerischer Nationalfonds zur Förderung der Wissenschaftlichen Forschung</institution>
            <institution-id institution-id-type="doi">10.13039/501100001711</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>Postdoc.Mobility</award-id>
      </award-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution>Stanford University</institution>
            <institution-id institution-id-type="doi">10.13039/100005492</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>Unassigned</award-id>
      </award-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution>Natural Resources Canada</institution>
            <institution-id institution-id-type="doi">10.13039/501100000159</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>Unassigned</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="12"/>
    </counts>
    <custom-meta-group>
      <custom-meta>
        <meta-name>pubstatus</meta-name>
        <meta-value>Paginated Article</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec>
    <label>1.</label>
    <title>Introduction</title>
    <p>In recent years, machine learning (ML) has become a powerful tool to tackle challenging problems in chemistry. Machine learning pipelines involve three crucial elements: data, representations, and models. Choosing the proper representation is important as it defines the space of models available to work with the data, as well as impacting directly model performance. For molecules, one of the more widely-used classes of representations encode molecules as strings (<italic toggle="yes">i.e.</italic>, the string-based molecular representations). These representations are popular since they can leverage the rich collection of ML tools that have been developed for sequential data.<sup><xref rid="cit1" ref-type="bibr">1,2</xref></sup> Historically, the most employed string representation is the Simplified Molecular Input Line Entry System (SMILES), which was introduced by Weininger in 1988.<sup><xref rid="cit3" ref-type="bibr">3</xref></sup> Currently, SMILES has become the <italic toggle="yes">de facto</italic> standard representation in cheminformatics and has historically been a key component of central applications in the field, such as chemical databases. The main appeal of SMILES is its simple underlying grammar, which allows for the rigorous specification of molecules in a manner that can be parsed efficiently, and which is readable for humans at least for small molecules.</p>
    <p>However, in an ML setting, this grammar can carry two intrinsic weaknesses. First, many strings constructed from SMILES symbols are syntactically invalid due to the rigidity of the SMILES grammar, <italic toggle="yes">i.e.</italic>, the strings cannot be interpreted as molecular graphs.<sup><xref rid="cit4" ref-type="bibr">4,5</xref></sup> In particular, SMILES requires branch brackets and ring numbers to appear in matching pairs (<italic toggle="yes">e.g.</italic>, C(CC and C1C are invalid), so a single misplaced or missing token could ruin the validity of a SMILES string. This is problematic because ML models that produce SMILES strings, especially generative models, can be prone to these syntactic errors, rendering a significant fraction of their output meaningless. One strategy is to constrain the ML architecture to reduce the number of invalid structures, which has been demonstrated successfully in the literature.<sup><xref rid="cit6" ref-type="bibr">6–8</xref></sup> This approach, of course, needs significant computational effort and cannot be transferred directly to other systems without model retraining, model architecture adjustments, or domain-specific design considerations. An alternative and more fundamental solution is to define representations that are inherently robust. A first step towards this direction was taken by DeepSMILES,<sup><xref rid="cit9" ref-type="bibr">9</xref></sup> a string-based representation derived from SMILES that reworked some of its most syntactically susceptible rules. While DeepSMILES solves most of the syntactical errors, it does not address the second weakness of SMILES, namely, that even syntactically valid strings may not necessarily correspond to a physical molecule. Typically, this occurs when a string represents a molecular graph that exceeds normal chemical valences, in which case we call the string semantically invalid. For example, the SMILES string CO<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><!-- PBM data was replaced with SVG by xgml2pxml:
<glyph-data id="z.dbd" format="PBM" resolution="300" x-size="8" y-size="10" xml:space="preserve">
00000000
00000000
00000000
00000000
11111111
00000000
11111111
00000000
00000000
00000000
</glyph-data>
--><glyph-data id="z.dbd" format="SVG" resolution="300" x-size="8" y-size="10" xml:space="preserve">
<![CDATA[
<svg xmlns="http://www.w3.org/2000/svg" version="1.0" width="13.200000pt" height="16.000000pt" viewBox="0 0 13.200000 16.000000" preserveAspectRatio="xMidYMid meet"><metadata>
Created by potrace 1.16, written by Peter Selinger 2001-2019
</metadata><g transform="translate(1.000000,15.000000) scale(0.017500,-0.017500)" fill="currentColor" stroke="none"><path d="M0 440 l0 -40 320 0 320 0 0 40 0 40 -320 0 -320 0 0 -40z M0 280 l0 -40 320 0 320 0 0 40 0 40 -320 0 -320 0 0 -40z"/></g></svg>
]]>
</glyph-data></private-char>C is semantically invalid because it erroneously specifies a trivalent oxygen atom, which is chemically unstable and reactive.</p>
    <p>To eliminate both syntactic and semantic invalidities in string-based molecular representations on a fundamental level, an entirely new representation termed SELF-referencIng Embedded Strings (SELFIES) has been proposed by some of us.<sup><xref rid="cit10" ref-type="bibr">10</xref></sup> By construction, SELFIES is 100% robust to both syntactic and semantic errors. That is, any combination of SELFIES symbols specifies a molecular graph that obeys chemical valences. This is achieved through a small Chomsky type-2, context-free grammar<sup><xref rid="cit11" ref-type="bibr">11</xref></sup> that is augmented with self-referencing functions to handle the generation of branches and rings. Since its release, SELFIES has enabled or improved numerous applications, ranging from molecular design<sup><xref rid="cit12" ref-type="bibr">12–15</xref></sup> to interpretability<sup><xref rid="cit16" ref-type="bibr">16</xref></sup> to image-to-string and string-to-string translations,<sup><xref rid="cit17" ref-type="bibr">17,18</xref></sup> and has been extended to incorporate functional groups and other fragments.<sup><xref rid="cit19" ref-type="bibr">19</xref></sup> For an extensive summary of its applications and opportunities, we refer readers to the recent community paper on SELFIES.<sup><xref rid="cit20" ref-type="bibr">20</xref></sup></p>
    <p>Herein, we introduce selfies 2.1.1, the latest version of the open-source Python implementation of SELFIES. In particular, we provide a detailed look into its history, developments, underlying algorithms, design, and performance. Together with the community, we have recently overviewed potential extensions and formulated 16 concrete future projects for SELFIES and other robust molecular string representations.<sup><xref rid="cit20" ref-type="bibr">20</xref></sup> We hope that this manuscript will also help in developing some of these extensions and ideas. Our software package selfies can be installed with “pip install selfies” and is available at GitHub (<uri xlink:href="https://github.com/aspuru-guzik-group/selfies">https://github.com/aspuru-guzik-group/selfies</uri>) under the Apache 2.0 license, along with comprehensive documentation and tutorials.</p>
  </sec>
  <sec>
    <label>2.</label>
    <title>Timeline and advances</title>
    <p>The selfies library version that implemented the representation from Krenn <italic toggle="yes">et al.</italic><sup><xref rid="cit10" ref-type="bibr">10</xref></sup> was first released as selfies 0.2.4 in 2019. This older version provided an API of two translation functions where a restricted subset of organic, uncharged, nonaromatic SMILES strings could be converted to and from SELFIES strings. In addition, the internal algorithms behind selfies relied heavily on direct string manipulations, so they were computationally inefficient and difficult to maintain. Since then, selfies has undergone several major redesigns that have significantly advanced the algorithmic handling of both SMILES and SELFIES. Most importantly, the underlying grammar of selfies has been streamlined and generalized in subsequent versions. We will now describe the changes up until selfies 2.1.1, the most recent version of selfies at the time of publication of this work.</p>
    <p>One major modification we made is that selfies now uses directed molecular graphs to internally represent SMILES and SELFIES strings. This has afforded selfies greater efficiency and flexibility, and enabled a number of additional extensions to be made. For example, we added support for aromatic molecules by kekulizing SMILES strings with aromatic symbols before they are translated into SELFIES. Furthermore, we handle species with partial charges, radicals, explicit hydrogens, non-standard isotopes, and stereochemical definitions in a fully syntactically and semantically robust way. Besides the standard constraints for the number of valences, users can now specify their own constraints and we provide built-in relaxed and stricter constraint presets that can be selected conveniently. Most recently, we introduced the ability to trace the connection between input and output tokens when translating between SELFIES and SMILES. <xref rid="tab1" ref-type="table">Table 1</xref> gives a brief changelog of the major releases of selfies and their associated advancements.</p>
    <table-wrap position="float" id="tab1">
      <caption>
        <title>A timeline of the various releases of selfies</title>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col span="1"/>
          <col span="1"/>
          <col span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">Version</th>
            <th rowspan="1" colspan="1">Year(s)</th>
            <th rowspan="1" colspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">0.1.1</td>
            <td rowspan="1" colspan="1">(Jun) 2019</td>
            <td rowspan="1" colspan="1">• Initial release of selfies</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">0.2.4</td>
            <td rowspan="1" colspan="1">(Oct) 2019</td>
            <td rowspan="1" colspan="1">• Release of selfies that implements the representation from Krenn <italic toggle="yes">et al.</italic><sup><xref rid="cit10" ref-type="bibr">10</xref></sup></td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">1.0.x</td>
            <td rowspan="1" colspan="1">2020–21</td>
            <td rowspan="1" colspan="1">• Expanded the support of selfies to a greater subset of SMILES strings, including strings with aromatic atoms, isotopes, charged species, and certain stereochemical specifications. To do so, the underlying grammar used by selfies was both streamlined and generalized</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1">• Added support for the customization of the semantic constraints used by selfies</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1">• Significantly improved the efficiency of translation between SELFIES and SMILES</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1">• Added a variety of utility functions to make the handling of SELFIES strings convenient</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">2.0.x</td>
            <td rowspan="1" colspan="1">2021</td>
            <td rowspan="1" colspan="1">• Updated the SELFIES alphabet to be more human-readable and standardized</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1">• Improved handling of stereochemical specifications in SELFIES involving ring bonds</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">2.1.x</td>
            <td rowspan="1" colspan="1">2022</td>
            <td rowspan="1" colspan="1">• Added support for explaining translations between SELFIES and SMILES through attributions</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <p>While the ideas outlined in the initial publication<sup><xref rid="cit10" ref-type="bibr">10</xref></sup> that ensure the validity of the representation remain at the core of selfies, the manifold implementation improvements and extensions are the novelties that we detail in this paper. Hereafter, unless specified otherwise, we will use selfies to refer to selfies 2.1.1 in particular and SELFIES to refer to the representation that selfies 2.1.1 implements. We will provide a complete and formal description of the updated representation in Section 3 and describe the API of selfies in Section 4.</p>
  </sec>
  <sec>
    <label>3.</label>
    <title>SELFIES specification</title>
    <p>Being 100% robust, every string of SELFIES symbols corresponds to a SMILES string that is both syntactically and semantically valid. Recall that we call a SMILES string semantically valid if it is syntactically valid and represents a molecular graph that obeys normal chemical valences.</p>
    <p>Within SELFIES, these chemical valences are encoded as a constraint function <inline-graphic xlink:href="d3dd00044c-t3.jpg" id="ugt3"/> where <inline-graphic xlink:href="d3dd00044c-t4.jpg" id="ugt4"/> is a finite universe of the atom types (<italic toggle="yes">e.g.</italic>, <inline-graphic xlink:href="d3dd00044c-t5.jpg" id="ugt5"/>) of interest and <inline-graphic xlink:href="d3dd00044c-t6.jpg" id="ugt6"/> The valences represented by <italic toggle="yes">ν</italic> dictate that an atom <italic toggle="yes">A</italic> must assume <italic toggle="yes">ν</italic>(type(<italic toggle="yes">A</italic>)) incident bonds in total. Note that if a SMILES string obeys the valences <italic toggle="yes">k</italic>, each of its atoms <italic toggle="yes">A</italic> makes at most <italic toggle="yes">ν</italic>(type(<italic toggle="yes">A</italic>)) explicit bonds within the string. There is a possibly-strict inequality in this case due to the way SMILES automatically adds implicit hydrogens until chemical valences are satisfied. In practice, the mapping <italic toggle="yes">ν</italic> is rationally chosen to align with both physical considerations and established cheminformatics packages such as RDKit.<sup><xref rid="cit21" ref-type="bibr">21</xref></sup> For example, a plausible setting might map<disp-formula id="eqn1"><label>1</label><italic toggle="yes">ν</italic>(C) = 4, <italic toggle="yes">ν</italic>(N) = 3, <italic toggle="yes">ν</italic>(O) = 2, <italic toggle="yes">ν</italic>(F) = 1</disp-formula>which is the default behaviour of selfies (see Section 4.3).</p>
    <p>We formulate chemical valences in this manner to emphasize that although SELFIES depends on <italic toggle="yes">ν</italic>, it is not fixed to any particular setting of <italic toggle="yes">ν</italic>. That is to say, SELFIES can enforce rule sets induced by any arbitrary mapping <inline-graphic xlink:href="d3dd00044c-t7.jpg" id="ugt7"/> even if they are not chemically meaningful. To highlight an absurd example, the uniform constraints <italic toggle="yes">ν</italic>(·) = 1000 can be used in principle, which corresponds to effectively having no semantic constraints at all. In this sense, SELFIES can be thought of as a general framework for an adjustable set of constraints <italic toggle="yes">ν</italic>. In the ensuing discussion, we will describe SELFIES under the assumption that some constraint function <italic toggle="yes">ν</italic> is fixed beforehand.</p>
    <sec>
      <label>3.1.</label>
      <title>Syntax</title>
      <p>Before explaining the SELFIES specification, we make a brief aside and give an overview of the form of SELFIES strings. Simply, a valid SELFIES string is any finite sequence of SELFIES symbols joined together. For ease of visual partitioning, all SELFIES symbols are enclosed by square brackets. Hence, a generic SELFIES string is of the form<disp-formula id="eqn2"><label>2</label>[…][…][…]⋯[…][…]</disp-formula>where the … is a placeholder for a symbol-specific token. We can further categorize SELFIES symbols into four main types, namely, atom, ring, branch, and miscellaneous, and characterize the syntax of each in the following. Throughout, let <italic toggle="yes">ε</italic> be the empty string and given <italic toggle="yes">n</italic> strings <inline-graphic xlink:href="d3dd00044c-t8.jpg" id="ugt8"/> let <italic toggle="yes">σ</italic><sub>1,</sub><italic toggle="yes">σ</italic><sub>2</sub>,…,<italic toggle="yes">σ</italic><sub><italic toggle="yes">n</italic></sub> denote their concatenation.</p>
      <sec>
        <label>3.1.1.</label>
        <title>Atom symbols</title>
        <p>The general SELFIES atom symbol has the form<disp-formula id="eqn3"><label>3</label><graphic xlink:href="d3dd00044c-t9.jpg" id="ugt9" position="float"/></disp-formula>where <italic toggle="yes">β</italic> ∈ {<italic toggle="yes">ε</italic>, = , #,/, \} is a SMILES-like bond symbol and<disp-formula id="eqn4"><label>4</label><graphic xlink:href="d3dd00044c-t10.jpg" id="ugt10" position="float"/></disp-formula></p>
        <p>collectively specify an atom type type(<italic toggle="yes">α</italic>) in a SMILES-like fashion (the atom's isotope number, atomic number, chirality, number of attached hydrogens, and charge, respectively, and sometimes optionally). Notably, each SELFIES atom symbol is semantically unique, <italic toggle="yes">i.e.</italic>, different atom symbols are not interchangeable. This is not the case in SMILES due to shorthand abbreviations in how attached hydrogens and charge can be represented. For example, the SMILES atom symbol pairs ([Fe++], [Fe+2]) and ([CH], [CH1]) are interchangeable. To create a more standardized alphabet of symbols, we remove this redundancy in SELFIES.</p>
      </sec>
      <sec>
        <label>3.1.2.</label>
        <title>Branch symbols</title>
        <p>The general SELFIES branch symbol has the form<disp-formula id="eqn5"><label>5</label>[<italic toggle="yes">β</italic>Branch<italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><!-- PBM data was replaced with SVG by xgml2pxml:
<glyph-data id="lscr.i" format="PBM" resolution="300" x-size="9" y-size="11" xml:space="preserve">
000000100
000001010
000010010
000010100
000011000
001110000
000100000
000100000
001100000
001101000
000110000
</glyph-data>
--><glyph-data id="lscr.i" format="SVG" resolution="300" x-size="9" y-size="11" xml:space="preserve">
<![CDATA[
<svg xmlns="http://www.w3.org/2000/svg" version="1.0" width="13.454545pt" height="16.000000pt" viewBox="0 0 13.454545 16.000000" preserveAspectRatio="xMidYMid meet"><metadata>
Created by potrace 1.16, written by Peter Selinger 2001-2019
</metadata><g transform="translate(1.000000,15.000000) scale(0.015909,-0.015909)" fill="currentColor" stroke="none"><path d="M480 840 l0 -40 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 -120 0 -120 -80 0 -80 0 0 -40 0 -40 40 0 40 0 0 -80 0 -80 -40 0 -40 0 0 -80 0 -80 40 0 40 0 0 -40 0 -40 80 0 80 0 0 40 0 40 40 0 40 0 0 40 0 40 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 160 0 160 40 0 40 0 0 40 0 40 40 0 40 0 0 40 0 40 40 0 40 0 0 40 0 40 40 0 40 0 0 80 0 80 -40 0 -40 0 0 40 0 40 -40 0 -40 0 0 -40z m80 -120 l0 -80 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 80 0 80 40 0 40 0 0 40 0 40 40 0 40 0 0 -80z"/></g></svg>
]]>
</glyph-data></private-char></italic>]</disp-formula>where <italic toggle="yes">β</italic> ∈ {<italic toggle="yes">ε</italic>, = , #} is a SMILES-like bond symbol and <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> ∈ {1, 2, 3}.</p>
      </sec>
      <sec>
        <label>3.1.3.</label>
        <title>Ring symbols</title>
        <p>SELFIES ring symbols can be further subdivided into two sub-types. These are of the form<disp-formula id="eqn6"><label>6</label><graphic xlink:href="d3dd00044c-t11.jpg" id="ugt11" position="float"/></disp-formula>where <italic toggle="yes">β</italic> ∈ {<italic toggle="yes">ε</italic>, = , #} and<disp-formula id="eqn7"><label>7</label><italic toggle="yes">β</italic><sub>1</sub>,<italic toggle="yes">β</italic><sub>2</sub> ∈ {−,/,\}, and not both <italic toggle="yes">β</italic><sub>1</sub> = <italic toggle="yes">β</italic><sub>2</sub> = −</disp-formula></p>
        <p>are SMILES-like bond symbols and <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> ∈ {1, 2, 3}, similar to branch symbols. The second ring symbol type (<xref rid="eqn6" ref-type="disp-formula">eqn (6)</xref>) is used to handle stereochemical specifications across ring bonds (see Section 3.5).</p>
      </sec>
      <sec>
        <label>3.1.4.</label>
        <title>Miscellaneous symbols</title>
        <p>SELFIES has a few auxiliary symbols that are not core to the representation. These symbols still have common use cases and are specially recognized by the functions in selfies that translate between SELFIES strings and SMILES strings (see Section 4.1):</p>
        <p>• The dot symbol, which can be used to express multiple disconnected fragments in a single SELFIES string, similar to its role in SMILES. The dot symbol is interpreted by treating it as delimiter and splitting the SELFIES string across the symbol. Then, each token is treated as an independent SELFIES string.</p>
        <p>• The [nop] (for “no-operation”) symbol, which is a special padding symbol ignored by selfies.</p>
        <p><xref rid="tab2" ref-type="table">Table 2</xref> provides examples of SELFIES atom, branch, and ring symbols.</p>
        <table-wrap position="float" id="tab2">
          <caption>
            <title>Example SELFIES symbols, by symbol type</title>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col span="1"/>
              <col span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1">Type</th>
                <th rowspan="1" colspan="1">Examples</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">Atom</td>
                <td rowspan="1" colspan="1">[#13C], [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O], [C@@H1], [N + 1]</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Branch</td>
                <td rowspan="1" colspan="1">[Branch3], [#Branch1], [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Branch2]</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Ring</td>
                <td rowspan="1" colspan="1">[<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Ring1], [/\Ring3], [Ring2]</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Misc.</td>
                <td rowspan="1" colspan="1">., [nop]</td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
    </sec>
    <sec>
      <label>3.2.</label>
      <title>The SELFIES grammar</title>
      <p>Now, we return to explaining the practical algorithm used to derive SMILES strings from their corresponding SELFIES strings. To do so, we first introduce the notion of a context-free grammar. A context-free grammar <italic toggle="yes">G</italic> is a tuple <italic toggle="yes">G</italic> = (<italic toggle="yes">V</italic>, <italic toggle="yes">Σ</italic>, <italic toggle="yes">R</italic>, <italic toggle="yes">S</italic>), where <italic toggle="yes">V</italic> and <italic toggle="yes">Σ</italic> are disjoint finite sets of nonterminal and terminal symbols, respectively, <italic toggle="yes">R</italic> ⊆ <italic toggle="yes">V</italic> × (<italic toggle="yes">V</italic> ∪ <italic toggle="yes">Σ</italic>)* is a finite relation,<xref rid="fn1" ref-type="fn">†</xref><fn id="fn1"><label>†</label><p>The Kleene star of a finite set of symbols <italic toggle="yes">A</italic>, denoted <italic toggle="yes">A</italic>*, is the set of all strings formed by concatenating finitely-many symbols from <italic toggle="yes">A</italic>, which includes the empty string.</p></fn> and <italic toggle="yes">S</italic> ∈ <italic toggle="yes">V</italic> is a so-called start symbol. Under <italic toggle="yes">G</italic>, strings of terminal symbols can be derived by performing a finite sequence of replacements starting with the single-symbol string <italic toggle="yes">σ</italic><sub>0</sub> = <italic toggle="yes">S</italic>. At each step <italic toggle="yes">t</italic>, if the current string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub> contains a nonterminal symbol <bold><italic toggle="yes">A</italic></bold> ∈ <italic toggle="yes">V</italic> (<italic toggle="yes">i.e.</italic>, <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub> = <italic toggle="yes">ρ</italic><sub>1</sub><bold><italic toggle="yes">A</italic></bold><italic toggle="yes">ρ</italic><sub>2</sub> for <italic toggle="yes">ρ</italic><sub>1</sub>, <italic toggle="yes">ρ</italic><sub>2</sub> ∈ (<italic toggle="yes">V</italic> ∪ <italic toggle="yes">Σ</italic>)*) and there is an (<bold><italic toggle="yes">A</italic></bold>, <italic toggle="yes">α</italic>) ∈ <italic toggle="yes">R</italic>, then we replace <bold><italic toggle="yes">A</italic></bold> with <italic toggle="yes">α</italic> to get the next string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic>+1</sub> = <italic toggle="yes">ρ</italic><sub>1</sub><italic toggle="yes">αρ</italic><sub>2</sub>. For this reason, tuples (<bold><italic toggle="yes">A</italic></bold>, <italic toggle="yes">α</italic>) ∈ <italic toggle="yes">R</italic> are called production rules, and are suggestively notated <bold><italic toggle="yes">A</italic></bold> → <italic toggle="yes">α</italic>. The derivation terminates once only terminal symbols remain. The derivation of SMILES strings under SELFIES is similar to the preceding process. In fact, a context-free grammar underlies SELFIES, which we call the SELFIES grammar.</p>
      <p>Specifically, the SELFIES grammar takes<disp-formula id="eqn8"><label>8</label><graphic xlink:href="d3dd00044c-t12.jpg" id="ugt12" position="float"/></disp-formula>where <inline-graphic xlink:href="d3dd00044c-t13.jpg" id="ugt13"/> is the maximum valence of all atom types. The production rules <italic toggle="yes">R</italic> will be characterized later. Given a SELFIES string, its corresponding SMILES string is then derived through a trajectory of replacements starting from <italic toggle="yes">S</italic>, as previously described. However, there are two further modifications that provides SELFIES its strong robustness. First, the replacements that are performed are not chosen arbitrarily, but are instead dictated by the SELFIES string of interest. At each derivation step, the next symbol of the SELFIES string is read off and fully specifies which production rule is applied. We systematically design this symbol-to-rule mapping such that the final derived SMILES string will always be valid. Second, SELFIES augments the grammar with self-referencing functions. These self-referencing functions manipulate the derivation process in more complicated ways than simple replacements, so they are not production rules. However, as before, the manner in which these self-referencing functions are applied is also dictated by the symbols in the SELFIES string. Thus, a SELFIES string can be viewed as a recipe of instructions (the symbols) that guides string derivation under the SELFIES grammar.</p>
    </sec>
    <sec>
      <label>3.3.</label>
      <title>Simple chain derivation</title>
      <p>Herein, we begin by considering the simplest type of SELFIES strings, those that correspond to simple chains of atoms. In SMILES, simple chains of atoms are represented by sequences of alternating atom and bond SMILES symbols, the latter of which can sometimes be left implicit by convention. Examples of such SMILES strings include CCCC (<italic toggle="yes">n</italic>-butane) and O<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>C<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O (carbon dioxide). Analogously, in SELFIES, simple chains are represented by sequences of SELFIES atom symbols, which can be understood as playing a similar role as a grouping of a SMILES atom symbol and its preceding SMILES bond symbol. Simple chains are the easiest to derive in SELFIES, because the process occurs only through mere replacements, as in regular context-free grammars.</p>
      <p>The derivation of a simple chain starts with the initial string <italic toggle="yes">σ</italic><sub>0</sub> = <italic toggle="yes">S</italic>. Recall that the SELFIES symbols dictate how production rules are applied. For simple chains, this is achieved by having each pair of SELFIES atom symbol and nonterminal symbol <italic toggle="yes">A</italic> ∈ <italic toggle="yes">V</italic> determine a production rule of the form <italic toggle="yes">A</italic> → <italic toggle="yes">α A</italic>′, where <italic toggle="yes">α</italic> ∈ <italic toggle="yes">Σ</italic>* is a terminal string and <italic toggle="yes">A</italic>′ ∈ <italic toggle="yes">V</italic> ∪ {<italic toggle="yes">ε</italic>}. Then, a sequence of replacements is iteratively performed by treating the SELFIES string as a queue <inline-graphic xlink:href="d3dd00044c-t14.jpg" id="ugt14"/> of SELFIES symbols. At each step, the head of <inline-graphic xlink:href="d3dd00044c-t15.jpg" id="ugt15"/> is popped<xref rid="fn2" ref-type="fn">‡</xref><fn id="fn2"><label>‡</label><p>To pop or dequeue the head of a queue <inline-graphic xlink:href="d3dd00044c-t1.jpg" id="ugt1"/> means to fetch and then remove the oldest item in <inline-graphic xlink:href="d3dd00044c-t2.jpg" id="ugt2"/></p></fn> and, with a nonterminal symbol in the current string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub>, is used to select and apply a production rule to get the next string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic>+1</sub>. Note that <italic toggle="yes">σ</italic><sub>0</sub> = <italic toggle="yes">S</italic> is itself a single nonterminal symbol, and each rule induced by a SELFIES atom symbol replaces one nonterminal symbol by another. Hence, throughout the derivation, the current string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub> will always contain at most one nonterminal symbol and there is never any ambiguity as to how or which production rule is applied. Once the current string has only terminal symbols or <inline-graphic xlink:href="d3dd00044c-t16.jpg" id="ugt16"/> is empty, the process ends (since SELFIES strings are finite, termination necessarily occurs). The final derived SMILES string is read off by dropping all nonterminal symbols.</p>
      <p>We now fully enumerate the SELFIES atom symbol to production rule mapping. Let [<italic toggle="yes">βα</italic>] be a generic atom symbol, as described in <xref rid="eqn3" ref-type="disp-formula">eqn (3)</xref>. Based on this symbol, we first define the terminal string<disp-formula id="eqn9"><label>9</label><graphic xlink:href="d3dd00044c-t17.jpg" id="ugt17" position="float"/></disp-formula>where <inline-graphic xlink:href="d3dd00044c-t18.jpg" id="ugt18"/> are the symbols of elements in the SMILES organic subset. The string <inline-graphic xlink:href="d3dd00044c-t19.jpg" id="ugt19"/> can be thought of as transforming <italic toggle="yes">α</italic> into the SMILES syntax. Then [<italic toggle="yes">βα</italic>] together with the nonterminal symbol <italic toggle="yes">S</italic> ∈ <italic toggle="yes">V</italic> specifies the production rule:<disp-formula id="eqn10"><label>10</label><bold><italic toggle="yes">S</italic></bold> → <italic toggle="yes"><private-char name="ITALIC SMALL ALPHA, GREEK, TILDE" description="italic small alpha, Greek, tilde"><!-- PBM data was replaced with SVG by xgml2pxml:
<glyph-data id="z.agrt.i" format="PBM" resolution="300" x-size="10" y-size="11" xml:space="preserve">
0000000000
0001110010
0001001110
0000000000
0001110100
0010001100
0010001000
0100001000
0100011000
0100101010
0011001100
</glyph-data>
--><glyph-data id="z.agrt.i" format="SVG" resolution="300" x-size="10" y-size="11" xml:space="preserve">
<![CDATA[
<svg xmlns="http://www.w3.org/2000/svg" version="1.0" width="14.727273pt" height="16.000000pt" viewBox="0 0 14.727273 16.000000" preserveAspectRatio="xMidYMid meet"><metadata>
Created by potrace 1.16, written by Peter Selinger 2001-2019
</metadata><g transform="translate(1.000000,15.000000) scale(0.015909,-0.015909)" fill="currentColor" stroke="none"><path d="M240 720 l0 -80 40 0 40 0 0 40 0 40 80 0 80 0 0 -40 0 -40 120 0 120 0 0 80 0 80 -40 0 -40 0 0 -40 0 -40 -80 0 -80 0 0 40 0 40 -120 0 -120 0 0 -80z M240 520 l0 -40 -40 0 -40 0 0 -80 0 -80 -40 0 -40 0 0 -120 0 -120 40 0 40 0 0 -40 0 -40 80 0 80 0 0 40 0 40 40 0 40 0 0 40 0 40 40 0 40 0 0 -80 0 -80 80 0 80 0 0 40 0 40 40 0 40 0 0 40 0 40 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 160 0 160 40 0 40 0 0 80 0 80 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 40 0 40 -120 0 -120 0 0 -40z m240 -160 l0 -120 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 -40 0 -40 -80 0 -80 0 0 120 0 120 40 0 40 0 0 80 0 80 120 0 120 0 0 -120z"/></g></svg>
]]>
</glyph-data></private-char></italic><bold><italic toggle="yes">X</italic></bold><sub><italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic></sub></disp-formula>where <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> = <italic toggle="yes">ν</italic>(type(<italic toggle="yes">α</italic>)) is the valence of the atom type specified by <italic toggle="yes">α</italic>, and we hereafter define <italic toggle="yes">X</italic><sub>0</sub> = <italic toggle="yes">ε</italic> to be the empty string to handle the case where <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> = 0. The atom symbol [<italic toggle="yes">βα</italic>] together with the symbol <italic toggle="yes">X</italic><sub><italic toggle="yes">i</italic></sub> ∈ <italic toggle="yes">V</italic>, where <inline-graphic xlink:href="d3dd00044c-t20.jpg" id="ugt20"/> specifies a production of the form:<disp-formula id="eqn11"><label>11</label><graphic xlink:href="d3dd00044c-t21.jpg" id="ugt21" position="float"/></disp-formula>where <italic toggle="yes">d</italic><sub>0</sub> = min(<italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>, <italic toggle="yes">i</italic>, <italic toggle="yes">d</italic>(<italic toggle="yes">β</italic>)). Here, <italic toggle="yes">d</italic>(<italic toggle="yes">β</italic>) is a function that returns the order of the bond type represented by <italic toggle="yes">β</italic>:<disp-formula id="eqn12"><label>12</label><graphic xlink:href="d3dd00044c-t22.jpg" id="ugt22" position="float"/></disp-formula>and <italic toggle="yes">β</italic><sub>↓</sub>(<italic toggle="yes">n</italic>) is a function that demotes <italic toggle="yes">β</italic> into a SMILES token representing a bond of lower order <italic toggle="yes">n</italic> ≤ <italic toggle="yes">d</italic>(<italic toggle="yes">β</italic>):<disp-formula id="eqn13"><label>13</label><graphic xlink:href="d3dd00044c-t23.jpg" id="ugt23" position="float"/></disp-formula></p>
      <p>In <xref rid="eqn10" ref-type="disp-formula">eqn (10)</xref> and <xref rid="eqn11" ref-type="disp-formula">(11)</xref>, the nonterminal symbols <italic toggle="yes">X</italic><sub>m</sub> are intuitively memorizing the maximum number of bonds that the most recently derived atom can adopt; the nonterminal symbol <italic toggle="yes">X</italic><sub>m</sub> can be understood as encoding that the last atom can make at most m bonds. When the next atom is derived, the bond connecting it to the preceding atom has its order decreased minimally such that the bond constraints are always satisfied.</p>
      <p>Examples: To show these production rules in a concrete setting, we will translate the SELFIES string<disp-formula id="eqn14"><label>14</label><graphic xlink:href="d3dd00044c-t24.jpg" id="ugt24" position="float"/></disp-formula></p>
      <p>along with the constraints in <xref rid="eqn1" ref-type="disp-formula">eqn (1)</xref>. The derivation of its corresponding SMILES string would proceed step-wise as follows:<disp-formula id="eqn15"><label>15</label><graphic xlink:href="d3dd00044c-t25.jpg" id="ugt25" position="float"/></disp-formula>where each line <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub> ⇒ <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic>+1</sub> ([<italic toggle="yes">βα</italic>]) is used to denote a step of the derivation process induced by the SELFIES symbol [<italic toggle="yes">βα</italic>]. The final derived SMILES string in this case is COCF. Now, for a more complicated example, consider the SELFIES string<disp-formula id="eqn16"><label>16</label><graphic xlink:href="d3dd00044c-t26.jpg" id="ugt26" position="float"/></disp-formula></p>
      <p>under the same constraints. The derivation proceeds as<disp-formula id="eqn17"><label>17</label><graphic xlink:href="d3dd00044c-t27.jpg" id="ugt27" position="float"/></disp-formula></p>
      <p>producing the final SMILES string [CH3][13CH1]<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O. Note that isotopes are assumed to share the same valence, and when hydrogen atoms are specified in an atom type, its valence is decremented accordingly.</p>
    </sec>
    <sec>
      <label>3.4.</label>
      <title>Branch derivation</title>
      <p>So far, we discussed chains of atoms, and their connectivity. However, most molecules are more complex than simple linear chains. Therefore, now, we talk about the derivations of branches (followed by rings in the subsequent section). In SMILES, branches are specified by enclosing a SMILES substring in parentheses, which can be recursively nested; for example, CC(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)O (acetic acid) and C(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)(C(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)O)O (oxalic acid). In SELFIES, branches are specified by SELFIES branch symbols, and similar to atom symbols, every pair of SELFIES branch symbol and nonterminal symbol determine some rule on how to modify the current string. We can encode branched trees of atoms in SELFIES by sequences of atom and branch symbols.</p>
      <p>The derivation process extends that for simple chains (in Section 3.3), where we pop SELFIES symbols step-by-step off of a queue <inline-graphic xlink:href="d3dd00044c-t28.jpg" id="ugt28"/>. We only add an additional rule for when we dequeue a branch symbol from <inline-graphic xlink:href="d3dd00044c-t29.jpg" id="ugt29"/>. Let this symbol be [<italic toggle="yes">β</italic>Branch<italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>], as in <xref rid="eqn5" ref-type="disp-formula">eqn (5)</xref>, and let <italic toggle="yes">A</italic> be a nonterminal symbol in the current string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub>. If <italic toggle="yes">A</italic> ∈ {<italic toggle="yes">S</italic>, <italic toggle="yes">X</italic><sub>1</sub>}, then this specifies the application of the production rule <italic toggle="yes">A</italic> → <italic toggle="yes">A</italic>. Effectively, the branch symbol is ignored in this case. If <italic toggle="yes">A</italic> = <italic toggle="yes">X</italic><sub><italic toggle="yes">i</italic></sub> for <italic toggle="yes">i</italic> ≥ 2, then we perform a replacement:<disp-formula id="eqn18"><label>18</label><bold><italic toggle="yes">A</italic></bold> → <italic toggle="yes">ρ</italic><bold><italic toggle="yes">X</italic></bold><sub><italic toggle="yes">i</italic>−d<sub>0</sub></sub></disp-formula>where <italic toggle="yes">d</italic><sub>0</sub> = min(<italic toggle="yes">i</italic> − 1, <italic toggle="yes">d</italic>(<italic toggle="yes">β</italic>)), and <italic toggle="yes">ρ</italic> ∈ <italic toggle="yes">Σ</italic>* is a SMILES substring obtained through the following recursive process.</p>
      <p>First, <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> symbols are popped from <inline-graphic xlink:href="d3dd00044c-t30.jpg" id="ugt30"/> and converted into integer values by the mapping summarized in <xref rid="tab3" ref-type="table">Table 3</xref>. Let <italic toggle="yes">c</italic><sub>1</sub>⋯, <italic toggle="yes">c</italic><sub><italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic></sub> be the indices in first-to-last order of retrieval. In the event that <inline-graphic xlink:href="d3dd00044c-t31.jpg" id="ugt31"/> contains fewer than <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> symbols, the missing indices are set to have a default value of 0. Next, these indices are identified with a natural number <inline-graphic xlink:href="d3dd00044c-t32.jpg" id="ugt32"/> by treating them as hexadecimal digits:<disp-formula id="eqn19"><label>19</label><graphic xlink:href="d3dd00044c-t33.jpg" id="ugt33" position="float"/></disp-formula></p>
      <table-wrap position="float" id="tab3">
        <caption>
          <title>The symbols succeeding a branch or ring SELFIES symbol are sometimes overloaded with a numeric index, which is determined by the following symbol-to-index mapping</title>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col span="1"/>
            <col span="1"/>
            <col span="1"/>
            <col span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Index</th>
              <th rowspan="1" colspan="1">Symbol</th>
              <th rowspan="1" colspan="1">Index</th>
              <th rowspan="1" colspan="1">Symbol</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">[C]</td>
              <td rowspan="1" colspan="1">8</td>
              <td rowspan="1" colspan="1">[#Branch2]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">[Ring1]</td>
              <td rowspan="1" colspan="1">9</td>
              <td rowspan="1" colspan="1">[O]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">2</td>
              <td rowspan="1" colspan="1">[Ring2]</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">[N]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">[Branch1]</td>
              <td rowspan="1" colspan="1">11</td>
              <td rowspan="1" colspan="1">[<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>N]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">[<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Branch1]</td>
              <td rowspan="1" colspan="1">12</td>
              <td rowspan="1" colspan="1">[<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>C]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">[#Branch1]</td>
              <td rowspan="1" colspan="1">13</td>
              <td rowspan="1" colspan="1">[#C]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">[Branch2]</td>
              <td rowspan="1" colspan="1">14</td>
              <td rowspan="1" colspan="1">[S]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">7</td>
              <td rowspan="1" colspan="1">[<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Branch2]</td>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">[P]</td>
            </tr>
            <tr>
              <td colspan="4" rowspan="1">All other symbols are assigned index 0</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Then, <italic toggle="yes">N</italic> symbols from <inline-graphic xlink:href="d3dd00044c-t34.jpg" id="ugt34"/> (or all symbols in <inline-graphic xlink:href="d3dd00044c-t35.jpg" id="ugt35"/> if fewer exist) are consumed to form a new SELFIES string, and with start symbol <inline-graphic xlink:href="d3dd00044c-t36.jpg" id="ugt36"/> (instead of <italic toggle="yes">S</italic> = <italic toggle="yes">S</italic> as before), this substring is recursively derived into a SMILES string <italic toggle="yes">ρ</italic><sub>0</sub>. We take <italic toggle="yes">ρ</italic> = <italic toggle="yes">ε</italic> if <italic toggle="yes">ρ</italic><sub>0</sub> = <italic toggle="yes">ε</italic>, and <italic toggle="yes">ρ</italic> = (<italic toggle="yes">ρ</italic><sub>0</sub>) otherwise.<xref rid="fn3" ref-type="fn">§</xref><fn id="fn3"><label>§</label><p>A minor technicality occurs if <italic toggle="yes">ρ</italic><sub>0</sub> starts with a branch parentheses (, in which case <italic toggle="yes">ρ</italic> is of the form ((<italic toggle="yes">α</italic><sub>1</sub>),…,(<italic toggle="yes">α</italic><sub><italic toggle="yes">m</italic></sub>)<italic toggle="yes">α</italic><sub><italic toggle="yes">m</italic>+1</sub>) for strings <italic toggle="yes">α</italic><sub><italic toggle="yes">k</italic></sub> ∈ <italic toggle="yes">Σ</italic>* that do not start with (. This would result in an invalid SMILES string because branches cannot start with other branches in SMILES. To amend this, we naturally interpret and replace <italic toggle="yes">ρ</italic> with the string (<italic toggle="yes">α</italic><sub>1</sub>),…,(<italic toggle="yes">α</italic><sub><italic toggle="yes">m</italic></sub>)(<italic toggle="yes">α</italic><sub><italic toggle="yes">m</italic>+1</sub>).</p></fn></p>
      <p>Examples: To provide an overview of branch derivation, we translate a SELFIES string representing acetic acid:<disp-formula id="eqn20"><label>20</label><graphic xlink:href="d3dd00044c-t37.jpg" id="ugt37" position="float"/></disp-formula></p>
      <p>Processing the first two SELFIES symbols [O][C] results in the string OC <italic toggle="yes">X</italic><sub>3</sub>, after which the symbol [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Branch1] is dequeued. Since <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> = 1, we consume the next symbol [C] in <inline-graphic xlink:href="d3dd00044c-t38.jpg" id="ugt38"/> and identify it with <italic toggle="yes">N</italic> = 1. Hence, we create the SELFIES substring [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O] from popping the next symbol in <inline-graphic xlink:href="d3dd00044c-t39.jpg" id="ugt39"/> and, with start symbol <italic toggle="yes">X</italic><sub>2</sub>, recursively derive it into the SMILES substring <italic toggle="yes">ρ</italic> = (<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O). Then, performing the replacement in <xref rid="eqn18" ref-type="disp-formula">eqn (18)</xref> gives the string OC(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O) <italic toggle="yes">X</italic><sub>1</sub>, and processing the last symbol [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>C] in <inline-graphic xlink:href="d3dd00044c-t40.jpg" id="ugt40"/> finally produces a SMILES string OC(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)C for acetic acid. Another SELFIES string that corresponds to OC(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)C is:<disp-formula id="eqn21"><label>21</label><graphic xlink:href="d3dd00044c-t41.jpg" id="ugt41" position="float"/></disp-formula></p>
      <p>The derivation is largely similar to that before. The major difference is that when the branch symbol is dequeued, the next <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> = 2 symbols [C][Ring1] are identified with <italic toggle="yes">N</italic> = 1 + 16(0) + 1 = 2, and then, the SELFIES substring [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O][F] is used to again derive <italic toggle="yes">ρ</italic> = (<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O).</p>
    </sec>
    <sec>
      <label>3.5.</label>
      <title>Ring derivation</title>
      <p>The final feature that is necessary to capture the diverse variety of molecules is the ability to encode ring closures. In SMILES, this is achieved by paired numeric tags that indicate two separate atoms are joined together; for example, CC1CCC1 (methylcyclobutane). By adding bond characters before the numbers, SMILES can also specify ring closures of higher bond orders, such as C<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>1CCCC<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>1 (cyclopentene). In SELFIES, ring closures are specified by ring symbols, which behave similarly to branch symbols. The derivation process extends that in Section 3.4.</p>
      <p>Per <xref rid="eqn6" ref-type="disp-formula">eqn (6)</xref>, there are two forms of SELFIES ring symbols. To simplify the ensuing discussion, however, we will begin by only considering the first form. When a ring symbol [<italic toggle="yes">β</italic> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>] is popped from the queue of SELFIES symbols <inline-graphic xlink:href="d3dd00044c-t42.jpg" id="ugt42"/> a nonterminal symbol <italic toggle="yes">A</italic> in the current derived string is used to specify a production rule. If <italic toggle="yes">A</italic> = <italic toggle="yes">S</italic>, then we apply the rule <italic toggle="yes">A</italic> → <italic toggle="yes">A</italic>, and the ring symbol is effectively skipped. If <italic toggle="yes">A</italic> = <italic toggle="yes">Xi</italic>, then we replace:<disp-formula id="eqn22"><label>22</label><bold><italic toggle="yes">A</italic></bold> → <bold><italic toggle="yes">X</italic></bold><sub><italic toggle="yes">i</italic>−min(<italic toggle="yes">i</italic>,<italic toggle="yes">d</italic>(<italic toggle="yes">β</italic>))</sub></disp-formula></p>
      <p>In addition, we consume the next <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> symbols of <inline-graphic xlink:href="d3dd00044c-t43.jpg" id="ugt43"/> (or all symbols in <inline-graphic xlink:href="d3dd00044c-t44.jpg" id="ugt44"/> if fewer exist) to specify a number <inline-graphic xlink:href="d3dd00044c-t45.jpg" id="ugt45"/> by <xref rid="eqn19" ref-type="disp-formula">eqn (19)</xref>. Then, the ring symbol would indicate that a ring closure should be formed between the ring-initiating atom and the <italic toggle="yes">N</italic>-th atom previously derived from it (or simply, the first atom if less than <italic toggle="yes">N</italic> such atoms exist). Here, the derivation order is the order in which atoms are realized through the production rules in <xref rid="eqn10" ref-type="disp-formula">eqn (10)</xref> and <xref rid="eqn11" ref-type="disp-formula">(11)</xref>. By ring-initiating atom, we also mean the atom at which bonds would be made if the ring symbol were instead an atom symbol. Often, this coincides with the last-derived atom, as is the case in:<disp-formula id="eqn23"><label>23</label>NC(C)COC*†<bold><italic toggle="yes">X</italic></bold><sub>4</sub></disp-formula>where the ring-initiating and last-derived atoms are marked with an asterisk and dagger, respectively. However, this is not the case when the last-derived atom lies within a fully-derived branch:<disp-formula id="eqn24"><label>24</label>NC(C)COC*(C)(C†)<bold><italic toggle="yes">X</italic></bold><sub>1</sub></disp-formula></p>
      <p>For brevity, we will refer to the ring-initiating atom as the right ring atom and its counterpart the left ring atom, as the latter precedes the former in a SMILES string under derivation order.</p>
      <p>Although a ring symbol specifies a closure between the left and right ring atoms, such a bond cannot be naively added since it may cause valences to be violated for the left ring atom immediately (<italic toggle="yes">e.g.</italic>, consider the case where this atom has already attained its maximum valence) or in the future. Hence, SELFIES postpones the creation of ring closures to a final post-processing step. Instead, the ring closure candidates are pushed to a temporary queue <inline-graphic xlink:href="d3dd00044c-t46.jpg" id="ugt46"/> and once all the SELFIES symbols have been processed, the items in <inline-graphic xlink:href="d3dd00044c-t47.jpg" id="ugt47"/> are revisited in first-to-last order. Based on the state of the ring atoms, a candidate may be rejected (and no ring bond is made) or executed.</p>
      <p>Specifically, given a potential ring closure indicated by symbol [<italic toggle="yes">β</italic> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>], let <italic toggle="yes">m</italic><sub>1</sub> and <italic toggle="yes">m</italic><sub>2</sub> be the number of additional bonds that the left and right ring atoms can make, respectively. If <italic toggle="yes">m</italic><sub>1</sub> = 0 or <italic toggle="yes">m</italic><sub>2</sub> = 0, we must reject the candidate since adding the ring closure would exceed one of the valences of the ring atom. The candidate is also rejected if its left and right ring atoms are not distinct, to avoid unphysical self-loops. Otherwise, the candidate is accepted, and, assuming there is no pre-existing bond between its two ring atoms, we form a new bond of order <italic toggle="yes">d</italic><sub>0</sub> = min(<italic toggle="yes">d</italic>(<italic toggle="yes">β</italic><sub>1</sub>), <italic toggle="yes">m</italic><sub>1</sub>, <italic toggle="yes">m</italic><sub>2</sub>) between them. If a prior bond does exist (<italic toggle="yes">e.g.</italic>, if a duplicate ring closure is specified earlier in <inline-graphic xlink:href="d3dd00044c-t48.jpg" id="ugt48"/>), then we increment the order of this existing bond as necessary. That is, if the existing bond is of order <italic toggle="yes">d</italic><sub>1</sub>, then we promote it to a bond of potentially-higher order min(3, <italic toggle="yes">d</italic><sub>1</sub> + <italic toggle="yes">d</italic><sub>0</sub>).</p>
      <p>Examples: We translate a SELFIES string representing methylcyclobutane:<disp-formula id="eqn25"><label>25</label><graphic xlink:href="d3dd00044c-t49.jpg" id="ugt49" position="float"/></disp-formula></p>
      <p>The first five symbols produce the string CCCCC <bold><italic toggle="yes">X</italic></bold><sub>4</sub>, after which the ring symbol [Ring1] is dequeued. Since <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> = 1, the next and final symbol [Ring2] specifies a single ring bond between the final C and its <italic toggle="yes">N</italic> = 3rd preceding atom. This produces the SMILES string CC1CCC1. Note that incrementing the indexing symbol:<disp-formula id="eqn26"><label>26</label><graphic xlink:href="d3dd00044c-t50.jpg" id="ugt50" position="float"/></disp-formula></p>
      <p>increments the distance of the ring closure, hence producing a SMILES string for cyclopentane C1CCCC1. Appending a copy of the ring and index symbols:<disp-formula id="eqn27"><label>27</label><graphic xlink:href="d3dd00044c-t51.jpg" id="ugt51" position="float"/></disp-formula>increments the bond order of the ring closure and produces the SMILES string CC<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>1CCC<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>1.</p>
      <p>The second ring symbol form [<italic toggle="yes">β</italic><sub>1</sub><italic toggle="yes">β</italic><sub>2</sub> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>] in <xref rid="eqn3" ref-type="disp-formula">eqn (3)</xref> behaves nearly identically to [Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>], and is used to support specification of stereochemistry across single ring bonds. The only difference occurs when a ring closure candidate produced by [<italic toggle="yes">β</italic><sub>1</sub><italic toggle="yes">β</italic><sub>2</sub> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>] is accepted, and a new ring bond is added between the two ring atoms. In this case, if <italic toggle="yes">β</italic><sub>1</sub> ∈ {/, \}, then we add the bond character <italic toggle="yes">β</italic><sub>1</sub> before the numeric ring tag on the left ring atom, and similarly with <italic toggle="yes">β</italic><sub>2</sub> and the right ring atom. For instance, if the example <xref rid="eqn25" ref-type="disp-formula">eqn (25)</xref> used the symbol [/−Ring1] instead of [Ring1], then the derived SMILES string would be CC/1CCC1.</p>
    </sec>
  </sec>
  <sec>
    <label>4.</label>
    <title>Library design</title>
    <p>The selfies library is designed to be fast, lightweight, and user-friendly. A small but nice feature of selfies is that it also requires no extra dependencies. At its core, there are two functions that facilitate the interconversion between SELFIES strings and SMILES strings. For more advanced usage, we provide functions to customize the underlying semantic constraints that selfies enforces and operates upon. The default constraints are given in <xref rid="tab4" ref-type="table">Table 4</xref>, and are intended for organic molecules with single, double, or triple bonds. Finally, we also provide a variety of utility functions for manipulating SELFIES strings. The following describes each type of function in more detail and provides potential use case examples. All code snippets are written in Python, with selfies being a Python library.</p>
    <table-wrap position="float" id="tab4">
      <caption>
        <title>The default constraints used by selfies. All atom types other than those explicitly listed below are constrained to 8 maximum bonds, which acts as a catch-all constraint</title>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col span="1"/>
          <col span="1"/>
          <col span="1"/>
          <col span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="2" colspan="1">Element</th>
            <th colspan="3" rowspan="1">Maximum bonds</th>
          </tr>
          <tr>
            <th rowspan="1" colspan="1">Charge 0</th>
            <th rowspan="1" colspan="1">Charge +1</th>
            <th rowspan="1" colspan="1">Charge −1</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">H, F, Cl, Br, I</td>
            <td rowspan="1" colspan="1">1</td>
            <td rowspan="1" colspan="1">—</td>
            <td rowspan="1" colspan="1">—</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">B</td>
            <td rowspan="1" colspan="1">3</td>
            <td rowspan="1" colspan="1">2</td>
            <td rowspan="1" colspan="1">4</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">C</td>
            <td rowspan="1" colspan="1">4</td>
            <td rowspan="1" colspan="1">5</td>
            <td rowspan="1" colspan="1">3</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">N</td>
            <td rowspan="1" colspan="1">3</td>
            <td rowspan="1" colspan="1">4</td>
            <td rowspan="1" colspan="1">2</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">O</td>
            <td rowspan="1" colspan="1">2</td>
            <td rowspan="1" colspan="1">3</td>
            <td rowspan="1" colspan="1">1</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">P</td>
            <td rowspan="1" colspan="1">5</td>
            <td rowspan="1" colspan="1">6</td>
            <td rowspan="1" colspan="1">4</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">S</td>
            <td rowspan="1" colspan="1">6</td>
            <td rowspan="1" colspan="1">7</td>
            <td rowspan="1" colspan="1">5</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <sec>
      <label>4.1.</label>
      <title>Core functions</title>
      <p>SELFIES strings can conveniently be created from and turned into SMILES strings using the functions encoder( ) and decoder( ), respectively. The latter derives a SMILES string from a SELFIES string, using the procedure described in Section 3. The former performs the translation in the reverse direction such that passing a SMILES string through the composition decoder(encoder( )) is always guaranteed to recover a SMILES string that represents the same molecule (but not necessarily the original SMILES string itself). The recovered SMILES string will also maintain the molecular traversal order (<italic toggle="yes">i.e.</italic>, the specification order of the atoms) of the original string. The following excerpt defines a toy function roundtrip( ) that illustrates this:<graphic xlink:href="d3dd00044c-u1.jpg" id="ugr1" position="float"/></p>
      <p>Line 5 translates the SMILES string for benzene into the SELFIES string in Line 11. Notably, SELFIES does not support aromatic atom symbols (<italic toggle="yes">e.g.</italic>, c) in the same way as SMILES, so encoder( ) performs an internal kekulization if it is passed an aromatic SMILES string. Line 7 guards against errors raised by encoder( ) when being passed SMILES strings that are syntactically invalid, semantically invalid (<italic toggle="yes">i.e.</italic>, violate the constraints described in the next subsection), or unsupported. An unsupported SMILES string uses features of SMILES that are not implemented in SELFIES, such as the wildcard * and quadruple bond $ symbols; the API reference of selfies further details which SMILES strings are currently supported. Line 10 applies the roundtrip( ) function to a SMILES string c1ccccc1 for benzene. Indeed, this round-trip translation recovers a SMILES string C1<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>CC<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>CC<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>C1 that is different than the original string, but still specifies the (kekulized) benzene molecule.</p>
      <p>In greater detail, given an input SMILES string, encoder( ) first performs a kekulization if it contains any aromatic atom symbols, as was in the example above. Next, the actual translation process begins. In the simplest case, if the input represents a simple atom chain, then a translation to SELFIES is performed by essentially grouping each atom symbol with its preceding bond symbol, if any. For example, the SMILES string O<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>[13CH]C#N would be partitioned into O, <private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char> [13CH], C, #N and turned respectively into SELFIES symbols [O][<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>13CH1][C][#N]. Branches are recursively translated and the result is used to work backwards to find the appropriate branch and indexing symbols to prepend. If there are multiple plausible choices, we use the one in which the branch symbol [<italic toggle="yes">β</italic>Branch<italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>] has <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> minimized and <italic toggle="yes">β</italic> representing the bond connecting the branch to the parent chain. For instance, C(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)O is encoded as [C][<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Branch1][C][<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O][O] instead of [C][#Branch2][C][C][<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O][O], despite both SELFIES strings producing C(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)O under the derivation process. Finally, ring closures are handled similarly in that we work backwards to find the appropriate ring and indexing symbols. If there are multiple choices, we use the one in which the ring symbol [<italic toggle="yes">β</italic> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>] (or [<italic toggle="yes">β</italic><sub>1</sub><italic toggle="yes">β</italic><sub>2</sub> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>]) has <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> minimized and <italic toggle="yes">β</italic> (or <italic toggle="yes">β</italic><sub>1</sub>, <italic toggle="yes">β</italic><sub>2</sub>) representing the bond of the ring closure.</p>
      <sec>
        <label>4.1.1.</label>
        <title>SELFIES and SMILES</title>
        <p>The core functions of selfies interconvert between SELFIES and SMILES; and in Section 3, we present the method of interpreting SELFIES strings by deriving SMILES strings under a simple augmented grammar, following the previous SELFIES paper.<sup><xref rid="cit10" ref-type="bibr">10</xref></sup> However, it is important to note that SELFIES is not conceptually reliant on SMILES, and we may just as naturally interpret SELFIES strings through deriving molecular graphs. In fact, before version 2.0.0, both encoder( ) and decoder( ) were implemented as direct string-to-string translations. We have since refactored the functions to convert the input string to an intermediate graph-based representation, which is subsequently transcribed in the target representation. Future work could then expose this graph representation with a clean interface, allowing users to use selfies in a SMILES-independent manner.</p>
      </sec>
      <sec>
        <label>4.1.2.</label>
        <title>Random SELFIES</title>
        <p>Since every string of SELFIES symbols can be derived into a valid SMILES string, we can generate random but valid SMILES strings by passing random SELFIES strings through decoder( ). To sample these SELFIES strings, we use the get_semantic_robust_alphabet( ) utility function, which returns a subset of semantically constrained SELFIES symbols:<graphic xlink:href="d3dd00044c-u2.jpg" id="ugr2" position="float"/></p>
        <p>Note that by changing the pool of SELFIES symbols from which we sample from, we can change the distribution of produced molecules.</p>
      </sec>
    </sec>
    <sec>
      <label>4.2.</label>
      <title>Explaining translation</title>
      <p>To explain translations between SELFIES and SMILES, both encoder( ) and decoder( ) support an attribute flag that enables attributions of the output string symbol(s) to symbol(s) in the input string:<graphic xlink:href="d3dd00044c-u3.jpg" id="ugr3" position="float"/></p>
      <p>The attributions are a list of AttributionMap objects, one for each output symbol. Each AttributionMap contains the output symbol, its index, and a list of Attribution objects, each of which holds an input symbol (and its index) that is responsible for the output symbol. Note that a single output symbol may be attributed to multiple input symbols because it may be determined by both atom symbols and branch or ring symbols. Tracing the relationship between symbols can enable alignment between SMILES and SELFIES so that per-atom properties can be connected on both sides of the translation.</p>
    </sec>
    <sec>
      <label>4.3.</label>
      <title>Customization functions</title>
      <p>The selfies library dynamically constructs its derivation rules from a set of prespecified constraints, which dictate the maximum number of bonds that each atom type in a molecule may form. The derivation rules then ensure that each SELFIES string corresponds to a molecular graph satisfying the set constraints. By choosing a set of constraints in accordance with chemical valences, 100% robustness can be achieved. Specifically, selfies uses the constraints in <xref rid="tab4" ref-type="table">Table 4</xref> by default.</p>
      <p>However, a limitation of the default constraints is that SELFIES cannot represent existing molecules that violate them, such as perchloric acid (which features a hypervalent Cl making 7 bonds). Moreover, the catch-all constraint may be too relaxed to ensure the validity of SELFIES strings containing atom types outside those in <xref rid="tab4" ref-type="table">Table 4</xref> (<italic toggle="yes">e.g.</italic>, Si, Se). Hence, users may wish to instead use custom constraints that are tailored to the SELFIES strings being worked with. To this end, selfies provides the key function set_semantic_constraints( ). The following provides a minimal example:<graphic xlink:href="d3dd00044c-u4.jpg" id="ugr4" position="float"/></p>
      <p>Here, the constraints dictionary encodes a set of custom constraints; specifically, explicit constraints on the neutral and ±1 charged variants of C (as in <xref rid="tab4" ref-type="table">Table 4</xref>) and a catch-all constraint (of 4 maximum bonds). Line 8 then sets constraints as the underlying semantic constraints that selfies will operate under, which changes the subsequent behaviour of encoder( ) and decoder( ) appropriately. Note that the pre-existing constraints are fully replaced in Line 8; any constraint that is not explicitly specified in constraints would be thus removed.</p>
      <p>For convenience, selfies provides a couple of preset constraints to serve as templates that can be easily modified. These can be obtained as follows:<graphic xlink:href="d3dd00044c-u5.jpg" id="ugr5" position="float"/></p>
      <p>The currently-set constraints can also be viewed by:<graphic xlink:href="d3dd00044c-u6.jpg" id="ugr6" position="float"/></p>
    </sec>
    <sec>
      <label>4.4.</label>
      <title>Utility functions</title>
      <p>The selfies library provides a number of utility and convenience functions. Two basic utility functions are len_selfies( ), which computes the number of symbols in a SELFIES string, and split_selfies( ), which tokenizes a SELFIES string into an iterable of its constituent symbols:<graphic xlink:href="d3dd00044c-u7.jpg" id="ugr7" position="float"/></p>
      <p>Furthermore, selfies includes functions to extract a vocabulary of symbols from a dataset of SELFIES strings, and to convert SELFIES strings into label or one-hot encodings. Consider the following example:<graphic xlink:href="d3dd00044c-u8.jpg" id="ugr8" position="float"/></p>
      <p>Here, we are given a list dataset of SELFIES strings. Line 7 uses a utility function of selfies to extract the set alphabet of SELFIES symbols that appear in the dataset, which is used in Line 13 to create a symbol to index mapping termed stoi. Next, lines 17–22 use another utility function selfies_to_encoding( ) to create a label and one-hot encoding of the first SELFIES string in the dataset. Under the hood, this function first pads the input string to length pad_to_len by appending to it sufficiently many copies of the symbol [nop] (for “no-operation”), which is a special padding symbol in selfies that is automatically ignored by decoder( ). Then, the padded SELFIES string is tokenized, and stoi is used to convert each of its symbols into integer labels and one-hot vectors. Since the padded SELFIES string may now contain [nop], this symbol must be added to stoi, which is done through Line 8. Lastly, the reverse encoding can be performed using the encoding_to_selfies( ) utility:<graphic xlink:href="d3dd00044c-u9.jpg" id="ugr9" position="float"/></p>
      <p><xref rid="tab5" ref-type="table">Table 5</xref> summarizes the various utility functions introduced within this section.</p>
      <table-wrap position="float" id="tab5">
        <caption>
          <title>An overview of selfies utility functions</title>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col span="1"/>
            <col span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Function</th>
              <th rowspan="1" colspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">len_selfies( )</td>
              <td rowspan="1" colspan="1">Computes the symbol length of a SELFIES string</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">split_selfies( )</td>
              <td rowspan="1" colspan="1">Tokenizes a SELFIES string into its constituent symbols</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">get_alphabet_from_selfies( )</td>
              <td rowspan="1" colspan="1">Extracts a minimal vocabulary from a dataset of SELFIES strings</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">selfies_to_encoding( )</td>
              <td rowspan="1" colspan="1">Converts a SELFIES string into a label and/or one-hot encoding</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">encoding_to_selfies( )</td>
              <td rowspan="1" colspan="1">Recovers a SELFIES string from its label and/or one-hot encoding</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">get_semantic_robust_alphabet( )</td>
              <td rowspan="1" colspan="1">Provides an alphabet of semantically-constrained SELFIES symbols</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <label>5.</label>
    <title>Results and discussion</title>
    <p>The selfies library is quick and efficient in its translation, despite being implemented in pure Python. To demonstrate this, we provide some simple benchmarks of its core functions encoder( ) and decoder( ). The following experiments were run on Google Colaboratory, which uses two 2.20 GHz Intel(R) Xeon(R) CPUs.</p>
    <sec>
      <label>5.1.</label>
      <title>Roundtrip translation</title>
      <p>Here, we consider the roundtrip translation task, where a SMILES string is translated to SELFIES and then back to SMILES (see Section 4.1). Specifically, we translate the Developmental Therapeutics Program (DTP) open compound collection,<sup><xref rid="cit22" ref-type="bibr">22,23</xref></sup> which contains a little over 300 k SMILES strings and is a set of molecules which have been tested experimentally for potential treatment against cancer and the acquired immunodeficiency syndrome (AIDS).<sup><xref rid="cit24" ref-type="bibr">24</xref></sup> Translating the full dataset into SELFIES strings with encoder( ) takes 136 s, and recovering the SMILES dataset using decoder( ) takes 116 s, for a total roundtrip translation time of 252 s. <xref rid="fig2" ref-type="fig">Fig. 2</xref> plots how this roundtrip time scales with molecular size. Notably, we obtain all of these times by averaging over 3 replicate trials.</p>
    </sec>
    <sec>
      <label>5.2.</label>
      <title>Random SELFIES</title>
      <p>First, we sample 1000 fixed-length SELFIES strings and translate them to SMILES, per Section 4.1. We try this experiment with different symbol lengths and alphabets from which the SELFIES strings are built. <xref rid="fig1" ref-type="fig">Fig. 1</xref> shows the resulting distribution of SMILES strings and the time it takes to decode each full batch of random SELFIES strings. Performing this experiment reaffirms the robustness of SELFIES and demonstrates the ease in which we can create random valid molecules without applying any filters, pre- or post-selection. In <xref rid="fig1" ref-type="fig">Fig. 1a</xref>, we show how SELFIES strings sampled from a basic alphabet translate to random molecules; an important observation is that the generated molecules are rather small, independent of the SELFIES length chosen. That is mainly caused by the inclusion of multi-bonds and low-valence atoms in the considered alphabet, which exhaust the available valences of the constituent atoms and then lead to an earlier termination of the derivation. A simple workaround is to instead use an alphabet without multi-bonds and low-valence atom types, as illustrated in <xref rid="fig1" ref-type="fig">Fig. 1b</xref>. Here, the molecular size distribution is shifted significantly towards larger molecules, especially when longer SELFIES string are sampled. Hence, this showcases how to create very large and valid random molecules.</p>
      <fig position="float" id="fig1">
        <label>Fig. 1</label>
        <caption>
          <title>For a fixed alphabet <inline-graphic xlink:href="d3dd00044c-t52.jpg" id="ugt52"/> 1000 SELFIES strings were generated by uniformly sampling <italic toggle="yes">L</italic> symbols from an alphabet. Then, we plot the size distribution of the resulting molecules for varying symbol lengths <italic toggle="yes">L</italic>. (a) We take <inline-graphic xlink:href="d3dd00044c-t53.jpg" id="ugt53"/> to be the 69 symbols returned by get_semantic_robust_alphabet( ) under the default semantic constraints. (b) We filter the alphabet in (a) to 19 symbols by removing all atom symbols [<italic toggle="yes">βα</italic>] where <italic toggle="yes">β</italic> ∈ {=, #} or <italic toggle="yes">ν</italic>(type(<italic toggle="yes">α</italic>)) = 1, and removing all branch and ring symbols except for [Branch1] and [Ring1]. This decreases the chance that the SELFIES derivation process is terminated early, causing the derived molecules to be larger. (c) The time taken to translate each batch of random SELFIES strings to SMILES using decoder( ), measured by averaging over 20 replicate trials.</title>
        </caption>
        <graphic xlink:href="d3dd00044c-f1" position="float"/>
      </fig>
      <fig position="float" id="fig2">
        <label>Fig. 2</label>
        <caption>
          <title>The roundtrip translation time of 1000 randomly-sampled SMILES strings from the DTP open compound collection as a function of size, measured in number of atoms.</title>
        </caption>
        <graphic xlink:href="d3dd00044c-f2" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <label>6.</label>
    <title>Conclusions and outlook</title>
    <p>Since its first release in 2019, the selfies library has undergone significant changes and experienced a drastic transformation in terms of both capabilities and code design. All of these modifications were executed with two major premises, namely, (1) extending its functionality and capability to support all features of the SMILES representation and (2) retaining or even improving upon its simplicity and user-friendliness. To achieve that, we implemented all necessary functionality in the library itself so that it does not require any other packages. Additionally, we added several utility functions to the library to support common use cases. Apart from these two prime goals, we also made significant efforts to make the implementation faster as SELFIES has been employed in many performance-critical applications and workflows.</p>
    <p>Overall, the SELFIES community has grown rapidly and we are actively engaging in constructive discussions about the current implementation and future improvements. While selfies 2.1.1 supports almost all important features of SMILES, there are still many new features on our agenda. We outlined many of them in a recent perspective,<sup><xref rid="cit20" ref-type="bibr">20</xref></sup> for example, extensions to polymers, crystals, molecules with non-covalent bonds, or reactions. Our vision is that SELFIES will become a standard computer representation for molecular matter. We encourage the community to implement it into their workflows, report errors in the current implementation, and propose changes and new features that will help them to succeed in their goals.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The selfies library is available at GitHub (<uri xlink:href="https://github.com/aspuru-guzik-group/selfies">https://github.com/aspuru-guzik-group/selfies</uri>). Our benchmarking scripts were run on Google Colab and are also available at our repository (<uri xlink:href="https://github.com/aspuru-guzik-group/selfies/blob/f38eeea4c8b60ce412fa917adb9258b89d4e8efc/examples/benchmark_v2_1_1.ipynb">https://github.com/aspuru-guzik-group/selfies/blob/f38eeea4c8b60ce412fa917adb9258b89d4e8efc/examples/benchmark_v2_1_1.ipynb</uri>).</p>
  </sec>
  <sec>
    <title>Author contributions</title>
    <p>A. L.: conceptualization (equal), data curation (lead), formal analysis (lead), investigation (lead), methodology (lead), software (lead), validation (lead), visualization (lead), writing – original draft (lead), writing – review &amp; editing (lead). R. P.: conceptualization (equal), funding acquisition (supporting), methodology (equal), project administration (equal), software (equal), supervision (equal), writing – original draft (equal), writing – review &amp; editing (equal). A. K. N.: conceptualization (equal), funding acquisition (supporting), methodology (supporting), software (supporting), writing – original draft (supporting), writing – review &amp; editing (equal). A. D. W.: methodology (supporting), software (supporting), writing – original draft (supporting), writing – review &amp; editing (supporting). M. K.: conceptualization (equal), methodology (equal), project administration (equal), software (equal), supervision (equal), writing – original draft (equal), writing – review &amp; editing (equal). A. A. -G: conceptualization (equal), funding acquisition (lead), project administration (supporting), resources (lead), supervision (supporting), writing – review &amp; editing (supporting).</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflicts of interest</title>
    <p>There are no conflicts to declare.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
  </sec>
</body>
<back>
  <ack>
    <p>R. P. acknowledges funding through a Postdoc. Mobility fellowship by the Swiss National Science Foundation (SNSF, Project No. 191127). A. K. N. acknowledges funding from the Bio-X Stanford Interdisciplinary Graduate Fellowship (SGIF). A. A.-G. thanks Anders G. Frøseth for his generous support. A. A.-G. also acknowledges the support of Natural Resources Canada and the Canada 150 Research Chairs program.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="cit1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Warr</surname>
            <given-names>W. A.</given-names>
          </name>
        </person-group>
        <article-title>Representation of chemical structures</article-title>
        <source>Wiley Interdiscip. Rev.: Comput. Mol. Sci.</source>
        <year>2011</year>
        <volume>1</volume>
        <fpage>557</fpage>
        <lpage>579</lpage>
      </element-citation>
    </ref>
    <ref id="cit2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wigh</surname>
            <given-names>D. S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Goodman</surname>
            <given-names>J. M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Lapkin</surname>
            <given-names>A. A.</given-names>
          </name>
        </person-group>
        <article-title>A review of molecular representation in the age of machine learning</article-title>
        <source>Wiley Interdiscip. Rev.: Comput. Mol. Sci.</source>
        <year>2022</year>
        <volume>12</volume>
        <fpage>e1603</fpage>
      </element-citation>
    </ref>
    <ref id="cit3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weininger</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>SMILES, a chemical language and information system. 1. Introduction to methodology and encoding rules</article-title>
        <source>J. Chem. Inf. Comput. Sci.</source>
        <year>1988</year>
        <volume>28</volume>
        <fpage>31</fpage>
        <lpage>36</lpage>
        <pub-id pub-id-type="doi">10.1021/ci00057a005</pub-id>
      </element-citation>
    </ref>
    <ref id="cit4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gómez-Bombarelli</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Wei</surname>
            <given-names>J. N.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Duvenaud</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Hernández-Lobato</surname>
            <given-names>J. M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Sánchez-Lengeling</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Sheberla</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aguilera-Iparraguirre</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Hirzel</surname>
            <given-names>T. D.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Adams</surname>
            <given-names>R. P.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Automatic chemical design using a data-driven continuous representation of molecules</article-title>
        <source>ACS Cent. Sci.</source>
        <year>2018</year>
        <volume>4</volume>
        <fpage>268</fpage>
        <lpage>276</lpage>
        <pub-id pub-id-type="doi">10.1021/acscentsci.7b00572</pub-id>
        <?supplied-pmid 29532027?>
        <pub-id pub-id-type="pmid">29532027</pub-id>
      </element-citation>
    </ref>
    <ref id="cit5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sanchez-Lengeling</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Inverse molecular design using machine learning: generative models for matter engineering</article-title>
        <source>Science</source>
        <year>2018</year>
        <volume>361</volume>
        <fpage>360</fpage>
        <lpage>365</lpage>
        <pub-id pub-id-type="doi">10.1126/science.aat2663</pub-id>
        <?supplied-pmid 30049875?>
        <pub-id pub-id-type="pmid">30049875</pub-id>
      </element-citation>
    </ref>
    <ref id="cit6">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Kusner</surname><given-names>M. J.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Paige</surname><given-names>B.</given-names></name></person-group> and <person-group person-group-type="author"><name><surname>Hernández-Lobato</surname><given-names>J. M.</given-names></name></person-group>, <source>Proceedings of the 34th International Conference on Machine Learning</source>, <volume>vol. 70</volume>, <year>2017</year>, pp. 1945–1954</mixed-citation>
    </ref>
    <ref id="cit7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Olivecrona</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Blaschke</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Engkvist</surname>
            <given-names>O.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <article-title>Molecular de-novo design through deep reinforcement learning</article-title>
        <source>J. Cheminf.</source>
        <year>2017</year>
        <volume>9</volume>
        <fpage>48</fpage>
      </element-citation>
    </ref>
    <ref id="cit8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Popova</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Isayev</surname>
            <given-names>O.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Tropsha</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Deep reinforcement learning for <italic toggle="yes">de novo</italic> drug design</article-title>
        <source>Sci. Adv.</source>
        <year>2018</year>
        <volume>4</volume>
        <fpage>eaap7885</fpage>
        <pub-id pub-id-type="doi">10.1126/sciadv.aap7885</pub-id>
        <?supplied-pmid 30050984?>
        <pub-id pub-id-type="pmid">30050984</pub-id>
      </element-citation>
    </ref>
    <ref id="cit9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>O’Boyle</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Dalke</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>DeepSMILES: an adaptation of SMILES for use in machine-learning of chemical structures</article-title>
        <source>ChemRxiv</source>
        <year>2018</year>
        <pub-id pub-id-type="doi">10.26434/chemrxiv.7097960.v1</pub-id>
      </element-citation>
    </ref>
    <ref id="cit10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Krenn</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Häse</surname>
            <given-names>F.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Nigam</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Friederich</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Self-referencing embedded strings (SELFIES): a 100% robust molecular string representation</article-title>
        <source>Mach. Learn.: Sci. Technol.</source>
        <year>2020</year>
        <volume>1</volume>
        <fpage>045024</fpage>
      </element-citation>
    </ref>
    <ref id="cit11">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Hopcroft</surname><given-names>J. E.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Motwani</surname><given-names>R.</given-names></name></person-group> and <person-group person-group-type="author"><name><surname>Ullman</surname><given-names>J. D.</given-names></name></person-group>, <source>Introduction to automata theory, languages, and computation</source>, <publisher-name>Addison-Wesley</publisher-name>, <publisher-loc>Boston, MA</publisher-loc>, <year>2006</year></mixed-citation>
    </ref>
    <ref id="cit12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nigam</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Pollice</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Krenn</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>dos Passos Gomes</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Beyond generative models: superfast traversal, optimization, novelty, exploration and discovery (STONED) algorithm for molecules using SELFIES</article-title>
        <source>Chem. Sci.</source>
        <year>2021</year>
        <volume>12</volume>
        <fpage>7079</fpage>
        <lpage>7090</lpage>
        <pub-id pub-id-type="doi">10.1039/D1SC00231G</pub-id>
        <?supplied-pmid 34123336?>
        <pub-id pub-id-type="pmid">34123336</pub-id>
      </element-citation>
    </ref>
    <ref id="cit13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shen</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Krenn</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Eppel</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Deep molecular dreaming: inverse machine learning for de-novo molecular design and interpretability with surjective representations</article-title>
        <source>Mach. Learn.: Sci. Technol.</source>
        <year>2021</year>
        <volume>2</volume>
        <fpage>03LT02</fpage>
      </element-citation>
    </ref>
    <ref id="cit14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thiede</surname>
            <given-names>L. A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Krenn</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Nigam</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Curiosity in exploring chemical spaces: intrinsic rewards for molecular reinforcement learning</article-title>
        <source>Mach. Learn.: Sci. Technol.</source>
        <year>2022</year>
        <volume>3</volume>
        <fpage>035008</fpage>
      </element-citation>
    </ref>
    <ref id="cit15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Eckmann</surname><given-names>P.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Sun</surname><given-names>K.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Zhao</surname><given-names>B.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Feng</surname><given-names>M.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Gilson</surname><given-names>M.</given-names></name></person-group> and <person-group person-group-type="author"><name><surname>Yu</surname><given-names>R.</given-names></name></person-group>, <source>International Conference on Machine Learning</source>, <year>2022</year>, pp. 5777–5792</mixed-citation>
    </ref>
    <ref id="cit16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wellawatte</surname>
            <given-names>G. P.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Seshadri</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>White</surname>
            <given-names>A. D.</given-names>
          </name>
        </person-group>
        <article-title>Model agnostic generation of counterfactual explanations for molecules</article-title>
        <source>Chem. Sci.</source>
        <year>2022</year>
        <volume>13</volume>
        <fpage>3697</fpage>
        <lpage>3705</lpage>
        <pub-id pub-id-type="doi">10.1039/D1SC05259D</pub-id>
        <?supplied-pmid 35432902?>
        <pub-id pub-id-type="pmid">35432902</pub-id>
      </element-citation>
    </ref>
    <ref id="cit17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rajan</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Zielesny</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Steinbeck</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>DECIMER: towards deep learning for chemical image recognition</article-title>
        <source>J. Cheminf.</source>
        <year>2020</year>
        <volume>12</volume>
        <fpage>65</fpage>
      </element-citation>
    </ref>
    <ref id="cit18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rajan</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Zielesny</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Steinbeck</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>STOUT: SMILES to IUPAC names using neural machine translation</article-title>
        <source>J. Cheminf.</source>
        <year>2021</year>
        <volume>13</volume>
        <fpage>34</fpage>
      </element-citation>
    </ref>
    <ref id="cit19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cheng</surname>
            <given-names>A. H.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Cai</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Miret</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Malkomes</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Phielipp</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Group SELFIES: a robust fragment-based molecular string representation</article-title>
        <source>Digital Discovery</source>
        <year>2023</year>
        <volume>2</volume>
        <fpage>748</fpage>
        <lpage>758</lpage>
        <pub-id pub-id-type="doi">10.1039/D3DD00012E</pub-id>
      </element-citation>
    </ref>
    <ref id="cit20">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Krenn</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Ai</surname>
            <given-names>Q.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Barthel</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Carson</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Frei</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Frey</surname>
            <given-names>N. C.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Friederich</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Gaudin</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Gayle</surname>
            <given-names>A. A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Jablonka</surname>
            <given-names>K. M.</given-names>
          </name>
        </person-group>
        <article-title>et al., SELFIES and the future of molecular string representations</article-title>
        <source>Patterns</source>
        <year>2022</year>
        <volume>3</volume>
        <fpage>100588</fpage>
        <pub-id pub-id-type="doi">10.1016/j.patter.2022.100588</pub-id>
        <?supplied-pmid 36277819?>
        <pub-id pub-id-type="pmid">36277819</pub-id>
      </element-citation>
    </ref>
    <ref id="cit21">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Landrum</surname><given-names>G.</given-names></name></person-group>, <article-title><italic toggle="yes">et al.</italic></article-title>, <source>RDKit: Open-Source Cheminformatics</source>, <year>2006</year>, <uri xlink:href="https://www.rdkit.org/">https://www.rdkit.org/</uri></mixed-citation>
    </ref>
    <ref id="cit22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Voigt</surname>
            <given-names>J. H.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Bienfait</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Nicklaus</surname>
            <given-names>M. C.</given-names>
          </name>
        </person-group>
        <article-title>Comparison of the NCI open database with seven large chemical structural databases</article-title>
        <source>J. Chem. Inf. Comput. Sci.</source>
        <year>2001</year>
        <volume>41</volume>
        <fpage>702</fpage>
        <lpage>712</lpage>
        <pub-id pub-id-type="doi">10.1021/ci000150t</pub-id>
        <?supplied-pmid 11410049?>
        <pub-id pub-id-type="pmid">11410049</pub-id>
      </element-citation>
    </ref>
    <ref id="cit23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ihlenfeldt</surname>
            <given-names>W.-D.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Voigt</surname>
            <given-names>J. H.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Bienfait</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Oellien</surname>
            <given-names>F.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Nicklaus</surname>
            <given-names>M. C.</given-names>
          </name>
        </person-group>
        <article-title>Enhanced CACTVS browser of the Open NCI Database</article-title>
        <source>J. Chem. Inf. Comput. Sci.</source>
        <year>2002</year>
        <volume>42</volume>
        <fpage>46</fpage>
        <lpage>57</lpage>
        <pub-id pub-id-type="doi">10.1021/ci010056s</pub-id>
        <?supplied-pmid 11855965?>
        <pub-id pub-id-type="pmid">11855965</pub-id>
      </element-citation>
    </ref>
    <ref id="cit24">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Milne</surname>
            <given-names>G. W.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Nicklaus</surname>
            <given-names>M. C.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Driscoll</surname>
            <given-names>J. S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Zaharevitz</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>National cancer institute drug information system 3D database</article-title>
        <source>J. Chem. Inf. Comput. Sci.</source>
        <year>1994</year>
        <volume>34</volume>
        <fpage>1219</fpage>
        <lpage>1224</lpage>
        <pub-id pub-id-type="doi">10.1021/ci00021a032</pub-id>
        <?supplied-pmid 7962217?>
        <pub-id pub-id-type="pmid">7962217</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Digit Discov</journal-id>
    <journal-id journal-id-type="iso-abbrev">Digit Discov</journal-id>
    <journal-id journal-id-type="publisher-id">DD</journal-id>
    <journal-id journal-id-type="coden">DDIIAI</journal-id>
    <journal-title-group>
      <journal-title>Digital Discovery</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2635-098X</issn>
    <publisher>
      <publisher-name>RSC</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10408573</article-id>
    <article-id pub-id-type="publisher-id">d3dd00044c</article-id>
    <article-id pub-id-type="doi">10.1039/d3dd00044c</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Chemistry</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Recent advances in the self-referencing embedded strings (SELFIES) library</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-1744-1446</contrib-id>
        <name>
          <surname>Lo</surname>
          <given-names>Alston</given-names>
        </name>
        <xref rid="affa" ref-type="aff">a</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8836-6266</contrib-id>
        <name>
          <surname>Pollice</surname>
          <given-names>Robert</given-names>
        </name>
        <xref rid="affa" ref-type="aff">a</xref>
        <xref rid="affb" ref-type="aff">b</xref>
        <xref rid="affc" ref-type="aff">c</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Nigam</surname>
          <given-names>AkshatKumar</given-names>
        </name>
        <xref rid="affd" ref-type="aff">d</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-6647-3965</contrib-id>
        <name>
          <surname>White</surname>
          <given-names>Andrew D.</given-names>
        </name>
        <xref rid="affe" ref-type="aff">e</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Krenn</surname>
          <given-names>Mario</given-names>
        </name>
        <xref rid="afff" ref-type="aff">f</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Aspuru-Guzik</surname>
          <given-names>Alán</given-names>
        </name>
        <xref rid="affa" ref-type="aff">a</xref>
        <xref rid="affb" ref-type="aff">b</xref>
        <xref rid="affg" ref-type="aff">g</xref>
        <xref rid="affh" ref-type="aff">h</xref>
      </contrib>
      <aff id="affa">
        <label>a</label>
        <institution>Department of Computer Science, University of Toronto</institution>
        <country>Canada</country>
        <email>alston.lo@mail.utoronto.ca</email>
        <email>r.pollice@rug.nl</email>
        <email>alan@aspuru.com</email>
      </aff>
      <aff id="affb">
        <label>b</label>
        <institution>Chemical Physics Theory Group, Department of Chemistry, University of Toronto</institution>
        <country>Canada</country>
      </aff>
      <aff id="affc">
        <label>c</label>
        <institution>Stratingh Institute for Chemistry, University of Groningen</institution>
        <country>The Netherlands</country>
      </aff>
      <aff id="affd">
        <label>d</label>
        <institution>Department of Computer Science, Stanford University</institution>
        <state>California</state>
        <country>USA</country>
      </aff>
      <aff id="affe">
        <label>e</label>
        <institution>Department of Chemical Engineering, University of Rochester</institution>
        <country>USA</country>
      </aff>
      <aff id="afff">
        <label>f</label>
        <institution>Max Planck Institute for the Science of Light (MPL)</institution>
        <city>Erlangen</city>
        <country>Germany</country>
      </aff>
      <aff id="affg">
        <label>g</label>
        <institution>Vector Institute for Artificial Intelligence</institution>
        <city>Toronto</city>
        <country>Canada</country>
      </aff>
      <aff id="affh">
        <label>h</label>
        <institution>Canadian Institute for Advanced Research (CIFAR) Lebovic Fellow</institution>
        <city>Toronto</city>
        <country>Canada</country>
      </aff>
    </contrib-group>
    <pub-date publication-format="electronic" date-type="pub" iso-8601-date="2023-07-01">
      <day>1</day>
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <pub-date publication-format="electronic" date-type="collection" iso-8601-date="2023-08-08">
      <day>8</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>1</day>
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <!--PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>.-->
    <volume>2</volume>
    <issue>4</issue>
    <fpage>897</fpage>
    <lpage>908</lpage>
    <history>
      <date date-type="received" iso-8601-date="2023-03-17">
        <day>17</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="accepted" iso-8601-date="2023-06-23">
        <day>23</day>
        <month>6</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>This journal is © The Royal Society of Chemistry</copyright-statement>
      <copyright-year>2023</copyright-year>
      <copyright-holder>RSC</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense" start_date="2023-07-01">https://creativecommons.org/licenses/by/3.0/</ali:license_ref>
      </license>
    </permissions>
    <abstract>
      <p>String-based molecular representations play a crucial role in cheminformatics applications, and with the growing success of deep learning in chemistry, have been readily adopted into machine learning pipelines. However, traditional string-based representations such as SMILES are often prone to syntactic and semantic errors when produced by generative models. To address these problems, a novel representation, SELF-referencing embedded strings (SELFIES), was proposed that is inherently 100% robust, alongside an accompanying open-source implementation called selfies. Since then, we have generalized SELFIES to support a wider range of molecules and semantic constraints, and streamlined its underlying grammar. We have implemented this updated representation in subsequent versions of selfies, where we have also made major advances with respect to design, efficiency, and supported features. Hence, we present the current status of selfies (version 2.1.1) in this manuscript. Our library, selfies, is available at GitHub (<uri xlink:href="https://github.com/aspuru-guzik-group/selfies">https://github.com/aspuru-guzik-group/selfies</uri>).</p>
    </abstract>
    <abstract abstract-type="toc">
      <p>We describe the current state of the SELFIES library (version 2.1.1), and, in particular, the advances and improvements we have made in its underlying algorithms, design, and API.<graphic xlink:href="d3dd00044c-ga.jpg" id="ga" position="float"/></p>
    </abstract>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution>Stanford Bio-X</institution>
            <institution-id institution-id-type="doi">10.13039/100011098</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>Bio-X SIGF</award-id>
      </award-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution>Schweizerischer Nationalfonds zur Förderung der Wissenschaftlichen Forschung</institution>
            <institution-id institution-id-type="doi">10.13039/501100001711</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>Postdoc.Mobility</award-id>
      </award-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution>Stanford University</institution>
            <institution-id institution-id-type="doi">10.13039/100005492</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>Unassigned</award-id>
      </award-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution>Natural Resources Canada</institution>
            <institution-id institution-id-type="doi">10.13039/501100000159</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>Unassigned</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="12"/>
    </counts>
    <custom-meta-group>
      <custom-meta>
        <meta-name>pubstatus</meta-name>
        <meta-value>Paginated Article</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec>
    <label>1.</label>
    <title>Introduction</title>
    <p>In recent years, machine learning (ML) has become a powerful tool to tackle challenging problems in chemistry. Machine learning pipelines involve three crucial elements: data, representations, and models. Choosing the proper representation is important as it defines the space of models available to work with the data, as well as impacting directly model performance. For molecules, one of the more widely-used classes of representations encode molecules as strings (<italic toggle="yes">i.e.</italic>, the string-based molecular representations). These representations are popular since they can leverage the rich collection of ML tools that have been developed for sequential data.<sup><xref rid="cit1" ref-type="bibr">1,2</xref></sup> Historically, the most employed string representation is the Simplified Molecular Input Line Entry System (SMILES), which was introduced by Weininger in 1988.<sup><xref rid="cit3" ref-type="bibr">3</xref></sup> Currently, SMILES has become the <italic toggle="yes">de facto</italic> standard representation in cheminformatics and has historically been a key component of central applications in the field, such as chemical databases. The main appeal of SMILES is its simple underlying grammar, which allows for the rigorous specification of molecules in a manner that can be parsed efficiently, and which is readable for humans at least for small molecules.</p>
    <p>However, in an ML setting, this grammar can carry two intrinsic weaknesses. First, many strings constructed from SMILES symbols are syntactically invalid due to the rigidity of the SMILES grammar, <italic toggle="yes">i.e.</italic>, the strings cannot be interpreted as molecular graphs.<sup><xref rid="cit4" ref-type="bibr">4,5</xref></sup> In particular, SMILES requires branch brackets and ring numbers to appear in matching pairs (<italic toggle="yes">e.g.</italic>, C(CC and C1C are invalid), so a single misplaced or missing token could ruin the validity of a SMILES string. This is problematic because ML models that produce SMILES strings, especially generative models, can be prone to these syntactic errors, rendering a significant fraction of their output meaningless. One strategy is to constrain the ML architecture to reduce the number of invalid structures, which has been demonstrated successfully in the literature.<sup><xref rid="cit6" ref-type="bibr">6–8</xref></sup> This approach, of course, needs significant computational effort and cannot be transferred directly to other systems without model retraining, model architecture adjustments, or domain-specific design considerations. An alternative and more fundamental solution is to define representations that are inherently robust. A first step towards this direction was taken by DeepSMILES,<sup><xref rid="cit9" ref-type="bibr">9</xref></sup> a string-based representation derived from SMILES that reworked some of its most syntactically susceptible rules. While DeepSMILES solves most of the syntactical errors, it does not address the second weakness of SMILES, namely, that even syntactically valid strings may not necessarily correspond to a physical molecule. Typically, this occurs when a string represents a molecular graph that exceeds normal chemical valences, in which case we call the string semantically invalid. For example, the SMILES string CO<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><!-- PBM data was replaced with SVG by xgml2pxml:
<glyph-data id="z.dbd" format="PBM" resolution="300" x-size="8" y-size="10" xml:space="preserve">
00000000
00000000
00000000
00000000
11111111
00000000
11111111
00000000
00000000
00000000
</glyph-data>
--><glyph-data id="z.dbd" format="SVG" resolution="300" x-size="8" y-size="10" xml:space="preserve">
<![CDATA[
<svg xmlns="http://www.w3.org/2000/svg" version="1.0" width="13.200000pt" height="16.000000pt" viewBox="0 0 13.200000 16.000000" preserveAspectRatio="xMidYMid meet"><metadata>
Created by potrace 1.16, written by Peter Selinger 2001-2019
</metadata><g transform="translate(1.000000,15.000000) scale(0.017500,-0.017500)" fill="currentColor" stroke="none"><path d="M0 440 l0 -40 320 0 320 0 0 40 0 40 -320 0 -320 0 0 -40z M0 280 l0 -40 320 0 320 0 0 40 0 40 -320 0 -320 0 0 -40z"/></g></svg>
]]>
</glyph-data></private-char>C is semantically invalid because it erroneously specifies a trivalent oxygen atom, which is chemically unstable and reactive.</p>
    <p>To eliminate both syntactic and semantic invalidities in string-based molecular representations on a fundamental level, an entirely new representation termed SELF-referencIng Embedded Strings (SELFIES) has been proposed by some of us.<sup><xref rid="cit10" ref-type="bibr">10</xref></sup> By construction, SELFIES is 100% robust to both syntactic and semantic errors. That is, any combination of SELFIES symbols specifies a molecular graph that obeys chemical valences. This is achieved through a small Chomsky type-2, context-free grammar<sup><xref rid="cit11" ref-type="bibr">11</xref></sup> that is augmented with self-referencing functions to handle the generation of branches and rings. Since its release, SELFIES has enabled or improved numerous applications, ranging from molecular design<sup><xref rid="cit12" ref-type="bibr">12–15</xref></sup> to interpretability<sup><xref rid="cit16" ref-type="bibr">16</xref></sup> to image-to-string and string-to-string translations,<sup><xref rid="cit17" ref-type="bibr">17,18</xref></sup> and has been extended to incorporate functional groups and other fragments.<sup><xref rid="cit19" ref-type="bibr">19</xref></sup> For an extensive summary of its applications and opportunities, we refer readers to the recent community paper on SELFIES.<sup><xref rid="cit20" ref-type="bibr">20</xref></sup></p>
    <p>Herein, we introduce selfies 2.1.1, the latest version of the open-source Python implementation of SELFIES. In particular, we provide a detailed look into its history, developments, underlying algorithms, design, and performance. Together with the community, we have recently overviewed potential extensions and formulated 16 concrete future projects for SELFIES and other robust molecular string representations.<sup><xref rid="cit20" ref-type="bibr">20</xref></sup> We hope that this manuscript will also help in developing some of these extensions and ideas. Our software package selfies can be installed with “pip install selfies” and is available at GitHub (<uri xlink:href="https://github.com/aspuru-guzik-group/selfies">https://github.com/aspuru-guzik-group/selfies</uri>) under the Apache 2.0 license, along with comprehensive documentation and tutorials.</p>
  </sec>
  <sec>
    <label>2.</label>
    <title>Timeline and advances</title>
    <p>The selfies library version that implemented the representation from Krenn <italic toggle="yes">et al.</italic><sup><xref rid="cit10" ref-type="bibr">10</xref></sup> was first released as selfies 0.2.4 in 2019. This older version provided an API of two translation functions where a restricted subset of organic, uncharged, nonaromatic SMILES strings could be converted to and from SELFIES strings. In addition, the internal algorithms behind selfies relied heavily on direct string manipulations, so they were computationally inefficient and difficult to maintain. Since then, selfies has undergone several major redesigns that have significantly advanced the algorithmic handling of both SMILES and SELFIES. Most importantly, the underlying grammar of selfies has been streamlined and generalized in subsequent versions. We will now describe the changes up until selfies 2.1.1, the most recent version of selfies at the time of publication of this work.</p>
    <p>One major modification we made is that selfies now uses directed molecular graphs to internally represent SMILES and SELFIES strings. This has afforded selfies greater efficiency and flexibility, and enabled a number of additional extensions to be made. For example, we added support for aromatic molecules by kekulizing SMILES strings with aromatic symbols before they are translated into SELFIES. Furthermore, we handle species with partial charges, radicals, explicit hydrogens, non-standard isotopes, and stereochemical definitions in a fully syntactically and semantically robust way. Besides the standard constraints for the number of valences, users can now specify their own constraints and we provide built-in relaxed and stricter constraint presets that can be selected conveniently. Most recently, we introduced the ability to trace the connection between input and output tokens when translating between SELFIES and SMILES. <xref rid="tab1" ref-type="table">Table 1</xref> gives a brief changelog of the major releases of selfies and their associated advancements.</p>
    <table-wrap position="float" id="tab1">
      <caption>
        <title>A timeline of the various releases of selfies</title>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col span="1"/>
          <col span="1"/>
          <col span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">Version</th>
            <th rowspan="1" colspan="1">Year(s)</th>
            <th rowspan="1" colspan="1">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">0.1.1</td>
            <td rowspan="1" colspan="1">(Jun) 2019</td>
            <td rowspan="1" colspan="1">• Initial release of selfies</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">0.2.4</td>
            <td rowspan="1" colspan="1">(Oct) 2019</td>
            <td rowspan="1" colspan="1">• Release of selfies that implements the representation from Krenn <italic toggle="yes">et al.</italic><sup><xref rid="cit10" ref-type="bibr">10</xref></sup></td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">1.0.x</td>
            <td rowspan="1" colspan="1">2020–21</td>
            <td rowspan="1" colspan="1">• Expanded the support of selfies to a greater subset of SMILES strings, including strings with aromatic atoms, isotopes, charged species, and certain stereochemical specifications. To do so, the underlying grammar used by selfies was both streamlined and generalized</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1">• Added support for the customization of the semantic constraints used by selfies</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1">• Significantly improved the efficiency of translation between SELFIES and SMILES</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1">• Added a variety of utility functions to make the handling of SELFIES strings convenient</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">2.0.x</td>
            <td rowspan="1" colspan="1">2021</td>
            <td rowspan="1" colspan="1">• Updated the SELFIES alphabet to be more human-readable and standardized</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1">• Improved handling of stereochemical specifications in SELFIES involving ring bonds</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">2.1.x</td>
            <td rowspan="1" colspan="1">2022</td>
            <td rowspan="1" colspan="1">• Added support for explaining translations between SELFIES and SMILES through attributions</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <p>While the ideas outlined in the initial publication<sup><xref rid="cit10" ref-type="bibr">10</xref></sup> that ensure the validity of the representation remain at the core of selfies, the manifold implementation improvements and extensions are the novelties that we detail in this paper. Hereafter, unless specified otherwise, we will use selfies to refer to selfies 2.1.1 in particular and SELFIES to refer to the representation that selfies 2.1.1 implements. We will provide a complete and formal description of the updated representation in Section 3 and describe the API of selfies in Section 4.</p>
  </sec>
  <sec>
    <label>3.</label>
    <title>SELFIES specification</title>
    <p>Being 100% robust, every string of SELFIES symbols corresponds to a SMILES string that is both syntactically and semantically valid. Recall that we call a SMILES string semantically valid if it is syntactically valid and represents a molecular graph that obeys normal chemical valences.</p>
    <p>Within SELFIES, these chemical valences are encoded as a constraint function <inline-graphic xlink:href="d3dd00044c-t3.jpg" id="ugt3"/> where <inline-graphic xlink:href="d3dd00044c-t4.jpg" id="ugt4"/> is a finite universe of the atom types (<italic toggle="yes">e.g.</italic>, <inline-graphic xlink:href="d3dd00044c-t5.jpg" id="ugt5"/>) of interest and <inline-graphic xlink:href="d3dd00044c-t6.jpg" id="ugt6"/> The valences represented by <italic toggle="yes">ν</italic> dictate that an atom <italic toggle="yes">A</italic> must assume <italic toggle="yes">ν</italic>(type(<italic toggle="yes">A</italic>)) incident bonds in total. Note that if a SMILES string obeys the valences <italic toggle="yes">k</italic>, each of its atoms <italic toggle="yes">A</italic> makes at most <italic toggle="yes">ν</italic>(type(<italic toggle="yes">A</italic>)) explicit bonds within the string. There is a possibly-strict inequality in this case due to the way SMILES automatically adds implicit hydrogens until chemical valences are satisfied. In practice, the mapping <italic toggle="yes">ν</italic> is rationally chosen to align with both physical considerations and established cheminformatics packages such as RDKit.<sup><xref rid="cit21" ref-type="bibr">21</xref></sup> For example, a plausible setting might map<disp-formula id="eqn1"><label>1</label><italic toggle="yes">ν</italic>(C) = 4, <italic toggle="yes">ν</italic>(N) = 3, <italic toggle="yes">ν</italic>(O) = 2, <italic toggle="yes">ν</italic>(F) = 1</disp-formula>which is the default behaviour of selfies (see Section 4.3).</p>
    <p>We formulate chemical valences in this manner to emphasize that although SELFIES depends on <italic toggle="yes">ν</italic>, it is not fixed to any particular setting of <italic toggle="yes">ν</italic>. That is to say, SELFIES can enforce rule sets induced by any arbitrary mapping <inline-graphic xlink:href="d3dd00044c-t7.jpg" id="ugt7"/> even if they are not chemically meaningful. To highlight an absurd example, the uniform constraints <italic toggle="yes">ν</italic>(·) = 1000 can be used in principle, which corresponds to effectively having no semantic constraints at all. In this sense, SELFIES can be thought of as a general framework for an adjustable set of constraints <italic toggle="yes">ν</italic>. In the ensuing discussion, we will describe SELFIES under the assumption that some constraint function <italic toggle="yes">ν</italic> is fixed beforehand.</p>
    <sec>
      <label>3.1.</label>
      <title>Syntax</title>
      <p>Before explaining the SELFIES specification, we make a brief aside and give an overview of the form of SELFIES strings. Simply, a valid SELFIES string is any finite sequence of SELFIES symbols joined together. For ease of visual partitioning, all SELFIES symbols are enclosed by square brackets. Hence, a generic SELFIES string is of the form<disp-formula id="eqn2"><label>2</label>[…][…][…]⋯[…][…]</disp-formula>where the … is a placeholder for a symbol-specific token. We can further categorize SELFIES symbols into four main types, namely, atom, ring, branch, and miscellaneous, and characterize the syntax of each in the following. Throughout, let <italic toggle="yes">ε</italic> be the empty string and given <italic toggle="yes">n</italic> strings <inline-graphic xlink:href="d3dd00044c-t8.jpg" id="ugt8"/> let <italic toggle="yes">σ</italic><sub>1,</sub><italic toggle="yes">σ</italic><sub>2</sub>,…,<italic toggle="yes">σ</italic><sub><italic toggle="yes">n</italic></sub> denote their concatenation.</p>
      <sec>
        <label>3.1.1.</label>
        <title>Atom symbols</title>
        <p>The general SELFIES atom symbol has the form<disp-formula id="eqn3"><label>3</label><graphic xlink:href="d3dd00044c-t9.jpg" id="ugt9" position="float"/></disp-formula>where <italic toggle="yes">β</italic> ∈ {<italic toggle="yes">ε</italic>, = , #,/, \} is a SMILES-like bond symbol and<disp-formula id="eqn4"><label>4</label><graphic xlink:href="d3dd00044c-t10.jpg" id="ugt10" position="float"/></disp-formula></p>
        <p>collectively specify an atom type type(<italic toggle="yes">α</italic>) in a SMILES-like fashion (the atom's isotope number, atomic number, chirality, number of attached hydrogens, and charge, respectively, and sometimes optionally). Notably, each SELFIES atom symbol is semantically unique, <italic toggle="yes">i.e.</italic>, different atom symbols are not interchangeable. This is not the case in SMILES due to shorthand abbreviations in how attached hydrogens and charge can be represented. For example, the SMILES atom symbol pairs ([Fe++], [Fe+2]) and ([CH], [CH1]) are interchangeable. To create a more standardized alphabet of symbols, we remove this redundancy in SELFIES.</p>
      </sec>
      <sec>
        <label>3.1.2.</label>
        <title>Branch symbols</title>
        <p>The general SELFIES branch symbol has the form<disp-formula id="eqn5"><label>5</label>[<italic toggle="yes">β</italic>Branch<italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><!-- PBM data was replaced with SVG by xgml2pxml:
<glyph-data id="lscr.i" format="PBM" resolution="300" x-size="9" y-size="11" xml:space="preserve">
000000100
000001010
000010010
000010100
000011000
001110000
000100000
000100000
001100000
001101000
000110000
</glyph-data>
--><glyph-data id="lscr.i" format="SVG" resolution="300" x-size="9" y-size="11" xml:space="preserve">
<![CDATA[
<svg xmlns="http://www.w3.org/2000/svg" version="1.0" width="13.454545pt" height="16.000000pt" viewBox="0 0 13.454545 16.000000" preserveAspectRatio="xMidYMid meet"><metadata>
Created by potrace 1.16, written by Peter Selinger 2001-2019
</metadata><g transform="translate(1.000000,15.000000) scale(0.015909,-0.015909)" fill="currentColor" stroke="none"><path d="M480 840 l0 -40 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 -120 0 -120 -80 0 -80 0 0 -40 0 -40 40 0 40 0 0 -80 0 -80 -40 0 -40 0 0 -80 0 -80 40 0 40 0 0 -40 0 -40 80 0 80 0 0 40 0 40 40 0 40 0 0 40 0 40 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 160 0 160 40 0 40 0 0 40 0 40 40 0 40 0 0 40 0 40 40 0 40 0 0 40 0 40 40 0 40 0 0 80 0 80 -40 0 -40 0 0 40 0 40 -40 0 -40 0 0 -40z m80 -120 l0 -80 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 80 0 80 40 0 40 0 0 40 0 40 40 0 40 0 0 -80z"/></g></svg>
]]>
</glyph-data></private-char></italic>]</disp-formula>where <italic toggle="yes">β</italic> ∈ {<italic toggle="yes">ε</italic>, = , #} is a SMILES-like bond symbol and <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> ∈ {1, 2, 3}.</p>
      </sec>
      <sec>
        <label>3.1.3.</label>
        <title>Ring symbols</title>
        <p>SELFIES ring symbols can be further subdivided into two sub-types. These are of the form<disp-formula id="eqn6"><label>6</label><graphic xlink:href="d3dd00044c-t11.jpg" id="ugt11" position="float"/></disp-formula>where <italic toggle="yes">β</italic> ∈ {<italic toggle="yes">ε</italic>, = , #} and<disp-formula id="eqn7"><label>7</label><italic toggle="yes">β</italic><sub>1</sub>,<italic toggle="yes">β</italic><sub>2</sub> ∈ {−,/,\}, and not both <italic toggle="yes">β</italic><sub>1</sub> = <italic toggle="yes">β</italic><sub>2</sub> = −</disp-formula></p>
        <p>are SMILES-like bond symbols and <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> ∈ {1, 2, 3}, similar to branch symbols. The second ring symbol type (<xref rid="eqn6" ref-type="disp-formula">eqn (6)</xref>) is used to handle stereochemical specifications across ring bonds (see Section 3.5).</p>
      </sec>
      <sec>
        <label>3.1.4.</label>
        <title>Miscellaneous symbols</title>
        <p>SELFIES has a few auxiliary symbols that are not core to the representation. These symbols still have common use cases and are specially recognized by the functions in selfies that translate between SELFIES strings and SMILES strings (see Section 4.1):</p>
        <p>• The dot symbol, which can be used to express multiple disconnected fragments in a single SELFIES string, similar to its role in SMILES. The dot symbol is interpreted by treating it as delimiter and splitting the SELFIES string across the symbol. Then, each token is treated as an independent SELFIES string.</p>
        <p>• The [nop] (for “no-operation”) symbol, which is a special padding symbol ignored by selfies.</p>
        <p><xref rid="tab2" ref-type="table">Table 2</xref> provides examples of SELFIES atom, branch, and ring symbols.</p>
        <table-wrap position="float" id="tab2">
          <caption>
            <title>Example SELFIES symbols, by symbol type</title>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col span="1"/>
              <col span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1">Type</th>
                <th rowspan="1" colspan="1">Examples</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">Atom</td>
                <td rowspan="1" colspan="1">[#13C], [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O], [C@@H1], [N + 1]</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Branch</td>
                <td rowspan="1" colspan="1">[Branch3], [#Branch1], [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Branch2]</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Ring</td>
                <td rowspan="1" colspan="1">[<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Ring1], [/\Ring3], [Ring2]</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Misc.</td>
                <td rowspan="1" colspan="1">., [nop]</td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
    </sec>
    <sec>
      <label>3.2.</label>
      <title>The SELFIES grammar</title>
      <p>Now, we return to explaining the practical algorithm used to derive SMILES strings from their corresponding SELFIES strings. To do so, we first introduce the notion of a context-free grammar. A context-free grammar <italic toggle="yes">G</italic> is a tuple <italic toggle="yes">G</italic> = (<italic toggle="yes">V</italic>, <italic toggle="yes">Σ</italic>, <italic toggle="yes">R</italic>, <italic toggle="yes">S</italic>), where <italic toggle="yes">V</italic> and <italic toggle="yes">Σ</italic> are disjoint finite sets of nonterminal and terminal symbols, respectively, <italic toggle="yes">R</italic> ⊆ <italic toggle="yes">V</italic> × (<italic toggle="yes">V</italic> ∪ <italic toggle="yes">Σ</italic>)* is a finite relation,<xref rid="fn1" ref-type="fn">†</xref><fn id="fn1"><label>†</label><p>The Kleene star of a finite set of symbols <italic toggle="yes">A</italic>, denoted <italic toggle="yes">A</italic>*, is the set of all strings formed by concatenating finitely-many symbols from <italic toggle="yes">A</italic>, which includes the empty string.</p></fn> and <italic toggle="yes">S</italic> ∈ <italic toggle="yes">V</italic> is a so-called start symbol. Under <italic toggle="yes">G</italic>, strings of terminal symbols can be derived by performing a finite sequence of replacements starting with the single-symbol string <italic toggle="yes">σ</italic><sub>0</sub> = <italic toggle="yes">S</italic>. At each step <italic toggle="yes">t</italic>, if the current string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub> contains a nonterminal symbol <bold><italic toggle="yes">A</italic></bold> ∈ <italic toggle="yes">V</italic> (<italic toggle="yes">i.e.</italic>, <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub> = <italic toggle="yes">ρ</italic><sub>1</sub><bold><italic toggle="yes">A</italic></bold><italic toggle="yes">ρ</italic><sub>2</sub> for <italic toggle="yes">ρ</italic><sub>1</sub>, <italic toggle="yes">ρ</italic><sub>2</sub> ∈ (<italic toggle="yes">V</italic> ∪ <italic toggle="yes">Σ</italic>)*) and there is an (<bold><italic toggle="yes">A</italic></bold>, <italic toggle="yes">α</italic>) ∈ <italic toggle="yes">R</italic>, then we replace <bold><italic toggle="yes">A</italic></bold> with <italic toggle="yes">α</italic> to get the next string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic>+1</sub> = <italic toggle="yes">ρ</italic><sub>1</sub><italic toggle="yes">αρ</italic><sub>2</sub>. For this reason, tuples (<bold><italic toggle="yes">A</italic></bold>, <italic toggle="yes">α</italic>) ∈ <italic toggle="yes">R</italic> are called production rules, and are suggestively notated <bold><italic toggle="yes">A</italic></bold> → <italic toggle="yes">α</italic>. The derivation terminates once only terminal symbols remain. The derivation of SMILES strings under SELFIES is similar to the preceding process. In fact, a context-free grammar underlies SELFIES, which we call the SELFIES grammar.</p>
      <p>Specifically, the SELFIES grammar takes<disp-formula id="eqn8"><label>8</label><graphic xlink:href="d3dd00044c-t12.jpg" id="ugt12" position="float"/></disp-formula>where <inline-graphic xlink:href="d3dd00044c-t13.jpg" id="ugt13"/> is the maximum valence of all atom types. The production rules <italic toggle="yes">R</italic> will be characterized later. Given a SELFIES string, its corresponding SMILES string is then derived through a trajectory of replacements starting from <italic toggle="yes">S</italic>, as previously described. However, there are two further modifications that provides SELFIES its strong robustness. First, the replacements that are performed are not chosen arbitrarily, but are instead dictated by the SELFIES string of interest. At each derivation step, the next symbol of the SELFIES string is read off and fully specifies which production rule is applied. We systematically design this symbol-to-rule mapping such that the final derived SMILES string will always be valid. Second, SELFIES augments the grammar with self-referencing functions. These self-referencing functions manipulate the derivation process in more complicated ways than simple replacements, so they are not production rules. However, as before, the manner in which these self-referencing functions are applied is also dictated by the symbols in the SELFIES string. Thus, a SELFIES string can be viewed as a recipe of instructions (the symbols) that guides string derivation under the SELFIES grammar.</p>
    </sec>
    <sec>
      <label>3.3.</label>
      <title>Simple chain derivation</title>
      <p>Herein, we begin by considering the simplest type of SELFIES strings, those that correspond to simple chains of atoms. In SMILES, simple chains of atoms are represented by sequences of alternating atom and bond SMILES symbols, the latter of which can sometimes be left implicit by convention. Examples of such SMILES strings include CCCC (<italic toggle="yes">n</italic>-butane) and O<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>C<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O (carbon dioxide). Analogously, in SELFIES, simple chains are represented by sequences of SELFIES atom symbols, which can be understood as playing a similar role as a grouping of a SMILES atom symbol and its preceding SMILES bond symbol. Simple chains are the easiest to derive in SELFIES, because the process occurs only through mere replacements, as in regular context-free grammars.</p>
      <p>The derivation of a simple chain starts with the initial string <italic toggle="yes">σ</italic><sub>0</sub> = <italic toggle="yes">S</italic>. Recall that the SELFIES symbols dictate how production rules are applied. For simple chains, this is achieved by having each pair of SELFIES atom symbol and nonterminal symbol <italic toggle="yes">A</italic> ∈ <italic toggle="yes">V</italic> determine a production rule of the form <italic toggle="yes">A</italic> → <italic toggle="yes">α A</italic>′, where <italic toggle="yes">α</italic> ∈ <italic toggle="yes">Σ</italic>* is a terminal string and <italic toggle="yes">A</italic>′ ∈ <italic toggle="yes">V</italic> ∪ {<italic toggle="yes">ε</italic>}. Then, a sequence of replacements is iteratively performed by treating the SELFIES string as a queue <inline-graphic xlink:href="d3dd00044c-t14.jpg" id="ugt14"/> of SELFIES symbols. At each step, the head of <inline-graphic xlink:href="d3dd00044c-t15.jpg" id="ugt15"/> is popped<xref rid="fn2" ref-type="fn">‡</xref><fn id="fn2"><label>‡</label><p>To pop or dequeue the head of a queue <inline-graphic xlink:href="d3dd00044c-t1.jpg" id="ugt1"/> means to fetch and then remove the oldest item in <inline-graphic xlink:href="d3dd00044c-t2.jpg" id="ugt2"/></p></fn> and, with a nonterminal symbol in the current string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub>, is used to select and apply a production rule to get the next string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic>+1</sub>. Note that <italic toggle="yes">σ</italic><sub>0</sub> = <italic toggle="yes">S</italic> is itself a single nonterminal symbol, and each rule induced by a SELFIES atom symbol replaces one nonterminal symbol by another. Hence, throughout the derivation, the current string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub> will always contain at most one nonterminal symbol and there is never any ambiguity as to how or which production rule is applied. Once the current string has only terminal symbols or <inline-graphic xlink:href="d3dd00044c-t16.jpg" id="ugt16"/> is empty, the process ends (since SELFIES strings are finite, termination necessarily occurs). The final derived SMILES string is read off by dropping all nonterminal symbols.</p>
      <p>We now fully enumerate the SELFIES atom symbol to production rule mapping. Let [<italic toggle="yes">βα</italic>] be a generic atom symbol, as described in <xref rid="eqn3" ref-type="disp-formula">eqn (3)</xref>. Based on this symbol, we first define the terminal string<disp-formula id="eqn9"><label>9</label><graphic xlink:href="d3dd00044c-t17.jpg" id="ugt17" position="float"/></disp-formula>where <inline-graphic xlink:href="d3dd00044c-t18.jpg" id="ugt18"/> are the symbols of elements in the SMILES organic subset. The string <inline-graphic xlink:href="d3dd00044c-t19.jpg" id="ugt19"/> can be thought of as transforming <italic toggle="yes">α</italic> into the SMILES syntax. Then [<italic toggle="yes">βα</italic>] together with the nonterminal symbol <italic toggle="yes">S</italic> ∈ <italic toggle="yes">V</italic> specifies the production rule:<disp-formula id="eqn10"><label>10</label><bold><italic toggle="yes">S</italic></bold> → <italic toggle="yes"><private-char name="ITALIC SMALL ALPHA, GREEK, TILDE" description="italic small alpha, Greek, tilde"><!-- PBM data was replaced with SVG by xgml2pxml:
<glyph-data id="z.agrt.i" format="PBM" resolution="300" x-size="10" y-size="11" xml:space="preserve">
0000000000
0001110010
0001001110
0000000000
0001110100
0010001100
0010001000
0100001000
0100011000
0100101010
0011001100
</glyph-data>
--><glyph-data id="z.agrt.i" format="SVG" resolution="300" x-size="10" y-size="11" xml:space="preserve">
<![CDATA[
<svg xmlns="http://www.w3.org/2000/svg" version="1.0" width="14.727273pt" height="16.000000pt" viewBox="0 0 14.727273 16.000000" preserveAspectRatio="xMidYMid meet"><metadata>
Created by potrace 1.16, written by Peter Selinger 2001-2019
</metadata><g transform="translate(1.000000,15.000000) scale(0.015909,-0.015909)" fill="currentColor" stroke="none"><path d="M240 720 l0 -80 40 0 40 0 0 40 0 40 80 0 80 0 0 -40 0 -40 120 0 120 0 0 80 0 80 -40 0 -40 0 0 -40 0 -40 -80 0 -80 0 0 40 0 40 -120 0 -120 0 0 -80z M240 520 l0 -40 -40 0 -40 0 0 -80 0 -80 -40 0 -40 0 0 -120 0 -120 40 0 40 0 0 -40 0 -40 80 0 80 0 0 40 0 40 40 0 40 0 0 40 0 40 40 0 40 0 0 -80 0 -80 80 0 80 0 0 40 0 40 40 0 40 0 0 40 0 40 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 160 0 160 40 0 40 0 0 80 0 80 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 40 0 40 -120 0 -120 0 0 -40z m240 -160 l0 -120 -40 0 -40 0 0 -40 0 -40 -40 0 -40 0 0 -40 0 -40 -80 0 -80 0 0 120 0 120 40 0 40 0 0 80 0 80 120 0 120 0 0 -120z"/></g></svg>
]]>
</glyph-data></private-char></italic><bold><italic toggle="yes">X</italic></bold><sub><italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic></sub></disp-formula>where <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> = <italic toggle="yes">ν</italic>(type(<italic toggle="yes">α</italic>)) is the valence of the atom type specified by <italic toggle="yes">α</italic>, and we hereafter define <italic toggle="yes">X</italic><sub>0</sub> = <italic toggle="yes">ε</italic> to be the empty string to handle the case where <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> = 0. The atom symbol [<italic toggle="yes">βα</italic>] together with the symbol <italic toggle="yes">X</italic><sub><italic toggle="yes">i</italic></sub> ∈ <italic toggle="yes">V</italic>, where <inline-graphic xlink:href="d3dd00044c-t20.jpg" id="ugt20"/> specifies a production of the form:<disp-formula id="eqn11"><label>11</label><graphic xlink:href="d3dd00044c-t21.jpg" id="ugt21" position="float"/></disp-formula>where <italic toggle="yes">d</italic><sub>0</sub> = min(<italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>, <italic toggle="yes">i</italic>, <italic toggle="yes">d</italic>(<italic toggle="yes">β</italic>)). Here, <italic toggle="yes">d</italic>(<italic toggle="yes">β</italic>) is a function that returns the order of the bond type represented by <italic toggle="yes">β</italic>:<disp-formula id="eqn12"><label>12</label><graphic xlink:href="d3dd00044c-t22.jpg" id="ugt22" position="float"/></disp-formula>and <italic toggle="yes">β</italic><sub>↓</sub>(<italic toggle="yes">n</italic>) is a function that demotes <italic toggle="yes">β</italic> into a SMILES token representing a bond of lower order <italic toggle="yes">n</italic> ≤ <italic toggle="yes">d</italic>(<italic toggle="yes">β</italic>):<disp-formula id="eqn13"><label>13</label><graphic xlink:href="d3dd00044c-t23.jpg" id="ugt23" position="float"/></disp-formula></p>
      <p>In <xref rid="eqn10" ref-type="disp-formula">eqn (10)</xref> and <xref rid="eqn11" ref-type="disp-formula">(11)</xref>, the nonterminal symbols <italic toggle="yes">X</italic><sub>m</sub> are intuitively memorizing the maximum number of bonds that the most recently derived atom can adopt; the nonterminal symbol <italic toggle="yes">X</italic><sub>m</sub> can be understood as encoding that the last atom can make at most m bonds. When the next atom is derived, the bond connecting it to the preceding atom has its order decreased minimally such that the bond constraints are always satisfied.</p>
      <p>Examples: To show these production rules in a concrete setting, we will translate the SELFIES string<disp-formula id="eqn14"><label>14</label><graphic xlink:href="d3dd00044c-t24.jpg" id="ugt24" position="float"/></disp-formula></p>
      <p>along with the constraints in <xref rid="eqn1" ref-type="disp-formula">eqn (1)</xref>. The derivation of its corresponding SMILES string would proceed step-wise as follows:<disp-formula id="eqn15"><label>15</label><graphic xlink:href="d3dd00044c-t25.jpg" id="ugt25" position="float"/></disp-formula>where each line <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub> ⇒ <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic>+1</sub> ([<italic toggle="yes">βα</italic>]) is used to denote a step of the derivation process induced by the SELFIES symbol [<italic toggle="yes">βα</italic>]. The final derived SMILES string in this case is COCF. Now, for a more complicated example, consider the SELFIES string<disp-formula id="eqn16"><label>16</label><graphic xlink:href="d3dd00044c-t26.jpg" id="ugt26" position="float"/></disp-formula></p>
      <p>under the same constraints. The derivation proceeds as<disp-formula id="eqn17"><label>17</label><graphic xlink:href="d3dd00044c-t27.jpg" id="ugt27" position="float"/></disp-formula></p>
      <p>producing the final SMILES string [CH3][13CH1]<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O. Note that isotopes are assumed to share the same valence, and when hydrogen atoms are specified in an atom type, its valence is decremented accordingly.</p>
    </sec>
    <sec>
      <label>3.4.</label>
      <title>Branch derivation</title>
      <p>So far, we discussed chains of atoms, and their connectivity. However, most molecules are more complex than simple linear chains. Therefore, now, we talk about the derivations of branches (followed by rings in the subsequent section). In SMILES, branches are specified by enclosing a SMILES substring in parentheses, which can be recursively nested; for example, CC(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)O (acetic acid) and C(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)(C(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)O)O (oxalic acid). In SELFIES, branches are specified by SELFIES branch symbols, and similar to atom symbols, every pair of SELFIES branch symbol and nonterminal symbol determine some rule on how to modify the current string. We can encode branched trees of atoms in SELFIES by sequences of atom and branch symbols.</p>
      <p>The derivation process extends that for simple chains (in Section 3.3), where we pop SELFIES symbols step-by-step off of a queue <inline-graphic xlink:href="d3dd00044c-t28.jpg" id="ugt28"/>. We only add an additional rule for when we dequeue a branch symbol from <inline-graphic xlink:href="d3dd00044c-t29.jpg" id="ugt29"/>. Let this symbol be [<italic toggle="yes">β</italic>Branch<italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>], as in <xref rid="eqn5" ref-type="disp-formula">eqn (5)</xref>, and let <italic toggle="yes">A</italic> be a nonterminal symbol in the current string <italic toggle="yes">σ</italic><sub><italic toggle="yes">t</italic></sub>. If <italic toggle="yes">A</italic> ∈ {<italic toggle="yes">S</italic>, <italic toggle="yes">X</italic><sub>1</sub>}, then this specifies the application of the production rule <italic toggle="yes">A</italic> → <italic toggle="yes">A</italic>. Effectively, the branch symbol is ignored in this case. If <italic toggle="yes">A</italic> = <italic toggle="yes">X</italic><sub><italic toggle="yes">i</italic></sub> for <italic toggle="yes">i</italic> ≥ 2, then we perform a replacement:<disp-formula id="eqn18"><label>18</label><bold><italic toggle="yes">A</italic></bold> → <italic toggle="yes">ρ</italic><bold><italic toggle="yes">X</italic></bold><sub><italic toggle="yes">i</italic>−d<sub>0</sub></sub></disp-formula>where <italic toggle="yes">d</italic><sub>0</sub> = min(<italic toggle="yes">i</italic> − 1, <italic toggle="yes">d</italic>(<italic toggle="yes">β</italic>)), and <italic toggle="yes">ρ</italic> ∈ <italic toggle="yes">Σ</italic>* is a SMILES substring obtained through the following recursive process.</p>
      <p>First, <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> symbols are popped from <inline-graphic xlink:href="d3dd00044c-t30.jpg" id="ugt30"/> and converted into integer values by the mapping summarized in <xref rid="tab3" ref-type="table">Table 3</xref>. Let <italic toggle="yes">c</italic><sub>1</sub>⋯, <italic toggle="yes">c</italic><sub><italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic></sub> be the indices in first-to-last order of retrieval. In the event that <inline-graphic xlink:href="d3dd00044c-t31.jpg" id="ugt31"/> contains fewer than <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> symbols, the missing indices are set to have a default value of 0. Next, these indices are identified with a natural number <inline-graphic xlink:href="d3dd00044c-t32.jpg" id="ugt32"/> by treating them as hexadecimal digits:<disp-formula id="eqn19"><label>19</label><graphic xlink:href="d3dd00044c-t33.jpg" id="ugt33" position="float"/></disp-formula></p>
      <table-wrap position="float" id="tab3">
        <caption>
          <title>The symbols succeeding a branch or ring SELFIES symbol are sometimes overloaded with a numeric index, which is determined by the following symbol-to-index mapping</title>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col span="1"/>
            <col span="1"/>
            <col span="1"/>
            <col span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Index</th>
              <th rowspan="1" colspan="1">Symbol</th>
              <th rowspan="1" colspan="1">Index</th>
              <th rowspan="1" colspan="1">Symbol</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">[C]</td>
              <td rowspan="1" colspan="1">8</td>
              <td rowspan="1" colspan="1">[#Branch2]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">[Ring1]</td>
              <td rowspan="1" colspan="1">9</td>
              <td rowspan="1" colspan="1">[O]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">2</td>
              <td rowspan="1" colspan="1">[Ring2]</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">[N]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">[Branch1]</td>
              <td rowspan="1" colspan="1">11</td>
              <td rowspan="1" colspan="1">[<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>N]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">[<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Branch1]</td>
              <td rowspan="1" colspan="1">12</td>
              <td rowspan="1" colspan="1">[<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>C]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">[#Branch1]</td>
              <td rowspan="1" colspan="1">13</td>
              <td rowspan="1" colspan="1">[#C]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">[Branch2]</td>
              <td rowspan="1" colspan="1">14</td>
              <td rowspan="1" colspan="1">[S]</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">7</td>
              <td rowspan="1" colspan="1">[<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Branch2]</td>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">[P]</td>
            </tr>
            <tr>
              <td colspan="4" rowspan="1">All other symbols are assigned index 0</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Then, <italic toggle="yes">N</italic> symbols from <inline-graphic xlink:href="d3dd00044c-t34.jpg" id="ugt34"/> (or all symbols in <inline-graphic xlink:href="d3dd00044c-t35.jpg" id="ugt35"/> if fewer exist) are consumed to form a new SELFIES string, and with start symbol <inline-graphic xlink:href="d3dd00044c-t36.jpg" id="ugt36"/> (instead of <italic toggle="yes">S</italic> = <italic toggle="yes">S</italic> as before), this substring is recursively derived into a SMILES string <italic toggle="yes">ρ</italic><sub>0</sub>. We take <italic toggle="yes">ρ</italic> = <italic toggle="yes">ε</italic> if <italic toggle="yes">ρ</italic><sub>0</sub> = <italic toggle="yes">ε</italic>, and <italic toggle="yes">ρ</italic> = (<italic toggle="yes">ρ</italic><sub>0</sub>) otherwise.<xref rid="fn3" ref-type="fn">§</xref><fn id="fn3"><label>§</label><p>A minor technicality occurs if <italic toggle="yes">ρ</italic><sub>0</sub> starts with a branch parentheses (, in which case <italic toggle="yes">ρ</italic> is of the form ((<italic toggle="yes">α</italic><sub>1</sub>),…,(<italic toggle="yes">α</italic><sub><italic toggle="yes">m</italic></sub>)<italic toggle="yes">α</italic><sub><italic toggle="yes">m</italic>+1</sub>) for strings <italic toggle="yes">α</italic><sub><italic toggle="yes">k</italic></sub> ∈ <italic toggle="yes">Σ</italic>* that do not start with (. This would result in an invalid SMILES string because branches cannot start with other branches in SMILES. To amend this, we naturally interpret and replace <italic toggle="yes">ρ</italic> with the string (<italic toggle="yes">α</italic><sub>1</sub>),…,(<italic toggle="yes">α</italic><sub><italic toggle="yes">m</italic></sub>)(<italic toggle="yes">α</italic><sub><italic toggle="yes">m</italic>+1</sub>).</p></fn></p>
      <p>Examples: To provide an overview of branch derivation, we translate a SELFIES string representing acetic acid:<disp-formula id="eqn20"><label>20</label><graphic xlink:href="d3dd00044c-t37.jpg" id="ugt37" position="float"/></disp-formula></p>
      <p>Processing the first two SELFIES symbols [O][C] results in the string OC <italic toggle="yes">X</italic><sub>3</sub>, after which the symbol [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Branch1] is dequeued. Since <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> = 1, we consume the next symbol [C] in <inline-graphic xlink:href="d3dd00044c-t38.jpg" id="ugt38"/> and identify it with <italic toggle="yes">N</italic> = 1. Hence, we create the SELFIES substring [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O] from popping the next symbol in <inline-graphic xlink:href="d3dd00044c-t39.jpg" id="ugt39"/> and, with start symbol <italic toggle="yes">X</italic><sub>2</sub>, recursively derive it into the SMILES substring <italic toggle="yes">ρ</italic> = (<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O). Then, performing the replacement in <xref rid="eqn18" ref-type="disp-formula">eqn (18)</xref> gives the string OC(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O) <italic toggle="yes">X</italic><sub>1</sub>, and processing the last symbol [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>C] in <inline-graphic xlink:href="d3dd00044c-t40.jpg" id="ugt40"/> finally produces a SMILES string OC(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)C for acetic acid. Another SELFIES string that corresponds to OC(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)C is:<disp-formula id="eqn21"><label>21</label><graphic xlink:href="d3dd00044c-t41.jpg" id="ugt41" position="float"/></disp-formula></p>
      <p>The derivation is largely similar to that before. The major difference is that when the branch symbol is dequeued, the next <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> = 2 symbols [C][Ring1] are identified with <italic toggle="yes">N</italic> = 1 + 16(0) + 1 = 2, and then, the SELFIES substring [<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O][F] is used to again derive <italic toggle="yes">ρ</italic> = (<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O).</p>
    </sec>
    <sec>
      <label>3.5.</label>
      <title>Ring derivation</title>
      <p>The final feature that is necessary to capture the diverse variety of molecules is the ability to encode ring closures. In SMILES, this is achieved by paired numeric tags that indicate two separate atoms are joined together; for example, CC1CCC1 (methylcyclobutane). By adding bond characters before the numbers, SMILES can also specify ring closures of higher bond orders, such as C<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>1CCCC<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>1 (cyclopentene). In SELFIES, ring closures are specified by ring symbols, which behave similarly to branch symbols. The derivation process extends that in Section 3.4.</p>
      <p>Per <xref rid="eqn6" ref-type="disp-formula">eqn (6)</xref>, there are two forms of SELFIES ring symbols. To simplify the ensuing discussion, however, we will begin by only considering the first form. When a ring symbol [<italic toggle="yes">β</italic> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>] is popped from the queue of SELFIES symbols <inline-graphic xlink:href="d3dd00044c-t42.jpg" id="ugt42"/> a nonterminal symbol <italic toggle="yes">A</italic> in the current derived string is used to specify a production rule. If <italic toggle="yes">A</italic> = <italic toggle="yes">S</italic>, then we apply the rule <italic toggle="yes">A</italic> → <italic toggle="yes">A</italic>, and the ring symbol is effectively skipped. If <italic toggle="yes">A</italic> = <italic toggle="yes">Xi</italic>, then we replace:<disp-formula id="eqn22"><label>22</label><bold><italic toggle="yes">A</italic></bold> → <bold><italic toggle="yes">X</italic></bold><sub><italic toggle="yes">i</italic>−min(<italic toggle="yes">i</italic>,<italic toggle="yes">d</italic>(<italic toggle="yes">β</italic>))</sub></disp-formula></p>
      <p>In addition, we consume the next <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> symbols of <inline-graphic xlink:href="d3dd00044c-t43.jpg" id="ugt43"/> (or all symbols in <inline-graphic xlink:href="d3dd00044c-t44.jpg" id="ugt44"/> if fewer exist) to specify a number <inline-graphic xlink:href="d3dd00044c-t45.jpg" id="ugt45"/> by <xref rid="eqn19" ref-type="disp-formula">eqn (19)</xref>. Then, the ring symbol would indicate that a ring closure should be formed between the ring-initiating atom and the <italic toggle="yes">N</italic>-th atom previously derived from it (or simply, the first atom if less than <italic toggle="yes">N</italic> such atoms exist). Here, the derivation order is the order in which atoms are realized through the production rules in <xref rid="eqn10" ref-type="disp-formula">eqn (10)</xref> and <xref rid="eqn11" ref-type="disp-formula">(11)</xref>. By ring-initiating atom, we also mean the atom at which bonds would be made if the ring symbol were instead an atom symbol. Often, this coincides with the last-derived atom, as is the case in:<disp-formula id="eqn23"><label>23</label>NC(C)COC*†<bold><italic toggle="yes">X</italic></bold><sub>4</sub></disp-formula>where the ring-initiating and last-derived atoms are marked with an asterisk and dagger, respectively. However, this is not the case when the last-derived atom lies within a fully-derived branch:<disp-formula id="eqn24"><label>24</label>NC(C)COC*(C)(C†)<bold><italic toggle="yes">X</italic></bold><sub>1</sub></disp-formula></p>
      <p>For brevity, we will refer to the ring-initiating atom as the right ring atom and its counterpart the left ring atom, as the latter precedes the former in a SMILES string under derivation order.</p>
      <p>Although a ring symbol specifies a closure between the left and right ring atoms, such a bond cannot be naively added since it may cause valences to be violated for the left ring atom immediately (<italic toggle="yes">e.g.</italic>, consider the case where this atom has already attained its maximum valence) or in the future. Hence, SELFIES postpones the creation of ring closures to a final post-processing step. Instead, the ring closure candidates are pushed to a temporary queue <inline-graphic xlink:href="d3dd00044c-t46.jpg" id="ugt46"/> and once all the SELFIES symbols have been processed, the items in <inline-graphic xlink:href="d3dd00044c-t47.jpg" id="ugt47"/> are revisited in first-to-last order. Based on the state of the ring atoms, a candidate may be rejected (and no ring bond is made) or executed.</p>
      <p>Specifically, given a potential ring closure indicated by symbol [<italic toggle="yes">β</italic> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>], let <italic toggle="yes">m</italic><sub>1</sub> and <italic toggle="yes">m</italic><sub>2</sub> be the number of additional bonds that the left and right ring atoms can make, respectively. If <italic toggle="yes">m</italic><sub>1</sub> = 0 or <italic toggle="yes">m</italic><sub>2</sub> = 0, we must reject the candidate since adding the ring closure would exceed one of the valences of the ring atom. The candidate is also rejected if its left and right ring atoms are not distinct, to avoid unphysical self-loops. Otherwise, the candidate is accepted, and, assuming there is no pre-existing bond between its two ring atoms, we form a new bond of order <italic toggle="yes">d</italic><sub>0</sub> = min(<italic toggle="yes">d</italic>(<italic toggle="yes">β</italic><sub>1</sub>), <italic toggle="yes">m</italic><sub>1</sub>, <italic toggle="yes">m</italic><sub>2</sub>) between them. If a prior bond does exist (<italic toggle="yes">e.g.</italic>, if a duplicate ring closure is specified earlier in <inline-graphic xlink:href="d3dd00044c-t48.jpg" id="ugt48"/>), then we increment the order of this existing bond as necessary. That is, if the existing bond is of order <italic toggle="yes">d</italic><sub>1</sub>, then we promote it to a bond of potentially-higher order min(3, <italic toggle="yes">d</italic><sub>1</sub> + <italic toggle="yes">d</italic><sub>0</sub>).</p>
      <p>Examples: We translate a SELFIES string representing methylcyclobutane:<disp-formula id="eqn25"><label>25</label><graphic xlink:href="d3dd00044c-t49.jpg" id="ugt49" position="float"/></disp-formula></p>
      <p>The first five symbols produce the string CCCCC <bold><italic toggle="yes">X</italic></bold><sub>4</sub>, after which the ring symbol [Ring1] is dequeued. Since <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> = 1, the next and final symbol [Ring2] specifies a single ring bond between the final C and its <italic toggle="yes">N</italic> = 3rd preceding atom. This produces the SMILES string CC1CCC1. Note that incrementing the indexing symbol:<disp-formula id="eqn26"><label>26</label><graphic xlink:href="d3dd00044c-t50.jpg" id="ugt50" position="float"/></disp-formula></p>
      <p>increments the distance of the ring closure, hence producing a SMILES string for cyclopentane C1CCCC1. Appending a copy of the ring and index symbols:<disp-formula id="eqn27"><label>27</label><graphic xlink:href="d3dd00044c-t51.jpg" id="ugt51" position="float"/></disp-formula>increments the bond order of the ring closure and produces the SMILES string CC<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>1CCC<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>1.</p>
      <p>The second ring symbol form [<italic toggle="yes">β</italic><sub>1</sub><italic toggle="yes">β</italic><sub>2</sub> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>] in <xref rid="eqn3" ref-type="disp-formula">eqn (3)</xref> behaves nearly identically to [Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>], and is used to support specification of stereochemistry across single ring bonds. The only difference occurs when a ring closure candidate produced by [<italic toggle="yes">β</italic><sub>1</sub><italic toggle="yes">β</italic><sub>2</sub> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>] is accepted, and a new ring bond is added between the two ring atoms. In this case, if <italic toggle="yes">β</italic><sub>1</sub> ∈ {/, \}, then we add the bond character <italic toggle="yes">β</italic><sub>1</sub> before the numeric ring tag on the left ring atom, and similarly with <italic toggle="yes">β</italic><sub>2</sub> and the right ring atom. For instance, if the example <xref rid="eqn25" ref-type="disp-formula">eqn (25)</xref> used the symbol [/−Ring1] instead of [Ring1], then the derived SMILES string would be CC/1CCC1.</p>
    </sec>
  </sec>
  <sec>
    <label>4.</label>
    <title>Library design</title>
    <p>The selfies library is designed to be fast, lightweight, and user-friendly. A small but nice feature of selfies is that it also requires no extra dependencies. At its core, there are two functions that facilitate the interconversion between SELFIES strings and SMILES strings. For more advanced usage, we provide functions to customize the underlying semantic constraints that selfies enforces and operates upon. The default constraints are given in <xref rid="tab4" ref-type="table">Table 4</xref>, and are intended for organic molecules with single, double, or triple bonds. Finally, we also provide a variety of utility functions for manipulating SELFIES strings. The following describes each type of function in more detail and provides potential use case examples. All code snippets are written in Python, with selfies being a Python library.</p>
    <table-wrap position="float" id="tab4">
      <caption>
        <title>The default constraints used by selfies. All atom types other than those explicitly listed below are constrained to 8 maximum bonds, which acts as a catch-all constraint</title>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col span="1"/>
          <col span="1"/>
          <col span="1"/>
          <col span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="2" colspan="1">Element</th>
            <th colspan="3" rowspan="1">Maximum bonds</th>
          </tr>
          <tr>
            <th rowspan="1" colspan="1">Charge 0</th>
            <th rowspan="1" colspan="1">Charge +1</th>
            <th rowspan="1" colspan="1">Charge −1</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">H, F, Cl, Br, I</td>
            <td rowspan="1" colspan="1">1</td>
            <td rowspan="1" colspan="1">—</td>
            <td rowspan="1" colspan="1">—</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">B</td>
            <td rowspan="1" colspan="1">3</td>
            <td rowspan="1" colspan="1">2</td>
            <td rowspan="1" colspan="1">4</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">C</td>
            <td rowspan="1" colspan="1">4</td>
            <td rowspan="1" colspan="1">5</td>
            <td rowspan="1" colspan="1">3</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">N</td>
            <td rowspan="1" colspan="1">3</td>
            <td rowspan="1" colspan="1">4</td>
            <td rowspan="1" colspan="1">2</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">O</td>
            <td rowspan="1" colspan="1">2</td>
            <td rowspan="1" colspan="1">3</td>
            <td rowspan="1" colspan="1">1</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">P</td>
            <td rowspan="1" colspan="1">5</td>
            <td rowspan="1" colspan="1">6</td>
            <td rowspan="1" colspan="1">4</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">S</td>
            <td rowspan="1" colspan="1">6</td>
            <td rowspan="1" colspan="1">7</td>
            <td rowspan="1" colspan="1">5</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <sec>
      <label>4.1.</label>
      <title>Core functions</title>
      <p>SELFIES strings can conveniently be created from and turned into SMILES strings using the functions encoder( ) and decoder( ), respectively. The latter derives a SMILES string from a SELFIES string, using the procedure described in Section 3. The former performs the translation in the reverse direction such that passing a SMILES string through the composition decoder(encoder( )) is always guaranteed to recover a SMILES string that represents the same molecule (but not necessarily the original SMILES string itself). The recovered SMILES string will also maintain the molecular traversal order (<italic toggle="yes">i.e.</italic>, the specification order of the atoms) of the original string. The following excerpt defines a toy function roundtrip( ) that illustrates this:<graphic xlink:href="d3dd00044c-u1.jpg" id="ugr1" position="float"/></p>
      <p>Line 5 translates the SMILES string for benzene into the SELFIES string in Line 11. Notably, SELFIES does not support aromatic atom symbols (<italic toggle="yes">e.g.</italic>, c) in the same way as SMILES, so encoder( ) performs an internal kekulization if it is passed an aromatic SMILES string. Line 7 guards against errors raised by encoder( ) when being passed SMILES strings that are syntactically invalid, semantically invalid (<italic toggle="yes">i.e.</italic>, violate the constraints described in the next subsection), or unsupported. An unsupported SMILES string uses features of SMILES that are not implemented in SELFIES, such as the wildcard * and quadruple bond $ symbols; the API reference of selfies further details which SMILES strings are currently supported. Line 10 applies the roundtrip( ) function to a SMILES string c1ccccc1 for benzene. Indeed, this round-trip translation recovers a SMILES string C1<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>CC<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>CC<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>C1 that is different than the original string, but still specifies the (kekulized) benzene molecule.</p>
      <p>In greater detail, given an input SMILES string, encoder( ) first performs a kekulization if it contains any aromatic atom symbols, as was in the example above. Next, the actual translation process begins. In the simplest case, if the input represents a simple atom chain, then a translation to SELFIES is performed by essentially grouping each atom symbol with its preceding bond symbol, if any. For example, the SMILES string O<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>[13CH]C#N would be partitioned into O, <private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char> [13CH], C, #N and turned respectively into SELFIES symbols [O][<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>13CH1][C][#N]. Branches are recursively translated and the result is used to work backwards to find the appropriate branch and indexing symbols to prepend. If there are multiple plausible choices, we use the one in which the branch symbol [<italic toggle="yes">β</italic>Branch<italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>] has <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> minimized and <italic toggle="yes">β</italic> representing the bond connecting the branch to the parent chain. For instance, C(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)O is encoded as [C][<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>Branch1][C][<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O][O] instead of [C][#Branch2][C][C][<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O][O], despite both SELFIES strings producing C(<private-char name="DOUBLE BOND, LENGTH AS M-DASH" description="double bond, length as m-dash"><glyph-ref glyph-data="z.dbd"/></private-char>O)O under the derivation process. Finally, ring closures are handled similarly in that we work backwards to find the appropriate ring and indexing symbols. If there are multiple choices, we use the one in which the ring symbol [<italic toggle="yes">β</italic> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>] (or [<italic toggle="yes">β</italic><sub>1</sub><italic toggle="yes">β</italic><sub>2</sub> Ring <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic>]) has <italic toggle="yes"><private-char name="ITALIC SMALL SCRIPT L" description="italic small script l"><glyph-ref glyph-data="lscr.i"/></private-char></italic> minimized and <italic toggle="yes">β</italic> (or <italic toggle="yes">β</italic><sub>1</sub>, <italic toggle="yes">β</italic><sub>2</sub>) representing the bond of the ring closure.</p>
      <sec>
        <label>4.1.1.</label>
        <title>SELFIES and SMILES</title>
        <p>The core functions of selfies interconvert between SELFIES and SMILES; and in Section 3, we present the method of interpreting SELFIES strings by deriving SMILES strings under a simple augmented grammar, following the previous SELFIES paper.<sup><xref rid="cit10" ref-type="bibr">10</xref></sup> However, it is important to note that SELFIES is not conceptually reliant on SMILES, and we may just as naturally interpret SELFIES strings through deriving molecular graphs. In fact, before version 2.0.0, both encoder( ) and decoder( ) were implemented as direct string-to-string translations. We have since refactored the functions to convert the input string to an intermediate graph-based representation, which is subsequently transcribed in the target representation. Future work could then expose this graph representation with a clean interface, allowing users to use selfies in a SMILES-independent manner.</p>
      </sec>
      <sec>
        <label>4.1.2.</label>
        <title>Random SELFIES</title>
        <p>Since every string of SELFIES symbols can be derived into a valid SMILES string, we can generate random but valid SMILES strings by passing random SELFIES strings through decoder( ). To sample these SELFIES strings, we use the get_semantic_robust_alphabet( ) utility function, which returns a subset of semantically constrained SELFIES symbols:<graphic xlink:href="d3dd00044c-u2.jpg" id="ugr2" position="float"/></p>
        <p>Note that by changing the pool of SELFIES symbols from which we sample from, we can change the distribution of produced molecules.</p>
      </sec>
    </sec>
    <sec>
      <label>4.2.</label>
      <title>Explaining translation</title>
      <p>To explain translations between SELFIES and SMILES, both encoder( ) and decoder( ) support an attribute flag that enables attributions of the output string symbol(s) to symbol(s) in the input string:<graphic xlink:href="d3dd00044c-u3.jpg" id="ugr3" position="float"/></p>
      <p>The attributions are a list of AttributionMap objects, one for each output symbol. Each AttributionMap contains the output symbol, its index, and a list of Attribution objects, each of which holds an input symbol (and its index) that is responsible for the output symbol. Note that a single output symbol may be attributed to multiple input symbols because it may be determined by both atom symbols and branch or ring symbols. Tracing the relationship between symbols can enable alignment between SMILES and SELFIES so that per-atom properties can be connected on both sides of the translation.</p>
    </sec>
    <sec>
      <label>4.3.</label>
      <title>Customization functions</title>
      <p>The selfies library dynamically constructs its derivation rules from a set of prespecified constraints, which dictate the maximum number of bonds that each atom type in a molecule may form. The derivation rules then ensure that each SELFIES string corresponds to a molecular graph satisfying the set constraints. By choosing a set of constraints in accordance with chemical valences, 100% robustness can be achieved. Specifically, selfies uses the constraints in <xref rid="tab4" ref-type="table">Table 4</xref> by default.</p>
      <p>However, a limitation of the default constraints is that SELFIES cannot represent existing molecules that violate them, such as perchloric acid (which features a hypervalent Cl making 7 bonds). Moreover, the catch-all constraint may be too relaxed to ensure the validity of SELFIES strings containing atom types outside those in <xref rid="tab4" ref-type="table">Table 4</xref> (<italic toggle="yes">e.g.</italic>, Si, Se). Hence, users may wish to instead use custom constraints that are tailored to the SELFIES strings being worked with. To this end, selfies provides the key function set_semantic_constraints( ). The following provides a minimal example:<graphic xlink:href="d3dd00044c-u4.jpg" id="ugr4" position="float"/></p>
      <p>Here, the constraints dictionary encodes a set of custom constraints; specifically, explicit constraints on the neutral and ±1 charged variants of C (as in <xref rid="tab4" ref-type="table">Table 4</xref>) and a catch-all constraint (of 4 maximum bonds). Line 8 then sets constraints as the underlying semantic constraints that selfies will operate under, which changes the subsequent behaviour of encoder( ) and decoder( ) appropriately. Note that the pre-existing constraints are fully replaced in Line 8; any constraint that is not explicitly specified in constraints would be thus removed.</p>
      <p>For convenience, selfies provides a couple of preset constraints to serve as templates that can be easily modified. These can be obtained as follows:<graphic xlink:href="d3dd00044c-u5.jpg" id="ugr5" position="float"/></p>
      <p>The currently-set constraints can also be viewed by:<graphic xlink:href="d3dd00044c-u6.jpg" id="ugr6" position="float"/></p>
    </sec>
    <sec>
      <label>4.4.</label>
      <title>Utility functions</title>
      <p>The selfies library provides a number of utility and convenience functions. Two basic utility functions are len_selfies( ), which computes the number of symbols in a SELFIES string, and split_selfies( ), which tokenizes a SELFIES string into an iterable of its constituent symbols:<graphic xlink:href="d3dd00044c-u7.jpg" id="ugr7" position="float"/></p>
      <p>Furthermore, selfies includes functions to extract a vocabulary of symbols from a dataset of SELFIES strings, and to convert SELFIES strings into label or one-hot encodings. Consider the following example:<graphic xlink:href="d3dd00044c-u8.jpg" id="ugr8" position="float"/></p>
      <p>Here, we are given a list dataset of SELFIES strings. Line 7 uses a utility function of selfies to extract the set alphabet of SELFIES symbols that appear in the dataset, which is used in Line 13 to create a symbol to index mapping termed stoi. Next, lines 17–22 use another utility function selfies_to_encoding( ) to create a label and one-hot encoding of the first SELFIES string in the dataset. Under the hood, this function first pads the input string to length pad_to_len by appending to it sufficiently many copies of the symbol [nop] (for “no-operation”), which is a special padding symbol in selfies that is automatically ignored by decoder( ). Then, the padded SELFIES string is tokenized, and stoi is used to convert each of its symbols into integer labels and one-hot vectors. Since the padded SELFIES string may now contain [nop], this symbol must be added to stoi, which is done through Line 8. Lastly, the reverse encoding can be performed using the encoding_to_selfies( ) utility:<graphic xlink:href="d3dd00044c-u9.jpg" id="ugr9" position="float"/></p>
      <p><xref rid="tab5" ref-type="table">Table 5</xref> summarizes the various utility functions introduced within this section.</p>
      <table-wrap position="float" id="tab5">
        <caption>
          <title>An overview of selfies utility functions</title>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col span="1"/>
            <col span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Function</th>
              <th rowspan="1" colspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">len_selfies( )</td>
              <td rowspan="1" colspan="1">Computes the symbol length of a SELFIES string</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">split_selfies( )</td>
              <td rowspan="1" colspan="1">Tokenizes a SELFIES string into its constituent symbols</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">get_alphabet_from_selfies( )</td>
              <td rowspan="1" colspan="1">Extracts a minimal vocabulary from a dataset of SELFIES strings</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">selfies_to_encoding( )</td>
              <td rowspan="1" colspan="1">Converts a SELFIES string into a label and/or one-hot encoding</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">encoding_to_selfies( )</td>
              <td rowspan="1" colspan="1">Recovers a SELFIES string from its label and/or one-hot encoding</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">get_semantic_robust_alphabet( )</td>
              <td rowspan="1" colspan="1">Provides an alphabet of semantically-constrained SELFIES symbols</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <label>5.</label>
    <title>Results and discussion</title>
    <p>The selfies library is quick and efficient in its translation, despite being implemented in pure Python. To demonstrate this, we provide some simple benchmarks of its core functions encoder( ) and decoder( ). The following experiments were run on Google Colaboratory, which uses two 2.20 GHz Intel(R) Xeon(R) CPUs.</p>
    <sec>
      <label>5.1.</label>
      <title>Roundtrip translation</title>
      <p>Here, we consider the roundtrip translation task, where a SMILES string is translated to SELFIES and then back to SMILES (see Section 4.1). Specifically, we translate the Developmental Therapeutics Program (DTP) open compound collection,<sup><xref rid="cit22" ref-type="bibr">22,23</xref></sup> which contains a little over 300 k SMILES strings and is a set of molecules which have been tested experimentally for potential treatment against cancer and the acquired immunodeficiency syndrome (AIDS).<sup><xref rid="cit24" ref-type="bibr">24</xref></sup> Translating the full dataset into SELFIES strings with encoder( ) takes 136 s, and recovering the SMILES dataset using decoder( ) takes 116 s, for a total roundtrip translation time of 252 s. <xref rid="fig2" ref-type="fig">Fig. 2</xref> plots how this roundtrip time scales with molecular size. Notably, we obtain all of these times by averaging over 3 replicate trials.</p>
    </sec>
    <sec>
      <label>5.2.</label>
      <title>Random SELFIES</title>
      <p>First, we sample 1000 fixed-length SELFIES strings and translate them to SMILES, per Section 4.1. We try this experiment with different symbol lengths and alphabets from which the SELFIES strings are built. <xref rid="fig1" ref-type="fig">Fig. 1</xref> shows the resulting distribution of SMILES strings and the time it takes to decode each full batch of random SELFIES strings. Performing this experiment reaffirms the robustness of SELFIES and demonstrates the ease in which we can create random valid molecules without applying any filters, pre- or post-selection. In <xref rid="fig1" ref-type="fig">Fig. 1a</xref>, we show how SELFIES strings sampled from a basic alphabet translate to random molecules; an important observation is that the generated molecules are rather small, independent of the SELFIES length chosen. That is mainly caused by the inclusion of multi-bonds and low-valence atoms in the considered alphabet, which exhaust the available valences of the constituent atoms and then lead to an earlier termination of the derivation. A simple workaround is to instead use an alphabet without multi-bonds and low-valence atom types, as illustrated in <xref rid="fig1" ref-type="fig">Fig. 1b</xref>. Here, the molecular size distribution is shifted significantly towards larger molecules, especially when longer SELFIES string are sampled. Hence, this showcases how to create very large and valid random molecules.</p>
      <fig position="float" id="fig1">
        <label>Fig. 1</label>
        <caption>
          <title>For a fixed alphabet <inline-graphic xlink:href="d3dd00044c-t52.jpg" id="ugt52"/> 1000 SELFIES strings were generated by uniformly sampling <italic toggle="yes">L</italic> symbols from an alphabet. Then, we plot the size distribution of the resulting molecules for varying symbol lengths <italic toggle="yes">L</italic>. (a) We take <inline-graphic xlink:href="d3dd00044c-t53.jpg" id="ugt53"/> to be the 69 symbols returned by get_semantic_robust_alphabet( ) under the default semantic constraints. (b) We filter the alphabet in (a) to 19 symbols by removing all atom symbols [<italic toggle="yes">βα</italic>] where <italic toggle="yes">β</italic> ∈ {=, #} or <italic toggle="yes">ν</italic>(type(<italic toggle="yes">α</italic>)) = 1, and removing all branch and ring symbols except for [Branch1] and [Ring1]. This decreases the chance that the SELFIES derivation process is terminated early, causing the derived molecules to be larger. (c) The time taken to translate each batch of random SELFIES strings to SMILES using decoder( ), measured by averaging over 20 replicate trials.</title>
        </caption>
        <graphic xlink:href="d3dd00044c-f1" position="float"/>
      </fig>
      <fig position="float" id="fig2">
        <label>Fig. 2</label>
        <caption>
          <title>The roundtrip translation time of 1000 randomly-sampled SMILES strings from the DTP open compound collection as a function of size, measured in number of atoms.</title>
        </caption>
        <graphic xlink:href="d3dd00044c-f2" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <label>6.</label>
    <title>Conclusions and outlook</title>
    <p>Since its first release in 2019, the selfies library has undergone significant changes and experienced a drastic transformation in terms of both capabilities and code design. All of these modifications were executed with two major premises, namely, (1) extending its functionality and capability to support all features of the SMILES representation and (2) retaining or even improving upon its simplicity and user-friendliness. To achieve that, we implemented all necessary functionality in the library itself so that it does not require any other packages. Additionally, we added several utility functions to the library to support common use cases. Apart from these two prime goals, we also made significant efforts to make the implementation faster as SELFIES has been employed in many performance-critical applications and workflows.</p>
    <p>Overall, the SELFIES community has grown rapidly and we are actively engaging in constructive discussions about the current implementation and future improvements. While selfies 2.1.1 supports almost all important features of SMILES, there are still many new features on our agenda. We outlined many of them in a recent perspective,<sup><xref rid="cit20" ref-type="bibr">20</xref></sup> for example, extensions to polymers, crystals, molecules with non-covalent bonds, or reactions. Our vision is that SELFIES will become a standard computer representation for molecular matter. We encourage the community to implement it into their workflows, report errors in the current implementation, and propose changes and new features that will help them to succeed in their goals.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The selfies library is available at GitHub (<uri xlink:href="https://github.com/aspuru-guzik-group/selfies">https://github.com/aspuru-guzik-group/selfies</uri>). Our benchmarking scripts were run on Google Colab and are also available at our repository (<uri xlink:href="https://github.com/aspuru-guzik-group/selfies/blob/f38eeea4c8b60ce412fa917adb9258b89d4e8efc/examples/benchmark_v2_1_1.ipynb">https://github.com/aspuru-guzik-group/selfies/blob/f38eeea4c8b60ce412fa917adb9258b89d4e8efc/examples/benchmark_v2_1_1.ipynb</uri>).</p>
  </sec>
  <sec>
    <title>Author contributions</title>
    <p>A. L.: conceptualization (equal), data curation (lead), formal analysis (lead), investigation (lead), methodology (lead), software (lead), validation (lead), visualization (lead), writing – original draft (lead), writing – review &amp; editing (lead). R. P.: conceptualization (equal), funding acquisition (supporting), methodology (equal), project administration (equal), software (equal), supervision (equal), writing – original draft (equal), writing – review &amp; editing (equal). A. K. N.: conceptualization (equal), funding acquisition (supporting), methodology (supporting), software (supporting), writing – original draft (supporting), writing – review &amp; editing (equal). A. D. W.: methodology (supporting), software (supporting), writing – original draft (supporting), writing – review &amp; editing (supporting). M. K.: conceptualization (equal), methodology (equal), project administration (equal), software (equal), supervision (equal), writing – original draft (equal), writing – review &amp; editing (equal). A. A. -G: conceptualization (equal), funding acquisition (lead), project administration (supporting), resources (lead), supervision (supporting), writing – review &amp; editing (supporting).</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflicts of interest</title>
    <p>There are no conflicts to declare.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
  </sec>
</body>
<back>
  <ack>
    <p>R. P. acknowledges funding through a Postdoc. Mobility fellowship by the Swiss National Science Foundation (SNSF, Project No. 191127). A. K. N. acknowledges funding from the Bio-X Stanford Interdisciplinary Graduate Fellowship (SGIF). A. A.-G. thanks Anders G. Frøseth for his generous support. A. A.-G. also acknowledges the support of Natural Resources Canada and the Canada 150 Research Chairs program.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="cit1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Warr</surname>
            <given-names>W. A.</given-names>
          </name>
        </person-group>
        <article-title>Representation of chemical structures</article-title>
        <source>Wiley Interdiscip. Rev.: Comput. Mol. Sci.</source>
        <year>2011</year>
        <volume>1</volume>
        <fpage>557</fpage>
        <lpage>579</lpage>
      </element-citation>
    </ref>
    <ref id="cit2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wigh</surname>
            <given-names>D. S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Goodman</surname>
            <given-names>J. M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Lapkin</surname>
            <given-names>A. A.</given-names>
          </name>
        </person-group>
        <article-title>A review of molecular representation in the age of machine learning</article-title>
        <source>Wiley Interdiscip. Rev.: Comput. Mol. Sci.</source>
        <year>2022</year>
        <volume>12</volume>
        <fpage>e1603</fpage>
      </element-citation>
    </ref>
    <ref id="cit3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weininger</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>SMILES, a chemical language and information system. 1. Introduction to methodology and encoding rules</article-title>
        <source>J. Chem. Inf. Comput. Sci.</source>
        <year>1988</year>
        <volume>28</volume>
        <fpage>31</fpage>
        <lpage>36</lpage>
        <pub-id pub-id-type="doi">10.1021/ci00057a005</pub-id>
      </element-citation>
    </ref>
    <ref id="cit4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gómez-Bombarelli</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Wei</surname>
            <given-names>J. N.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Duvenaud</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Hernández-Lobato</surname>
            <given-names>J. M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Sánchez-Lengeling</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Sheberla</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aguilera-Iparraguirre</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Hirzel</surname>
            <given-names>T. D.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Adams</surname>
            <given-names>R. P.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Automatic chemical design using a data-driven continuous representation of molecules</article-title>
        <source>ACS Cent. Sci.</source>
        <year>2018</year>
        <volume>4</volume>
        <fpage>268</fpage>
        <lpage>276</lpage>
        <pub-id pub-id-type="doi">10.1021/acscentsci.7b00572</pub-id>
        <?supplied-pmid 29532027?>
        <pub-id pub-id-type="pmid">29532027</pub-id>
      </element-citation>
    </ref>
    <ref id="cit5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sanchez-Lengeling</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Inverse molecular design using machine learning: generative models for matter engineering</article-title>
        <source>Science</source>
        <year>2018</year>
        <volume>361</volume>
        <fpage>360</fpage>
        <lpage>365</lpage>
        <pub-id pub-id-type="doi">10.1126/science.aat2663</pub-id>
        <?supplied-pmid 30049875?>
        <pub-id pub-id-type="pmid">30049875</pub-id>
      </element-citation>
    </ref>
    <ref id="cit6">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Kusner</surname><given-names>M. J.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Paige</surname><given-names>B.</given-names></name></person-group> and <person-group person-group-type="author"><name><surname>Hernández-Lobato</surname><given-names>J. M.</given-names></name></person-group>, <source>Proceedings of the 34th International Conference on Machine Learning</source>, <volume>vol. 70</volume>, <year>2017</year>, pp. 1945–1954</mixed-citation>
    </ref>
    <ref id="cit7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Olivecrona</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Blaschke</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Engkvist</surname>
            <given-names>O.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <article-title>Molecular de-novo design through deep reinforcement learning</article-title>
        <source>J. Cheminf.</source>
        <year>2017</year>
        <volume>9</volume>
        <fpage>48</fpage>
      </element-citation>
    </ref>
    <ref id="cit8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Popova</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Isayev</surname>
            <given-names>O.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Tropsha</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Deep reinforcement learning for <italic toggle="yes">de novo</italic> drug design</article-title>
        <source>Sci. Adv.</source>
        <year>2018</year>
        <volume>4</volume>
        <fpage>eaap7885</fpage>
        <pub-id pub-id-type="doi">10.1126/sciadv.aap7885</pub-id>
        <?supplied-pmid 30050984?>
        <pub-id pub-id-type="pmid">30050984</pub-id>
      </element-citation>
    </ref>
    <ref id="cit9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>O’Boyle</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Dalke</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>DeepSMILES: an adaptation of SMILES for use in machine-learning of chemical structures</article-title>
        <source>ChemRxiv</source>
        <year>2018</year>
        <pub-id pub-id-type="doi">10.26434/chemrxiv.7097960.v1</pub-id>
      </element-citation>
    </ref>
    <ref id="cit10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Krenn</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Häse</surname>
            <given-names>F.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Nigam</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Friederich</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Self-referencing embedded strings (SELFIES): a 100% robust molecular string representation</article-title>
        <source>Mach. Learn.: Sci. Technol.</source>
        <year>2020</year>
        <volume>1</volume>
        <fpage>045024</fpage>
      </element-citation>
    </ref>
    <ref id="cit11">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Hopcroft</surname><given-names>J. E.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Motwani</surname><given-names>R.</given-names></name></person-group> and <person-group person-group-type="author"><name><surname>Ullman</surname><given-names>J. D.</given-names></name></person-group>, <source>Introduction to automata theory, languages, and computation</source>, <publisher-name>Addison-Wesley</publisher-name>, <publisher-loc>Boston, MA</publisher-loc>, <year>2006</year></mixed-citation>
    </ref>
    <ref id="cit12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nigam</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Pollice</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Krenn</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>dos Passos Gomes</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Beyond generative models: superfast traversal, optimization, novelty, exploration and discovery (STONED) algorithm for molecules using SELFIES</article-title>
        <source>Chem. Sci.</source>
        <year>2021</year>
        <volume>12</volume>
        <fpage>7079</fpage>
        <lpage>7090</lpage>
        <pub-id pub-id-type="doi">10.1039/D1SC00231G</pub-id>
        <?supplied-pmid 34123336?>
        <pub-id pub-id-type="pmid">34123336</pub-id>
      </element-citation>
    </ref>
    <ref id="cit13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shen</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Krenn</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Eppel</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Deep molecular dreaming: inverse machine learning for de-novo molecular design and interpretability with surjective representations</article-title>
        <source>Mach. Learn.: Sci. Technol.</source>
        <year>2021</year>
        <volume>2</volume>
        <fpage>03LT02</fpage>
      </element-citation>
    </ref>
    <ref id="cit14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thiede</surname>
            <given-names>L. A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Krenn</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Nigam</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Curiosity in exploring chemical spaces: intrinsic rewards for molecular reinforcement learning</article-title>
        <source>Mach. Learn.: Sci. Technol.</source>
        <year>2022</year>
        <volume>3</volume>
        <fpage>035008</fpage>
      </element-citation>
    </ref>
    <ref id="cit15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Eckmann</surname><given-names>P.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Sun</surname><given-names>K.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Zhao</surname><given-names>B.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Feng</surname><given-names>M.</given-names></name></person-group>, <person-group person-group-type="author"><name><surname>Gilson</surname><given-names>M.</given-names></name></person-group> and <person-group person-group-type="author"><name><surname>Yu</surname><given-names>R.</given-names></name></person-group>, <source>International Conference on Machine Learning</source>, <year>2022</year>, pp. 5777–5792</mixed-citation>
    </ref>
    <ref id="cit16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wellawatte</surname>
            <given-names>G. P.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Seshadri</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>White</surname>
            <given-names>A. D.</given-names>
          </name>
        </person-group>
        <article-title>Model agnostic generation of counterfactual explanations for molecules</article-title>
        <source>Chem. Sci.</source>
        <year>2022</year>
        <volume>13</volume>
        <fpage>3697</fpage>
        <lpage>3705</lpage>
        <pub-id pub-id-type="doi">10.1039/D1SC05259D</pub-id>
        <?supplied-pmid 35432902?>
        <pub-id pub-id-type="pmid">35432902</pub-id>
      </element-citation>
    </ref>
    <ref id="cit17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rajan</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Zielesny</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Steinbeck</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>DECIMER: towards deep learning for chemical image recognition</article-title>
        <source>J. Cheminf.</source>
        <year>2020</year>
        <volume>12</volume>
        <fpage>65</fpage>
      </element-citation>
    </ref>
    <ref id="cit18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rajan</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Zielesny</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Steinbeck</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>STOUT: SMILES to IUPAC names using neural machine translation</article-title>
        <source>J. Cheminf.</source>
        <year>2021</year>
        <volume>13</volume>
        <fpage>34</fpage>
      </element-citation>
    </ref>
    <ref id="cit19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cheng</surname>
            <given-names>A. H.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Cai</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Miret</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Malkomes</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Phielipp</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Aspuru-Guzik</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>Group SELFIES: a robust fragment-based molecular string representation</article-title>
        <source>Digital Discovery</source>
        <year>2023</year>
        <volume>2</volume>
        <fpage>748</fpage>
        <lpage>758</lpage>
        <pub-id pub-id-type="doi">10.1039/D3DD00012E</pub-id>
      </element-citation>
    </ref>
    <ref id="cit20">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Krenn</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Ai</surname>
            <given-names>Q.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Barthel</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Carson</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Frei</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Frey</surname>
            <given-names>N. C.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Friederich</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Gaudin</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Gayle</surname>
            <given-names>A. A.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Jablonka</surname>
            <given-names>K. M.</given-names>
          </name>
        </person-group>
        <article-title>et al., SELFIES and the future of molecular string representations</article-title>
        <source>Patterns</source>
        <year>2022</year>
        <volume>3</volume>
        <fpage>100588</fpage>
        <pub-id pub-id-type="doi">10.1016/j.patter.2022.100588</pub-id>
        <?supplied-pmid 36277819?>
        <pub-id pub-id-type="pmid">36277819</pub-id>
      </element-citation>
    </ref>
    <ref id="cit21">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Landrum</surname><given-names>G.</given-names></name></person-group>, <article-title><italic toggle="yes">et al.</italic></article-title>, <source>RDKit: Open-Source Cheminformatics</source>, <year>2006</year>, <uri xlink:href="https://www.rdkit.org/">https://www.rdkit.org/</uri></mixed-citation>
    </ref>
    <ref id="cit22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Voigt</surname>
            <given-names>J. H.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Bienfait</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Nicklaus</surname>
            <given-names>M. C.</given-names>
          </name>
        </person-group>
        <article-title>Comparison of the NCI open database with seven large chemical structural databases</article-title>
        <source>J. Chem. Inf. Comput. Sci.</source>
        <year>2001</year>
        <volume>41</volume>
        <fpage>702</fpage>
        <lpage>712</lpage>
        <pub-id pub-id-type="doi">10.1021/ci000150t</pub-id>
        <?supplied-pmid 11410049?>
        <pub-id pub-id-type="pmid">11410049</pub-id>
      </element-citation>
    </ref>
    <ref id="cit23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ihlenfeldt</surname>
            <given-names>W.-D.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Voigt</surname>
            <given-names>J. H.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Bienfait</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Oellien</surname>
            <given-names>F.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Nicklaus</surname>
            <given-names>M. C.</given-names>
          </name>
        </person-group>
        <article-title>Enhanced CACTVS browser of the Open NCI Database</article-title>
        <source>J. Chem. Inf. Comput. Sci.</source>
        <year>2002</year>
        <volume>42</volume>
        <fpage>46</fpage>
        <lpage>57</lpage>
        <pub-id pub-id-type="doi">10.1021/ci010056s</pub-id>
        <?supplied-pmid 11855965?>
        <pub-id pub-id-type="pmid">11855965</pub-id>
      </element-citation>
    </ref>
    <ref id="cit24">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Milne</surname>
            <given-names>G. W.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Nicklaus</surname>
            <given-names>M. C.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Driscoll</surname>
            <given-names>J. S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <person-group person-group-type="author">
          <name>
            <surname>Zaharevitz</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>National cancer institute drug information system 3D database</article-title>
        <source>J. Chem. Inf. Comput. Sci.</source>
        <year>1994</year>
        <volume>34</volume>
        <fpage>1219</fpage>
        <lpage>1224</lpage>
        <pub-id pub-id-type="doi">10.1021/ci00021a032</pub-id>
        <?supplied-pmid 7962217?>
        <pub-id pub-id-type="pmid">7962217</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
