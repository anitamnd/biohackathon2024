<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8312264</article-id>
    <article-id pub-id-type="pmid">34252921</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btab328</article-id>
    <article-id pub-id-type="publisher-id">btab328</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Evolutionary, Comparative and Population Genomics</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Gene tree and species tree reconciliation with endosymbiotic gene
transfer</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Anselmetti</surname>
          <given-names>Yoann</given-names>
        </name>
        <xref rid="btab328-aff1" ref-type="aff">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>El-Mabrouk</surname>
          <given-names>Nadia</given-names>
        </name>
        <xref rid="btab328-aff2" ref-type="aff">2</xref>
        <xref rid="btab328-cor1" ref-type="corresp"/>
        <!--mabrouk@iro.umontreal.ca-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lafond</surname>
          <given-names>Manuel</given-names>
        </name>
        <xref rid="btab328-aff1" ref-type="aff">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ouangraoua</surname>
          <given-names>Aïda</given-names>
        </name>
        <xref rid="btab328-aff1" ref-type="aff">1</xref>
      </contrib>
    </contrib-group>
    <aff id="btab328-aff1">
      <label>1</label>
      <institution>Département d'informatique, Université de Sherbrooke, 2500, boulevard de
l'Université, Sherbrooke (Québec) J1K 2R1, Canada</institution>
    </aff>
    <aff id="btab328-aff2">
      <label>2</label>
      <institution>Département d'informatique et de recherche opérationnelle, Université de
Montréal, CP 6128 succ Centre-Ville, Montréal, Québec H3C 3J7, Canada</institution>
    </aff>
    <author-notes>
      <corresp id="btab328-cor1">To whom correspondence should be addressed.
<email>mabrouk@iro.umontreal.ca</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2021-07-12">
      <day>12</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>12</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <volume>37</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2021 Proceedings</issue-title>
    <fpage>i120</fpage>
    <lpage>i132</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2021. Published by Oxford University
Press.</copyright-statement>
      <copyright-year>2021</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative
Commons Attribution License (<ext-link xmlns:xlink="http://www.w3.org/1999/xlink" ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted
reuse, distribution, and reproduction in any medium, provided the original work is
properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btab328.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>It is largely established that all extant mitochondria originated from a unique
endosymbiotic event integrating an α−proteobacterial genome into an eukaryotic cell.
Subsequently, eukaryote evolution has been marked by episodes of gene transfer, mainly
from the mitochondria to the nucleus, resulting in a significant reduction of the
mitochondrial genome, eventually completely disappearing in some lineages. However, in
other lineages such as in land plants, a high variability in gene repertoire
distribution, including genes encoded in both the nuclear and mitochondrial genome, is
an indication of an ongoing process of Endosymbiotic Gene Transfer (EGT). Understanding
how both nuclear and mitochondrial genomes have been shaped by gene loss, duplication
and transfer is expected to shed light on a number of open questions regarding the
evolution of eukaryotes, including rooting of the eukaryotic tree.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We address the problem of inferring the evolution of a gene family through duplication,
loss and EGT events, the latter considered as a special case of horizontal gene transfer
occurring between the mitochondrial and nuclear genomes of the same species (in one
direction or the other). We consider both EGT events resulting in maintaining (EGTcopy)
or removing (EGTcut) the gene copy in the source genome. We present a linear-time
algorithm for computing the DLE (Duplication, Loss and EGT) distance, as well as an
optimal reconciled tree, for the unitary cost, and a dynamic programming algorithm
allowing to output all optimal reconciliations for an arbitrary cost of operations. We
illustrate the application of our EndoRex software and analyze different costs settings
parameters on a plant dataset and discuss the resulting reconciled trees.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>EndoRex implementation and supporting data are available on the GitHub repository via
<ext-link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/AEVO-lab/EndoRex" ext-link-type="uri">https://github.com/AEVO-lab/EndoRex</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Natural Sciences and Engineering Research Council of Canada</institution>
            <institution-id institution-id-type="DOI">10.13039/501100000038</institution-id>
          </institution-wrap>
          <!-- oupReleaseDelayRemoved from OA Article (00|0) -->
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Fonds de recherche Nature et Technologie, Québec</institution>
          </institution-wrap>
          <!-- oupReleaseDelayRemoved from OA Article (00|0) -->
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="13"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Genomics and cell biology investigations have revealed that all known eukaryotes descend
from a common ancestral mitochondrial-containing cell that originated from the integration
of an endosymbiotic α-proteobacterium into a host cell (<xref rid="btab328-B11" ref-type="bibr">Dyall and Johnson, 2000</xref>). After this early event, eukaryotic gene
contents have been shaped by duplications, losses and Horizontal Gene Transfers (HGT) from
one species to another, but also by Endosymbiotic Gene Transfers (EGT), mainly from the
mitochondrion to the nucleus, in some cases leading to the total disappearance of the
mitochondrion (<xref rid="btab328-B26" ref-type="bibr">Roger et al., 2017</xref>; <xref rid="btab328-B28" ref-type="bibr">Sloan et al., 2018</xref>).</p>
    <p>Many questions regarding the ancestral mitochondrial proteome and gene content evolution
remain open (<xref rid="btab328-B21" ref-type="bibr">Lang and Burger, 2012</xref>). One of
the reasons is that, to date, comparative genomics studies have largely focused on
multicellular eukaryotes, mainly animals and plants. While imprints of global evolutionary
events at the genomic level are hardly visible on multicellular eukaryotes that have
diverged too much from the Last Eukaryotic Common Ancestor (LECA), protists, known to have
emerged close to the eukaryotic origin, are better candidates for such a comprehensive
evolutionary study. Interestingly, a recent sequencing effort on jakobids (<xref rid="btab328-B16" ref-type="bibr">Gray et al., 2020</xref>) and malawimonads (<xref rid="btab328-B8" ref-type="bibr">Derelle et al., 2015</xref>) protist genomes have been
undertaken by a consortium of protistologists (DeepEuk), suggesting that soon enough data
will be available to allow further investigations on early-eukaryotic evolution.</p>
    <p>In addition to having the appropriate datasets, understanding the concerted evolution of
the eukaryotic mitochondrial and nuclear genomes also requires having the appropriate
algorithmic tools. This problem can be seen as related to the host-parasite coevolution
inference problem (<xref rid="btab328-B6" ref-type="bibr">Charleston and Perkins,
2006</xref>). Given a host tree and a parasite tree, cophylogenetic analysis consists in
inferring a history of codivergence, parasite duplication, host switch or extinction events
explaining the coevolution of hosts and parasites. However, nuclear and mitochondrial
genomes can hardly be treated by the same kind of approach, as they evolve, through a
different evolutionary model, together in the same species, and thus are related through the
same species tree. Rather, inferring an endosymbiotic evolutionary history requires focusing
on gene families and studying the movement of genes between the mitochondrial and nuclear
genomes.</p>
    <p>Inferring the evolution of gene families is the purpose of the
gene-tree-species-tree-reconciliation field, seeking for a most parsimonious (<xref rid="btab328-B13" ref-type="bibr">El-Mabrouk and Noutahi, 2019</xref>; <xref rid="btab328-B15" ref-type="bibr">Goodman et al., 1979</xref>), or a most probable (<xref rid="btab328-B2" ref-type="bibr">Akerborg et al., 2009</xref>; <xref rid="btab328-B31" ref-type="bibr">Szöllősi et al., 2015</xref>) evolutionary scenario of gene gain and
loss explaining the incongruence between a gene tree and a species tree. A most parsimonious
reconciliation minimizing the number of Duplications (the D-distance) or the number of
Duplications and Losses (the DL-distance) can be found in linear time using the LCA (Last
Common Ancestor) mapping (<xref rid="btab328-B7" ref-type="bibr">Chen, 2000</xref>; <xref rid="btab328-B34" ref-type="bibr">Zhang, 1997</xref>; <xref rid="btab328-B35" ref-type="bibr">Zmasek and Eddy, 2001</xref>). Such an algorithm can actually be used to
solve the cophylogenetic problem if operations are restricted to coevolution, duplication
and extinction. Including HGT events (i.e. finding the DTL-distance) leads to an NP-hard
problem if time-consistency is required, remaining polynomial otherwise (<xref rid="btab328-B3" ref-type="bibr">Bansal et al., 2012</xref>; <xref rid="btab328-B32" ref-type="bibr">Tofigh et al., 2011</xref>).</p>
    <p>In this article, we introduce the reconciliation model accounting for EGT events, i.e. the
special case of HGT events where genes are exchanged only between the mitochondrial and
nuclear genomes of the same species. Although integration of the mitochondrial content into
the nucleus is the most frequent event in the course of evolution of eukaryotes, the
transfer from the nucleus to the mitochondrion has also been observed (<xref rid="btab328-B1" ref-type="bibr">Adams and Palmer, 2003</xref>). Here, we consider the exchange of genes
in both directions. Moreover, we consider EGT events resulting in maintaining a gene copy in
the source genome (EGTcopy), as well as those resulting in the removal or loss of function
of the gene in the source genome (EGTcut).</p>
    <p>Formally, given a gene tree for a gene family with a known mitochondrial or nuclear
location for each gene copy, we seek for a most parsimonious sequence of Duplication, Loss
and EGT (DLE) events explaining the tree given a known species tree. First, based on the
DL-distance and on the Fitch algorithm for weighted parsimony, we present, in Section 3, a
linear-time algorithm for computing the DLE-Distance, as well as an optimal reconciled tree
for the unitary cost. We then develop, in Section 4, a general dynamic programming algorithm
that can be used to output all optimal reconciliations, for an arbitrary cost of operations,
including possibly a different cost for an EGT from the mitochondrion to the nucleus, or
conversely. This algorithm is linear in the size of the gene tree. It can be seen as an
adaptation of the quadratic-time DTL algorithm for dated trees (<xref rid="btab328-B10" ref-type="bibr">Doyon et al., 2010</xref>), which allows transfers between any
co-existing species. We finally illustrate, in Section 5, the application of our EndoRex
software on clusters of orthologous mitochondrial protein-coding genes (MitoCOGs) (<xref rid="btab328-B22" ref-type="bibr">Kannan et al., 2014</xref>) of plants, analyze different
costs settings parameters and discuss the obtained reconciled trees.</p>
    <p>For space reasons, some of the proofs are given in Appendix.</p>
  </sec>
  <sec>
    <title>2 Preliminaries</title>
    <p>All trees are considered rooted. Given a tree <italic toggle="yes">T</italic>, we denote by
<italic toggle="yes">r</italic>(<italic toggle="yes">T</italic>) its root, by <italic toggle="yes">V</italic>(<italic toggle="yes">T</italic>)
its set of nodes and by <inline-formula id="IE1"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> its leafset. A node <italic toggle="yes">x</italic> is a
<italic toggle="yes">descendant</italic> of <inline-formula id="IE2"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> if <italic toggle="yes">x</italic> is on the path from <inline-formula id="IE3"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> to a leaf of <italic toggle="yes">T</italic> and an
<italic toggle="yes">ancestor</italic> of <inline-formula id="IE4"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> if <italic toggle="yes">x</italic> is on the path from
<italic toggle="yes">r</italic>(<italic toggle="yes">T</italic>) to <inline-formula id="IE5"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>;</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">x</italic> is a <italic toggle="yes">strict descendant</italic>
(respectively <italic toggle="yes">strict ancestor</italic>) of <inline-formula id="IE6"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> if it is a descendant (respectively ancestor) of
<inline-formula id="IE7"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> different from <inline-formula id="IE8"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, <italic toggle="yes">x</italic> is the <italic toggle="yes">parent</italic>
of <inline-formula id="IE9"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>≠</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if it directly precedes <inline-formula id="IE10"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> on the path from <inline-formula id="IE11"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> to <italic toggle="yes">r</italic>(<italic toggle="yes">T</italic>). In this latter
case, <inline-formula id="IE12"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is a <italic toggle="yes">child</italic> of <italic toggle="yes">x</italic>. We denote
by <italic toggle="yes">E</italic>(<italic toggle="yes">T</italic>) the set of edges of <italic toggle="yes">T</italic>, where an
edge is represented by its two terminal nodes <inline-formula id="IE13"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, with <italic toggle="yes">x</italic> being the parent of <inline-formula id="IE14"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. An internal node (a node which is not a leaf) is said to be
<italic toggle="yes">unary</italic> if it has a single child and <italic toggle="yes">binary</italic> if it has two
children. If not stated differently, the children of a binary node <italic toggle="yes">x</italic> are
denoted <italic toggle="yes">x<sub>l</sub></italic> and <italic toggle="yes">x<sub>r</sub></italic>. Given a node
<italic toggle="yes">x</italic> of <italic toggle="yes">T</italic>, the subtree of <italic toggle="yes">T</italic> rooted at
<italic toggle="yes">x</italic> is denoted <inline-formula id="IE15"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    <p>A <italic toggle="yes">binary tree</italic> is a tree with all internal nodes being binary. If internal
nodes have one or two children, then the tree is said <italic toggle="yes">partially binary</italic>.</p>
    <p>The <italic toggle="yes">lowest common ancestor</italic> (LCA) in <italic toggle="yes">T</italic> of a subset
<inline-formula id="IE16"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE17"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, denoted <inline-formula id="IE18"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is the ancestor common to all the nodes in <inline-formula id="IE19"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> that is the most distant from the root.</p>
    <p>A tree <italic toggle="yes">R</italic> is <italic toggle="yes">an extension</italic> of a tree <italic toggle="yes">T</italic> if
it is obtained from <italic toggle="yes">T</italic> by <italic toggle="yes">grafting</italic> unary or binary nodes in
<italic toggle="yes">T</italic>, where grafting a unary node <italic toggle="yes">x</italic> on an edge
(<italic toggle="yes">u</italic>, <italic toggle="yes">v</italic>) consists in creating a new node
<italic toggle="yes">x</italic>, removing the edge (<italic toggle="yes">u</italic>, <italic toggle="yes">v</italic>) and
creating two edges (<italic toggle="yes">u</italic>, <italic toggle="yes">x</italic>) and (<italic toggle="yes">x</italic>,
<italic toggle="yes">v</italic>), and in the case of grafting a binary node, also creating a new leaf
<italic toggle="yes">y</italic> and an edge (<italic toggle="yes">x</italic>, <italic toggle="yes">y</italic>). In the latter
case, we say that <italic toggle="yes">y</italic> is a grafted leaf.</p>
    <p><italic toggle="yes">Species and gene trees:</italic> The <italic toggle="yes">species tree S</italic> for a set
<inline-formula id="IE20"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM20" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula> of species represents a partially ordered set of speciation
events that have led to <inline-formula id="IE21"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM21" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula>. In this article, we consider that each species of
<inline-formula id="IE22"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula> has two genomes:
<bold><sub><italic toggle="yes">σ</italic></sub></bold><sub>0</sub> corresponding to its mitochondrial
genome and <bold><sub><italic toggle="yes">σ</italic></sub></bold><sub>1</sub> corresponding to its
nuclear genome.</p>
    <p>A <italic toggle="yes">gene family</italic> is a set <inline-formula id="IE23"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM23" display="inline" overflow="scroll"><mml:mo>Γ</mml:mo></mml:math></inline-formula> of genes where each gene <italic toggle="yes">x</italic> belongs to a
given species <italic toggle="yes">s</italic>(<italic toggle="yes">x</italic>) of <inline-formula id="IE24"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM24" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula>. A tree <italic toggle="yes">T</italic> is a <italic toggle="yes">gene tree</italic>
for a gene family <inline-formula id="IE25"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM25" display="inline" overflow="scroll"><mml:mo>Γ</mml:mo></mml:math></inline-formula> if its leafset is in bijection with <inline-formula id="IE26"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM26" display="inline" overflow="scroll"><mml:mo>Γ</mml:mo></mml:math></inline-formula>. We will make no distinction between a leaf of
<italic toggle="yes">T</italic> and the gene of <sub><bold>Γ</bold></sub> it corresponds to. We call
<italic toggle="yes">s</italic>(<italic toggle="yes">x</italic>) the <italic toggle="yes">species labeling</italic> of the leaf
<italic toggle="yes">x</italic>. For a subset <inline-formula id="IE27"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>⊆</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:math></inline-formula> of genes, we write <inline-formula id="IE28"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>g</mml:mi><mml:mo>∈</mml:mo><mml:mi>G</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> as the set of species containing the genes of
<italic toggle="yes">G</italic>.</p>
    <p>Moreover, we assign to each gene <italic toggle="yes">x</italic> of <inline-formula id="IE29"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM29" display="inline" overflow="scroll"><mml:mo>Γ</mml:mo></mml:math></inline-formula> a Boolean value corresponding to the genome it belongs to.
More precisely, <italic toggle="yes">b</italic>(<italic toggle="yes">x</italic>) = 0 if <italic toggle="yes">x</italic> belongs to
<inline-formula id="IE30"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">b</italic>(<italic toggle="yes">x</italic>) = 1 if
<italic toggle="yes">x</italic> belongs to <inline-formula id="IE31"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. In this article, we assume that the mitochondrial or nuclear
location of each extant gene is known. We call <italic toggle="yes">b</italic>(<italic toggle="yes">x</italic>) the
<italic toggle="yes">genome labeling</italic> of the leaf representing <italic toggle="yes">x</italic>.</p>
    <p>An evolutionary history is represented by an <italic toggle="yes">event labeled</italic> tree, where the
event label <inline-formula id="IE32"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of an internal node <italic toggle="yes">x</italic> is its corresponding
event. The event labeling of the internal nodes of a gene tree is obtained through
reconciliation.</p>
    <sec>
      <title>2.1 Reconciliation</title>
      <p>Inside the species’ genomes, genes undergo <italic toggle="yes">Speciation</italic> (Spe) when the
species to which they belong do, but also <italic toggle="yes">Duplication</italic> (Dup) i.e. the
creation of a new gene copy, <italic toggle="yes">Loss</italic> of a gene copy and <italic toggle="yes">Horizontal
Gene Transfer</italic> (HGT) when a gene is transmitted from a source to a target
genome. In this article, we consider special cases of HGTs, called EGTs, only allowing the
transmission of genes from the mitochondrial genome to the nuclear genome of the same
species, or vice-versa. Moreover, we consider two types of EGTs: <italic toggle="yes">EGTcopy</italic>
and <italic toggle="yes">EGTcut</italic> defined as follows (see <xref rid="btab328-F1" ref-type="fig">Fig. 1</xref>):</p>
      <fig position="float" id="btab328-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>The effect of an event on a node <italic toggle="yes">x</italic> of a gene tree representing the
gene <italic toggle="yes">a</italic> belonging to the genome <italic toggle="yes">s<sub>i</sub></italic>
(denoted <inline-formula id="IE33"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>), where <italic toggle="yes">s</italic> is a species and
<inline-formula id="IE34"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> (for a species <italic toggle="yes">s</italic>,
<italic toggle="yes">s<sub>o</sub></italic> is the mitochondrial genome and
<italic toggle="yes">s</italic><sub>1</sub> the nuclear genome of <italic toggle="yes">s</italic>). The tree
<italic toggle="yes">S</italic> up-right is the species tree, where <italic toggle="yes">u</italic> and
<italic toggle="yes">v</italic> are the two species arising from the speciation of
<italic toggle="yes">s</italic>. (Spe): Gives rise to a copy <italic toggle="yes">a<sub>u</sub></italic> in
<italic toggle="yes">u<sub>i</sub></italic> and <italic toggle="yes">a<sub>v</sub></italic> in
<italic toggle="yes">v<sub>i</sub></italic>; (Dup): Preserves the copy <italic toggle="yes">a</italic> in
<italic toggle="yes">s<sub>i</sub></italic> and gives rise to a new copy <italic toggle="yes">b</italic> in
<italic toggle="yes">s<sub>i</sub></italic>; (EGTcopy): Represents a transfer event from
<italic toggle="yes">s<sub>i</sub></italic> to <italic toggle="yes">s<sub>j</sub></italic>, where
<inline-formula id="IE35"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE36"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>, preserving the copy <italic toggle="yes">a</italic> in
<italic toggle="yes">s<sub>i</sub></italic> and giving rise to a new copy
<italic toggle="yes">a<sub>j</sub></italic> in <italic toggle="yes">s<sub>j</sub></italic>; (EGTcut):
Represents a transposition event from <italic toggle="yes">s<sub>i</sub></italic> to
<italic toggle="yes">s<sub>j</sub></italic> removing the copy <italic toggle="yes">a</italic> in
<italic toggle="yes">s<sub>i</sub></italic> and creating a copy <italic toggle="yes">a<sub>j</sub></italic>
in <italic toggle="yes">s<sub>j</sub></italic></p>
        </caption>
        <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btab328f1" position="float"/>
      </fig>
      <list list-type="bullet">
        <list-item>
          <p>A gene <italic toggle="yes">x</italic> belonging to
<bold><sub><italic toggle="yes">σ</italic></sub></bold><sub><italic toggle="yes">i</italic></sub> is
<italic toggle="yes">copied</italic> (or transferred) by an EGTcopy event to
<bold><sub><italic toggle="yes">σ</italic></sub></bold><sub><italic toggle="yes">j</italic></sub> for
<inline-formula id="IE37"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> if it is copied from
<bold><sub><italic toggle="yes">σ</italic></sub></bold><sub><italic toggle="yes">i</italic></sub> and
inserted in
<bold><sub><italic toggle="yes">σ</italic></sub></bold><sub><italic toggle="yes">j</italic></sub>.</p>
        </list-item>
        <list-item>
          <p>A gene <italic toggle="yes">x</italic> belonging to
<bold><sub><italic toggle="yes">σ</italic></sub></bold><sub><italic toggle="yes">i</italic></sub> is
<italic toggle="yes">transposed</italic> by an EGTcut event to
<bold><sub><italic toggle="yes">σ</italic></sub></bold><sub><italic toggle="yes">j</italic></sub> for
<inline-formula id="IE38"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> if it is cut from
<bold><sub><italic toggle="yes">σ</italic></sub></bold><sub><italic toggle="yes">i</italic></sub> and inserted
in <bold><sub><italic toggle="yes">σ</italic></sub></bold><sub><italic toggle="yes">j</italic></sub>.</p>
        </list-item>
      </list>
      <p>Thus, in this article, the set of considered events is: <disp-formula id="E1"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">DLE</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Loss</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcut</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Notice that we do not consider general HGT events. To define a DLE-Reconciliation, assume
that we are given a species tree <italic toggle="yes">S</italic>, a gene tree <italic toggle="yes">T</italic>, a
mapping <italic toggle="yes">s</italic> from <inline-formula id="IE39"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE40"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and a mapping <italic toggle="yes">b</italic> from <inline-formula id="IE41"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to {0, 1}. We need to define how to extend
<italic toggle="yes">s</italic> and <italic toggle="yes">b</italic> to the internal nodes of <italic toggle="yes">T</italic>.
Given an extension <italic toggle="yes">R</italic> of <italic toggle="yes">T</italic> (<italic toggle="yes">R</italic> can be
equal to <italic toggle="yes">T</italic>) <italic toggle="yes">an extension of s</italic> is a function
<inline-formula id="IE42"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> from <italic toggle="yes">V</italic>(<italic toggle="yes">R</italic>) to
<italic toggle="yes">V</italic>(<italic toggle="yes">S</italic>) such that, for each leaf <italic toggle="yes">x</italic> of
<italic toggle="yes">T</italic>, <inline-formula id="IE43"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, an <italic toggle="yes">extension of b</italic> is a function
<inline-formula id="IE44"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> from <italic toggle="yes">V</italic>(<italic toggle="yes">R</italic>) to {0, 1} such
that, for each leaf <italic toggle="yes">x</italic> of <italic toggle="yes">T</italic>, <inline-formula id="IE45"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <statement id="mthst1">
        <label>Definition 1</label>
        <p>(DLE-Reconciliation).
<italic toggle="yes">Let</italic> <bold><sub><italic toggle="yes">Γ</italic></sub></bold> <italic toggle="yes">be a gene
family where each</italic> <inline-formula id="IE46"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">belongs to the genome b(x) of a species s(x)
of</italic> <bold><sub><italic toggle="yes">Σ</italic></sub></bold><italic toggle="yes">. Let T be a rooted
binary gene tree for</italic> <bold><sub><italic toggle="yes">Γ</italic></sub></bold> <italic toggle="yes">and S
be a rooted binary species tree
for</italic> <bold><sub><italic toggle="yes">Σ</italic></sub></bold><italic toggle="yes">. A DLE-Reconciliation
is a quadruplet</italic> <inline-formula id="IE47"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">where R is a partially binary extension of
T</italic>, <inline-formula id="IE48"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula><italic toggle="yes">is an extension of s and</italic> <inline-formula id="IE49"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula><italic toggle="yes">is an extension of b such that:</italic><list list-type="simple"><list-item><p>a. <inline-formula id="IE54"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE55"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">are the two children
of</italic> <inline-formula id="IE56"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">in S and</italic> <inline-formula id="IE57"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">, in which case</italic> <inline-formula id="IE58"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo>;</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>b. <inline-formula id="IE59"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>σ</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE60"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">in which case</italic> <inline-formula id="IE61"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">representing a duplication
in</italic> <inline-formula id="IE62"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>;</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>c. <inline-formula id="IE63"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>σ</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE64"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">in which case</italic> <inline-formula id="IE65"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo>;</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">let y be the element
of</italic> <inline-formula id="IE66"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">such that</italic> <inline-formula id="IE67"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">, then</italic> <inline-formula id="IE68"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">is a transfer with source
genome</italic> <inline-formula id="IE69"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">and target genome</italic> <inline-formula id="IE70"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p></list-item></list></p>
        <p><italic toggle="yes">A grafted leaf on a newly created node x corresponds to a loss
in</italic> <inline-formula id="IE71"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </statement>
      <p>As <italic toggle="yes">R</italic> is as an extension of <italic toggle="yes">T</italic>, each node in
<italic toggle="yes">T</italic> has a corresponding node in <italic toggle="yes">R</italic>. In other words, we
can consider that <inline-formula id="IE72"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In particular, the species labeling on <italic toggle="yes">R</italic>
induces a species labeling on <italic toggle="yes">T</italic>.</p>
      <p>Given a cost function <italic toggle="yes">c</italic> on <italic toggle="yes">DLE</italic> and a reconciliation
<inline-formula id="IE73"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>, the cost <inline-formula id="IE74"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the sum of costs of the induced events. In this article,
we assume a 0 cost for speciations and positive costs for all the other events.</p>
      <p>We are now ready to formally define the considered optimization problem.</p>
      <p>
        <bold>DLE-Reconciliation Problem:</bold>
      </p>
      <p>
        <disp-quote content-type="extract">
          <p><bold>Input:</bold> A species tree <italic toggle="yes">S</italic> for a set of species
<inline-formula id="IE75"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM71" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula>, a gene family <inline-formula id="IE76"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM72" display="inline" overflow="scroll"><mml:mo>Γ</mml:mo></mml:math></inline-formula> on <inline-formula id="IE77"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM73" display="inline" overflow="scroll"><mml:mo>Σ</mml:mo></mml:math></inline-formula>, a gene tree <italic toggle="yes">T</italic> for <inline-formula id="IE78"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM74" display="inline" overflow="scroll"><mml:mo>Γ</mml:mo></mml:math></inline-formula>, a species labeling <italic toggle="yes">s</italic> and a genome
labeling <italic toggle="yes">b</italic> of <inline-formula id="IE79"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and a cost function <italic toggle="yes">c</italic> on DLE.</p>
          <p><bold>Output:</bold> A most <italic toggle="yes">parsimonious DLE-Reconciliation</italic>, i.e. a
DLE-Reconciliation <inline-formula id="IE80"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> of minimum cost.</p>
        </disp-quote>
      </p>
      <p>In the next section, we first consider the case of a unitary cost, thus reducing the
problem to minimizing the number of operations induced by a reconciliation. The cost
<italic toggle="yes">DLE</italic>(<italic toggle="yes">T</italic>, <italic toggle="yes">S</italic>) of the most parsimonious
DLE-Reconciliation for <italic toggle="yes">T</italic> and <italic toggle="yes">S</italic> in the case of a unitary
cost <italic toggle="yes">c</italic> is called the <italic toggle="yes">DLE-Distance</italic>. We then extend the
algorithmic developments to arbitrary costs, allowing in particular to consider an EGTcopy
or an EGTcut event copying a gene from the mitochondria to the nucleus differently from a
similar event copying a gene from the nucleus to the mitochondria.</p>
      <p>In the following section, we will refer to the DL-Reconciliation of <italic toggle="yes">T</italic>
and <italic toggle="yes">S</italic>. Recall that it is a triplet <inline-formula id="IE81"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> defined by only considering the cases of speciations,
duplications and losses in Definition 1, and ignoring the binary assignment of genes. We
denote by <italic toggle="yes">DL</italic>(<italic toggle="yes">T</italic>, <italic toggle="yes">S</italic>) the DL-Distance,
i.e. the minimum number of duplications and losses induced by a DL-reconciliation. The
DL-Reconciliation <inline-formula id="IE82"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> of cost <italic toggle="yes">DL</italic>(<italic toggle="yes">T</italic>,
<italic toggle="yes">S</italic>) is unique and verifies, for any internal node <italic toggle="yes">x</italic> of
<inline-formula id="IE83"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>:</p>
      <list list-type="order">
        <list-item>
          <p>
            <inline-formula id="IE84">
              <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM80" display="inline" overflow="scroll">
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>s</mml:mi>
                    <mml:mo>˜</mml:mo>
                  </mml:mover>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>x</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi>l</mml:mi>
                  <mml:mi>c</mml:mi>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                    </mml:mrow>
                    <mml:mi>S</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>s</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>ℓ</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>T</mml:mi>
                  <mml:mo stretchy="false">[</mml:mo>
                  <mml:mi>x</mml:mi>
                  <mml:mo stretchy="false">]</mml:mo>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>;</mml:mo>
                </mml:mrow>
              </mml:math>
            </inline-formula>
          </p>
        </list-item>
        <list-item>
          <p>if <inline-formula id="IE85"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE86"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> then <italic toggle="yes">v</italic> is a Speciation; otherwise
<italic toggle="yes">x</italic> is a Duplication.</p>
        </list-item>
      </list>
      <p>We finally need to make the link between the species labeling <inline-formula id="IE87"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> of an optimal reconciliation and the well-known
LCA-Mapping. This is formally stated in the following lemma.</p>
      <statement id="mthst2">
        <label>Lemma 1</label>
        <p>(LCA-Mapping). <italic toggle="yes">Let</italic> <inline-formula id="IE88"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">be a DLE-Reconciliation of minimum cost between T
and S. Then, for each</italic> <inline-formula id="IE89"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>Note that in the above statement, <inline-formula id="IE90"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and thus the intersection is redundant. We write it this
way to emphasize that <italic toggle="yes">x</italic> is a vertex of <italic toggle="yes">R</italic> (which
happens to also be in <italic toggle="yes">T</italic>), i.e. the LCA-Mapping here applies to the
reconciled trees, not to the original gene tree <italic toggle="yes">T</italic>.</p>
      </statement>
    </sec>
  </sec>
  <sec>
    <title>3 A linear-time algorithm for the DLE-distance</title>
    <p>In this section, we consider a unitary cost <italic toggle="yes">c</italic> on DLE.</p>
    <p>Consider a <italic toggle="yes">given</italic> extension <inline-formula id="IE91"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">b</italic> to the internal nodes of
<italic toggle="yes">T</italic>. We first present an algorithm for computing a DLE-Reconciliation
<inline-formula id="IE92"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> of minimum cost, under the condition that <inline-formula id="IE93"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each <inline-formula id="IE94"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We will then show how a <inline-formula id="IE95"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> minimizing the DLE-Distance can be obtained.</p>
    <p><xref rid="btab328-BOX1" ref-type="boxed-text">Algorithm 1</xref> computes the
DLE-Reconciliation <inline-formula id="IE96"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> from the DL-Reconciliation <inline-formula id="IE97"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> (see <xref rid="btab328-F2" ref-type="fig">Fig. 2</xref> for
an example).</p>
    <fig position="float" id="btab328-F2">
      <label>Fig. 2.</label>
      <caption>
        <p>The tree <italic toggle="yes">R<sub>DL</sub></italic> up left, together with its node labeling, is
the optimal DL-Reconciliation for the gene tree <italic toggle="yes">T</italic> represented by the
plain edges of <italic toggle="yes">R<sub>DL</sub></italic> and the species tree <italic toggle="yes">S</italic>
up right. The two down trees are obtained by Algorithm 1 for two different
<inline-formula id="IE98"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> labeling of internal nodes: the left labeling is obtained
by the Fitch algorithm for weighted parsimony, while the right labeling is obtained by
applying Algorithm 2. The left labeling gives rise to a non-optimal reconciliation with
seven operations (two losses, one duplication, two EGTcopy and two EGTcut), while the
right labeling gives rise to the DLE-Distance which is equal to six (two losses, three
EGTcopy and one EGTcut). Rectangles represent duplications; triangles represent either
EGTcopy or EGTcut events depending whether the labeled node is binary or unary; dotted
lines represent losses; A leaf <italic toggle="yes">x<sub>i</sub></italic> represent a gene
<italic toggle="yes">x</italic> belonging to the genome <italic toggle="yes">i</italic> (0 for mitochondrial and
1 for nuclear) of species <italic toggle="yes">X</italic></p>
      </caption>
      <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btab328f2" position="float"/>
    </fig>
    <statement id="mthst3">
      <label>Lemma 2</label>
      <p>(Optimality of Algorithm 1). <italic toggle="yes">Given a binary assignment</italic> <inline-formula id="IE99"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">of the nodes of T, Algorithm 1 outputs a
DLE-Reconciliation</italic> <inline-formula id="IE100"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">of minimum cost with the constraint
that</italic> <inline-formula id="IE101"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">for</italic> <inline-formula id="IE102"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>It follows from <xref rid="mthst3" ref-type="statement">Lemma 2</xref> that if
<inline-formula id="IE103"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is known in advance for the nodes of <italic toggle="yes">T</italic>, a
DLE-Reconciliation of minimum cost is obtained from Algorithm 1 with <inline-formula id="IE104"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> as input. We now focus on finding such a labeling
<inline-formula id="IE105"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
    </statement>
    <statement id="mthst4">
      <label>Lemma 3</label>
      <p>(Necessary condition for <inline-formula id="IE106"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>) <italic toggle="yes">There exists a
DLE-Reconciliation</italic> <inline-formula id="IE107"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">of minimum cost DLE(T, S) such that, for any node x
of T and its children x<sub>l</sub> and x<sub>r</sub> in T</italic>, <inline-formula id="IE108"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">or</italic> <inline-formula id="IE109"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Proof.</p>
      <p>Assume <inline-formula id="IE110"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> is a most parsimonious DLE-Reconciliation with a lowest
node <italic toggle="yes">x</italic> not satisfying condition (1): <inline-formula id="IE111"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE112"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus we should have <inline-formula id="IE113"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Note that an EGTcut event must be present on at least one
of the <inline-formula id="IE114"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE115"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> branches. A reconciliation of lower or equal cost can be
obtained by assigning <inline-formula id="IE116"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and removing this EGTcut event, reducing the cost by one.
Let <italic toggle="yes">p<sub>x</sub></italic> be the parent of <italic toggle="yes">x</italic> in
<italic toggle="yes">R</italic> (note that if <italic toggle="yes">x</italic> is the root,
<italic toggle="yes">p<sub>x</sub></italic> might not exist, in which case there is nothing else to
do). If <inline-formula id="IE117"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is now different from <inline-formula id="IE118"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we add an EGTcut event between
<italic toggle="yes">p<sub>x</sub></italic> and <italic toggle="yes">x</italic>, yielding an alternate
reconciliation of equal or lower cost.</p>
      <p>We can reproduce the same transformation iteratively in a bottom-up fashion until
condition (1) is satisfied for every node. <sub><bold>□</bold></sub></p>
    </statement>
    <p>For a node <inline-formula id="IE119"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, define <italic toggle="yes">d</italic>(<italic toggle="yes">x</italic>) = 1 if
<italic toggle="yes">x</italic> is a duplication in the DL-Reconciliation of minimum cost, and
<italic toggle="yes">d</italic>(<italic toggle="yes">x</italic>) = 0 otherwise. Let <inline-formula id="IE120"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> be a binary labeling of
<italic toggle="yes">V</italic>(<italic toggle="yes">T</italic>). For any node <italic toggle="yes">x</italic> of
<italic toggle="yes">T</italic>, denote <inline-formula id="IE121"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE122"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, otherwis<italic toggle="yes"><sc>e</sc></italic><disp-formula id="E2"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>and define: <disp-formula id="E3"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
    <p>Roughly speaking, <inline-formula id="IE123"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> reflects the number of label changes between
<italic toggle="yes">x</italic> and its children <italic toggle="yes">x<sub>l</sub></italic> and
<italic toggle="yes">x<sub>r</sub></italic> in <italic toggle="yes">T</italic>, with the exception that a
duplication is allowed a ‘free’ change since it can be turned into an EGTcopy node. For
example, in <xref rid="btab328-F2" ref-type="fig">Figure 2</xref>, <inline-formula id="IE124"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> for the labeling <inline-formula id="IE125"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">T</italic> consistent with that of the left tree
<italic toggle="yes">R</italic> (Algo1+Fitch), and <inline-formula id="IE126"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for the labeling <inline-formula id="IE127"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">T</italic> consistent with that of the right tree
<italic toggle="yes">R</italic> (Algo1+Algo2), reflecting, for each one, the number of requested
EGTcut.</p>
    <p>
      <boxed-text id="btab328-BOX1" position="float">
        <caption>
          <title>
            <inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btab328ilf1.jpg"/>
          </title>
        </caption>
      </boxed-text>
    </p>
    <statement id="mthst5">
      <label>Lemma 4.</label>
      <p>
        <italic toggle="yes">The minimum cost of a DLE-Reconciliation between a gene tree T and a species tree
S is</italic>
        <disp-formula id="E4">
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi mathvariant="italic">DLE</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>T</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>S</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mi>D</mml:mi>
              <mml:mi>L</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>T</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>S</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>+</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mrow>
                    <mml:mi>min</mml:mi>
                  </mml:mrow>
                </mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>b</mml:mi>
                    <mml:mo>˜</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:msub>
              <mml:mi>c</mml:mi>
              <mml:mi mathvariant="italic">ost</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>T</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mi>S</mml:mi>
              <mml:mo>,</mml:mo>
              <mml:mrow>
                <mml:mover accent="true">
                  <mml:mi>b</mml:mi>
                  <mml:mo>˜</mml:mo>
                </mml:mover>
              </mml:mrow>
              <mml:mo stretchy="false">)</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>Proof. By <xref rid="mthst3" ref-type="statement">Lemma 2</xref>, Algorithm 1 correctly
infers a minimum cost DLE-Reconciliation for a given <inline-formula id="IE172"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. Note that this DLE-Reconciliation is obtained from a
DL-Reconciliation by turning some duplication nodes into EGTcopy nodes (which do not
change the cost), and by grafting some EGTcut nodes. Thus, the latter are responsible for
any possible change in cost from <italic toggle="yes">DL</italic>(<italic toggle="yes">T</italic>,
<italic toggle="yes">S</italic>) to <italic toggle="yes">DLE</italic>(<italic toggle="yes">T</italic>, <italic toggle="yes">S</italic>). It
follows that the cost of the returned DLE-Reconciliation is
<italic toggle="yes">DL</italic>(<italic toggle="yes">T</italic>, <italic toggle="yes">S</italic>), plus the number of grafted
EGTcut nodes.</p>
      <p>Let <inline-formula id="IE173"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> be a binary assignment of <italic toggle="yes">T</italic> that minimizes
<italic toggle="yes">DLE</italic>(<italic toggle="yes">T</italic>, <italic toggle="yes">S</italic>) when <inline-formula id="IE174"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is passed to Algorithm 1. By <xref rid="mthst4" ref-type="statement">Lemma 3</xref>, we may assume that for any node <italic toggle="yes">x</italic> and its
children <italic toggle="yes">x<sub>l</sub></italic> and <italic toggle="yes">x<sub>r</sub></italic>,
<inline-formula id="IE175"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE176"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus <inline-formula id="IE177"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> for every <italic toggle="yes">x</italic>. Furthermore, <inline-formula id="IE178"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if and only if <italic toggle="yes">x</italic> is a speciation node and
an EGTcut node is grafted on the edge <inline-formula id="IE179"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (if <inline-formula id="IE180"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) or on the edge <inline-formula id="IE181"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (if <inline-formula id="IE182"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). In consequence, <inline-formula id="IE183"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> counts exactly the number of graftings of EGTcut nodes.
<sub><bold>□ □</bold></sub></p>
    </statement>
    <p>Since the most-parsimonious DL-Reconciliation is unique, the
<italic toggle="yes">DL</italic>(<italic toggle="yes">T</italic>, <italic toggle="yes">S</italic>) term in the above lemma is an
invariant. Our goal is therefore to find the labeling <inline-formula id="IE184"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> that minimizes <inline-formula id="IE185"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    <p>This can be achieved by a slight modification of the <xref rid="btab328-B14" ref-type="bibr">Fitch (1971)</xref> algorithm (<xref rid="btab328-B14" ref-type="bibr">Fitch, 1971</xref>) computing, for a given tree with leaf labels, all possible label
assignments of internal nodes minimizing the number of label changes along the edges of the
tree. We first need to recall some concepts on parsimony. Given a tree <italic toggle="yes">T</italic> on
a leafset <italic toggle="yes">L</italic> of residues (generally nucleotides or amino-acids, but in this
article <inline-formula id="IE186"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM138" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> corresponding to the possible <inline-formula id="IE187"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> labeling), the <italic toggle="yes">weighted parsimony</italic> problem
consists in assigning a residue <inline-formula id="IE188"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM140" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula> to each internal node <italic toggle="yes">u</italic> of
<italic toggle="yes">T</italic> in a way minimizing the total weight of the tree. More precisely, given
a cost matrix <italic toggle="yes">M</italic> on residues, the weight of <italic toggle="yes">T</italic> is the sum of
weights <inline-formula id="IE189"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM141" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE190"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. An <italic toggle="yes">assignment of T</italic> refers to the assignment
of a residue to each internal node of <italic toggle="yes">T</italic>.</p>
    <p>The <xref rid="btab328-B27" ref-type="bibr">Sankoff and Cedergren (1983)</xref> algorithm
(<xref rid="btab328-B27" ref-type="bibr">Sankoff and Cedergren, 1983</xref>) allows to
compute, in quadratic time, the minimum cost <inline-formula id="IE191"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM143" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of an assignment of <italic toggle="yes">T</italic>. Moreover, it allows
to find all the assignments <inline-formula id="IE192"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM144" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>T</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">T</italic> leading to <inline-formula id="IE193"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. When <inline-formula id="IE194"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE195"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM147" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE196"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE197"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>≠</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>, weighted parsimony can be computed in linear time using the
Fitch algorithm.</p>
    <p>The Fitch algorithm consists of two phases. The first phase is recursive and reconstructs
possible ancestral labels <italic toggle="yes">L</italic>(<italic toggle="yes">x</italic>) for each node
<italic toggle="yes">x</italic> of <italic toggle="yes">T</italic> and the overall minimum number of label changes
required as follows: For each node <italic toggle="yes">x</italic> of <italic toggle="yes">T</italic> in a bottom-up
traversal, (1) if <italic toggle="yes">x</italic> is a leaf, then <inline-formula id="IE198"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE199"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM151" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. (2) Else, let <italic toggle="yes">x<sub>l</sub></italic> and
<italic toggle="yes">x<sub>r</sub></italic> be the children of <italic toggle="yes">x</italic>. If <inline-formula id="IE200"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM152" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE201"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM153" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE202"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM154" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>; else <inline-formula id="IE203"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM155" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE204"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM156" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The second phase of the algorithm reconstructs an assignment
<inline-formula id="IE205"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM157" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">T</italic> that has a minimum cost, by computing
<inline-formula id="IE206"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM158" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as follows: For each node <italic toggle="yes">x</italic> of
<italic toggle="yes">T</italic> in a top-down traversal, (1) if <italic toggle="yes">x</italic> is the root, assign
<inline-formula id="IE207"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM159" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to any label in <italic toggle="yes">L</italic>(<italic toggle="yes">x</italic>). (2)
Else, let <italic toggle="yes">x<sub>p</sub></italic> be the parent of <italic toggle="yes">x</italic>. If
<inline-formula id="IE208"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM160" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then assign <inline-formula id="IE209"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM161" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, else assign <inline-formula id="IE210"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM162" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to any label in <italic toggle="yes">L</italic>(<italic toggle="yes">x</italic>).</p>
    <p>The Fitch algorithm does not always find an optimal <inline-formula id="IE211"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM163" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> assignment because of duplications that can be turned into
EGTcopy events. <xref rid="btab328-BOX2" ref-type="boxed-text">Algorithm 2</xref> modifies
the first phase of the Fitch algorithm to compute the DLE-Distance and an assignment
<inline-formula id="IE212"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM164" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">T</italic> that leads to the DLE-Distance. The
modification reflects the fact that a duplication node is allowed a ‘free’ change since it
can be turned into an EGTcopy node (see <xref rid="btab328-F2" ref-type="fig">Fig. 2</xref>
for an illustration).</p>
    <p>
      <boxed-text id="btab328-BOX2" position="float">
        <caption>
          <title>
            <inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btab328ilf2.jpg"/>
          </title>
        </caption>
      </boxed-text>
    </p>
    <statement id="mthst6">
      <label>Lemma 5.</label>
      <p><italic toggle="yes">Algorithm 2 outputs, in linear time, the DLE-Distance DLE(T, S) and a binary
assignment</italic> <inline-formula id="IE231"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM165" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula><italic toggle="yes">of T that leads to a most parsimonious
DLE-Reconciliation.</italic></p>
      <p>Proof. It suffices to prove that the following statement holds for any node
<italic toggle="yes">x</italic> of <italic toggle="yes">T</italic>: for any label
<bold><sub><italic toggle="yes">β</italic></sub></bold> in <italic toggle="yes">L</italic>(<italic toggle="yes">x</italic>),
there exists a binary assignment <inline-formula id="IE232"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM166" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE233"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM167" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE234"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM168" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE235"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM169" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> minimizes <inline-formula id="IE236"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM170" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <list list-type="order"><list-item><p>If <inline-formula id="IE257"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM171" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE258"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM172" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE259"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM173" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Thus <inline-formula id="IE260"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM174" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, without any increment.</p></list-item><list-item><p>If <inline-formula id="IE261"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM175" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>∈</mml:mo></mml:menclose><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE262"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM176" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE263"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM177" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE264"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM178" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE265"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM179" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE266"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM180" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Thus <inline-formula id="IE267"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM181" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, without any increment.</p><p>In both cases, Algorithm 1 computes a DLE-Reconciliation with minimum cost
<inline-formula id="IE268"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM182" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">DLE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">DLE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> with a minimum increment of 1 for a Dup node in case
(1), or by making <italic toggle="yes">x</italic> an EGTcopy node in case (2), but no additional
EGTcut node is required.</p></list-item><list-item><p>If <italic toggle="yes">x</italic> is a speciation node in the DL-reconciliation. </p></list-item></list></p>
      <p>
        <list list-type="order">
          <list-item>
            <p>If <inline-formula id="IE269"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM183" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE270"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM184" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE271"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM185" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE272"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM186" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. So <inline-formula id="IE273"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM187" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE274"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM188" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE275"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM189" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Thus <inline-formula id="IE276"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM190" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, with a minimum increment of 1, obtained by grafting
an EGTcut node on one of the <inline-formula id="IE277"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM191" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE278"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM192" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> branches. In this case, Algorithm 1 computes a
DLE-Reconciliation with minimum cost <inline-formula id="IE279"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM193" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">DLE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">DLE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
          </list-item>
          <list-item>
            <p>If <inline-formula id="IE280"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM194" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE281"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM195" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE282"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM196" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. So <inline-formula id="IE283"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM197" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE284"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM198" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Δ</mml:mo></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Thus <inline-formula id="IE285"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM199" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">cost</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> without any additional cost. Algorithm 1 computes a
DLE-Reconciliation with minimum cost <inline-formula id="IE286"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM200" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">DLE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">DLE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> when given <inline-formula id="IE287"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM201" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
          </list-item>
        </list>
      </p>
      <p>It is easy to see that both the first and the second phases of the algorithm have linear
time complexity, thus the overall algorithm has a linear time complexity.
<sub><bold>□</bold></sub></p>
    </statement>
    <p>As for the Fitch Algorithm, Algorithm 2 does not allow to output all the solutions of the
DL<sc>E-</sc>Reconciliation problem leading to the DLE-Distance. However, this can be
achieved by adapting the Sankoff and Cedergren’s dynamic programming algorithm. Rather, we
choose to introduce, in the next section, a more general dynamic programming algorithm
allowing to output all optimal solutions for an arbitrary cost of the DLE events, not only
for the unitary cost.</p>
  </sec>
  <sec>
    <title>4 Solving the DLE-reconciliation problem with arbitrary DLE costs</title>
    <p>We now introduce a dynamic programming algorithm for general costs. We use
<bold><sub><italic toggle="yes">δ</italic></sub></bold> and
<bold><sub><italic toggle="yes">λ</italic></sub></bold> to denote the cost of a duplication and a loss,
respectively. We use <bold><sub><italic toggle="yes">ρ</italic></sub></bold><sub>0</sub> (respectively
<bold><sub><italic toggle="yes">τ</italic></sub></bold><sub>0</sub>) for the cost of an EGTcut
(respectively EGTcopy) from the mitochondrial genome to the nuclear genome, and
<bold><sub><italic toggle="yes">ρ</italic></sub></bold><sub>1</sub> (respectively
<bold><sub><italic toggle="yes">τ</italic></sub></bold><sub>1</sub>) for the cost of an EGTcut
(respectively EGTcopy) from the nuclear genome to the mitochondrial genome. Note that the
subscripts of the EGT costs indicate the source of the switch. Also
denot<italic toggle="yes"><sc>e</sc></italic><disp-formula id="E5"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>0</mml:mn><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>1</mml:mn><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
    <p>Roughly speaking, <inline-formula id="IE288"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM202" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>0</mml:mn><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> represents the minimum cost required to switch from
mitochondrial to nuclear genome inside a branch of <italic toggle="yes">T</italic>, and <inline-formula id="IE289"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM203" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>1</mml:mn><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> the minimum cost required in the other direction. The purpose
of <inline-formula id="IE290"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM204" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>0</mml:mn><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE291"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM205" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>1</mml:mn><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> is that a switch can be accomplished by an EGTcut event, but
also by an EGTcopy event followed by a loss.</p>
    <p>Let <inline-formula id="IE292"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM206" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Note that <inline-formula id="IE293"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM207" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> does not need to be inferred, since by <xref rid="mthst2" ref-type="statement">Lemma 1</xref>, we can assume that <inline-formula id="IE294"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM208" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Our dynamic programming table only needs to store the
optimal cost on <inline-formula id="IE295"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM209" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for each possible <inline-formula id="IE296"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM210" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. This requires testing each of three possible events
<inline-formula id="IE297"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM211" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> at <italic toggle="yes">x</italic>, and the number of scenarios to
consider at <italic toggle="yes">x</italic> is therefore constant [this is the main reason for the gain
in time compared to the algorithm of <xref rid="btab328-B10" ref-type="bibr">Doyon
<italic toggle="yes">et al.</italic> (2010)</xref>, which requires adding a dimension to the table
corresponding to all possible species at <italic toggle="yes">x</italic>]. Let <inline-formula id="IE298"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM212" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. We denote by <inline-formula id="IE299"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM213" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> the minimum cost of a <italic toggle="yes">DLE</italic>-Reconciliation
<inline-formula id="IE300"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM214" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE301"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM215" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> with <italic toggle="yes">S</italic> in which <inline-formula id="IE302"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM216" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (or <inline-formula id="IE303"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM217" display="inline" overflow="scroll"><mml:mo>∞</mml:mo></mml:math></inline-formula> if no such reconciliation exists). Trivially, if
<italic toggle="yes">x</italic> is a leaf of <italic toggle="yes">T</italic>, we
hav<italic toggle="yes"><sc>e</sc></italic><disp-formula id="E6"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mo>∞</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
    <p>Assume now that <italic toggle="yes">x</italic> is an internal node of <italic toggle="yes">T</italic>. Let
<italic toggle="yes">x<sub>l</sub></italic>, <italic toggle="yes">x<sub>r</sub></italic> be the children of
<italic toggle="yes">x</italic>. For <inline-formula id="IE304"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM218" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, let <inline-formula id="IE305"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM219" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">path</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denote the number of vertices on the path between
<italic toggle="yes">s</italic><sub>1</sub> and <italic toggle="yes">s</italic><sub>2</sub> in <italic toggle="yes">S</italic>,
<italic toggle="yes">including s</italic><sub>1</sub> and <italic toggle="yes">s</italic><sub>2</sub>. Then
defin<italic toggle="yes"><sc>e</sc></italic><disp-formula id="E7"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="italic">path</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">path</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>which counts the number of mandatory losses on the child
branches of a node <italic toggle="yes">x</italic> of <italic toggle="yes">T</italic>.</p>
    <p>To compute <inline-formula id="IE306"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM220" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, we use three auxiliary values <inline-formula id="IE307"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM221" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE308"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM222" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> represents the event label of <italic toggle="yes">x</italic> (note that
<italic toggle="yes">e<sub>x</sub></italic> cannot be an EGTcut event, since <italic toggle="yes">x</italic> has
two children).</p>
    <p>If <inline-formula id="IE309"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM223" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE310"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM224" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE311"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM225" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal">S</mml:mi><mml:mi>p</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>∞</mml:mo></mml:mrow></mml:math></inline-formula>. Assuming this check has been performed, we
hav<italic toggle="yes"><sc>e</sc></italic><disp-formula id="E8"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal">S</mml:mi><mml:mi>p</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal">D</mml:mi><mml:mi>u</mml:mi><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>δ</mml:mo><mml:mo>+</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo> </mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>EGTcopy</mml:mtext><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>min</mml:mi><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
    <p>Put <inline-formula id="IE312"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM226" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The value of interest is <inline-formula id="IE313"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM227" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.<statement id="mthst7"><label>Theorem 1.</label><p><italic toggle="yes">For any</italic> <inline-formula id="IE314"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM228" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE315"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM229" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">, the value of</italic> <inline-formula id="IE316"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM230" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">, as defined above, is equal to the minimum cost
of a DLE-Reconciliation</italic> <inline-formula id="IE317"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM231" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">of</italic> <inline-formula id="IE318"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM232" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">with S satisfying</italic> <inline-formula id="IE319"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM233" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p><p><italic toggle="yes">Moreover, the minimum cost</italic> <inline-formula id="IE320"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM234" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">of a reconciliation of T with S can be computed in
time</italic> <inline-formula id="IE321"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM235" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement></p>
    <p>Let us note that once the <italic toggle="yes">D</italic> table is computed, a standard backtracking
procedure allow to reconstruct every optimal DLE-Reconciliation.</p>
  </sec>
  <sec>
    <title>5 Experimental results</title>
    <p>We implemented the above dynamic programming procedure in python in a software called
EndoRex, which supports arbitrary costs as input and returns a reconciled gene tree in
Newick format. The python source can be accessed at <ext-link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://github.com/AEVO-lab/EndoRex" ext-link-type="uri">https://github.com/AEVO-lab/EndoRex</ext-link>. We then performed a variety of
experiments on a dataset obtained from (<xref rid="btab328-B22" ref-type="bibr">Kannan
<italic toggle="yes">et al.</italic>, 2014</xref>), as described bellow.</p>
    <sec>
      <title>5.1 Kannan <italic toggle="yes">et al.</italic> (2014) dataset</title>
      <p>For the reconstruction of evolutionary histories with EGT events, we used a dataset from
Kannan <italic toggle="yes">et al.</italic> (2014) available at
ftp://ftp.ncbi.nih.gov/pub/koonin/MitoCOGs. The dataset consists of 140 MitoCOGs extended
with paralogs and nuclear protein-coding homologs from 2486 eukaryotes with complete
mitochondrial genomes. MitoCOGs are clusters of orthologous genes for
mitochondrial-encoded proteins generated using COG construction (<xref rid="btab328-B24" ref-type="bibr">Makarova et al., 2007</xref>; <xref rid="btab328-B33" ref-type="bibr">Yutin et al., 2009</xref>). Full description of the MitoCOG generation procedure is
described in Kannan <italic toggle="yes">et al.</italic> (2014). Among the 140 MitoCOGs, 73 correspond
to protein-coding gene families, 49 are hypothetical proteins and 18 are clusters for
which the protein function is identified but not the gene name. Among these 73 MitoCOGs,
13 are core-mitochondrial proteins that are shared by most of the 2486 mitochondrial
genomes. Statistics on MitoCOGs of the Kannan <italic toggle="yes">et al.</italic> dataset are given in
<xref rid="btab328-T1" ref-type="table">Table 1</xref>.</p>
      <table-wrap position="float" id="btab328-T1">
        <label>Table 1.</label>
        <caption>
          <p>Statistics on the Kannan <italic toggle="yes">et al.</italic> (2014) dataset</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Gene set</th>
              <th rowspan="1" colspan="1">Nb of MitoCOGs</th>
              <th rowspan="1" colspan="1">Nb of species</th>
              <th rowspan="1" colspan="1">Nb of genes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Mitochondrial-encoded</td>
              <td rowspan="1" colspan="1">140</td>
              <td rowspan="1" colspan="1">2486</td>
              <td rowspan="1" colspan="1">34 755</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Nuclear-encoded</td>
              <td rowspan="1" colspan="1">45</td>
              <td rowspan="1" colspan="1">52</td>
              <td rowspan="1" colspan="1">1317</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Whole set</td>
              <td rowspan="1" colspan="1">140</td>
              <td rowspan="1" colspan="1">2486</td>
              <td rowspan="1" colspan="1">36 072</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: Notice that MitoCOGs have been designed for
mitochondrial-encoded genes, and nuclear-encoded genes have been included later.
This explains why all nuclear-encoded MitoCOGs, and the corresponding species, are
included in the mitochondrial-encoded sets of MitoCOGs and species.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>5.2 Dataset preprocessing</title>
      <p>Among the 140 MitoCOGs of the initial Kannan <italic toggle="yes">et al.</italic> dataset, we first
selected the 45 clusters involving nuclear-encoded protein sequences. Within these
MitoCOGs, 52 eukaryotes are represented including 28 <italic toggle="yes">Opisthokonta</italic> (10
<italic toggle="yes">Fungi</italic>, 17 <italic toggle="yes">Metazoa</italic> and 1
<italic toggle="yes">Choanoflagellata</italic>), 9 <italic toggle="yes">Viridiplantae</italic>, 1
<italic toggle="yes">Rhodophyta</italic>, 1 <italic toggle="yes">Glaucophyta</italic>, 5
<italic toggle="yes">Alveolata</italic>, 1 <italic toggle="yes">Amoebozoa</italic>, 2 <italic toggle="yes">Euglenozoa</italic>,
1 <italic toggle="yes">Heterolobosea</italic>, 1 <italic toggle="yes">Rhizaria</italic> and 3
<italic toggle="yes">Stramenopiles</italic>. Based on <xref rid="btab328-F1" ref-type="fig">Figure 1</xref> in Kannan <italic toggle="yes">et al.</italic> (2014) and the analysis of the
dataset, for the EGT evolutionary history inference with EndoRex, we selected the 11 plant
species, including the 9 <italic toggle="yes">Viridiplantae</italic>, <italic toggle="yes">Cyanidioschyzon
merolae</italic> (<italic toggle="yes">Rhodophyta</italic>) and <italic toggle="yes">Cyanophora paradoxa</italic>
(<italic toggle="yes">Glaucophyta</italic>), as gene-content location is more diversified among this
species group.</p>
      <p>The 11 plant species are represented in 68 MitoCOGs with mitochondrial-encoded proteins
and 41 MitoCOGs with nuclear-encoded proteins. We selected the clusters for which there
were mitochondrial and nuclear encoded genes, yielding 28 MitoCOGS containing 326
protein-coding genes, including 184 encoded in the mitochondria and 142 in the nucleus.
All the 28 MitoCOGs correspond to gene names that are present in the mitochondrial gene
content review of <xref rid="btab328-B28" ref-type="bibr">Sloan <italic toggle="yes">et al.</italic>
(2018)</xref>.</p>
      <p><xref rid="btab328-T2" ref-type="table">Table 2</xref> gives information about the 28
MitoCOGs of the 11 plants dataset specifying the gene name, the protein metabolic pathway
and the number of genes and species for each MitoCOG.</p>
      <table-wrap position="float" id="btab328-T2">
        <label>Table 2.</label>
        <caption>
          <p>Statistics on the 28 MitoCOGs of the 11 plants dataset</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="(" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">MitoCOG</th>
              <th rowspan="1" colspan="1">Gene</th>
              <th rowspan="1" colspan="1">Metabolic</th>
              <th rowspan="1" colspan="1">Nb of genes</th>
              <th rowspan="1" colspan="1">Nb of</th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">ID</th>
              <th rowspan="1" colspan="1">name</th>
              <th rowspan="1" colspan="1">pathway</th>
              <th rowspan="1" colspan="1">(mito+nuc)</th>
              <th rowspan="1" colspan="1">species</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0006</td>
              <td rowspan="1" colspan="1">nad3</td>
              <td rowspan="1" colspan="1">Complex I</td>
              <td rowspan="1" colspan="1">11 (10 + 1)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0007</td>
              <td rowspan="1" colspan="1">nad4L</td>
              <td rowspan="1" colspan="1">Complex I</td>
              <td rowspan="1" colspan="1">13 (12 + 1)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0031</td>
              <td rowspan="1" colspan="1">nad7</td>
              <td rowspan="1" colspan="1">Complex I</td>
              <td rowspan="1" colspan="1">11 (9 + 2)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0043</td>
              <td rowspan="1" colspan="1">nad9</td>
              <td rowspan="1" colspan="1">Complex I</td>
              <td rowspan="1" colspan="1">11 (9 + 2)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0029</td>
              <td rowspan="1" colspan="1">nad10</td>
              <td rowspan="1" colspan="1">Complex I</td>
              <td rowspan="1" colspan="1">13 (1 + 12)</td>
              <td rowspan="1" colspan="1">10</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0052</td>
              <td rowspan="1" colspan="1">sdh2</td>
              <td rowspan="1" colspan="1">Complex II</td>
              <td rowspan="1" colspan="1">22 (1 + 21)</td>
              <td rowspan="1" colspan="1">10</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0051</td>
              <td rowspan="1" colspan="1">sdh3</td>
              <td rowspan="1" colspan="1">Complex II</td>
              <td rowspan="1" colspan="1">8 (3 + 5)</td>
              <td rowspan="1" colspan="1">6</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0075</td>
              <td rowspan="1" colspan="1">sdh4</td>
              <td rowspan="1" colspan="1">Complex II</td>
              <td rowspan="1" colspan="1">9 (4 + 5)</td>
              <td rowspan="1" colspan="1">9</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0003</td>
              <td rowspan="1" colspan="1">cox2</td>
              <td rowspan="1" colspan="1">Complex IV</td>
              <td rowspan="1" colspan="1">13 (10 + 3)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0005</td>
              <td rowspan="1" colspan="1">cox3</td>
              <td rowspan="1" colspan="1">Complex IV</td>
              <td rowspan="1" colspan="1">13 (10 + 3)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0059</td>
              <td rowspan="1" colspan="1">atp1</td>
              <td rowspan="1" colspan="1">Complex V</td>
              <td rowspan="1" colspan="1">9 (7 + 2)</td>
              <td rowspan="1" colspan="1">8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0076</td>
              <td rowspan="1" colspan="1">atp4</td>
              <td rowspan="1" colspan="1">Complex V</td>
              <td rowspan="1" colspan="1">12 (11 + 1)</td>
              <td rowspan="1" colspan="1">10</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0004</td>
              <td rowspan="1" colspan="1">atp6</td>
              <td rowspan="1" colspan="1">Complex V</td>
              <td rowspan="1" colspan="1">13 (12 + 1)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0014</td>
              <td rowspan="1" colspan="1">atp9</td>
              <td rowspan="1" colspan="1">Complex V</td>
              <td rowspan="1" colspan="1">13 (10 + 3)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0027</td>
              <td rowspan="1" colspan="1">rpl2</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">14 (5 + 9)</td>
              <td rowspan="1" colspan="1">10</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0053</td>
              <td rowspan="1" colspan="1">rpl6</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">10 (4 + 6)</td>
              <td rowspan="1" colspan="1">8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0092</td>
              <td rowspan="1" colspan="1">rpl10</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">5 (2 + 3)</td>
              <td rowspan="1" colspan="1">5</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0048</td>
              <td rowspan="1" colspan="1">rpl14</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">15 (5 + 10)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0039</td>
              <td rowspan="1" colspan="1">rpl16</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">12 (8 + 4)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0070</td>
              <td rowspan="1" colspan="1">rpl20</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">11 (2 + 9)</td>
              <td rowspan="1" colspan="1">8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0080</td>
              <td rowspan="1" colspan="1">rps2</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">9 (5 + 4)</td>
              <td rowspan="1" colspan="1">9</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0067</td>
              <td rowspan="1" colspan="1">rps4</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">8 (7 + 1)</td>
              <td rowspan="1" colspan="1">7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0061</td>
              <td rowspan="1" colspan="1">rps7</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">12 (8 + 4)</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0072</td>
              <td rowspan="1" colspan="1">rps10</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">12 (3 + 9)</td>
              <td rowspan="1" colspan="1">8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0054</td>
              <td rowspan="1" colspan="1">rps11</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">12 (6 + 6)</td>
              <td rowspan="1" colspan="1">10</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0064</td>
              <td rowspan="1" colspan="1">rps13</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">10 (7 + 3)</td>
              <td rowspan="1" colspan="1">10</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0055</td>
              <td rowspan="1" colspan="1">rps14</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">9 (5 + 4)</td>
              <td rowspan="1" colspan="1">8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">MitoCOG0026</td>
              <td rowspan="1" colspan="1">rps19</td>
              <td rowspan="1" colspan="1">Translation</td>
              <td rowspan="1" colspan="1">16 (8 + 8)</td>
              <td rowspan="1" colspan="1">8</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic toggle="yes">Note</italic>: For the ‘Nb of gene’ column, the number of
mitochondria-encoded (mito) and nucleus-encoded (nuc) gene are specified.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>For each MitoCOG, we applied a pipeline to infer the evolutionary history of EGTs with
DLE-Reconciliation along the 11 plants species tree. The topology of the species tree was
taken from Kannan <italic toggle="yes">et al.</italic> (2014). We added the species <italic toggle="yes">Micromonas
sp. RCC299</italic> as the sister species of <italic toggle="yes">Ostreococcus tauri</italic> as only
these 2 among the 11 plants species belong to the <italic toggle="yes">Mamiellophyceae</italic> class.
We also swapped the position between <italic toggle="yes">P. patens</italic> and <italic toggle="yes">S.
moellendorffi</italic> according to (<xref rid="btab328-B25" ref-type="bibr">Puttick et
al., 2018</xref>) (<xref rid="btab328-F3" ref-type="fig">Fig. 3</xref>).</p>
      <fig position="float" id="btab328-F3">
        <label>Fig. 3.</label>
        <caption>
          <p>Species tree of the 11 plants considered in our experimental analysis. Topology of
the tree is based on (<xref rid="btab328-B22" ref-type="bibr">Kannan <italic toggle="yes">et
al.</italic>, 2014</xref>)</p>
        </caption>
        <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btab328f3" position="float"/>
      </fig>
      <p>As for constructing gene trees, the first step of the pipeline was to align the protein
sequences with MUSCLE (<xref rid="btab328-B12" ref-type="bibr">Edgar, 2004</xref>). In the
second step, a maximum likelihood protein tree was infered using RAxML (v8.2.4) with the
PROTGAMMAGTRX evolutionary model (<xref rid="btab328-B29" ref-type="bibr">Stamatakis
<italic toggle="yes">et al.</italic>, 2014</xref>). NOTUNG (v.2.9.1.5) was then used to root the
trees by minimizing the cost of a duplication-loss reconciliation with default parameter
(loss cost: 1.0 and duplication cost: 1.5) (<xref rid="btab328-B30" ref-type="bibr">Stolzer et al., 2012</xref>).</p>
      <p>The rooted protein trees obtained with this pipeline and the 11 plants species tree were
given as input of the EndoRex software to infer a most parsimonious DLE-Reconciliation
allowing for arbitrary costs for duplications, losses and EGTs.</p>
    </sec>
    <sec>
      <title>5.3 EndoRex evolutionary events cost setting</title>
      <p>As a reminder, we consider six parameters corresponding to the different evolutionary
event costs: <bold><sub><italic toggle="yes">δ</italic></sub></bold> and
<bold><sub><italic toggle="yes">λ</italic></sub></bold> the cost of, respectively, a gene
duplication and loss; <bold><sub><italic toggle="yes">ρ</italic></sub></bold><sub>0</sub> (respectively
<bold><sub><italic toggle="yes">τ</italic></sub></bold><sub>0</sub>) the cost of an EGTcut
(respectively EGTcopy) from the mitochondrial genome to the nuclear genome, and
<bold><sub><italic toggle="yes">ρ</italic></sub></bold><sub>1</sub> (respectively
<bold><sub><italic toggle="yes">τ</italic></sub></bold><sub>1</sub>) the cost of an EGTcut
(respectively EGTcopy) from the nuclear genome to the mitochondrial genome.</p>
      <p>We test five different cost settings for the application of EndoRex on the 11 plants
dataset. The setting <italic toggle="yes">S</italic>1 corresponds to the default values for parameters,
with a unitary cost for evolutionary events (allowing to compute the DLE-Distance). For
setting <italic toggle="yes">S</italic>2, the gene loss and duplication costs are those used in NOTUNG
for rooting the protein trees, and EGTcopy and EGTcut costs are set higher to reflect the
fact that these evolutionary events are less frequent than gene duplications:
<inline-formula id="IE322"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM236" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo>=</mml:mo><mml:mn>1.0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>δ</mml:mo><mml:mo>=</mml:mo><mml:mn>1.5</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE323"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM237" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>2.0</mml:mn></mml:mrow></mml:math></inline-formula>. In setting <italic toggle="yes">S</italic>3, we consider EGTcopy as
less likely than EGTcut: <inline-formula id="IE324"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM238" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo>=</mml:mo><mml:mn>1.0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>δ</mml:mo><mml:mo>=</mml:mo><mml:mn>1.5</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>2.0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE325"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM239" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>3.0</mml:mn></mml:mrow></mml:math></inline-formula>. For setting <italic toggle="yes">S</italic>4, we differentiate the cost
of the mitochondria to the nucleus from the nucleus to the mitochondria gene move, and
account for the fact that, during the evolution of eukaryotes, mitochondrial genes are
integrated into the nuclear genome, while the reverse is extremely rare: <inline-formula id="IE326"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM240" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo>=</mml:mo><mml:mn>1.0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>δ</mml:mo><mml:mo>=</mml:mo><mml:mn>1.5</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>2.0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>3.0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>3.0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE327"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM241" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>4.0</mml:mn></mml:mrow></mml:math></inline-formula>. Finally, setting <italic toggle="yes">S</italic>5 is the same as
setting <italic toggle="yes">S</italic>4 except we make no difference between the costs of EGTcopy and
EGTcut events: <inline-formula id="IE328"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM242" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo>=</mml:mo><mml:mn>1.0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>δ</mml:mo><mml:mo>=</mml:mo><mml:mn>1.5</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>2.0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>3.0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>2.0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE329"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM243" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>3.0</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      <p>Applied to the 28 MitoCOGs trees, EndoRex infers the same DLE-Reconciliation with the
five different settings for 21 of the 28 MitoCOGs.</p>
      <p>All the seven MitoCOGs with more that one inferred DLE-Reconciliation, depending on the
considered setting, lead to two different DLE-Reconciliations: for MitoCOG0014,
MitoCOG0051 and MitoCOG0053, setting <italic toggle="yes">S</italic>1 gives a DEL-reconciliation
different from the other settings; for MitoCOG0027, it is setting <italic toggle="yes">S</italic>3 that
gives a different DEL-reconciliation; for MitoCOG0005 and MitoCOG0039, it is setting
<italic toggle="yes">S</italic>4; and finally for MitoCOG0072, the settings <italic toggle="yes">S</italic>4 ans
<italic toggle="yes">S</italic>5 give a DEL-reconciliation different from <italic toggle="yes">S</italic>1,
<italic toggle="yes">S</italic>2 and <italic toggle="yes">S</italic>3. We analyzed the two DLE-Reconciliations of
MitoCOG0014 (<italic toggle="yes">atp9</italic>), MitoCOG0027 (<italic toggle="yes">rpl2</italic>), MitoCOG0039
(<italic toggle="yes">rpl16</italic>) and MitoCOG0072 (<italic toggle="yes">rps10</italic>) to illustrate the
dynamic of the score settings (see <xref rid="btab328-F4" ref-type="fig">Fig. 4</xref>).</p>
      <fig position="float" id="btab328-F4">
        <label>Fig. 4.</label>
        <caption>
          <p>DLE-Reconciliations obtained for MitoCOG0014, MitoCOG0027, MitoCOG0039 and
MitoCOG0072 with the EndoRex scores settings <italic toggle="yes">S</italic>1, <italic toggle="yes">S</italic>2,
<italic toggle="yes">S</italic>3, <italic toggle="yes">S</italic>4 and <italic toggle="yes">S</italic>5. The blue part of
the tree indicates that the genetic material is located in the mitochondrion, while
the red part indicates location in the nucleus. The shape of an internal node
represents its associated event, as represented in <xref rid="btab328-F1" ref-type="fig">Figure 1</xref> (circle for a speciation, rectangle for a
duplication and triangle for an EGT event). Loss events are not represented. Genes are
formatted as follow: [species name]__[gene-encoding location]__[gene id]. Moreover, 0
indicates a location in the mitochondrion, while 1 indicates a location in the
nucleus</p>
        </caption>
        <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btab328f4" position="float"/>
      </fig>
      <p>According to these case studies, it seems that setting <italic toggle="yes">S</italic>1 is
inappropriate as it leads to the prediction of higher number of EGTs which are rare
evolutionary events (see MitoCOG0014 in <xref rid="btab328-F4" ref-type="fig">Fig. 4, and
M</xref>itoCOGs 51 and 53 in Appendix <xref rid="btab328-F1" ref-type="fig">Fig.
A1</xref>). For MitoCOG0027, setting <italic toggle="yes">S</italic>3 leads to the prediction of
numerous EGTs from the nucleus to the mitochondria, which is very unrealistic as a very
few number of gene movements from the nucleus to the mitochondria have been described in
the literature. DLE-Reconciliations predicted with setting <italic toggle="yes">S</italic>4 are the
scenarii most in line with the literature as it only infers EGTs from the mitochondria to
the nucleus (except for MitoCOG0072), with transpositions located close to the leaves of
the tree, indicating an ongoing process of endosymbiotic gene transfer in plants for this
gene family (see MitoCOGs 39 and 72 in <xref rid="btab328-F4" ref-type="fig">Fig. 4, and
M</xref>itoCOG0005 in Appendix <xref rid="btab328-F1" ref-type="fig">Fig.
A1</xref>).</p>
    </sec>
  </sec>
  <sec>
    <title>6 Conclusion</title>
    <p>Investigating the origin, evolution and characteristics of gene coding capacity of
eukaryotes has been among the central themes in the Life Sciences. In this context, the
endosymbiotic origin of mitochondrial genomes and the gradual integration of the
mitochondrial gene content to the nucleus are important evolutionary parameters expected to
shed light on features of eukaryotic gene evolution and function.</p>
    <p>From a computational point of view, detecting the footprint of endosymbiosis in the gene
repertoires of the mitochondrial and nuclear genomes of eukaryotes requires new evolutionary
prediction methods. This article is a first effort toward developing the appropriate
algorithmic tools for analyzing the movement of genes inside a gene family between the
mitochondrial and nuclear genome of the same species. We presented a linear-time algorithm
computing a most parsimonious history of Duplication, Loss and EGT (DLE) events explaining a
gene tree with leaves identified as mitochondrial or nuclear genes. We also presented a
general dynamic programming algorithm, implemented in the EndoRex software, to compute all
optimal DLE-Reconciliations for any arbitrary cost scheme of operations.</p>
    <p>By applying EndoRex to a plant dataset, we showed that it is well-designed to infer the
evolutionary histories of EGT events, considering a variety of cost settings. Some
reconciled trees (not shown) of the 11 plants dataset produced evolutionary histories that
could be considered unrealistic as leading to an unexpected high number of gene duplications
and losses. As our algorithm is exact and thus guaranteed to infer the minimum number of
events given a gene tree, this is likely due to errors in protein sequence alignment and/or
gene tree inference, leading to erroneous gene trees (<xref rid="btab328-B17" ref-type="bibr">Hahn, 2007</xref>). A better gene tree inference pipeline should be
designed in the future to get more accurate gene trees. In particular, gene trees have been
rooted according to the DL-distance and standing on the default NOTUNG parameters. Instead,
we could have rooted the trees according to our DLE-model, with the 5 considered cost
settings. In addition, the obtained RAxML binary gene trees contain many weakly supported
edges. Those edges may be contracted, and a polytomy resolution tool such as PolytomySolver
(<xref rid="btab328-B20" ref-type="bibr">Lafond et al., 2016</xref>) may be used to better
resolve multifurcations. On the other hand, simulations studies should also be conducted, in
the future, to better evaluate the quality of the obtained solutions.</p>
    <p>In fact, our method relies on a deterministic parsimony approach to compute all optimal
DLE-reconciliations given a cost scheme for DLE events. This model has many limitations. In
particular, parsimony does not allow to model multiple state changes along a branch of the
phylogeny, or uncertainty in phylogenetic reconstructions. An alternative is to rely on
approaches using stochastic state mapping models such as the mutational mapping approach
(<xref rid="btab328-B4" ref-type="bibr">Bollback, 2006</xref>; <xref rid="btab328-B18" ref-type="bibr">Huelsenbeck et al., 2003</xref>). Since our method outputs all optimal
DLE-reconciliations, it can also be used to compute the probabilities of all possible events
over all optimal solutions.</p>
    <p>Future algorithmic extensions of the optimization problem considered in this article may
concern extending the model to account for both EGT and HGT events, toward inferring a
Duplication, HGT, loss and EGT (DTLE) evolutionary scenario for a gene family. Another
direction would be to infer common episodes of EGT events for a set of gene families. This
may be handled by generalizing the Super-Reconciliation (<xref rid="btab328-B9" ref-type="bibr">Delabre et al., 2020</xref>) model to account for segmental DLE
events.</p>
    <p>Future developments will define an EGT simulation model to provide EGT evolutionary
histories to assess the accuracy of our algorithm. Some efforts have been made to provide
EGT simulation model. <xref rid="btab328-B5" ref-type="bibr">Brandvain and Wade
(2009)</xref> provides a model to explore the influence of population-genetic parameters
(such as selection, dominance, mutation rates and population size with a rate of
self-fertilization) on the rate and probability of functional gene transfer from
mitochondrial genome (haploid) to nuclear genome (diploid). (<xref rid="btab328-B19" ref-type="bibr">Kelly, 2020</xref>) defines an EGT simulation model based on the ATP
biosynthesis cost for the encoding of a mitochondrial/chloroplast gene in the nuclear genome
and the import of the resulting in the organelle. These prior works provide useful insights
to design a model for the simulation of EGT evolutionary histories that would be strongly
inspired from existing model for the simulation of HGT evolutionary histories.</p>
    <p>Future applications will also concern a thorough analysis of protein-coding genes involved
in common metabolic pathways. As an example, the oxydative phophorylation (OXPHOS) is a
series of protein complexes (I, II, III, IV and V) leading to an electrochemical proton
gradient activating the ATP synthase (complex V) that produces ATP. These protein-coding
genes involved in OXPHOS are expected to share common mitochondrial-nuclear movements, as
nucleus and mitochondria are two compartments with different biological dynamics.</p>
    <p>Finally, the recent sequencing effort conducted toward jakobids and malawimonads protists
genomes known to have emerged close to the eukaryotic origin will provide a valuable dataset
that can be analyzed with the new developed algorithms, helping to shed light on a number of
important biological questions, among them resolving the root of the eukaryote tree. In
fact, as EGTs are rare events, candidate topologies for which DLE-Reconciliations infer the
lowest number of EGT events, may provide evidence for a correct rooting.</p>
    <p><italic toggle="yes">Financial Support</italic>: Natural Sciences and Engineering Research Council of
Canada;Fonds de recherche Nature et Technologie, Québec.</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank B. Franz Lang (Biochemistry Department, University of Montreal) for his
insights and clever advices on the algorithmic needs and open questions regarding
eukaryotes’ evolution.</p>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btab328-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Adams</surname><given-names>K.L.</given-names></string-name>, <string-name><surname>Palmer</surname><given-names>J.D.</given-names></string-name></person-group>
(<year>2003</year>) <article-title>Evolution of mitochondrial gene content: gene loss
and transfer to the nucleus</article-title>. <source>Mol. Phylogenet. Evol. Plant Mol.
Evol</source>., <volume>29</volume>,
<fpage>380</fpage>–<lpage>395</lpage>.</mixed-citation>
    </ref>
    <ref id="btab328-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Akerborg</surname><given-names>O.</given-names></string-name></person-group><etal>et al</etal> (<year>2009</year>) <article-title>Simultaneous Bayesian gene tree
reconstruction and reconciliation analysis</article-title>. <source>Proc. Natl. Acad.
Sci. USA</source>, <volume>106</volume>,
<fpage>5714</fpage>–<lpage>5719</lpage>.<pub-id pub-id-type="pmid">19299507</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bansal</surname><given-names>M.S.</given-names></string-name></person-group><etal>et al</etal> (<year>2012</year>) <article-title>Efficient algorithms for the
reconciliation problem with gene duplication, horizontal transfer and
loss</article-title>. <source>Bioinformatics</source>, <volume>28</volume>,
<fpage>i283</fpage>–<lpage>291</lpage>.<pub-id pub-id-type="pmid">22689773</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bollback</surname><given-names>J.P.</given-names></string-name></person-group> (<year>2006</year>) <article-title>SIMMAP: stochastic character mapping of
discrete traits on phylogenies</article-title>. <source>BMC Bioinformatics</source>,
<volume>7</volume>, <fpage>88</fpage>–<lpage>87</lpage>.<pub-id pub-id-type="pmid">16504105</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Brandvain</surname><given-names>Y.</given-names></string-name>, <string-name><surname>Wade</surname><given-names>M.J.</given-names></string-name></person-group>
(<year>2009</year>) <article-title>The functional transfer of genes from the
mitochondria to the nucleus: the effects of selection, mutation, population size and
rate of self-fertilization</article-title>. <source>Genetics</source>,
<volume>182</volume>, <fpage>1129</fpage>–<lpage>1139</lpage>.<pub-id pub-id-type="pmid">19448273</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Charleston</surname><given-names>M.A.</given-names></string-name>, <string-name><surname>Perkins</surname><given-names>S.L.</given-names></string-name></person-group>
(<year>2006</year>) <article-title>Traversing the tangle: algorithms and applications
for cophylogenetic studies</article-title>. <source>J. Biomed. Inf</source>.,
<volume>39</volume>, <fpage>62</fpage>–<lpage>71</lpage>.</mixed-citation>
    </ref>
    <ref id="btab328-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>K.</given-names></string-name></person-group><etal>et al</etal> (<year>2000</year>) <article-title>NOTUNG: a program for dating gene
duplications and optimizing gene family trees</article-title>. <source>J. Comput.
Biol</source>., <volume>7</volume>,
<fpage>e429</fpage>–<lpage>e447</lpage>.</mixed-citation>
    </ref>
    <ref id="btab328-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Derelle</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>Bacterial proteins pinpoint a single
eukaryotic root</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>,
<volume>112</volume>, <fpage>E693</fpage>–<lpage>E699</lpage>.<pub-id pub-id-type="pmid">25646484</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Delabre</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>Evolution through segmental
duplications and losses: a Super-Reconciliation approach</article-title>.
<source>Algorithms. Mol. Biol</source>., <volume>15</volume>,
<fpage>12</fpage>.<pub-id pub-id-type="pmid">32508979</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B10">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Doyon</surname><given-names>J.P.</given-names></string-name></person-group><etal>et al</etal> (<year>2010</year>) An efficient algorithm for gene/species trees
parsimonious reconciliation with losses, duplications and transfers. In: <italic toggle="yes">Lecture
notes in computer science, Proceedings of RECOMB International Workshop on Comparative
Genomics</italic>, vol. 6398, pp. <fpage>93</fpage>–<lpage>108</lpage>.</mixed-citation>
    </ref>
    <ref id="btab328-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dyall</surname><given-names>S.D.</given-names></string-name>, <string-name><surname>Johnson</surname><given-names>P.J.</given-names></string-name></person-group>
(<year>2000</year>) <article-title>Origins of hydrogenosomes and mitochondria: evolution
and organelle biogenesis</article-title>. <source>Curr. Opin. Microbiol</source>.,
<volume>3</volume>, <fpage>404</fpage>–<lpage>411</lpage>.<pub-id pub-id-type="pmid">10972502</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Edgar</surname><given-names>R.</given-names></string-name></person-group> (<year>2004</year>) <article-title>MUSCLE: multiple sequence alignment
with high accuracy and high throughput</article-title>. <source>Nucleic Acids
Res</source>., <volume>32</volume>,
<fpage>1792</fpage>–<lpage>1797</lpage>.<pub-id pub-id-type="pmid">15034147</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B13">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>El-Mabrouk</surname><given-names>N.</given-names></string-name>, <string-name><surname>Noutahi</surname><given-names>E.</given-names></string-name></person-group>
(<year>2019</year>) <chapter-title>Gene family evolution-an algorithmic
framework</chapter-title>. In: <person-group person-group-type="editor"><string-name><surname>Warnow</surname><given-names>T.</given-names></string-name></person-group>
(ed.) <source>Bioinformatics and Phylogenetics. Computational Biology, vol 29.</source>,
<publisher-name>Springer International Publishing</publisher-name>, pp.
<fpage>87</fpage>–<lpage>119</lpage>.</mixed-citation>
    </ref>
    <ref id="btab328-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fitch</surname><given-names>W.A.</given-names></string-name></person-group> (<year>1971</year>) <article-title>Minimum change for a specific tree
topology</article-title>. <source>Syst. Biol</source>., <volume>20</volume>,
<fpage>406</fpage>–<lpage>416</lpage>.</mixed-citation>
    </ref>
    <ref id="btab328-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Goodman</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>1979</year>) <article-title>Fitting the gene lineage into its
species lineage, a parsimony strategy illustrated by cladograms constructed from globin
sequences</article-title>. <source>Syst. Zool</source>., <volume>28</volume>,
<fpage>132</fpage>–<lpage>163</lpage>.</mixed-citation>
    </ref>
    <ref id="btab328-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gray</surname><given-names>M.W.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>The draft nuclear genome sequence
and predicted mitochondrial proteome of <italic toggle="yes">Andalucia godoyi</italic>, a protist
with the most gene-rich and bacteria-like mitochondrial genome</article-title>.
<source>BMC Biol</source>., <volume>18</volume>, <fpage>22</fpage>.<pub-id pub-id-type="pmid">32122349</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hahn</surname><given-names>M.W.</given-names></string-name></person-group> (<year>2007</year>) <article-title>Bias in phylogenetic tree
reconciliation methods: implications for vertebrate genome evolution</article-title>.
<source>Genome Biology</source>, <volume>8</volume>,
<fpage>R141</fpage>.<pub-id pub-id-type="pmid">17634151</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Huelsenbeck</surname><given-names>J.P.</given-names></string-name></person-group><etal>et al</etal> (<year>2003</year>) <article-title>Stochastic mapping of morphological
characters</article-title>. <source>Syst. Biol</source>., <volume>52</volume>,
<fpage>131</fpage>–<lpage>158</lpage>.<pub-id pub-id-type="pmid">12746144</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kelly</surname><given-names>S.</given-names></string-name></person-group> (<year>2020</year>) <article-title>The economics of endosymbiotic gene
transfer and the evolution of organellar genomes</article-title>.
<source>bioRxiv</source>, doi:10.1101/2020.10.01.322487.</mixed-citation>
    </ref>
    <ref id="btab328-B20">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Lafond</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2016</year>) Efficient non-binary gene tree resolution with
weighted reconciliation cost. InLeibniz International Proceedings in Informatics,
<italic toggle="yes">27th Annual Symposium on Combinatorial Pattern Matching (CPM), num 14, p
14:1-14:12</italic>.</mixed-citation>
    </ref>
    <ref id="btab328-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lang</surname><given-names>B.F.</given-names></string-name>, <string-name><surname>Burger</surname><given-names>G.</given-names></string-name></person-group>
(<year>2012</year>) <article-title>Mitochondrial and eukaryotic origins: a critical
review</article-title>. <source>Bot. Res</source>., <volume>63</volume>,
<fpage>1</fpage>–<lpage>20</lpage>.</mixed-citation>
    </ref>
    <ref id="btab328-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kannan</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2014</year>) <article-title>MitoCOGs: clusters of orthologous
genes from mitochondria and implications for the evolution of
eukaryotes</article-title>. <source>BMC Evol. Biol</source>., <volume>14</volume>,
<fpage>1</fpage>–<lpage>16</lpage>.<pub-id pub-id-type="pmid">24382122</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Makarova</surname><given-names>K.</given-names></string-name></person-group><etal>et al</etal> (<year>2007</year>) <article-title>Clusters of orthologous genes for 41
archaeal genomes and implications for evolutionary genomics of archaea</article-title>.
<source>Biol. Direct</source>, <volume>2</volume>, <fpage>33</fpage>.<pub-id pub-id-type="pmid">18042280</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Puttick</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>The interrelationships of land
plants and the nature of the ancestral embryophyte</article-title>. <source>Curr.
Biol</source>., <volume>28</volume>,
<fpage>733</fpage>–<lpage>745.e2</lpage>.<pub-id pub-id-type="pmid">29456145</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roger</surname><given-names>A.J.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>The origin and diversification of
mitochondria</article-title>. <source>Curr. Biol</source>., <volume>27</volume>,
<fpage>R1177</fpage>–<lpage>R1192</lpage>.<pub-id pub-id-type="pmid">29112874</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B27">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Sankoff</surname><given-names>D.</given-names></string-name>, <string-name><surname>Cedergren</surname><given-names>R.J.</given-names></string-name></person-group>
(<year>1983</year>) <chapter-title>Simultaneous comparison of three or more sequences
related by a tree</chapter-title>. In: <person-group person-group-type="editor"><string-name><surname>Sankoff</surname><given-names>D.</given-names></string-name>, <string-name><surname>Kruskal</surname><given-names>J.B.</given-names></string-name></person-group>
(eds.) <source>Time Warps, String Edits and Macromolecules: The Theory and Practice of
Sequence Comparison</source>, Chapter 9.
<publisher-name>Addison-Wesley</publisher-name>, pp.
<fpage>253</fpage>–<lpage>264</lpage>.</mixed-citation>
    </ref>
    <ref id="btab328-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sloan</surname><given-names>D.B.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Cytonuclear integration and
co-evolution</article-title>. <source>Nat. Rev. Genet</source>., <volume>19</volume>,
<fpage>635</fpage>–<lpage>648</lpage>.<pub-id pub-id-type="pmid">30018367</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Stamatakis</surname><given-names>A.</given-names></string-name></person-group> (<year>2014</year>) <article-title>RAxML version 8: a tool for
phylogenetic analysis and post-analysis of large phylogenies</article-title>.
<source>Bioinformatics</source>, <volume>30</volume>,
<fpage>1312</fpage>–<lpage>1313</lpage>.<pub-id pub-id-type="pmid">24451623</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Stolzer</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2012</year>) <article-title>Inferring duplications, losses,
transfers and incomplete lineage sorting with nonbinary species trees</article-title>.
<source>Bioinformatics</source>, <volume>28</volume>,
<fpage>i409</fpage>–<lpage>415</lpage>.<pub-id pub-id-type="pmid">22962460</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Szöllősi</surname><given-names>G.J.</given-names></string-name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>The inference of gene trees with
species trees</article-title>. <source>Syst. Biol</source>., <volume>64</volume>,
<fpage>e42</fpage>–<lpage>e62</lpage>.<pub-id pub-id-type="pmid">25070970</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tofigh</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2011</year>) <article-title>Simultaneous identification of
duplications and lateral gene transfers</article-title>. <source>IEEE/ACM Trans. Comput.
Biol. Bioinf</source>., <volume>8</volume>,
<fpage>517</fpage>–<lpage>535</lpage>.</mixed-citation>
    </ref>
    <ref id="btab328-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yutin</surname><given-names>N.</given-names></string-name></person-group><etal>et al</etal> (<year>2009</year>) <article-title>Eukaryotic large nucleo-cytoplasmic
DNA viruses: clusters of orthologous genes and reconstruction of viral genome
evolution</article-title>. <source>Virol. J</source>., <volume>6</volume>,
<fpage>223</fpage>.<pub-id pub-id-type="pmid">20017929</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhang</surname><given-names>L.</given-names></string-name></person-group> (<year>1997</year>) <article-title>On a Mirkin-Muchnik-Smith conjecture
for comparing molecular phylogenies</article-title>. <source>J. Comput. Biol</source>.,
<volume>4</volume>, <fpage>177</fpage>–<lpage>187</lpage>.<pub-id pub-id-type="pmid">9228616</pub-id></mixed-citation>
    </ref>
    <ref id="btab328-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zmasek</surname><given-names>C.M.</given-names></string-name>, <string-name><surname>Eddy</surname><given-names>S.R.</given-names></string-name></person-group>
(<year>2001</year>) <article-title>A simple algorithm to infer gene duplication and
speciation events on a gene tree</article-title>. <source>Bioinformatics</source>,
<volume>17</volume>, <fpage>821</fpage>–<lpage>828</lpage>.<pub-id pub-id-type="pmid">11590098</pub-id></mixed-citation>
    </ref>
  </ref-list>
  <app-group>
    <app id="app1">
      <title>Appendix A</title>
      <statement id="mthst8">
        <label>Proof of Lemma 1</label>
        <p>Let <inline-formula id="IE330"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM244" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> be a DLE-Reconciliation of minimum cost between
<italic toggle="yes">T</italic> and <italic toggle="yes">S</italic>. Let
<bold><sub><italic toggle="yes">λ</italic></sub></bold> be the cost of a loss event. Let us first
make an observation. Let <inline-formula id="IE331"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM245" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and let <inline-formula id="IE332"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM246" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, assuming that <italic toggle="yes">l</italic> exists. Let
<inline-formula id="IE333"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM247" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the path from <italic toggle="yes">v</italic> to <italic toggle="yes">l</italic>
in <italic toggle="yes">R</italic>. It is easy to see from the definition of reconciliation that
<inline-formula id="IE334"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM248" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a path of <italic toggle="yes">S</italic>, but with some vertices
possibly being repeated (i.e. <inline-formula id="IE335"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM249" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is possible, but otherwise <inline-formula id="IE336"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM250" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a child of <inline-formula id="IE337"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM251" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). It follows that <inline-formula id="IE338"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM252" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> must be an ancestor of
<italic toggle="yes">s</italic>(<italic toggle="yes">l</italic>). Since <italic toggle="yes">v</italic> and
<italic toggle="yes">l</italic> were chosen arbitrarily, we have that for any <inline-formula id="IE339"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM253" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is an ancestor of <italic toggle="yes">s</italic>(<italic toggle="yes">l</italic>)
for every leaf <inline-formula id="IE340"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM254" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>Now suppose that, for some <inline-formula id="IE341"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM255" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, choose <italic toggle="yes">x</italic> as a lowest node of
<inline-formula id="IE342"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM256" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with this property (i.e. <inline-formula id="IE343"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM257" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all descendants <inline-formula id="IE344"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM258" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">x</italic> in <italic toggle="yes">R</italic>). Note that
<italic toggle="yes">x</italic> is an internal node of <italic toggle="yes">T</italic> since <inline-formula id="IE345"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM259" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for every leaf <italic toggle="yes">x</italic> of
<italic toggle="yes">T</italic>.</p>
        <p>As we argued, <inline-formula id="IE346"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM260" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is an ancestor of <italic toggle="yes">s</italic>(<italic toggle="yes">l</italic>)
for every leaf <inline-formula id="IE347"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM261" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Since <inline-formula id="IE348"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM262" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, it follows that <inline-formula id="IE349"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM263" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a strict ancestor of <inline-formula id="IE350"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM264" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We first argue that <italic toggle="yes">x</italic> cannot be a
speciation. Assume this is the case and let <inline-formula id="IE351"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM265" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the children of <italic toggle="yes">x</italic> in
<italic toggle="yes">R</italic> (but not necessarily in <italic toggle="yes">T</italic>). We use
<italic toggle="yes">x<sub>l</sub></italic> and <italic toggle="yes">x<sub>r</sub></italic> to denote the
children of <italic toggle="yes">x</italic> in <italic toggle="yes">T</italic>. By the definition of speciation,
<inline-formula id="IE352"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM266" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE353"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM267" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are the two children of <inline-formula id="IE354"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM268" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Because <inline-formula id="IE355"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM269" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a strict ancestor of <inline-formula id="IE356"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM270" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, only one of <inline-formula id="IE357"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM271" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE358"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM272" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has descendants in <inline-formula id="IE359"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM273" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Assume without loss of generality that only
<inline-formula id="IE360"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM274" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has such descendants. But then, <inline-formula id="IE361"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM275" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is not an ancestor of any member of <inline-formula id="IE362"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM276" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In particular, <inline-formula id="IE363"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM277" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is not an ancestor of any member of <inline-formula id="IE364"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM278" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and the latter is easily seen to be non-empty (this is
because <inline-formula id="IE365"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM279" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is an ancestor of <italic toggle="yes">x<sub>r</sub></italic> and
<inline-formula id="IE366"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM280" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> has leaves from <italic toggle="yes">T</italic>). As we argued before,
this is not possible, since there should be a path from <inline-formula id="IE367"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM281" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to any <italic toggle="yes">s</italic>(<italic toggle="yes">l</italic>) with
<inline-formula id="IE368"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM282" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>Assume that <italic toggle="yes">x</italic> is a duplication or EGTcopy event (<italic toggle="yes">x</italic>
cannot be an EGTcut event because it is binary). As before, let
<italic toggle="yes">x<sub>l</sub></italic> and <italic toggle="yes">x<sub>r</sub></italic> be the children of
<italic toggle="yes">x</italic> in <italic toggle="yes">T</italic> (but not necessarily in <italic toggle="yes">R</italic>).
By the choice of <italic toggle="yes">x</italic>, <inline-formula id="IE369"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM283" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE370"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM284" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus <inline-formula id="IE371"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM285" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> must be a strict ancestor of both <inline-formula id="IE372"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM286" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE373"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM287" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Let <inline-formula id="IE374"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM288" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> be the child of <inline-formula id="IE375"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM289" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that is on the path from <inline-formula id="IE376"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM290" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE377"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM291" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We obtain an alternate reconciliation by modifying
<italic toggle="yes">R</italic> to obtain another extension <inline-formula id="IE378"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM292" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">T</italic>. We do not change any event
labeling. We map <italic toggle="yes">x</italic> to <inline-formula id="IE379"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM293" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and graft a loss in <inline-formula id="IE380"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM294" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> on the edge between <italic toggle="yes">x</italic> and its parent in
<italic toggle="yes">R</italic> (if any). In that manner, the parent of <italic toggle="yes">x</italic> in
<italic toggle="yes">R</italic> still has a child mapped to <inline-formula id="IE381"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM295" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <inline-formula id="IE382"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM296" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. This increases the cost by
<bold><sub><italic toggle="yes">λ</italic></sub></bold>, the cost of one loss.</p>
        <p>Now let <inline-formula id="IE383"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM297" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the nodes on the path from <italic toggle="yes">x</italic> to
<italic toggle="yes">x<sub>l</sub></italic> in <italic toggle="yes">R</italic> (excluding <italic toggle="yes">x</italic>
and <italic toggle="yes">x<sub>l</sub></italic>). Note that since <italic toggle="yes">x</italic> is a duplication
or EGTcopy, <inline-formula id="IE384"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM298" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, at most one node among <inline-formula id="IE385"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM299" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> can be an EGTcopy or an EGTcut, since there is no point
in making more than one switch within an edge.</p>
        <p>If present, we may assume without loss of generality that such an event occurs at
<italic toggle="yes">x<sub>k</sub></italic>, the parent of <italic toggle="yes">x<sub>l</sub></italic> in
<italic toggle="yes">R</italic>, since the timing of the switch does not affect the reconciliation
cost. In this case, <inline-formula id="IE386"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM300" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. On the other hand, <inline-formula id="IE387"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM301" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This implies that <inline-formula id="IE388"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM302" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and thus <italic toggle="yes">x</italic><sub>1</sub> is not an
EGTcopy or an EGTcut. It follows that <italic toggle="yes">x</italic><sub>1</sub> is a node inserted
because of a grafted loss, and <inline-formula id="IE389"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM303" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. In <inline-formula id="IE390"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM304" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, we can remove <italic toggle="yes">x</italic><sub>1</sub> and its
loss leaf, and by doing so, the left child of <italic toggle="yes">x</italic> becomes
<italic toggle="yes">x</italic><sub>2</sub>. This preserves all properties of a valid
reconciliation because both <italic toggle="yes">x</italic> and <italic toggle="yes">x</italic><sub>2</sub> are
mapped to <inline-formula id="IE391"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM305" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. We can apply the same procedure on the path from
<italic toggle="yes">x</italic> to <italic toggle="yes">x<sub>r</sub></italic>.</p>
        <p>In <inline-formula id="IE392"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM306" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, we have created one loss above <italic toggle="yes">x</italic>, but
have removed two losses on both sides of <italic toggle="yes">x</italic>. No other event labeling has
changed. Since we assume that losses have a non-zero cost, <inline-formula id="IE393"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM307" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> has a strictly lower cost than <italic toggle="yes">R</italic>, a
contradiction.</p>
      </statement>
      <statement id="mthst9">
        <label>Proof of Lemma 2</label>
        <p>We first show that the reconciliation <inline-formula id="IE394"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM308" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> obtained from Algorithm 1 is a valid DLE-Reconciliation.
Note that the tree <italic toggle="yes">R</italic> returned by the algorithm is the same as
<italic toggle="yes">R<sub>DL</sub></italic>, but with some grafted unary nodes for EGTcut events
where needed. Consider some <inline-formula id="IE395"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM309" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In <italic toggle="yes">R</italic>, we put <inline-formula id="IE396"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM310" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE397"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM311" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE398"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM312" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE399"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM313" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi></mml:mrow></mml:math></inline-formula>. If no additional node was grafted as a new child of
<italic toggle="yes">x</italic>, all properties of reconciliation would be preserved since we keep
<inline-formula id="IE400"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM314" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> as in <inline-formula id="IE401"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM315" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. If some node <inline-formula id="IE402"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM316" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> was grafted as a new child of <italic toggle="yes">x</italic>, we
ensure that <inline-formula id="IE403"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM317" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the same as the previous child of <italic toggle="yes">x</italic>,
which ensures that we satisfy the properties of reconciliation. Therefore, we only need
to check whether the tree <italic toggle="yes">R<sub>DL</sub></italic> is modified in an appropriate
way in the case of a different <inline-formula id="IE404"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM318" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> value for a node <italic toggle="yes">x</italic> of <italic toggle="yes">T</italic>
and one of its two children <italic toggle="yes">x<sub>l</sub></italic> or
<italic toggle="yes">x<sub>r</sub></italic>.</p>
        <p>Lines 2–8 first ensure that the starting tree <italic toggle="yes">R</italic> is such that, for each
node <italic toggle="yes">x</italic> of <italic toggle="yes">T</italic>, <inline-formula id="IE405"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM319" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and for any edge (<italic toggle="yes">x</italic>,
<italic toggle="yes">y</italic>) in <italic toggle="yes">T</italic> such that <inline-formula id="IE406"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM320" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the corresponding path <inline-formula id="IE407"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM321" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> on <italic toggle="yes">R</italic> is such that for all
<italic toggle="yes">i</italic>, <inline-formula id="IE408"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM322" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Subsequently, in the case of a different <inline-formula id="IE409"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM323" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> value for a node <italic toggle="yes">x</italic> of <italic toggle="yes">T</italic>
and its child <italic toggle="yes">y</italic>, the node <italic toggle="yes">x</italic> is either modified to an
EGTcopy node, ensuring that the switch between <inline-formula id="IE410"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM324" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE411"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM325" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is correctly explained by this EGTcopy, or a new EGTcut
node <italic toggle="yes">v</italic> is grafted on the edge <inline-formula id="IE412"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM326" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, also correctly explaining the switch between
<inline-formula id="IE413"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM327" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE414"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM328" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>We now show that the DLE-Reconciliation output by Algorithm 1 is of minimum cost. First
Note that, from the initialization done in Line 8, for each leaf <italic toggle="yes">x</italic>
which is on <italic toggle="yes">R<sub>DL</sub></italic> but not in <italic toggle="yes">T</italic> (lost gene),
the algorithm ensures that <inline-formula id="IE415"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM329" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> were <italic toggle="yes">p<sub>x</sub></italic> is
<italic toggle="yes">x’</italic>s parent. Thus, grafted loss leaves never require an extra EGTcopy
event on an ‘inserted edge’ of <italic toggle="yes">R<sub>DL</sub></italic>.</p>
        <p>Assume another reconciliation <inline-formula id="IE416"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM330" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> has a strictly lower cost than <inline-formula id="IE417"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM331" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> output by Algorithm 1. We first show that, for any node
of <italic toggle="yes">T</italic>, the corresponding node in <italic toggle="yes">R</italic> and <inline-formula id="IE418"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM332" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> have the same event label. Assume this is not the case.
Let <italic toggle="yes">x</italic> be the lowest node of <italic toggle="yes">T</italic> such that
<inline-formula id="IE419"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM333" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Let <italic toggle="yes">x<sub>l</sub></italic> and
<italic toggle="yes">x<sub>r</sub></italic> be its two children in <italic toggle="yes">T</italic> and
<italic toggle="yes">v<sub>l</sub></italic> and <italic toggle="yes">v<sub>r</sub></italic> be the two
non-unary descendant of <italic toggle="yes">x</italic> in <inline-formula id="IE420"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM334" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> the closest from <italic toggle="yes">x</italic>. Note that
<italic toggle="yes">x<sub>l</sub></italic> and <italic toggle="yes">x<sub>r</sub></italic> do not necessarily
correspond to <italic toggle="yes">v<sub>l</sub></italic> and <italic toggle="yes">v<sub>r</sub></italic> in
<inline-formula id="IE421"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM335" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. Rather, they may be strict descendants of these nodes in
<inline-formula id="IE422"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM336" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>1. If <inline-formula id="IE423"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM337" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi></mml:mrow></mml:math></inline-formula>, then from Algorithm 1, <inline-formula id="IE424"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM338" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE425"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM339" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE426"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM340" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE427"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM341" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi></mml:mrow></mml:math></inline-formula> otherwise. As <inline-formula id="IE428"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM342" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we should have <inline-formula id="IE429"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM343" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> in the first case, or <inline-formula id="IE430"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM344" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> in the second case.</p>
        <p>
          <disp-quote content-type="extract">
            <p>Assume <inline-formula id="IE431"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM345" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi></mml:mrow></mml:math></inline-formula>. From <xref rid="mthst2" ref-type="statement">Lemma
1</xref>, as <inline-formula id="IE432"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM346" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> is a reconciliation of minimum cost, <inline-formula id="IE433"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM347" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and as <italic toggle="yes">x</italic> is a speciation node in
<inline-formula id="IE434"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM348" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, one of <italic toggle="yes">v<sub>l</sub></italic> and
<italic toggle="yes">v<sub>r</sub></italic> should be mapped to <inline-formula id="IE435"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM349" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the other to <inline-formula id="IE436"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM350" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Assume w.l.o.g. that <inline-formula id="IE437"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM351" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE438"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM352" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Now, as <italic toggle="yes">x</italic> is a duplication node in
<italic toggle="yes">R<sub>DL</sub></italic>, then <inline-formula id="IE439"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM353" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE440"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM354" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Assume w.l.o.g. that <inline-formula id="IE441"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM355" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. As <italic toggle="yes">x<sub>l</sub></italic> is a node of the
subtree of <inline-formula id="IE442"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM356" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> rooted at <italic toggle="yes">v<sub>l</sub></italic>, by
definition of a reconciliation, <inline-formula id="IE443"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM357" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> should be a descendant of <inline-formula id="IE444"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM358" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which is not the case as <inline-formula id="IE445"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM359" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is rather a strict descendant of <inline-formula id="IE446"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM360" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Therefore, <italic toggle="yes">x</italic> cannot be a speciation
node in <inline-formula id="IE447"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM361" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>. We deduce that <inline-formula id="IE448"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM362" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
            <p>Now assume that <inline-formula id="IE449"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM363" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE450"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM364" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In this case, the algorithm puts <inline-formula id="IE451"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM365" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi></mml:mrow></mml:math></inline-formula> and, as <italic toggle="yes">x</italic> is not a speciation, it
should be a duplication node in <inline-formula id="IE452"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM366" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>. But then an a unary EGTcut node <italic toggle="yes">v</italic>
should be present in one of the two paths from <italic toggle="yes">x</italic> to
<italic toggle="yes">x<sub>l</sub></italic> or from <italic toggle="yes">x</italic> to
<italic toggle="yes">x<sub>r</sub></italic> in <inline-formula id="IE453"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM367" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, contradicting the fact that <inline-formula id="IE454"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM368" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> is a reconciliation of minimum cost, since labeling
<italic toggle="yes">x</italic> as an EGTcopy node and removing <italic toggle="yes">v</italic> would reduce
the cost of the reconciliation by one.</p>
            <p>Finally, assume that <inline-formula id="IE455"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM369" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE456"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM370" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In this case, the algorithm puts <inline-formula id="IE457"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM371" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi></mml:mrow></mml:math></inline-formula> and, as <italic toggle="yes">x</italic> is not a speciation, it
should be an EGTcopy node in <inline-formula id="IE458"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM372" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>, which induces, by definition of an EGTcopy event,
that one of the two children <italic toggle="yes">y</italic> of <italic toggle="yes">x</italic> in
<inline-formula id="IE459"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM373" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is such that <inline-formula id="IE460"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM374" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Now, as <inline-formula id="IE461"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM375" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, one unary EGTcut node <italic toggle="yes">v</italic> should
change the <inline-formula id="IE462"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM376" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> labeling of <italic toggle="yes">y</italic> to the <inline-formula id="IE463"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM377" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> labeling of its descendant in <inline-formula id="IE464"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM378" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. But then relabeling <italic toggle="yes">x</italic> as a
duplication node would allow removing <italic toggle="yes">v</italic> and thus reducing the cost
of the reconciliation by one, contradicting the fact that <inline-formula id="IE465"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM379" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> is a reconciliation of minimum cost.</p>
          </disp-quote>
        </p>
        <p>2. If <inline-formula id="IE466"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM380" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi></mml:mrow></mml:math></inline-formula>, then from the properties of a DL-Reconciliation, we
should have <inline-formula id="IE467"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM381" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE468"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM382" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. From Algorithm 1, <italic toggle="yes">x</italic> remains a
speciation node in <inline-formula id="IE469"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM383" display="inline" overflow="scroll"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>
          <disp-quote content-type="extract">
            <p>As <inline-formula id="IE470"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM384" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we should have <inline-formula id="IE471"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM385" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE472"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM386" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi></mml:mrow></mml:math></inline-formula>. In both cases, <inline-formula id="IE473"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM387" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This implies that <inline-formula id="IE474"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM388" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE475"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM389" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and thus <italic toggle="yes">v<sub>l</sub></italic> and
<italic toggle="yes">v<sub>r</sub></italic> are grafted because of losses. Since
<inline-formula id="IE476"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM390" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> uses the LCA-mapping by <xref rid="mthst2" ref-type="statement">Lemma 1</xref>, we can remove <italic toggle="yes">v<sub>l</sub></italic>,
<italic toggle="yes">v<sub>r</sub></italic> and their corresponding grafted loss leaves and
make <italic toggle="yes">x</italic> a speciation, while preserving a valid reconciliation. This
saves a cost of three (two losses and a <italic toggle="yes">Dup</italic> or
<italic toggle="yes">EGTcopy</italic> event). In the worst case, we had <inline-formula id="IE477"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM391" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi></mml:mrow></mml:math></inline-formula>, in which case we can add an EGTcut event on the
appropriate branch to enforce the same switch.</p>
            <p>Thus replacing the <italic toggle="yes">Dup</italic> or EGTcopy label of <italic toggle="yes">x</italic> by a
speciation reduces the cost of <inline-formula id="IE478"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM392" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> by at least two, contradicting the fact that
<inline-formula id="IE479"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM393" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is a reconciliation of minimum cost.</p>
          </disp-quote>
        </p>
        <p>Since we have the same number of <italic toggle="yes">Dup</italic> and ETTr events as
<inline-formula id="IE480"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM394" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, it remains to show that we cannot graft less nodes than
those induced by Algorithm 1. The grafted nodes are either binary nodes corresponding to
losses, or EGTcut unary nodes. Suppose <inline-formula id="IE481"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM395" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> has less grafted nodes than <italic toggle="yes">R</italic>. Then
there is an edge (<italic toggle="yes">x</italic>, <italic toggle="yes">y</italic>) in <italic toggle="yes">T</italic> such
that the corresponding path <inline-formula id="IE482"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM396" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>v</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <inline-formula id="IE483"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM397" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is shorter than the corresponding path <inline-formula id="IE484"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM398" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">R</italic>. We consider a lowest edge
(<italic toggle="yes">x</italic>, <italic toggle="yes">y</italic>) of <italic toggle="yes">T</italic> verifying this
condition, and we assume, without loss of generality, that <italic toggle="yes">y</italic> =
<italic toggle="yes">x<sub>l</sub></italic>. Recall that by <xref rid="mthst2" ref-type="statement">Lemma 1</xref>, <inline-formula id="IE485"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM399" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE486"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM400" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <list list-type="bullet"><list-item><p>If <inline-formula id="IE487"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM401" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi></mml:mrow></mml:math></inline-formula>, then <italic toggle="yes">x</italic> is a duplication or an
EGTcopy node in both <italic toggle="yes">R</italic> and <inline-formula id="IE488"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM402" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. Then, by definition of a reconciliation,
<inline-formula id="IE489"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM403" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, from the fact that <italic toggle="yes">R</italic> is
obtained from <italic toggle="yes">R<sub>DL</sub></italic>, Algorithm 1 leads to a path
<inline-formula id="IE490"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM404" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> with as many nodes as the path from <inline-formula id="IE491"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM405" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE492"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM406" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">S</italic> if <italic toggle="yes">x</italic> is a
duplication node, and an additional EGTcut node if <inline-formula id="IE493"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM407" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, it is easy to see that the number of
losses crafted on (<italic toggle="yes">x</italic>, <italic toggle="yes">y</italic>) must be equal to the
number of nodes on the path from <inline-formula id="IE494"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM408" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE495"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM409" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, excluding <inline-formula id="IE496"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM410" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, either in <italic toggle="yes">R</italic> or <inline-formula id="IE497"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM411" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, and that the EGTcut event added by the algorithm
cannot be avoided. And thus, the path <inline-formula id="IE498"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM412" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> should be at least as long as <inline-formula id="IE499"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM413" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, contradicting the hypothesis that <inline-formula id="IE500"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM414" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is shorter than <inline-formula id="IE501"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM415" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p>If <inline-formula id="IE502"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM416" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi></mml:mrow></mml:math></inline-formula>, then <italic toggle="yes">x</italic> is a speciation node in
both <italic toggle="yes">R</italic> and <inline-formula id="IE503"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM417" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. Then, by definition of a reconciliation,
<inline-formula id="IE504"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM418" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Thus, from the fact that <italic toggle="yes">R</italic> is
obtained from <italic toggle="yes">R<sub>DL</sub></italic>, Algorithm 1 leads to a path
<inline-formula id="IE505"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM419" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> with as many nodes as the path from <inline-formula id="IE506"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM420" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE507"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM421" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">S</italic>, with an additional EGTcut
node if <inline-formula id="IE508"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM422" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, it is easy to see that no other
operation (Spe, Dup, RGT or EGTcut) can allow making less losses or avoid the
EGTcut event. And thus, the path <inline-formula id="IE509"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM423" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> should be at least as long as <inline-formula id="IE510"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM424" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, contradicting the hypothesis that <inline-formula id="IE511"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM425" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is shorter than <inline-formula id="IE512"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM426" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p></list-item></list></p>
      </statement>
      <statement id="mthst10">
        <label>Proof of Theorem 1</label>
        <p>Let us first argue on the complexity of computing <inline-formula id="IE513"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM427" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for every <inline-formula id="IE514"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM428" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and every <inline-formula id="IE515"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM429" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> (including <inline-formula id="IE516"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM430" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE517"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM431" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, our values of interest). The LCA-mapping <inline-formula id="IE518"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM432" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> can be computed in time <inline-formula id="IE519"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM433" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using classical approaches from DL-reconciliation. We can
compute <inline-formula id="IE520"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM434" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE521"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM435" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for every <inline-formula id="IE522"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM436" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in a post-order traversal of <italic toggle="yes">T</italic> (because
their value only depends on <italic toggle="yes">x<sub>l</sub></italic> and
<italic toggle="yes">x<sub>r</sub></italic>), and thus there are <inline-formula id="IE523"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM437" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> values to compute. If we assume that if we have access to
<italic toggle="yes">l<sub>x</sub></italic> for each <italic toggle="yes">x</italic>, it is clear from the
recurrences that <inline-formula id="IE524"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM438" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE525"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM439" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> can be computed in <italic toggle="yes">O</italic>(1) time. To access
<italic toggle="yes">l<sub>x</sub></italic> in time <italic toggle="yes">O</italic>(1) for any
<italic toggle="yes">x</italic>, we can preprocess <italic toggle="yes">S</italic> by labeling each
<inline-formula id="IE526"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM440" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by its depth (i.e. its distance to the root). Then,
<inline-formula id="IE527"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM441" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">path</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is simply the difference in depth between <inline-formula id="IE528"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM442" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE529"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM443" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (because <inline-formula id="IE530"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM444" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> must be a descendant of <inline-formula id="IE531"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM445" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). This difference can be obtained in constant time, and
it follows that <italic toggle="yes">l<sub>x</sub></italic> can be obtained in <italic toggle="yes">O</italic>(1).
Therefore, each <inline-formula id="IE532"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM446" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> entry takes <italic toggle="yes">O</italic>(1) time to compute.
Including the time to compute the preprocessing and the LCA-mapping, the total time of
the algorithm is <inline-formula id="IE533"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM447" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>Let us now argue that the algorithm is correct. Let <inline-formula id="IE534"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM448" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, let <inline-formula id="IE535"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM449" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, and let <inline-formula id="IE536"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM450" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> be a DLE-Reconciliation of minimum cost between
<inline-formula id="IE537"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM451" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">S</italic> that satisfies <inline-formula id="IE538"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM452" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The proof is by induction on the height of
<inline-formula id="IE539"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM453" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. If <italic toggle="yes">x</italic> is a leaf, it is easy to see that
<inline-formula id="IE540"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM454" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is correct. Assume that <italic toggle="yes">x</italic> is an internal
node with children <italic toggle="yes">x<sub>l</sub></italic> and <italic toggle="yes">x<sub>r</sub></italic>. We
may inductively assume that <inline-formula id="IE541"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM455" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE542"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM456" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> are computed correctly for <inline-formula id="IE543"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM457" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>In what follows, let <inline-formula id="IE544"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM458" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> be the reconciliation between <inline-formula id="IE545"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM459" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">S</italic> obtained by taking <inline-formula id="IE546"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM460" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and restricting <inline-formula id="IE547"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM461" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE548"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM462" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE549"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM463" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Similarly, let <inline-formula id="IE550"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM464" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the reconciliation of <inline-formula id="IE551"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM465" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> with <italic toggle="yes">S</italic> obtained by taking
<inline-formula id="IE552"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM466" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and restricting <inline-formula id="IE553"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM467" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE554"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM468" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE555"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM469" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>We show two useful claims, the first being that these sub-reconciliations must be
optimal with respect to their subtrees.</p>
      </statement>
      <statement id="mthst11">
        <p>Claim 1.1. <inline-formula id="IE556"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM470" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE557"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM471" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>Proof. By induction and by the definition of <italic toggle="yes">D</italic>, we have
<inline-formula id="IE558"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM472" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, in <inline-formula id="IE559"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM473" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula> we may replace the <inline-formula id="IE560"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM474" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> subtree by <inline-formula id="IE561"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM475" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (more precisely, replace <inline-formula id="IE562"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM476" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> by <italic toggle="yes">R<sub>l</sub></italic>, and use
<inline-formula id="IE563"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM477" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE564"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM478" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for the vertices of <italic toggle="yes">R<sub>l</sub></italic>).
Since <inline-formula id="IE565"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM479" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE566"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM480" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, all conditions of a valid reconciliation are met after
such a replacement. Furthermore, no additional loss, EGTcopy or EGTcut is required on
the path between <italic toggle="yes">x</italic> to <italic toggle="yes">x<sub>l</sub></italic>. If
<inline-formula id="IE567"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM481" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> held, this transformation would yield a lower cost
reconciliation and contradict the optimality of <inline-formula id="IE568"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM482" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula>. Therefore, <inline-formula id="IE569"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM483" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. It follows that <inline-formula id="IE570"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM484" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. By a symmetric argument, <inline-formula id="IE571"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM485" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <sub><bold>□</bold></sub></p>
      </statement>
      <statement id="mthst12">
        <p>Claim 1.2. If <inline-formula id="IE572"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM486" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi></mml:mrow></mml:math></inline-formula>, then there are at least <inline-formula id="IE573"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM487" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> losses grafted on the <inline-formula id="IE574"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM488" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE575"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM489" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> branches, and otherwise, there are at least
<inline-formula id="IE576"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM490" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> such grafted losses.</p>
        <p>Proof. If <inline-formula id="IE577"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM491" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi></mml:mrow></mml:math></inline-formula>, in <italic toggle="yes">R</italic> there must be a loss grafted on
the <inline-formula id="IE578"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM492" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (respectively <inline-formula id="IE579"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM493" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) branch for each node of <inline-formula id="IE580"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM494" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">path</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (respectively <inline-formula id="IE581"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM495" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">path</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>), excluding <inline-formula id="IE582"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM496" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE583"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM497" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (respectively <inline-formula id="IE584"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM498" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). The number of such losses is <inline-formula id="IE585"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM499" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> and induce a cost of <inline-formula id="IE586"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM500" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. If <inline-formula id="IE587"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM501" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, the required losses are the same, except that we do not
exclude <italic toggle="yes">x</italic> from both paths, and thus <inline-formula id="IE588"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM502" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> losses are required for a cost of <inline-formula id="IE589"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM503" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <sub><bold>□</bold></sub></p>
      </statement>
      <list list-type="simple">
        <list-item>
          <p>We now argue that <inline-formula id="IE590"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM504" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. First assume that <inline-formula id="IE591"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM505" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. We then consider the four possible <inline-formula id="IE592"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM506" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> labelings of <italic toggle="yes">x<sub>l</sub></italic> and
<italic toggle="yes">x<sub>r</sub></italic>.</p>
        </list-item>
      </list>
      <p>• If <inline-formula id="IE593"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM507" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then no cost other than the losses is required on the
<inline-formula id="IE594"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM508" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE595"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM509" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> branches. Thus using claims 1.1 and 1.2,</p>
      <list list-type="simple">
        <list-item>
          <p>
            <inline-formula id="IE596">
              <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM510" display="inline" overflow="scroll">
                <mml:mtable>
                  <mml:mtr>
                    <mml:mtd>
                      <mml:mi>c</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi mathvariant="script">R</mml:mi>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>≥</mml:mo>
                      <mml:mrow>
                        <mml:mo stretchy="true">{</mml:mo>
                        <mml:mrow>
                          <mml:mtable>
                            <mml:mtr columnalign="left">
                              <mml:mtd columnalign="left">
                                <mml:mrow>
                                  <mml:mo>λ</mml:mo>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>l</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:msub>
                                  <mml:mo>−</mml:mo>
                                  <mml:mn>4</mml:mn>
                                  <mml:mo stretchy="false">)</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mi>c</mml:mi>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi mathvariant="script">R</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>l</mml:mi>
                                  </mml:msub>
                                  <mml:mo stretchy="false">)</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mi>c</mml:mi>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi mathvariant="script">R</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>r</mml:mi>
                                  </mml:msub>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mtd>
                              <mml:mtd columnalign="left">
                                <mml:mrow>
                                  <mml:mo> </mml:mo>
                                  <mml:mtext>if</mml:mtext>
                                  <mml:mo> </mml:mo>
                                  <mml:mover accent="true">
                                    <mml:mi>e</mml:mi>
                                    <mml:mo>˜</mml:mo>
                                  </mml:mover>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mi>x</mml:mi>
                                  <mml:mo stretchy="false">)</mml:mo>
                                  <mml:mo>=</mml:mo>
                                  <mml:mi mathvariant="italic">Spe</mml:mi>
                                </mml:mrow>
                              </mml:mtd>
                            </mml:mtr>
                            <mml:mtr columnalign="left">
                              <mml:mtd columnalign="left">
                                <mml:mrow>
                                  <mml:mo>δ</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mo>λ</mml:mo>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>l</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:msub>
                                  <mml:mo>−</mml:mo>
                                  <mml:mn>2</mml:mn>
                                  <mml:mo stretchy="false">)</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mi>c</mml:mi>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi mathvariant="script">R</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>l</mml:mi>
                                  </mml:msub>
                                  <mml:mo stretchy="false">)</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mi>c</mml:mi>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi mathvariant="script">R</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>r</mml:mi>
                                  </mml:msub>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mtd>
                              <mml:mtd columnalign="left">
                                <mml:mrow>
                                  <mml:mo> </mml:mo>
                                  <mml:mtext>if</mml:mtext>
                                  <mml:mo> </mml:mo>
                                  <mml:mover accent="true">
                                    <mml:mi>e</mml:mi>
                                    <mml:mo>˜</mml:mo>
                                  </mml:mover>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mi>x</mml:mi>
                                  <mml:mo stretchy="false">)</mml:mo>
                                  <mml:mo>=</mml:mo>
                                  <mml:mi mathvariant="italic">Dup</mml:mi>
                                </mml:mrow>
                              </mml:mtd>
                            </mml:mtr>
                          </mml:mtable>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
              </mml:math>
            </inline-formula>
          </p>
        </list-item>
        <list-item>
          <p>
            <inline-formula id="IE596a">
              <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM511" display="inline" overflow="scroll">
                <mml:mtable>
                  <mml:mtr>
                    <mml:mtd>
                      <mml:mo>=</mml:mo>
                      <mml:mrow>
                        <mml:mo stretchy="true">{</mml:mo>
                        <mml:mrow>
                          <mml:mtable>
                            <mml:mtr columnalign="left">
                              <mml:mtd columnalign="left">
                                <mml:mrow>
                                  <mml:mo>λ</mml:mo>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>l</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:msub>
                                  <mml:mo>−</mml:mo>
                                  <mml:mn>4</mml:mn>
                                  <mml:mo stretchy="false">)</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mi>D</mml:mi>
                                  <mml:mo stretchy="false">[</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>x</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>l</mml:mi>
                                  </mml:msub>
                                  <mml:mo>,</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>b</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:msub>
                                  <mml:mo stretchy="false">]</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mi>D</mml:mi>
                                  <mml:mo stretchy="false">[</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>x</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>r</mml:mi>
                                  </mml:msub>
                                  <mml:mo>,</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>b</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:msub>
                                  <mml:mo stretchy="false">]</mml:mo>
                                </mml:mrow>
                              </mml:mtd>
                              <mml:mtd columnalign="left">
                                <mml:mrow>
                                  <mml:mo> </mml:mo>
                                  <mml:mtext>if</mml:mtext>
                                  <mml:mo> </mml:mo>
                                  <mml:mover accent="true">
                                    <mml:mi>e</mml:mi>
                                    <mml:mo>˜</mml:mo>
                                  </mml:mover>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mi>x</mml:mi>
                                  <mml:mo stretchy="false">)</mml:mo>
                                  <mml:mo>=</mml:mo>
                                  <mml:mi mathvariant="italic">Spe</mml:mi>
                                </mml:mrow>
                              </mml:mtd>
                            </mml:mtr>
                            <mml:mtr columnalign="left">
                              <mml:mtd columnalign="left">
                                <mml:mrow>
                                  <mml:mo>δ</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mo>λ</mml:mo>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>l</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:msub>
                                  <mml:mo>−</mml:mo>
                                  <mml:mn>2</mml:mn>
                                  <mml:mo stretchy="false">)</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mi>D</mml:mi>
                                  <mml:mo stretchy="false">[</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>x</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>l</mml:mi>
                                  </mml:msub>
                                  <mml:mo>,</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>b</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:msub>
                                  <mml:mo stretchy="false">]</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mi>D</mml:mi>
                                  <mml:mo stretchy="false">[</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>x</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>r</mml:mi>
                                  </mml:msub>
                                  <mml:mo>,</mml:mo>
                                  <mml:msub>
                                    <mml:mrow>
                                      <mml:mi>b</mml:mi>
                                    </mml:mrow>
                                    <mml:mi>x</mml:mi>
                                  </mml:msub>
                                  <mml:mo stretchy="false">]</mml:mo>
                                </mml:mrow>
                              </mml:mtd>
                              <mml:mtd columnalign="left">
                                <mml:mrow>
                                  <mml:mo> </mml:mo>
                                  <mml:mtext>if</mml:mtext>
                                  <mml:mo> </mml:mo>
                                  <mml:mover accent="true">
                                    <mml:mi>e</mml:mi>
                                    <mml:mo>˜</mml:mo>
                                  </mml:mover>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mi>x</mml:mi>
                                  <mml:mo stretchy="false">)</mml:mo>
                                  <mml:mo>=</mml:mo>
                                  <mml:mi mathvariant="italic">Dup</mml:mi>
                                </mml:mrow>
                              </mml:mtd>
                            </mml:mtr>
                          </mml:mtable>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
              </mml:math>
            </inline-formula>
          </p>
        </list-item>
        <list-item>
          <p>Since for both <inline-formula id="IE597"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM512" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> adds the losses, plus the minimum of <inline-formula id="IE598"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM513" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE599"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM514" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for each child <inline-formula id="IE600"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM515" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, we see that <inline-formula id="IE601"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM516" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p>• If <inline-formula id="IE602"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM517" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE603"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM518" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then no additional cost is required on the
<inline-formula id="IE604"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM519" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> branch, but a switch is required on <inline-formula id="IE605"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM520" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The minimum possible cost of such a switch is
<inline-formula id="IE606"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM521" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>, and thus using the two claims as the previous case (we
omit the step replacing <inline-formula id="IE607"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM522" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by <inline-formula id="IE608"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM523" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE609"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM524" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by <inline-formula id="IE610"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM525" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, which is implicit by claim 1.1), if <inline-formula id="IE611"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM526" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi></mml:mrow></mml:math></inline-formula>, we have <disp-formula id="E12"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" display="block" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
        </list-item>
      </list>
      <p>and if <inline-formula id="IE613"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM527" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi></mml:mrow></mml:math></inline-formula>, we have <disp-formula id="E11"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" display="block" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mo>δ</mml:mo><mml:mo>+</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Again, the above expressions are considered by the minimization of <inline-formula id="IE615"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM528" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and so <inline-formula id="IE616"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM529" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>• If <inline-formula id="IE617"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM530" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE618"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM531" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, this case is symmetric to the previous one.</p>
      <p>• If <inline-formula id="IE619"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM532" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and If <inline-formula id="IE620"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM533" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then a switch with host <italic toggle="yes">b<sub>x</sub></italic> is
needed on both branches <inline-formula id="IE621"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM534" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE622"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM535" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, if <inline-formula id="IE623"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM536" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi></mml:mrow></mml:math></inline-formula>, we have <disp-formula id="E13"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" display="block" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula>and if <inline-formula id="IE625"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM537" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi></mml:mrow></mml:math></inline-formula>, we hav<italic toggle="yes"><sc>e</sc></italic><disp-formula id="E14"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" display="block" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mo>δ</mml:mo><mml:mo>+</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Again, these are considered in <inline-formula id="IE627"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM538" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and we get <inline-formula id="IE628"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM539" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>In all cases, <inline-formula id="IE629"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM540" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. It remains to show that this holds for <inline-formula id="IE630"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM541" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi></mml:mrow></mml:math></inline-formula>. In this case, a cost of <inline-formula id="IE631"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM542" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> must be counted for the <italic toggle="yes">x</italic> node, plus the
cost for <inline-formula id="IE632"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM543" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> losses by claim 1.2. Next, we consider all values of
<inline-formula id="IE633"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM544" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE634"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM545" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>• if <inline-formula id="IE635"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM546" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then as we argued <disp-formula id="E15"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
      <p>The latter expression is among the expressions that <inline-formula id="IE637"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM547" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> minimizes and thus <inline-formula id="IE638"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM548" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>• if <inline-formula id="IE639"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM549" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then since <italic toggle="yes">x</italic> is an EGTcopy event, one of
the <inline-formula id="IE640"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM550" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE641"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM551" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> branches must switch to <inline-formula id="IE642"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM552" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, then switch back to <italic toggle="yes">b<sub>x</sub></italic>,
implying a an EGTcut from <inline-formula id="IE643"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM553" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to <italic toggle="yes">b<sub>x</sub></italic> of cost <inline-formula id="IE644"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM554" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. In this situation, <disp-formula id="E9"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" display="block" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula>which is considered among the expressions minimized by
<inline-formula id="IE645"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM555" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Again, <inline-formula id="IE646"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM556" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>• if <inline-formula id="IE647"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM557" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then one of the <inline-formula id="IE648"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM558" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE649"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM559" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> branches stays in <italic toggle="yes">b<sub>x</sub></italic>, and thus
must switch to <inline-formula id="IE650"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM560" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for a cost of <inline-formula id="IE651"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM561" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. In this situation, <disp-formula id="E10"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" display="block" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula>which is considered among the expressions minimized by
<inline-formula id="IE652"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM562" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Again, <inline-formula id="IE653"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM563" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>In every possible case, <inline-formula id="IE654"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM564" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>We must now prove the complementary bound, i.e. that <inline-formula id="IE655"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM565" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Let <inline-formula id="IE656"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM566" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Dup</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE657"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM567" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. If <italic toggle="yes">e</italic> = <italic toggle="yes">Spe</italic>, the
expression <inline-formula id="IE658"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM568" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> corresponds to making <italic toggle="yes">x</italic> a speciation
(which is possible since we check that neither of <inline-formula id="IE659"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM569" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> nor <inline-formula id="IE660"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM570" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mi>s</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> holds) and adding the minimum number of mandatory losses on
<inline-formula id="IE661"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM571" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE662"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM572" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Let <inline-formula id="IE663"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM573" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> that minimizes <inline-formula id="IE664"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM574" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and define <italic toggle="yes">b<sub>r</sub></italic> for
<italic toggle="yes">x<sub>r</sub></italic> analogously. Thus consider the reconciliation
<inline-formula id="IE665"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM575" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> in which <italic toggle="yes">x</italic> is a speciation, on which we
graft the <inline-formula id="IE666"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM576" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> mandatory losses on <inline-formula id="IE667"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM577" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE668"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM578" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and then, for each of <italic toggle="yes">b<sub>l</sub></italic> or
<italic toggle="yes">b<sub>r</sub></italic> that differs from <italic toggle="yes">b<sub>x</sub></italic>, adds
an EGTcut on the corresponding branch. Then, for <inline-formula id="IE669"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM579" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> subtree, take an optimal reconciliation <inline-formula id="IE670"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM580" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE671"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM581" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and for the <inline-formula id="IE672"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM582" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> subtree, take the optimal reconciliation <inline-formula id="IE673"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM583" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE674"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM584" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. By induction, <inline-formula id="IE675"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM585" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE676"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM586" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are of costs <inline-formula id="IE677"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM587" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE678"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM588" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> respectively. Since all optimal reconciliations use the
LCA-mapping, such a reconciliation is valid and its cost is as defined in <inline-formula id="IE679"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM589" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. It follows that <inline-formula id="IE680"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM590" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Spe</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (the latter inequality owing to the optimality of
<inline-formula id="IE681"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM591" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula>).</p>
      <p>If <italic toggle="yes">e</italic> = <italic toggle="yes">Dup</italic>, the argument is exactly the same, except
that to construct <inline-formula id="IE682"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM592" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, we make <italic toggle="yes">x</italic> a duplication and add
<inline-formula id="IE683"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM593" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> losses instead.</p>
      <p>Finally, assume that <italic toggle="yes">e</italic> = <italic toggle="yes">EGTcopy</italic>. It is not hard to see
that each expression that <inline-formula id="IE684"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM594" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> may choose when minimizing corresponds to a valid
reconciliation. Indeed, consider the reconciliation <inline-formula id="IE685"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM595" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE686"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM596" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>e</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi></mml:mrow></mml:math></inline-formula> for a cost of <inline-formula id="IE687"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM597" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>τ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. We add <inline-formula id="IE688"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM598" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> mandatory losses on the <inline-formula id="IE689"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM599" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE690"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM600" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> branches. Then, the first two cases of the minimization in
<inline-formula id="IE691"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM601" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> correspond to having no additional switch needed, and hence
we can use the optimal reconciliation for <inline-formula id="IE692"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM602" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE693"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM603" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. The third case corresponds to having both
<italic toggle="yes">x<sub>l</sub></italic> and <italic toggle="yes">x<sub>r</sub></italic> mapped to
<italic toggle="yes">b<sub>x</sub></italic>, in which case we can choose to apply the EGTcopy on
<inline-formula id="IE694"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM604" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, but need to switch back for a cost of <inline-formula id="IE695"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM605" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. The last case corresponds to having both
<italic toggle="yes">x<sub>l</sub></italic> and <italic toggle="yes">x<sub>r</sub></italic> mapped to
<inline-formula id="IE696"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM606" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, in which case the EGTcopy applies one switch, and we add
an EGTcut for the other switch of cost <inline-formula id="IE697"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM607" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>ρ</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
      <p>Since each possible case represents the cost of a valid reconciliation <inline-formula id="IE698"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM608" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, we get <inline-formula id="IE699"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM609" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">EGTcopy</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus for every possible value of <italic toggle="yes">e</italic>, we
have <inline-formula id="IE700"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM610" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>To conclude, the two complementary bounds show that <inline-formula id="IE701"><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="IM611" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <sub><bold>□</bold></sub></p>
      <fig position="anchor" id="btab328-F5">
        <label>Fig. A1.</label>
        <caption>
          <p>DLE-Reconciliations obtained forMitoCOG0005, MitoCOG0051 and MitoCOG0053 with the
EndoRex scores settings <italic toggle="yes">S</italic>1, <italic toggle="yes">S</italic>2, <italic toggle="yes">S</italic>3,
<italic toggle="yes">S</italic>4 and <italic toggle="yes">S</italic>5. The blue part of the tree indicates
that the genetic material is located in the mitochondrion, while the red part
indicates location in the nucleus. The shape of an internal node represents its
associated event, as represented in <xref rid="btab328-F1" ref-type="fig">Figure 1</xref> (circle for a speciation, rectangle for a duplication and triangle
for an EGT event). Loss events are not represented. Genes are formatted as follow:
[species name]__[gene-encoding location]__[gene id]. Moreover, 0 indicates a location
in the mitochondrion, while 1 indicates a location in the nucleus</p>
        </caption>
        <graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="btab328f5" position="float"/>
      </fig>
    </app>
  </app-group>
</back>
