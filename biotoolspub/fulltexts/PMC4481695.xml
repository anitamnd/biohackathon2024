<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4481695</article-id>
    <article-id pub-id-type="pmid">25649622</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btv071</article-id>
    <article-id pub-id-type="publisher-id">btv071</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Reference-based compression of short-read sequences using path encoding</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Kingsford</surname>
          <given-names>Carl</given-names>
        </name>
        <xref ref-type="aff" rid="btv071-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="btv071-COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Patro</surname>
          <given-names>Rob</given-names>
        </name>
        <xref ref-type="aff" rid="btv071-AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
      <aff id="btv071-AFF1"><sup>1</sup>Department of Computational Biology, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA and <sup>2</sup>Department of Computer Science, Stony Brook University, Stony Brook, NY 11794-4400, USA</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btv071-COR1">*To whom correspondence should be addressed.</corresp>
      <fn id="FN1">
        <p>Associate Editor: Ivo Hofacker</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>6</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>02</day>
      <month>2</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>02</day>
      <month>2</month>
      <year>2015</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>31</volume>
    <issue>12</issue>
    <fpage>1920</fpage>
    <lpage>1928</lpage>
    <history>
      <date date-type="received">
        <day>23</day>
        <month>7</month>
        <year>2014</year>
      </date>
      <date date-type="rev-recd">
        <day>16</day>
        <month>1</month>
        <year>2015</year>
      </date>
      <date date-type="accepted">
        <day>29</day>
        <month>1</month>
        <year>2015</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2015. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2015</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<uri xlink:type="simple" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</uri>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation</bold>: Storing, transmitting and archiving data produced by next-generation sequencing is a significant computational burden. New compression techniques tailored to short-read sequence data are needed.</p>
      <p><bold>Results</bold>: We present here an approach to compression that reduces the difficulty of managing large-scale sequencing data. Our novel approach sits between pure reference-based compression and reference-free compression and combines much of the benefit of reference-based approaches with the flexibility of <italic>de novo</italic> encoding. Our method, called path encoding, draws a connection between storing paths in de Bruijn graphs and context-dependent arithmetic coding. Supporting this method is a system to compactly store sets of kmers that is of independent interest. We are able to encode RNA-seq reads using 3–11% of the space of the sequence in raw FASTA files, which is on average more than 34% smaller than competing approaches. We also show that even if the reference is very poorly matched to the reads that are being encoded, good compression can still be achieved.</p>
      <p><bold>Availability and implementation</bold>: Source code and binaries freely available for download at <ext-link ext-link-type="uri" xlink:href="http://www.cs.cmu.edu/~ckingsf/software/pathenc/">http://www.cs.cmu.edu/∼ckingsf/software/pathenc/</ext-link>, implemented in Go and supported on Linux and Mac OS X.</p>
      <p><bold>Contact</bold>: <email>carlk@cs.cmu.edu</email>.</p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btv071/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>The size of short-read sequence collections is often a stumbling block to rapid analysis. Central repositories such as the NIH Sequence Read Archive (SRA; <ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/sra">http://www.ncbi.nlm.nih.gov/sra</ext-link>) are enormous and rapidly growing. The SRA now contains 2.5 petabases of DNA and RNA sequence information, and due to its size, it cannot be downloaded in its entirety by anyone except those with enormous resources. When select experiments are downloaded, the local storage burden can be high, limiting large-scale analysis to those with large computing resources available. Use of cloud computing also suffers from the data size problem: often transmitting the data to the cloud cluster represents a significant fraction of the cost. Data sizes also hamper collaboration between researchers at different institutions, where shipping hard disks is still a reasonable mode of transmission. Local storage costs inhibit preservation of source data necessary for reproducibility of published results.</p>
    <p>Compression techniques that are specialized to short-read sequence data can help to ameliorate some of these difficulties. If data sizes can be made smaller without loss of information, transmission and storage costs will correspondingly decrease. While general compression is a long-studied field, biological sequence compression—though studied somewhat before short-read sequencing (e.g. <xref rid="btv071-B11" ref-type="bibr">Cherniavsky and Ladner, 2004</xref>; <xref rid="btv071-B29" ref-type="bibr">Matsumoto <italic>et al.</italic>, 2000</xref>)—is still a young field that has become more crucial as data sizes have outpaced increases in storage capacities. In order to achieve compression beyond what standard compressors can achieve, a compression approach must be tailored to the specific data type, and it is likely that different compression approaches are warranted even for different short-read experimental settings such as metagenomic, RNA-seq or genome assembly applications.</p>
    <p>Here, we present a new compression algorithm for collections of RNA-seq reads that outperforms existing compression schemes. RNA-seq experiments are extremely common, and because they are repeated for many different conditions, the number of future experiments is nearly unbounded. Among the SRA’s 2500 terabases, there are over 72 304 experiments labeled ‘RNA-seq’ that contain short-read sequences of expressed transcripts. While the compression technique we describe here was motivated by, and optimized for, RNA-seq data, it will work for any type of short read data.</p>
    <p>Existing short-read compression approaches generally fall into categories: reference-based schemes (<xref rid="btv071-B9" ref-type="bibr">Campagne <italic>et al.</italic>, 2013</xref>; <xref rid="btv071-B17" ref-type="bibr">Fritz <italic>et</italic>
<italic>al.</italic>, 2011</xref>; <xref rid="btv071-B27" ref-type="bibr">Li <italic>et</italic>
<italic>al.</italic>, 2014</xref>) attempt to compress reads by aligning them to one or more known reference sequences and recording edits between the read and its mapped location in the reference. <italic>De novo</italic> compression schemes (<xref rid="btv071-B1" ref-type="bibr">Adjeroh <italic>et</italic>
<italic>al.</italic>, 2002</xref>; <xref rid="btv071-B2" ref-type="bibr">Bhola <italic>et</italic>
<italic>al.</italic>, 2011</xref>; <xref rid="btv071-B4" ref-type="bibr">Bonfield and Mahoney, 2013</xref>; <xref rid="btv071-B5" ref-type="bibr">Brandon <italic>et</italic>
<italic>al.</italic>, 2009</xref>; <xref rid="btv071-B7" ref-type="bibr">Burriesci <italic>et</italic>
<italic>al.</italic>, 2012</xref>; <xref rid="btv071-B12" ref-type="bibr">Cox <italic>et</italic><italic> al.</italic>, 2012</xref>; <xref rid="btv071-B15" ref-type="bibr">Deorowicz and Grabowski, 2011</xref>; <xref rid="btv071-B18" ref-type="bibr">Hach <italic>et al.</italic>, 2012</xref>; <xref rid="btv071-B21" ref-type="bibr">Jones <italic>et al.</italic>, 2012</xref>; <xref rid="btv071-B23" ref-type="bibr">Kozanitis <italic>et</italic>
<italic>al.</italic>, 2011</xref>; <xref rid="btv071-B34" ref-type="bibr">Popitsch and von Haeseler, 2013</xref>; <xref rid="btv071-B35" ref-type="bibr">Rajarajeswari and Apparao, 2011</xref>; <xref rid="btv071-B39" ref-type="bibr">Tembe <italic>et al.</italic>, 2010</xref>) attempt to compress without appeal to a reference. SCALCE (<xref rid="btv071-B18" ref-type="bibr">Hach <italic>et</italic>
<italic>al.</italic>, 2012</xref>) is one of the most effective <italic>de novo</italic> compressors. It works by reordering reads within the FASTA file to boost the compression of general purpose compressors.</p>
    <p>Reference-based schemes require a shared reference to be transmitted between all parties who want to decode the data. Most reference-based schemes (e.g. <xref rid="btv071-B9" ref-type="bibr">Campagne <italic>et</italic>
<italic>al.</italic>, 2013</xref>; <xref rid="btv071-B17" ref-type="bibr">Fritz <italic>et</italic>
<italic>al.</italic>, 2011</xref>; <xref rid="btv071-B21" ref-type="bibr">Jones <italic>et</italic><italic> al.</italic>, 2012</xref>; <xref rid="btv071-B27" ref-type="bibr">Li <italic>et </italic><italic>al.</italic>, 2014</xref>) focus on compressing alignments between the reads and a set of reference sequences. As such, they work by compressing BAM files, which are the result of alignment tools such as Bowtie (<xref rid="btv071-B24" ref-type="bibr">Langmead <italic>et</italic>
<italic>al.</italic>, 2009</xref>). The most-used such compression tool is CRAM (<xref rid="btv071-B17" ref-type="bibr">Fritz <italic>et</italic>
<italic>al.</italic>, 2011</xref>). The limitation of these approaches is that they must encode information in the BAM file that can be recreated by re-running the alignment tool. In fact, such BAM compressors may increase the raw size of the data since all the alignment information must be preserved. Another reference-based compressor, fastqz (<xref rid="btv071-B4" ref-type="bibr">Bonfield and Mahoney, 2013</xref>), attempts to compress sequences directly using its own alignment scheme without first creating a BAM file.</p>
    <p>We present a scheme that lies somewhat in the middle of these two extremes: we exploit a shared reference—a compressed transcriptome—but we do no aligning. The reference serves only to generate a statistical, generative model of reads that is then employed in a fixed-order context, adaptive arithmetic coder. The coder is adaptive in the sense that as reads are encoded, the model is updated in such a way that the decoder can reconstruct the updates without any additional information beyond the initial compressed transcriptome. In this way, if the read set differs significantly from the reference transcriptome, the statistical model will eventually converge on this new distribution, resulting in improved compression. We present a scheme that updates the model in a way that is robust to sequencing errors, which are a common source of poor compression. By sitting between pure reference-based compression and <italic>de novo</italic> compression, the path encoding scheme gains flexibility and generality: the same scheme works reasonably well even when the provided reference is a poor match for the sample but is significantly improved with better shared data.</p>
    <p>The arithmetic coder uses a fixed-length context to select a conditional distribution for the following base. This scheme is efficient but has the drawback that at the start of each read, there is insufficient context to apply the model. We solve this problem with a new approach. We encode the starts of all the reads in a single, compact data structure called a bit tree. The bit tree is a general scheme for storing sets of small, fixed length (say, &lt;30 nt) sequences. It is a simplification of other serial encoding schemes such as S-trees (<xref rid="btv071-B14" ref-type="bibr">de Jonge <italic>et</italic>
<italic>al.</italic>, 1994</xref>) and sequence multiset encoding (<xref rid="btv071-B38" ref-type="bibr">Steinruecken, 2014</xref>).</p>
    <p>Taken together, the bit tree for encoding the read starts and the adaptive, context-aware arithmetic coding for the remainder of the read, produce files that are on average &lt;66% of the size of those produced by a current state-of-the-art <italic>de novo</italic> encoder, SCALCE (<xref rid="btv071-B18" ref-type="bibr">Hach <italic>et</italic>
<italic>al.</italic>, 2012</xref>). The size reduction of these files is often larger than the space needed to transmit the reference, and thus the overhead of transmitting the reference is recovered immediately. Our approach also produces smaller files compared with reference-based schemes. Its files are on average 33% the size of those produced by CRAM (<xref rid="btv071-B17" ref-type="bibr">Fritz <italic>et</italic>
<italic>al.</italic>, 2011</xref>) and on average 59% the size of those produced by fastqz (<xref rid="btv071-B4" ref-type="bibr">Bonfield and Mahoney, 2013</xref>). These are very large improvements in compression, a field where improvements of several percent are often difficult to achieve.</p>
    <p>We call the resulting approach <italic>path encoding</italic> because, in the methods below, we draw a parallel between the design of our arithmetic coder and the problem of efficiently encoding paths in directed graphs, which is a problem that arises in genome assembly (<xref rid="btv071-B33" ref-type="bibr">Pevzner <italic>et</italic>
<italic>al.</italic>, 2001</xref>) and metagenomic analyses (<xref rid="btv071-B19" ref-type="bibr">Iqbal <italic>et</italic>
<italic>al.</italic>, 2012</xref>). The bit tree scheme for storing sets of short sequences (kmers) is of independent interest as the need to transmit and store collections of kmers is also increasingly common in de Bruijn-graph-based genome assembly, metagenomic classification (<xref rid="btv071-B42" ref-type="bibr">Wood and Salzberg, 2014</xref>) and other analyses (<xref rid="btv071-B32" ref-type="bibr">Patro <italic>et</italic>
<italic>al.</italic>, 2014</xref>).</p>
  </sec>
  <sec>
    <title>2 Algorithm</title>
    <sec sec-type="intro">
      <title>2.1 Overview</title>
      <p>Our compression approach is composed of several different encoding techniques that are applied to the input reads as a set. First, the reads are reverse complemented based on a heuristic to determine which orientation matches the initial reference better (Section 2.6). The initial <italic>k</italic> letters of each read are stored in a bit tree data structure along with the counts of their occurrences (Section 2.3). These initial <italic>k</italic> letters of each read are called the read <italic>head</italic>. The reads are then reordered to place reads with the same heads next to one another. Finally, the remainder of each read (called the read <italic>tail</italic>) is encoded using an adaptive arithmetic coding scheme (Section 2.4) inspired by the path encoding problem (Section 2.2).</p>
    </sec>
    <sec>
      <title>2.2 The path encoding problem</title>
      <p>We can capture much of the information in a reference transcriptome using a graph <italic>G</italic> that has a node for every kmer that occurs in a transcript and an edge (<italic>u</italic>, <italic>v</italic>) between any two kmers <italic>u</italic> and <italic>v</italic> if <italic>v</italic> follows <italic>u</italic>, overlapping it by <italic>k</italic> − 1 characters, in some transcript. This is a de Bruijn graph, except it is derived from several strings rather than a single string. A read <italic>r</italic>, if its sequence occurs in the transcriptome, corresponds to a path in <italic>G</italic>, and conversely there is only one path in <italic>G</italic> that spells out <italic>r</italic>. Therefore, <italic>r</italic> can be encoded by specifying a path in <italic>G</italic> by listing a sequence of nodes. This leads to a very general problem:</p>
      <p>Problem (Path encoding) <italic>Given a directed graph G</italic>, <italic>encode a collection of paths </italic><inline-formula><mml:math id="MM1"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <italic>each given as an ordered sequence of nodes of G</italic>, <italic>using as little space as possible.</italic></p>
      <p>Our compression scheme uses one system for encoding the first node of each read path <italic>P<sub>i</sub></italic> (the read head) and another system for encoding the remaining nodes in the path (the read tails). We describe each below.</p>
    </sec>
    <sec>
      <title>2.3 Encoding the starts of the reads with a bit tree</title>
      <p>Let <italic>T</italic> be the kmer trie defined as follows. <italic>T</italic> has a root node that has four children, and each edge from the root node to a child is labeled by a different nucleotide in <inline-formula><mml:math id="MM2"><mml:mrow><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Each of these children themselves has four similar children, with edges for each of the nucleotides. This continues until every path from the root to a leaf node has exactly <italic>k</italic> edges on it. In this way, a complete, 4-ary tree of depth <italic>k</italic> is constructed such that any path from the root to a leaf spells out a unique kmer, and every possible kmer corresponds to some such path in <italic>T</italic>. The set of kmers <italic>K</italic> that appear at the start of some read corresponds to a subset of those possible paths, and we can construct a subtree <italic>T</italic><sub>|</sub><italic><sub>K</sub></italic> from <italic>T</italic> by removing all edges that are not used when spelling out any kmer in <italic>K</italic>. Knowing <italic>T</italic><sub>|</sub><italic><sub>K</sub></italic> allows us to reconstruct <italic>K</italic> precisely: <italic>K</italic> is those kmers spelled out by some path from the root to a leaf in <italic>T</italic><sub>|</sub><italic><sub>K</sub></italic>.</p>
      <p><italic>T</italic><sub>|</sub><italic><sub>K</sub></italic> can be encoded compactly by performing a depth-first search starting at the root, visiting each child of every node in a fixed order (say A then C then T then G) and emitting a 1 bit whenever an edge is traversed for the first time and a 0 bit if we attempt to go to a child that does not exist. This bit stream is then compressed using a general purpose compressor, gzip (Gailly, J. and Adler, M. <ext-link ext-link-type="uri" xlink:href="http://www.gzip.org">http://www.gzip.org</ext-link>). <italic>T</italic><sub>|</sub><italic><sub>K</sub></italic> can be reconstructed from this stream of 0s and 1s by performing a depth-first search on <italic>T</italic> traversing an edge whenever a 1 bit encountered but pruning subtrees whenever a 0 bit is read. <italic>K</italic> is then reconstructed as the set of kmers corresponding to the leaves that we encountered.</p>
      <p>The trie <italic>T</italic> never need be actually built to perform the encoding or the decoding. Rather, a sorted list of the kmers is sufficient for simulating the traversal of the trie to encode, and decoding only ever needs to implicitly construct the part of the trie that is on the current depth-first search path. In practice, encoding and decoding of very large collections of kmers takes very little time or memory.</p>
      <p>The same kmer may start many reads, but the encoding of <italic>T</italic><sub>|</sub><italic><sub>K</sub></italic> only records which kmers were used, not the number of times each was used. To store this, we write out a separate file called the count file with the count of each kmer in <italic>T</italic><sub>|</sub><italic><sub>K</sub></italic> in the order that the kmers will be visited during the decoding of <italic>T</italic><sub>|</sub><italic><sub>K</sub></italic>. This file stores counts as space-separated ASCII integers, and the entire file is compressed using the gzip algorithm. <italic>T</italic><sub>|</sub><italic><sub>K</sub></italic> also does not record the order in which the kmers were used as read heads, so we reorder the read set to put reads with the same head adjacent to one another in the same order as their starts will be encountered during the decoding of <italic>T</italic><sub>|</sub><italic><sub>K</sub></italic>.</p>
      <p>This data structure is essentially the same as an S-tree (<xref rid="btv071-B14" ref-type="bibr">de Jonge <italic>et</italic>
<italic>al.</italic>, 1994</xref>) specialized to kmer tries, except that no data is stored at the leaves, and because the length of every sequence is a known constant <italic>k</italic> we need not store any information about the (always nonexistent) children of nodes at depth <italic>k</italic>. It is a simplification of Steinrucken (<xref rid="btv071-B38" ref-type="bibr">Steinruecken, 2014</xref>) since counts are stored only for the leaves.</p>
    </sec>
    <sec>
      <title>2.4 Arithmetic coding of read tails</title>
      <p>Arithmetic coding (<xref rid="btv071-B30" ref-type="bibr">Moffat <italic>et</italic>
<italic>al.</italic>,1998</xref>; <xref rid="btv071-B36" ref-type="bibr">Rissanen and Langdon, 1979</xref>; <xref rid="btv071-B41" ref-type="bibr">Witten <italic>et</italic>
<italic>al.</italic>, 1987</xref>) compresses a message by encoding it as a single, high-precision number between 0 and 1. During the encoding, an interval [<italic>a</italic>, <italic>b</italic>] is maintained. At the start, this interval is [0, 1], and at each step of the encoding, it is reduced to a subinterval of the current interval. At the end, a real number within the final interval is chosen to represent entire message. The interval is updated based on the probability of observing each symbol in a particular context. For path encoding, we store a probability distribution <inline-formula><mml:math id="MM3"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> associated with each node <italic>u</italic> in <italic>G</italic> on its outgoing edges such that <inline-formula><mml:math id="MM4"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> gives an estimate for the probability that edge (<italic>u</italic>, <italic>v</italic>) will be the one used by a path leaving <italic>u</italic>. We also give the outgoing edges of <italic>u</italic> an arbitrary, fixed order <inline-formula><mml:math id="MM5"><mml:mrow><mml:mo>〈</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>d</italic>(<italic>u</italic>) is the out-degree of <italic>u</italic> (when encoding DNA or RNA, <italic>d</italic>(<italic>u</italic>) is always 4). Using this ordering, we can compute the cumulative distribution <inline-formula><mml:math id="MM6"><mml:mrow><mml:mi>p</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="false"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The probability distributions <inline-formula><mml:math id="MM7"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each node in <italic>G</italic> represent the statistical generative model that encodes the information about which sequences are more or less likely.</p>
      <p>Let <inline-formula><mml:math id="MM8"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> be a sequence of nodes of the path <italic>P<sub>i</sub></italic> that we are encoding. The first node <italic>u</italic><sub>1</sub> is encoded using the bit tree approach described above. Suppose we have encoded <inline-formula><mml:math id="MM10"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the current interval is <inline-formula><mml:math id="MM11"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. To encode <italic>u<sub>j</sub></italic>, we update the interval to:
<disp-formula id="btv071-M1"><label>(1)</label><mml:math id="MM12"><mml:mrow><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>p</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
      <p>This chooses a subinterval of <inline-formula><mml:math id="MM13"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> that corresponds to the interval for <italic>u<sub>j</sub></italic> in <inline-formula><mml:math id="MM14"><mml:mrow><mml:mi>p</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The intuition for why this approach achieves compression is that it requires fewer bits to specify a number that falls in a high probability (large) interval than in a low probability (small) interval. If we choose the distributions <inline-formula><mml:math id="MM15"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> well so that common edges are given high probability, we will use few bits to encode frequently occurring symbols.</p>
      <p>In practice, <xref ref-type="disp-formula" rid="btv071-M1">Equation (1)</xref> is not used directly because it would require infinite precision, real arithmetic which is not available on digital computers. Rather, an approach (<xref rid="btv071-B30" ref-type="bibr">Moffat <italic>et</italic>
<italic>al.</italic>, 1998</xref>) that uses only finite, small precision, integer arithmetic and that rescales the current interval when necessary is used. This practical arithmetic coding has achieved state-of-the-art compression in many applications.</p>
    </sec>
    <sec>
      <title>2.5 Initializing and updating the sequence generative model</title>
      <p>The probability distributions <inline-formula><mml:math id="MM16"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each node <italic>u</italic> specify what we consider to be a high-probability sequence (which is equivalent to a high probability path). It is here that we can use shared, prior information to influence the encoding. These distributions need not be constant—so long as the decoder can reconstruct any changes made to the distributions, we can adapt them to observed data as we see it.</p>
      <p>We derive <inline-formula><mml:math id="MM17"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using counts <inline-formula><mml:math id="MM18"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which are set according to:
<disp-formula id="btv071-M2"><label>(2)</label><mml:math id="MM19"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow><mml:mn>10</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if </mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mtext> occurs&amp; in&amp; the&amp; reference</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mn>10</mml:mn><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if </mml:mtext><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mtext> and </mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>∉</mml:mo></mml:menclose><mml:mtext>the reference</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
where <italic>n<sub>uv</sub></italic> is the number of times edge (<italic>u</italic>, <italic>v</italic>) was observed in the read paths that have been encoded so far. This expression for <inline-formula><mml:math id="MM20"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> requires an edge (<italic>u</italic>, <italic>v</italic>) to either occur in the reference or be used at least twice in a read path before it is given the larger weight. This is to reduce the impact of sequencing errors that are frequent, but unlikely to occur twice (the +2 makes kmers in the reference start as if we had seen them twice, and this is the only place where the reference is used). The 1 in the third case of <xref ref-type="disp-formula" rid="btv071-M2">Equation (2)</xref> acts as a pseudocount for edges that have not yet been observed, and the 10 in the first two cases sets the relative weight of observations versus this pseudocount (changing this weight within a reasonable range has little effect on the compression—see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btv071/-/DC1">Supplementary Table 6</ext-link>). We compute <inline-formula><mml:math id="MM21"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mstyle displaystyle="false"><mml:munder><mml:mo>∑</mml:mo><mml:mi>w</mml:mi></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>During the encoding of reads, it is possible that we encounter a kmer that we have never seen before. In this case, we encode the base following this kmer using a default probability distribution derived from a distinct count distribution <inline-formula><mml:math id="MM22"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that gives the number of times we encoded base <italic>b</italic> using this default distribution. After the first time we see a new kmer, we add it to the graph <italic>G</italic> and on subsequent observations, we treat it using <xref ref-type="disp-formula" rid="btv071-M2">Equation (2)</xref>.</p>
      <p>An alternative way to view the arithmetic coding scheme above is that the probability distribution is provided by a fixed-order (<italic>k</italic>) Markov chain for which the transition probabilities are updated as edges are traversed. The <italic>k</italic> preceding bases provide a context for estimating the probability of the next base. The read heads provide the initial context for the Markov chain. This view also motivates the need to handle sequence errors and (less common) sequence variants effectively, because an error in a read will produce an incorrect context for <italic>k</italic> bases, resulting in decreased compression.</p>
    </sec>
    <sec>
      <title>2.6 Other considerations</title>
      <p>The reference model only includes the forward strand of the transcript but, in an unstranded RNA-seq protocol, reads may come from either strand. We implement a heuristic for selecting whether or not to reverse complement the input read. To do this, we estimate whether the forward read <italic>r</italic> or its reverse complement <italic>rc</italic>(<italic>r</italic>) will produce a smaller encoding by counting the number of times adjacent kmers in the read are both present in the reference for both <italic>r</italic> and <italic>rc</italic>(<italic>r</italic>). If <italic>rc</italic>(<italic>r</italic>) has a higher number of observed transitions in the statistical model, we reverse complement the read before encoding. The decision to reverse complement reads is made for all reads at the beginning of compression before any reads are encoded and before the read starts are encoded. We often do not need to store whether a read was flipped or not since in an unstranded protocol the strand that was sequenced and recorded in the file was arbitrary to begin with. However, if it is important to store the string in the direction it was originally specified, a single bit per read is recorded indicating whether the read was reverse complemented.</p>
      <p>Due to biases in RNA-seq, and due to pooling of technical replicates, it is often the case that the exact same read sequence is listed more than once in a read file. To more compactly encode this situation, we check whether the set of reads that start with a given kmer <italic>m</italic> consists entirely of <italic>d</italic> duplicates of the same sequence. In this case, we record the number of reads associated with <italic>m</italic> in the count file as −<italic>d</italic> rather than <italic>d</italic>, and we only store one of the tails in the path file.</p>
      <p>To simplify the statistical model, any Ns that appear in the input file are translated to As upon initial input. This is a strategy taken by other compressors (<xref rid="btv071-B18" ref-type="bibr">Hach <italic>et</italic>
<italic>al.</italic>, 2012</xref>) because the lowest quality value always indicates an N and all Ns must have the lowest quality value. If quality scores are not stored with the sequences and the locations of the Ns are needed, a separate compressed file is output with their locations.</p>
      <p>Because reads are reordered, the two ends of a mate pair cannot be encoded separately if pairing information is to be preserved. Instead, when dealing with paired-ended RNA-seq, we merge the ends of the mate pair into a longer read, encoding this ‘read’ as described above. If the library was constructed with the mate pairs from opposite strands, one strand is reverse complemented before merging so that the entire sequence comes from the same strand in order to better match the generative model described above. This transformation can be undone when the reads are decoded.</p>
    </sec>
    <sec>
      <title>2.7 Implementation</title>
      <p>Software, called kpath, implementing the path encoding and decoding method was written in the Go programming language, using a translation of the arithmetic coding functions of <xref rid="btv071-B30" ref-type="bibr">Moffat <italic>et al</italic>. (1998)</xref>. The software is parallelized and can use several threads to complete various steps of the encoding and decoding algorithms simultaneously. Parallelization is used for the input, output and preprocessing steps, but arithmetic coding itself is not easily parallelizable because information from all previous reads may be needed to decode the current read. To limit memory usage, the counts <inline-formula><mml:math id="MM23"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> described above are stored in 8-bit fields with a mechanism to hold the few kmers with counts <inline-formula><mml:math id="MM24"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>255</mml:mn></mml:mrow></mml:math></inline-formula>. This results in a small loss of compression effectiveness compared with 32-bit fields but large improvements in running times for the larger files.</p>
    </sec>
    <sec sec-type="methods">
      <title>2.8 Comparison with other methods</title>
      <p>SCALCE (<xref rid="btv071-B18" ref-type="bibr">Hach <italic>et</italic>
<italic>al.</italic>, 2012</xref>) version 2.7 was run with its default parameters, using <monospace>-r</monospace> for paired-end read sets. The file sizes reported are the sizes of the .<monospace>scalcer</monospace> files it produces, which encode the sequence data (except the positions of the Ns). The program fqzcomp (<xref rid="btv071-B4" ref-type="bibr">Bonfield and Mahoney, 2013</xref>) version 4.6 was run using the recommended parameters for Illumina data (<monospace>-n2 -s7+ -b -q3</monospace>). The file sizes used were the sizes of only the portion of its output file that encodes for the sequences, as printed by fqzcomp. Running fqzcomp with <monospace>-s8</monospace> instead of <monospace>-s7+</monospace> produced files that were still larger than SCALCE. For paired-end reads, fqzcomp often achieved better compression if it was provided with a FASTQ file that contained both ends merged into a single read, and so sizes for compressing these files (the same as provided to kpath) were used. Despite this, fqzcomp always produced files that were larger than SCALCE, and so only the SCALCE numbers are reported. Both SCALCE and fqzcomp are <italic>de novo</italic> compressors. Experiments with the <italic>de novo</italic> version of fastqz always produced larger files than fqzcomp and so its results are not reported here. The reference-based version of fastqz (<xref rid="btv071-B4" ref-type="bibr">Bonfield and Mahoney, 2013</xref>) version 1.5 was provided the same reference as used with path encoding (a multi-fasta file with transcripts), processed with the <monospace>fapack</monospace> program. The file sizes reported for fastqz are the sum of the sizes of its output files .<monospace>fxb.zpaq</monospace> and .<monospace>fxa.zpaq</monospace> that encode the sequences (except the Ns).</p>
      <p>CRAM (<xref rid="btv071-B17" ref-type="bibr">Fritz <italic>et</italic>
<italic>al.</italic>, 2011</xref>) is designed for compressing BAM files. To adapt it to compress sequences, read files were aligned with Bowtie (<xref rid="btv071-B24" ref-type="bibr">Langmead <italic>et</italic>
<italic>al.</italic>, 2009</xref>) using <monospace>–best -q -y –</monospace><monospace>sam</monospace> to an index built from the same transcriptome as used for path encoding. Quality values, sequence names and sequence descriptions were stripped from the file (fields 1 and 11), MAPQ values were all set to 255, and the RNEXT and PNEXT fields were set to ‘*’ and ‘0’ respectively. The resulting simplified SAM file was converted to a sorted BAM file using samtools (<xref rid="btv071-B26" ref-type="bibr">Li <italic>et</italic>
<italic>al.</italic>, 2009</xref>). This file was then encoded using CRAM, and the reported file size is that of the resulting .<monospace>cram</monospace> file. (Leaving the MAPQ, RNEXT and PNEXT fields unchanged resulted in compressed files of nearly identical size.)</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Path encoding effectively compresses RNA-seq reads</title>
      <p>We selected seven short-read, RNA-seq datasets of various read lengths and number of reads. Both single- and paired-end protocols are represented among the sets. One dataset, SRR037452, was chosen because it is a benchmark dataset for comparing RNA-seq abundance estimation algorithms (e.g. <xref rid="btv071-B32" ref-type="bibr">Patro <italic>et</italic>
<italic>al.</italic>, 2014</xref>; <xref rid="btv071-B37" ref-type="bibr">Roberts and Pachter, 2013</xref>). Three sets related to human embryo development were chosen as a representative set of related experiments that one might consider when investigating a particular biological question. A fifth set represents a larger collection of single-end reads of a human cell line. Finally, to assess the effect of using a human transcriptome as a reference when encoding other species, RNA-seq experiments from <italic>Mus musculus</italic> (SRR689233) and the bacterium <italic>Pseudomonas aeruginosa</italic> (SRR519063) were included. The read sets are a mix of paired- and single-end protocols, with read lengths ranging from 35 to 90 bp. Taken together, these are representative set of RNA-seq read sets.</p>
      <p>Path encoding with <italic>k</italic> = 16 is able to reduce these files to 12–42% of the size that would be achieved if the file was naïvely encoded by representing each base with 2 bits (<xref ref-type="table" rid="btv071-T1">Table 1</xref>). The 2-bit encoding is approximately one-fourth the size of the sequence data represented as ASCII. (It is approximate because the ASCII encoding includes newline characters separating the reads.) Thus, path encoding reduces files to 3–10.5% of the original, raw ASCII encoding. For the human datasets, this is on average 34% smaller than the encoding produced by the SCALCE compression scheme (<xref rid="btv071-B18" ref-type="bibr">Hach <italic>et</italic>
<italic>al.</italic>, 2012</xref>), a recent, highly effective <italic>de novo</italic> compression approach. This is also smaller than the <italic>de novo</italic> compressor fqzcomp (<xref rid="btv071-B4" ref-type="bibr">Bonfield and Mahoney, 2013</xref>), which produces files that are larger than those produced by SCALCE.
<table-wrap id="btv071-T1" position="float"><label>Table 1.</label><caption><p>Compressed sizes (in bytes) using various methods</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Read set</th><th rowspan="1" colspan="1">Org.<xref ref-type="table-fn" rid="btv071-TF1"><sup>a</sup></xref></th><th rowspan="1" colspan="1">S/P<xref ref-type="table-fn" rid="btv071-TF2"><sup>b</sup></xref></th><th rowspan="1" colspan="1">2-Bit</th><th rowspan="1" colspan="1">SCALCE</th><th rowspan="1" colspan="1">fastqz</th><th rowspan="1" colspan="1">CRAM</th><th rowspan="1" colspan="1">PathEnc</th><th rowspan="1" colspan="1">No. Trans.<xref ref-type="table-fn" rid="btv071-TF3"><sup>c</sup></xref></th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">SRR037452 (<xref rid="btv071-B6" ref-type="bibr">Bullard <italic>et al.</italic>, 2010</xref>)</td><td align="char" char="." rowspan="1" colspan="1"><italic>H.s.</italic></td><td align="char" char="." rowspan="1" colspan="1">S</td><td align="char" char="." rowspan="1" colspan="1">102 487 744</td><td align="char" char="." rowspan="1" colspan="1">66 630 706</td><td align="char" char="." rowspan="1" colspan="1">80 465 928</td><td align="char" char="." rowspan="1" colspan="1">156 554 323</td><td align="char" char="." rowspan="1" colspan="1"><bold>43 105 624</bold></td><td align="char" char="." rowspan="1" colspan="1">4.10</td></tr><tr><td rowspan="1" colspan="1">SRR445718 (<xref rid="btv071-B44" ref-type="bibr">Yan <italic>et al.</italic>, 2013</xref>)</td><td align="char" char="." rowspan="1" colspan="1"><italic>H.s.</italic></td><td align="char" char="." rowspan="1" colspan="1">S</td><td align="char" char="." rowspan="1" colspan="1">823 591 625</td><td align="char" char="." rowspan="1" colspan="1">252 989 168</td><td align="char" char="." rowspan="1" colspan="1">238 180 853</td><td align="char" char="." rowspan="1" colspan="1">375 901 891</td><td align="char" char="." rowspan="1" colspan="1"><bold>154 960 810</bold></td><td align="char" char="." rowspan="1" colspan="1">0.98</td></tr><tr><td rowspan="1" colspan="1">SRR490961 (<xref rid="btv071-B44" ref-type="bibr">Yan <italic>et al.</italic>, 2013</xref>)</td><td align="char" char="." rowspan="1" colspan="1"><italic>H.s.</italic></td><td align="char" char="." rowspan="1" colspan="1">S</td><td align="char" char="." rowspan="1" colspan="1">1 228 191 700</td><td align="char" char="." rowspan="1" colspan="1">300 176 711</td><td align="char" char="." rowspan="1" colspan="1">316 478 709</td><td align="char" char="." rowspan="1" colspan="1">518 183 711</td><td align="char" char="." rowspan="1" colspan="1"><bold>170 613 303</bold></td><td align="char" char="." rowspan="1" colspan="1">0.74</td></tr><tr><td rowspan="1" colspan="1">SRR635193 (<xref rid="btv071-B22" ref-type="bibr">Kim <italic>et al.</italic>, 2012</xref>)</td><td align="char" char="." rowspan="1" colspan="1"><italic>H.s.</italic></td><td align="char" char="." rowspan="1" colspan="1">P</td><td align="char" char="." rowspan="1" colspan="1">736 178 787</td><td align="char" char="." rowspan="1" colspan="1">294 524 283</td><td align="char" char="." rowspan="1" colspan="1">272 862 515</td><td align="char" char="." rowspan="1" colspan="1">366 789 369</td><td align="char" char="." rowspan="1" colspan="1"><bold>187 256 974</bold></td><td align="char" char="." rowspan="1" colspan="1">0.90</td></tr><tr><td rowspan="1" colspan="1">SRR1294122 (<xref rid="btv071-B16" ref-type="bibr">Friedli <italic>et al</italic>., 2014</xref>)</td><td align="char" char="." rowspan="1" colspan="1"><italic>H.s.</italic></td><td align="char" char="." rowspan="1" colspan="1">S</td><td align="char" char="." rowspan="1" colspan="1">1 001 574 429</td><td align="char" char="." rowspan="1" colspan="1">299 329 267</td><td align="char" char="." rowspan="1" colspan="1">285 710 714</td><td align="char" char="." rowspan="1" colspan="1">369 774 561</td><td align="char" char="." rowspan="1" colspan="1"><bold>187 808 066</bold></td><td align="char" char="." rowspan="1" colspan="1">0.86</td></tr><tr><td rowspan="1" colspan="1">SRR689233 (<xref rid="btv071-B43" ref-type="bibr">Xue <italic>et al.</italic>, 2013</xref>)</td><td align="char" char="." rowspan="1" colspan="1"><italic>M.m</italic></td><td align="char" char="." rowspan="1" colspan="1">P</td><td align="char" char="." rowspan="1" colspan="1">738 357 525</td><td align="char" char="." rowspan="1" colspan="1">233 812 737</td><td align="char" char="." rowspan="1" colspan="1">266 126 542</td><td align="char" char="." rowspan="1" colspan="1">929 644 204</td><td align="char" char="." rowspan="1" colspan="1"><bold>167 659 551</bold></td><td align="char" char="." rowspan="1" colspan="1">1.46</td></tr><tr><td rowspan="1" colspan="1">SRR519063 (<xref rid="btv071-B40" ref-type="bibr">Winsor <italic>et al.</italic>, 2011</xref>)</td><td align="char" char="." rowspan="1" colspan="1"><italic>P.a</italic></td><td align="char" char="." rowspan="1" colspan="1">P</td><td align="char" char="." rowspan="1" colspan="1">688 509 129</td><td align="char" char="." rowspan="1" colspan="1">100 403 786</td><td align="char" char="." rowspan="1" colspan="1">183 275 880</td><td align="char" char="." rowspan="1" colspan="1">714 193 963</td><td align="char" char="." rowspan="1" colspan="1"><bold>84 642 682</bold></td><td align="char" char="." rowspan="1" colspan="1">6.12</td></tr></tbody></table><table-wrap-foot><fn id="btv071-TF1"><p><sup>a</sup>Organism (H.s., human; M.m., mouse; P.a., <italic>Pseudomonas aeruginosa</italic>).</p></fn><fn id="btv071-TF2"><p><sup>b</sup>P indicates paired-end reads; S indicates single-end reads.</p></fn><fn id="btv071-TF3"><p><sup>c</sup>Number of transmissions before size of the reference is recovered.</p></fn></table-wrap-foot></table-wrap></p>
      <p>When encoding these files, a human reference transcriptome derived from the hg19 build of human genome was used to prime the statistical model. This transcriptome contains 214 294 transcripts and occupies 96 446 089 bytes as a gzipped FASTA file. This reference file is required to decompress any files that were compressed using it, but because the same reference transcriptome can be used by many RNA-seq experiments, the cost of transmitting the reference can be amortized over the many files encoded with it. The cost of transmitting or storing the 92 Mb of the reference can be recovered after &lt;1 to 6.12 transmissions of a compressed file (<xref ref-type="table" rid="btv071-T1">Table 1</xref>, last column). Often the size of the reference transcriptome plus the encoded file is less than the size required by previous pure <italic>de novo</italic> compression schemes—this means that path encoding can also be seen as a very effective <italic>de novo</italic> encoder if the reference is always transmitted with the file, with the option to become a reference-based compressor if several files share the same reference.</p>
      <p>Even though this reference contains only human transcripts, it is still effective when encoding RNA-seq experiments from other organisms. For mouse data (SRR689233), for example, the compression is on par with that achieved for the human datasets. For the very different bacterium <italic>P.</italic>
<italic>aeruginosa</italic> (SRR519063), the compression gain over <italic>de novo</italic> encoding is still substantial (<xref ref-type="table" rid="btv071-T1">Table 1</xref>, last row). Thus, a single reference can provide enough information to effectively encode RNA-seq reads from many organisms, further allowing its size to be amortized across collections of read sets.</p>
      <p>When compared against a recent reference-based encoding scheme, fastqz (<xref rid="btv071-B4" ref-type="bibr">Bonfield and Mahoney, 2013</xref>), path encoding fares well, consistently producing smaller files than the mapping approach taken by fastqz. In contrast to path encoding, using a mismatched reference for fastqz results in files that are larger than if no reference were used at all (<xref ref-type="table" rid="btv071-T1">Table 1</xref>, last 2 rows). This is because nearly no reads map sufficiently well to the reference. This shows that the non-mapping-based reference scheme implemented by path encoding is both more effective and more robust than mapping-based schemes, which require good matches along a read to benefit from the reference and which also spend a lot of their encoding recording the edits between the reference and the mapped read.</p>
      <p>Much of the previous work on reference-based compression has focused on compressing alignment BAM files. The archetypical example of this is CRAM (<xref rid="btv071-B17" ref-type="bibr">Fritz <italic>et</italic>
<italic>al.</italic>, 2011</xref>). BAM files contain more than sequences. They normally include quality values, sequence descriptions, etc. and may contain multiple alignments for each sequence. To fairly compare sequence compression schemes, we generated BAM files with a single, best alignment for each read to the reference transcriptome, and then stripped extraneous fields (including quality values and sequence names) from the resulting BAM file by setting them to the appropriate ‘empty’ value. These streamlined BAM files were then compressed with CRAM (<xref ref-type="table" rid="btv071-T1">Table 1</xref>). In all cases, path encoding produced a much smaller file than CRAM. This is not entirely fair to CRAM, since it attempts to preserve all alignment information in the BAM files, and it also allows for random access to records in compressed file, which path encoding does not. However, for raw compression and transmission, path encoding sequences directly is much more effective than compressing a BAM file. Again, when the reference is mismatched to the sequence (<xref ref-type="table" rid="btv071-T1">Table 1</xref>, last two rows), compression of the CRAM mapping-based approach is reduced substantially.</p>
    </sec>
    <sec>
      <title>3.2 Encoding of the read tails represents the bulk of the compressed file</title>
      <p>A path encoded file consists of several parts (<xref ref-type="fig" rid="btv071-F1">Fig. 1</xref>). The bulk of the space is used to encode the ends of reads using a context-dependent arithmetic coding scheme (see Section 2). The first few characters (here 16) of each read are encoded via a bit tree—a data structure that encodes a set of kmers—along with counts for how many reads begin with each kmer (‘read head counts’ in <xref ref-type="fig" rid="btv071-F1">Fig. 1</xref>). Together, the read tail encoding, the bit tree, and the counts represent the information needed to reconstruct the original reads if we do not care about recording the locations of ‘N’ characters or the orientation of the reads. Since SCALCE and 2-bit encoding also do not record the location of ‘N’s and read orientation is often arbitrary, the sum of the sizes of these three parts are what is reported in <xref ref-type="table" rid="btv071-T1">Table 1</xref>.
<fig id="btv071-F1" position="float"><label>Fig. 1.</label><caption><p><bold>Sizes of the various components of the compressed files.</bold> ‘Read tails’ are the portion of the reads encoded using arithmetic encoding. ‘Bit tree’ gives the storage used by the bit tree for encoding the read starts (the first <italic>k</italic> = 16 letters of each read). ‘Read head counts’ is the space taken to store the number of reads with each start. ‘N locations’ is the space to store the location of input Ns that were changed to As upon encoding. ‘Flipped bits’ gives the space needed to record (in a compressed format) a single bit for each read indicating whether the read was reverse complemented</p></caption><graphic xlink:href="btv071f1p"/></fig></p>
      <p>N locations and the original read orientations can optionally be recovered using the ‘N locations’ and ‘Flipped bits’ parts of the compressed output. The sizes of these later two parts are a tiny fraction of the overall size and so the compression effectiveness does not qualitatively change if their sizes are included (<xref ref-type="fig" rid="btv071-F1">Fig. 1</xref>). While smarter encoding schemes may reduce the size of these parts of the path encoded file [for example by performing a bit-level Burrows-Wheeler transformation (<xref rid="btv071-B8" ref-type="bibr">Burrows and Wheeler, 1994</xref>) of the bit vector], they do not represent a large fraction of the output and so improvements to them will likely have a small effect.</p>
    </sec>
    <sec>
      <title>3.3 Priming the statistical model results in improved compression</title>
      <p>The availability of the reference typically results in a 15–25% reduction in file size for human read sets, a non-trivial gain in compression (<xref ref-type="fig" rid="btv071-F2">Fig. 2</xref>A). For example, for a file with 3.8 gigabases of sequence (SRR1294122), path encoding with the reference produces an encoded file of 0.17 GB, while starting with a uniform, empty statistical model produces a file of 0.22 GB. For non-human data, the gain of using a human reference is naturally smaller. For mouse reads, the reference yields only a <inline-formula><mml:math id="MM25"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>2</mml:mn><mml:mi>%</mml:mi></mml:mrow></mml:math></inline-formula> gain in compression—still a non-trivial size reduction in the context of large files, but much smaller than with a well-matched reference. For the bacterial data, the reference provides little help, but does not hurt compression, unlike the similar situation with mapping-based approaches.
<fig id="btv071-F2" position="float"><label>Fig. 2.</label><caption><p><bold>Performance when several features of the path encoding scheme are disabled.</bold> All values are given as percentage over the encoding size for the encoding that uses all the features. (<bold>A</bold>) ‘No reference’ starts with an empty transcriptome reference. ‘No reverse complement’ disables the reverse complementation of the reads. ‘No duplicate handling’ disables the recognition and special encoding of exact duplicate reads. (<bold>B</bold>) ‘No dynamic updates’ gives the compression when the probabilities of the statistical model are not updated as reads are encoded</p></caption><graphic xlink:href="btv071f2p"/></fig></p>
      <p>Although the reference provides a starting point for the statistical model, the arithmetic coding we use is adaptive in the sense that read patterns observed frequently during encoding will become more efficiently encoded as they are observed. By disabling these dynamic updates, we can quantify their benefit (<xref ref-type="fig" rid="btv071-F2">Fig. 2</xref>B), which is substantial. The dynamic updating for the larger human files results in a encodings that are 42–92% the size of those produced by the non-dynamic model. For non-human data, where the initial model is likely to be most wrong, the adaptive coding is essential for good compression, resulting in a file that is 4.1 (mouse) or 7.0 (<italic>P. aeruginosa</italic>) times smaller. Thus, even with a poor initial model, a good model can be constructed on the fly by adapting the probabilities to the reads as they are processed.</p>
      <p>These results show that path encoding provides a unified framework for good compression: when a good reference is available, it can be exploited to gain substantially in compression. When a reference is mismatched to the reads being encoded, the initial model is poor but can be improved via adaptive updates.</p>
    </sec>
    <sec>
      <title>3.4 Effect of heuristics for reverse complementation and encoding duplicate reads, and of the choice of context size</title>
      <p>Reverse complementing reads also provides a significant gain, particularly for reads that match the reference (<xref ref-type="fig" rid="btv071-F2">Fig. 2</xref>A). This is because the reverse complementation allows the read to agree more with the statistical model. Recognizing some duplicate reads also leads to a modest improvement in encoding size (<xref ref-type="fig" rid="btv071-F2">Fig. 2</xref>A). The improvement based on handling duplicate reads is small both because there are relatively few exact duplicate reads and because—in the interest of speed—we only tag a read as a duplicate if every read with the same first 16 bases is identical. It is possible that, in more redundant read sets, better handling of duplicate reads could result in a bigger gain.</p>
      <p>Path encoding has one major parameter: the kmer length <italic>k</italic> used to construct the nodes of the context graph (see Section 2). A bigger <italic>k</italic> uses more of the preceding string as context to set the probability distribution for the next base, but at the same time bigger <italic>k</italic>s make the effect of sequencing errors last longer since the sequence error affects the context for <italic>k</italic> bases. In addition, a larger <italic>k</italic> requires more memory resources to encode and decode. We find that <italic>k</italic> = 16 is the point at which encoding is most effective (<xref ref-type="fig" rid="btv071-F3">Fig. 3</xref>). This is also the point at which a kmer can fit in a single 32-bit computer word, leading to an efficient use of memory. While longer <italic>k</italic> does reduce the size of the encoding of the read ends (both because the read ends are shorter and because a longer context is used), the size of the bit tree encoding the read starts grows more quickly than the savings gained.
<fig id="btv071-F3" position="float"><label>Fig. 3.</label><caption><p><bold>Effective of kmer length.</bold> File size, represented as a fraction of the 2-bit encoding size, using various kmer lengths <italic>k</italic>.</p></caption><graphic xlink:href="btv071f3p"/></fig></p>
    </sec>
    <sec>
      <title>3.5 Encoding and decoding path-encoded files is fast</title>
      <p>Running times and memory usage for all the tools discussed here are reported in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btv071/-/DC1">Supplementary Tables 1–4</ext-link>. Path encoding the entire dataset here takes 2.45 h, including all read preprocessing. This is nearly identical to the running time for running bowtie and CRAM on the same dataset (2.44 h; Scramble (<xref rid="btv071-B3" ref-type="bibr">Bonfield, 2014</xref>) is a faster implementation of CRAM that may improve this running time, although the slowest step in compressing with CRAM is the read alignment). Decoding with path encoding is generally faster, taking 2.10 h for the files in <xref ref-type="table" rid="btv071-T1">Table 1</xref>. When a larger amount of memory is available, the prototype implementation provides a <monospace>-</monospace><monospace>bigmem</monospace> option that reduces decoding time by 40% (<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btv071/-/DC1">Supplementary Table 5</ext-link>). While these running times are practical, an important direction for future work is improving the speed and memory usage of the technique.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>We have provided a novel encoding scheme for short read sequence data that is effective at compressing sequences to 12–42% of the uncompressed, 2-bit encoded size. To do this, we introduced the novel approach of encoding paths in a de Bruijn graph using an adaptive arithmetic encoder combined with a bit tree data structure to encode start nodes (see Section 2 for a description). These two computational approaches are of interest in other settings as well. Path encoding achieves better compression than both <italic>de novo</italic> schemes and mapping-based reference schemes. Because the reference for the human transcriptome is small (92 Mb) compared with the size of the compressed files, the overhead of transmitting the reference is recovered after only a few transmissions. In addition, although it would be possible to shrink the reference using a custom format, in our current implementation the reference is intentionally chosen to be merely a gzipped version of the transcriptome—a file that most researchers would have stored anyway.</p>
    <p>Path encoding is more general than reference-based schemes because we have more flexibility in choosing how to initialize the statistical model with the reference sequence. For example, the reference could be reduced to simple context-specific estimates of GC content. This will naturally lead to worse compression but will also eliminate most of the need to transmit a reference. Technology-specific error models could also be incorporated to augment the reference to better deal with sequencing errors. In addition, single nucleotide polymorphism (SNP) data from a resource such as the HapMap project could be included in the reference to better deal with genomic variation. Framing the problem using a statistical generative model as we have done here opens the door to more sophisticated models being developed and incorporated.</p>
    <p>Another source of flexibility is the possibility of lossy sequence compression. Path encoding naturally handles with errors since they will have low probability because they are typically seen only once (or a few times) in contrast to correct kmers that are more frequently seen. While encoding, a base that has low probability in a particular context could be converted to a higher probability base under the assumption that the low probability base is a sequencing error. Implementation of this technique does indeed reduce file sizes substantially, but of course at the loss of being able to reconstruct the input sequence. While lossy compression may be appropriate for some analyses (such as isoform expression estimation) and error correction can be viewed as a type of lossy encoding, because we are interested in lossless compression, we do not explore this idea more here.</p>
    <p>An interesting direction for future research is to explore the use of the reference to improve the encoding of the read heads, using for example, a Huffman encoding-like scheme. Another important direction for future work is to reduce the time and memory requirements of the implementation of path encoding. Part of the reason for the higher computational demands is use of dynamic arithmetic encoding, which is needed because the probabilities of kmers need not be stationary. For example, in a file with many As in the first reads but many Cs in the later reads, the dynamic AC will adapt to this non-stationary distribution, leading to improved compression. Another direction for future work is to apply similar ideas to genomic reads, where the reference is much larger.</p>
    <p>A recent line of work (e.g. <xref rid="btv071-B13" ref-type="bibr">Daniels <italic>et</italic>
<italic>al.</italic>, 2013</xref>; <xref rid="btv071-B20" ref-type="bibr">Janin <italic>et</italic><italic> al.</italic>, 2014</xref>; <xref rid="btv071-B28" ref-type="bibr">Loh <italic>et </italic><italic>al.</italic>, 2012</xref>) aims at producing searchable, compressed representations of sequence information. Allowing sequence search limits the type and amount of compression that can be applied and requires some type of random access into the encoded sequences. Arithmetic encoding does not generally allow such random access decoding because the constructed interval for a given symbol depends on all previously observed symbols. However, decompression with our path encoding scheme can be performed in a streaming manner: the encoded file is read once from start to finish, and the decoder produces reads as they are decoded. This would allow reads to be decoded as they are being downloaded from a central repository.</p>
    <p>The other dimension of compressing short-read data is storing the quality values that typically accompany the reads. Path encoding does not attempt to store these quality values as there are other, more appropriate approaches for this problem (<xref rid="btv071-B10" ref-type="bibr">Cánovas <italic>et al.</italic>, 2014</xref>; <xref rid="btv071-B18" ref-type="bibr">Hach <italic>et</italic>
<italic>al.</italic>, 2012</xref>; <xref rid="btv071-B31" ref-type="bibr">Ochoa <italic>et</italic>
<italic>al.</italic>, 2013</xref>; <xref rid="btv071-B45" ref-type="bibr">Yu <italic>et</italic>
<italic>al.</italic>, 2014</xref>). Path encoding can be coupled with one of these approaches to store both sequence and quality values. In fact, in many cases, the quality values are unnecessary and many genomic tools such as BWA (<xref rid="btv071-B25" ref-type="bibr">Li and Durbin, 2009</xref>) and Sailfish (<xref rid="btv071-B32" ref-type="bibr">Patro <italic>et</italic>
<italic>al.</italic>, 2014</xref>) now routinely ignore them. <xref rid="btv071-B45" ref-type="bibr">Yu <italic>et</italic>
<italic>al.</italic> (2014)</xref> showed that quality values can be aggressively discarded and without loss of ability to distinguish sequencing errors from novel SNPs. Thus, the problem of compression of quality values is both very different and less important than that of recording the sequence reads.</p>
    <p>Our main contribution is the design of a high-performing compression scheme. We hope that our compression results will spur further reference-based read compression work in the new direction that we propose here: mapping-free, statistical compression with accompanying supporting pre-processing.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_31_12_1920__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btv071_Kingsford-Patro-supp.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>We would like to thank Darya Filippova, Emre Sefer, and Hao Wang for useful discussions relating to this work and for comments on the manuscript. This work was primarily completed while R.P. was at the Lane Center at Carnegie Mellon University.</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>This work is funded in part by the <funding-source>Gordon and Betty Moore Foundation’s Data-Driven Discovery Initiative through Grant</funding-source>
<award-id>GBMF4554</award-id> to Carl Kingsford. It has been partially funded by the <funding-source>US National Science Foundation</funding-source> [grant numbers <award-id>CCF-1256087</award-id>, <award-id>CCF-1319998</award-id>]; and <funding-source>US National Institutes of Health</funding-source> [<award-id>R21HG006913</award-id>, <award-id>R01HG007104</award-id>]. C.K. received support as an Alfred P. Sloan Research Fellow.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="btv071-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Adjeroh</surname><given-names>D.</given-names></name><etal/></person-group> (<year>2002</year>) <article-title>DNA sequence compression using the Burrows-Wheeler transform</article-title>. In: <source>Procceeding IEEE Computer Society Bioinformatics Conference</source>. <volume>Vol. 1</volume>, <comment>IEEE Computer Society, Washington, DC, pp. 303–313</comment>.</mixed-citation>
    </ref>
    <ref id="btv071-B2">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Bhola</surname><given-names>V.</given-names></name><etal/></person-group> (<year>2011</year>) <article-title>No-reference compression of genomic data stored in FASTQ format</article-title>. In: <source>IEEE International Conference on Bioinformatics and Biomedicine</source>. <comment>IEEE Computer Society, Washington, DC, pp. 147–150</comment></mixed-citation>
    </ref>
    <ref id="btv071-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bonfield</surname><given-names>J.K.</given-names></name></person-group> (<year>2014</year>) <article-title>The Scramble conversion tool</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>2818</fpage>–<lpage>2819</lpage>.<pub-id pub-id-type="pmid">24930138</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bonfield</surname><given-names>J.K.</given-names></name><name><surname>Mahoney</surname><given-names>M.V.</given-names></name></person-group> (<year>2013</year>) <article-title>Compression of FASTQ and SAM format sequencing data</article-title>. <source>PLoS One</source>, <volume>8</volume>(<issue>3</issue>), <fpage>e59190</fpage>.<pub-id pub-id-type="pmid">23533605</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brandon</surname><given-names>M.C.</given-names></name><etal/></person-group> (<year>2009</year>) <article-title>Data structures and compression algorithms for genomic sequence data</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>1731</fpage>–<lpage>1738</lpage>.<pub-id pub-id-type="pmid">19447783</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bullard</surname><given-names>J.</given-names></name><etal/></person-group> (<year>2010</year>) <article-title>Evaluation of statistical methods for normalization and differential expression in mRNA-Seq experiments</article-title>. <source>BMC Bioinformatics</source>, <volume>11</volume>, <fpage>94</fpage>.<pub-id pub-id-type="pmid">20167110</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Burriesci</surname><given-names>M.S.</given-names></name><etal/></person-group> (<year>2012</year>) <article-title>Fulcrum: condensing redundant reads from high-throughput sequencing studies</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>1324</fpage>–<lpage>1327</lpage>.<pub-id pub-id-type="pmid">22419786</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Burrows</surname><given-names>M.</given-names></name><name><surname>Wheeler</surname><given-names>D.J.</given-names></name></person-group> (<year>1994</year>) <article-title>A block sorting lossless data compression algorithm</article-title>. <source>Technical Report 124</source>. <comment>Digital Equipment Corporation</comment>.</mixed-citation>
    </ref>
    <ref id="btv071-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Campagne</surname><given-names>F.</given-names></name><etal/></person-group> (<year>2013</year>) <article-title>Compression of structured high-throughput sequencing data</article-title>. <source>PLoS One</source>, <volume>8</volume>, <fpage>e79871</fpage>.<pub-id pub-id-type="pmid">24260313</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cánovas</surname><given-names>R.</given-names></name><etal/></person-group> (<year>2014</year>) <article-title>Lossy compression of quality scores in genomic data</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>2130</fpage>–<lpage>2136</lpage>.<pub-id pub-id-type="pmid">24728856</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cherniavsky</surname><given-names>N.</given-names></name><name><surname>Ladner</surname><given-names>R.</given-names></name></person-group> (<year>2004</year>) <article-title>Grammar-based compression of DNA sequences</article-title>. <source>Technical Report</source>
<comment>2007-05-02. University of Washington CSE</comment>.</mixed-citation>
    </ref>
    <ref id="btv071-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cox</surname><given-names>A.J.</given-names></name><etal/></person-group> (<year>2012</year>) <article-title>Large-scale compression of genomic sequence databases with the Burrows-Wheeler transform</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>1415</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">22556365</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Daniels</surname><given-names>N.M.</given-names></name><etal/></person-group> (<year>2013</year>) <article-title>Compressive genomics for protein databases</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>i283</fpage>–<lpage>i290</lpage>.<pub-id pub-id-type="pmid">23812995</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>de Jonge</surname><given-names>W.</given-names></name><etal/></person-group> (<year>1994</year>) <article-title>S+-trees: an efficient structure for the representation of large pictures</article-title>. <source>CVGIP: Imag. Understan.</source>, <volume>59</volume>, <fpage>265</fpage>–<lpage>280</lpage>.</mixed-citation>
    </ref>
    <ref id="btv071-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Deorowicz</surname><given-names>S.</given-names></name><name><surname>Grabowski</surname><given-names>S.</given-names></name></person-group> (<year>2011</year>) <article-title>Compression of DNA sequence reads in FASTQ format</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>860</fpage>–<lpage>862</lpage>.<pub-id pub-id-type="pmid">21252073</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Friedli</surname><given-names>M.</given-names></name><etal/></person-group> (<year>2014</year>). <article-title>Loss of transcriptional control over endogenous retroelements during reprogramming to pluripotency</article-title>. <source>Genome Res</source>, <volume>24</volume>, <fpage>1251</fpage>–<lpage>1259</lpage>.<pub-id pub-id-type="pmid">24879558</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fritz</surname><given-names>M.H.-Y.</given-names></name><etal/></person-group> (<year>2011</year>) <article-title>Efficient storage of high throughput DNA sequencing data using reference-based compression</article-title>. <source>Genome Res.</source>, <volume>21</volume>, <fpage>734</fpage>–<lpage>740</lpage>.<pub-id pub-id-type="pmid">21245279</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hach</surname><given-names>F.</given-names></name><etal/></person-group> (<year>2012</year>) <article-title>SCALCE: boosting sequence compression algorithms using locally consistent encoding</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>3051</fpage>–<lpage>3057</lpage>.<pub-id pub-id-type="pmid">23047557</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Iqbal</surname><given-names>Z.</given-names></name><etal/></person-group> (<year>2012</year>) <article-title>De novo assembly and genotyping of variants using colored de Bruijn graphs</article-title>. <source>Nat. Genet.</source>, <volume>44</volume>, <fpage>226</fpage>–<lpage>232</lpage>.<pub-id pub-id-type="pmid">22231483</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Janin</surname><given-names>L.</given-names></name><etal/></person-group> (<year>2014</year>) <article-title>BEETL-fastq: a searchable compressed archive for DNA reads</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>2796</fpage>–<lpage>2801</lpage>.<pub-id pub-id-type="pmid">24950811</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jones</surname><given-names>D.C.</given-names></name><etal/></person-group> (<year>2012</year>) <article-title>Compression of next-generation sequencing reads aided by highly efficient de novo assembly</article-title>. <source>Nucleic Acids Res.</source>, <volume>40</volume>, <fpage>e171</fpage>.<pub-id pub-id-type="pmid">22904078</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>J.</given-names></name><etal/></person-group> (<year>2012</year>) <article-title>Transcriptome landscape of the human placenta</article-title>. <source>BMC Genomics</source>, <volume>13</volume>, <fpage>115</fpage>.<pub-id pub-id-type="pmid">22448651</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kozanitis</surname><given-names>C.</given-names></name><etal/></person-group> (<year>2011</year>) <article-title>Compressing genomic sequence fragments using SlimGene</article-title>. <source>J. Comput. Biol.</source>, <volume>18</volume>, <fpage>401</fpage>–<lpage>413</lpage>.<pub-id pub-id-type="pmid">21385043</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Langmead</surname><given-names>B.</given-names></name></person-group> (<year>2009</year>) <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>. <source>Genome Biol.</source>, <volume>10</volume>, <fpage>R25</fpage>.<pub-id pub-id-type="pmid">19261174</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H.</given-names></name><name><surname>Durbin</surname><given-names>R.</given-names></name></person-group> (<year>2009</year>) <article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>1754</fpage>–<lpage>1760</lpage>.<pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H.</given-names></name><etal/></person-group> (<year>2009</year>) <article-title>The Sequence Alignment/Map format and SAMtools</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>2078</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">19505943</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>P.</given-names></name><etal/></person-group> (<year>2014</year>) <article-title>HUGO: hierarchical mUlti-reference Genome cOmpression for aligned reads</article-title>. <source>J. Am. Med. Inform. Assoc.</source>, <volume>21</volume>, <fpage>363</fpage>–<lpage>373</lpage>.<pub-id pub-id-type="pmid">24368726</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Loh</surname><given-names>P.-R.</given-names></name><etal/></person-group> (<year>2012</year>) <article-title>Compressive genomics</article-title>. <source>Nat. Biotechnol.</source>, <volume>30</volume>, <fpage>627</fpage>–<lpage>630</lpage>.<pub-id pub-id-type="pmid">22781691</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Matsumoto</surname><given-names>T.</given-names></name><etal/></person-group> (<year>2000</year>) <article-title>Biological sequence compression algorithms</article-title>. <source>Genome Inform. Ser. Workshop Genome Inform.</source>, <volume>11</volume>, <fpage>43</fpage>–<lpage>52</lpage>.</mixed-citation>
    </ref>
    <ref id="btv071-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Moffat</surname><given-names>A.</given-names></name><etal/></person-group> (<year>1998</year>) <article-title>Arithmetic coding revisited</article-title>. <source>ACM Trans. Inform. Syst.</source>, <volume>16</volume>, <fpage>256</fpage>–<lpage>294</lpage>.</mixed-citation>
    </ref>
    <ref id="btv071-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ochoa</surname><given-names>I.</given-names></name><etal/></person-group> (<year>2013</year>) <article-title>QualComp: a new lossy compressor for quality scores based on rate distortion theory</article-title>. <source>BMC Bioinformatics</source>, <volume>14</volume>, <fpage>187</fpage>.<pub-id pub-id-type="pmid">23758828</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Patro</surname><given-names>R.</given-names></name><etal/></person-group> (<year>2014</year>) <article-title>Sailfish enables alignment-free isoform quantification from RNA-seq reads using lightweight algorithms</article-title>. <source>Nat. Biotechnol.</source>, <volume>32</volume>, <fpage>462</fpage>–<lpage>464</lpage>.<pub-id pub-id-type="pmid">24752080</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pevzner</surname><given-names>P.A.</given-names></name><etal/></person-group> (<year>2001</year>) <article-title>An Eulerian path approach to DNA fragment assembly</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>98</volume>, <fpage>9748</fpage>—<lpage>9753</lpage>.<pub-id pub-id-type="pmid">11504945</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Popitsch</surname><given-names>N.</given-names></name><name><surname>von Haeseler</surname><given-names>A.</given-names></name></person-group> (<year>2013</year>) <article-title>NGC: lossless and lossy compression of aligned high-throughput sequencing data</article-title>. <source>Nucleic Acids Res.</source>, <volume>41</volume>, <fpage>e27</fpage>.<pub-id pub-id-type="pmid">23066097</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rajarajeswari</surname><given-names>P.</given-names></name><name><surname>Apparao</surname><given-names>A.</given-names></name></person-group> (<year>2011</year>) <article-title>DNABIT Compress—genome compression algorithm</article-title>. <source>Bioinformation</source>, <volume>5</volume>, <fpage>350</fpage>–<lpage>360</lpage>.<pub-id pub-id-type="pmid">21383923</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rissanen</surname><given-names>J.</given-names></name><name><surname>Langdon</surname><given-names>G.</given-names><suffix>Jr.</suffix></name></person-group> (<year>1979</year>) <article-title>Arithmetic coding</article-title>. <source>IBM J. Res. Dev.</source>, <volume>23</volume>, <fpage>149</fpage>–<lpage>162</lpage>.</mixed-citation>
    </ref>
    <ref id="btv071-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Roberts</surname><given-names>A.</given-names></name><name><surname>Pachter</surname><given-names>L.</given-names></name></person-group> (<year>2013</year>) <article-title>Streaming fragment assignment for real-time analysis of sequencing experiments</article-title>. <source>Nat. Methods</source>, <volume>10</volume>, <fpage>71</fpage>–<lpage>73</lpage>.<pub-id pub-id-type="pmid">23160280</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Steinruecken</surname><given-names>C.</given-names></name></person-group> (<year>2014</year>) <article-title>Compressing sets and multisets of sequences</article-title>. <comment>arXiv:1401.6410 [cs.IT]</comment>.</mixed-citation>
    </ref>
    <ref id="btv071-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tembe</surname><given-names>W.</given-names></name><etal/></person-group> (<year>2010</year>) <article-title>G-SQZ: compact encoding of genomic sequence and quality data</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>2192</fpage>–<lpage>2194</lpage>.<pub-id pub-id-type="pmid">20605925</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Winsor</surname><given-names>G.L.</given-names></name><etal/></person-group> (<year>2011</year>) <article-title><italic>Pseudomonas</italic> Genome Database: improved comparative analysis and population genomics capability for <italic>Pseudomonas</italic> genomes</article-title>. <source>Nucleic Acids Res.</source>, <volume>39</volume>(<issue>Database issue</issue>), <fpage>D596</fpage>–<lpage>D600</lpage>.<pub-id pub-id-type="pmid">20929876</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Witten</surname><given-names>I.H.</given-names></name><etal/></person-group>. (<year>1987</year>) <article-title>Arithmetic coding for data compression</article-title>. <source>Comm. ACM</source>, <volume>30</volume>, <fpage>520</fpage>–<lpage>540</lpage>.</mixed-citation>
    </ref>
    <ref id="btv071-B42">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wood</surname><given-names>D.E.</given-names></name><name><surname>Salzberg</surname><given-names>S.L.</given-names></name></person-group> (<year>2014</year>) <article-title>Kraken: ultrafast metagenomic sequence classification using exact alignments</article-title>. <source>Genome Biol.</source>, <volume>15</volume>, <fpage>R46</fpage>.<pub-id pub-id-type="pmid">24580807</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B43">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Xue</surname><given-names>Z.</given-names></name><etal/></person-group> (<year>2013</year>) <article-title>Genetic programs in human and mouse early embryos revealed by single-cell RNA sequencing</article-title>. <source>Nature</source>, <volume>500</volume>, <fpage>593</fpage>–<lpage>597</lpage>.<pub-id pub-id-type="pmid">23892778</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B44">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yan</surname><given-names>L.</given-names></name><etal/></person-group> (<year>2013</year>) <article-title>Single-cell RNA-Seq profiling of human preimplantation embryos and embryonic stem cells</article-title>. <source>Nat. Struct. Mol. Biol.</source>, <volume>20</volume>, <fpage>1131</fpage>–<lpage>1139</lpage>.<pub-id pub-id-type="pmid">23934149</pub-id></mixed-citation>
    </ref>
    <ref id="btv071-B45">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Yu</surname><given-names>Y.W.</given-names></name><etal/></person-group> (<year>2014</year>) <article-title>Traversing the k-mer landscape of NGS read datasets for quality score sparsification</article-title>. In: <person-group person-group-type="editor"><name><surname>Sharan</surname><given-names>R.</given-names></name></person-group> (ed.) <source>Research in Computational Molecular Biology</source> (<comment>Lecture Notes in Computer Science). Switzerland: Springer International Publishing. pp. 385–399</comment>.</mixed-citation>
    </ref>
  </ref-list>
</back>
