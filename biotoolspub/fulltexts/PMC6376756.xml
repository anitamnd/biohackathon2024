<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6376756</article-id>
    <article-id pub-id-type="publisher-id">2665</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-019-2665-0</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>ADS-HCSpark: A scalable HaplotypeCaller leveraging adaptive data segmentation to accelerate variant calling on Spark</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Xiao</surname>
          <given-names>Anghong</given-names>
        </name>
        <address>
          <email>anghongxiao@qq.com</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wu</surname>
          <given-names>Zongze</given-names>
        </name>
        <address>
          <email>shedfree@qq.com</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Dong</surname>
          <given-names>Shoubin</given-names>
        </name>
        <address>
          <email>sbdong@scut.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1764 3838</institution-id><institution-id institution-id-type="GRID">grid.79703.3a</institution-id><institution>Communication &amp; Computer Network Lab of Guangdong, School of Computer Science &amp; Engineering, </institution><institution>South China University of Technology, </institution></institution-wrap>Wushan Road, Guangzhou, 510641 China </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>14</day>
      <month>2</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>14</day>
      <month>2</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>76</elocation-id>
    <history>
      <date date-type="received">
        <day>9</day>
        <month>11</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>30</day>
        <month>1</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s). 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">The advance of next generation sequencing enables higher throughput with lower price, and as the basic of high-throughput sequencing data analysis, variant calling is widely used in disease research, clinical treatment and medicine research. However, current mainstream variant caller tools have a serious problem of computation bottlenecks, resulting in some long tail tasks when performing on large datasets. This prevents high scalability on clusters of multi-node and multi-core, and leads to long runtime and inefficient usage of computing resources. Thus, a high scalable tool which could run in distributed environment will be highly useful to accelerate variant calling on large scale genome data.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">In this paper, we present ADS-HCSpark, a scalable tool for variant calling based on Apache Spark framework. ADS-HCSpark accelerates the process of variant calling by implementing the parallelization of mainstream GATK HaplotypeCaller algorithm on multi-core and multi-node. Aiming at solving the problem of computation skew in HaplotypeCaller, a parallel strategy of adaptive data segmentation is proposed and a variant calling algorithm based on adaptive data segmentation is implemented, which achieves good scalability on both single-node and multi-node. For the requirement that adjacent data blocks should have overlapped boundaries, Hadoop-BAM library is customized to implement partitioning BAM file into overlapped blocks, further improving the accuracy of variant calling.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">ADS-HCSpark is a scalable tool to achieve variant calling based on Apache Spark framework, implementing the parallelization of GATK HaplotypeCaller algorithm. ADS-HCSpark is evaluated on our cluster and in the case of best performance that could be achieved in this experimental platform, ADS-HCSpark is 74% faster than GATK3.8 HaplotypeCaller on single-node experiments, 57% faster than GATK4.0 HaplotypeCallerSpark and 27% faster than SparkGA on multi-node experiments, with better scalability and the accuracy of over 99%. The source code of ADS-HCSpark is publicly available at <ext-link ext-link-type="uri" xlink:href="https://github.com/SCUT-CCNL/ADS-HCSpark.git">https://github.com/SCUT-CCNL/ADS-HCSpark.git</ext-link>.</p>
      </sec>
      <sec>
        <title>Electronic supplementary material</title>
        <p>The online version of this article (10.1186/s12859-019-2665-0) contains supplementary material, which is available to authorized users.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Variant calling</kwd>
      <kwd>Spark</kwd>
      <kwd>Adaptive data segmentation</kwd>
      <kwd>Hadoop-BAM</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100003453</institution-id>
            <institution>Natural Science Foundation of Guangdong Province</institution>
          </institution-wrap>
        </funding-source>
        <award-id>2015A030308017</award-id>
        <principal-award-recipient>
          <name>
            <surname>Dong</surname>
            <given-names>Shoubin</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p id="Par14">In the past decade, next generation sequencing (NGS) technology has made great progress and personal genome sequencing has also been widely used in human disease research, clinical treatment and new drug research [<xref ref-type="bibr" rid="CR1">1</xref>]. In the genome analysis process, variant calling is significant step to discover and obtain variants relative to reference genome, which is also the basis for subsequent analysis. GATK [<xref ref-type="bibr" rid="CR2">2</xref>, <xref ref-type="bibr" rid="CR3">3</xref>] from the Broad Institute is one of the mainstream NGS genome data analysis toolkits, which focuses on processing variant discovery and genotyping of both exomes and whole genomes generated by Illumina sequencing machines. In GATK, HaplotypeCaller is the most prevalent variant calling approach applied to the discovery of short variant in germ cells. Its capability of calling SNPs and indels simultaneously through local de-novo assembly of haplotypes in an active region, which makes the HaplotypeCaller much better at calling indels [<xref ref-type="bibr" rid="CR4">4</xref>] than other position-based callers such as Samtools [<xref ref-type="bibr" rid="CR5">5</xref>] and GATK UnifiedGenotyper.</p>
    <p id="Par15">However, with the dramatic increasing of genome data, it will take a long time to perform variant calling. GATK HaplotypeCaller runs on a single node with serious scalability bottleneck, which leads to inefficient use of the computing resources, especially dealing with large scale genome data. The calculation of HaplotypeCaller is complex, mainly including four steps: identifying active regions, local reassembly, likelihood calculation and assigning genotypes. In the study [<xref ref-type="bibr" rid="CR6">6</xref>], the time consumption of various parts of HaplotypeCaller is counted as shown in Table <xref rid="Tab1" ref-type="table">1</xref>. Among them, “Assembly” is the second step, local reassembly of HaplotypeCaller, and “PairHMM” is the third step, likelihood calculation. “Traversal + Genotyping” includes traversing alignment sequence data, identifying active regions and assigning genotypes. It could be seen that the most time-consuming step in HaplotypeCaller is the calculation of PairHMM, which takes up to 70% of the total time.<table-wrap id="Tab1"><label>Table 1</label><caption><p>The runtime for each step of HaplotypeCaller [<xref ref-type="bibr" rid="CR6">6</xref>]</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Stage</th><th>Runtime</th><th>Percentage</th></tr></thead><tbody><tr><td>Assembly</td><td>2598 s</td><td>13%</td></tr><tr><td>PairHMM</td><td>14,225 s</td><td>70%</td></tr><tr><td>Traversal + Genotyping</td><td>3379 s</td><td>17%</td></tr></tbody></table></table-wrap></p>
    <p id="Par16">It is reported [<xref ref-type="bibr" rid="CR7">7</xref>] that there is a serious problem of computation skew in HaplotypeCaller, meaning that though the size of input file is the same, the running time of variant calling is still significantly different. This is mainly caused by some difference in sequence data. This problem poses a great challenge to the parallelization of HaplotypeCaller, which easily causes long tail tasks and leads to poor scalability.</p>
    <p id="Par17">Recently, cloud computing and big data technology have become increasingly popular. A couple distributed frameworks such as Hadoop and Apache Spark [<xref ref-type="bibr" rid="CR8">8</xref>] have emerged to provide excellent solutions for addressing the scalability problem of variant calling. Hadoop/Spark are big data frameworks that provide highly parallel distributed computing environment using multiple ordinary machines to store and analyze large datasets faster and more efficiently. Spark could achieve higher performance than Hadoop due to its memory-based computing. A growing number of genome analysis tools based on distributed framework have been proposed [<xref ref-type="bibr" rid="CR9">9</xref>, <xref ref-type="bibr" rid="CR10">10</xref>]. GATK-Queue [<xref ref-type="bibr" rid="CR11">11</xref>] is an extension of GATK that uses Sun Grid Engine to run tasks in a distributed cluster in Scatter-gather mode, but its parallel approach is command-based, whose task segmentation is large and cannot be fine-grained. Halvade [<xref ref-type="bibr" rid="CR12">12</xref>] implements genome analysis process using Hadoop MapReduce based approach, in which the variant calling tasks are divided by chromosome. This division is likely to cause load imbalance due to the obvious difference in the length of human chromosomes. Churchill [<xref ref-type="bibr" rid="CR13">13</xref>] is a tightly-integrated DNA analysis pipeline and can implement variant calling using FreeBayes [<xref ref-type="bibr" rid="CR14">14</xref>] or HaplotypeCalller. Its parallel strategy is to divide the data by the same size and perform variant calling in parallel on each segment, which can overcome the load imbalance caused by uneven chromosome length to some extent. Nevertheless, it does not solve the problem of computation skew. SparkGA [<xref ref-type="bibr" rid="CR15">15</xref>] is a parallel implementation of a genome analysis pipeline based on Spark, in which the parallel strategy of the variant calling is relatively simple and does not consider the overlap of adjacent blocks. In addition, the official version of the latest GATK4.0 [<xref ref-type="bibr" rid="CR16">16</xref>] was released and many analysis tools are redeveloped based on Spark framework. GATK4.0’s multi-node variant caller HaplotypeCallerSpark also implements parallelization of variant calling on multi-node and multi-core based on Spark framework, but it has a high demand for computing resources. When HaplotypeCallerSpark runs on large scale datasets, huge memory overhead and time-consuming shuffle operators have become a bottleneck.</p>
    <p id="Par18">Thus, in order to accelerate variant calling on large scale genome data, a high scalable tool which could run in distributed environment is demanded. In this paper, we proposed ADS-HCSpark, a scalable tool to accelerate the stage of variant calling based on Spark framework, which implements the parallelization of GATK3.8 HaplotypeCaller algorithm on the cluster of multi-core and multi-node. The source code and usage document of ADS-HCSpark are respectively described in the Additional files <xref rid="MOESM1" ref-type="media">1</xref> and <xref rid="MOESM2" ref-type="media">2</xref>. The main contributions of our work are as follows:</p>
    <p id="Par19">• A parallel strategy of adaptive data segmentation is proposed and a variant calling algorithm based on adaptive data segmentation (ADS-HC) is implemented to address the problem of computation skew in HaplotypeCaller.</p>
    <p id="Par20">• For the requirement that adjacent data blocks should have overlapped boundaries, Hadoop-BAM library is customized to implement partitioning BAM file into overlapped blocks, improving the accuracy of variant calling.</p>
  </sec>
  <sec id="Sec2">
    <title>Implementation</title>
    <sec id="Sec3">
      <title>Overview of ADS-HCSpark</title>
      <p id="Par21">Current variant caller is relatively inefficient which takes lots of time to perform variant calling, and ADS-HCSpark is proposed to achieve parallelization of HaplotypeCaller to accelerate the process of variant calling. In the distributed environment, the input BAM file is usually segmented into equal-sized original data blocks for parallel processing by default on HDFS. Due to the computation skew of HaplotypeCaller, the processing of some data blocks may take a very long time. To address the problem of computation skew in HaplotypeCaller, we propose a parallel strategy of adaptive data segmentation. Adaptive data segmentation aims to divide the original time-consuming blocks into multiple new blocks and keep the rest in their original partitions, to ensure all the blocks would be processed in almost same execution time ideally. Due to the scheduling mechanism (that the next task in the task queue is performed when there is an idle core) of Spark framework, if the number of data blocks is reasonable and there is no obvious long tail task, the whole program is generally load balanced.</p>
      <p id="Par22">Therefore, our target is to find the original time-consuming data blocks and apply appropriate segmentation. According to the Table <xref rid="Tab1" ref-type="table">1</xref>, the third step PairHMM takes up most of running time, so if runtime of PairHMM could be estimated, the runtime of the data block also could be estimated roughly. The time complexity of PairHMM is O(N × M × R × H) [<xref ref-type="bibr" rid="CR6">6</xref>], in which N is the number of reads, M is the number of candidate haplotypes, R is total length of reads and H is total length of candidate haplotypes. In order to estimate the time consumption of PairHMM, the first two steps of HaplotypeCaller have to be performed, which will increase the time by at least 20%. Accurately estimating the running time of variant calling for a data block is complex and time-consuming, so for further simplifying the calculation, in ADS-HCSpark, above task is converted to use the sequence features to determine whether it takes long execution time to process the data block. The parallel strategy of adaptive data segmentation is implemented by combining the file partitioning mechanism of HDFS and the scheduling mechanism of Spark based on the sequence features of input file. The flow-process diagram of ADS-HCSpark is shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref>.<fig id="Fig1"><label>Fig. 1</label><caption><p>The flow-process diagram of ADS-HCSpark. The figure shows the execution flow of ADS-HCSpark. First the BAM file needs to be uploaded to HDFS. ADS-HCSpark includes two parts: the data preprocessing and the variant calling based on adaptive data segmentation (ADS-HC). ADS-HC includes targeted data partitioning, overlapped processing, variant calling and output merge. Among them, variant calling consists of four main steps of GATK HaplotypeCaller: identifying active regions, local reassembly, likelihood calculation and assigning genotypes</p></caption><graphic xlink:href="12859_2019_2665_Fig1_HTML" id="MO1"/></fig></p>
      <p id="Par23">ADS-HCSpark is divided into two parts: the data preprocessing to mining sequence features of input file and the variant calling based on adaptive data segmentation (ADS-HC). ADS-HC includes targeted data partitioning, overlapped processing, variant calling and output merge. Among them, variant calling consists of four main steps of GATK HaplotypeCaller: identifying active regions, local reassembly, likelihood calculation and assigning genotypes.</p>
    </sec>
    <sec id="Sec4">
      <title>Data preprocessing</title>
      <p id="Par24">According to the previous analysis of HaplotypeCaller, it can be inferred that accurately predicting the execution time of variant calling for a data block is quite complex and time-consuming. In order to simplify the calculation, the above task is converted to use the sequence features to determine whether it takes long execution time to process the data block in ADS-HCSpark. As described above, the time complexity of most time-consuming part PairHMM of HaplotypeCaller is O(N × M × R × H), which means that the execution time is related with sequence and candidate haplotypes. However, to obtain features of candidate haplotypes, the first two steps of HaplotypeCaller have to be performed, which will increase the runtime of preprocessing stage. To simplify calculations and reduce extra time, we select relevant sequence features which could be counted and retrieved by scanning the original input file once. The relevant sequence features are demonstrated in Table <xref rid="Tab2" ref-type="table">2</xref>.<table-wrap id="Tab2"><label>Table 2</label><caption><p>Relevant sequence features obtained in the preprocessing stage</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Sequence features</th><th>Comment</th></tr></thead><tbody><tr><td>Index ID</td><td>Index number of data block</td></tr><tr><td>Interval</td><td>Interval length of all the alignment sequence in the data block</td></tr><tr><td>Record Num</td><td>Number of all the alignment sequence in the data block</td></tr><tr><td>CIGAR_I</td><td>Sum of the insertion lengths of all the alignment sequence in the data block</td></tr><tr><td>CIGAR_D</td><td>Sum of the deletion lengths of all the alignment sequence in the data block</td></tr></tbody></table></table-wrap></p>
      <p id="Par25">Above sequence features intuitively reflect the characteristics and variation situation of sequence. Their differences could affect the execution time of variant calling. In order to obtain these sequence features, the data preprocessing is required. First of all, the input BAM file should be uploaded to HDFS where the BAM file is partitioned into several fix size data blocks (eg.128 MB by default). In the data preprocessing stage, ADS-HCSpark reads each block in parallel and counts sequence features of each block according to the corresponding field of every record in the block. Among sequence features, Interval and RecordNum can be obtained by separately counting the number of bases and the number of records in the data block. CIGAR_I and CIGAR_R could be calculated from the field CIGAR of every record in the block. Finally, all the sequence features are saved into the preprocessing result file. The algorithm description and specific implementation details are described in the Additional file <xref rid="MOESM3" ref-type="media">3</xref>.</p>
    </sec>
    <sec id="Sec5">
      <title>Adaptive data segmentation</title>
      <p id="Par26">In the variant calling stage based on adaptive data segmentation, we need to predict and divide the time-consuming data blocks according to the sequence features. Therefore, the first step is to determine the number of data blocks to be segmented and how to select these data blocks.</p>
      <p id="Par27">In order to determine which block needs to be segmented, we select an input BAM file to analyze the execution time of each original block. The variant caller HaplotypeCaller is separately executed on every original blocks of the BAM file on HDFS and their respective running time is recorded. Then data blocks are sorted by their execution time from high to low and it could be concluded that the running time of top n% of data blocks is obviously longer than that of others by statistics (The value of n will be discussed in the later experimental part). Thus, we consider this top n% of data blocks as the long time-consuming blocks and our target is to predict and segment them.</p>
      <p id="Par28">The sequence features obtained in preprocessing stage could reflect the computational complexity of variant calling to some extent. Generally, the reads could be mapped to the reference sequence, but when there are more insertions and deletions in the alignment reads, more candidate haplotypes are easily generated, which leads to more subsequent time-consuming analysis. CIGAR_I and CIGAR_D in the preprocessed result file reflect the approximate number of inserted and missing segments in the data block. Usually, the distribution of alignment sequences is relatively uniform, but when they are too concentrated or sparse, the variation situation is more complicated and more calculations are required. In the sequence features, this is reflected that the range of the site covering the chromosome within the data block is too short or long. In general, the number of alignment sequence in every data block is equivalent. When the number of alignment sequence in some data blocks is significantly less than that in others, it is owing to the effect of the filters of HaplotypeCaller, indicating that part of alignment sequence in these data blocks are unreliable and need to be filtered. The alignment sequence situation in this region may be more complex and it is likely to require more calculations to execute variant calling, resulting in a time-consuming increase.</p>
      <p id="Par29">Based on the above analysis, our segmentation target is the top n% of the most time-consuming data blocks and they are predicted according to the following four rules. The parameters of rules and specific segmentation ratio will be discussed in the later experimental part.</p>
      <p id="Par30">• Top m% of the data blocks sorted by Interval from low to high.</p>
      <p id="Par31">• Top k% of the data blocks sorted by Interval from high to low.</p>
      <p id="Par32">• Top s% of the data blocks sorted by RecordNum from low to high.</p>
      <p id="Par33">• Top r% of the data blocks sorted by (CIGAR_I + CIGAR_D) from high to low.</p>
      <p id="Par34">These four rules correspond to several time-consuming situations analyzed above. The first two rules filter out the data blocks in which alignment sequence distribution is too concentrated or too sparse. The third rule filters out those data blocks in which the number of alignment reads is significantly less than that in others and the last rule filters out those blocks in which there are more insertions and deletions. These filtered data blocks are potential blocks that cause a long time for variant calling. In order to find time-consuming data blocks as much as possible, we do not consider priorities among above rules and as long as sequence features satisfy any rule, this data block is predicted to be time-consuming.</p>
      <p id="Par35">In the process of adaptive data segmentation, ADS-HCSpark first reads the sequence features of each original data block from the preprocessing result file and then all the original data blocks are sorted according to the requirements of four rules mentioned above. For the data blocks that satisfy any one rule, they are considered as the time-consuming block and their index numbers are stored in a collection. These blocks will be segmented into multiple new blocks which are set to high priority to execute variant calling. Other blocks that are not in the collection are not segmented and set to standard execution priority. After completing adaptive data segmentation, all the data blocks will be sorted by their execution priority, thereby ensuring that time-consuming blocks will be processed firstly. The algorithm description for computing the index number of data block to be segmented and segmenting data blocks are respectively described in the Additional files <xref rid="MOESM4" ref-type="media">4</xref> and <xref rid="MOESM5" ref-type="media">5</xref>.</p>
    </sec>
    <sec id="Sec6">
      <title>Customized Hadoop-BAM for overlapped blocks</title>
      <p id="Par36">After adaptive data segmentation, new data blocks will be read in parallel for processing. Since the variant calling of one site is associated with the alignment information of the sites in the vicinity, simple partitioning strategy by data block may lead to unreliable results. For higher accuracy of variant calling, ADS-HCSpark adopts an approach to partition data blocks with overlapped boundaries of adjacent data block. Hadoop-BAM [<xref ref-type="bibr" rid="CR17">17</xref>] is a library commonly used to read BAM files in parallel by Spark and Hadoop, but it cannot achieve overlapped processing between adjacent data blocks, which needs to be customized. Thus, we improved the Hadoop-BAM library to implement partitioning BAM file into overlapped blocks. In ADS-HCSpark, the size of overlapped boundaries of adjacent data blocks is set to the parameter <italic>overlapSize</italic> and different values of this parameter will affect the result of subsequent variant calling. The experiment is conducted to evaluate it in detail in the later chapter. In the process of partition of BAM file with overlapped blocks, all the data block information of the BAM file is obtained firstly and then data blocks are sorted according to the block number to ensure that data blocks are order. Then the program traverses all the data blocks and except for the last data block, the rest need to be extended the size of overlapped boundary. After overlapped processing, the boundary of two adjacent data blocks are the same. The size of overlapped boundary is up to the parameter <italic>overlapSize</italic>. Finally, the program returns all the overlapped blocks. The algorithm description for acquiring overlapped data blocks is described in the Additional file <xref rid="MOESM6" ref-type="media">6</xref>.</p>
    </sec>
    <sec id="Sec7">
      <title>Algorithm framework of ADS-HCSpark</title>
      <p id="Par37">In the step of variant calling, ADS-HCSpark uses the main algorithm of HaplotypeCaller to discover and obtain variants. After adaptive data segmentation and overlapped processing, ADS-HCSpark performs operations such as identifying active regions, local reassembly, likelihood calculation and assigning genotypes for all the alignment data in each data blocks in parallel. Finally, all the variants discovered are merged and output into a VCF file.</p>
      <p id="Par38">Combining all the above steps, the entire algorithm framework of ADS-HCSpark is illustrated in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. In the preprocessing, the program scans the input BAM file to obtain the sequence features of each original block. According to the preprocessing result and the rules mentioned above, data blocks to be split are predicted and segmented. Then overlapped blocks are read in parallel by customized Hadoop-BAM and finally variant calling is executed on them.<fig id="Fig2"><label>Fig. 2</label><caption><p>Algorithm framework diagram of ADS-HCSpark. The figure shows the entire algorithm framework of ADS-HCSpark. In the preprocessing, the program scans the input BAM file to obtain the sequence features of each original block. According to the preprocessing result and the rules mentioned above, data blocks to be split are predicted and segmented. Then overlapped blocks are read in parallel by customized Hadoop-BAM library and finally variant calling is executed on them</p></caption><graphic xlink:href="12859_2019_2665_Fig2_HTML" id="MO2"/></fig></p>
    </sec>
  </sec>
  <sec id="Sec8">
    <title>Results</title>
    <sec id="Sec9">
      <title>Experiment setup</title>
      <p id="Par39">ADS-HCSpark is evaluated on our cluster with 6 nodes. Each node is equipped with two E5–2670 CPU (2.6GHz, 8 cores) with 64 GB memory. The network is 1 GigE. Spark version is 2.2.0. Scala version is 2.11.8. The datasets used in the experiments are from the reference [<xref ref-type="bibr" rid="CR18">18</xref>] and the human genome data are selected. The datasets are described in detail in the Table <xref rid="Tab3" ref-type="table">3</xref>. Some program execution scripts and dataset details in the experiments are respectively described in the Additional files <xref rid="MOESM7" ref-type="media">7</xref> and <xref rid="MOESM8" ref-type="media">8</xref>.<table-wrap id="Tab3"><label>Table 3</label><caption><p>Experimental datasets</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Dataset</th><th>Genome</th><th>File format</th><th>Coverage depth</th><th>File size</th><th>Default number of data blocks</th></tr></thead><tbody><tr><td>D1</td><td>NA12878</td><td>BAM</td><td>14x</td><td>67.7GB</td><td>543</td></tr><tr><td>D2</td><td>NA12878</td><td>BAM</td><td>28x</td><td>128.5GB</td><td>1028</td></tr><tr><td>D3</td><td>NA18507</td><td>BAM</td><td>11x</td><td>59.3GB</td><td>475</td></tr><tr><td>D4</td><td>NA12878</td><td>BAM</td><td>60x</td><td>250.15GB</td><td>2002</td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec id="Sec10">
      <title>Parameters of adaptive segmentation</title>
      <p id="Par40">As mentioned above, our segmentation target is the top n% of the most time-consuming data blocks. In order to determine the value of n, the HaplotypeCaller algorithm is separately executed on every data block of the dataset D1 and their respective running time is recorded. Then data blocks are sorted by execution time from high to low and the percentage of time consumption for per 5% data blocks is counted, as is shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref>. It could be clearly found that the top 5% of the data blocks are up to 16.9% of the total running time and obviously higher than the latter. Thus, we consider this top 5% of data blocks as the long time-consuming blocks and our target is to predict and segment them.<fig id="Fig3"><label>Fig. 3</label><caption><p>The percentage of running time per 5% data blocks after all the data blocks are sorted. The HaplotypeCaller algorithm is separately executed on every original data blocks of dataset D1 and their respective running time is recorded. Then data blocks are sorted by execution time from high to low and the percentage of time consumption for per 5% data blocks is counted, as is shown in the figure</p></caption><graphic xlink:href="12859_2019_2665_Fig3_HTML" id="MO3"/></fig></p>
      <p id="Par41">To determine the parameters of predict rules, the specific segmentation ratio is adjusted on the dataset D1 and verified on the dataset D2, D3 and D4. The parameters chosen should allow our approach to find as many time-consuming raw data blocks as possible. For the parameters of four rules, when we set m% = 5%, k% = 7%, s% = 5%, and r% = 7%, the detailed situation of the segmentation indicators in each dataset is shown in Table <xref rid="Tab4" ref-type="table">4</xref>. Segmenting precision is defined as: <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \mathrm{P}=\frac{TP}{N} $$\end{document}</tex-math><mml:math id="M2" display="inline"><mml:mi mathvariant="normal">P</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi mathvariant="italic">TP</mml:mi><mml:mi>N</mml:mi></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2019_2665_Article_IEq1.gif"/></alternatives></inline-formula>, and segmenting recall is defined as: <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \mathrm{R}=\frac{TP}{M} $$\end{document}</tex-math><mml:math id="M4" display="inline"><mml:mi mathvariant="normal">R</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi mathvariant="italic">TP</mml:mi><mml:mi>M</mml:mi></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2019_2665_Article_IEq2.gif"/></alternatives></inline-formula>. TP is the number of true time-consuming data blocks in the predicted data blocks. N is the number of the predicted data blocks. M is the target number of time-consuming data blocks in the original data blocks. From Table <xref rid="Tab4" ref-type="table">4</xref>, the recall rates of segmenting on four datasets are high even reaching 100%, which means that our solution could find most or even all of the top 5% of the most time-consuming data blocks. This is the reason why adaptive data segmentation can solve the problem of computation skew. As for segmenting precision, it is maintained at approximately 33%, which indicates that some of the predicted data blocks are not time-consuming, but segmenting some non-target data blocks does not affect the final running time much. Because the problem of computation skew is mainly caused by time-consuming data blocks, as long as most of time-consuming blocks are included in our predicted blocks (meaning high recall rate), long tail tasks could be effectively avoided. Thus, we give priority to a high recall rate while allowing a certain precision ratio to be sacrificed.<table-wrap id="Tab4"><label>Table 4</label><caption><p>The detailed situation of the segmentation indicators in each dataset</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Dataset</th><th>D1</th><th>D2</th><th>D3</th><th>D4</th></tr></thead><tbody><tr><td>BAM file size</td><td>67.8GB</td><td>128.5GB</td><td>59.3GB</td><td>250.15GB</td></tr><tr><td>Default number of data blocks</td><td>543</td><td>1028</td><td>475</td><td>2002</td></tr><tr><td>Target number of segmentations (5%)</td><td>28</td><td>52</td><td>24</td><td>102</td></tr><tr><td>Actual number of segmentations</td><td>84</td><td>147</td><td>76</td><td>303</td></tr><tr><td>Actual proportion of segmenting</td><td>15.47%</td><td>14.3%</td><td>16%</td><td>15.13%</td></tr><tr><td>Number of matching blocks</td><td>27</td><td>52</td><td>24</td><td>101</td></tr><tr><td>Segmenting Precision</td><td>32.14%</td><td>35.37%</td><td>31.58%</td><td>33.33%</td></tr><tr><td>Segmenting Recall</td><td>96.43%</td><td>100%</td><td>100%</td><td>99.02%</td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec id="Sec11">
      <title>Impact of overlapped boundaries on the variant calling accuracy</title>
      <p id="Par42">In ADS-HCSpark, the size of overlapped boundaries of adjacent data blocks is set to the parameter <italic>overlapSize</italic> and different values of this parameter will affect the accuracy of variant calling. The following experiments were performed to evaluate the accuracy of ADS-HCSpark under different size of overlapped boundaries of adjacent blocks. The accuracy is evaluated by comparing the variants detected by ADS-HCSpark with the results of GATK3.8 HaplotypeCaller as a baseline. The experimental result is shown in Table <xref rid="Tab5" ref-type="table">5</xref>. Even though there are no overlapped boundaries of adjacent blocks, ADS-HCSpark could reach a high accuracy with over 99.9%. When there are overlapped boundaries of adjacent blocks, the accuracy of ADS-HCSpark is generally higher than that without overlapped boundaries, which explains that overlapped boundaries could maintain the integrity of variant calling. Simultaneously, overlapped boundaries of different sizes have a slight effect on the accuracy and overlapped boundaries are too small to completely cover the detection of the edges. When the size of overlapped boundaries of adjacent blocks is set to 512 KB, ADS-HCSpark achieves the highest accuracy and the accuracy tends to be stable when continuing to increase the size of overlapped area. Thus, the parameter <italic>overlapSize</italic> is set to 512 KB.</p>
      <table-wrap id="Tab5">
        <label>Table 5</label>
        <caption>
          <p>Accuracy of ADS-HCSpark in different sized overlapped boundaries</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th>Overlap Size</th>
              <th>D1</th>
              <th>D2</th>
              <th>D3</th>
              <th>D4</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>0 KB</td>
              <td>99.9828%</td>
              <td>99.9678%</td>
              <td>99.9887%</td>
              <td>99.9842%</td>
            </tr>
            <tr>
              <td>64 KB</td>
              <td>99.9829%</td>
              <td>99.9686%</td>
              <td>99.9896%</td>
              <td>99.9844%</td>
            </tr>
            <tr>
              <td>128 KB</td>
              <td>99.9831%</td>
              <td>99.9691%</td>
              <td>99.9891%</td>
              <td>99.9847%</td>
            </tr>
            <tr>
              <td>256 KB</td>
              <td>99.9832%</td>
              <td>99.9698%</td>
              <td>99.9891%</td>
              <td>99.9851%</td>
            </tr>
            <tr>
              <td>512 KB</td>
              <td>99.9835%</td>
              <td>99.9698%</td>
              <td>99.9893%</td>
              <td>99.9856%</td>
            </tr>
            <tr>
              <td>1024 KB</td>
              <td>99.9835%</td>
              <td>99.9698%</td>
              <td>99.9893%</td>
              <td>99.9856%</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec id="Sec12">
      <title>Performance analysis</title>
      <sec id="Sec13">
        <title>Data preprocessing</title>
        <p id="Par43">To analyze the performance of data preprocessing, the experiment was conducted on one node with different threads. The execution time and speedup of data preprocessing on four datasets are illustrated in Fig. <xref rid="Fig4" ref-type="fig">4</xref>. In the figure, T(D1), T(D2), T(D3), T(D4) represent the execution time of preprocessing on dataset D1, D2, D3, D4 and S(D1), S(D2), S(D3), S(D4) represent the speedup of preprocessing on dataset D1, D2, D3, D4. Speedup is defined as: <inline-formula id="IEq3"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \mathrm{S}=\frac{T_p}{T_s} $$\end{document}</tex-math><mml:math id="M6" display="inline"><mml:mi mathvariant="normal">S</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mi>T</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:msub><mml:mi>T</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2019_2665_Article_IEq3.gif"/></alternatives></inline-formula> . <italic>T</italic><sub><italic>p</italic></sub> represents the execution time to serially perform the algorithm and <italic>T</italic><sub><italic>s</italic></sub> represents the execution time to parallelly perform the algorithm on p processors. As the number of threads increases, the running time of preprocessing decreases and the speedup ratio is on the rise. When the number of threads exceeds 8, the speedup remains stable or drops slightly, which indicates that there is a bottleneck in the scalability of the preprocessing step. Figure <xref rid="Fig5" ref-type="fig">5</xref> shows the comparison of network transmission rates for different threads (1 t represents 1 thread in the figure) on dataset D1, which could be found that the bottleneck of the preprocessing step is the network bandwidth. The theoretical network transmission rate of Gigabit Ethernet is 120 MB/s. When executing preprocessing with 8 threads, the network transmission is already close to the bandwidth limit. Continuing to allocate more threads brings a lower promotion of performance and even may lead to performance degradation due to excessive threads competing for network resources. Thus, the optimal number of threads for data preprocessing step is 8 in a single-node and Gigabit Ethernet environment. In a multi-node cluster, the optimal number of threads in this step is 8 threads per node.<fig id="Fig4"><label>Fig. 4</label><caption><p>Execution time and speedup of preprocessing with different threads. The figure shows the execution time and speedup of data preprocessing on four datasets. T(D1), T(D2), T(D3), T(D4) represent the execution time of preprocessing on dataset D1, D2, D3, D4 and S(D1), S(D2), S(D3), S(D4) represent the speedup of preprocessing on dataset D1, D2, D3, D4</p></caption><graphic xlink:href="12859_2019_2665_Fig4_HTML" id="MO4"/></fig><fig id="Fig5"><label>Fig. 5</label><caption><p>Network transmission rate of preprocessing with different threads on D1. The figure shows the comparison of network transmission rate for different threads on dataset D1. Curves of different colors indicate different threads. 1 t represents 1 thread, 2 t represents 2 threads and so on</p></caption><graphic xlink:href="12859_2019_2665_Fig5_HTML" id="MO5"/></fig></p>
      </sec>
      <sec id="Sec14">
        <title>Adaptive data segmentation and scalability analysis</title>
        <p id="Par44">ADS-HC needs to segment the target data blocks and the different granularity of data segmentation will also affect the running time of ADS-HC. The granularity is the number of new data blocks divided from the time-consuming block. The following experiments were conducted to evaluate the impact of various granularity of data segmentation. The running time of different fine-grained segmenting numbers on a single node with 32 threads and a 6-node cluster with 192 threads is shown in Table <xref rid="Tab6" ref-type="table">6</xref>.<table-wrap id="Tab6"><label>Table 6</label><caption><p>ADS-HC running time with different granularity of data segmentation</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Execution time (min)</th><th>only sorted</th><th>2 blocks + sorted</th><th>4 blocks + sorted</th><th>6 blocks + sorted</th><th>8 blocks + sorted</th><th>0 blocks + no sorted</th></tr></thead><tbody><tr><td>D1 (1 node)</td><td>73.89</td><td>75.30</td><td>75.76</td><td>76.42</td><td>77.47</td><td>85.09</td></tr><tr><td>D2 (1 node)</td><td>100.14</td><td>101.05</td><td>103.79</td><td>105.12</td><td>103.44</td><td>106.68</td></tr><tr><td>D3 (1 node)</td><td>71.45</td><td>71.43</td><td>72.67</td><td>73.30</td><td>75.11</td><td>80.67</td></tr><tr><td>D4 (1 node)</td><td>160.59</td><td>161.40</td><td>164.32</td><td>165.93</td><td>168.43</td><td>182.85</td></tr><tr><td>D1 (6 nodes)</td><td>27.32</td><td>20.34</td><td>19.46</td><td>18.41</td><td>18.49</td><td>33.92</td></tr><tr><td>D2 (6 nodes)</td><td>33.02</td><td>28.95</td><td>27.15</td><td>26.01</td><td>26.22</td><td>40.32</td></tr><tr><td>D3 (6 nodes)</td><td>26.21</td><td>20.96</td><td>19.31</td><td>19.33</td><td>20.65</td><td>33.14</td></tr><tr><td>D4 (6 nodes)</td><td>47.38</td><td>44.42</td><td>43.75</td><td>43.22</td><td>43.22</td><td>62.13</td></tr></tbody></table></table-wrap></p>
        <p id="Par45">In Table <xref rid="Tab6" ref-type="table">6</xref>, “only sorted” strategy represents that after preprocessing, only data blocks are sorted by processing priority from high to low and the time-consuming data blocks are directly processed without being segmented. “n blocks + sorted” strategy means that every target data block is equally segmented to n new blocks after preprocessing and they are set to higher processing priority. Then data blocks are sorted by processing priority from high to low. The last column “0 blocks + no sorted” strategy is the control group in which the BAM file is segmented and processed by default Spark framework without any preprocessing.</p>
        <p id="Par46">In the experiment on a single node, running time of “only sorted” strategy is usually shorter than others. This is because all four datasets are quite large and their default numbers of partitions are a lot, while the degree of parallelism (execution threads) of one node is low. In this case, each thread needs to execute more tasks, so long tail tasks could be avoided by prioritizing time-consuming blocks even without fine-grained segmentation. Furthermore, excessive blocks will lead to extra scheduling overhead. Therefore, with more default blocks and lower degree of parallelism, “only sorted” strategy can achieve better results. However, when ADS-HC runs on a cluster with 6 nodes, the degree of parallelism is much more than that of one single node, so it needs to segment the default data blocks properly to avoid long tail tasks. The running time of “6 blocks + sorted” strategy is shorter than that of others. Too few segments could not avoid long tail tasks and excessive segments will cause extra overhead. Summarizing above experimental results, compared to the default blocking mode, the adaptive data segmentation strategy could effectively predict and segment the time-consuming data blocks, thus avoiding long tail tasks and addressing the problem of computation skew.</p>
        <p id="Par47">The scalability of ADS-HC is evaluated on a 6-node cluster with different threads using the “6 blocks + sorted” strategy. The running time and the corresponding speedup on four datasets are illustrated in Fig. <xref rid="Fig6" ref-type="fig">6</xref>. In the figure, T(D1), T(D2), T(D3), T(D4) represent the execution time on dataset D1, D2, D3, D4 and S(D1), S(D2), S(D3), S(D4) represent the speedup ratio on dataset D1, D2, D3, D4. From the experimental results, as the number of threads increases, the execution time decreases and the speedup rate increases. Particularly, when the number of threads increases from 1 to 96, ADS-HC achieves good scalability, and the speedup rate linearly increases, approximately. While the number of threads exceeds 96, the speedup ratio increases slowly, because the average number of threads used per node is more than 16 at this time. Although each node could support up to 32 threads with 32 logical cores, there are only 16 physical cores. In these datasets, D4 is the completed NA12878 dataset with the coverage depth of 60x. From the experimental results, ADS-HCSpark achieves good scalability for datasets of different size and coverage depth, which proves that it could be used to execute variant calling on large scale datasets.<fig id="Fig6"><label>Fig. 6</label><caption><p>Execution time and speedup of ADS-HC with different threads on 6 nodes. The figure shows that the execution time and the corresponding speedup of ADS-HC with different threads on a 6-node cluster. T(D1), T(D2), T(D3), T(D4) represent the running time on dataset D1, D2, D3, D4 and S(D1), S(D2), S(D3), S(D4) represent the speedup ratio on dataset D1, D2, D3, D4</p></caption><graphic xlink:href="12859_2019_2665_Fig6_HTML" id="MO6"/></fig></p>
      </sec>
    </sec>
    <sec id="Sec15">
      <title>Comparison with GATK and SparkGA</title>
      <sec id="Sec16">
        <title>Multiple threads on single node</title>
        <p id="Par48">GATK HaplotypeCalller is the benchmark of variant calling tool, which supports multithreading on single node. Our ADS-HCSpark is also implemented based on GATK3.8 HaplotypeCaller. In the previous analysis, the time-consuming characteristics of four datasets are similar, so we take dataset D1 as an example to compare the execution time and scalability of ADS-HCSpark with that of GATK3.8 HaplotypeCaller on a single node. HaplotypeCaller includes two steps: building index and variant calling, while ADS-HCSpark also consists of two parts: data preprocessing and ADS-HC. The experimental result is shown in Table <xref rid="Tab7" ref-type="table">7</xref>, and corresponding diagram is illustrated in Fig. <xref rid="Fig7" ref-type="fig">7</xref>. In the figure, T (GATK3.8 HaplotypeCaller), T (ADS-HCSpark) represent the execution time of GATK3.8 HaplotypeCaller and ADS-HCSpark. S (GATK3.8 HaplotypeCaller), S (ADS-HCSpark) represent the speedup of GATK3.8 HaplotypeCaller and ADS-HCSpark. In case of full load with 32 threads, where both tools achieve optimal performance, the running time of ADS-HCSpark is reduced by 74.33% compared to GATK3.8 HaplotypeCalller. After GATK3.8 HaplotypeCaller reaches 8 threads, the speedup remains around 4, while the speedup ratio of ADS-HCSpark continues to increase, eventually reaching 16.5, which is more scalable than GATK3.8 HaplotypeCaller. The CPU utilization of GATK3.8 HaplotypeCaller is lower than that of ADS-HCSpark, because in GATK3.8 HaplotypeCaller, data are serially read and processed firstly, consuming too much time and easily causing waiting among threads. Conversely, ADS-HCSpark uses customized Hadoop-BAM to read alignment data in parallel, achieving high CPU utilization.<fig id="Fig7"><label>Fig. 7</label><caption><p>Comparison of execution time and speedup on a single node. The figure shows the comparison of execution time and speedup between GATK3.8 HaplotypeCaller and ADS-HCSpark on a single node with different threads. T (GATK3.8 HaplotypeCaller), T (ADS-HCSpark) represent the execution time of GATK3.8 HaplotypeCaller and ADS-HCSpark. S (GATK3.8 HaplotypeCaller), S (ADS-HCSpark) represent the speedup of GATK3.8 HaplotypeCaller and ADS-HCSpark</p></caption><graphic xlink:href="12859_2019_2665_Fig7_HTML" id="MO7"/></fig></p>
      </sec>
      <sec id="Sec17">
        <title>Multiple threads on multiple nodes</title>
        <p id="Par49">GATK4.0 is a toolkit developed by Broad Institute based on Spark framework and HaplotypeCallerSpark is its variant calling tool, which could run on a multi-node cluster. SparkGA is also a high-performance genome analysis toolkit based on Spark framework. The experiments were conducted to compare both running time and scalability among these three tools on a cluster with 6 nodes on dataset D1. ADS-HCSpark includes data preprocessing and variant calling, while GATK4 HaplotypeCallerSpark and SparkGA only includes variant calling stage. Table <xref rid="Tab8" ref-type="table">8</xref> describes the running time of them with different threads and the corresponding diagram is illustrated in Fig. <xref rid="Fig8" ref-type="fig">8</xref>. In the figure, T (GATK4 HaplotypeCallerSpark), T (SparkGA), T (ADS-HCSpark) represent the execution time of GATK4.0 HaplotypeCallerSpark, SparkGA and ADS-HCSpark. S (GATK4 HaplotypeCallerSpark), S (SparkGA), S (ADS-HCSpark) represent the speedup of GATK4.0 HaplotypeCallerSpark, SparkGA and ADS-HCSpark. Since GATK4 HaplotypeCallerSpark consumes a large amount of memory, this experimental platform cannot support HaplotypeCallerSpark running on 6 nodes over 96 threads. With 96 threads, ADS-HCSpark is 57.69% faster than GATK4 HaplotypeCallerSpark. Besides, its speedup is low and only reaches around 30 at the end. The speedup of ADS-HCSpark continues to increase and eventually reaches 60. Therefore, the scalability of ADS-HCSpark on 6 nodes is far better than that of GATK4 HaplotypeCallerSpark. As for the comparison between SparkGA and ADS-HCSpark, in case of full load with 192 threads, ADS-HCSpark is 27.91% faster than SparkGA and it is similar in the trend of their speedup ratios. Since the adaptive data segmentation, ADS-HCSpark effectively avoids long tail tasks and outperforms SparkGA in execution time.<table-wrap id="Tab7"><label>Table 7</label><caption><p>Comparison of execution time on D1 (unit: min)</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Number of threads</th><th>1</th><th>8</th><th>16</th><th>24</th><th>32</th></tr></thead><tbody><tr><td>GATK3.8 HaplotypeCaller</td><td>1372.33</td><td>369.77</td><td>356.21</td><td>361.19</td><td>326.48</td></tr><tr><td>ADS-HCSpark</td><td>1384.21</td><td>180.07</td><td>110.40</td><td>92.34</td><td>83.81</td></tr></tbody></table></table-wrap><fig id="Fig8"><label>Fig. 8</label><caption><p>Comparison of execution time and speedup on 6 nodes. The figure shows the comparison of execution time and speedup with different threads on a 6-node cluster among three tools: GATK4.0 HaplotypeCallerSpark, SparkGA and ADS-HCSpark. T (GATK4 HaplotypeCallerSpark), T (SparkGA), T (ADS-HCSpark) represent the execution time of GATK4.0 HaplotypeCallerSpark, SparkGA and ADS-HCSpark. S (GATK4 HaplotypeCallerSpark), S (SparkGA), S (ADS-HCSpark) represent the speedup of GATK4.0 HaplotypeCallerSpark, SparkGA and ADS-HCSpark</p></caption><graphic xlink:href="12859_2019_2665_Fig8_HTML" id="MO8"/></fig><table-wrap id="Tab8"><label>Table 8</label><caption><p>Comparison of execution time on D1 (unit: min)</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Number of threads</th><th>6</th><th>12</th><th>24</th><th>48</th><th>96</th><th>192</th></tr></thead><tbody><tr><td>GATK4 HaplotypeCallerSpark</td><td>306.32</td><td>170.32</td><td>105.91</td><td>76.41</td><td>59.56</td><td>–</td></tr><tr><td>SparkGA</td><td>286.18</td><td>145.35</td><td>85.94</td><td>51.29</td><td>36.76</td><td>28.73</td></tr><tr><td>ADS-HCSpark</td><td>209.93</td><td>109.96</td><td>58.45</td><td>34.70</td><td>24.97</td><td>20.71</td></tr></tbody></table></table-wrap></p>
      </sec>
    </sec>
  </sec>
  <sec id="Sec18">
    <title>Conclusion</title>
    <p id="Par50">In this paper, we present ADS-HCSpark, a scalable tool for variant calling based on Spark framework. ADS-HCSpark implements the parallelization of the mainstream variant calling algorithm HaplotypeCaller on multi-node and multi-core, accelerating the procession of variant calling. In ADS-HCSpark, a parallel strategy of adaptive data segmentation is proposed and a variant caller based on adaptive data segmentation (ADS-HC) is implemented to solve the problem of computation skew in HaplotypeCaller. Furthermore, for the requirement that adjacent data blocks should have overlapped boundaries, Hadoop-BAM library is customized to implement partitioning BAM file into overlapped blocks, improving the accuracy of variant calling. The performance of ADS-HCSpark is evaluated and the experimental result demonstrates that in the case of best performance that could be achieved in this experimental platform, ADS-HCSpark is 74% faster than GATK3.8 HaplotypeCaller on single-node experiments, 57% faster than GATK4.0 HaplotypeCallerSpark and 27% faster than SparkGA on multi-node experiments, with better scalability and the accuracy of over 99%. The future work will be to optimize performance and scale to large scale cloud computing platform.</p>
  </sec>
  <sec id="Sec19">
    <title>Availability and requirements</title>
    <p id="Par51"><bold>Project name:</bold> ASD-HCSpark</p>
    <p id="Par52"><bold>Project home page:</bold><ext-link ext-link-type="uri" xlink:href="http://github.com/SCUT-CCNL/ADS-HCSpark.git">http://github.com/SCUT-CCNL/ADS-HCSpark.git</ext-link>.</p>
    <p id="Par53"><bold>Operating system:</bold> Linux</p>
    <p id="Par54"><bold>Programming language:</bold> Java</p>
    <p id="Par55"><bold>Other requirements:</bold> Java 1.8, Scala 2.11.8, Hadoop 2.6.4, Spark2.2.0, Maven 3.5.3</p>
    <p id="Par56"><bold>License:</bold> New BSD License</p>
    <p id="Par57"><bold>Any restrictions to use by non-academics:</bold> none</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Additional files</title>
    <sec id="Sec20">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="12859_2019_2665_MOESM1_ESM.zip">
            <label>Additional file 1:</label>
            <caption>
              <p>ADS-HCSpark’s source code. This is a compressed file and needs to be decompressed first. It contains all the code for this software. (ZIP 1793 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM2">
          <media xlink:href="12859_2019_2665_MOESM2_ESM.pdf">
            <label>Additional file 2:</label>
            <caption>
              <p>ADS-HCSpark’s usage document. This file introduces the software preparation environment and how to build and use ASD-HCSpark. (PDF 89 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM3">
          <media xlink:href="12859_2019_2665_MOESM3_ESM.pdf">
            <label>Additional file 3:</label>
            <caption>
              <p>The algorithm description of data preprocessing. This file includes the algorithm table and implementation details of data preprocessing. (PDF 47 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM4">
          <media xlink:href="12859_2019_2665_MOESM4_ESM.pdf">
            <label>Additional file 4:</label>
            <caption>
              <p>The algorithm description of computing the index number of data block to be split. This file includes the algorithm table and implementation details of computing the index number of data block to be split. (PDF 66 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM5">
          <media xlink:href="12859_2019_2665_MOESM5_ESM.pdf">
            <label>Additional file 5:</label>
            <caption>
              <p>The algorithm description of segmenting data blocks and sorting. This file includes the algorithm table and implementation details of segmenting data blocks and sorting. (PDF 51 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM6">
          <media xlink:href="12859_2019_2665_MOESM6_ESM.pdf">
            <label>Additional file 6:</label>
            <caption>
              <p>The algorithm description of acquiring overlapped data segments. This file includes the algorithm table and implementation details of acquiring overlapped data segments. (PDF 55 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM7">
          <media xlink:href="12859_2019_2665_MOESM7_ESM.pdf">
            <label>Additional file 7:</label>
            <caption>
              <p>The execution scripts. This file contains some execution scripts used in the experiments and some parameter settings. (PDF 64 kb)</p>
            </caption>
          </media>
        </supplementary-material>
        <supplementary-material content-type="local-data" id="MOESM8">
          <media xlink:href="12859_2019_2665_MOESM8_ESM.pdf">
            <label>Additional file 8:</label>
            <caption>
              <p>Dataset document. This file describes the datasets used in the experiments. (PDF 19 kb)</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>ADS-HC</term>
        <def>
          <p id="Par4">a variant calling algorithm based on adaptive data segmentation</p>
        </def>
      </def-item>
      <def-item>
        <term>CPU</term>
        <def>
          <p id="Par5">Central Processing Unit</p>
        </def>
      </def-item>
      <def-item>
        <term>DNA</term>
        <def>
          <p id="Par6">Deoxyribonucleic acid</p>
        </def>
      </def-item>
      <def-item>
        <term>GATK</term>
        <def>
          <p id="Par7">Genome Analysis Toolkit</p>
        </def>
      </def-item>
      <def-item>
        <term>GigE</term>
        <def>
          <p id="Par8">Gigabit Ethernet</p>
        </def>
      </def-item>
      <def-item>
        <term>HDFS</term>
        <def>
          <p id="Par9">Hadoop file system</p>
        </def>
      </def-item>
      <def-item>
        <term>I/O</term>
        <def>
          <p id="Par10">input/output</p>
        </def>
      </def-item>
      <def-item>
        <term>NGS</term>
        <def>
          <p id="Par11">next-generation sequencing</p>
        </def>
      </def-item>
      <def-item>
        <term>SNP</term>
        <def>
          <p id="Par12">single nucleotide polymorphism</p>
        </def>
      </def-item>
      <def-item>
        <term>VCF</term>
        <def>
          <p id="Par13">Variant Call Format</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors would like to thank Mr. Yong Zhang and Shengkang Li of Beijing Genomics Institute (BGI) for great help and guidance in the processing of genes data and providing test platforms for tools in our research.</p>
    <sec id="FPar1">
      <title>Funding</title>
      <p id="Par58">This study was supported by a grant (2015A030308017) from Guangdong Natural Science Foundation of China. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</p>
    </sec>
    <sec id="FPar2" sec-type="data-availability">
      <title>Availability of data and materials</title>
      <p id="Par59">The datasets supporting the conclusions of this paper are available from <ext-link ext-link-type="uri" xlink:href="http://smash.cs.berkeley.edu">http://smash.cs.berkeley.edu</ext-link>. Our software ADS-HCSpark are available from <ext-link ext-link-type="uri" xlink:href="https://github.com/SCUT-CCNL/ADS-HCSpark.git">https://github.com/SCUT-CCNL/ADS-HCSpark.git</ext-link>.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>AX summarized the software, performed the experiments and wrote the paper. ZW designed the algorithms and coded the programs. SD guided the project, advised on the design of the software and modified the paper. All authors read and approved the manuscript.</p>
  </notes>
  <notes notes-type="COI-statement">
    <sec id="FPar3">
      <title>Ethics approval and consent to participate</title>
      <p>The datasets used in the experiment are publicly available on the website <ext-link ext-link-type="uri" xlink:href="http://smash.cs.berkeley.edu">http://smash.cs.berkeley.edu</ext-link>, so the ethics approval is not required.</p>
    </sec>
    <sec id="FPar4">
      <title>Consent for publication</title>
      <p>Not applicable.</p>
    </sec>
    <sec id="FPar5">
      <title>Competing interests</title>
      <p>The authors declare that they have no competing interests.</p>
    </sec>
    <sec id="FPar6">
      <title>Publisher’s Note</title>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </sec>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>CORNELISSEN</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>GALL</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>VINK</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>From clinical sample to complete genome: comparing methods for the extraction of HIV-1 RNA for high-throughput deep sequencing</article-title>
        <source>Virus Res</source>
        <year>2017</year>
        <volume>239</volume>
        <fpage>10</fpage>
        <lpage>16</lpage>
        <pub-id pub-id-type="doi">10.1016/j.virusres.2016.08.004</pub-id>
        <pub-id pub-id-type="pmid">27497916</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McKenna</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Hanna</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Banks</surname>
            <given-names>E</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The genome analysis toolkit: a MapReduce framework for analyzing next-generation DNA sequencing data</article-title>
        <source>Genome Res</source>
        <year>2010</year>
        <volume>20</volume>
        <issue>9</issue>
        <fpage>1297</fpage>
        <lpage>1303</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.107524.110</pub-id>
        <pub-id pub-id-type="pmid">20644199</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Highnam</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>JJ</given-names>
          </name>
          <name>
            <surname>Kusler</surname>
            <given-names>D</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>An analytical framework for optimizing variant discovery from personal genomes</article-title>
        <source>Nat Commun</source>
        <year>2015</year>
        <volume>6</volume>
        <fpage>6275</fpage>
        <pub-id pub-id-type="doi">10.1038/ncomms7275</pub-id>
        <pub-id pub-id-type="pmid">25711446</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hwang</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>I</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Systematic comparison of variant calling pipelines using gold standard personal exome variants</article-title>
        <source>Sci Rep</source>
        <year>2015</year>
        <volume>5</volume>
        <fpage>17875</fpage>
        <pub-id pub-id-type="doi">10.1038/srep17875</pub-id>
        <pub-id pub-id-type="pmid">26639839</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Handsaker</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Wysoker</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>The sequence alignment/map format and SAMtools</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>16</issue>
        <fpage>2078</fpage>
        <lpage>2079</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp352</pub-id>
        <pub-id pub-id-type="pmid">19505943</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <mixed-citation publication-type="other">Huang S, Manikandan GJ, Ramachandran A, et al. Hardware acceleration of the pair-HMM algorithm for DNA variant calling. Proceedings of the 2017 ACM/SIGDA International Symposium on Field-Programmable Gate Arrays. 2017:275–84.</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <mixed-citation publication-type="other">Deng L, Huang G, Zhuang Y, et al. HiGene: A high-performance platform for genomic data analysis. IEEE International Conference on Bioinformatics and Biomedicine. 2016:576–83.</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zaharia</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Franklin</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Ghodsi</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Apache spark: a unified engine for big data processing</article-title>
        <source>Commun ACM</source>
        <year>2016</year>
        <volume>59</volume>
        <issue>11</issue>
        <fpage>56</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="doi">10.1145/2934664</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Taylor</surname>
            <given-names>RC</given-names>
          </name>
        </person-group>
        <article-title>An overview of the Hadoop/MapReduce/HBase framework and its current applications in bioinformatics</article-title>
        <source>BMC Bioinformatics</source>
        <year>2010</year>
        <volume>11</volume>
        <issue>Suppl 12</issue>
        <fpage>S1</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-11-S12-S1</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <mixed-citation publication-type="other">O'Connor B D, Merriman B, Nelson S F. SeqWare Query Engine: storing and searching sequence data in the cloud. BMC Bioinformatics. 2010; 11 Suppl 12: S2-S2.</mixed-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <mixed-citation publication-type="other">GATK Queue. <ext-link ext-link-type="uri" xlink:href="https://software.broadinstitute.org/gatk/documentation/index#intro1306">https://software.broadinstitute.org/gatk/documentation/index#intro1306</ext-link>. Accessed 23 Mar 2018.</mixed-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Decap</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Reumers</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Herzeel</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Halvade: scalable sequence analysis with MapReduce</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <issue>15</issue>
        <fpage>2482</fpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv179</pub-id>
        <pub-id pub-id-type="pmid">25819078</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kelly</surname>
            <given-names>BJ</given-names>
          </name>
          <name>
            <surname>Fitch</surname>
            <given-names>JR</given-names>
          </name>
          <name>
            <surname>Hu</surname>
            <given-names>Y</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Churchill: an ultra-fast, deterministic, highly scalable and balanced parallelization strategy for the discovery of human genetic variation in clinical and population-scale genomics</article-title>
        <source>Genome Biol</source>
        <year>2015</year>
        <volume>16</volume>
        <issue>1</issue>
        <fpage>6</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-014-0577-x</pub-id>
        <pub-id pub-id-type="pmid">25600152</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <mixed-citation publication-type="other">Garrison E, Marth G. Haplotype-based variant detection from short-read sequencing. arXiv preprint arXiv. 2012;(1207):3907.</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <mixed-citation publication-type="other">Mushtaq H, Liu F, Costa C, et al. SparkGA: A Spark Framework for Cost Effective, Fast and Accurate DNA Analysis at Scale. Proceedings of the 8th ACM International Conference on Bioinformatics, Computational Biology, and Health Informatics. 2017:148–57.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <mixed-citation publication-type="other">Broad Institute Gatk 4.0. <ext-link ext-link-type="uri" xlink:href="https://software.broadinstitute.org/gatk/gatk4">https://software.broadinstitute.org/gatk/gatk4</ext-link>. Accessed 11 May 2018.</mixed-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Niemenmaa</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kallio</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Schumacher</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Hadoop-BAM: directly manipulating next generation sequencing data in the cloud</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>6</issue>
        <fpage>876</fpage>
        <lpage>877</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts054</pub-id>
        <pub-id pub-id-type="pmid">22302568</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Talwalkar</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Liptrap</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Newcomb</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>SMaSH: A benchmarking toolkit for human genome variant calling</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <issue>19</issue>
        <fpage>2787</fpage>
        <lpage>2795</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu345</pub-id>
        <pub-id pub-id-type="pmid">24894505</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
