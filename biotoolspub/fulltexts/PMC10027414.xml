<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinform Adv</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinform Adv</journal-id>
    <journal-id journal-id-type="publisher-id">bioadv</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics Advances</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2635-0041</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10027414</article-id>
    <article-id pub-id-type="doi">10.1093/bioadv/vbad030</article-id>
    <article-id pub-id-type="publisher-id">vbad030</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Gene Expression</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>scAnnotate: an automated cell-type annotation tool for single-cell RNA-sequencing data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Ji</surname>
          <given-names>Xiangling</given-names>
        </name>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Data curation" vocab-term-identifier="http://credit.niso.org/contributor-roles/data-curation" degree-contribution="equal">Data curation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Formal analysis" vocab-term-identifier="http://credit.niso.org/contributor-roles/formal-analysis" degree-contribution="lead">Formal analysis</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Software" vocab-term-identifier="http://credit.niso.org/contributor-roles/software" degree-contribution="equal">Software</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Validation" vocab-term-identifier="http://credit.niso.org/contributor-roles/validation" degree-contribution="equal">Validation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Visualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/visualization" degree-contribution="equal">Visualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Writing – original draft" vocab-term-identifier="http://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="equal">Writing – original draft</role>
        <aff><institution>Department of Mathematics and Statistics, University of Victoria</institution>, Victoria V8P 5C2, <country country="CA">Canada</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tsao</surname>
          <given-names>Danielle</given-names>
        </name>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Data curation" vocab-term-identifier="http://credit.niso.org/contributor-roles/data-curation" degree-contribution="supporting">Data curation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Formal analysis" vocab-term-identifier="http://credit.niso.org/contributor-roles/formal-analysis" degree-contribution="equal">Formal analysis</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Software" vocab-term-identifier="http://credit.niso.org/contributor-roles/software" degree-contribution="equal">Software</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Validation" vocab-term-identifier="http://credit.niso.org/contributor-roles/validation" degree-contribution="equal">Validation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Visualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/visualization" degree-contribution="equal">Visualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Writing – review &amp; editing" vocab-term-identifier="http://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing – review &amp; editing</role>
        <aff><institution>Department of Mathematics and Statistics, University of Victoria</institution>, Victoria V8P 5C2, <country country="CA">Canada</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bai</surname>
          <given-names>Kailun</given-names>
        </name>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Data curation" vocab-term-identifier="http://credit.niso.org/contributor-roles/data-curation" degree-contribution="equal">Data curation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Formal analysis" vocab-term-identifier="http://credit.niso.org/contributor-roles/formal-analysis" degree-contribution="supporting">Formal analysis</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Writing – review &amp; editing" vocab-term-identifier="http://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing – review &amp; editing</role>
        <aff><institution>Department of Mathematics and Statistics, University of Victoria</institution>, Victoria V8P 5C2, <country country="CA">Canada</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tsao</surname>
          <given-names>Min</given-names>
        </name>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/conceptualization" degree-contribution="supporting">Conceptualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="http://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="supporting">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="http://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="http://credit.niso.org/contributor-roles/methodology" degree-contribution="equal">Methodology</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="http://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Resources" vocab-term-identifier="http://credit.niso.org/contributor-roles/resources" degree-contribution="equal">Resources</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Software" vocab-term-identifier="http://credit.niso.org/contributor-roles/software" degree-contribution="equal">Software</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="http://credit.niso.org/contributor-roles/supervision" degree-contribution="equal">Supervision</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Validation" vocab-term-identifier="http://credit.niso.org/contributor-roles/validation" degree-contribution="equal">Validation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Visualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/visualization" degree-contribution="equal">Visualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Writing – review &amp; editing" vocab-term-identifier="http://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing – review &amp; editing</role>
        <aff><institution>Department of Mathematics and Statistics, University of Victoria</institution>, Victoria V8P 5C2, <country country="CA">Canada</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Xing</surname>
          <given-names>Li</given-names>
        </name>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/conceptualization" degree-contribution="supporting">Conceptualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="http://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="supporting">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="http://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="http://credit.niso.org/contributor-roles/methodology" degree-contribution="equal">Methodology</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="http://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Resources" vocab-term-identifier="http://credit.niso.org/contributor-roles/resources" degree-contribution="equal">Resources</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Software" vocab-term-identifier="http://credit.niso.org/contributor-roles/software" degree-contribution="equal">Software</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="http://credit.niso.org/contributor-roles/supervision" degree-contribution="equal">Supervision</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Validation" vocab-term-identifier="http://credit.niso.org/contributor-roles/validation" degree-contribution="equal">Validation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Visualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/visualization" degree-contribution="equal">Visualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Writing – review &amp; editing" vocab-term-identifier="http://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing – review &amp; editing</role>
        <aff><institution>Department of Mathematics and Statistics, University of Saskatchewan</institution>, Saskatoon S7N 5C9, <country country="CA">Canada</country></aff>
        <xref rid="vbad030-cor1" ref-type="corresp"/>
        <!--li.xing@math.usask.ca-->
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-4728-2343</contrib-id>
        <name>
          <surname>Zhang</surname>
          <given-names>Xuekui</given-names>
        </name>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/conceptualization" degree-contribution="lead">Conceptualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="http://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="lead">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="http://credit.niso.org/contributor-roles/investigation" degree-contribution="equal">Investigation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="http://credit.niso.org/contributor-roles/methodology" degree-contribution="equal">Methodology</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="http://credit.niso.org/contributor-roles/project-administration" degree-contribution="equal">Project administration</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Resources" vocab-term-identifier="http://credit.niso.org/contributor-roles/resources" degree-contribution="equal">Resources</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Software" vocab-term-identifier="http://credit.niso.org/contributor-roles/software" degree-contribution="equal">Software</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="http://credit.niso.org/contributor-roles/supervision" degree-contribution="equal">Supervision</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Validation" vocab-term-identifier="http://credit.niso.org/contributor-roles/validation" degree-contribution="equal">Validation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Visualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/visualization" degree-contribution="equal">Visualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Writing – review &amp; editing" vocab-term-identifier="http://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing – review &amp; editing</role>
        <aff><institution>Department of Mathematics and Statistics, University of Victoria</institution>, Victoria V8P 5C2, <country country="CA">Canada</country></aff>
        <xref rid="vbad030-cor1" ref-type="corresp"/>
        <!--xuekui@uvic.ca-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Lengauer</surname>
          <given-names>Thomas</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="vbad030-cor1">To whom correspondence should be addressed. <email>xuekui@uvic.ca</email> or <email>li.xing@math.usask.ca</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-03-13">
      <day>13</day>
      <month>3</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>13</day>
      <month>3</month>
      <year>2023</year>
    </pub-date>
    <volume>3</volume>
    <issue>1</issue>
    <elocation-id>vbad030</elocation-id>
    <history>
      <date date-type="received">
        <day>07</day>
        <month>11</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>28</day>
        <month>2</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>05</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>10</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>20</day>
        <month>3</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="vbad030.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Single-cell RNA-sequencing (scRNA-seq) technology enables researchers to investigate a genome at the cellular level with unprecedented resolution. An organism consists of a heterogeneous collection of cell types, each of which plays a distinct role in various biological processes. Hence, the first step of scRNA-seq data analysis is often to distinguish cell types so they can be investigated separately. Researchers have recently developed several automated cell-type annotation tools, requiring neither biological knowledge nor subjective human decisions. Dropout is a crucial characteristic of scRNA-seq data widely used in differential expression analysis. However, no current cell annotation method explicitly utilizes dropout information. Fully utilizing dropout information motivated this work.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present scAnnotate, a cell annotation tool that fully utilizes dropout information. We model every gene’s marginal distribution using a mixture model, which describes both the dropout proportion and the distribution of the non-dropout expression levels. Then, using an ensemble machine learning approach, we combine the mixture models of all genes into a single model for cell-type annotation. This combining approach can avoid estimating numerous parameters in the high-dimensional joint distribution of all genes. Using 14 real scRNA-seq datasets, we demonstrate that scAnnotate is competitive against nine existing annotation methods. Furthermore, because of its distinct modelling strategy, scAnnotate’s misclassified cells differ greatly from competitor methods. This suggests using scAnnotate together with other methods could further improve annotation accuracy.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>We implemented scAnnotate as an R package and made it publicly available from CRAN: <ext-link xlink:href="https://cran.r-project.org/package=scAnnotate" ext-link-type="uri">https://cran.r-project.org/package=scAnnotate</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics Advances</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Genome BC SIP7</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Natural Sciences and Engineering Research Council of Canada</institution>
            <institution-id institution-id-type="DOI">10.13039/501100000038</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Many biological processes in the human body rely on the coaction of numerous cell types, each with its own designated function. Cell identification is thus crucial in studying biological phenomena and developing medical practices; pathology, for example, hinges on the accuracy of this task. Although standard immunophenotyping methods are widely practiced for cell identification, their heavy reliance on the manual selection of antibodies, markers and fluorochromes renders new and rare cell types particularly difficult to identify (<xref rid="vbad030-B15" ref-type="bibr">Gown, 2008</xref>; <xref rid="vbad030-B25" ref-type="bibr">Leach <italic toggle="yes">et al.</italic>, 2013</xref>). Conversely, newly developed single-cell RNA sequencing (scRNA-seq) technologies (<xref rid="vbad030-B36" ref-type="bibr">Tang <italic toggle="yes">et al.</italic>, 2009</xref>) have heightened the detail with which we can examine cell composition by offering an unprecedented resolution of gene expression at the cellular level. The recent surge of available scRNA-seq data allows for increased accuracy in several aspects of genomic data analysis, including cell annotation (<xref rid="vbad030-B4" ref-type="bibr">Artegiani <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="vbad030-B7" ref-type="bibr">Chen <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="vbad030-B11" ref-type="bibr">Diaz-Mejia <italic toggle="yes">et al.</italic>, 2019</xref>).</p>
    <p>Cell-type annotation using scRNA-seq data enables researchers to distinguish various types of cells from heterozygous populations, then investigate each cell type separately and learn their interactions. Hence, cell-type annotation is often the first step of scRNA-seq data analysis, which has led to a recent surge of methods developed for this task. <xref rid="vbad030-B32" ref-type="bibr">Pasquini <italic toggle="yes">et al.</italic> (2021)</xref> discuss 24 scRNA-seq cell-type annotation methods developed in the last 5 years. The most popular cell-type annotation approach was clustering analysis followed by manual annotation. The most important advantage of such an approach is that it does not require training a model using another ‘annotated’ scRNA-seq dataset. However, such unsupervised machine learning approaches have a critical issue; namely, they require users to manually label the cell types for each cluster of cells. The manual decisions need special biological knowledge and are subjective to researchers’ individual opinions, which can be time-consuming and inconsistent. In the last few years, a huge amount of scRNA-seq data were generated and made publicly available. These rich resources made it easier and easier to identify suitable data for training supervised machine learning models to annotate new scRNA-seq data. Recently, many supervised machine learning methods have been developed for cell-type annotation.</p>
    <p>Currently, the discriminative classification approach dominates supervised machine learning methods for cell-type annotation. This discriminative classification approach models the distribution of cell types conditional on genomic data. For example, CaSTLe (<xref rid="vbad030-B28" ref-type="bibr">Lieberman <italic toggle="yes">et al.</italic>, 2018</xref>) employs an XGBoost (<xref rid="vbad030-B8" ref-type="bibr">Chen and Guestrin, 2016</xref>) classification model and SingleCellNet (<xref rid="vbad030-B35" ref-type="bibr">Tan and Cahan, 2019</xref>) trains a Random Forest classifier on discriminating gene pairs. CHETAH (<xref rid="vbad030-B10" ref-type="bibr">de Kanter <italic toggle="yes">et al.</italic>, 2019</xref>) and scClassify (<xref rid="vbad030-B29" ref-type="bibr">Lin <italic toggle="yes">et al.</italic>, 2020</xref>) construct hierarchical classification trees and evaluate the correlation of query cells to reference cell types or apply an ensemble of weighted K-Nearest Neighbors Algorithm (kNN) classifiers, respectively. In SingleR (<xref rid="vbad030-B3" ref-type="bibr">Aran <italic toggle="yes">et al.</italic>, 2019</xref>), the Spearman rank correlations of query cells to reference samples are used in an altered kNN classification algorithm. Similarly, scmap (<xref rid="vbad030-B23" ref-type="bibr">Kiselev <italic toggle="yes">et al.</italic>, 2018</xref>) classifies cells by measuring their similarity to either the centroids of reference clusters (scmap-cluster) or by kNN cell annotation (scmap-cell). Finally, scPred (<xref rid="vbad030-B1" ref-type="bibr">Alquicira-Hernandez <italic toggle="yes">et al.</italic>, 2019</xref>) reduces the reference data’s dimensionality using principal component analysis (PCA) and applies a support vector machine model for classification. The common unwanted characteristic of discriminative classification methods is that they do not utilize the distribution of genomic data. However, the distribution of genomic data carries key features of scRNA-seq data, which should be helpful for cell-type annotation. For example, ‘dropout’ is the well-known sparsity issue characterized by the excessive amount of zero counts in scRNA-seq data, arising from technical limitations in detecting moderate or low gene-expression levels in cells of the same type (<xref rid="vbad030-B18" ref-type="bibr">Hicks <italic toggle="yes">et al.</italic>, 2018</xref>). Various imputation methods have been developed to remove dropouts from data, such as SAVER (<xref rid="vbad030-B20" ref-type="bibr">Huang <italic toggle="yes">et al.</italic>, 2018</xref>), scImpute (<xref rid="vbad030-B27" ref-type="bibr">Li and Li, 2018</xref>) and DrImpute (<xref rid="vbad030-B14" ref-type="bibr">Gong <italic toggle="yes">et al.</italic>, 2018</xref>). However, imputation could generate false positive signals within the data due to the intrinsic circularity of current scRNA-seq expression recovery practices (<xref rid="vbad030-B2" ref-type="bibr">Andrews and Hemberg, 2018</xref>). Furthermore, the proportion of dropouts can provide helpful information for cell annotation. To illustrate the importance of dropouts, we did two proportions <italic toggle="yes">Z</italic>-test on proportional zero of each gene between every pair of cell populations. In the selected dataset PBMC.10Xv2 (<xref rid="vbad030-B12" ref-type="bibr">Ding <italic toggle="yes">et al.</italic>, 2019</xref>), we observed 10–48% of genes whose proportion of dropouts was significantly different in each pair of cell populations. The results details are given in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>. These results suggest that genes with dropout carry important information helping distinguish cell types. Hence, instead of removing genes with dropout, we are motivated to build a novel model that fully utilizes the dropout information in the annotation.</p>
    <p>To fully utilize the unique characteristics of scRNA-seq genomic data, we investigate the generative classification approach, which models the distribution of genomic data conditional on cell type. Such an approach focuses on distributions of genomic data in different cell types, and annotates cells using the Bayesian theorem. To the best of our knowledge, scID (<xref rid="vbad030-B6" ref-type="bibr">Boufea <italic toggle="yes">et al.</italic>, 2020</xref>) is the only cell-type annotation method based on a generative classifier. scID uses Fisher’s linear discriminant analysis (LDA) to distinguish the characteristic genes of pre-determined cell clusters. LDA assumes that genomic data follow a multivariate normal distribution, which might over-simplify the complexity of the data. Furthermore, from data with limited sample sizes, it is hard to precisely estimate numerous parameters in the high-dimensional covariance matrix of the assumed multivariate normal distribution.</p>
    <p>This article proposes a novel generative classifier for automated cell-type annotation, scAnnotate. We focus on addressing the two critical challenges of scRNA-seq data as discussed above: the curse of high dimensionality (as discussed in LDA) and explicitly modelling dropout. To address the curse of high dimensionality, we use every gene to make a classifier and consider it as a ‘weak’ learner, and then use a combiner function to ensemble ‘weak’ learners built from all genes into a single ‘strong’ learner for making the final decision. To select a gene’s distribution that explicitly models the excessive zero counts in each weak learner, we borrow the idea from differential expression (DE) analysis of scRNA-seq data. The literature on DE analysis is well-established, with many methods that focus on modelling excessive zero counts. For example, <xref rid="vbad030-B21" ref-type="bibr">Kharchenko <italic toggle="yes">et al.</italic> (2014)</xref> introduced a Bayesian approach to scRNA-seq DE analysis in which non-zero counts are modelled using a Negative Binomial distribution and zero counts are modelled with a low-magnitude Poisson process. DEsingle (<xref rid="vbad030-B31" ref-type="bibr">Miao <italic toggle="yes">et al.</italic>, 2018</xref>) is another scRNA-seq DE analysis tool that uses the Zero-Inflated Negative Binomial (ZINB) distribution. However, after batch effect removal and other preprocessing, scRNA-seq data are often no longer integers and hence are unsuitable for the ZINB model. Furthermore, recent benchmark studies did not show any clear advantage of the ZINB model in DE analysis of scRNA-seq data (<xref rid="vbad030-B34" ref-type="bibr">Soneson and Robinson, 2018</xref>). We, therefore, model gene expression levels as a continuous variable. MAST (<xref rid="vbad030-B13" ref-type="bibr">Finak <italic toggle="yes">et al.</italic>, 2015</xref>) joint models the proportion of dropouts and the distribution of non-dropouts using a hurdle regression model, which is one of the most popular DE analysis software, and has shown great performance in benchmark studies (<xref rid="vbad030-B34" ref-type="bibr">Soneson and Robinson, 2018</xref>). Inspired by MAST, we joint model the proportion of dropouts and the gene expressions of non-dropouts by a two-component mixture model. We tried various distributions to model the non-dropout component in the mixture model and found empirically that the log-normal distribution works best for most of the data that we explored. In Section 4, we also discuss two alternative distributions implemented in our software that are useful in particular situations. In the rest of this article, we will introduce the details of the scAnnotate method and use real scRNA-seq datasets to compare its classification performance with nine other scRNA-seq annotation methods based on supervised machine learning algorithms.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>We introduce scAnnotate, an automated cell-type annotation tool. scAnnotate is entirely data-driven, meaning that it requires training data to learn the classifier but does not require biological knowledge or subjective decisions from the user. It consists of three steps: preprocessing training and test data, model fitting on training data and cell classification on test data. The classification model in the last step uses an ensemble machine learning approach involving many weak learners and a combiner function to integrate the outputs of the weak learners into a single strong learner. Each weak learner is a classifier based on a mixture model for the expression level of one gene. The combiner is a weighted average of all weak learners’ outputs. The weights can be either learned from training data with at most one rare cell population or prespecified as equal weights on the training data with at least two rare cell populations. In this study, we defined a rare cell population as a cell population with less than 100 cells in a given dataset. scAnnotate handles data with varying numbers of rare cell populations differently. An illustration of its workflow is shown in <xref rid="vbad030-F1" ref-type="fig">Figure 1</xref> (dataset with at most one rare cell population) and <xref rid="vbad030-F2" ref-type="fig">Figure 2</xref> (dataset with at least two rare cell populations). Details of each element of scAnnotate will be discussed in the rest of this section.</p>
    <fig position="float" id="vbad030-F1">
      <label>Fig. 1.</label>
      <caption>
        <p>Workflow of scAnnotate on a dataset with at most one rare cell population (at most one cell population less than 100 cells). The vertical grey dashed line separates training data (left) and test data (right) information</p>
      </caption>
      <graphic xlink:href="vbad030f1" position="float"/>
    </fig>
    <fig position="float" id="vbad030-F2">
      <label>Fig. 2.</label>
      <caption>
        <p>Workflow of scAnnotate on a dataset with at least two rare cell populations (at least two cell populations less than 100 cells). The vertical grey dashed line separates training data (left) and test data (right) information</p>
      </caption>
      <graphic xlink:href="vbad030f2" position="float"/>
    </fig>
    <sec>
      <title>2.1 Batch effect removal</title>
      <p>When building a supervised machine learning model for cell-type annotation, batch effects often create differences between the training and testing data. We, therefore, believe that removing batch effects will make the model learned from the training data more suitable for annotating cells in the test data. For example, scPred (<xref rid="vbad030-B1" ref-type="bibr">Alquicira-Hernandez <italic toggle="yes">et al.</italic>, 2019</xref>) has batch effect removal as a built-in optional step. Following this idea, we suggest using batch effect removal as a data preprocessing step unless users strongly believe that their training data and test data are similar enough to each other. scAnnotate removes batch effects using the Seurat package (<xref rid="vbad030-B17" ref-type="bibr">Hao <italic toggle="yes">et al.</italic>, 2021</xref>) for data with at most one rare cell population or the Harmony package (<xref rid="vbad030-B24" ref-type="bibr">Korsunsky <italic toggle="yes">et al.</italic>, 2018</xref>) for data with at least two rare cell populations. Both packages are recommended by <xref rid="vbad030-B39" ref-type="bibr">Tran <italic toggle="yes">et al.</italic> (2020)</xref> due to their consistently high-quality performances and comparatively low runtimes. The output from the batch effect removal step is used as input for the classification model discussed next.</p>
    </sec>
    <sec>
      <title>2.2 Mixture model for the expression level of a given gene in a fixed cell type</title>
      <p>The traditional mixture model is a model-based clustering approach and does not need training data with cell-type labels. Our model has the same form as a mixture model, but we used the training data with cell-type labels to avoid the expectation–maximization (EM) algorithm for model fitting. Given the cell-type labels, we could estimate each gene’s density in each cell type directly without an iterative update. We use a mixture model to describe the expression level, <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, as below
where <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the index of cell types, <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the index of (selected) genes, <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> is the degenerated distribution at 0, <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> is a distribution supported on <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>∞</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are, respectively, the total number of cell types and the total number of genes selected for use in classification. The <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are the mixing proportions for <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>, respectively. Model (1) includes commonly used zero-inflated models such as the zero-inflated Poisson model as special cases, but it offers more flexibility than such zero-inflated models as it models the proportion of zeros and the distribution of the positive expression levels <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> separately. In particular, under <xref rid="E1" ref-type="disp-formula">Equation (1)</xref>, all distributions supported on <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>∞</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> or a subset of <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>∞</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> may be used to model <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. In situations where no good parametric models for <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> are available, we may also specify <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> nonparametrically.</p>
      <disp-formula id="E1">
        <label>(1)</label>
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>F</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>p</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:msup>
              <mml:mrow>
                <mml:mi>F</mml:mi>
              </mml:mrow>
              <mml:mn>0</mml:mn>
            </mml:msup>
            <mml:mo>+</mml:mo>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mn>1</mml:mn>
            <mml:mo>−</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>p</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:msubsup>
              <mml:mrow>
                <mml:mi>F</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mi>j</mml:mi>
              </mml:mrow>
              <mml:mo>+</mml:mo>
            </mml:msubsup>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Note that the indexes <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic> are used consistently throughout this article to refer to cell types and genes, respectively. To be concise, we will use these two indexes without repeated definitions in the rest of this article.</p>
    </sec>
    <sec>
      <title>2.3 Mixture model for the expression level of a given gene, its estimation and prior specification</title>
      <p>Let <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>π</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the prior probability that a randomly selected cell is of type-<italic toggle="yes">i</italic> where <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>π</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>π</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>⋯</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>π</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. The (prior) distribution of the expression level of the <italic toggle="yes">j</italic>th gene of this cell is the following mixture distribution:
where <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are defined in <xref rid="E1" ref-type="disp-formula">Equation (1)</xref>. We estimate <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> using training data as follows. Suppose the training data contain <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> independent type-<italic toggle="yes">i</italic> cells. Then, there are <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> independent observations for the <italic toggle="yes">j</italic>th gene in type-<italic toggle="yes">i</italic> cells. Let <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> be the number of zeros among these <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> observations and <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> be the number of positive observations so that <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. Then, we may estimate the mixing proportions <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in <xref rid="E1" ref-type="disp-formula">Equation (1)</xref> with
</p>
      <disp-formula id="E2">
        <label>(2)</label>
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>F</mml:mi>
              </mml:mrow>
              <mml:mi>j</mml:mi>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>π</mml:mo>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:msub>
              <mml:mrow>
                <mml:mi>F</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mn>1</mml:mn>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>+</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>π</mml:mo>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:msub>
              <mml:mrow>
                <mml:mi>F</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mn>2</mml:mn>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>+</mml:mo>
            <mml:mo>⋯</mml:mo>
            <mml:mo>+</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>π</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:msub>
              </mml:mrow>
            </mml:msub>
            <mml:msub>
              <mml:mrow>
                <mml:mi>F</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:msub>
                <mml:mo>,</mml:mo>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
          </mml:mrow>
          <mml:mo>,</mml:mo>
        </mml:math>
      </disp-formula>
      <disp-formula id="E3">
        <mml:math id="M3" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>p</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:msubsup>
              <mml:mrow>
                <mml:mi>k</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mi>j</mml:mi>
              </mml:mrow>
              <mml:mn>0</mml:mn>
            </mml:msubsup>
            <mml:mo>/</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>m</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mn>1</mml:mn>
            <mml:mo>,</mml:mo>
            <mml:mn>2</mml:mn>
            <mml:mo>,</mml:mo>
            <mml:mo>…</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>n</mml:mi>
              </mml:mrow>
              <mml:mi>t</mml:mi>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:mi>j</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mn>1</mml:mn>
            <mml:mo>,</mml:mo>
            <mml:mn>2</mml:mn>
            <mml:mo>,</mml:mo>
            <mml:mo>…</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>n</mml:mi>
              </mml:mrow>
              <mml:mi>g</mml:mi>
            </mml:msub>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>To estimate the parameters of the distribution <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>, we use the <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> positive observations. For example, if <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> is assumed to be a log-normal distribution, then we can find the maximum-likelihood estimates for its parameters using the <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> positive observations.</p>
      <p>The prior probabilities <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>π</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> depend on the application at hand. In the absence of information for determining these probabilities, we recommend the uniform prior <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>π</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We have also used the observed proportions <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>π</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, which are reasonable when the training sample is a random sample from the population of cells of all types.</p>
    </sec>
    <sec>
      <title>2.4 Weak learner based on mixture model of a single gene</title>
      <p>To classify a future cell of unknown type into one of the <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> types with its <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> gene expression data, we first use the <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> genes one at a time to perform the classification. This leads to <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> weak learners.</p>
      <p>Let <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the expression level of the <italic toggle="yes">j</italic>th gene of the cell. Then, since the cell type is unknown, <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in <xref rid="E2" ref-type="disp-formula">Equation (2)</xref>. Let <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the observed value of <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The posterior probability that the cell belongs to type-<italic toggle="yes">i</italic> is
which can be computed by using the estimated <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Specifically, for <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, we have
which is the probability that the observed zero comes from a type-<italic toggle="yes">i</italic> cell. For <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, we have
where <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the estimated probability mass/density function of <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. When <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> is a continuous distribution, <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is a continuous density function, so <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in <xref rid="E6" ref-type="disp-formula">Equation (4)</xref> is not a real probability, but we still call it a posterior probability here for the purpose of classifying the cell. If we only use the expression level of the <italic toggle="yes">j</italic>th gene, we would assign the cell to type-<inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> where
by the rule of the maximum posterior probability. This is a weak learner in the sense that it is based on the expression level of only one gene.</p>
      <disp-formula id="E4">
        <label>(3)</label>
        <mml:math id="M4" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mi>P</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mtext>type</mml:mtext>
            <mml:mo>-</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>|</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>X</mml:mi>
              </mml:mrow>
              <mml:mi>j</mml:mi>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>x</mml:mi>
              </mml:mrow>
              <mml:mi>j</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>X</mml:mi>
                  </mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:msub>
                <mml:mo>|</mml:mo>
                <mml:mtext>type</mml:mtext>
                <mml:mo>-</mml:mo>
                <mml:mi>i</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mtext>type</mml:mtext>
                <mml:mo>-</mml:mo>
                <mml:mi>i</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>X</mml:mi>
                  </mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
          </mml:mrow>
          <mml:mo>,</mml:mo>
        </mml:math>
      </disp-formula>
      <disp-formula id="E5">
        <mml:math id="M5" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mi>P</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mtext>type</mml:mtext>
            <mml:mo>-</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>|</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>X</mml:mi>
              </mml:mrow>
              <mml:mi>j</mml:mi>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mn>0</mml:mn>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mo>π</mml:mo>
                  </mml:mrow>
                  <mml:mi>i</mml:mi>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>p</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mo>π</mml:mo>
                  </mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>p</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>+</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mo>π</mml:mo>
                  </mml:mrow>
                  <mml:mn>2</mml:mn>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>p</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>2</mml:mn>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>+</mml:mo>
                <mml:mo>⋯</mml:mo>
                <mml:mo>+</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mo>π</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>n</mml:mi>
                      </mml:mrow>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>p</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>n</mml:mi>
                      </mml:mrow>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
            </mml:mfrac>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E6">
        <label>(4)</label>
        <mml:math id="M6" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mo>π</mml:mo>
                  </mml:mrow>
                  <mml:mi>i</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>−</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>p</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>f</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mo>π</mml:mo>
                  </mml:mrow>
                  <mml:mn>1</mml:mn>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>−</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>p</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>f</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>1</mml:mn>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>+</mml:mo>
                <mml:mo>⋯</mml:mo>
                <mml:mo>+</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mo>π</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>n</mml:mi>
                      </mml:mrow>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>−</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>p</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>n</mml:mi>
                      </mml:mrow>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>f</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>n</mml:mi>
                      </mml:mrow>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>x</mml:mi>
                  </mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
          </mml:mrow>
          <mml:mo>,</mml:mo>
        </mml:math>
      </disp-formula>
      <disp-formula id="E7">
        <label>(5)</label>
        <mml:math id="M7" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:msup>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                  <mml:mo>*</mml:mo>
                </mml:msup>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mi>max</mml:mi>
            <mml:mo>{</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mn>1</mml:mn>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mn>2</mml:mn>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:mo>…</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:msub>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>}</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
    </sec>
    <sec>
      <title>2.5 Combiner functions and the strong learner</title>
      <p>Based on <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> genes, we obtain <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> weak learners to annotate cell types. Next, we define a combiner function to integrate the <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> posterior probabilities into one final decision, which is considered a strong learner. We propose the combiner function as the weighted sum of log-transformed <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>-scores, defined below,
where the values of weights parameters <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are specified using two different approaches according to the sample size of the training data.</p>
      <disp-formula id="E8">
        <label>(6)</label>
        <mml:math id="M8" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>s</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>s</mml:mi>
              </mml:mrow>
              <mml:mi>C</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mn>1</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mn>2</mml:mn>
              </mml:mrow>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:mo>…</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                  <mml:mi>g</mml:mi>
                </mml:msub>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munderover>
              <mml:mo>∑</mml:mo>
              <mml:mrow>
                <mml:mi>j</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                  <mml:mi>g</mml:mi>
                </mml:msub>
              </mml:mrow>
            </mml:munderover>
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>w</mml:mi>
                </mml:mrow>
                <mml:mi>j</mml:mi>
              </mml:msub>
            </mml:mrow>
            <mml:mo> </mml:mo>
            <mml:mtext>log</mml:mtext>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>q</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mi>j</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Based on the scores obtained from the combiner function, we classify a cell to be the cell type with the largest score of <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, that is, type-<inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> satisfying
</p>
      <disp-formula id="E9">
        <label>(7)</label>
        <mml:math id="M9" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msup>
              <mml:mrow>
                <mml:mi>i</mml:mi>
              </mml:mrow>
              <mml:mo>*</mml:mo>
            </mml:msup>
            <mml:mo>=</mml:mo>
            <mml:munder>
              <mml:mrow>
                <mml:mi>arg</mml:mi>
                <mml:mi>max</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:munder>
            <mml:mo>{</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>s</mml:mi>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>s</mml:mi>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:mo>…</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>s</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>n</mml:mi>
                  </mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:msub>
              </mml:mrow>
            </mml:msub>
            <mml:mo>}</mml:mo>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>We call steps (1)–(7) mixture model-based supervised classification of a cell. We name this method ‘scAnnotate’.</p>
      <p>When the training data have at most one rare cell population, we randomly split the training data into two parts. The weights <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are learned via the following five steps. (1) We use <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mn>20</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> of the cells to estimate the parameters of <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. (2) We use the estimated distributions to calculate <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> scores of the remaining <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mn>80</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> of cells. (3) Using the Wilcoxon rank-sum test, we filter out genes whose <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> scores are not highly associated with cell-type labels, that is, retain the top genes with the smallest <italic toggle="yes">p</italic>-values. (4) Using these <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mn>80</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> cells’ <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> scores as predictors and their corresponding cell types as outcomes, we train an Elastic Net model (<xref rid="vbad030-B43" ref-type="bibr">Zou and Hastie, 2005</xref>) to learn the weights <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Note, to reduce the number of predictors, we apply PCA to the scores and use PC scores to replace the <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> scores. Since the Elastic Net model’s result is a linear combination of PC scores, and the PC scores are linear combinations of <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> scores, the final results are linear combinations of <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> scores. (5) To avoid sampling bias introduced by random data splitting, we repeat Steps (1)–(4) 10 times with different random splits, and use average weights learned from the 10 models as the final weights of combiner <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <p>When the training data have at least two rare cell populations, we do not have enough data to estimate parameters of all <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and, at the same time, train a model to learn the weights <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for the combiner. Specifically, a rare cell population has less than 100 cells, as defined for this study. Since we only use <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mn>20</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> of training data to learn the distribution parameters, if we also have to model the weights <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for the combiner, we cannot sufficiently estimate the parameter <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for a rare cell population with less than 20 cells. We can make a reasonable prediction when there is only one rare cell population. The well-estimated distribution of other cell populations can draw an excellent boundary to distinguish the only rare cell population from them. However, we cannot distinguish these rare cells from each other when there are at least two rare cells. In this case, we use all training cells to estimate the parameters of <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and assume equal weights <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for all <italic toggle="yes">j</italic>. When we use a uniform prior <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>π</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mtext>type</mml:mtext><mml:mo>-</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and equal weights <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> with combiner <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, it is equivalent to <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Π</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∝</mml:mo><mml:msubsup><mml:mo>∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mtext>type</mml:mtext><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and our ensemble learning reduces to the well-known Naive Bayes Classifier (<xref rid="vbad030-B33" ref-type="bibr">Rish <italic toggle="yes">et al.</italic>, 2001</xref>). To see this, a detailed process of proven is given in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>.</p>
      <p>Note that we set 100 cells as the threshold for using our non-equal-weight ensemble model, which is an empirically ‘safe’ threshold to estimate the model parameters reasonably well. It implies using 20+ cells to estimate two distribution parameters (mean and SD of a log-normal distribution) and 80+ cells to train a model learning the best ensemble weights. Users could set a smaller threshold and still get good annotation results. However, the threshold value must not be too small. When the sample size is insufficient to reasonably estimate the model parameters, the equal-weights ensemble model may work better since assuming equal weights enables using all cells to estimate distribution parameters. Note that other combiner functions could be used as alternatives to Formula (6). We provided a few examples in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S2</xref>. We investigated the combiners using multiple real scRNA-seq datasets and empirically found the combiner <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> works best.</p>
    </sec>
    <sec>
      <title>2.6 Implementation of scAnnotate</title>
      <p>Classification using scAnnotate depends on three key components: (i) the model for <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> in <xref rid="E1" ref-type="disp-formula">Equation (1)</xref>, (ii) the prior probabilities <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>π</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in <xref rid="E2" ref-type="disp-formula">Equation (2)</xref> and (iii) the combiner function in <xref rid="E8" ref-type="disp-formula">Equation (6)</xref>. For (i), we may use, for example, Negative Binomial distribution, Exponential distribution, log-normal distribution or in situations where no good parametric models for positive expression levels are available, a nonparametric measure (see Section 2.7). Due to the usually huge number of combinations of <italic toggle="yes">i</italic> (cell types) and <italic toggle="yes">j</italic> (genes), it is not practical to model each individual <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> separately, so we assume that distributions of all <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> are of the same type, for example, all log-normal; and they can only differ in their parameter values. For (ii), we use either a uniform prior or the observed proportions as discussed in Section 2.3. For (iii), we may use one of the three combiner functions given above.</p>
      <p>In real applications, we recommend using several combinations of the three components to build several classifiers with the training data, and then use test data to evaluate the performance of these classifiers using their <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> scores to identify the optimal combination with the highest <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score. For real data, the correct specifications of the components are unknown, so optimizing the combination by trying several combinations and choosing the best one protects scAnnotate from serious misspecifications of its components. For examples that we have tried, we found that the combination of the log-normal distribution, uniform prior and combiner <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> often has the best or second-best performance. For simplicity of presentation, this combination is used in all examples in the next section.</p>
      <p>Note that in cross-species and cross-platform studies, we need to apply batch effect removal techniques to preprocess the datasets and the processed datasets contain no zeros. For such processed datasets, the mixture model <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in <xref rid="E1" ref-type="disp-formula">Equation (1)</xref> for the <italic toggle="yes">j</italic>th gene of a type-<italic toggle="yes">i</italic> cell reduces to <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> as the proportion of zero <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. The mixture model <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in <xref rid="E2" ref-type="disp-formula">Equation (2)</xref> remains unchanged. The implementation of scAnnotate also remains the same.</p>
    </sec>
    <sec>
      <title>2.7 Nonparametric depth measure</title>
      <p>The true distribution of gene expression can be very complex. We may be unable to find, from the set of commonly used parametric distributions, a suitable one for modelling <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. The assumption that distributions for <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> of all genes are the same kind and that they can only differ in parameter values may also be too strong. To deal with these issues, when the sample size is large, we suggest using a nonparametric depth measure for <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>, which is totally free of any parametric assumptions. Specifically, we may replace the estimated density function <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> with a depth measure when computing the posterior probability in <xref rid="E6" ref-type="disp-formula">Equation (4)</xref>. We now illustrate this point using the halfspace depth measure (<xref rid="vbad030-B30" ref-type="bibr">Liu <italic toggle="yes">et al.</italic>, 1999</xref>).</p>
      <p>For a fixed gene of a fixed cell type, suppose there are <italic toggle="yes">m</italic> non-zero expression data points from the training dataset <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Let <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> be the expression level of that gene of the cell to be classified. The halfspace depth of <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> measures how consistent <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is with the sample <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. It is defined as follows. First, rank the <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> observations in the augmented sample <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and denote by <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the rank of <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. Then, the halfspace depth of <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is given by
</p>
      <disp-formula id="E10">
        <mml:math id="M10" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>h</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msup>
              <mml:mrow>
                <mml:mi>x</mml:mi>
              </mml:mrow>
              <mml:mo>*</mml:mo>
            </mml:msup>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mn>1</mml:mn>
              <mml:mrow>
                <mml:mi>m</mml:mi>
                <mml:mo>+</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
            </mml:mfrac>
            <mml:mi>min</mml:mi>
            <mml:mo>{</mml:mo>
            <mml:mi>r</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msup>
              <mml:mrow>
                <mml:mi>x</mml:mi>
              </mml:mrow>
              <mml:mo>*</mml:mo>
            </mml:msup>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>m</mml:mi>
            <mml:mo>+</mml:mo>
            <mml:mn>1</mml:mn>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>−</mml:mo>
            <mml:mi>r</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msup>
              <mml:mrow>
                <mml:mi>x</mml:mi>
              </mml:mrow>
              <mml:mo>*</mml:mo>
            </mml:msup>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>+</mml:mo>
            <mml:mn>1</mml:mn>
            <mml:mo>}</mml:mo>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>To see how <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> measures the consistency of <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> with the data, when <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is the smallest or the largest of the augmented sample, <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has its minimum value of <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, so a low <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> value indicates <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is not consistent with the data in that it is an extreme value. On the other hand, when <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is the median of the augmented sample, <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> reaches its maximum value of <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, so a large <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> value (close to 1/2) indicate <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is consistent with the data. As such, it may be used to substitute <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in scAnnotate. Using this depth measure protects scAnnotate from severe misspecification of the model for <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. In simulation studies, scAnnotate based on the halfspace depth outperforms scAnnotate with severely misspecified <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> in terms of accuracy. On the other hand, the depth measure requires the number of non-zero observations at all genes to be large (otherwise, the depth measure is too discrete to be a useful replacement for <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) and is more computationally intensive.</p>
      <p>To evaluate the performance of scAnnotate, we conduct a benchmark study to compare it against nine other scRNA-seq annotation methods based on supervised machine learning algorithms, including scID (<xref rid="vbad030-B6" ref-type="bibr">Boufea <italic toggle="yes">et al.</italic>, 2020</xref>), scClassify (<xref rid="vbad030-B29" ref-type="bibr">Lin <italic toggle="yes">et al.</italic>, 2020</xref>), SingleCellNet (<xref rid="vbad030-B35" ref-type="bibr">Tan and Cahan, 2019</xref>), scPred (<xref rid="vbad030-B1" ref-type="bibr">Alquicira-Hernandez <italic toggle="yes">et al.</italic>, 2019</xref>), CaSTLe (<xref rid="vbad030-B28" ref-type="bibr">Lieberman <italic toggle="yes">et al.</italic>, 2018</xref>), SingleR (<xref rid="vbad030-B3" ref-type="bibr">Aran <italic toggle="yes">et al.</italic>, 2019</xref>), CHETAH (<xref rid="vbad030-B10" ref-type="bibr">de Kanter <italic toggle="yes">et al.</italic>, 2019</xref>), scmapCluster and scmapCell (<xref rid="vbad030-B23" ref-type="bibr">Kiselev <italic toggle="yes">et al.</italic>, 2018</xref>). The parameters of these methods are chosen according to the suggestions in their vignettes or the software default settings; we note that all of the benchmarked methods have a fully automated data-driven approach without requiring previous biological knowledge. Details of the nine methods are listed in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref>. In our experiments, all models are learned on training data and then applied to annotate cells in the test data. Prior to performing classification, we remove all cells whose cell types do not appear in both the training and test data. To evaluate the classification performance of the benchmarked methods, we compare the predicted labels of the test data with the corresponding true labels. Following the evaluation rule of other annotation method papers (<xref rid="vbad030-B1" ref-type="bibr">Alquicira-Hernandez <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="vbad030-B28" ref-type="bibr">Lieberman <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="vbad030-B29" ref-type="bibr">Lin <italic toggle="yes">et al.</italic>, 2020</xref>; <xref rid="vbad030-B42" ref-type="bibr">Zhao <italic toggle="yes">et al.</italic>, 2020</xref>), we use classification accuracy as our performance criteria. Accuracy in this study is defined as the percentage of correctly annotated cells.</p>
      <p>We conduct our benchmark study under three situations according to the relationship between training and test data: (1) training and test data are from the same platform (i.e. obtained from the same sequencing method) and the same species; (2) training and test data are from different platforms and (3) training and test data are from different species, human versus mouse.</p>
    </sec>
    <sec>
      <title>2.8 Datasets and preprocessing</title>
      <p><xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref> summarizes the 14 publicly available scRNA-seq datasets used in our benchmark study. These data have been used to illustrate the annotation performances of scAnnotate and its nine competitor methods in this section.</p>
      <p>The Seurat (version 4.0.5) (<xref rid="vbad030-B17" ref-type="bibr">Hao <italic toggle="yes">et al.</italic>, 2021</xref>) package was used for normalization on all raw count matrices. The datasets were normalized using the NormalizeData function with the ‘LogNormalize’ method and a scale factor of 10 000. Since scID was not compatible with log-transformed data, it used the raw count matrices as input. All other methods used the log-transformed normalized gene expression matrix as input.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Annotation performance evaluation when training and test data are generated from the same species using the same platform</title>
      <p>We used all 14 datasets as described in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref> for intra-dataset evaluation. We applied stratified sampling (by cell type) to select 80% of the dataset as training data and set the remaining 20% of the dataset as test data. To eliminate the variability in performance evaluation caused by sampling bias, we repeated this experiment 10 times with different random data splitting. Then we reported the median accuracy from the 10 replications to represent each method’s overall performance on selected datasets.</p>
      <p><xref rid="vbad030-F3" ref-type="fig">Figure 3</xref> shows the classification accuracy of scAnnotate and competitor methods. scAnnotate (assuming <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> follows a log-normal distribution) had a mean accuracy 93.83%, a median accuracy 95.47%, and an overall prediction accuracy range of 79.43–100.00%. In most cases, scAnnotate ranks in the top four best-performing methods. Multiple methods had high classification accuracies when training and test data were similar.</p>
      <fig position="float" id="vbad030-F3">
        <label>Fig. 3.</label>
        <caption>
          <p>Within-study classification performance of scAnnotate on all 14 datasets, as provided by <xref rid="vbad030-B12" ref-type="bibr">Ding <italic toggle="yes">et al.</italic> (2019)</xref>, <xref rid="vbad030-B38" ref-type="bibr">Tian <italic toggle="yes">et al.</italic> (2019)</xref>, <xref rid="vbad030-B5" ref-type="bibr">Baron <italic toggle="yes">et al.</italic> (2016)</xref>, <xref rid="vbad030-B37" ref-type="bibr">Tasic <italic toggle="yes">et al.</italic> (2018)</xref> and <xref rid="vbad030-B19" ref-type="bibr">Hodge <italic toggle="yes">et al.</italic> (2019)</xref>. The dot plot shows the comparison results of each individual setting. Each column represents one combination of training and test data. Each circle represents the performance of one method. The colours of the circles represent the methods’ ranks and the sizes of the circles represent their corresponding accuracies. The boxplot on the right summarizes the overall comparison of methods under all settings</p>
        </caption>
        <graphic xlink:href="vbad030f3" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.2 Annotation performance evaluation using cross-platform training data</title>
      <p>We used the PBMC datasets (<xref rid="vbad030-B12" ref-type="bibr">Ding <italic toggle="yes">et al.</italic>, 2019</xref>) provided by the SeuratData Package and the lung cancer cell lines dataset (<xref rid="vbad030-B38" ref-type="bibr">Tian <italic toggle="yes">et al.</italic>, 2019</xref>) to evaluate the 10 annotation methods’ classification performances when training and test data are obtained from different scRNA-seq generating platforms. The PBMC data consist of scRNA-seq data generated using seven different platforms as listed in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref>, which leads to 42 pairs of cross-platform training and test data. The lung cancer cell lines datasets, 10X and Cel-seq2, provided two pairs of cross-platform training and test data.</p>
      <p>scAnnotate (assuming <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> follows a log-normal distribution) had the highest mean accuracy (80.27%) and the highest median accuracy (81.92%), and an overall prediction accuracy range of 39.45–100.00%. scAnnotate, singleCellNet and scPred had the highest median accuracies, indicating that they are the top three best methods in the overall comparison of the 44 settings. When we look into individual settings, scAnnotate is among the top-ranked most accurate methods in most of the 44 cross-platform settings (<xref rid="vbad030-F4" ref-type="fig">Figure 4</xref>). When scAnnotate is not the best method, its accuracy is often not much lower than that of the winners. We note that there is a significant drop in performance for scAnnotate when trained on the PBMC 10x-v3 dataset and tested on the PBMC Seq-Well dataset. As shown in the top boxplot of <xref rid="vbad030-F4" ref-type="fig">Figure 4</xref>, all methods have a significant drop in performance for this cross-platform dataset combination; thus, in general, training on the 10x-v3 dataset may produce poor predictions on the Seq-Well dataset. Comparing the performance of each classifier across the different protocols on the lung cancer cell lines, we observe an almost perfect performance for all classifiers. To illustrate the difference between the top-performing methods, we did a paired Wilcoxon rank-sum test on scAnnotate and other top-performing methods. Based on 0.05 <italic toggle="yes">p</italic>-value criteria, we didn’t observe a significantly different performance between the scAnnotate and the other top four best-performing methods (singleCellNet, scPred and SingleR).</p>
      <fig position="float" id="vbad030-F4">
        <label>Fig. 4.</label>
        <caption>
          <p>Classification performance of scAnnotate on 44 combinations of cross-platform datasets, as provided by <xref rid="vbad030-B12" ref-type="bibr">Ding <italic toggle="yes">et al.</italic> (2019)</xref> and <xref rid="vbad030-B38" ref-type="bibr">Tian <italic toggle="yes">et al.</italic> (2019)</xref>, which included 42 PBMC datasets and two lung cancer cell lines datasets marked with (*). The dot plot shows the comparison results of each individual setting. Each column represents one set of training and test data combination. Each circle represents the performance of one method. The colours of the circles represent the methods’ ranks and the sizes of the circles represent their corresponding accuracies. The boxplot on the right side of the dot plot summarizes the overall comparison of methods under all settings. The boxplot on top of the dot plot summarizes the overall performance of classifiers for each experiment</p>
        </caption>
        <graphic xlink:href="vbad030f4" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.3 Annotation performance evaluation using cross-species training data</title>
      <p>We first trained scAnnotate (assuming that <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>+</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> follows a log-normal distribution) and nine other cell annotation methods on the <xref rid="vbad030-B5" ref-type="bibr">Baron <italic toggle="yes">et al.</italic>’s (2016)</xref> mouse pancreatic dataset and predicted 10 pancreatic cell types in the <xref rid="vbad030-B5" ref-type="bibr">Baron <italic toggle="yes">et al.</italic>’s (2016)</xref> human pancreatic datasets. scAnnotate ranked first with a prediction accuracy of 92.23%. We then switched the training–testing order and used the human data as training data to classify the mouse data. scAnnotate’s rank is third, with a prediction accuracy of 90.15%.</p>
      <p>We then repeated this training/testing process with scAnnotate and the nine competitor methods on the mouse and human brain datasets provided by <xref rid="vbad030-B37" ref-type="bibr">Tasic <italic toggle="yes">et al.</italic> (2018)</xref> and <xref rid="vbad030-B19" ref-type="bibr">Hodge <italic toggle="yes">et al.</italic> (2019)</xref>, respectively. Since we utilized two mouse brain datasets and one human brain dataset, switching the training-testing order gave us four distinct pairs of datasets. As shown in <xref rid="vbad030-F5" ref-type="fig">Figure 5</xref>, scAnnotate consistently ranks in the top five best-performing methods for mouse and human brain cell annotation with a mean accuracy of 99.15% and a median accuracy of 99.79%.</p>
      <fig position="float" id="vbad030-F5">
        <label>Fig. 5.</label>
        <caption>
          <p>Cross-species classification performance of scAnnotate and nine other methods on six combinations of mouse and human scRNA-seq datasets, provided by <xref rid="vbad030-B5" ref-type="bibr">Baron <italic toggle="yes">et al.</italic> (2016)</xref>, <xref rid="vbad030-B37" ref-type="bibr">Tasic <italic toggle="yes">et al.</italic> (2018)</xref> and <xref rid="vbad030-B19" ref-type="bibr">Hodge <italic toggle="yes">et al.</italic> (2019)</xref>. The dot plot shows the comparison results of each individual setting. Each column represents one combination of training and test data. Each circle represents the performance of one method. The colours of the circles represent the methods’ ranks and the sizes of the circles represent their corresponding accuracies. The boxplot on the right summarizes the overall comparison of methods under all settings</p>
        </caption>
        <graphic xlink:href="vbad030f5" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.4 scAnnotate can complement other annotation methods</title>
      <p>The scAnnotate uses a very distinct modelling approach compared with its competitors. It is the only annotation method that explicitly models the dropout (a critical characteristic of scRNA-seq), and is one of the only two generative classifiers while all others are discriminative classifiers. Therefore, we expect scAnnotate’s annotation of individual cells can be quite different from its competitors, although scAnnotate has similar cohort-level accuracy to other top-performing methods. That is, scAnnotate’s incorrectly annotated cells could be very distinct from its competitors’ incorrectly annotated cells. Being able to complement competitors enables scAnnotate to be used together with other annotation methods, which may lead to improved results. The mosaic plot shows the cells that are inconsistently annotated by the top six benchmarked methods in 42 PBMC cross-platform datasets given in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figures S1–S3</xref>.</p>
      <p>Next, we look into the detailed annotation results of one data analysis conducted above, as an example, to demonstrate the difference between annotation results of scAnnotate’s generative approach and its competitors (i.e. discriminative methods). We focus on the cross-platform analysis training model on PBMC.SW dataset and tested it on the PBMC.10Xv3 dataset (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref> for dataset details). Of the 2930 cells included in the PBMC.10Xv3 dataset, 886 cells were inconsistently annotated by these methods. The mosaic plot of <xref rid="vbad030-F6" ref-type="fig">Figure 6</xref> shows the comparison of annotation results of six top-performing annotation methods. Each row represents an annotation method and each column represents a cell. The grids filled with black colour indicate those cells are incorrectly annotated. To highlight the difference pattern between methods’ annotation results, we only show the results of the top six best-performing methods and exclude cells consistently annotated by all methods. We grouped these cells into 20 clusters using the <italic toggle="yes">K</italic>-means algorithm, and re-ordered them according to their cluster membership to highlight the pattern. From <xref rid="vbad030-F6" ref-type="fig">Figure 6</xref>, we can observe an obvious pattern that scAnnotate’s results complement all other methods. In this analysis, SingleR had the best performance with an accuracy of 91.74% and scAnnotate ranked second with an accuracy of 90.14%. If we could let methods correct each other’s errors (e.g. by manually investigating inconsistently annotated cells or building an ensemble model to borrow information among different methods), the ideal accuracy could be improved to 98.50% in this example.</p>
      <fig position="float" id="vbad030-F6">
        <label>Fig. 6.</label>
        <caption>
          <p>The mosaic plot shows the cells of the PBMC.10Xv3 dataset that are inconsistently annotated by the top six benchmarked methods (when trained on the PBMC.SW dataset)</p>
        </caption>
        <graphic xlink:href="vbad030f6" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>scAnnotate is an analysis framework that consists of three major components. Users can change the components according to their own needs. First, we use two available software as a batch effect removal step: Harmony for datasets with at least two rare cell populations and Seurat for datasets with at most one rare cell population. Many batch effect removal methods can be used to replace them, such as the methods compared in the benchmark study by <xref rid="vbad030-B39" ref-type="bibr">Tran <italic toggle="yes">et al.</italic> (2020)</xref>. Note that the batch effect removal step is critical, which ensures that training and test data are comparable so the model learned on the training data can be applied to test data. This step requires learning a new annotation model for every test data, which is ‘not’ desired for conventional classification problems, but is essential and practical in cell annotation problems. In practice, when users want to annotate cells from scRNA-seq data, they should find the best matching training data preferably generated from the same species using the same platform. Using pre-trained models as a black box for annotation could lead to misleading results. Second, an Elastic Net (<xref rid="vbad030-B43" ref-type="bibr">Zou and Hastie, 2005</xref>) model is used to learn a combiner function. Users can choose any supervised machine learning model to replace it. For example, when the sample size is large, users can train the combiner function using XGBoost (<xref rid="vbad030-B8" ref-type="bibr">Chen and Guestrin, 2016</xref>), which is faster and much more precise than Elastic Net in this situation. Note that the supervised learning approach can only annotate cell types seen in training data. Semi-supervised learning methods could be incorporated into this framework as follow-up research to annotate unseen cell types. Third, the distributions used in weak learners can also be changed. We will discuss this next.</p>
    <p>After investigating many candidate distributions used in weak learners, we recommend using the log-normal distribution as the non-dropout component of our mixture model. Besides log-normal, we added alternative distributions in our software for particular usages. The non-parametric distribution is estimated using a depth function approach for extra-large sample size problems. We believe that all distributions oversimplify the complex truth of gene expression. Hence, a non-parametric approach can better estimate the complex true distribution when the sample size is big enough. We believe that this alternative will be more useful in the future as the sample size of scRNA-seq data continues to grow rapidly over the years.</p>
    <p>DE analysis uses genes one at a time; most DE methods, therefore, focus on modelling gene expression distribution to best utilize key features of genomic data. In contrast, annotation analysis needs to use all genes to make decisions. Most cell annotation methods do not model the distribution of genomic data, since it is hard to model the joint distribution of many genes. We address this challenge using an ensemble approach. We build classifiers using each gene separately and ensemble them using a combiner. This approach has three advantages in computing. First, by modelling each gene separately, the number of parameters in our model is linear in the number of genes, which successfully avoids the curse of dimensionality. Second, the estimation of distribution parameters in the training data and the evaluation of posterior probability in the test data often have close-formed formulas, rather than the expensive iterative approximation used by many other types of classifiers. Third, when necessary, such calculations for tens of thousands of genes can be done in parallel to further reduce computing time.</p>
    <p>While scAnnotate is developed as a standalone tool for cell annotation, it can also be used with other methods to correct each other’s errors. According to the ‘No free lunch theorem’ by <xref rid="vbad030-B40" ref-type="bibr">Wolpert and Macready (1997)</xref>, there is no single best machine learning algorithm for predictive modelling problems. All methods have their particular advantages and disadvantages. Hence, different annotation methods are expected to make errors on different sets of cells. At the end of Section 3, we demonstrate that scAnnotate’s annotation errors are very different from its competitors. In practice, users could use scAnnotate and another method to analyse the same data and compare their annotation results. Users could manually investigate the cells annotated inconsistently between scAnnotate and its competitors to improve the accuracy of cell annotation further. When there are enough computing resources and training data, users could also build an ensemble annotator to integrate the annotation results of many methods automatically. In such an ensemble annotator, we believe scAnnotate should play a key role because of its distinct characteristics and ability to complement competitors. The ensemble annotator is not limited to the competing methods selected in our study. There were many new methods developed for cell-type annotation while we were developing the scAnnotate. scNym (<xref rid="vbad030-B22" ref-type="bibr">Kimmel and Kelley, 2021</xref>) involved semi-supervised adversarial neural networks for classification. SciBet (<xref rid="vbad030-B26" ref-type="bibr">Li <italic toggle="yes">et al.</italic>, 2020</xref>) was developed based on a multinomial-distribution model and maximum-likelihood estimation. Cell-ID (<xref rid="vbad030-B9" ref-type="bibr">Cortal <italic toggle="yes">et al.</italic>, 2021</xref>) is based on multiple correspondence analysis. scSorter (<xref rid="vbad030-B16" ref-type="bibr">Guo <italic toggle="yes">et al.</italic>, 2021</xref>) is a semi-supervised method that assigns cells to known cell types according to marker genes. scBERT (<xref rid="vbad030-B41" ref-type="bibr">Yang <italic toggle="yes">et al.</italic>, 2022</xref>) is a large-scale pretrained deep language model for cell-type annotation. Users could also use annotation results of scAnnotate and other methods as input for downstream analyses, then compare the final results to identify which one makes more sense in biology.</p>
    <p>In conclusion, we introduce scAnnotate, a streamlined process for scRNA-seq data analysis that includes data preprocessing and cell annotation. We simultaneously model genes’ dropout proportions and expression levels via a two-component mixture model. We use an ensemble machine learning approach to address the curse of high dimensionality. We build weak classifiers using each gene and use a combiner function to integrate all weak classifiers into a single strong classifier. Using multiple real scRNA-seq benchmark datasets, we show that scAnnotate accurately annotates cells when training and test data are from (1) the same platform and species, (2) different scRNA-seq generating platforms and (3) different species (specifically, mouse to human). Compared with other supervised machine learning methods, scAnnotate provides top-tier cell classification performance.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>vbad030_Supplementary_Data</label>
      <media xlink:href="vbad030_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>This research was enabled in part by computing resources support provided by WestGrid and Compute Canada.</p>
    <sec>
      <title>Author contributions</title>
      <p>Xiangling Ji (Data curation [equal], Formal analysis [lead], Software [equal], Validation [equal], Visualization [equal], Writing—original draft [equal]), Danielle Tsao (Data curation [supporting], Formal analysis [equal], Software [equal], Validation [equal], Visualization [equal], Writing—review &amp; editing [equal]), Kailun Bai (Data curation [equal], Formal analysis [supporting], Writing—review &amp; editing [supporting]), Min Tsao (Conceptualization [supporting], Funding acquisition [supporting], Investigation [equal], Methodology [equal], Project administration [equal], Resources [equal], Software [equal], Supervision [equal], Validation [equal], Visualization [equal], Writing—review &amp; editing [equal]), Li Xing (Conceptualization [supporting], Funding acquisition [supporting], Investigation [equal], Methodology [equal], Project administration [equal], Resources [equal], Software [equal], Supervision [equal], Validation [equal], Visualization [equal], Writing—review &amp; editing [equal]) and Xuekui Zhang (Conceptualization [lead], Funding acquisition [lead], Investigation [equal], Methodology [equal], Project administration [equal], Resources [equal], Software [equal], Supervision [equal], Validation [equal], Visualization [equal], Writing—review &amp; editing [equal])</p>
    </sec>
    <sec sec-type="data-availability">
      <title>Data and software availability</title>
      <p>All data used in this study are published and can be accessed online as described in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref>. The code for reproducing results presented in our study is available on GitHub: <ext-link xlink:href="https://github.com/ubcxzhang/scAnnotate_reproduce" ext-link-type="uri">https://github.com/ubcxzhang/scAnnotate_reproduce</ext-link>. An open-source implementation of scAnnotate is available as an R package from CRAN.</p>
    </sec>
  </ack>
  <sec>
    <title>Funding</title>
    <p>This work was supported by Genome BC SIP7 [to X.Z., L.X., X.J., D.T. and K.B.], Canada Research Chair [950-231363 to X.Z.] and Natural Sciences and Engineering Research Council of Canada USRA-fellowship [565679-2021 to D.T.] and Discovery Grants [RGPIN-2021-03530 to L.X.].</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="vbad030-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Alquicira-Hernandez</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Scpred: accurate supervised method for cell-type classification from single-cell RNA-seq data</article-title>. <source>Genome Biol</source>., <volume>20</volume>, <fpage>1</fpage>–<lpage>17</lpage>.<pub-id pub-id-type="pmid">30606230</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Andrews</surname><given-names>T.S.</given-names></string-name>, <string-name><surname>Hemberg</surname><given-names>M.</given-names></string-name></person-group> (<year>2018</year>) <article-title>False signals induced by single-cell imputation</article-title>. <source>F1000Research</source><volume>7</volume>, 1740. <pub-id pub-id-type="doi">10.12688/f1000research.16613.2</pub-id>.</mixed-citation>
    </ref>
    <ref id="vbad030-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Aran</surname><given-names>D.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Reference-based analysis of lung single-cell sequencing reveals a transitional profibrotic macrophage</article-title>. <source>Nat. Immunol</source>., <volume>20</volume>, <fpage>163</fpage>–<lpage>172</lpage>.<pub-id pub-id-type="pmid">30643263</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Artegiani</surname><given-names>B.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>A single-cell RNA sequencing study reveals cellular and molecular dynamics of the hippocampal neurogenic niche</article-title>. <source>Cell Rep</source>., <volume>21</volume>, <fpage>3271</fpage>–<lpage>3284</lpage>.<pub-id pub-id-type="pmid">29241552</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Baron</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2016</year>) <article-title>A single-cell transcriptomic map of the human and mouse pancreas reveals inter- and intra-cell population structure</article-title>. <source>Cell Syst</source>., <volume>3</volume>, <fpage>346</fpage>–<lpage>360</lpage>.<pub-id pub-id-type="pmid">27667365</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Boufea</surname><given-names>K.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>ScID uses discriminant analysis to identify transcriptionally equivalent cell types across single-cell RNA-seq data with batch effect</article-title>. <source>iScience</source><volume>23</volume>, <fpage>100914</fpage>.<pub-id pub-id-type="pmid">32151972</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>H.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Revolutionizing immunology with single-cell RNA sequencing</article-title>. <source>Cell. Mol. Immunol</source>., <volume>16</volume>, <fpage>242</fpage>–<lpage>249</lpage>.<pub-id pub-id-type="pmid">30796351</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B8">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>T.</given-names></string-name>, <string-name><surname>Guestrin</surname><given-names>C.</given-names></string-name></person-group> (<year>2016</year>) Xgboost: a scalable tree boosting system. In: <italic toggle="yes">Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</italic> (KDD'16). Association for Computing Machinery, New York, NY, USA, pp. <fpage>785</fpage>–<lpage>794</lpage>. <pub-id pub-id-type="doi">10.1145/2939672.2939785</pub-id>.</mixed-citation>
    </ref>
    <ref id="vbad030-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cortal</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Gene signature extraction and cell identity recognition at the single-cell level with cell-ID</article-title>. <source>Nat. Biotechnol</source>., <volume>39</volume>, <fpage>1095</fpage>–<lpage>1102</lpage>.<pub-id pub-id-type="pmid">33927417</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>de Kanter</surname><given-names>J.K.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>CHETAH: a selective, hierarchical cell type identification method for single-cell RNA sequencing</article-title>. <source>Nucleic Acids Res</source>., <volume>47</volume>, <fpage>e95</fpage>–<lpage>e95</lpage>.<pub-id pub-id-type="pmid">31226206</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Diaz-Mejia</surname><given-names>J.J.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Evaluation of methods to assign cell type labels to cell clusters from single-cell RNA-sequencing data</article-title>. <source>F1000Research</source><volume>8</volume>(ISCB Comm J), 296. <pub-id pub-id-type="doi">10.12688/f1000research.18490.3</pub-id>.</mixed-citation>
    </ref>
    <ref id="vbad030-B12">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Ding</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) Systematic comparative analysis of single cell RNA-sequencing methods. <italic toggle="yes">bioRxiv</italic>.</mixed-citation>
    </ref>
    <ref id="vbad030-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Finak</surname><given-names>G.</given-names></string-name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>MAST: a flexible statistical framework for assessing transcriptional changes and characterizing heterogeneity in single-cell RNA sequencing data</article-title>. <source>Genome Biol</source>., <volume>16</volume>, <fpage>1</fpage>–<lpage>13</lpage>.<pub-id pub-id-type="pmid">25583448</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gong</surname><given-names>W.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Drimpute: imputing dropout events in single cell RNA sequencing data</article-title>. <source>BMC Bioinformatics</source>, <volume>19</volume>, <fpage>1</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">29291722</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gown</surname><given-names>A.M.</given-names></string-name></person-group> (<year>2008</year>) <article-title>Current issues in ER and HER2 testing by IHC in breast cancer</article-title>. <source>Mod. Pathol</source>., <volume>21</volume>, <fpage>S8</fpage>–<lpage>S15</lpage>.<pub-id pub-id-type="pmid">18437174</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Guo</surname><given-names>H.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Scsorter: assigning cells to known cell types according to marker genes</article-title>. <source>Genome Biol</source>., <volume>22</volume>, <fpage>69</fpage>–<lpage>69</lpage>.<pub-id pub-id-type="pmid">33618746</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hao</surname><given-names>Y.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Integrated analysis of multimodal single-cell data</article-title>. <source>Cell</source>, <volume>184</volume>, <fpage>3573</fpage>–<lpage>3587.e29</lpage>.<pub-id pub-id-type="pmid">34062119</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hicks</surname><given-names>S.C.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Missing data and technical variability in single-cell RNA-sequencing experiments</article-title>. <source>Biostatistics</source>, <volume>19</volume>, <fpage>562</fpage>–<lpage>578</lpage>.<pub-id pub-id-type="pmid">29121214</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hodge</surname><given-names>R.D.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Conserved cell types with divergent features in human versus mouse cortex</article-title>. <source>Nature</source>, <volume>573</volume>, <fpage>61</fpage>–<lpage>68</lpage>.<pub-id pub-id-type="pmid">31435019</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Huang</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Saver: gene expression recovery for single-cell RNA sequencing</article-title>. <source>Nat. Methods</source>, <volume>15</volume>, <fpage>539</fpage>–<lpage>542</lpage>.<pub-id pub-id-type="pmid">29941873</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kharchenko</surname><given-names>P.V.</given-names></string-name></person-group><etal>et al</etal> (<year>2014</year>) <article-title>Bayesian approach to single-cell differential expression analysis</article-title>. <source>Nat. Methods</source>, <volume>11</volume>, <fpage>740</fpage>–<lpage>742</lpage>.<pub-id pub-id-type="pmid">24836921</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kimmel</surname><given-names>J.C.</given-names></string-name>, <string-name><surname>Kelley</surname><given-names>D.R.</given-names></string-name></person-group> (<year>2021</year>) <article-title>Semisupervised adversarial neural networks for single-cell classification</article-title>. <source>Genome Res</source>., <volume>31</volume>, <fpage>1791</fpage>–<lpage>1793</lpage>.</mixed-citation>
    </ref>
    <ref id="vbad030-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kiselev</surname><given-names>V.Y.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Scmap: projection of single-cell RNA-seq data across data sets</article-title>. <source>Nat. Methods</source>, <volume>15</volume>, <fpage>359</fpage>–<lpage>362</lpage>.<pub-id pub-id-type="pmid">29608555</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B24">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Korsunsky</surname><given-names>I.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) Fast, sensitive, and flexible integration of single cell data with harmony. <italic toggle="yes">bioRxiv</italic>.</mixed-citation>
    </ref>
    <ref id="vbad030-B25">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Leach</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2013</year>). <source>Limitations</source>, chapter 3, pp. <fpage>20</fpage>–<lpage>30</lpage>. <publisher-name>John Wiley &amp; Sons, Ltd</publisher-name>.</mixed-citation>
    </ref>
    <ref id="vbad030-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>C.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>SciBet as a portable and fast single cell type identifier</article-title>. <source>Nat. Commun</source>., <volume>11</volume>, <fpage>1818</fpage>–<lpage>1818</lpage>.<pub-id pub-id-type="pmid">32286268</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>W.V.</given-names></string-name>, <string-name><surname>Li</surname><given-names>J.J.</given-names></string-name></person-group> (<year>2018</year>) <article-title>An accurate and robust imputation method scimpute for single-cell RNA-seq data</article-title>. <source>Nat. Commun</source>., <volume>9</volume>, <fpage>1</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">29317637</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lieberman</surname><given-names>Y.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>CaSTLe—classification of single cells by transfer learning: harnessing the power of publicly available single cell RNA sequencing experiments to annotate new experiments</article-title>. <source>PLoS ONE</source><volume>13</volume>, <fpage>e0205499</fpage>.<pub-id pub-id-type="pmid">30304022</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lin</surname><given-names>Y.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>scClassify: sample size estimation and multiscale classification of cells using single and multiple reference</article-title>. <source>Mol. Syst. Biol</source>., <volume>16</volume>, <fpage>e9389</fpage>.<pub-id pub-id-type="pmid">32567229</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>R.Y.</given-names></string-name></person-group><etal>et al</etal> (<year>1999</year>) <article-title>Multivariate analysis by data depth: descriptive statistics, graphics and inference</article-title>. <source>Ann. Stat</source>., <volume>27</volume>, <fpage>783</fpage>–<lpage>858</lpage> (with discussion).</mixed-citation>
    </ref>
    <ref id="vbad030-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Miao</surname><given-names>Z.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Desingle for detecting three types of differential expression in single-cell RNA-seq data</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3223</fpage>–<lpage>3224</lpage>.<pub-id pub-id-type="pmid">29688277</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pasquini</surname><given-names>G.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Automated methods for cell type annotation on scRNA-seq data</article-title>. <source>Comput. Struct. Biotechnol. J.</source><volume>19</volume>, <fpage>961</fpage>–<lpage>969</lpage>.<pub-id pub-id-type="pmid">33613863</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rish</surname><given-names>I.</given-names></string-name></person-group><etal>et al</etal> (<year>2001</year>) An empirical study of the naive Bayes classifier. In: <italic toggle="yes">IJCAI 2001 Workshop on Empirical Methods in Artificial Intelligence</italic>, Vol. <volume>3</volume>, pp. <fpage>41</fpage>–<lpage>46</lpage>.</mixed-citation>
    </ref>
    <ref id="vbad030-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Soneson</surname><given-names>C.</given-names></string-name>, <string-name><surname>Robinson</surname><given-names>M.D.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Bias, robustness and scalability in single-cell differential expression analysis</article-title>. <source>Nat. Methods</source>, <volume>15</volume>, <fpage>255</fpage>–<lpage>261</lpage>.<pub-id pub-id-type="pmid">29481549</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tan</surname><given-names>Y.</given-names></string-name>, <string-name><surname>Cahan</surname><given-names>P.</given-names></string-name></person-group> (<year>2019</year>) <article-title>SingleCellNet: a computational tool to classify single cell RNA-seq data across platforms and across species</article-title>. <source>Cell Syst.</source><volume>9</volume>, <fpage>207</fpage>–<lpage>213</lpage>.<pub-id pub-id-type="pmid">31377170</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tang</surname><given-names>F.</given-names></string-name></person-group><etal>et al</etal> (<year>2009</year>) <article-title>mRNA-Seq whole-transcriptome analysis of a single cell</article-title>. <source>Nat. Methods</source>, <volume>6</volume>, <fpage>377</fpage>–<lpage>382</lpage>.<pub-id pub-id-type="pmid">19349980</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tasic</surname><given-names>B.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Shared and distinct transcriptomic cell types across neocortical areas</article-title>. <source>Nature</source>, <volume>563</volume>, <fpage>72</fpage>–<lpage>78</lpage>.<pub-id pub-id-type="pmid">30382198</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tian</surname><given-names>L.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Benchmarking single cell RNA-sequencing analysis pipelines using mixture control experiments</article-title>. <source>Nat. Methods</source>, <volume>16</volume>, <fpage>479</fpage>–<lpage>487</lpage>.<pub-id pub-id-type="pmid">31133762</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tran</surname><given-names>H.T.N.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>A benchmark of batch-effect correction methods for single-cell RNA sequencing data</article-title>. <source>Genome Biol</source>., <volume>21</volume>, <fpage>1</fpage>–<lpage>32</lpage>.</mixed-citation>
    </ref>
    <ref id="vbad030-B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wolpert</surname><given-names>D.H.</given-names></string-name>, <string-name><surname>Macready</surname><given-names>W.G.</given-names></string-name></person-group> (<year>1997</year>) <article-title>No free lunch theorems for optimization</article-title>. <source>Trans. Evol. Comput</source>., <volume>1</volume>, <fpage>67</fpage>–<lpage>82</lpage>.</mixed-citation>
    </ref>
    <ref id="vbad030-B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yang</surname><given-names>F.</given-names></string-name></person-group><etal>et al</etal> (<year>2022</year>) <article-title>scBERT as a large-scale pretrained deep language model for cell type annotation of single-cell RNA-seq data</article-title>. <source>Nat. Mach. Intell</source>., <volume>4</volume>, <fpage>852</fpage>–<lpage>866</lpage>.</mixed-citation>
    </ref>
    <ref id="vbad030-B42">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhao</surname><given-names>X.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>Evaluation of single-cell classifiers for single-cell RNA sequencing data sets</article-title>. <source>Brief. Bioinform</source>., <volume>21</volume>, <fpage>1581</fpage>–<lpage>1595</lpage>.<pub-id pub-id-type="pmid">31675098</pub-id></mixed-citation>
    </ref>
    <ref id="vbad030-B43">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zou</surname><given-names>H.</given-names></string-name>, <string-name><surname>Hastie</surname><given-names>T.</given-names></string-name></person-group> (<year>2005</year>) <article-title>Regularization and variable selection via the elastic net</article-title>. <source>J. R. Stat. Soc. Ser. B (Stat. Methodol.)</source>, <volume>67</volume>, <fpage>301</fpage>–<lpage>320</lpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
