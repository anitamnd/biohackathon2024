<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10089674</article-id>
    <article-id pub-id-type="pmid">36945891</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad142</article-id>
    <article-id pub-id-type="publisher-id">btad142</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genome Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>OutSingle: a novel method of detecting and injecting outliers in RNA-Seq count data using the optimal hard threshold for singular values</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Salkovic</surname>
          <given-names>Edin</given-names>
        </name>
        <aff><institution>College of Science Engineering, Hamad Bin Khalifa University</institution>, Doha, <country country="QA">Qatar</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Sadeghi</surname>
          <given-names>Mohammad Amin</given-names>
        </name>
        <aff><institution>Qatar Computing Research Institute, Hamad Bin Khalifa University</institution>, Doha, <country country="QA">Qatar</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8742-5519</contrib-id>
        <name>
          <surname>Baggag</surname>
          <given-names>Abdelkader</given-names>
        </name>
        <aff><institution>Qatar Computing Research Institute, Hamad Bin Khalifa University</institution>, Doha, <country country="QA">Qatar</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Salem</surname>
          <given-names>Ahmed Gamal Rashed</given-names>
        </name>
        <aff><institution>Department of Computer Sciences, College of Engineering, Qatar University</institution>, <addr-line>P.O. Box: 2713</addr-line>, Doha, <country country="QA">Qatar</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-6700-5752</contrib-id>
        <name>
          <surname>Bensmail</surname>
          <given-names>Halima</given-names>
        </name>
        <aff><institution>Qatar Computing Research Institute, Hamad Bin Khalifa University</institution>, Doha, <country country="QA">Qatar</country></aff>
        <xref rid="btad142-cor1" ref-type="corresp"/>
        <!--hbensmail@hbku.edu.qa-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Kendziorski</surname>
          <given-names>Christina</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad142-cor1">Corresponding author. Center for Artificial intelligence, Qatar Computing Research Institute, Hamad Bin Khalifa University, PO Box 34110, Doha, Qatar. E-mail: <email>hbensmail@hbku.edu.qa</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>4</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-03-22">
      <day>22</day>
      <month>3</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>22</day>
      <month>3</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>4</issue>
    <elocation-id>btad142</elocation-id>
    <history>
      <date date-type="received">
        <day>31</day>
        <month>5</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>23</day>
        <month>2</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>12</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>20</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>11</day>
        <month>4</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad142.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Finding outliers in RNA-sequencing (RNA-Seq) gene expression (GE) can help in identifying genes that are aberrant and cause Mendelian disorders. Recently developed models for this task rely on modeling RNA-Seq GE data using the negative binomial distribution (NBD). However, some of those models either rely on procedures for inferring NBD’s parameters in a nonbiased way that are computationally demanding and thus make confounder control challenging, while others rely on less computationally demanding but biased procedures and convoluted confounder control approaches that hinder interpretability.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this article, we present OutSingle (Outlier detection using Singular Value Decomposition), an almost instantaneous way of detecting outliers in RNA-Seq GE data. It uses a simple log-normal approach for count modeling. For confounder control, it uses the recently discovered optimal hard threshold (OHT) method for noise detection, which itself is based on singular value decomposition (SVD). Due to its SVD/OHT utilization, OutSingle’s model is straightforward to understand and interpret. We then show that our novel method, when used on RNA-Seq GE data with real biological outliers masked by confounders, outcompetes the previous state-of-the-art model based on an <italic toggle="yes">ad hoc</italic> denoising autoencoder. Additionally, OutSingle can be used to inject artificial outliers masked by confounders, which is difficult to achieve with previous approaches. We describe a way of using OutSingle for outlier injection and proceed to show how OutSingle outperforms its competition on 16 out of 18 datasets that were generated from three real datasets using OutSingle’s injection procedure with different outlier types and magnitudes. Our methods are applicable to other types of similar problems involving finding outliers in matrices under the presence of confounders.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The code for OutSingle is available at <ext-link xlink:href="https://github.com/esalkovic/outsingle" ext-link-type="uri">https://github.com/esalkovic/outsingle</ext-link>.</p>
      </sec>
    </abstract>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Recent research efforts have made evident that whole-genome sequencing while being able to provide a global insight into the genetic material of organisms, is unable to always help in identifying the genetic causes of localized genetic disorders, such as rare Mendelian diseases of specific tissues (<xref rid="btad142-B23" ref-type="bibr">Wortmann et al. 2015</xref>; <xref rid="btad142-B21" ref-type="bibr">Turro et al. 2020</xref>).</p>
    <p>Other recent works also reported on RNA-sequencing (RNA-Seq) gene expression (GE) data being a useful additional source of information for finding the genetic causes of such rare diseases (<xref rid="btad142-B6" ref-type="bibr">Cummings et al. 2017</xref>; <xref rid="btad142-B10" ref-type="bibr">Kremer et al. 2017</xref>; <xref rid="btad142-B2" ref-type="bibr">Bamshad et al. 2019</xref>; <xref rid="btad142-B14" ref-type="bibr">Mertes et al. 2021</xref>; <xref rid="btad142-B15" ref-type="bibr">Murdock et al. 2021</xref>; <xref rid="btad142-B25" ref-type="bibr">Yépez et al. 2021</xref>).</p>
    <p>These works used RNA-Seq GE data in different ways but in our work, we focus only on finding outliers in RNA-Seq GE count data. To our knowledge, only <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref>, <xref rid="btad142-B18" ref-type="bibr">Salkovic et al. (2020)</xref>, and <xref rid="btad142-B17" ref-type="bibr">Salkovic and Bensmail (2021)</xref> developed models for specifically tackling the problem of finding outlier counts in RNA-Seq GE data for the purpose of identifying the genetic causes of Mendelian disorders. Both used the negative binomial distribution (NBD) to model the data.</p>
    <p>Other researchers relied on general methods for detecting outliers and methods developed for other purposes. For example, <xref rid="btad142-B6" ref-type="bibr">Cummings et al. (2017)</xref> calculated simple <italic toggle="yes">z</italic>-scores of log-transformed and normalized counts, while <xref rid="btad142-B10" ref-type="bibr">Kremer et al. (2017)</xref> also used a <italic toggle="yes">z</italic>-score-based approach in conjunction with a statistical significance test from DESeq2 (<xref rid="btad142-B12" ref-type="bibr">Love et al. 2014</xref>), which was originally designed for differential expression not outlier detection. However, <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref> have shown that building a model specifically for outlier detection with incorporated confounder control can give better results: their model detected six out of six validated pathogenic events as outliers, while <xref rid="btad142-B10" ref-type="bibr">Kremer et al. (2017)</xref> detected only four.</p>
    <p><xref rid="btad142-B18" ref-type="bibr">Salkovic et al. (2020)</xref> and its improved version <xref rid="btad142-B17" ref-type="bibr">Salkovic and Bensmail (2021)</xref> focused on data with outliers, neglecting confounder control while suggesting that confounder control could be implemented downstream. However, they did not provide any concrete recommendations. All of these outlier-oriented models have downsides. When it comes to the OUTRIDER (Outlier in RNA-Seq Finder) model by <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref>, it can be deduced that its authors were forced to use an autoencoder (AE) to control for confounders, as they had been unable to obtain good results using a simpler dimensionality reduction method such as principal component analysis (PCA). They themselves suggest that PCA is not suitable for the NBD loss function that they used for training their tool. Furthermore, as the AE they use is a denoising AE, in order to determine the latent dimension of the AE they relied on artificial noise injection with somewhat arbitrary characteristics: a mean of <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and a standard deviation of <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>1.6</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, with a <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> frequency of injection. Moreover, in order to prevent convergence issues while training they had to initialize their model parameters manually, and monitor that the parameter values are between certain numerical bounds. Finally, although the NBD loss function they constructed is mathematically sound, we can say that the process of deriving it is somewhat laborious because they did not include it in the paper’s main body. Instead, they detailed the numerous steps in the Supplementary material. Similar complexity issues affected the updating of the parameters of the AE’s decoding matrix which is tightly tied to the loss function. Another drawback of their overall approach is that they tested the performance of their method on datasets that were derived from real datasets by injecting artificial outliers using a simple z-score-based procedure without mimicking confounding effects. However, the main stated reason for developing OUTRIDER was for it to detect outliers masked by confounding effects, not simple outliers. Due to the complexity of their model, they did not inject artificial outliers masked by confounders.</p>
    <p>Having said that, we have to acknowledge that their model performs well on the real datasets they tested it against, as well as datasets with artificially injected outliers: at the time of writing this work their model was state of the art. As <xref rid="btad142-B18" ref-type="bibr">Salkovic et al. (2020)</xref> and <xref rid="btad142-B17" ref-type="bibr">Salkovic and Bensmail (2021)</xref> used OUTRIDER in their performance comparisons, from their results we can say that OUTRIDER seems to perform best on data with underexpressed outliers.</p>
    <p>As far as OutPyR by <xref rid="btad142-B18" ref-type="bibr">Salkovic et al. (2020)</xref> is concerned, the main downsides of their Bayesian model are its computational complexity leading to very long execution times and the lack of confounder control, which prevents the model from being performant on datasets with outliers that are masked by confounding effects. Although the authors suggest performing confounder control downstream, i.e. on the <italic toggle="yes">P</italic>-value matrix that their model produces, they fail to show a concrete way of how to perform it.</p>
    <p>Still, while their model is based on the NBD distribution, due to its Bayesian nature it does not impose unique, rigid values on the parameters of the model, but instead the values are sampled from a loose posterior distribution of the parameters using a recently discovered method of inferring the dispersion parameter of the NBD through a particular form of Gibbs sampling (<xref rid="btad142-B26" ref-type="bibr">Zhou and Carin 2015</xref>). This allows their model to incorporate uncertainty in their reported <italic toggle="yes">P</italic>-values, which can be useful for downstream analysis. Also, they show that their model performs well in some settings with datasets containing a small number of samples and artificially injected outliers, as well as a synthetic NBD dataset with a large number of samples having no confounding. <xref rid="btad142-B17" ref-type="bibr">Salkovic and Bensmail (2021)</xref> with their Bayesian OutPyRX model further improved the OutPyR model by extending it with novel parameters which they utilize for developing a novel outlier score. Their model has multifold decrease in execution time compared to OutPyR, while also obtaining much better performance in their experiments involving real datasets with artificially injected outliers. However, they again use outliers with <italic toggle="yes">z</italic>-scores of only 3 and 4, neglecting 2. Although, similar to OutPyR, they do not perform any confounder control, nevertheless they get good results on datasets with a large number of samples, significantly outperforming OUTRIDER, both its AE version, as well as its PCA and PEER versions, all of which do perform confounder control.</p>
    <sec>
      <title>1.1 Our contribution</title>
      <p>In order to improve on results and the methodology of prior research efforts, in this article, we propose a novel method, OutSingle (Outlier detection using Singular Value Decomposition) for outlier detection in count data. The method can be decomposed into two steps that have separate but complementary roles.</p>
      <p>The first step is simply log-transforming the data and then calculating gene-specific <italic toggle="yes">z</italic>-scores. The second step, which is our main contribution, is a confounder control method for <italic toggle="yes">z</italic>-score matrices (such as the one calculated in the first step) that relies on the recently discovered method for denoising matrices by finding an optimal hard threshold (OHT) for discarding singular values obtained through singular value decomposition (SVD) (<xref rid="btad142-B9" ref-type="bibr">Gavish and Donoho 2014</xref>).</p>
      <p>In comparison to OUTRIDER, by using SVD and OHT we evade the need to implement an <italic toggle="yes">ad hoc</italic> AE, and thus avoid deriving complicated loss functions, training using artificial noise, and performing repeated inference in order to find the latent AE dimension. Both SVD and OHT are deterministic.</p>
      <p>When we apply our model on the benchmark dataset by <xref rid="btad142-B10" ref-type="bibr">Kremer et al. (2017)</xref> which contains real, biologically aberrant counts masked by confounder effects, we obtain results better than the previous state-of-the-art model OUTRIDER (<xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. 2018</xref>) in a fraction of its running time.</p>
      <p>Moreover, relying on the fact that both steps of our procedure are “invertible”, we implement an inverse procedure in order to inject artificial outliers masked by confounding effects. Due to the complexity of the OUTRIDER model, such a procedure was not even considered by <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref>.</p>
      <p>In the following section, we give more details about our methods, in Section 3, we briefly describe the datasets we use to test the performance of our method, in Section 4, we discuss the results of those tests, and we conclude with Section 5.</p>
    </sec>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>An RNA-Seq GE count dataset is a <italic toggle="yes">J </italic>×<italic toggle="yes"> N</italic> matrix of counts <italic toggle="yes">k<sub>ji</sub></italic> whose columns correspond to different samples <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, while rows correspond to different genes <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>J</mml:mi></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>J</mml:mi><mml:mo>≫</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>. When it comes to datasets that are used for identifying rare Mendelian disease disorders, samples would correspond to same-tissue samples from different patients having a rare disease specific to that tissue.</p>
    <sec>
      <title>2.1 Log-normal <italic toggle="yes">z</italic>-scores</title>
      <p>Our assumption is that the counts <italic toggle="yes">k<sub>ji</sub></italic> follow a log-normal distribution. Such modeling of count data is well known (see <xref rid="btad142-B16" ref-type="bibr">Robinson et al. 2010</xref>; <xref rid="btad142-B13" ref-type="bibr">McCarthy et al. 2012</xref>; <xref rid="btad142-B24" ref-type="bibr">Wu et al. 2013</xref>; <xref rid="btad142-B11" ref-type="bibr">Law et al. 2014</xref>; <xref rid="btad142-B27" ref-type="bibr">Zhu et al. 2019</xref>). Based on that assumption, we calculate gene-specific <italic toggle="yes">z</italic>-scores for every count in the matrix. First, we control for sequencing depth using sample-specific DESeq size factors <italic toggle="yes">s</italic><sub><italic toggle="yes">i</italic></sub> (<xref rid="btad142-B1" ref-type="bibr">Anders and Huber 2010</xref>):
Then, we log-transform the controlled counts <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>:
where <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are gene-specific mean values of <italic toggle="yes">c<sub>ji</sub></italic>.</p>
      <disp-formula id="E1">
        <label>(1)</label>
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>s</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:munder>
              <mml:mrow>
                <mml:mtext>median</mml:mtext>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:munder>
            <mml:mfrac>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mrow>
                <mml:msup>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:mo stretchy="true">(</mml:mo>
                        <mml:mrow>
                          <mml:munderover>
                            <mml:mo>∏</mml:mo>
                            <mml:mrow>
                              <mml:mi>t</mml:mi>
                              <mml:mo>=</mml:mo>
                              <mml:mn>1</mml:mn>
                            </mml:mrow>
                            <mml:mi>N</mml:mi>
                          </mml:munderover>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>k</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>j</mml:mi>
                              <mml:mi>t</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                        <mml:mo stretchy="true">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mfrac>
                      <mml:mn>1</mml:mn>
                      <mml:mi>N</mml:mi>
                    </mml:mfrac>
                  </mml:mrow>
                </mml:msup>
              </mml:mrow>
            </mml:mfrac>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E2">
        <label>(2)</label>
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>c</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>j</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                  <mml:mi>i</mml:mi>
                </mml:msub>
              </mml:mrow>
            </mml:mfrac>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E3">
        <label>(3)</label>
        <mml:math id="M3" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>l</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>j</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo> </mml:mo>
                  <mml:mtext>log</mml:mtext>
                  <mml:mo> </mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>c</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>+</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>c</mml:mi>
                            <mml:mo>¯</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mi>j</mml:mi>
                    </mml:msub>
                    <mml:mo>+</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
          </mml:mrow>
          <mml:mo>,</mml:mo>
        </mml:math>
      </disp-formula>
      <p>Now, we can model the <italic toggle="yes">l<sub>ji</sub></italic> values as being normally distributed and having gene-specific means <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>l</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and standard deviations <italic toggle="yes">λ<sub>j</sub></italic> as the following: we assume that our data are expressed as a matrix <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>J</mml:mi></mml:mrow></mml:math></inline-formula> (genes), <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> (samples), and <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo>Λ</mml:mo><mml:mo>=</mml:mo><mml:mtext>diag</mml:mtext><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mo>λ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>λ</mml:mo></mml:mrow><mml:mi>J</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Therefore, we can express every row of the matrix <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> as a vector having a normal distribution, i.e.
</p>
      <disp-formula id="E4">
        <label>(4)</label>
        <mml:math id="M4" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>l</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>j</mml:mi>
                <mml:mo>.</mml:mo>
              </mml:mrow>
            </mml:msub>
            <mml:mo>∼</mml:mo>
            <mml:mi mathvariant="script" class="calligraphy">N</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>l</mml:mi>
                    <mml:mo>¯</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mi>j</mml:mi>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mo>λ</mml:mo>
              </mml:mrow>
              <mml:mi>j</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>This assumption is motivated by the fact that even the original counts <italic toggle="yes">k<sub>ji</sub></italic> in a single gene can be seen as being generated by a single gene-specific underlying process. For example, <xref rid="btad142-B18" ref-type="bibr">Salkovic et al. (2020)</xref> use gene-specific NBD modeling. Thus, it is reasonable to expect that the <italic toggle="yes">l<sub>ji</sub></italic> values will have gene-specific normal distributions.</p>
      <p>Finally, we can calculate a <italic toggle="yes">J </italic>×<italic toggle="yes"> N z</italic>-score matrix <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> (the reason for the tilde notation will be made clear in the next section), whose members <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> correspond directly to the original counts <italic toggle="yes">k<sub>ji</sub></italic>:
where <italic toggle="yes">μ<sub>j</sub></italic> and <italic toggle="yes">τ<sub>j</sub></italic> are the gene-specific means and standard deviations of <italic toggle="yes">l<sub>ji</sub></italic> values. By doing this, we have standardized the whole matrix. It is well known that many algorithms perform best on data that is standardized, and we use that fact in the next step, by applying SVD on the obtained <italic toggle="yes">z</italic>-score matrix.</p>
      <disp-formula id="E5">
        <label>(5)</label>
        <mml:math id="M5" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>z</mml:mi>
                    <mml:mo>˜</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>j</mml:mi>
                <mml:mi>i</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>l</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>−</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mo>μ</mml:mo>
                  </mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:msub>
              </mml:mrow>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mo>τ</mml:mo>
                  </mml:mrow>
                  <mml:mi>j</mml:mi>
                </mml:msub>
              </mml:mrow>
            </mml:mfrac>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
    </sec>
    <sec>
      <title>2.2 OutSingle: confounder control using SVD and OHT</title>
      <p>Here, we develop a confounding control procedure based on applying SVD on the matrix <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. The main benefit of using SVD for confounder control over an AE is the ease of implementation, as SVD is available in many programming languages and does not require extensive <italic toggle="yes">ad hoc</italic> setting up the way an AE would require. Another benefit is speed due to the SVD being an established method and therefore there are many optimizations in its implementations. We used SciPy’s (<xref rid="btad142-B22" ref-type="bibr">Virtanen et al. 2020</xref>) implementation. Perhaps, the most important benefit is that we do not have to perform repeated AE training in order to find the optimal latent AE dimension. Instead, we can rely on an almost instantaneous procedure which is described in Section 2.2.1.</p>
      <p>We consider the matrix <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> as being a perturbation (hence the tilde notation) of a low-rank matrix <bold>Z</bold> (<xref rid="btad142-B20" ref-type="bibr">Stewart 1998</xref>):
where <bold>E</bold> is a Gaussian noise matrix. The matrix <bold>Z</bold> is also called “signal” (<xref rid="btad142-B20" ref-type="bibr">Stewart 1998</xref>). In the following, we will show what the expressions of <bold>Z</bold> and <bold>E</bold> are. The <italic toggle="yes">z</italic>-scores corresponding to biological outliers will be contained in the noise matrix <bold>E</bold>. Because they have an extremely sparse impulse-like distribution, they cannot be considered part of the signal. The signal matrix <bold>Z</bold>, on the other hand, can be thought of as “capturing” the confounding effects because it has an underlying coherent structure that is distinct from both Gaussian noise and outliers. Using SVD, we can decompose <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> as follows:
where <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">U</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">V</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> are orthogonal matrices with <italic toggle="yes">J </italic>×<italic toggle="yes"> J</italic> and <italic toggle="yes">N </italic>×<italic toggle="yes"> N</italic> dimensions and <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Σ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is a rectangular diagonal <italic toggle="yes">J </italic>×<italic toggle="yes"> N</italic> matrix, having non-negative values on the diagonal called singular values (i.e. <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Σ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>diag</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>J</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>σ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>σ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>N</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). Specifically, columns of <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">U</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">V</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> in the singular value decomposition of <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> always form an orthogonal set with no assumption on <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. Therefore they capture the projection space and all information is captured by <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>Σ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> including perturbation and noise, which means that there is a sensitivity in the singular value <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>Σ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. The singular values of <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Σ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> are in descending order from the top left value to the bottom right value on the diagonal. That is the standard way of ordering singular values.</p>
      <disp-formula id="E6">
        <label>(6)</label>
        <mml:math id="M6" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:mover accent="true">
                <mml:mi mathvariant="bold">Z</mml:mi>
                <mml:mo>˜</mml:mo>
              </mml:mover>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mi mathvariant="bold">Z</mml:mi>
            <mml:mo>+</mml:mo>
            <mml:mi mathvariant="bold">E</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E7">
        <label>(7)</label>
        <mml:math id="M7" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:mover accent="true">
                <mml:mi mathvariant="bold">Z</mml:mi>
                <mml:mo>˜</mml:mo>
              </mml:mover>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mover accent="true">
                <mml:mi mathvariant="normal">U</mml:mi>
                <mml:mo>˜</mml:mo>
              </mml:mover>
            </mml:mrow>
            <mml:mrow>
              <mml:mover accent="true">
                <mml:mi>Σ</mml:mi>
                <mml:mo>˜</mml:mo>
              </mml:mover>
            </mml:mrow>
            <mml:msup>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi mathvariant="bold">V</mml:mi>
                    <mml:mo>˜</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mi>T</mml:mi>
            </mml:msup>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Considering this descending order of singular values, we can say that, theoretically, if we knew only the rank <italic toggle="yes">r</italic> of the low-rank signal matrix <bold>Z</bold>, we could split <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Σ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> into two matrices that would directly correspond to <bold>Z</bold> and <bold>E</bold>:
where
<inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mi mathvariant="bold">Σ</mml:mi></mml:math></inline-formula> would then be an r-rank matrix, having zeroes in the lower right part, while <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">Σ</mml:mi></mml:mrow><mml:mi mathvariant="bold">E</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> would be a matrix of rank <italic toggle="yes">N − r</italic>, having zeroes in the top part. Using the previous set up, we have
Approximating the original matrices <bold>Z</bold> and <bold>E</bold> is then trivial:
which proves (6).</p>
      <disp-formula id="E8">
        <label>(8)</label>
        <mml:math id="M8" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:mover accent="true">
                <mml:mi mathvariant="bold">Σ</mml:mi>
                <mml:mo>˜</mml:mo>
              </mml:mover>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mi mathvariant="bold">Σ</mml:mi>
            <mml:mo>+</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi mathvariant="bold">Σ</mml:mi>
              </mml:mrow>
              <mml:mi mathvariant="bold">E</mml:mi>
            </mml:msub>
          </mml:mrow>
          <mml:mo>,</mml:mo>
        </mml:math>
      </disp-formula>
      <disp-formula id="E9">
        <mml:math id="M9" display="block" overflow="scroll">
          <mml:mtable>
            <mml:mtr>
              <mml:mtd>
                <mml:mi mathvariant="bold">Σ</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:mtable>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi mathvariant="bold">Σ</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo stretchy="false">[</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo stretchy="false">]</mml:mo>
                              </mml:mrow>
                              <mml:mi>r</mml:mi>
                            </mml:msubsup>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo stretchy="false">[</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>N</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo stretchy="false">]</mml:mo>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo stretchy="false">[</mml:mo>
                                <mml:mi>J</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo stretchy="false">]</mml:mo>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo stretchy="false">[</mml:mo>
                                <mml:mi>J</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>N</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo stretchy="false">]</mml:mo>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mtd>
                      </mml:mtr>
                    </mml:mtable>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
                <mml:mo> </mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="bold">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mi>E</mml:mi>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:mtable>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo stretchy="false">[</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo stretchy="false">]</mml:mo>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo stretchy="false">[</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>N</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo stretchy="false">]</mml:mo>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mn>0</mml:mn>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo stretchy="false">[</mml:mo>
                                <mml:mi>J</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo stretchy="false">]</mml:mo>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mi mathvariant="bold">Σ</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo stretchy="false">[</mml:mo>
                                <mml:mi>J</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>N</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo stretchy="false">]</mml:mo>
                              </mml:mrow>
                              <mml:mi>n</mml:mi>
                            </mml:msubsup>
                          </mml:mrow>
                        </mml:mtd>
                      </mml:mtr>
                    </mml:mtable>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
            <mml:mtr>
              <mml:mtd>
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi mathvariant="bold">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mo stretchy="false">[</mml:mo>
                    <mml:mi>r</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>r</mml:mi>
                    <mml:mo stretchy="false">]</mml:mo>
                  </mml:mrow>
                  <mml:mi>r</mml:mi>
                </mml:msubsup>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:mtable>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mo>σ</mml:mo>
                              </mml:mrow>
                              <mml:mn>1</mml:mn>
                              <mml:mo>2</mml:mo>
                            </mml:msubsup>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mo>σ</mml:mo>
                              </mml:mrow>
                              <mml:mn>2</mml:mn>
                              <mml:mo>2</mml:mo>
                            </mml:msubsup>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mo>⋮</mml:mo>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mo>⋮</mml:mo>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mo>⋱</mml:mo>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mo>⋮</mml:mo>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mo>⋯</mml:mo>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mo>σ</mml:mo>
                              </mml:mrow>
                              <mml:mi>r</mml:mi>
                              <mml:mn>2</mml:mn>
                            </mml:msubsup>
                          </mml:mrow>
                        </mml:mtd>
                      </mml:mtr>
                    </mml:mtable>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
                <mml:mo> </mml:mo>
                <mml:msubsup>
                  <mml:mrow>
                    <mml:mi mathvariant="bold">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mo stretchy="false">[</mml:mo>
                    <mml:mi>J</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mi>r</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>N</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mi>r</mml:mi>
                    <mml:mo stretchy="false">]</mml:mo>
                  </mml:mrow>
                  <mml:mi>n</mml:mi>
                </mml:msubsup>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:mtable>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mo>ϵ</mml:mo>
                              </mml:mrow>
                              <mml:mn>1</mml:mn>
                              <mml:mo>2</mml:mo>
                            </mml:msubsup>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mo>ϵ</mml:mo>
                              </mml:mrow>
                              <mml:mn>2</mml:mn>
                              <mml:mo>2</mml:mo>
                            </mml:msubsup>
                          </mml:mrow>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mo>⋮</mml:mo>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mo>⋮</mml:mo>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mo>⋱</mml:mo>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mo>⋮</mml:mo>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mo>⋯</mml:mo>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mrow>
                                <mml:mo>ϵ</mml:mo>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>N</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>r</mml:mi>
                              </mml:mrow>
                              <mml:mn>2</mml:mn>
                            </mml:msubsup>
                          </mml:mrow>
                        </mml:mtd>
                      </mml:mtr>
                      <mml:mtr>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mo>⋯</mml:mo>
                        </mml:mtd>
                        <mml:mtd>
                          <mml:mn>0</mml:mn>
                        </mml:mtd>
                      </mml:mtr>
                    </mml:mtable>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
          <mml:mo>,</mml:mo>
        </mml:math>
      </disp-formula>
      <disp-formula id="E10">
        <mml:math id="M10" display="block" overflow="scroll">
          <mml:mtable>
            <mml:mtr>
              <mml:mtd>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi mathvariant="bold">Z</mml:mi>
                    <mml:mo>˜</mml:mo>
                  </mml:mover>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi mathvariant="bold">U</mml:mi>
                    <mml:mo>˜</mml:mo>
                  </mml:mover>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi mathvariant="bold">Σ</mml:mi>
                <mml:mo>+</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="bold">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mi mathvariant="bold">E</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi mathvariant="bold">V</mml:mi>
                        <mml:mo>˜</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:msup>
              </mml:mtd>
            </mml:mtr>
            <mml:mtr>
              <mml:mtd>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi mathvariant="normal">U</mml:mi>
                    <mml:mo>˜</mml:mo>
                  </mml:mover>
                </mml:mrow>
                <mml:mo>Σ</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi mathvariant="bold">V</mml:mi>
                        <mml:mo>˜</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:msup>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi mathvariant="bold">U</mml:mi>
                    <mml:mo>˜</mml:mo>
                  </mml:mover>
                </mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="bold">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mi>E</mml:mi>
                </mml:msub>
                <mml:msup>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi mathvariant="bold">V</mml:mi>
                        <mml:mo>˜</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:msup>
                <mml:mo>.</mml:mo>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <disp-formula id="E11">
        <label>(9)</label>
        <mml:math id="M11" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi mathvariant="bold">Z</mml:mi>
            <mml:mo>≈</mml:mo>
            <mml:mrow>
              <mml:mover accent="true">
                <mml:mi mathvariant="normal">U</mml:mi>
                <mml:mo>˜</mml:mo>
              </mml:mover>
            </mml:mrow>
            <mml:mo>Σ</mml:mo>
            <mml:msup>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi mathvariant="bold">V</mml:mi>
                    <mml:mo>˜</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mi>T</mml:mi>
            </mml:msup>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E12">
        <label>(10)</label>
        <mml:math id="M12" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi mathvariant="bold">E</mml:mi>
            <mml:mo>≈</mml:mo>
            <mml:mrow>
              <mml:mover accent="true">
                <mml:mi mathvariant="bold">U</mml:mi>
                <mml:mo>˜</mml:mo>
              </mml:mover>
            </mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi mathvariant="bold">Σ</mml:mi>
              </mml:mrow>
              <mml:mi mathvariant="bold">E</mml:mi>
            </mml:msub>
            <mml:msup>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi mathvariant="bold">V</mml:mi>
                    <mml:mo>˜</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mi>T</mml:mi>
            </mml:msup>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>In the remainder of the work, we will treat these two approximations as equality in order to reduce the amount of symbols we use for notation. The rank <italic toggle="yes">r</italic> can be considered as a “cutoff”, because by keeping only the first <italic toggle="yes">r</italic> singular values and dismissing the rest, the noise is removed and only signal is kept.</p>
      <sec>
        <title>2.2.1 Optimal hard threshold</title>
        <p><xref rid="btad142-B9" ref-type="bibr">Gavish and Donoho (2014)</xref> have found an optimal method to remove the noise <bold>E</bold> from an SVD-decomposable matrix <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> by finding the rank <italic toggle="yes">r</italic> (i.e. singular value cutoff which they call OHT) of the low-rank matrix <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mi mathvariant="bold">Σ</mml:mi></mml:math></inline-formula> (<xref rid="btad142-F1" ref-type="fig">Fig. 1</xref>). The assumption under which their model is valid is that the <bold>E</bold> has the following property (<xref rid="btad142-B5" ref-type="bibr">Brunton and Kutz 2019</xref>):
where <italic toggle="yes">γ</italic> is a scalar corresponding to the magnitude of the noise and <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">E</mml:mi></mml:mrow><mml:mrow><mml:mtext>SND</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is a matrix of values that have a standard normal distribution (SND). We can assume that in our setting this is the case, as majority of real datasets are affected by normally distributed noise, including RNA-Seq GE datasets.</p>
        <disp-formula id="E13">
          <label>(11)</label>
          <mml:math id="M13" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi mathvariant="bold">E</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mo>γ</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mi mathvariant="bold">E</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mtext>SND</mml:mtext>
                </mml:mrow>
              </mml:msub>
              <mml:mo> </mml:mo>
              <mml:mo>,</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <fig position="float" id="btad142-F1">
          <label>Figure 1</label>
          <caption>
            <p>Schema of how cutoff value is determined to find the low-rank matrix</p>
          </caption>
          <graphic xlink:href="btad142f1" position="float"/>
        </fig>
        <p>They have proposed an exact solution for finding the rank <italic toggle="yes">r</italic> for the case where <italic toggle="yes">γ</italic> is not known as follows:
where <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>σ</mml:mo></mml:mrow><mml:mrow><mml:mtext>median</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the median <italic toggle="yes">σ</italic> value of the values on the diagonal of <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Σ</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>=</mml:mo><mml:mi>N</mml:mi><mml:mo>/</mml:mo><mml:mi>J</mml:mi></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mo>ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>β</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the following function:
where:
and <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mo>β</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> is the solution to:
</p>
        <disp-formula id="E14">
          <label>(12)</label>
          <mml:math id="M14" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi>r</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mo>ω</mml:mo>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mo>β</mml:mo>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mo>σ</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:mtext>median</mml:mtext>
                </mml:mrow>
              </mml:msub>
              <mml:mo> </mml:mo>
              <mml:mo>,</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="E15">
          <label>(13)</label>
          <mml:math id="M15" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mo>ω</mml:mo>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mo>β</mml:mo>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mo>λ</mml:mo>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mo>β</mml:mo>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>/</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mo>μ</mml:mo>
                </mml:mrow>
                <mml:mo>β</mml:mo>
              </mml:msub>
              <mml:mo> </mml:mo>
              <mml:mo>,</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="E16">
          <label>(14)</label>
          <mml:math id="M16" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mo>λ</mml:mo>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mo>β</mml:mo>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:msup>
                <mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mn>2</mml:mn>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mo>β</mml:mo>
                        <mml:mo>+</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>+</mml:mo>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mn>8</mml:mn>
                            <mml:mo>β</mml:mo>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mo>β</mml:mo>
                            <mml:mo>+</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo stretchy="false">)</mml:mo>
                            <mml:mo>+</mml:mo>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:msup>
                                    <mml:mrow>
                                      <mml:mo>β</mml:mo>
                                    </mml:mrow>
                                    <mml:mn>2</mml:mn>
                                  </mml:msup>
                                  <mml:mo>+</mml:mo>
                                  <mml:mn>14</mml:mn>
                                  <mml:mo>β</mml:mo>
                                  <mml:mo>+</mml:mo>
                                  <mml:mn>1</mml:mn>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mn>1</mml:mn>
                                <mml:mo>/</mml:mo>
                                <mml:mn>2</mml:mn>
                              </mml:mrow>
                            </mml:msup>
                          </mml:mrow>
                        </mml:mfrac>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mrow>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                  <mml:mo>/</mml:mo>
                  <mml:mn>2</mml:mn>
                </mml:mrow>
              </mml:msup>
              <mml:mo> </mml:mo>
              <mml:mo>,</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <disp-formula id="E17">
          <label>(15)</label>
          <mml:math id="M17" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mrow>
                <mml:msubsup>
                  <mml:mo>∫</mml:mo>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mn>1</mml:mn>
                          <mml:mo>−</mml:mo>
                          <mml:mo>β</mml:mo>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mn>2</mml:mn>
                    </mml:msup>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mo>μ</mml:mo>
                      </mml:mrow>
                      <mml:mo>β</mml:mo>
                    </mml:msub>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo>(</mml:mo>
                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mo>(</mml:mo>
                                  <mml:mrow>
                                    <mml:msup>
                                      <mml:mrow>
                                        <mml:mrow>
                                          <mml:mo stretchy="false">(</mml:mo>
                                          <mml:mn>1</mml:mn>
                                          <mml:mo>+</mml:mo>
                                          <mml:msqrt>
                                            <mml:mo>β</mml:mo>
                                          </mml:msqrt>
                                          <mml:mo stretchy="false">)</mml:mo>
                                        </mml:mrow>
                                      </mml:mrow>
                                      <mml:mn>2</mml:mn>
                                    </mml:msup>
                                    <mml:mo>−</mml:mo>
                                    <mml:mi>t</mml:mi>
                                  </mml:mrow>
                                  <mml:mo>)</mml:mo>
                                </mml:mrow>
                                <mml:mrow>
                                  <mml:mo>(</mml:mo>
                                  <mml:mrow>
                                    <mml:mi>t</mml:mi>
                                    <mml:mo>−</mml:mo>
                                    <mml:msup>
                                      <mml:mrow>
                                        <mml:mrow>
                                          <mml:mo stretchy="false">(</mml:mo>
                                          <mml:mn>1</mml:mn>
                                          <mml:mo>−</mml:mo>
                                          <mml:msqrt>
                                            <mml:mo>β</mml:mo>
                                          </mml:msqrt>
                                          <mml:mo stretchy="false">)</mml:mo>
                                        </mml:mrow>
                                      </mml:mrow>
                                      <mml:mn>2</mml:mn>
                                    </mml:msup>
                                  </mml:mrow>
                                  <mml:mo>)</mml:mo>
                                </mml:mrow>
                              </mml:mrow>
                              <mml:mo>)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>1</mml:mn>
                          <mml:mo>/</mml:mo>
                          <mml:mn>2</mml:mn>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                      <mml:mo>π</mml:mo>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mrow>
              <mml:mi>d</mml:mi>
              <mml:mi>t</mml:mi>
              <mml:mo>=</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>/</mml:mo>
              <mml:mn>2</mml:mn>
              <mml:mo> </mml:mo>
              <mml:mo>.</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p>The benefit of this procedure, which is equivalent to finding the latent dimension of an AE, is that it does not require repeated calculations for all possible values of <italic toggle="yes">r</italic>, as, <italic toggle="yes">r</italic> might theoretically, range from 1 to <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>J</mml:mi><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. It only requires solving <xref rid="E14 E15 E16 E17" ref-type="disp-formula">Equations (12)–(15)</xref>, for which the greatest “challenge” is the fact that the integral in (15) does not have a closed-form solution, but can be successfully and quickly approximated numerically using a Python tool, optht, (<ext-link xlink:href="https://github.com/erichson/optht" ext-link-type="uri">https://github.com/erichson/optht</ext-link>) for calculating the values above and we used it in our implementation.</p>
      </sec>
      <sec>
        <title>2.2.2 Final outlier score calculated by OutSingle</title>
        <p>Similar to the derivation of the <italic toggle="yes">z</italic>-scores in Section 2.1, for OutSingle we assume that the members <italic toggle="yes">e<sub>ji</sub></italic> of <bold>E</bold> follow gene-specific normal distributions and then proceed with deriving <italic toggle="yes">z</italic>-scores <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> analoguous to (4) and (5). We omit the derivation steps for brevity. Our rationale for doing a similar derivation is the fact that both outliers masked by confounding effect and unmasked outliers, if any, will be contained in the <bold>E</bold> matrix, as, by definition, they cannot be a part of the signal matrix <bold>Z</bold>. However, the true outliers will still be outliers with respect to a single gene, as the noise levels in <bold>E</bold> for different genes could be different. Moreover, even a masked outlier is only considered an outlier due to its deviation with respect to a single gene, irrespectively from other genes.</p>
        <p>Finally, in order to obtain a <italic toggle="yes">P</italic>-value score <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that is directly comparable with the <italic toggle="yes">P</italic>-value scores of OUTRIDER and OutPyR(X), we perform the following calculations for every element <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>:
where <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mo>Φ</mml:mo></mml:math></inline-formula> is the cumulative distribution function of SND. Because biological confounding effects cannot be completely eliminated, the expression levels of multiple genes in the same sample are associated. The Benjamini–Yekutieli false discovery rate (FDR) approach (<xref rid="btad142-B3" ref-type="bibr">Benjamini and Yekutieli 2001</xref>), which holds under positive dependency, was used to correct multiple tests.</p>
        <disp-formula id="E18">
          <label>(16)</label>
          <mml:math id="M18" display="block" overflow="scroll">
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mi>p</mml:mi>
                      <mml:mo>^</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mn>2</mml:mn>
              <mml:mo>·</mml:mo>
              <mml:mi>min</mml:mi>
              <mml:mrow>
                <mml:mo>{</mml:mo>
                <mml:mrow/>
              </mml:mrow>
              <mml:mo>Φ</mml:mo>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:msub>
                <mml:mrow>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mi>z</mml:mi>
                      <mml:mo>^</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>,</mml:mo>
              <mml:mrow>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                  <mml:mo>−</mml:mo>
                  <mml:mo>Φ</mml:mo>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:mover accent="true">
                          <mml:mi>z</mml:mi>
                          <mml:mo>^</mml:mo>
                        </mml:mover>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>j</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>}</mml:mo>
              </mml:mrow>
              <mml:mo> </mml:mo>
              <mml:mo>,</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </sec>
    </sec>
    <sec>
      <title>2.3 Injecting artificial outliers by “inverting” the outlier detection procedure</title>
      <p>An added benefit of using log-normal <italic toggle="yes">z</italic>-scores and SVD for outlier detection is that, due to their “invertibility”, they can be used for injecting artificial outliers that are masked by confounding effects. In terms of time complexity, the whole “inverted” procedure is similar to the original procedure.</p>
      <p>We have already shown in (9) and (10) that by using OutSingle it is possible to obtain the low-rank matrix <bold>Z</bold> that contains confounding effects. We can add artificial outliers to it by generating an artificial noise matrix analogous to <bold>E</bold> in which we specify the exact locations of outliers as well as their magnitude. The resulting matrix will be equivalent to the <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> matrix from (6).</p>
      <p>From such new <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> matrix, relying on (5), we can easily obtain new <italic toggle="yes">l<sub>ji</sub></italic> values, and consequently, new <italic toggle="yes">k<sub>ji</sub></italic> values. That way we obtain the final dataset containing all of the artificial outliers masked by confounders.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Datasets</title>
    <p>For the purpose of evaluating performance, we ran our methods and competing methods on 18 datasets that we derived from two base datasets by injecting outliers using the procedure outlined in Section 2.3. The two base datasets are:</p>
    <list list-type="order">
      <list-item>
        <p>Kremer-119, a dataset of transcriptome gene expression counts from skin fibroblast tissues of 119 patients with rare diseases published by <xref rid="btad142-B10" ref-type="bibr">Kremer et al. (2017)</xref>. The patients from that study were suspected of having some rare mitochondrial disorder. Nonexpressed genes were filtered out utilizing the pipeline of <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref>, resulting in retaining 10 556 out of 27 682 genes.</p>
      </list-item>
      <list-item>
        <p>Using <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref> approach for filtering genes, we removed out samples with a low RNA integrity number (&lt; 5.7) from the GTEx dataset. Fragments per kilobase per millions of reads (FPKM) values were obtained with DESeq2 (<xref rid="btad142-B12" ref-type="bibr">Love et al. 2014</xref>) where the gene length was defined as the aggregated length of all the exons. They also filtered out expressed genes, by keeping genes for which at least 5% of the samples had a FPKM value greater than 1 and also discarded genes that had zero counts in more than 75% of the samples.</p>
      </list-item>
      <list-item>
        <p>Murdock-125, a dataset of transcriptome gene expression counts from blood tissues of 125 patients with rare diseases recruited by Baylor College of Medicine clinical Undiagnosed Diseases Network site (UDN) published by <xref rid="btad142-B15" ref-type="bibr">Murdock et al. (2021a</xref>). The majority of patients were in the pediatric age group, and nearly half had a primary neurologic phenotype, consistent with the overall UDN historical proportions.</p>
      </list-item>
    </list>
    <sec>
      <title>3.1 Derived datasets</title>
      <p>Out of every base dataset we created derived datasets by injecting outliers following the procedure described in Section 2.3. Similar to the approach of <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref>, <xref rid="btad142-B18" ref-type="bibr">Salkovic et al. (2020)</xref>, and <xref rid="btad142-B17" ref-type="bibr">Salkovic and Bensmail (2021)</xref>, we created three separate groups of derived datasets: one that had only overexpressed outliers, another one that had only underexpressed outliers and a third group that had both underexpressed and overexpressed outliers in equal proportions using three schemes:</p>
      <list list-type="order">
        <list-item>
          <p>Overexpressed outliers: the derived dataset would contain only injected outliers whose value was greater than the mean/mode of a particular gene.</p>
        </list-item>
        <list-item>
          <p>Underexpressed outliers: outlier value was less than the mean/mode of a particular gene.</p>
        </list-item>
        <list-item>
          <p>Overexpressed and underexpressed outliers: outliers are generated using a ratio of 50%/50%.</p>
        </list-item>
      </list>
      <p>In each of those three groups, we had three derived datasets that had different magnitudes of outliers: 6, 7, and 8. So, in total, we created nine derived datasets for every base dataset. We injected randomly a single outlier in every sample, due to Mendelian disorders being caused by a single gene. The outliers were injected as follows:</p>
      <list list-type="order">
        <list-item>
          <p>an outlier could be injected in any cell of the count matrix, if possible;</p>
        </list-item>
        <list-item>
          <p>frequency of injection was <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
      </list>
      <p>The magnitudes of outliers were different than the ones chosen by <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref> (2, 3, 4, and 6) and <xref rid="btad142-B18" ref-type="bibr">Salkovic et al. (2020)</xref>, <xref rid="btad142-B17" ref-type="bibr">Salkovic and Bensmail (2021)</xref> (2, 3, and 4) because they used a simplistic approach without any consideration for confounding effects. In contrast, with our z-score-based approach, using the well-known order statistic for the SND, it is possible to calculate precisely the expected values of the lowest and highest z-score value in a matrix. Those extreme values are directly related to the number of elements in the matrix <italic toggle="yes">J </italic>×<italic toggle="yes"> N</italic>, and for the datasets we used their magnitude was approximately 5, so we chose 6 as the lowest magnitude of the injected outliers. We did not use magnitudes &gt;8 for brevity as they did not contribute significant added value.</p>
    </sec>
    <sec>
      <title>3.2 Simulated datasets</title>
      <p>To study the performance of OutSingle, we generated a 100-sample synthetic dataset using inferred <italic toggle="yes">p<sub>j</sub></italic> and <italic toggle="yes">r<sub>j</sub></italic> values from the filtered gene subset of the <xref rid="btad142-B10" ref-type="bibr">Kremer et al. (2017)</xref> full dataset (all 119 samples) together with a negative binomial random generator in order to get artificial data that are similar to <xref rid="btad142-B10" ref-type="bibr">Kremer et al. (2017)</xref> data (see Salkovic and Bensmail 2020). As there are no confounder effects in this dataset, even though the number of samples is high (100) OutSingle should be able to compete successfully with the other methods.</p>
    </sec>
    <sec>
      <title>3.3 <italic toggle="yes">P</italic>-value score function</title>
      <p>In order to compare the performance of OutSingle against other methods, we ran both OutSingle and other methods on the aforementioned derived datasets of all base datasets, estimated their model parameters and finally calculated the <italic toggle="yes">P</italic>-values for every count based on those parameters, using functions provided by the methods. Similar to OutSingle’s <italic toggle="yes">P</italic>-values, these <italic toggle="yes">P</italic>-values can be treated as an outlier score: the smaller the <italic toggle="yes">P</italic>-value, the greater an outlier a particular count is for a particular method. Ideally, the smallest <italic toggle="yes">P</italic>-values would correspond directly to actual injected outliers, however, in reality, none of the methods were detecting outliers perfectly. Therefore, to accurately compare the methods against each other, we did not use absolute <italic toggle="yes">P</italic>-values, but we instead ranked <italic toggle="yes">P</italic>-values of each method separately from the smallest to the largest. In that way, the <italic toggle="yes">P</italic>-value ranks were identical between different methods, and thus directly comparable. The method that would have actual injected outliers among the lowest <italic toggle="yes">P</italic>-value ranks would be the best-performing method.</p>
      <p>We have used the FDR <xref rid="btad142-B3" ref-type="bibr">Benjamini and Yekutieli (2001)</xref> which is the expected proportion of erroneous rejections among all rejections. In Multiple testing, regulating the FDR regulates the conventional FEW for which proportion of mistakes is controlled instead when many of the tested hypotheses are rejected to or smaller than 0.05.</p>
    </sec>
    <sec>
      <title>3.4 Alternative control methods</title>
      <p>We compared OutSingle’s performance on the derived datasets against (i) the novel AE-based OUTRIDER model introduced by <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref>, denoted by OUTRIDER-AE; (ii) the alternative model that OUTRIDER supports using PEER (<xref rid="btad142-B19" ref-type="bibr">Stegle et al. 2012</xref>) for confounder control, denoted by OUTRIDER-PEER; and (iii) another alternative model that OUTRIDER supports which uses PCA for confounder control, denoted by OUTRIDER-PCA. For OUTRIDER-AE, autoencoder preprocessing was used to model covariations while PEER and PCA were used to produce loadings in the lower dimension instead of AutoEncoder to produce OUTRIDER-PCA and OUTRIDER-PEER. The design of OUTRIDER-AE, OUTRIDER-PEER and OUTRIDER-PCA was done as suggested by <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref>. For OUTRIDER-AE, AutoEncoder preprocessing was used to model covariations while PEER and PCA were used to produce loadings instead of AE which was used with OUTRIDER and produced OUTRIDER-PCA and OUTRIDER-PEER.</p>
    </sec>
    <sec>
      <title>3.5 Implementation</title>
      <p>The code for OutSingle is implemented in Python using widely available packages. It has been tested on Linux and Windows. Several options can be modified by supplying a settings file. OutSingle can take advantage of multiple cores, following a multi-process approach. It supports progress reporting, trace saving to disk, with recovery if the program is stopped during execution. It uses pre-defined, but easily modifiable, pseudorandom number generator (PRNG) seeds, allowing for experiment reproducibility. In the case of using multiple cores, every (sub)process has its own PRNG, which allows computationally correct sampling. In addition, the full PRNG states for every process are saved along with the trace, providing resilient recovery even in the multi-process setting. If multi-processing is enabled it splits the data according to the desired number of virtual cores/processes, albeit smartly, taking into consideration not only the number of genes but also the sum of counts in each gene. OutSingle is available at <ext-link xlink:href="https://github.com/esalkovic/outsingle" ext-link-type="uri">https://github.com/esalkovic/outsingle</ext-link>.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Results</title>
    <p>In order to accurately assess and compare the performance of all methods, we tested them on datasets that were based on the aforementioned synthetic and real datasets but contained artificially injected outliers.</p>
    <sec>
      <title>4.1 Performance comparison of OutSingle and other relevant models on simulated datasets</title>
      <p>For all datasets derived from the Simulated-100 base dataset, all methods were performing with an AUC-PR value close to 1, i.e. almost perfectly. This confirms our assumption that, provided there are no confounders, OutSingle can match the performance of other methods. Here using <xref rid="btad142-B8" ref-type="bibr">Davis and Goadrich (2006)</xref>, since we are performing models comparison, then it does not matter because to use ROC/AUC or PR/AUPRC. In fact if ROC curve of one classifier is above the ROC curve of another classifier, the same also holds true for the PR curve, and vice versa. In this case, one classifier is better than the other for all thresholds in both the ROC and the PR space, and it usually does not matter whether one uses the ROC curve/AUC or the PR curve/AUPRC for comparing two classifiers.</p>
      <p><xref rid="btad142-F2" ref-type="fig">Figure 2</xref> shows the proportion of simulated outliers among reported outliers (precision) plotted against the proportion of reported simulated outliers among all simulated outliers (recall) for increasing <italic toggle="yes">P</italic>-values up to FDR &lt; 0.05 or decreasing absolute <italic toggle="yes">z</italic>-scores (PCA and PEER). Plots are provided for three simulated amplitudes (by row with simulated absolute <italic toggle="yes">z</italic>-scores of 2, 3, and 4 from top to bottom) and for three simulation scenarios (by column from left to right: aberrantly high and low counts, aberrantly high counts, and aberrantly low counts). The ranking of outliers was bootstrapped to yield 95% confidence bands.</p>
      <fig position="float" id="btad142-F2">
        <label>Figure 2</label>
        <caption>
          <p>The proportion of simulated outliers among reported outliers (precision) plotted against the proportion of reported simulated outliers among all simulated outliers (recall) for the four approaches: Outsingle, Outrider-PEER, Outrider, Outrider-AE and Outrider-PCA</p>
        </caption>
        <graphic xlink:href="btad142f2" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>4.2 Performance comparison of OutSingle and other relevant models on Kremer-115 and Murdock-125 datasets</title>
      <p>To compare different models on our artificially derived datasets, we use the same performance metric as in <xref rid="btad142-B4" ref-type="bibr">Brechtmann et al. (2018)</xref>, <xref rid="btad142-B18" ref-type="bibr">Salkovic et al. (2020)</xref>, and <xref rid="btad142-B17" ref-type="bibr">Salkovic and Bensmail (2021)</xref>, namely the precision-recall (PR) curve and area under (PR) curve (AUC) value (<xref rid="btad142-B8" ref-type="bibr">Davis and Goadrich 2006</xref>). In our setting, precision refers to the ratio of the number of true outliers and the number of outliers as reported by a tool; whereas recall refers to the ratio of the number of true outliers among the reported outliers versus the number of all true outliers. In a single row, we plotted graphs for derived datasets with an identical <italic toggle="yes">z</italic>-score. In a single column we plotted graphs for derived datasets with an identical type of injected outliers: “Over- and Underexpressed” stands for “50% overexpressed outliers and 50% underexpressed outliers”, “Overexpressed” refers to outliers that were 100% overexpressed, and “Underexpressed” refers to outliers that were 100% underexpressed. <xref rid="btad142-F3" ref-type="fig">Figures 3</xref> and <xref rid="btad142-F4" ref-type="fig">4</xref> show how different models performed on all derived datasets (Kremer-115 and Murdock-125) in terms of PR curves. The greater the area under a PR curve, the better its corresponding model is performing. As sometimes PR curves might not give a clear visual clue for which method is performing best.</p>
      <fig position="float" id="btad142-F3">
        <label>Figure 3</label>
        <caption>
          <p>Precision versus recall plots of different methods (with different colors) for datasets derived from the base dataset Kremer-119</p>
        </caption>
        <graphic xlink:href="btad142f3" position="float"/>
      </fig>
      <fig position="float" id="btad142-F4">
        <label>Figure 4</label>
        <caption>
          <p>Precision versus recall plots of different methods (with different colors) for datasets derived from the base dataset Murdock-125</p>
        </caption>
        <graphic xlink:href="btad142f4" position="float"/>
      </fig>
      <p>We then applied OutSingle on experimental data. Quantile–quantile plots for individual genes indicated that OutSingle reasonably modeled the count distribution (<xref rid="btad142-F5" ref-type="fig">Fig. 5</xref>) on the Kremer datasets and that the resulting <italic toggle="yes">P</italic>-values can be used for detecting outliers.</p>
      <fig position="float" id="btad142-F5">
        <label>Figure 5</label>
        <caption>
          <p>Quantile–quantile plot for 20 randomly selected genes from Kremer dataset</p>
        </caption>
        <graphic xlink:href="btad142f5" position="float"/>
      </fig>
      <p>In order to get a precise comparison among different methods we also calculated area under curve (AUC) numerical values for the PR curves of each method and each derived dataset, and grouped such values of all derived datasets of a particular base dataset in a single table. One such table is <xref rid="btad142-T1" ref-type="table">Tables 1</xref> and <xref rid="btad142-T2" ref-type="table">2</xref>, showing AUC-PR values of all methods for all derived nine datasets from the Kremer-119 base dataset and nine datasets from the Murdock-125 base dataset.</p>
      <table-wrap position="float" id="btad142-T1">
        <label>Table 1</label>
        <caption>
          <p>AUC values for the various PR curves from <xref rid="btad142-F3" ref-type="fig">Fig. 3</xref>.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">Over- and Underexpressed</th>
              <th rowspan="1" colspan="1">Overexpressed</th>
              <th rowspan="1" colspan="1">Underexpressed</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">z-score 6</td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OutSingle</td>
              <td rowspan="1" colspan="1">0.3900</td>
              <td rowspan="1" colspan="1">0.4764</td>
              <td rowspan="1" colspan="1">0.5275</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-AE</td>
              <td rowspan="1" colspan="1">0.2126</td>
              <td rowspan="1" colspan="1">0.4620</td>
              <td rowspan="1" colspan="1">0.1589</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PEER</td>
              <td rowspan="1" colspan="1">0.0133</td>
              <td rowspan="1" colspan="1">0.0294</td>
              <td rowspan="1" colspan="1">0.0066</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PCA</td>
              <td rowspan="1" colspan="1">0.2424</td>
              <td rowspan="1" colspan="1">0.5933</td>
              <td rowspan="1" colspan="1">0.0793</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">z-score 7</td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OutSingle</td>
              <td rowspan="1" colspan="1">0.7781</td>
              <td rowspan="1" colspan="1">0.8152</td>
              <td rowspan="1" colspan="1">0.7554</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-AE</td>
              <td rowspan="1" colspan="1">0.4818</td>
              <td rowspan="1" colspan="1">0.6778</td>
              <td rowspan="1" colspan="1">0.4813</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PEER</td>
              <td rowspan="1" colspan="1">0.0226</td>
              <td rowspan="1" colspan="1">0.0508</td>
              <td rowspan="1" colspan="1">0.0102</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PCA</td>
              <td rowspan="1" colspan="1">0.4894</td>
              <td rowspan="1" colspan="1">0.8332</td>
              <td rowspan="1" colspan="1">0.2696</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">z-score 8</td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OutSingle</td>
              <td rowspan="1" colspan="1">0.8882</td>
              <td rowspan="1" colspan="1">0.8813</td>
              <td rowspan="1" colspan="1">0.8630</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-AE</td>
              <td rowspan="1" colspan="1">0.8060</td>
              <td rowspan="1" colspan="1">0.7863</td>
              <td rowspan="1" colspan="1">0.7298</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PEER</td>
              <td rowspan="1" colspan="1">0.0611</td>
              <td rowspan="1" colspan="1">0.1156</td>
              <td rowspan="1" colspan="1">0.0213</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PCA</td>
              <td rowspan="1" colspan="1">0.6775</td>
              <td rowspan="1" colspan="1">0.8677</td>
              <td rowspan="1" colspan="1">0.5650</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <table-wrap position="float" id="btad142-T2">
        <label>Table 2</label>
        <caption>
          <p>AUC values for the various PR curves from <xref rid="btad142-F4" ref-type="fig">Fig. 4</xref>.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">Over- and Underexpressed</th>
              <th rowspan="1" colspan="1">Overexpressed</th>
              <th rowspan="1" colspan="1">Underexpressed</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">z-score 6</td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OutSingle</td>
              <td rowspan="1" colspan="1">0.4465</td>
              <td rowspan="1" colspan="1">0.6506</td>
              <td rowspan="1" colspan="1">0.3035</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-AE</td>
              <td rowspan="1" colspan="1">0.2979</td>
              <td rowspan="1" colspan="1">0.4137</td>
              <td rowspan="1" colspan="1">0.0001</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PEER</td>
              <td rowspan="1" colspan="1">0.0541</td>
              <td rowspan="1" colspan="1">0.0880</td>
              <td rowspan="1" colspan="1">0.0021</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PCA</td>
              <td rowspan="1" colspan="1">0.2876</td>
              <td rowspan="1" colspan="1">0.5236</td>
              <td rowspan="1" colspan="1">0.0028</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <bold>z-score 7</bold>
              </td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OutSingle</td>
              <td rowspan="1" colspan="1">0.6867</td>
              <td rowspan="1" colspan="1">0.8297</td>
              <td rowspan="1" colspan="1">0.4240</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-AE</td>
              <td rowspan="1" colspan="1">0.4466</td>
              <td rowspan="1" colspan="1">0.5755</td>
              <td rowspan="1" colspan="1">0.1669</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PEER</td>
              <td rowspan="1" colspan="1">0.1174</td>
              <td rowspan="1" colspan="1">0.1993</td>
              <td rowspan="1" colspan="1">0.0060</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PCA</td>
              <td rowspan="1" colspan="1">0.4503</td>
              <td rowspan="1" colspan="1">0.6356</td>
              <td rowspan="1" colspan="1">0.0221</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">z-score 8</td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OutSingle</td>
              <td rowspan="1" colspan="1">0.6559</td>
              <td rowspan="1" colspan="1">0.8881</td>
              <td rowspan="1" colspan="1">0.5823</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-AE</td>
              <td rowspan="1" colspan="1">0.4464</td>
              <td rowspan="1" colspan="1">0.5582</td>
              <td rowspan="1" colspan="1">0.4027</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PEER</td>
              <td rowspan="1" colspan="1">0.1727</td>
              <td rowspan="1" colspan="1">0.4156</td>
              <td rowspan="1" colspan="1">0.0153</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> OR-PCA</td>
              <td rowspan="1" colspan="1">0.4920</td>
              <td rowspan="1" colspan="1">0.8416</td>
              <td rowspan="1" colspan="1">0.0815</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>In terms of the model having the lowest rank for the 6th biological outlier, it is undisputedly obtained by OutSingle: 122nd, followed by OUTRIDER-AE: 161st i.e. it performs more than 30% better than the previous state-of-the-art model. While the performance of OUTRIDER-AE, OUTRIDER-PEER, and OUTRIDER-PCA is good in detecting the first five outliers, but the last two approaches detect the 6th biological outlier, i.e. the last one, as the 270th and 280th (rank) candidate outlier, which is almost double the rank of OutSingle (122nd) (see <xref rid="btad142-F6" ref-type="fig">Fig. 6</xref>). Applying OutSingle to the Kremer dataset resulted in a recall of 61 outliers (9.9%) identified by Kremer <italic toggle="yes">et al.</italic> on the basis of the 48 previously undiagnosed samples. Additionally, OutSingle detected 87 new expression outliers, of which 50 were downregulated. All the methods were able to recall all six pathogenic events (three expression outliers, one mono-allelic expression, and two splicing defects) validated by Kremer <italic toggle="yes">et al.</italic> On the Kremer dataset, OUTRIDER-PEER called 3.11 times more outliers than OutSingle, and OUTRIDER-AE called 3.38 more outliers than OutSingle. OUTRIDER-PCA did bad overall (<xref rid="btad142-F7" ref-type="fig">Fig. 7</xref>). These results are consistent with the results from the simulations.</p>
      <fig position="float" id="btad142-F6">
        <label>Figure 6</label>
        <caption>
          <p>Number of aberrant events per sample by gene, colored by method</p>
        </caption>
        <graphic xlink:href="btad142f6" position="float"/>
      </fig>
      <fig position="float" id="btad142-F7">
        <label>Figure 7</label>
        <caption>
          <p>All the methods were able to recall all six pathogenic events validated by Kremer et al. On the Kremer dataset, OUTRIDER-PEER called 3.11 times more outliers than OutSingle, and OUTRIDER-AE called 3.38 more outliers than OutSingle. OUTRIDER-PCA did bad overall</p>
        </caption>
        <graphic xlink:href="btad142f7" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>5 Conclusion</title>
    <p>In this work, we have presented an algorithm we called “OutSingle” which is a contribution to the problem of detecting outliers in RNA-Seq GE dataset in order to help clinicians detect aberrant genes causing rare diseases in patients. Our contribution is an alternative solution to the Bayesian approach that performed well but was slow. Here, we introduced a novel fastway of normalizing RNA-Seq GE data which allowed us to use a much simpler ND approach instead of NB to model the data; and culminating with developing several models for confounder control, with which we have shown that with a rigorous and interpretable statistical approach in modeling the data in the first place, we could then use a straightforward and fast SVD based model for confounder control, improving on previous ad hoc, less interpretable models. Although the end goal of our research was detecting aberrant genes in a rare genetic disorder setting, it is reasonable to believe that our advancements can be utilized in other settings involving RNA-Seq data, such as differential expression analysis. We have shown that our model is able to detect outliers in small number of samples successfully, and even control for confounders, if not fully, at least to a significant extent. Moreover, our approach could be useful for single-cell RNA data as there have already been attempts to model this type of data using a model similar to the NB inference approach such as the recent work of <xref rid="btad142-B7" ref-type="bibr">Dadaneh et al. (2020)</xref>.</p>
  </sec>
</body>
<back>
  <sec>
    <title> </title>
    <p>Financial Support: None declared.</p>
    <p>Conflict of interest: None declared.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad142-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Anders</surname><given-names>S</given-names></string-name>, <string-name><surname>Huber</surname><given-names>W.</given-names></string-name></person-group><article-title>Differential expression analysis for sequence count data</article-title>. <source>Genome Biol</source><year>2010</year>;<volume>11</volume>:<fpage>R106</fpage>.<pub-id pub-id-type="pmid">20979621</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bamshad</surname><given-names>MJ</given-names></string-name>, <string-name><surname>Nickerson</surname><given-names>DA</given-names></string-name>, <string-name><surname>Chong</surname><given-names>JX.</given-names></string-name></person-group><article-title>Mendelian gene discovery: fast and furious with no end in sight</article-title>. <source>Am J Hum Genet</source><year>2019</year>;<volume>105</volume>:<fpage>448</fpage>–<lpage>55</lpage>.<pub-id pub-id-type="pmid">31491408</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Benjamini</surname><given-names>Y</given-names></string-name>, <string-name><surname>Yekutieli</surname><given-names>D.</given-names></string-name></person-group><article-title>The control of the false discovery rate in multiple testing under dependency</article-title>. <source>Ann Stat</source><year>2001</year>;<fpage>1165</fpage>–<lpage>88</lpage>.</mixed-citation>
    </ref>
    <ref id="btad142-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Brechtmann</surname><given-names>F</given-names></string-name>, <string-name><surname>Mertes</surname><given-names>C</given-names></string-name>, <string-name><surname>Matusevičiūtė</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>OUTRIDER: a statistical method for detecting aberrantly expressed genes in RNA sequencing data</article-title>. <source>Am J Hum Genet</source><year>2018</year>;<volume>103</volume>:<fpage>907</fpage>–<lpage>17</lpage>.<pub-id pub-id-type="pmid">30503520</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Brunton</surname><given-names>SL</given-names></string-name>, <string-name><surname>Kutz</surname><given-names>JN.</given-names></string-name></person-group><source>Data-driven Science and Engineering: Machine Learning, Dynamical Systems, and Control</source>. <publisher-name>Cambridge University Press</publisher-name>, <year>2019</year>.</mixed-citation>
    </ref>
    <ref id="btad142-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cummings</surname><given-names>BB</given-names></string-name>, <string-name><surname>Marshall</surname><given-names>JL</given-names></string-name>, <string-name><surname>Tukiainen</surname><given-names>T</given-names></string-name></person-group>, <etal>et al</etal>; <collab>Genotype-Tissue Expression Consortium</collab>. <article-title>Improving genetic diagnosis in Mendelian disease with transcriptome sequencing</article-title>. <source>Sci Transl Med</source><year>2017</year>;<volume>9</volume>(<issue>386</issue>):eaal5209.</mixed-citation>
    </ref>
    <ref id="btad142-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dadaneh</surname><given-names>SZ</given-names></string-name>, <string-name><surname>de Figueiredo</surname><given-names>DP</given-names></string-name>, <string-name><surname>Sze</surname><given-names>S-H</given-names></string-name></person-group><etal>et al</etal><article-title>Bayesian gamma-negative binomial modeling of single-cell RNA sequencing data</article-title>. <source>BMC Genomics</source><year>2020</year>;<volume>21</volume>:<fpage>1</fpage>–<lpage>10</lpage>.</mixed-citation>
    </ref>
    <ref id="btad142-B8">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Davis</surname><given-names>J</given-names></string-name>, <string-name><surname>Goadrich</surname><given-names>M.</given-names></string-name></person-group><source>The Relationship between Precision-Recall and ROC Curves</source>. <publisher-loc>New York, NY, USA</publisher-loc>: <publisher-name>Association for Computing Machinery</publisher-name>, <year>2006</year>.</mixed-citation>
    </ref>
    <ref id="btad142-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gavish</surname><given-names>M</given-names></string-name>, <string-name><surname>Donoho</surname><given-names>DL.</given-names></string-name></person-group><article-title>The optimal hard threshold for singular values is</article-title><inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mn>4</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mn>3</mml:mn></mml:msqrt></mml:mrow></mml:math></inline-formula>. <source>IEEE Trans Inf Theory</source><year>2014</year>;<volume>60</volume>:<fpage>5040</fpage>–<lpage>53</lpage>.</mixed-citation>
    </ref>
    <ref id="btad142-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kremer</surname><given-names>LS</given-names></string-name>, <string-name><surname>Bader</surname><given-names>DM</given-names></string-name>, <string-name><surname>Mertes</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>Genetic diagnosis of Mendelian disorders via RNA sequencing</article-title>. <source>Nat Commun</source><year>2017</year>;<volume>8</volume>:<fpage>15824</fpage>.<pub-id pub-id-type="pmid">28604674</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Law</surname><given-names>CW</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y</given-names></string-name>, <string-name><surname>Shi</surname><given-names>W</given-names></string-name></person-group><etal>et al</etal><article-title>voom: precision weights unlock linear model analysis tools for RNA-seq read counts</article-title>. <source>Genome Biol</source><year>2014</year>;<volume>15</volume>:<fpage>1</fpage>–<lpage>17</lpage>.</mixed-citation>
    </ref>
    <ref id="btad142-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Love</surname><given-names>MI</given-names></string-name>, <string-name><surname>Huber</surname><given-names>W</given-names></string-name>, <string-name><surname>Anders</surname><given-names>S.</given-names></string-name></person-group><article-title>Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2</article-title>. <source>Genome Biol</source><year>2014</year>;<volume>15</volume>:<fpage>550</fpage>.<pub-id pub-id-type="pmid">25516281</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>McCarthy</surname><given-names>DJ</given-names></string-name>, <string-name><surname>Chen</surname><given-names>Y</given-names></string-name>, <string-name><surname>Smyth</surname><given-names>GK.</given-names></string-name></person-group><article-title>Differential expression analysis of multifactor RNA-seq experiments with respect to biological variation</article-title>. <source>Nucleic Acids Res</source><year>2012</year>;<volume>40</volume>:<fpage>4288</fpage>–<lpage>97</lpage>.<pub-id pub-id-type="pmid">22287627</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mertes</surname><given-names>C</given-names></string-name>, <string-name><surname>Scheller</surname><given-names>IF</given-names></string-name>, <string-name><surname>Yépez</surname><given-names>VA</given-names></string-name></person-group><etal>et al</etal><article-title>Detection of aberrant splicing events in RNA-seq data using FRASER</article-title>. <source>Nat Commun</source><year>2021</year>;<volume>12</volume>:<fpage>1</fpage>–<lpage>13</lpage>.<pub-id pub-id-type="pmid">33397941</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Murdock</surname><given-names>DR</given-names></string-name>, <string-name><surname>Dai</surname><given-names>H</given-names></string-name>, <string-name><surname>Burrage</surname><given-names>LC</given-names></string-name></person-group><etal>et al</etal><article-title>Transcriptome-directed analysis for mendelian disease diagnosis overcomes limitations of conventional genomic testing</article-title>. <source>J Clin Investig</source><year>2021</year>;<volume>131</volume></mixed-citation>
    </ref>
    <ref id="btad142-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Robinson</surname><given-names>MD</given-names></string-name>, <string-name><surname>McCarthy</surname><given-names>DJ</given-names></string-name>, <string-name><surname>Smyth</surname><given-names>GK.</given-names></string-name></person-group><article-title>Edger: a bioconductor package for differential expression analysis of digital gene expression data</article-title>. <source>Bioinformatics</source><year>2010</year>;<volume>26</volume>:<fpage>139</fpage>–<lpage>40</lpage>.<pub-id pub-id-type="pmid">19910308</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Salkovic</surname><given-names>E</given-names></string-name>, <string-name><surname>Bensmail</surname><given-names>H.</given-names></string-name></person-group><article-title>A novel Bayesian outlier score based on the negative binomial distribution for detecting aberrantly expressed genes in RNA-Seq gene expression count data</article-title>. <source>IEEE Access</source><year>2021</year>;<volume>9</volume>:<fpage>75789</fpage>.</mixed-citation>
    </ref>
    <ref id="btad142-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Salkovic</surname><given-names>E</given-names></string-name>, <string-name><surname>Hamza</surname><given-names>MM</given-names></string-name>, <string-name><surname>Belhaouari</surname><given-names>SB</given-names></string-name></person-group><etal>et al</etal><article-title>OutPyR: Bayesian inference for RNA-Seq outlier detection</article-title>. <source>J Comput Sci</source><year>2020</year>;<volume>47</volume>:<fpage>101245</fpage>.</mixed-citation>
    </ref>
    <ref id="btad142-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Stegle</surname><given-names>O</given-names></string-name>, <string-name><surname>Parts</surname><given-names>L</given-names></string-name>, <string-name><surname>Piipari</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Using probabilistic estimation of expression residuals (PEER) to obtain increased power and interpretability of gene expression analyses</article-title>. <source>Nat Protoc</source><year>2012</year>;<volume>7</volume>:<fpage>500</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">22343431</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B20">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Stewart</surname><given-names>GW.</given-names></string-name></person-group><year>1998</year>. Perturbation theory for the singular value decomposition. Technical report.</mixed-citation>
    </ref>
    <ref id="btad142-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Turro</surname><given-names>E</given-names></string-name>, <string-name><surname>Astle</surname><given-names>WJ</given-names></string-name>, <string-name><surname>Megy</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Whole-genome sequencing of patients with rare diseases in a national health system</article-title>. <source>Nature</source><year>2020</year>;<volume>583</volume>:<fpage>96</fpage>–<lpage>102</lpage>.<pub-id pub-id-type="pmid">32581362</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Virtanen</surname><given-names>P</given-names></string-name>, <string-name><surname>Gommers</surname><given-names>R</given-names></string-name>, <string-name><surname>Oliphant</surname><given-names>TE</given-names></string-name></person-group><etal>et al</etal>; <collab>SciPy 1.0 Contributors</collab>. <article-title>SciPy 1.0: fundamental algorithms for scientific computing in python</article-title>. <source>Nat Methods</source><year>2020</year>;<volume>17</volume>:<fpage>261</fpage>–<lpage>72</lpage>.<pub-id pub-id-type="pmid">32015543</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wortmann</surname><given-names>SB</given-names></string-name>, <string-name><surname>Koolen</surname><given-names>DA</given-names></string-name>, <string-name><surname>Smeitink</surname><given-names>JA</given-names></string-name></person-group><etal>et al</etal><article-title>Whole exome sequencing of suspected mitochondrial patients in clinical practice</article-title>. <source>J Inherit Metab Dis</source><year>2015</year>;<volume>38</volume>:<fpage>437</fpage>–<lpage>43</lpage>.<pub-id pub-id-type="pmid">25735936</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wu</surname><given-names>H</given-names></string-name>, <string-name><surname>Wang</surname><given-names>C</given-names></string-name>, <string-name><surname>Wu</surname><given-names>Z.</given-names></string-name></person-group><article-title>A new shrinkage estimator for dispersion improves differential expression detection in RNA-seq data</article-title>. <source>Biostatistics</source><year>2013</year>;<volume>14</volume>:<fpage>232</fpage>–<lpage>43</lpage>.<pub-id pub-id-type="pmid">23001152</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yépez</surname><given-names>VA</given-names></string-name>, <string-name><surname>Mertes</surname><given-names>C</given-names></string-name>, <string-name><surname>Müller</surname><given-names>MF</given-names></string-name></person-group><etal>et al</etal><article-title>Detection of aberrant gene expression events in RNA sequencing data</article-title>. <source>Nat Protoc</source><year>2021</year>;<volume>16</volume>:<fpage>1276</fpage>–<lpage>96</lpage>.<pub-id pub-id-type="pmid">33462443</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhou</surname><given-names>M</given-names></string-name>, <string-name><surname>Carin</surname><given-names>L.</given-names></string-name></person-group><article-title>Negative binomial process count and mixture modeling</article-title>. <source>IEEE Trans Pattern Anal Mach Intell</source><year>2015</year>;<volume>37</volume>:<fpage>307</fpage>–<lpage>20</lpage>.<pub-id pub-id-type="pmid">26353243</pub-id></mixed-citation>
    </ref>
    <ref id="btad142-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhu</surname><given-names>A</given-names></string-name>, <string-name><surname>Ibrahim</surname><given-names>JG</given-names></string-name>, <string-name><surname>Love</surname><given-names>MI.</given-names></string-name></person-group><article-title>Heavy-tailed prior distributions for sequence count data: removing the noise and preserving large differences</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>2084</fpage>–<lpage>92</lpage>.<pub-id pub-id-type="pmid">30395178</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
