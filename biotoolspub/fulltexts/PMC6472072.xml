<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genome Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genome Biol</journal-id>
    <journal-title-group>
      <journal-title>Genome Biology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1474-7596</issn>
    <issn pub-type="epub">1474-760X</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6472072</article-id>
    <article-id pub-id-type="publisher-id">1688</article-id>
    <article-id pub-id-type="doi">10.1186/s13059-019-1688-1</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Bazam: a rapid method for read extraction and realignment of high-throughput sequencing data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Sadedin</surname>
          <given-names>Simon P.</given-names>
        </name>
        <address>
          <email>simon.sadedin@mcri.edu.au</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-9788-5690</contrib-id>
        <name>
          <surname>Oshlack</surname>
          <given-names>Alicia</given-names>
        </name>
        <address>
          <email>alicia.oshlack@mcri.edu.au</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 0614 0346</institution-id><institution-id institution-id-type="GRID">grid.416107.5</institution-id><institution>Bioinformatics, Murdoch Children’s Research Institute, </institution><institution>Royal Children’s Hospital, </institution></institution-wrap>Flemington Road, Parkville, Victoria 3052 Australia </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 0614 0346</institution-id><institution-id institution-id-type="GRID">grid.416107.5</institution-id><institution>Victorian Clinical Genetics Services, </institution><institution>Royal Children’s Hospital, </institution></institution-wrap>Flemington Road, Parkville, Victoria 3052 Australia </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2179 088X</institution-id><institution-id institution-id-type="GRID">grid.1008.9</institution-id><institution>Department of BioScience, </institution><institution>University of Melbourne, </institution></institution-wrap>Parkville, 3050 Australia </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>18</day>
      <month>4</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>18</day>
      <month>4</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>78</elocation-id>
    <history>
      <date date-type="received">
        <day>23</day>
        <month>10</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>4</day>
        <month>4</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s). 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p id="Par1">The vast quantities of short-read sequencing data being generated are often exchanged and stored as aligned reads. However, aligned data becomes outdated as new reference genomes and alignment methods become available. Here we describe Bazam, a tool that efficiently extracts the original paired FASTQ from alignment files (BAM or CRAM format) in a format that directly allows efficient realignment. Bazam facilitates up to a 90% reduction in the time for realignment compared to standard methods. Bazam can support selective extraction of read pairs from focused genomic regions for applications such as targeted region analyses, quality control, structural variant calling, and alignment comparisons.</p>
      <sec>
        <title>Electronic supplementary material</title>
        <p>The online version of this article (10.1186/s13059-019-1688-1) contains supplementary material, which is available to authorized users.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100000925</institution-id>
            <institution>National Health and Medical Research Council</institution>
          </institution-wrap>
        </funding-source>
        <award-id>APP1126157</award-id>
        <principal-award-recipient>
          <name>
            <surname>Oshlack</surname>
            <given-names>Alicia</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p id="Par2">The wide-scale adoption of high-throughput genomic sequencing instruments over the last 10 years has generated vast quantities of genomic data with enormous potential for future use. Genomic data is often stored and exchanged as aligned reads in a coordinate-sorted BAM or CRAM format. This format is common because many applications (such as viewing the alignment or routine variant calling) can utilize it directly. Storage in aligned form, however, has the significant disadvantage that the data is tied to the reference genome and alignment method used. Many results are highly sensitive to these parameters, and combined data sets typically cannot be analyzed together at all unless these parameters are identical. Consequently, to make optimal use of data, users often need to realign the data to a recent genome build and reference. This is resulting in a widespread and growing need for the capability to efficiently realign genomic data.</p>
    <p id="Par3">Realignment of paired reads from aligned data is however both computationally expensive and inconvenient using standard methods. The challenges arise because aligners must access both reads of a pair simultaneously in order to optimally align them. While both reads are usually stored in an alignment file, in a coordinate-sorted file a significant fraction may be distant from each other. In these cases, an expensive random lookup is necessary to read the mate information so that both reads of the pair can be written to the output together. Consequently, the standard practice for realignment involves first extracting all the reads, and then sorting them by read name on disk prior to realignment. While this makes extraction feasible, the process is lengthy and requires substantial resources due to the intermediate steps. Interestingly, Picard Tools [<xref ref-type="bibr" rid="CR1">1</xref>] offers an alternative method to extract read pairs, in the form of SamToFastq, which avoids the need for these intermediate steps in extracting read pairs. However, this method is not widely used in the community. This is likely because SamToFastq is poorly optimized for memory use, making it impractical for use with large data sets. Additionally, Picard Tools cannot target a specific locus and can only emit a single output stream, causing the process to be bottlenecked by the maximum throughput of a single downstream process (such as alignment). Biobambam [<xref ref-type="bibr" rid="CR2">2</xref>] is another tool that addresses a similar purpose. Biobambam uses a specialized algorithm and data structure to reduce its memory requirements and increase efficiency, but ultimately relies on storing reads on disk when the number of pending reads to be paired exceeds a threshold. Biobambam also does not offer advanced features such as fully flexible read filtering and is limited to output through a single instance of the aligner.</p>
    <p id="Par4">Here we introduce Bazam, an alternative to SamToFastq that optimizes memory use, while offering increased parallelism and other additional features. Bazam increases parallelism by splitting the output streams into multiple paths for separate realignment (Fig. <xref rid="Fig1" ref-type="fig">1</xref>). Using this technique, a single-source alignment can be realigned using an unlimited number of parallel aligners, significantly accelerating the process when a computational cluster or cloud computing resource is available.<fig id="Fig1"><label>Fig. 1</label><caption><p>Different configurations for using Bazam. <bold>a</bold> Simple realignment from one reference genome to another without intermediate storage or steps. <bold>b</bold> Extraction of filtered reads such as those overlapping a specific locus. Reads can be streamed to downstream tools directly, or stored in FASTQ format for further processing. <bold>c</bold> Sharded realignment allows for many copies of the aligner to run on different subsets of the data, greatly speeding up realignment</p></caption><graphic xlink:href="13059_2019_1688_Fig1_HTML" id="MO1"/></fig></p>
    <p id="Par5">While realignment is a key application, Bazam also offers utility for any other application relying on detailed read pair information. Example applications include quality control and structural variant calling. Bazam offers two additional features of particular interest: read position tagging and localized extraction. Read position tagging renames reads as they are streamed to include the original alignment position in the name of each read. This feature allows ready comparison between new and old alignment positions after realignment. Localized extraction allows realignment to be limited to reads overlapping specified genomic coordinates. Like realignment, this can be achieved using standard tools. However, these tools do not emit both reads of a pair if only one overlaps a region of interest, and are therefore unsuitable for applications that require both of the reads.</p>
    <p id="Par6">Here we describe the implementation of Bazam and demonstrate that it increases efficiency without compromising accuracy.</p>
  </sec>
  <sec id="Sec2">
    <title>Results</title>
    <sec id="Sec3">
      <title>Bazam design</title>
      <sec id="Sec4">
        <title>Pairing of reads</title>
        <p id="Par7">The primary challenge in extracting paired reads from BAM and CRAM files arises from the predominant choice of coordinate-sorted ordering for their storage. This format is used because it places all the reads aligned to a given genomic locus in close physical proximity within the file, maximizing efficiency for any analysis focused on short-range variation (such as SNV and indel calling, or visualization in genome browsers). However, coordinate ordering is highly suboptimal for realignment, because a small but significant fraction of reads are located to a large genomic distance from their mate. Consequently, a simple linear scan cannot readily extract both a read and its mate in many cases. One possibility is to retrieve each mate as needed using a random seek within the file to the location of its mate. This strategy is highly inefficient, however, because reads are stored within BAM and CRAM files in a block format such that extracting a single read requires decoding some or all of the other reads from the same block. In practice, such a random seek strategy slows down read extraction by several orders of magnitude.</p>
        <p id="Par8">Bazam retains the efficient linear scan of standard methods. However, instead of performing random lookup of each mate, Bazam stores each read in memory until the mate is encountered naturally. For the majority of pairs, both reads derive from the same biological fragment, which is typically closely matched to the reference genome and therefore a short distance on the genome. In these cases, the mate for a read is encountered soon after the read itself, so that the first read needs to be only briefly stored in memory. Reads aligned at a greater distance from their mate must be buffered for significantly longer. Consequently, Bazam requires enough memory to run such that it can store these reads until their mates are encountered by the linear scan. To reduce the memory load, Bazam does not store the full read data structure in memory when the desired output is in FASTQ format. Instead, Bazam stores only data essential to the FASTQ output. Bazam additionally encodes the in-memory reads to compress the data and reduce memory load.</p>
        <p id="Par9">The worst-case scenario is represented by a small proportion of reads where the mate aligns to a different reference contig (or chromosome). These reads may represent real structural variation within the sample, but can also be generated artefactually in the preparation of sequencing libraries. In these cases, the mate does not resolve at all until its chromosome is encountered by the linear scan. Accordingly, Bazam requires enough memory to store this small proportion of reads for the full duration of the extraction.</p>
        <p id="Par10">By buffering reads, Bazam trades memory for speed. The peak memory required depends on the coverage depth of the alignment, the typical span between paired reads (the insert size distribution) and also on the number of reads whose mates align to different contigs. We observe on typical human whole genome data sequenced at 30× mean coverage depth, that Bazam requires approximately 16–32 GB of RAM. For cancer genomes or other scenarios with many genomic rearrangements, this could potentially increase. However, for many common scenarios, the memory requirement of Bazam remains well within the limitations of the resources available in most modern computing systems.</p>
      </sec>
      <sec id="Sec5">
        <title>Parallelism and sharding</title>
        <p id="Par11">As computational performance is one of the main goals of Bazam, it is designed with a high level of parallelism internally so that system input/output (I/O) is never blocked. This is achieved by using separate threads for reading the input alignment file, writing the output, and a pool of threads to index and buffer each read so that it can be paired with its mate. To further ensure that performance of Bazam can be scaled, read pairs can be split into multiple streams, which is referred to as “sharding.” In sharded mode, several copies of Bazam are run, with each copy emitting a different subset of the reads. Bazam utilizes the unique read name assigned to each read pair to ensure that the output streams receive mutually exclusive subsets. Specifically, the name of each read is used to generate a hash code and the modulus of this hash code with the total number of shards is used to decide whether a read is processed by a given Bazam instance. Many copies of Bazam can then run on the same alignment file simultaneously, with each one outputting a unique read subset. This arrangement both reduces the peak memory load and increases parallelism, as each shard can be streamed into different instance of the aligner. With a computational cluster or cloud computing facilities, almost unlimited parallelism is achievable with this method. Sharding can also be utilized to downsample data to lower coverage, by omitting one or more output streams from alignment.</p>
      </sec>
      <sec id="Sec6">
        <title>Output shuffling</title>
        <p id="Par12">In our testing of Bazam, we observed that, on some data sets, use of Bazam could cause significant inflation in memory usage of the downstream aligner software, BWA. This issue was also observed using other tools such as Biobambam. Investigation showed that the memory inflation was linked to the order of the reads and that randomizing the order eliminated the memory inflation. Bazam therefore implements a feature to shuffle extracted reads before writing them to the output. This requires a buffer of reads to be held in memory, increasing Bazam’s memory requirement. However, we find that in some data sets, the increase in usage by Bazam is more than offset by a greater decrease in memory usage by BWA. This effect was not observed in other aligner software that we tested, such as Bowtie2 [<xref ref-type="bibr" rid="CR3">3</xref>].</p>
      </sec>
      <sec id="Sec7">
        <title>Memory usage</title>
        <p id="Par13">To reduce memory use, Bazam compresses reads while they are stored for pairing or shuffling. Bazam includes several optional compression methods. The default mechanism uses a 4-bit encoding for bases and the compression library Snappy [<xref ref-type="bibr" rid="CR4">4</xref>] to encode quality scores. Although 2-bit encoding was considered for bases (allowing 4 possible values), the need to encode possible <italic>N</italic> bases in the reads required at least a 3-bit encoding to store the 5 values. To align these with 8-bit byte boundaries, 2 bases are stored per byte. A future extension could improve this scheme by using 3 bits per base, thereby storing 4 bases in 12 bytes. In our testing, Snappy compression reduces the memory needed to store quality scores to approximately 60% of the original size. Therefore, the overall compression is approximately 55% of the raw size. As a further memory optimization, Bazam scans the BAM index to determine the number of reads aligned to each reference contig. If the mate for a read is aligned to a contig for which no reads are present in the index, Bazam avoids buffering the read in memory. While such reads should not theoretically be present in well-formed BAM files, in practice we have found that BAM files are often filtered using mechanisms that leave such reads in place, resulting in a high memory burden if stored in memory for the duration of the processing.</p>
      </sec>
    </sec>
    <sec id="Sec8">
      <title>Efficiency of realignment on whole genome sequencing</title>
      <p id="Par14">To test the efficiency of Bazam, we applied it to a public whole genome data set (NA12878, 30× mean coverage) released as part of the Genome in a Bottle project [<xref ref-type="bibr" rid="CR5">5</xref>]. First, we realigned the data set from GRCh37 to GRCh38 using both Bazam and using the standard approach without Bazam. The standard approach consists of first sorting reads using samtools bamshuf (<ext-link ext-link-type="uri" xlink:href="http://www.htslib.org/">http://www.htslib.org/</ext-link>), then extracting them using samtools bam2fq, and finally realigning using BWA mem [<xref ref-type="bibr" rid="CR6">6</xref>] and re-sorting the output BAM file using samtools sort. To avoid directly storing intermediate files, this process was constructed using Unix pipes. However, we note that the intermediate sorting stages still write files, resulting in substantial temporary storage requirements. We refer to this process as Sort-Extract-Realign (SER). In this process, we used 16 cores in total as we observed empirically that on our test systems, relatively little improvement in performance was gained by adding additional cores. Picard SamToFastq was run using 32 GB of RAM and given 16 processor cores. However, in this configuration, it failed to complete as it exceeded the allocated memory early in the process. When increased memory was given, anomalies within the data set caused it to abort the process. To enable its performance to be measured, the problematic line in the Picard source code was removed, and the tool was recompiled, which enabled it to complete the processing. The Bazam process consisted of Bazam directly streaming reads into BWA mem, followed by re-sorting with samtools sort.</p>
      <p id="Par15">When using a single instance of BWA, Bazam took similar overall time but reduced the storage required by 75.9% compared to the Sort-Extract-Realign process. In this case, processing time was limited primarily by the speed of alignment rather than Bazam’s ability to pair reads. When run in sharded mode, however, Bazam was able to split reads between 10 copies of BWA, resulting in a time saving of 91%, while still reducing the storage needed by 63.8% (Table <xref rid="Tab1" ref-type="table">1</xref>).<table-wrap id="Tab1"><label>Table 1</label><caption><p>Comparison of run time, memory, and storage space between Bazam and alternative processes for realignment. Timings encompass the end to end process starting from read extraction and ending with completion of realigned and sorted BAM files</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Tool</th><th>Storage used</th><th>Memory</th><th>Effective Cores</th><th>Time</th></tr></thead><tbody><tr><td>Sort-Extract-Realign</td><td>282 GB</td><td>20 GB</td><td>16</td><td>13 h, 15 min</td></tr><tr><td>Picard SamToFastq</td><td>148 GB</td><td>78 GB</td><td>16</td><td>16 h, 14 min</td></tr><tr><td>Biobambam bamtofastq</td><td>149 GB</td><td>30 GB</td><td>16</td><td>15 h 30 min</td></tr><tr><td>Bazam (no sharding)</td><td>68 GB</td><td>28 GB</td><td>16</td><td>14 h, 55 min</td></tr><tr><td>Bazam 10-way sharding</td><td>102 GB</td><td>20 GB</td><td>160</td><td>1 h, 11 min</td></tr></tbody></table></table-wrap></p>
      <p id="Par16">The total memory used during the non-sharded Bazam realignment peaked at 28 GB. This memory can be broken down into the following: memory used to store reads while they are being paired, memory used by other parts of Bazam, and memory used by BWA. We observed that the peak total memory used by all the Bazam components was approximately 14 GB, with read storage for pairing accounting for approximately 5.4 GB. Much of the remainder is accounted for by large input and output buffers, and internal queuing of data used to ensure high performance. The components outside of Bazam, including BWA and samtools sort, peaked at 14 GB (50%) of memory.</p>
    </sec>
    <sec id="Sec9">
      <title>Accuracy of realignment</title>
      <p id="Par17">We tested the fidelity of Bazam’s read extraction process by comparing Bazam’s output to the expected output using two different methods. First, we converted all reads from the evaluation data set to FASTQ format using the SER method. Then, we aligned these reads to GRCh37 using BWA mem and re-extracted to FASTQ format using Bazam. Comparison of the two FASTQ data sets found that reads were identical, showing that Bazam reproduces FASTQ with perfect fidelity.</p>
      <p id="Par18">To investigate any unexpected effects resulting from realignment with Bazam, we first realigned the SER-extracted FASTQ to GRCh37, to create an updated alignment using our local alignment configuration. Next, we realigned this updated alignment, with Bazam. These steps ensured that both alignments with and without Bazam used identical reference genomes and aligner settings, so that these factors did not cause artefactual differences.</p>
      <p id="Par19">We then compared the alignments with each other, by applying Bazam’s read position tagging feature. The feature alters read names during realignment to carry the original alignment position. In this way, reads in the new alignment could be readily checked against their old position to identify reads that “moved.”</p>
      <p id="Par20">The comparison between the Bazam and updated realignments revealed a total of 13.7 m (1.7%) reads that changed position after Bazam realignment. We hypothesized based on previous studies [<xref ref-type="bibr" rid="CR7">7</xref>] that this may be caused by ambiguously positioned reads aligning differently due to altered input order. Consistent with this hypothesis, we identified that of the repositioned reads, 92.8% had mapping quality of 30 or less, suggesting their alignments are subject to significant ambiguity. We investigated the moved reads that had high mapping quality and observed that many of the these were mapped to repeat masker regions (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table S1) and in many cases were in fact subject to ambiguity despite receiving high mapping quality from BWA. Based on these results, we concluded that Bazam realignment has a minimal effect on reads with unambiguous mapping positions, and while reads with ambiguous positions may be repositioned, this is likely due to known behavior of BWA, rather than Bazam itself.</p>
    </sec>
    <sec id="Sec10">
      <title>Application to repeat expansion calling</title>
      <p id="Par21">As an example of Bazam’s utility for aiding downstream analysis tools such as complex variant calling, we applied Bazam to STRetch [<xref ref-type="bibr" rid="CR8">8</xref>], a method for detection of short tandem repeat expansions (STRs) in genomic data. The first step in STRetch selects reads aligning to more than 400,000 known STR repeat regions (as well as any unmapped reads) and then realigns these reads to artificial decoy sequences containing short tandem repeats. When run on pre-aligned data, STRetch extracts all reads within 800 bp of each known STR region. This window is chosen to be wide enough to capture both reads of the majority of pairs that fall into the STR region. Nonetheless, some pairs are mapped widely enough apart that they may be missed. We replaced this implementation with Bazam’s local extraction feature and tested the accuracy and efficiency.</p>
      <p id="Par22">When run using the default read extraction method on the same whole genome sample, STRetch took 6 h and 7 min. The unsharded Bazam method reduced the time required to 2 h and 27 min. This improvement is achieved partly by avoiding intermediate FASTQ extraction, but also by eliminating the additional window required for scanning of candidate STR reads. Bazam makes the expanded window unnecessary because it guarantees to output both reads of a pair, even if only one overlaps the extraction window, demonstrating the utility of the localized extraction feature. When run using sharded mode with six copies of BWA, STRetch finished in 1 h and 24 min. STRetch primarily derives its sensitivity from its ability to align reads from STR regions to the decoy sequences. Hence, we compared STRetch performance between Bazam and standard alignment methods by counting the reads that were aligned to each decoy sequence. We found that Bazam was able to align 3.4% more reads to the decoy sequences than the standard alignment process. Therefore, we conclude that alignment using Bazam increases both speed and accuracy in the case of STRetch.</p>
    </sec>
    <sec id="Sec11">
      <title>Wider applications</title>
      <p id="Par23">While we have primarily developed Bazam with realignment in mind, any application where paired reads are needed can benefit. In particular, we note that many algorithms for complex and structural variant calling are highly dependent on read pair information and hence could benefit from building on this method. Quality control statistics derived from read pair information can also be calculated more efficiently using Bazam than standard methods. Finally, the ability to tag read names with previous alignment information is also useful for benchmarking and comparing alignment software.</p>
    </sec>
  </sec>
  <sec id="Sec12">
    <title>Conclusion</title>
    <p id="Par24">Bazam offers a simple, yet effective, tool that enables a significant increase in efficiency and decrease in time required to realign existing genomic data. This has widespread practical utility, as the need to reprocess data onto new genome builds with updated alignment software is becoming increasingly prevalent. Bazam also has many other potential uses for applications where full read pair information is needed, especially where extraction from localized regions of the genome is of interest. Bazam is open source software and is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/ssadedin/bazam">https://github.com/ssadedin/bazam</ext-link>.</p>
  </sec>
  <sec id="Sec13">
    <title>Methods</title>
    <sec id="Sec14">
      <title>Software implementation</title>
      <p id="Par25">Bazam is implemented using Groovy, a modern language derived from Java and which shares most properties with Java including platform independence and very high performance. Bazam uses HTSJDK (<ext-link ext-link-type="uri" xlink:href="https://github.com/samtools/htsjdk">https://github.com/samtools/htsjdk</ext-link>) for the underlying BAM and CRAM parsing operations. To enable high concurrency, Bazam employs actor-based concurrency based on the GPars framework (<ext-link ext-link-type="uri" xlink:href="http://www.gpars.org/">http://www.gpars.org/</ext-link>).</p>
      <p id="Par26">Source code for Bazam used in producing the results presented is available at 10.5281/zenodo.2590831 and is freely available under the Lesser General Public License (LGPL). Methods can be found at <ext-link ext-link-type="uri" xlink:href="https://gitlab.com/ssadedin/bazam-paper-methods">https://gitlab.com/ssadedin/bazam-paper-methods</ext-link>.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Additional file</title>
    <sec id="Sec15">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="13059_2019_1688_MOESM1_ESM.docx">
            <label>Additional file 1:</label>
            <caption>
              <p><bold>Table S1.</bold> Additional details of the methods, data sources and statistics regarding realignment of reads. (DOCX 21 kb)</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>We wish to thank Cas Simons for the helpful discussions about workflows and comments on the manuscript. We wish to thank Harriet Dashnow for comments and explanations regarding STRetch output and software.</p>
    <sec id="FPar1">
      <title>Funding</title>
      <p id="Par27">This work was made possible through the Victorian State Government Operational Infrastructure Support and Australian Government NHMRC IRIISS. This work was supported by the National Health and Medical Research Council, Australia (Career Development Fellowship) APP1126157 to AO.</p>
    </sec>
    <sec id="FPar2" sec-type="data-availability">
      <title>Availability of data and materials</title>
      <p id="Par28">The data used in this study is a single whole genome sequencing data set from the Genome in the Bottle project found at <ext-link ext-link-type="uri" xlink:href="ftp://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/data/NA12878/NIST_NA12878_HG001_HiSeq_300x/RMNISTHS_30xdownsample.bam">ftp://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/data/NA12878/NIST_NA12878_HG001_HiSeq_300x/RMNISTHS_30xdownsample.bam</ext-link>. The realignment scripts to generate Table <xref rid="Tab1" ref-type="table">1</xref> can be found at <ext-link ext-link-type="uri" xlink:href="https://gitlab.com/ssadedin/bazam-paper-methods">https://gitlab.com/ssadedin/bazam-paper-methods</ext-link> [<xref ref-type="bibr" rid="CR9">9</xref>] and is under the MIT license. Source code for Bazam used in producing the results presented is available at 10.5281/zenodo.2590831 and is freely available under the Lesser General Public License (LGPL) [<xref ref-type="bibr" rid="CR10">10</xref>]. This analysis was run on the high-performance compute cluster at the Murdoch Children’s Research Institute, consisting of a Torque system with 16 nodes having 32–48 cores and 256 GB of RAM each. Resources were allocated to jobs on the cluster as described in Table <xref rid="Tab1" ref-type="table">1</xref>. Analyses were conducted with BWA version 0.7.17-r1188, samtools 1.8, and Picard-Tools 2.2.1.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>SS conceived of and implemented the method, performed the simulation work, and drafted the manuscript. AO advised on the design and implementation and interpretation of results and edited the manuscript. Both authors read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="COI-statement">
    <sec id="FPar3">
      <title>Ethics approval and consent to participate</title>
      <p>Not applicable.</p>
    </sec>
    <sec id="FPar4">
      <title>Consent for publication</title>
      <p>Not applicable</p>
    </sec>
    <sec id="FPar5">
      <title>Competing interests</title>
      <p>The authors declare that they have no competing interests.</p>
    </sec>
    <sec id="FPar6">
      <title>Publisher’s Note</title>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </sec>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <mixed-citation publication-type="other">Picard: A set of Java command line tools for manipulating high-throughput sequencing data (HTS) data and formats. <ext-link ext-link-type="uri" xlink:href="http://broadinstitute.github.io/picard">http://broadinstitute.github.io/picard</ext-link>. Accessed 12 Mar 2019.</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Tischler</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Leonard</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <source>Biobambam : tools for read pair collation based algorithms on BAM files arXiv : 1306 . 0836v1 [ q-bio . GN ] 4 Jun 2013</source>
        <year>2014</year>
        <fpage>1</fpage>
        <lpage>17</lpage>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Fast gapped-read alignment with Bowtie 2</article-title>
        <source>Nat Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <fpage>357</fpage>
        <lpage>359</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1923</pub-id>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <mixed-citation publication-type="other">Google/snappy - a fast compressor/decompressor. <ext-link ext-link-type="uri" xlink:href="https://github.com/google/snappy">https://github.com/google/snappy</ext-link>. Accessed 12 Mar 2019.</mixed-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zook</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Chapman</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Mittelman</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Hofmann</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Hide</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Salit</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Integrating human sequence data sets provides a resource of benchmark SNP and indel genotype calls</article-title>
        <source>Nat Biotechnol</source>
        <year>2014</year>
        <volume>32</volume>
        <fpage>246</fpage>
        <lpage>251</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.2835</pub-id>
        <pub-id pub-id-type="pmid">24531798</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Firtina</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Alkan</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>On genomic repeats and reproducibility</article-title>
        <source>Bioinformatics</source>
        <year>2016</year>
        <volume>32</volume>
        <fpage>2243</fpage>
        <lpage>2247</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btw139</pub-id>
        <pub-id pub-id-type="pmid">27153582</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dashnow</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Lek</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Phipson</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Halman</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Lamont</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Clayton</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Laing</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>MacArthur</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Oshlack</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>STRetch: detecting and discovering pathogenic short tandem repeats expansions</article-title>
        <source>Genome Biol</source>
        <year>2018</year>
        <volume>19</volume>
        <issue>1</issue>
        <fpage>121</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-018-1505-2</pub-id>
        <pub-id pub-id-type="pmid">30129428</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <mixed-citation publication-type="other">Sadedin S, Oshlack A. Bazam: a rapid method for read extraction and realignment of high-throughput sequencing data. Gitlab. 2019. <ext-link ext-link-type="uri" xlink:href="https://gitlab.com/ssadedin/bazam-paper-methods">https://gitlab.com/ssadedin/bazam-paper-methods</ext-link>. Accessed 12 Mar 2019.</mixed-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <mixed-citation publication-type="other">Sadedin S, Oshlack A. Bazam: a rapid method for read extraction and realignment of high-throughput sequencing data. zenodo. 2019. 10.5281/zenodo.2590831. Accessed 12 Mar 2019.</mixed-citation>
    </ref>
  </ref-list>
</back>
