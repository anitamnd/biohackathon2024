<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5998871</article-id>
    <article-id pub-id-type="pmid">29745832</article-id>
    <article-id pub-id-type="publisher-id">2071</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-018-2071-z</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>cmFSM: a scalable CPU-MIC coordinated drug-finding tool by frequent subgraph mining</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Yang</surname>
          <given-names>Shunyun</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Guo</surname>
          <given-names>Runxin</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Liu</surname>
          <given-names>Rui</given-names>
        </name>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Liao</surname>
          <given-names>Xiangke</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Zou</surname>
          <given-names>Quan</given-names>
        </name>
        <address>
          <email>zouquan@nclab.net</email>
        </address>
        <xref ref-type="aff" rid="Aff4">4</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Shi</surname>
          <given-names>Benyun</given-names>
        </name>
        <address>
          <email>benyunshi@outlook.com</email>
        </address>
        <xref ref-type="aff" rid="Aff5">5</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Peng</surname>
          <given-names>Shaoliang</given-names>
        </name>
        <address>
          <email>pengshaoliang@nudt.edu.cn</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="GRID">grid.67293.39</institution-id><institution>College of Computer Science and Electronic Engineering &amp; National Supercomputer Centre in Changsha, </institution><institution>Hunan University, </institution></institution-wrap>Changsha, 410082 China </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0000 9548 2110</institution-id><institution-id institution-id-type="GRID">grid.412110.7</institution-id><institution>School of Computer Science, </institution><institution>National University of Defense Technology, </institution></institution-wrap>Changsha, 410073 China </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1803 0208</institution-id><institution-id institution-id-type="GRID">grid.452708.c</institution-id><institution>Department of Oncology, </institution><institution>The Second Xiangya Hospital of Central South University, </institution></institution-wrap>Changsha, 410011 China </aff>
      <aff id="Aff4"><label>4</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1761 2484</institution-id><institution-id institution-id-type="GRID">grid.33763.32</institution-id><institution>School of Computer Science and Technology, </institution><institution>Tianjin University, </institution></institution-wrap>Tianjin, 300072 China </aff>
      <aff id="Aff5"><label>5</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0000 9804 6672</institution-id><institution-id institution-id-type="GRID">grid.411963.8</institution-id><institution>School of Cyberspace, </institution><institution>Hangzhou Dianzi University, </institution></institution-wrap>Hangzhou, 310018 China </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>8</day>
      <month>5</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>8</day>
      <month>5</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2018</year>
    </pub-date>
    <volume>19</volume>
    <issue>Suppl 4</issue>
    <issue-sponsor>Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. The articles have undergone the journal's standard peer review process for supplements. The Supplement Editors declare that they have no competing interests.</issue-sponsor>
    <elocation-id>98</elocation-id>
    <permissions>
      <copyright-statement>© The Author(s). 2018</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">Frequent subgraphs mining is a significant problem in many practical domains. The solution of this kind of problem can particularly used in some large-scale drug molecular or biological libraries to help us find drugs or core biological structures rapidly and predict toxicity of some unknown compounds. The main challenge is its efficiency, as (i) it is computationally intensive to test for graph isomorphisms, and (ii) the graph collection to be mined and mining results can be very large. Existing solutions often require days to derive mining results from biological networks even with relative low support threshold. Also, the whole mining results always cannot be stored in single node memory.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">In this paper, we implement a parallel acceleration tool for classical frequent subgraph mining algorithm called cmFSM. The core idea is to employ parallel techniques to parallelize extension tasks, so as to reduce computation time. On the other hand, we employ multi-node strategy to solve the problem of memory constraints. The parallel optimization of cmFSM is carried out on three different levels, including the fine-grained OpenMP parallelization on single node, multi-node multi-process parallel acceleration and CPU-MIC collaborated parallel optimization.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">Evaluation results show that cmFSM clearly outperforms the existing state-of-the-art miners even if we only hold a few parallel computing resources. It means that cmFSM provides a practical solution to frequent subgraph mining problem with huge number of mining results. Specifically, our solution is up to one order of magnitude faster than the best CPU-based approach on single node and presents a promising scalability of massive mining tasks in multi-node scenario. More source code are available at:Source Code: <ext-link ext-link-type="uri" xlink:href="https://github.com/ysycloud/cmFSM">https://github.com/ysycloud/cmFSM</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Frequent subgraph mining</kwd>
      <kwd>Bioinformatics</kwd>
      <kwd>Memory constraints</kwd>
      <kwd>Isomorphism</kwd>
      <kwd>Many integrated Core (MIC)</kwd>
    </kwd-group>
    <conference xlink:href="http://apbc2018.bio.keio.ac.jp/">
      <conf-name>The Sixteenth Asia Pacific Bioinformatics Conference</conf-name>
      <conf-acronym>APBC 2018</conf-acronym>
      <conf-loc>Yokohama, Japan</conf-loc>
      <conf-date>15-17 January 2018</conf-date>
    </conference>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2018</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <sec id="Sec2">
      <title>Frequent subgraphs mining</title>
      <p id="Par7">Frequent subgraphs mining in a collection of graph objects is a very difficult challenge, especially in the important application area “Bioinformatics” where it can help finding new drugs in pharmacological compound databases or core functional structures in biological networks. Subgraph mining problem is difficult to solve because arbitrary graph structures must be generated and matched. As isomorphism testing is a hard problem [<xref ref-type="bibr" rid="CR1">1</xref>], subgraph miners are exponential in memory consumption and execution time.</p>
      <p id="Par8">Lin [<xref ref-type="bibr" rid="CR2">2</xref>] have summarized that the problem of frequent subgraph mining mainly consists of two categories: (i) frequent subgraph patterns ought to be found in different regions of one large graph of massive scale; (ii) frequent subgraph patterns should be found within a large-scale collection of middle-sized graphs. The first case is usually adapted to social network domain, and the second case is usually adapted to the areas of computational pharmacology and bioinformatics. Both categories share several common challenges. For example, large data input size with relative low support threshold can lead to huge number of mining results, which may exceed the memory of a single machine, and require vast amounts of runtime. Given these characteristics, parallel techniques are presented as a promising solution to solve these challenges.</p>
      <p id="Par9">The objective of this problem is to find subgraphs that occur with support higher than a threshold <italic>θ</italic>, i.e., 0 ≪ <italic>θ</italic> ≪ 1. Several solutions have been put up with for the first case in either serial CPU-based techniques [<xref ref-type="bibr" rid="CR3">3</xref>–<xref ref-type="bibr" rid="CR5">5</xref>] or parallel computing (MapReduce, MPI, Spark) framework [<xref ref-type="bibr" rid="CR6">6</xref>–<xref ref-type="bibr" rid="CR9">9</xref>] and GPU [<xref ref-type="bibr" rid="CR10">10</xref>]. However, we mainly focus on the second case, which is more practical in the field of bioinformatics and known as transaction setting [<xref ref-type="bibr" rid="CR11">11</xref>].</p>
    </sec>
    <sec id="Sec3">
      <title>Related work</title>
      <p id="Par10">In the transaction scenario, miner/frequent subgraph mining algorithm recursively generates all possible refinement extensions from empty graph by adding edges and nodes to already generated refinements. Then, isomorphism test will be performed of each new possible refinement to determine if it appears frequently. Early miner/frequent subgraph mining algorithms generated refinements in a Breadth First Search (BFS) way, e.g., AGM [<xref ref-type="bibr" rid="CR12">12</xref>], and FSG [<xref ref-type="bibr" rid="CR13">13</xref>]. However, the Depth First Search (DFS) approaches need less memory and almost show better performance. [<xref ref-type="bibr" rid="CR14">14</xref>] have summarized three main subproblems (i.e. Purposive refinement Efficient enumeration and Focused isomorphism testing) have to be solved of efficient miners and made a quantitative and detailed comparison of some typical dfs-algorithms, e.g., MoFa [<xref ref-type="bibr" rid="CR15">15</xref>], FFSM [<xref ref-type="bibr" rid="CR16">16</xref>], gSpan [<xref ref-type="bibr" rid="CR17">17</xref>] and Gaston [<xref ref-type="bibr" rid="CR18">18</xref>], and some special extensions of them, e.g., CloseGraph [<xref ref-type="bibr" rid="CR19">19</xref>], showing them attacking the three subproblems quite differently. Thus, the dfs-algorithms will be mainly used for comparative analysis with our work. A follow-up work [<xref ref-type="bibr" rid="CR20">20</xref>] is more focus on accelerating the mining process.</p>
      <p id="Par11">All solutions discussed above are single-core serial version. When they come to large-scale mining problems, they may be difficult to meet time requirement. To solve this problem, SUBDUE [<xref ref-type="bibr" rid="CR21">21</xref>] develops a shared-memory parallel approach by using the minimum description length (MDL) principle and embodies in the SUBDUE system. Further, [<xref ref-type="bibr" rid="CR22">22</xref>] proposes parallel mining strategy in a multi-core system and partitions the mining tasks among multiple shared-memory processors. To some extent, these studies make full use of the machine resources on single node to accelerate the mining process.</p>
      <p id="Par12">Another problem is all these approaches are memory-based, and assume that the collection, intermediate data and mining results fit in memory. However, as data size increases and especially support threshold decreases (the scale of mining results grows exponentially), the assumption no longer reach. To address this limitation, some disk-based solutions have been proposed, e. g. ADI-Mine [<xref ref-type="bibr" rid="CR23">23</xref>]. However, these approaches face significant overhead of accessing the data. The same as a disk-based solution, PGM [<xref ref-type="bibr" rid="CR24">24</xref>] propose a data partition approach.</p>
      <p id="Par13">The work in IFSM [<xref ref-type="bibr" rid="CR11">11</xref>] is relatively early to employ MapReduce [<xref ref-type="bibr" rid="CR25">25</xref>] framework for mining frequent subgraphs. Specifically, it first determines local support for all possible single-edge subgraphs by mapping a part of the graph collection to each worker. Secondly, a reduction phase will determine the global support for each subgraph, and discard those candidates that do not reach the global support threshold. The solution continues to deal with the double-edge subgraphs, triple-edge subgraphs and so on. Similar with IFSM [<xref ref-type="bibr" rid="CR11">11</xref>], FSM-H [<xref ref-type="bibr" rid="CR26">26</xref>] and mrFSM [<xref ref-type="bibr" rid="CR27">27</xref>] are also developed on MapReduce framework by an iterative method. Relatively, [<xref ref-type="bibr" rid="CR27">27</xref>] pay more attention to the load balancing in each iteration. However, because MapReduce is not suitable for iterative computing, which may result in a lot of IO and serialization overhead, these approaches on MapReduce still create significant performance problem.</p>
      <p id="Par14">The more outstanding work so far on MapReduce framework is MRFSM [<xref ref-type="bibr" rid="CR28">28</xref>]. It does not adopt iterative method, but the whole process is divided into two MapReduce stages: filter and refinement. The filter stage prunes based on the probability of support and outputs local frequent subgraphs in the local dataset which is divided to each machine. The refinement phase intelligently translates the local support which is gotten from the filter phase into a global support to integrate the final results. Because there are no iterations, it presents a better performance than IFSM [<xref ref-type="bibr" rid="CR11">11</xref>], FSM-H [<xref ref-type="bibr" rid="CR26">26</xref>] and mrFSM [<xref ref-type="bibr" rid="CR27">27</xref>]. However, the implementation code of MRFSM is not purely native java program, most program is coding by C++, and then use Hadoop Streaming to adapt to MapReduce framework to complete distributed mining. As a result, the performance of the MRFSM will be severely restricted because of limited data exchange capacity using standard I/O and redundant data type conversions. Moreover, when the support threshold is low enough, the massive mining results tend to far exceed the single-machine memory. In this respect, because the refinement stage distributes all candidate subgraphs to all machines, this stage can easily cause severe memory pressure on each machine when a large number of candidate subgraphs cannot be filtered due to the low support threshold. Thus, MRFSM [<xref ref-type="bibr" rid="CR28">28</xref>] may not be able to cope with scenarios with massive mining results due to low support threshold.</p>
      <p id="Par15">In contrast, our tool is implemented by native C++ program with several efficient parallel techniques, e.g., MPI and OpenMP, to maximize performance. Also, every node will not hold all candidate subgraphs but carry out its own mining process to get local final results so as to easily handle the scenarios with massive mining results.</p>
    </sec>
  </sec>
  <sec id="Sec4">
    <title>Methods</title>
    <p id="Par16">cmFSM realizes parallelism of multiple levels and multiple granularities and utilizes MIC as accelerator. Multi-threading is implemented using OpenMP aimed at hotspots of mining process. Four kinds of static task dividing strategy and a supervisor-based dynamic task dividing strategy are implemented by MPI to achieve best load balancing. Further, we used MICs in offload mode only to transfer double-edge frequent subgraphs and back up complex data structures redundantly to avoid the bottlenecks caused by excessive transmission. By making full use of the multi-core computing capacity of MIC, we can achieve a desired effect of execution speed in the scenario of CPU and MIC collaboration.</p>
    <sec id="Sec5">
      <title>OpenMP parallelization on single node</title>
      <p id="Par17">
        <list list-type="order">
          <list-item>
            <p id="Par18">The strategy of parallelization</p>
          </list-item>
        </list>
      </p>
      <p id="Par19">The general dfs-algorithm of frequent subgraph mining uses a recursive approach to deal with the hotspot of mining process, which is very difficult to control the parallel granularity. Also, a simple function call can continuously find out a large number of mining results because we cannot pick out or predict the depth of recursive process. This is bound to lead to load unbalance among different mining tasks.</p>
      <p id="Par20">In order to solve this problem to achieve better effect of parallelization by OpenMP, we adopt a fine-grained parallel strategy. Specifically, we translate the common recursive mining process into a BFS loop mining process by one-edge growth of several layers, so as to implement the parallelization on the granularity of one-edge growth. The operation consists of two specific parts: (i) judgment of minimum DFS code and (ii) right-most extension. Overall, the computing scale of this operation is not too small, so that there is no possibility that most CPU resources is used in thread scheduling because the parallel granularity is not big enough. At the same time, the tasks of the two parts are specific and similar so as to easily achieve a good load balancing by dynamic scheduling strategy of OpenMP. Moreover, there is no need of system to help us manage the stack because recursive processes are replaced by loops, which may lead to additional acceleration.</p>
      <p id="Par21">Take gSpan [<xref ref-type="bibr" rid="CR15">15</xref>] as an example, the following pseudocode compares original Algorithm 1 with new parallel Algorithm 2.</p>
      <graphic position="anchor" xlink:href="12859_2018_2071_Figa_HTML" id="MO1"/>
      <p id="Par22">As the pseudocode shown above, in order to complete the parallelization, we apply for four new categories of buffer: children, tchildren, lchildren, cchildren. The children are used to record the set of subgraphs obtained from each level extension where the subgraphs in same level have same number of edges. When children is not empty, the next level mining process will be carried out. It is a global variable and will be used sequentially. The tchildren is a local variable within single-thread tasks, recording the subgraphs obtained from one-edge growth of each subgraph. The lchildren is also a local variable within single-thread tasks, but it is a summary of the results of all one-edge growths for each thread and gotten from the union of tchildren in every iteration. The cchildren also records the set of subgraphs obtained from each level extension. At the end of single-thread tasks, the lchildren will be summarized to cchildren in the critical area. Also, the cchildren and children will be exchanged out of the parallel area in order to carry out the next level iterative mining. It is worth noting that the meaning of the existence of cchildren is that we cannot directly summarize lchildren to children, because at the parallel computing scenario we cannot make sure all extension tasks in every thread are over at the same time. The thread not yet complete tasks will continue to use the data of children, which may lead to failures.<list list-type="simple"><list-item><label>2)</label><p id="Par23">2) Memory Management Deep Optimization</p></list-item></list></p>
      <p id="Par24">The main challenge of frequent subgraph mining is the memory constraint. In order to achieve the purpose of memory reuse and the efficient utilization of memory space, we adopt the strategy named “apply dynamically &amp; store pointers”. Specifically, when the subgraph is extended, the program applies edges dynamically and stores edge pointers rather than actual edge objects in the graph code structure, so that the new frequent graphs share most edges with their ancestors, which will lead to a significant saving in memory space. The schematic diagram is shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref>. It can be easily seen that only the edge pointers are stored in the graph code and each edge has only one instance in memory, so as to achieve the purpose of memory reuse.<fig id="Fig1"><label>Fig. 1</label><caption><p>Memory Reuse. The left side shows the frequent subgraph extension process in the form of graph code. The upper right subfigure is the original subgraph. Below it lists the codes of each edge and their corresponding pointers</p></caption><graphic xlink:href="12859_2018_2071_Fig1_HTML" id="MO2"/></fig></p>
    </sec>
    <sec id="Sec6">
      <title>Multi-node multi-process parallel acceleration</title>
      <p id="Par25">
        <list list-type="order">
          <list-item>
            <p id="Par26">The strategies of task division</p>
          </list-item>
        </list>
      </p>
      <p id="Par27">The biggest challenge of multi-node program is the communication overhead. To solve this problem, a coarse-grained parallel strategy is used among processes through dividing single-edge frequent subgraphs by MPI. The main tasks of each process are completely independent to avoid a large amount of communication overhead, and then each processes will write out its corresponding results in its own node to avoid the single-node memory pressure causing by massive mining results. We should notice that all output files can be easily merged to form the whole results. Further, combining with the multi-thread work on single node, our implementation allows to generate a second level of parallelization by creating multiple threads per MPI process to achieve a good performance.</p>
      <p id="Par28">However, this coarse-grained strategy is not conducive to load balancing, which is easily lead to data tilt and cannot make full use of system resources to achieve the best performance. Therefore, we design and provide four kinds of static task dividing (i.e. equality, single, increment, circle) strategies and a supervisor-based dynamic task dividing strategy based on different characteristics of datasets to achieve load balancing as much as possible.<list list-type="alpha-lower"><list-item><p id="Par29">static division___equality</p></list-item></list></p>
      <p id="Par30">A simple strategy is to divide the single-edge frequent subgraphs equally. However, we found that the load is extremely unbalanced after the experiment, and it is easy to achieve bottlenecks. Also, a lot of mining tasks are concentrated on the front of the nodes, and they will also pick out most results. This is because these single-edge frequent subgraphs will be sorted in descending order in the pretreatment stage. The more front they sorted, the more frequent they are and also the more frequent subgraphs they may pick out. And those sorted behind will be closer to the support threshold, they may no longer a frequent subgraph after one-edge growth even one time, so that they may pick out a little results and stop tasks early. Moreover, we find that the scale of results is decreased exponentially as the pretreatment order. Therefore, this intuitive strategy in most cases are difficult to achieve load balancing.<list list-type="simple"><list-item><label>b)</label><p id="Par31">static division___increment</p></list-item></list></p>
      <p id="Par32">In order to solve the problem of equal division, we propose an incremental task allocation strategy. Specifically, the first node gets only one graph, the second node gets two graphs, the third node gets three graphs, and so on, and the last node gets all remaining graphs. Implementation of this strategy actually improves the performance and achieve a better load balancing.<list list-type="simple"><list-item><label>c)</label><p id="Par33">static division___single</p></list-item></list></p>
      <p id="Par34">Actually, when the dataset is big enough, although the tasks of single-edge subgraphs ranking behind will drastically reduce, the gap among the tasks of top-ranked single-edge subgraphs is not obvious. In this case, incremental strategy will lead the relative top nodes to undertake more tasks, so that the load is still not balance. For this scenario, we proposed a single task allocation strategy, in which we assign all preceding nodes only one single-edge frequent subgraph, and the remaining subgraphs are allocated to the last node. This strategy sometimes can achieve a better performance.<list list-type="simple"><list-item><label>d)</label><p id="Par35">static division___circle</p></list-item></list></p>
      <p id="Par36">Considering the single strategy may make a large number of tasks focused on the last node when the dataset is big enough but the degree of parallelism is not particularly high, we proposed a circle task allocation strategy, in which we first allocate all nodes a round of single-edge subgraphs in turn, and then we allocate all nodes a round of graphs in reverse order, and then we allocate all nodes a round of graphs in turn again, and so on until all single-edge frequent subgraphs are allocated to their corresponding nodes. This strategy is expected in most cases to achieve better load balancing.<list list-type="simple"><list-item><label>e)</label><p id="Par37">dynamic division___supervisor-based</p></list-item></list></p>
      <p id="Par38">In fact, because the mining process is very complex and it is difficult for us to predict or measure the scale of tasks, these static task division strategies certainly cannot adapt to all practical scenarios. A more ideal method is to use dynamic division strategy based on task queue, in which we first allocate a round of single-edge subgraphs in turn to all nodes, and then one of the remaining graphs will be allocated to the node that finishes tasks earliest to carry out mining process until the end of all tasks. In theory, this strategy can always achieve a better load balancing compare to static division strategies.</p>
      <p id="Par39">In order to implement this dynamic strategy, we treat process0 as a supervisor, which manages all tasks uniformly. When other processes finish their current tasks, they first ask process0 for a remaining single-edge frequent subgraph. The process0 will search its task queue and reply to them. When the task queue is not empty, the process0 will allocate a new single-edge frequent subgraph to other processes, otherwise, it replies − 1 and counts. When the count reaches the number of process, the process0 will end its work. On the other hand, when other processes receive − 1 once, they will also end their work.</p>
      <p id="Par40">The Fig. <xref rid="Fig2" ref-type="fig">2</xref> shows an example of five division strategies. The dynamic strategy can always achieve a better load balancing than static strategies, but the overall performance is not necessarily more optimal because of other operations such as request, wait, communication and synchronization. Thus, users can choose all these strategies. However, in most cases it is recommended to adopt dynamic strategy.<fig id="Fig2"><label>Fig. 2</label><caption><p>Different kinds of task dividing strategies. Note that the equality division is not absolute, but each process holds the number of single-edge frequent subgraphs will be the same or keep the difference that no more than one. At the same time, the example of dynamic division in this figure shows only a possible result which is not necessary in this case</p></caption><graphic xlink:href="12859_2018_2071_Fig2_HTML" id="MO3"/></fig><list list-type="simple"><list-item><label>2)</label><p id="Par41">Remove multi-node redundant results</p></list-item></list></p>
      <p id="Par42">Another problem in multi-node scenario is the redundant results. From Algorithm 1, it is not difficult to find that the original single-edge frequent subgraph must be deleted after its extension tasks. This is to avoid to consider the high-frequency single-edge subgraphs which have been used in the following mining process, which may lead to redundant results. This possibility can result in some difficulties in multi-node scenario. Because each process can only handle its own single-edge frequent subgraphs in current mining process, the high-frequency single-edge subgraphs in other nodes which should not be considered will not be deleted.</p>
      <p id="Par43">We extend the parallel algorithm to multi-node scenario and show it in the following Algorithm 3.</p>
      <p id="Par44">In order to extend the parallel algorithm, we notice that the single-edge subgraphs which are allocated to every node are also be handled in turn. This characteristic make it possible for us to remove high-frequency single-edge subgraphs which priori to current object before the mining process.</p>
      <graphic position="anchor" xlink:href="12859_2018_2071_Figb_HTML" id="MO4"/>
    </sec>
    <sec id="Sec7">
      <title>CPU-MIC collaborated parallel optimization</title>
      <p id="Par45">
        <list list-type="order">
          <list-item>
            <p id="Par46">Collaborated Parallelization of cmFSM</p>
          </list-item>
        </list>
      </p>
      <p id="Par47">The collaboration among CPUs and MICs we employ a medium-grained parallel strategy. In detail, we divide the double-edge frequent subgraphs among CPUs and MICs, which are gotten from one-edge growth of initial single-edge frequent subgraphs in every process. Also, we adopt offload mode to transfer double-edge frequent subgraphs from host to MICs. By tolerating appropriate communication overhead and making full use of the multi-core computing capacity of MIC, we can achieve a desired effect of load balancing and computing speed.</p>
      <p id="Par48">The Fig. <xref rid="Fig3" ref-type="fig">3</xref> shows interactive process between CPU and MIC to achieve the ideal collaboration. It is worth noting that the coarse-grained strategy is not used because it is difficult to effectively reach load balancing under this strategy. Also, the single-edge frequent subgraphs are allocated to each process are not definitely able to be divided reasonably. For example, only one single-edge frequent subgraph may be allocated to some processes in many cases. Coupled with the truth that there is a difference of computing capacity between CPU and MIC, load balancing will be a great challenge. On the other hand, the fine-grained strategy also should not be considered, because it is not shared memory between CPU and MIC. There must be a huge scale of communication overhead to transfer and divide the graphs by offload mode. Thus, this strategy is also not conducive to improve the overall performance.<fig id="Fig3"><label>Fig. 3</label><caption><p>Framework of CPU/MIC collaboration. There are mainly three stages of MIC process: (i) Data loading and pretreatment (ii) Iterative mining process and (iii) Output the results. All these tasks are collaborated with CPU at the same time. Moreover, at the end of each stage, the two devices will synchronize their tasks to ensure the correctness and efficiency of the program</p></caption><graphic xlink:href="12859_2018_2071_Fig3_HTML" id="MO5"/></fig><list list-type="simple"><list-item><label>2)</label><p id="Par49">Memory Reuse</p></list-item></list></p>
      <p id="Par50">The memory of one MIC card is approximately 5 Gigabytes, which cannot be matched to the general node memory. Also, the speed of memory allocation and release is still slower than CPU. Experimental tests show that allocating 1 Gigabyte of memory on MIC takes approximately 5 s. Therefore, you must reduce the frequency of memory allocation and release on MIC and maximize possibility of memory reuse.</p>
      <p id="Par51">In addition to the usage of “apply dynamically &amp; store pointers” strategy we introduced before, cmFSM reduces the memory allocation time on MIC by memory reuse. We create a counter JobCount to record the job number. If count = 1, it uses “alloc_if(1) free_if(0)” to allocate memory for the array and object listed in the offload segment. When count &gt; 1, it employs “alloc_if(0) free_if(0)” to reuse the memory. Until the last time, it adopts “alloc_if(0) free_if(1)” to release the memory after the operation is completed. By this way, we can minimize the frequency of memory allocation and release on MIC.</p>
      <p id="Par52">On the other hand, when the dataset is relatively large and the mining process is deep enough, even if a whole extension process of one single-edge frequent subgraph can use up the memory on MIC. In this scenario, it is not suitable to transfer all the data to be mined once and then mining their results. Therefore, instead of uploading all the double-edge frequent graphs at one time, we adopt an iterative method to upload only a part of the graphs obtained from the same single-edge frequent graph at one time to facilitate data compression and save the memory space on MIC, which can be clearly seen from Fig. <xref rid="Fig3" ref-type="fig">3</xref>.<list list-type="simple"><list-item><label>3)</label><p id="Par53">Data Transmission Optimization</p></list-item></list></p>
      <p id="Par54">Although the C++ STL container and class is supported by MIC, the ICC compiler does not support the use of offload mode to transfer these structures. It can only support the basic datatype and array without pointers. Thus, we adopt the strategy named “dismantle &amp; restore” to transfer the objects. The Fig. <xref rid="Fig4" ref-type="fig">4</xref> shows the format of n double-edge frequent subgraphs that are supposed to be transfered in an iteration.<fig id="Fig4"><label>Fig. 4</label><caption><p>Data structure used in offload mode. The format of n double-edge frequent subgraphs that are supposed to be transfered in an iteration</p></caption><graphic xlink:href="12859_2018_2071_Fig4_HTML" id="MO6"/></fig></p>
      <p id="Par55">We first dismantle these objects and integrate their elements to make those of same kind are stored in the same successive buffer. Then, we transfer these buffers to MIC by offload mode and allocate memory of original objects on MIC. Finally, we restore these objects on MIC by filling corresponding elements from these buffers. This is no doubt a troublesome process, but fortunately we only need to transfer some double-edge frequent subgraphs with the same first edge in an iteration according to the above idea.</p>
      <p id="Par56">From the Fig. <xref rid="Fig4" ref-type="fig">4</xref>, we can find that there are seven buffers are used in transmission process. Because the format of edge code is a quintuple (ix, iy, x, a, y), the first five buffers are used to transfer edges. The elements with subscript 0 represent the first common edge. The following n elements represent the second edges of every subgraph. The next buffer represents the number of nodes of n subgraphs. The gs buffer is the numbered lists of original graphs where this subgraph appeared in dataset. Because the number begins from 0, we simply employ − 1 to separate these lists. From this formation, we can organize and transfer data between CPU and MIC efficiently.</p>
      <p id="Par57">On the other hand, some complex data structures will be used in the whole mining process, such as original graph set after the pretreatment, which may lead to unbearable transmission overhead and memory allocation overhead. Therefore, we back up complex data structures redundantly which are reusable and difficult to transfer to maximize performance. In detail, at the beginning we only transfer the analytical parameters to MIC, the coprocessor can read data and construct graph set by itself based on these parameters, which is not the hotspot of calculation and can be quickly completed on the MIC. Also, in many cases the mining results is too big to transfer by offload mode. Thus, at the end, instead of returning all mining results to CPU, we only return the count of results to show the overall consequence on CPU. Specific mining results will be directly written on MIC. These files can be easily merged to get the whole results. The two stages are clearly illustrated in Fig. <xref rid="Fig3" ref-type="fig">3</xref>.<list list-type="simple"><list-item><label>4)</label><p id="Par58">Load balancing and data division among CPU/MICs</p></list-item></list></p>
      <p id="Par59">According to the previous strategy, only the double-edge frequent subgraphs obtained from the one-edge growth of the same single-edge frequent graph will be transferred to MIC in an iteration. If the process continues to mine from this layer, the scale of calculation is supposed to be greatly closer than from single-edge subgraphs. Considering the computing capacities of CPU and MIC are still close in our environment after tests, we simply adopt a static strategy using interval division and make the host device with slightly stronger calculation ability start first, which is because the front double-edge subgraphs theoretically still have more potential to extend, to achieve an efficient load balancing among CPUs and MICs.</p>
      <p id="Par60">The data division and CPU/MIC collaborating mining process in an iteration is shown in the Fig. <xref rid="Fig5" ref-type="fig">5</xref>. Taking into account the truth that there are three MICs on single node of Tianhe-2, we take three MICs as an example in Fig. <xref rid="Fig5" ref-type="fig">5</xref>. Multiple CPUs in single node share memory, we can manage their computing resources uniformly and call them Host. The method of interval division can be clearly seen from Fig. <xref rid="Fig5" ref-type="fig">5</xref>. At the same time, the mining depth or scale of calculation on each device cannot be sure, but all their processes will end until there are no more new frequent subgraphs after one-edge growths. In the multi-node scenario, we just allocate every node different single-edge frequent subgraphs to form different task queues. There are no more other differences.<fig id="Fig5"><label>Fig. 5</label><caption><p>Data division among CPU/MICs and Mining Schematic. The data division and CPU/MIC collaborating mining process in an iteration</p></caption><graphic xlink:href="12859_2018_2071_Fig5_HTML" id="MO7"/></fig></p>
    </sec>
  </sec>
  <sec id="Sec8">
    <title>Results</title>
    <p id="Par61">We have evaluated the performance of cmFSM under five aspects: (i) parallelization on single node, (ii) multi-node division strategy, (iii) efficiency of multi-node multi-thread acceleration, (iv) CPU/MIC collaboration and (v) multi-node CPU/MIC collaboration.</p>
    <sec id="Sec9">
      <title>Setup and dataset</title>
      <p id="Par62">The cmFSM was implemented in C++ using the STL and compiled with the –O2 compilation flag. The first experiment is performed on a high performance server which consists of 8 Xeon E7–8800 v3 18 core CPU processors with 2 Xeon Phi 3120 57 core coprocessors and 2 K40 M GPU. It has a 2 TB memory in total and the operation system is Red Hat Enterprise Linux Server release 7.1. The next four experiments are performed on the Tianhe-2 supercomputer. The configuration is listed in the following Table <xref rid="Tab1" ref-type="table">1</xref>.<table-wrap id="Tab1"><label>Table 1</label><caption><p>Tianhe-2 supercomputer Configuration</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Hardware</th><th>Index</th></tr></thead><tbody><tr><td>Node number</td><td>16,000</td></tr><tr><td>Computing node</td><td>2 Xeon E5 CPUs and 3 Xeon Phi coprocessors</td></tr><tr><td>CPU memory</td><td>64 GB</td></tr><tr><td>Xeon Phi memory</td><td>8 GB</td></tr><tr><td>Communication system</td><td>High-speed interconnection network</td></tr><tr><td>File system</td><td>Lustre file system</td></tr><tr><td>Operating system</td><td>Kylin 2.6.32–431.TH.x86_64</td></tr></tbody></table></table-wrap></p>
      <p id="Par63">A comprehensive performance study was conducted in our experiments on both real molecular and synthetic datasets. The first real dataset we tested is the Predictive Toxicology dataset (PTE). It is sparse and contains 340 chemical compounds, 24 different atoms, 66 atom types, and 4 types of bonds. We use the type of atoms and bonds as labels. The second real dataset is the AIDS antiviral screen compound dataset from Developmental Therapeutics Program in NCI/NIH. It contains 43,905 chemical compounds. The results of the screening tests can be categorized into three classes: CA: confirmed active; CM: confirmed moderately active; and CI: confirmed inactive. We only use CA class in our tests which consists of 422 molecules (dataset DTP).</p>
      <p id="Par64">The synthetic graph dataset is using a synthetic data generator similar to that described in [<xref ref-type="bibr" rid="CR12">12</xref>]. A user can set parameters to decide the number of graphs and their average size. We generate three datasets (S1, S2 and S3) for our tests, which consist of 10,000 graphs, 20,000 graphs and 100,000 graphs respectively. More information of these four datasets in shown in Table <xref rid="Tab2" ref-type="table">2</xref>.<table-wrap id="Tab2"><label>Table 2</label><caption><p>Dataset information</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Dataset</th><th>Molecules Or Graphs</th><th>Average #edges</th><th>Largest #edges</th><th>Average #vertices</th><th>Largest #vertices</th></tr></thead><tbody><tr><td>PTE</td><td>340</td><td>28</td><td>214</td><td>27</td><td>214</td></tr><tr><td>DTP</td><td>422</td><td>42</td><td>196</td><td>40</td><td>188</td></tr><tr><td>S1</td><td>10,000</td><td>29</td><td>276</td><td>26</td><td>225</td></tr><tr><td>S2</td><td>20,000</td><td>32</td><td>214</td><td>30</td><td>197</td></tr><tr><td>S3</td><td>100,000</td><td>45</td><td>321</td><td>38</td><td>278</td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec id="Sec10">
      <title>Parallelization on single node</title>
      <p id="Par65">We try to compare our tool with a wide range of functionally comparable frequent structure miners, such as FSM [<xref ref-type="bibr" rid="CR12">12</xref>], FFSM [<xref ref-type="bibr" rid="CR14">14</xref>], gSpan [<xref ref-type="bibr" rid="CR15">15</xref>] and Gaston [<xref ref-type="bibr" rid="CR17">17</xref>]. We should note that some of these miners had restrictions regarding the number of labels or were restricted to molecular database. For these algorithm we only publish limited results.</p>
      <p id="Par66">In this part, we have used first three datasets for analysis to show that cmFSM can easily present a better performance than any other famous miners in a relatively low level of parallelization. Table <xref rid="Tab3" ref-type="table">3</xref> compares results and runtimes among cmFSM and other miners on PTE dataset.<table-wrap id="Tab3"><label>Table 3</label><caption><p>Results for PTE dataset</p></caption><table frame="hsides" rules="groups"><thead><tr><th>MinSup %</th><th>2</th><th>4</th><th>6</th><th>8</th><th>10</th><th>20</th><th>30</th></tr></thead><tbody><tr><td>MinSup Abs</td><td>7</td><td>14</td><td>20</td><td>27</td><td>34</td><td>68</td><td>102</td></tr><tr><td>Freq graphs</td><td>136,949</td><td>5935</td><td>2326</td><td>1323</td><td>844</td><td>190</td><td>68</td></tr><tr><td colspan="8">Runtime in Seconds</td></tr><tr><td> FSM</td><td>312.21</td><td>11.22</td><td>4.12</td><td>2.51</td><td>1.69</td><td>0.66</td><td>0.31</td></tr><tr><td> FFSM</td><td>78.12</td><td>5.21</td><td>2.01</td><td>1.03</td><td>0.75</td><td>0.58</td><td>0.29</td></tr><tr><td> gSpan</td><td>101.12</td><td>7.21</td><td>2.31</td><td>1.21</td><td>0.83</td><td>0.65</td><td>0.33</td></tr><tr><td> Gaston</td><td>36.53</td><td>2.13</td><td>1.01</td><td>0.66</td><td>0.38</td><td>0.12</td><td>0.06</td></tr><tr><td> cmFSM</td><td>97.32</td><td>3.28</td><td>1.25</td><td>0.71</td><td>0.49</td><td>0.15</td><td>0.08</td></tr><tr><td> cmFSM_2t</td><td>68.23</td><td>2.98</td><td>1.01</td><td>0.63</td><td>0.47</td><td>0.17</td><td>0.09</td></tr><tr><td> cmFSM_8t</td><td>21.51</td><td>1.03</td><td>0.42</td><td>0.27</td><td>0.21</td><td>0.08</td><td>0.07</td></tr><tr><td> cmFSM_32t</td><td>6.32</td><td>0.44</td><td>0.21</td><td>0.16</td><td>0.14</td><td>0.06</td><td>0.06</td></tr></tbody></table></table-wrap></p>
      <p id="Par67">From Table <xref rid="Tab3" ref-type="table">3</xref>, it is not difficult to find that cmFSM presents a significant performance advantage. The last three lines in Table <xref rid="Tab3" ref-type="table">3</xref> represent that cmFSM starts 2 threads, 8 threads and 32 threads respectively. It can be seen that even the serial version, the runtime of cmFSM is less than gSpan. In addition, as long as we start more than 8 threads, the runtime of cmFSM is less than all other tools. This proves that cmFSM can show better performance than other state-of-the-art miners even if we only hold a few parallel computing resources. Moreover, the consistency of the mining results also demonstrates that our parallel optimization does not affect the correctness of the miners.</p>
      <p id="Par68">Fig. <xref rid="Fig6" ref-type="fig">6</xref> reflects the mining conditions on DTP datasets. From Fig. <xref rid="Fig6" ref-type="fig">6</xref>, it is not difficult to see that cmFSM can also achieve better performance than any other state-of-the-art miners with a small number of threads on DTP dataset. Also, the mining scale will drastically decrease with the increase in support threshold.<fig id="Fig6"><label>Fig. 6</label><caption><p>Comparison of some miners for DTP dataset</p></caption><graphic xlink:href="12859_2018_2071_Fig6_HTML" id="MO8"/></fig></p>
      <p id="Par69">The experiments on S1 dataset is shown on Fig. <xref rid="Fig7" ref-type="fig">7a</xref>, which reflects the excellent parallel acceleration effect of cmFSM. We have set 1%, 2%, 3% and 4% as support thresholds respectively to form different scale of mining process. Basically, doubling the number of threads, the speedup is doubling too, which is close to the linear speedup. Also, the smaller the support threshold is, the larger the mining scale will be, where cmFSM presents a better parallel efficiency. This means it can be well applied to large-scale mining scenes.<fig id="Fig7"><label>Fig. 7</label><caption><p>Experiments of parallel optimization. There are six pictures labeled as <bold>a</bold>,<bold>b</bold>,<bold>c</bold>,<bold>d</bold>,<bold>e</bold> and <bold>f</bold> respectively. The “T” in coordinate axis means the number of thread we have started. The “P” in coordinate axis means the number of process we have started. The “1Core” means we have only started one process with single thread to carry out these experiments. The “2CPUs” means we have started one process with 24 threads to carry out these experiments. This is because there are two CPUs with 12 cores on single node of Tianhe-2 supercomputer</p></caption><graphic xlink:href="12859_2018_2071_Fig7_HTML" id="MO9"/></fig></p>
    </sec>
    <sec id="Sec11">
      <title>Multi-node division strategy</title>
      <p id="Par70">In order to compare the advantages and disadvantages of the five division strategies under different computing scenarios, we have experimented on DTP, PTE and S2 datasets, and set 4%, 2% and 1% as support thresholds respectively. Also, in order to eliminate the impact of multi-thread parallelization, we have only started one thread of each process. The Table <xref rid="Tab4" ref-type="table">4</xref> shows the results on DTP dataset.<table-wrap id="Tab4"><label>Table 4</label><caption><p>Multi-node results for DTP dataset</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Process number</th><th>Equality</th><th>Single</th><th>Increment</th><th>Circle</th><th>Dynamic</th></tr></thead><tbody><tr><td>2</td><td>3646</td><td>3183</td><td>3192</td><td>3532</td><td>3203</td></tr><tr><td>3</td><td>3584</td><td>3174</td><td>3185</td><td>3493</td><td>3213</td></tr><tr><td>4</td><td>3567</td><td>3178</td><td>3191</td><td>3468</td><td>3208</td></tr><tr><td>5</td><td>3552</td><td>3185</td><td>3188</td><td>3452</td><td>3216</td></tr></tbody></table></table-wrap></p>
      <p id="Par71">From Table <xref rid="Tab4" ref-type="table">4</xref>, it is not difficult to see that the runtime did not be significantly reduced among anyone of these five strategies with the number of process increases. This is because the first single-edge frequent subgraph will pick out 80% of the results on DTP dataset. Thus, the first process will become the bottleneck. Moreover, the equality strategy is undoubtedly the worst strategy. The single and increment strategies are relatively faster, because the first single-edge frequent subgraph will be uniquely allocated to first process. Although the dynamic strategy also has such a division result, it has additional communication scheduling overhead, so that the performance is slightly lower than these two strategies. However, no matter how much the processes are started, the mining time of first single-edge frequent subgraph is always bottleneck on such a special dataset.</p>
      <p id="Par72">Figure <xref rid="Fig7" ref-type="fig">7b and c</xref> reflects the multi-node runtimes on PTE and S2 datasets. The condition that more than half of the results are picked out by the first single-edge frequent subgraph will not happen again on these normal datasets, such as PTE and S2.</p>
      <p id="Par73">From Fig. <xref rid="Fig7" ref-type="fig">7b</xref>, we can find the equality is also the worst strategy. The single and increment strategies present close performance. The circle strategy gradually shows the advantages of performance with the number of process increases. The dynamic strategy is the best at first, but with the increase in the number of process, its performance begin to slowly weaker than circle. This is due to the fact that the mining process of single-edge frequent graphs can be completed quickly on this dataset, so that as the number of process increases, there are frequent task requests and competitions. Coupled with the communication costs, the dynamic strategy shows weakness compared to circle. Fortunately, this is not an obvious weakness.</p>
      <p id="Par74">From Fig. <xref rid="Fig7" ref-type="fig">7c</xref>, we can find that the equality is still the worst strategy on average. At the beginning, single and increment are weaker than equality, which is because a large number of tasks are allocated to the final process when the number of process is small so as to form a bottleneck. Also, it is not difficult to find that the circle is an optimal choice among static strategies when the mining scale is big enough. The single and increment strategies still present close performance and the dynamic strategy is always better than all these static ones. Therefore, it is more recommended to use dynamic strategy, especially in the face of large-scale mining tasks.</p>
    </sec>
    <sec id="Sec12">
      <title>Efficiency of multi-node multi-thread acceleration</title>
      <p id="Par75">In order to evaluate the efficiency of multi-node acceleration, we have experimented on S1, S2 and S3 datasets, and set 1%, 1% and 2% as support thresholds respectively.</p>
      <p id="Par76">The Table <xref rid="Tab5" ref-type="table">5</xref> shows the result of multi-node scalability. We should note that we have always adopted dynamic strategy in the following experiments because this division strategy can achieve an average best performance among all these five division strategies. By this way, we can simplify following tests.<table-wrap id="Tab5"><label>Table 5</label><caption><p>Multi-node scalability</p></caption><table frame="hsides" rules="groups"><thead><tr><th/><th>12Core 2P*6 T</th><th>24Core 2P*12 T</th><th>48Core 4P*12 T</th><th>96Core 4P*24 T</th><th>192Core 8P*24 T</th><th>384Core 16P*24 T</th></tr></thead><tbody><tr><td>S1</td><td>742</td><td>408</td><td>223</td><td>131</td><td>83</td><td>74</td></tr><tr><td>S2</td><td>1732</td><td>921</td><td>487</td><td>261</td><td>161</td><td>104</td></tr><tr><td>S3</td><td>22,821</td><td>11,763</td><td>6069</td><td>3135</td><td>1640</td><td>871</td></tr></tbody></table></table-wrap></p>
      <p id="Par77">Figure <xref rid="Fig7" ref-type="fig">7d</xref> indicates the comparison of parallel efficiency on different datasets which we can get from Table <xref rid="Tab5" ref-type="table">5</xref>. we can easily find that the parallel efficiency will be better maintained with the increase in the number of cores for larger datasets, which also means cmFSM can be well applied to large-scale mining scenes.</p>
    </sec>
    <sec id="Sec13">
      <title>CPU/MIC collaboration</title>
      <p id="Par78">We have also used the last three datasets with 1%, 1% and 2% as support thresholds respectively to evaluate the effect of CPU/MIC collaboration on single node. The following Table <xref rid="Tab6" ref-type="table">6</xref> shows the results. In general, the computing capacity of 2 CPUs should be close to 3 MICs on single node. Therefore, we expect to be 24 times faster with 2 CPUs and achieve 48 times speedup with 2 CPUs and 3 MICs to make full use of computing resources on single node.<table-wrap id="Tab6"><label>Table 6</label><caption><p>CPU/MIC collaboration on single node</p></caption><table frame="hsides" rules="groups"><thead><tr><th/><th>1Core</th><th>2CPUs</th><th>2CPUs &amp;1MIC</th><th>2CPUs &amp;2MICs</th><th>2CPUs &amp;3MICs</th></tr></thead><tbody><tr><td>S1</td><td>7590</td><td>382</td><td>274</td><td>234</td><td>208</td></tr><tr><td>S2</td><td>18,944</td><td>875</td><td>607</td><td>486</td><td>410</td></tr><tr><td>S3</td><td>266,794</td><td>11,625</td><td>7749</td><td>6457</td><td>5320</td></tr></tbody></table></table-wrap></p>
      <p id="Par79">Figure <xref rid="Fig7" ref-type="fig">7e</xref> reflects the comparison of speedup on different datasets with different CPU/MIC collaboration modes which we can get from Table <xref rid="Tab6" ref-type="table">6</xref>. We can easily find that the better accelerating effect can be achieved with larger scale mining tasks. Moreover, we obtained more than 50 times speedup finally on S3 dataset, which is better than we expect to get. This is because of a series of optimization means we adopt, such as memory reuse, data transmission optimization and vectorization. In addition, the experiment on S1 dataset quickly reached the bottleneck and there is no obvious difference between 2 MICs mode and 3 MICs mode. This should also be caused by the characteristics of the dataset itself. On this dataset, a large number of tasks are always concentrated in the Host and first MIC coprocessor. However, the accelerating effect of CPU/MIC is still nice in most large-scale mining scenarios.</p>
    </sec>
    <sec id="Sec14">
      <title>Multi-node CPU/MIC collaboration</title>
      <p id="Par80">We have employed the biggest dataset S3 with 2%, 1% and 0.8% as support thresholds respectively to evaluate the effect of CPU/MIC collaboration. The following Table <xref rid="Tab7" ref-type="table">7</xref> shows the results where each node have made full use of 2 CPUs and 3 MICs.<table-wrap id="Tab7"><label>Table 7</label><caption><p>Multi-node CPU/MIC collaboration</p></caption><table frame="hsides" rules="groups"><thead><tr><th>MinSup</th><th>1node</th><th>2nodes</th><th>4nodes</th><th>8nodes</th></tr></thead><tbody><tr><td>2%</td><td>5320</td><td>2816</td><td>1736</td><td>993</td></tr><tr><td>1%</td><td>18,329</td><td>9802</td><td>5508</td><td>2918</td></tr><tr><td>0.8%</td><td>43,253</td><td>23,026</td><td>12,847</td><td>6295</td></tr></tbody></table></table-wrap></p>
      <p id="Par81">Figure <xref rid="Fig7" ref-type="fig">7f</xref> reflects the comparison of multi-node speedup on S3 with different support thresholds which we can get from Table <xref rid="Tab7" ref-type="table">7</xref>. We can also easily find that the better multi-node accelerating effect can be achieved with larger scale mining tasks. In overall, all these experiments present weaker and weaker speedup than linear speedup, which is mainly caused by multi-node communication, process competition and synchronization. However, this condition does not affect the excellent scalability of cmFSM under large-scale mining tasks.</p>
    </sec>
  </sec>
  <sec id="Sec15">
    <title>Conclusions</title>
    <p id="Par82">cmFSM is a scalable parallel frequent subgraph mining tool using CPUs and MICs in collaboration. It realizes parallelism of multiple levels and multiple granularities. We first adopt a fine-grained parallel strategy among threads by translating the common recursive mining process into a BFS loop mining process on single node. In addition to some special datasets, cmFSM can obtain near-linear speedup. Second, a coarse-grained parallel strategy is used among processes by dividing single-edge frequent subgraphs. Four kinds of static task dividing (i.e. equality, single, increment, circle) strategies and a supervisor-based dynamic task dividing strategy are implemented to achieve load balancing as much as possible. Some experiments show the dynamic strategy mostly presents better performance than all these static ones, especially in the face of large-scale mining tasks. Also, combining with the multi-thread work on single node, our implementation allows to generate a second level of parallelization by creating multiple threads per MPI process, which shows a promising scalability of massive mining tasks. Third, the collaboration among CPUs and MICs we employ a medium-grained parallel strategy by dividing the double-edge frequent subgraphs which is gotten from one-edge growth of initial single-edge frequent subgraphs. We also back up complex data structures redundantly to avoid the bottlenecks caused by excessive transmission. By memory reuse and making full of the multi-core computing capacity of MIC, we can obtained more than 50 times speedup on single node for some datasets. Also, the multi-node CPU/MIC collaboration presents an excellent scalability under large-scale mining tasks.</p>
    <p id="Par83">Moreover, Experimental evaluation results on several real compound molecular datasets show that cmFSM clearly outperforms the existing state-of-the-art miners even if we only hold a few parallel computing resources, which sufficiently demonstrates the effectiveness of our tool in the field of bioinformatics. However, on some special datasets, which will concentrate most of the mining tasks on a few front single-edge subgraphs, cmFSM will show a great limitation. In this scenario, it will quickly reach the bottleneck, which needs to further our work to solve in the future.</p>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>FSM</term>
        <def>
          <p id="Par4">Frequent subgraphs mining</p>
        </def>
      </def-item>
      <def-item>
        <term>GPU</term>
        <def>
          <p id="Par5">Graphics Processing Unit</p>
        </def>
      </def-item>
      <def-item>
        <term>MIC</term>
        <def>
          <p id="Par6">Many Integrated Core</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <ack>
    <p>We would like to thank Xiaoyu Zhang, Kaiwen Huang and Wenhe Su for helpful discussions, comments and solidarity.</p>
    <sec id="FPar1">
      <title>Funding</title>
      <p id="Par84">The authors would like to acknowledge that the publication of this article was sponsored by National Key R&amp;D Program of China 2017YFB0202600, 2016YFC1302500, 2016YFB0200400, 2017YFB0202104; NSFC Grants 61772543, U1435222, 61625202, 61272056; and Guangdong Provincial Department of Science and Technology under grant No. 2016B090918122, National Natural Science Foundation of China (Grant Nos 81402760) and the Natural Science Foundation of Jiangsu Province, China (Grant No. BK20161563).</p>
    </sec>
    <sec id="FPar2">
      <title>Availability of data and materials</title>
      <p id="Par85">Not applicable.</p>
    </sec>
    <sec id="FPar3">
      <title>About this supplement</title>
      <p id="Par86">This article has been published as part of <italic>BMC Bioinformatics</italic> Volume 19 Supplement 4, 2018: Selected articles from the 16th Asia Pacific Bioinformatics Conference (APBC 2018): bioinformatics. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-19-supplement-4">https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-19-supplement-4</ext-link>.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>SY designed the method, wrote the software, do some experiments and wrote the paper. RG conceived the study, wrote the software and wrote the paper. XL and QZ give important comments on algorithm design and writing. SP designed the method and algorithm. All of the authors have read and approve of the final manuscript.</p>
  </notes>
  <notes notes-type="COI-statement">
    <sec id="FPar4">
      <title>Ethics approval and consent to participate</title>
      <p id="Par87">Not applicable.</p>
    </sec>
    <sec id="FPar5">
      <title>Consent for publication</title>
      <p id="Par88">Not applicable.</p>
    </sec>
    <sec id="FPar6">
      <title>Competing interests</title>
      <p id="Par89">The authors declare that they have no competing interests.</p>
    </sec>
    <sec id="FPar7">
      <title>Publisher’s Note</title>
      <p id="Par90">Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </sec>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mckay</surname>
            <given-names>BD</given-names>
          </name>
        </person-group>
        <article-title>Practical graph isomorphism</article-title>
        <source>J Symb Comput</source>
        <year>2013</year>
        <volume>60</volume>
        <issue>1</issue>
        <fpage>94</fpage>
        <lpage>112</lpage>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <mixed-citation publication-type="other">Lin W. Efficient techniques for subgraph mining and query processing. Singapore: School of Computer Engineering, Nanyang Technological University; 2015.</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Huan</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Prins</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <source>SPIN: mining maximal frequent subgraphs from graph databases. Tenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source>
        <year>2004</year>
        <publisher-loc>Seattle, Washington, Usa</publisher-loc>
        <publisher-name>August, DBLP</publisher-name>
        <fpage>581</fpage>
        <lpage>586</lpage>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jiang</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Xiong</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mining globally distributed frequent subgraphs in a single labeled graph</article-title>
        <source>Data Knowl Eng</source>
        <year>2009</year>
        <volume>68</volume>
        <issue>10</issue>
        <fpage>1034</fpage>
        <lpage>1058</lpage>
        <pub-id pub-id-type="doi">10.1016/j.datak.2009.04.008</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kuramochi</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Karypis</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Finding frequent patterns in a large sparse graph</article-title>
        <source>Data Min Knowl Disc</source>
        <year>2005</year>
        <volume>11</volume>
        <issue>3</issue>
        <fpage>243</fpage>
        <lpage>271</lpage>
        <pub-id pub-id-type="doi">10.1007/s10618-005-0003-9</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kang</surname>
            <given-names>U</given-names>
          </name>
          <name>
            <surname>Tsourakakis</surname>
            <given-names>CE</given-names>
          </name>
          <name>
            <surname>Faloutsos</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>PEGASUS: mining peta-scale graphs</article-title>
        <source>Knowl Inf Syst</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>2</issue>
        <fpage>303</fpage>
        <lpage>325</lpage>
        <pub-id pub-id-type="doi">10.1007/s10115-010-0305-0</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <mixed-citation publication-type="other">Reinhardt S, Karypis G. A Multi-Level Parallel Implementation of a Program for Finding Frequent Patterns in a Large Sparse Graph. Parallel and Distributed Processing Symposium, 2007. IPDPS 2007. IEEE international. IEEE; 2007. p. 1–8.</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <mixed-citation publication-type="other">Wu B, Bai YL. An efficient distributed subgraph mining algorithm in extreme large graphs. Artificial Intelligence and Computational Intelligence - International Conference, Aici 2010, DBLP, Sanya, China, 2010:107–115 October 23–24, 2010, Proceedings, .</mixed-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yan</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Dong</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>He</surname>
            <given-names>X</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>FSMBUS: a frequent subgraph mining algorithm in single large-scale graph using spark</article-title>
        <source>J Comput Res Dev</source>
        <year>2015</year>
        <volume>52</volume>
        <issue>8</issue>
        <fpage>1768</fpage>
        <lpage>1783</lpage>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <mixed-citation publication-type="other">Lin W, Xiao X, Xie X, et al. Network motif discovery: a GPU approach. IEEE, International Conference on Data Engineering IEEE. 2015. p. 831–42.</mixed-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <mixed-citation publication-type="other">Hill S, Srichandan B, Sunderraman R. An iterative MapReduce approach to frequent subgraph mining in biological datasets. ACM Conference on Bioinformatics, Computational Biology and Biomedicine ACM. 2012. p. 661–6.</mixed-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <mixed-citation publication-type="other">Inokuchi A, Washio T, Motoda H. An Apriori-based algorithm for mining frequent substructures from graph data. European conference on principles of data mining and knowledge discovery, London, UK. 2000;1910(1):13–23.</mixed-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <mixed-citation publication-type="other">Kuramochi M, Karypis G. Frequent subgraph discovery. IEEE International Conference on Data Mining IEEE Xplore. 2001:313–20.</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <mixed-citation publication-type="other">Meinl T, Fischer I, Philippsen M. A quantitative comparison of the subgraph miners mofa, gspan, FFSM, and gaston. European Conference on Principles and Practice of Knowledge Discovery in Databases Springer-Verlag. 2005:392–403.</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <mixed-citation publication-type="other">Borgelt C, Berthold MR. Mining Molecular Fragments: Finding Relevant Substructures of Molecules. IEEE International Conference on Data Mining, 2002. ICDM 2002. Proceedings. IEEE Xplore. 2002:51–8.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <mixed-citation publication-type="other">Huan J, Wang W, Prins J. Efficient mining of frequent subgraphs in the presence of isomorphism. IEEE International Conference on Data Mining IEEE. 2003:549–52.</mixed-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <mixed-citation publication-type="other">Yan X, Han J. gSpan: graph-based substructure pattern mining. IEEE International Conference on Data Mining, 2002. ICDM 2002. Proceedings. IEEE Xplore. 2002:721–4.</mixed-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Nijssen</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <source>A quickstart in frequent structure mining can make a difference. Tenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source>
        <year>2004</year>
        <publisher-loc>Seattle, Washington, Usa</publisher-loc>
        <publisher-name>August, DBLP</publisher-name>
        <fpage>647</fpage>
        <lpage>652</lpage>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <mixed-citation publication-type="other">Yan X, Han J. CloseGraph: mining closed frequent graph patterns. ACM SIGKDD International Conference on Knowledge Discovery and Data Mining: Washington, Dc, Usa, August DBLP; 2003. p. 286–95.</mixed-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <mixed-citation publication-type="other">Maunz A, Helma C, Kramer S. Large-scale graph mining using backbone refinement classes. ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, Paris, France, DBLP, 2009:617–626 June 28 - July.</mixed-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cook</surname>
            <given-names>DJ</given-names>
          </name>
          <name>
            <surname>Holder</surname>
            <given-names>LB</given-names>
          </name>
          <name>
            <surname>Galal</surname>
            <given-names>G</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Approaches to parallel graph-based knowledge discovery</article-title>
        <source>J Parallel &amp; Distributed Comput</source>
        <year>2001</year>
        <volume>61</volume>
        <issue>3</issue>
        <fpage>427</fpage>
        <lpage>446</lpage>
        <pub-id pub-id-type="doi">10.1006/jpdc.2000.1696</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <mixed-citation publication-type="other">Buehrer G, Parthasarathy S, Chen YK. Adaptive parallel graph mining for CMP architectures. International Conference on Data Mining IEEE Computer Society. 2006:97–106.</mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Pei</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <source>Scalable mining of large disk-based graph databases. Tenth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source>
        <year>2004</year>
        <publisher-loc>Seattle, Washington, Usa</publisher-loc>
        <publisher-name>August DBLP</publisher-name>
        <fpage>316</fpage>
        <lpage>325</lpage>
      </element-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <mixed-citation publication-type="other">Nguyen SN, Orlowska ME, Li X. Graph mining based on a data partitioning approach. Nineteenth Conference on Australasian Database: Australian Computer Society, Inc; 2008. p. 31–7.</mixed-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Dean</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Ghemawat</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <source>MapReduce: simplified data processing on large clusters. Conference on Symposium on Opearting Systems Design &amp; Implementation</source>
        <year>2004</year>
        <fpage>107</fpage>
        <lpage>113</lpage>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bhuiyan</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Al</surname>
            <given-names>HM</given-names>
          </name>
        </person-group>
        <article-title>An iterative MapReduce based frequent subgraph mining algorithm</article-title>
        <source>IEEE Transactions on Knowledge &amp; Data Engineering</source>
        <year>2013</year>
        <volume>27</volume>
        <issue>3</issue>
        <fpage>608</fpage>
        <lpage>620</lpage>
        <pub-id pub-id-type="doi">10.1109/TKDE.2014.2345408</pub-id>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <mixed-citation publication-type="other">Lu W, Chen G, Tung AKH, et al. Efficiently extracting frequent subgraphs using MapReduce. IEEE International Conference on Big Data IEEE. 2013:639–47.</mixed-citation>
    </ref>
    <ref id="CR28">
      <label>28.</label>
      <mixed-citation publication-type="other">Lin W, Xiao X, Ghinita G. Large-scale frequent subgraph mining in MapReduce. IEEE, International Conference on Data Engineering. IEEE. 2014:844–55.</mixed-citation>
    </ref>
  </ref-list>
</back>
