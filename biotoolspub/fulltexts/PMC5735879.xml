<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5735879</article-id>
    <article-id pub-id-type="publisher-id">1953</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-017-1953-9</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>HISEA: HIerarchical SEed Aligner for PacBio data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Khiste</surname>
          <given-names>Nilesh</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Ilie</surname>
          <given-names>Lucian</given-names>
        </name>
        <address>
          <email>ilie@uwo.ca</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1936 8884</institution-id><institution-id institution-id-type="GRID">grid.39381.30</institution-id><institution>Department of Computer Science, </institution><institution>University of Western Ontario, </institution></institution-wrap>LondonOntario, N6A 5B7 Canada </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>19</day>
      <month>12</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>19</day>
      <month>12</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2017</year>
    </pub-date>
    <volume>18</volume>
    <elocation-id>564</elocation-id>
    <history>
      <date date-type="received">
        <day>28</day>
        <month>3</month>
        <year>2017</year>
      </date>
      <date date-type="accepted">
        <day>22</day>
        <month>11</month>
        <year>2017</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2017</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver(<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p>The next generation sequencing (NGS) techniques have been around for over a decade. Many of their fundamental applications rely on the ability to compute good genome assemblies. As the technology evolves, the assembly algorithms and tools have to continuously adjust and improve. The currently dominant technology of Illumina produces reads that are too short to bridge many repeats, setting limits on what can be successfully assembled. The emerging SMRT (Single Molecule, Real-Time) sequencing technique from Pacific Biosciences produces uniform coverage and long reads of length up to sixty thousand base pairs, enabling significantly better genome assemblies. However, SMRT reads are much more expensive and have a much higher error rate than Illumina’s – around 10-15% – mostly due to indels. New algorithms are very much needed to take advantage of the long reads while mitigating the effect of high error rate and lowering the required coverage.</p>
      </sec>
      <sec>
        <title>Methods</title>
        <p>An essential step in assembling SMRT data is the detection of alignments, or overlaps, between reads. High error rate and very long reads make this a much more challenging problem than for Illumina data. We present a new pairwise read aligner, or overlapper, HISEA (Hierarchical SEed Aligner) for SMRT sequencing data. HISEA uses a novel two-step k-mer search, employing consistent clustering, k-mer filtering, and read alignment extension.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We compare HISEA against several state-of-the-art programs – BLASR, DALIGNER, GraphMap, MHAP, and Minimap – on real datasets from five organisms. We compare their sensitivity, precision, specificity, F1-score, as well as time and memory usage. We also introduce a new, more precise, evaluation method. Finally, we compare the two leading programs, MHAP and HISEA, for their genome assembly performance in the Canu pipeline.</p>
      </sec>
      <sec>
        <title>Discussion</title>
        <p>Our algorithm has the best alignment detection sensitivity among all programs for SMRT data, significantly higher than the current best. The currently best assembler for SMRT data is the Canu program which uses the MHAP aligner in its pipeline. We have incorporated our new HISEA aligner in the Canu pipeline and benchmarked it against the best pipeline for multiple datasets at two relevant coverage levels: 30x and 50x. Our assemblies are better than those using MHAP for both coverage levels. Moreover, Canu+HISEA assemblies for 30x coverage are comparable with Canu+MHAP assemblies for 50x coverage, while being faster and cheaper.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>The HISEA algorithm produces alignments with highest sensitivity compared with the current state-of-the-art algorithms. Integrated in the Canu pipeline, currently the best for assembling PacBio data, it produces better assemblies than Canu+MHAP.</p>
      </sec>
      <sec>
        <title>Electronic supplementary material</title>
        <p>The online version of this article (doi:10.1186/s12859-017-1953-9) contains supplementary material, which is available to authorized users.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>PacBio sequencing</kwd>
      <kwd>Read aligner</kwd>
      <kwd>Read overlapper</kwd>
      <kwd>Genome assembly</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100002790</institution-id>
            <institution>Canadian Network for Research and Innovation in Machining Technology, Natural Sciences and Engineering Research Council of Canada</institution>
          </institution-wrap>
        </funding-source>
        <award-id>R3143A01</award-id>
      </award-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100002790</institution-id>
            <institution>Canadian Network for Research and Innovation in Machining Technology, Natural Sciences and Engineering Research Council of Canada</institution>
          </institution-wrap>
        </funding-source>
        <award-id>R3143A07</award-id>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2017</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p><italic>De novo</italic> genome assembly is the problem of reconstructing the entire genome of an organism from sequencing reads without using a reference genome. The high throughput NGS technologies produce short reads, of few hundred base pairs, which are much smaller than most of the repeated regions in microbial and eukaryotic genomes. The repeated regions that are longer than read length pose serious challenges to the genome assembly algorithm. This imbalance of read versus repeat length increases the complexity and processing requirements of the assembly algorithm. This is the reason many assemblies using NGS data are fragmented and incomplete [<xref ref-type="bibr" rid="CR1">1</xref>], and often not useful for downstream analysis.</p>
    <p>The advent of SMRT sequencing technology from Pacific Biosciences has encouraged researchers to look into the genome assembly problem from a fresh perspective. The long reads spanning across many repeated regions enable the production of significantly better assemblies. The SMRT technology is also less biased [<xref ref-type="bibr" rid="CR2">2</xref>] than previous NGS technologies. However, two important drawbacks of SMRT sequencing are high error rate, of 10-15%, and high cost. For comparison, the dominant technology of Illumina has up to 100 times lower error rate and is over 100 times cheaper in terms of cost per Gbp [<xref ref-type="bibr" rid="CR3">3</xref>]. On the positive side, it has been found that the errors are random and it is possible to correct them algorithmically [<xref ref-type="bibr" rid="CR4">4</xref>] by increasing the coverage of sequencing data. Thus, SMRT sequencing makes it possible to produce more continuous and higher quality genome assemblies than what has been achieved with previous technologies.</p>
    <p>In most of the published SMRT genome assembly pipelines [<xref ref-type="bibr" rid="CR5">5</xref>–<xref ref-type="bibr" rid="CR7">7</xref>], a critical step is finding all-vs-all raw read alignments. The outcome of this step can have a large impact on the processing of subsequent steps and the overall outcome of the assembly pipeline. It is therefore essential to use a highly sensitive aligner. We present a new long read aligner, HISEA, which is much more sensitive than all existing ones. We compared the sensitivity of our aligner with BLASR [<xref ref-type="bibr" rid="CR8">8</xref>], DALIGNER [<xref ref-type="bibr" rid="CR9">9</xref>], GraphMap [<xref ref-type="bibr" rid="CR10">10</xref>], MHAP [<xref ref-type="bibr" rid="CR11">11</xref>], and MiniMap [<xref ref-type="bibr" rid="CR5">5</xref>]. Note that we use the terms “alignment” and “overlap” interchangeably.</p>
    <p>The comparatively high cost of SMRT sequencing has prevented its widespread use. It is very expensive to sequence large genomes with high coverage using SMRT technology, therefore it is still beyond the reach of many research labs. Recently, Koren et al. [<xref ref-type="bibr" rid="CR6">6</xref>] showed that their Canu assembler can generate assemblies using only 20x coverage that are comparable with 150x coverage hybrid assemblies generated with SPAdes [<xref ref-type="bibr" rid="CR12">12</xref>]. It has also shown that it can achieve maximum assembly continuity around 50x coverage. As indicated by Koren et al. [<xref ref-type="bibr" rid="CR6">6</xref>], Canu pipeline is currently the best. It uses the MHAP aligner [<xref ref-type="bibr" rid="CR11">11</xref>] and therefore we incorporated HISEA in this assembly pipeline, in place of MHAP. We have compared the two pipelines, Canu+MHAP and Canu+HISEA for five organisms, <italic>E.coli</italic>, <italic>S.cerevisiae</italic>, <italic>C.elegans</italic>, <italic>A.thaliana</italic>, and <italic>D.melanogaster</italic> at two coverage levels: 30x and 50x. The pipeline using HISEA is shown to produce better assemblies for both coverage levels. Moreover, the Canu+HISEA assemblies for 30x coverage are comparable with those of Canu+MHAP for 50x coverage.</p>
    <p>Our HISEA software is implemented in C++ and OpenMP and its source code is freely available. It can be used as a stand alone aligner or as an all-vs-all read aligner in other assembly pipelines. We have tested it in the Canu [<xref ref-type="bibr" rid="CR6">6</xref>] assembly pipeline and the modified pipeline source code is also freely available for download.</p>
  </sec>
  <sec id="Sec2">
    <title>Methods</title>
    <sec id="Sec3">
      <title>The HISEA algorithm</title>
      <p>Let <italic>Σ</italic>={<italic>A</italic>,<italic>C</italic>,<italic>G</italic>,<italic>T</italic>} be the DNA alphabet; <italic>Σ</italic>
<sup>∗</sup> is the set of all DNA sequences, that is, all finite strings over <italic>Σ</italic>. Our setup assumes two sets of reads: the set of reference reads, <italic>R</italic>={<italic>r</italic>
<sub>1</sub>,<italic>r</italic>
<sub>2</sub>,...,<italic>r</italic>
<sub><italic>n</italic></sub>}⊂<italic>Σ</italic>
<sup>∗</sup>, and the set of query reads, <italic>Q</italic>={<italic>q</italic>
<sub>1</sub>,<italic>q</italic>
<sub>2</sub>,...,<italic>q</italic>
<sub><italic>m</italic></sub>}⊂<italic>Σ</italic>
<sup>∗</sup>. A <italic>k</italic>-mer is a string of length <italic>k</italic> over <italic>Σ</italic>.</p>
      <sec id="Sec4">
        <title>Storing reads and hashing the reference set</title>
        <p>Each read <italic>r</italic>
<sub><italic>i</italic></sub> is encoded using 2 bits per nucleotide and stored as an array of unsigned 64-bit integers, that is, as blocks of 32 nucleotides. The reverse complement of <italic>r</italic> is stored in the same array and it starts at the next unsigned 64-bit integer. A precomputed 16-bit reverse complement array of all possible values is used to quickly compute the reverse complement of reads.</p>
        <p>All <italic>k</italic>-mers that occur in reads of <italic>R</italic> are quickly computed using bitwise operations and bit masking and stored in a hash table using double hashing technique. In the hash table, each entry stores the value of the <italic>k</italic>-mer and a pointer to another hash table which stores the set of read ids <italic>r</italic>
<sub><italic>j</italic></sub>, and positions within <italic>r</italic>
<sub><italic>j</italic></sub>, where this <italic>k</italic>-mer occurs. Any <italic>k</italic>-mer which occurs more than MAX_KMER_COUNT times is ignored. The MAX_KMER_COUNT is a user configurable parameter with a default value of 10000. Similarly, <italic>k</italic>-mers appearing in low count can be ignored. These <italic>k</italic>-mers do not impact the alignment and ignoring them speeds up the alignment process. The default value for low count <italic>k</italic>-mers is 2 and it can be controlled by a user configurable parameter.</p>
      </sec>
      <sec id="Sec5">
        <title>Searching the query set</title>
        <p>The <italic>k</italic>-mers occurring in the query read set <italic>Q</italic> are not stored; they are quickly computed as needed using bit operations. Then they are efficiently searched for in the hash table built for the set <italic>R</italic>. Every time a matching <italic>k</italic>-mer is found in the hash table, the corresponding reference read id and its position is recorded. Note that the reads in the query set are only searched in forward direction.</p>
      </sec>
      <sec id="Sec6">
        <title>Clustering and filtering</title>
        <p>For a given query <italic>q</italic>∈<italic>Q</italic> and a reference read <italic>r</italic>∈<italic>R</italic>, the reference read direction and all matching <italic>k</italic>-mer positions are stored in the previous step. For a pair of reads (<italic>q</italic>, <italic>r</italic>), further processing is considered either in forward or reverse direction of <italic>r</italic>. The decision is taken based on the read direction of <italic>r</italic> which has higher number of matching <italic>k</italic>-mers.</p>
        <p>The next step is to perform clustering of all the matching <italic>k</italic>-mers. Clustering is an essential step in identifying the best alignment out of multiple possible alignments. Our algorithm reports only the best alignment between a pair of reads. Figure <xref rid="Fig1" ref-type="fig">1</xref> shows an example of all <italic>k</italic>-mer matches between read <italic>q</italic> and read <italic>r</italic> before and after clustering. The example shown here is one simple case; in reality many complex cases are possible where clustering is essential. The initial matches can have contradictory information, such as the ones in Fig. <xref rid="Fig1" ref-type="fig">1</xref>
<xref rid="Fig1" ref-type="fig">a</xref>, and the clustering phase involves collecting together consistent matches. A <italic>consistent</italic> set of <italic>k</italic>-mer matches is defined as a set of all <italic>k</italic>-mer matches arranged in ascending order of their positions and are equidistant from neighboring <italic>k</italic>-mer matches within defined threshold. The threshold is governed by a global parameter <italic>m</italic>
<italic>a</italic>
<italic>x</italic>
<italic>S</italic>
<italic>h</italic>
<italic>i</italic>
<italic>f</italic>
<italic>t</italic>. The parameter <italic>m</italic>
<italic>a</italic>
<italic>x</italic>
<italic>S</italic>
<italic>h</italic>
<italic>i</italic>
<italic>f</italic>
<italic>t</italic> is a user configurable parameter that accommodates the <italic>indel</italic> errors during <italic>k</italic>-mer matching, clustering and extension algorithms. The default value of this parameter has been experimentally determined to be 0.2 (or 20%). Figure <xref rid="Fig1" ref-type="fig">1</xref>
<xref rid="Fig1" ref-type="fig">b</xref> shows the set of <italic>k</italic>-mers as divided into three consistent groups. It can be seen from the diagram that the rightmost cluster of <italic>k</italic>-mers is expected to produce the best alignment.
<fig id="Fig1"><label>Fig. 1</label><caption><p>All <italic>k</italic>-mer matches between reads <italic>q</italic> and <italic>r</italic> before (<bold>a</bold>) and after (<bold>b</bold>) clustering</p></caption><graphic xlink:href="12859_2017_1953_Fig1_HTML" id="MO1"/></fig>
</p>
        <p>Algorithm 2.1 gives the details of the clustering algorithm. The input to the algorithm is an array <italic>V</italic> which contains all <italic>k</italic>-mer matches for a pair of reads (<italic>q</italic>, <italic>r</italic>). The input <italic>k</italic>-mer matches in <italic>V</italic> are sorted beforehand, first by query read positions and then by reference read positions. If the clustering algorithm fails to produce any meaningful clusters, we reverse the sort order i.e. first sort by reference read positions and then by query read positions and retry the algorithm. The algorithm uses two global parameters, <italic>k</italic>
<italic>m</italic>
<italic>e</italic>
<italic>r</italic>
<italic>S</italic>
<italic>i</italic>
<italic>z</italic>
<italic>e</italic> and <italic>m</italic>
<italic>a</italic>
<italic>x</italic>
<italic>S</italic>
<italic>h</italic>
<italic>i</italic>
<italic>f</italic>
<italic>t</italic>. The parameter <italic>k</italic>
<italic>m</italic>
<italic>e</italic>
<italic>r</italic>
<italic>S</italic>
<italic>i</italic>
<italic>z</italic>
<italic>e</italic> is the size of the <italic>k</italic>-mers used for the initial hashing. The parameter <italic>m</italic>
<italic>a</italic>
<italic>x</italic>
<italic>S</italic>
<italic>h</italic>
<italic>i</italic>
<italic>f</italic>
<italic>t</italic> is defined previously. The output of the clustering algorithm is a set of matches, <italic>C</italic>
<italic>l</italic>
<italic>u</italic>
<italic>s</italic>
<italic>t</italic>
<italic>e</italic>
<italic>r</italic>
<italic>A</italic>
<italic>r</italic>
<italic>r</italic>
<italic>a</italic>
<italic>y</italic>, segregated in groups such that each group has a consistent set of <italic>k</italic>-mers. Note that the first two values in <italic>C</italic>
<italic>l</italic>
<italic>u</italic>
<italic>s</italic>
<italic>t</italic>
<italic>e</italic>
<italic>r</italic>
<italic>A</italic>
<italic>r</italic>
<italic>r</italic>
<italic>a</italic>
<italic>y</italic> store the left and right <italic>k</italic>-mer positions in <italic>V</italic> for that cluster. The third and fourth values are the number of matching bps and <italic>k</italic>-mer hit counts respectively.</p>
        <p>From the output of Algorithm 2.1, the cluster with the maximum number of matching base pairs is selected for further processing. The expected number of <italic>k</italic>-mer matches is estimated with the help of <italic>k</italic>-mer bounds in read <italic>q</italic> and read <italic>r</italic>; see Fig. <xref rid="Fig2" ref-type="fig">2</xref>. The leftmost and rightmost query <italic>k</italic>-mers start and end at positions <italic>q</italic>
<sub><italic>L</italic></sub> and <italic>q</italic>
<sub><italic>R</italic></sub>, respectively. Similarly, the corresponding positions in the reference read are <italic>r</italic>
<sub><italic>L</italic></sub> and <italic>r</italic>
<sub><italic>R</italic></sub>. The alignment length is <italic>L</italic>=<italic>r</italic>
<sub><italic>R</italic></sub>+<italic>q</italic>
<italic>u</italic>
<italic>e</italic>
<italic>r</italic>
<italic>y</italic>
<italic>S</italic>
<italic>i</italic>
<italic>z</italic>
<italic>e</italic>−<italic>q</italic>
<sub><italic>R</italic></sub>. The number of <italic>k</italic>-mer hits in the overlapping region is approximated as a binomial distribution with probability <italic>p</italic>=(1−<italic>e</italic>)<sup>2<italic>k</italic></sup> and <italic>L</italic> trials. Overlaps that have fewer <italic>k</italic>-mer matches than three standard deviations below the mean, that is, less than <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mu - 3\sigma = Lp - 3\sqrt {Lp(1-p)}$\end{document}</tex-math><mml:math id="M2"><mml:mi>μ</mml:mi><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mi>σ</mml:mi><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">Lp</mml:mtext><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:msqrt><mml:mrow><mml:mtext mathvariant="italic">Lp</mml:mtext><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msqrt></mml:math><inline-graphic xlink:href="12859_2017_1953_Article_IEq1.gif"/></alternatives></inline-formula>, are eliminated as having too low similarity. This procedure is employed several times during different steps of the algorithm and will be referred to as the <italic>μ</italic>−3<italic>σ</italic>
<italic>criterion</italic>.
<fig id="Fig2"><label>Fig. 2</label><caption><p>Computing the alignment. The dark grey region contains all <italic>k</italic>-mer matches and is extended by the light grey ones using <italic>k</italic>
<sup>′</sup>-mer matches</p></caption><graphic xlink:href="12859_2017_1953_Fig2_HTML" id="MO2"/></fig>
</p>
        <p>
          <graphic xlink:href="12859_2017_1953_Figa_HTML.gif" id="MO3"/>
        </p>
      </sec>
      <sec id="Sec7">
        <title>Computing alignments</title>
        <p>The alignment between the two given reads starts as the shortest interval that contains all <italic>k</italic>-mer matches, shown in dark grey in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. This region is extended using a smaller seed, that is, using <italic>k</italic>
<sup>′</sup>-mer matches, for some <italic>k</italic>
<sup>′</sup>&lt;<italic>k</italic>. The default values are <italic>k</italic>=16 and <italic>k</italic>
<sup>′</sup>=12. These values have been determined experimentally to produce reasonably good results for most datasets. Note that MHAP uses 16-mers as well.</p>
        <p>The first step is to compute the maximum bounds of the alignment considering the maximum amount of allowable indels in the overlapping region. This is given by the user configurable parameter <italic>m</italic>
<italic>a</italic>
<italic>x</italic>
<italic>S</italic>
<italic>h</italic>
<italic>i</italic>
<italic>f</italic>
<italic>t</italic> we mentioned above. As an example, for the situation depicted in Fig. <xref rid="Fig2" ref-type="fig">2</xref>, we set the maximum bounds for read <italic>q</italic> and read <italic>r</italic> as (<italic>q</italic>
<italic>u</italic>
<italic>e</italic>
<italic>r</italic>
<italic>y</italic>
<italic>S</italic>
<italic>t</italic>
<italic>a</italic>
<italic>r</italic>
<italic>t</italic>,<italic>q</italic>
<italic>u</italic>
<italic>e</italic>
<italic>r</italic>
<italic>y</italic>
<italic>S</italic>
<italic>i</italic>
<italic>z</italic>
<italic>e</italic>) and (0,<italic>r</italic>
<italic>e</italic>
<italic>f</italic>
<italic>E</italic>
<italic>n</italic>
<italic>d</italic>) respectively (see Fig. <xref rid="Fig2" ref-type="fig">2</xref>) where: 
<disp-formula id="Equa"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{rcl} {queryStart} &amp;=&amp; q_{L} - (1+{maxShift})r_{L}\\ {refEnd} &amp;=&amp; r_{R} + (1+{maxShift})({querySize} - q_{R}) \end{array} $$ \end{document}</tex-math><mml:math id="M4"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mtext mathvariant="italic">queryStart</mml:mtext></mml:mtd><mml:mtd><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">maxShift</mml:mtext><mml:mo>)</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext mathvariant="italic">refEnd</mml:mtext></mml:mtd><mml:mtd><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">maxShift</mml:mtext><mml:mo>)</mml:mo><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">querySize</mml:mtext><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>R</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="12859_2017_1953_Article_Equa.gif" position="anchor"/></alternatives></disp-formula>
</p>
        <p>Then, all <italic>k</italic>
<sup>′</sup>-mer matches within these bounds are computed as done previously for <italic>k</italic>-mers. These matches are used to extend the alignment we have computed so far; in Fig. <xref rid="Fig2" ref-type="fig">2</xref>, the dark grey region is extended by the light grey ones on both sides. Each <italic>k</italic>
<sup>′</sup>-mer match is added if together with the ones already added they satisfy the <italic>μ</italic>−3<italic>σ</italic> criterion described above. The structure of the extension step is given in Algorithm 2.2. The input bounds are either (<italic>q</italic>
<sub><italic>L</italic></sub>,<italic>r</italic>
<sub><italic>L</italic></sub>) or (<italic>q</italic>
<sub><italic>R</italic></sub>,<italic>r</italic>
<sub><italic>R</italic></sub>). The extension is performed as long as <italic>k</italic>
<sup>′</sup>-mer matches exist that satisfy the <italic>μ</italic>−3<italic>σ</italic> criterion.</p>
        <p>
          <graphic xlink:href="12859_2017_1953_Figb_HTML.gif" id="MO4"/>
        </p>
        <p>Finally, all the <italic>k</italic>
<sup>′</sup>-mers within the initial region – dark grey colour in Fig. <xref rid="Fig2" ref-type="fig">2</xref> – are computed. Note also that the process is now guided by the original <italic>k</italic>-mers and therefore the clustering step is not required. The <italic>μ</italic>−3<italic>σ</italic> criterion is applied once more to the total number of <italic>k</italic>
<sup>′</sup>-mer matches for the entire overlap (light and dark grey); if the condition is satisfied, then the reads are considered to be overlapping and the alignment is reported.</p>
        <p>Note that HISEA computes only the alignment boundaries, not the actual alignments. The same is true for other programs, such as MHAP [<xref ref-type="bibr" rid="CR11">11</xref>], Minimap [<xref ref-type="bibr" rid="CR5">5</xref>], and GraphMap [<xref ref-type="bibr" rid="CR10">10</xref>]. Once identified, the alignments can be computed by dynamic programming; we avoid this step as it is very time consuming and not necessary for assembly, which is the goal of HISEA.</p>
      </sec>
    </sec>
    <sec id="Sec8">
      <title>Alignment evaluation procedures</title>
      <p>The <italic>EstimateROC</italic> utility estimates the sensitivity, specificity, and precision for the alignments reported. The original <italic>EstimateROC</italic> utility of Berlin et al. [<xref ref-type="bibr" rid="CR11">11</xref>] relies heavily on BLASR mappings for the verification of reported alignments. This is not the most accurate procedure since BLASR can make errors. Ideally, each alignment needs to be verified against the optimally computed alignment using the Smith-Waterman dynamic programming algorithm [<xref ref-type="bibr" rid="CR13">13</xref>]. We modified the functions estimating sensitivity, specificity, and precision accordingly.</p>
      <p>The modified function <italic>ComputeDP</italic> first computes an optimal alignment, <italic>A</italic>
<sub>opt</sub>, between two reads using Smith-Waterman dynamic programming algorithm; it ensures that this is a good alignment. Then, assuming the program reported an alignment, <italic>A</italic>
<sub>rep</sub>, for these two reads, it compares the length, direction, and bounds of the alignment reported by the program with those of the optimal alignment. This is essential since the program could report a very different alignment between the same reads and that should not be considered correct. The use of an optimal alignment algorithm increases the accuracy of evaluation.</p>
      <p>The three functions used for evaluation, <italic>EstimateSensitivity, EstimateSpecificity</italic>, and <italic>EstimatePrecision</italic> are modified to correspond with our new <italic>ComputeDP</italic> function. The details are given in pseudo code below; see Algorithms 3.3-3.6.</p>
      <p>Note that our evaluation is more accurate than the one of Berlin et al. [<xref ref-type="bibr" rid="CR11">11</xref>] and all programs exhibit an decline in performance. The Results section contains a comparison of several evaluation procedures.</p>
      <p>
        <graphic xlink:href="12859_2017_1953_Figc_HTML.gif" id="MO5"/>
      </p>
      <p>
        <graphic xlink:href="12859_2017_1953_Figd_HTML.gif" id="MO6"/>
      </p>
      <p>
        <graphic xlink:href="12859_2017_1953_Fige_HTML.gif" id="MO7"/>
      </p>
      <p>
        <graphic xlink:href="12859_2017_1953_Figf_HTML.gif" id="MO8"/>
      </p>
    </sec>
  </sec>
  <sec id="Sec9" sec-type="results">
    <title>Results</title>
    <sec id="Sec10">
      <title>Datasets</title>
      <p>All the datasets have been downloaded from Pacific Biosciences DevNet Datasets (<ext-link ext-link-type="uri" xlink:href="https://github.com/PacificBiosciences/DevNet/wiki/Datasets">https://github.com/PacificBiosciences/DevNet/wiki/Datasets</ext-link>). The datasets used for this evaluation are given in Table <xref rid="Tab1" ref-type="table">1</xref>. Details are provided in the Additional file <xref rid="MOESM1" ref-type="media">1</xref>.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>SMRT datasets used in for evaluation</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Genome</th><th align="left">Reference</th><th align="left">Coverage</th><th align="left">Chemistry</th><th align="left">Genome size</th></tr><tr><th align="left"/><th align="left">number</th><th align="left"/><th align="left"/><th align="left">(Mbp)</th></tr></thead><tbody><tr><td align="left"><italic>E.coli</italic></td><td align="left">NC_000913</td><td align="left">85x</td><td align="left">P5C3</td><td align="left">4.64</td></tr><tr><td align="left"><italic>S.cerevisiae</italic></td><td align="left">NC_001133.9</td><td align="left">117x</td><td align="left">P4C2</td><td align="left">12.16</td></tr><tr><td align="left"><italic>C.elegans</italic></td><td align="left">WS222</td><td align="left">80x</td><td align="left">P6C4</td><td align="left">100.2</td></tr><tr><td align="left"><italic>A.thaliana</italic></td><td align="left">TAIR10</td><td align="left">110x</td><td align="left">P4C2</td><td align="left">134.6</td></tr><tr><td align="left"><italic>D.melanogaster</italic></td><td align="left">Ref v5</td><td align="left">90x</td><td align="left">P5C3</td><td align="left">129.7</td></tr></tbody></table></table-wrap>
</p>
      <p>The tests were performed on a DELL PowerEdge R620 computer with 12 cores Intel Xeon at 2.0 GHz and 256 GB of RAM, running Linux Red Hat, CentOS 6.3.</p>
    </sec>
    <sec id="Sec11">
      <title>Competing programs</title>
      <p>We evaluated the performance of HISEA against the currently best programs for PacBio read alignment: BLASR [<xref ref-type="bibr" rid="CR8">8</xref>], DALIGNER [<xref ref-type="bibr" rid="CR9">9</xref>], GraphMap [<xref ref-type="bibr" rid="CR10">10</xref>], MHAP [<xref ref-type="bibr" rid="CR11">11</xref>], and Minimap [<xref ref-type="bibr" rid="CR5">5</xref>]. We then assessed the performance of HISEA for assembling PacBio data by including HISEA in the Canu assembly pipeline [<xref ref-type="bibr" rid="CR6">6</xref>] and comparing it with the Canu assembly using MHAP as the aligner.</p>
      <p>The programs were run according to their own developers’ suggestions or better, as follows. Minimap and DALIGNER were run as suggested by the developers. BLASR was run according to what the MHAP paper claimed to be the best choice of parameters. This is clearly better than the default parameters of BLASR. GraphMap was run with default parameters as the only choice in overlapping mode. MHAP was run with default parameters, except the number of hashes, which was set to 1256, instead of the default 512, for increased sensitivity. Minimap was run with window size 5 (default is 10), as recommended by the designers. HISEA was run with default parameters.</p>
      <p>The Additional file <xref rid="MOESM1" ref-type="media">1</xref> contains all the details concerning the versions used, download websites, and command lines.</p>
    </sec>
    <sec id="Sec12">
      <title>Alignment comparison</title>
      <p>The first tests we performed, as done also by Berlin et al. [<xref ref-type="bibr" rid="CR11">11</xref>], use subdatasets of 1Gbp randomly sampled from the initial datasets; for the two smallest genomes, <italic>E.coli</italic> and <italic>S.cerevisiae</italic>, full datasets are used since they are close to 1Gbp with the given coverage. The sensitivity, specificity, and precision values for all five programs are given in Table <xref rid="Tab2" ref-type="table">2</xref>. They were computed using the <italic>EstimateSensitivity, EstimateSpecificity</italic>, and <italic>EstimatePrecision</italic> procedures that we described in the <xref rid="Sec2" ref-type="sec">Methods</xref> section.
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Comparison for the 1Gbp datasets (coverage levels in parentheses)</p></caption><table frame="hsides" rules="groups"><tbody><tr><td align="left" colspan="2"><inline-graphic xlink:href="12859_2017_1953_Figg_HTML.gif" id="d29e1720"/></td></tr></tbody></table><table-wrap-foot><p>Sensitivity, specificity, precision, and <italic>F</italic>
<sub>1</sub>-score are given as percentages; A dash mean that the program crashed with segmentation fault. The best values are shown in bold. The bottom of the table shows the average values, each computed from the five corresponding values in the table</p></table-wrap-foot></table-wrap>
</p>
      <p>Similarly to MHAP [<xref ref-type="bibr" rid="CR11">11</xref>] evaluation parameters for <italic>EstimateROC</italic>, we use minimum alignment length 2000 bps and 50,000 trials. The other mandatory inputs to <italic>EstimateROC</italic> are the reference genome, the reads and the mapping of the reads to the reference. The mapping of the reads to the reference is computed using the BLASR program.</p>
      <p>HISEA has clearly the highest sensitivity, over 16% higher, on the average, than the second best program, MHAP. The specificity is high for all programs. Minimap has the highest specificity but low sensitivity. BLASR has the highest precision but, again, low sensitivity. HISEA is second for precision, not far from BLASR. To better compare the performance with respect to sensitivity and precision, we have computed the <italic>F</italic>
<sub>1</sub>-scores, also shown in Table <xref rid="Tab2" ref-type="table">2</xref>. The <italic>F</italic>
<sub>1</sub>-score for HISEA is much higher than all the other programs, with DALIGNER and MHAP following 18% and 19% behind. Next are BLASR and Minimap and last comes GraphMap with a very low score.</p>
      <p>The time and memory comparison for the same 1Gbp datasets is presented in Table <xref rid="Tab3" ref-type="table">3</xref>. Minimap and GraphMap are clearly the fastest and BLASR the slowest. HISEA is in the middle, behind MHAP and DALINER. Space-wise, Minimap is again the best, followed closely by BLASR, and at some distance by HISEA and GraphMap. MHAP and DALIGNER used the most memory. MHAP is implemented in JAVA which generally requires more memory. The java command-line parameter -Xmx is used to set the maximum heap size for MHAP stand alone invocation. The default maximum java heap size depends on the platform and the amount of memory in the system. For our systems, the default was not sufficient to perform the tests. We set -Xmx parameter to 200G which was sufficient for all tests but it does not capture true overlapper memory for MHAP. The reported memory usage for MHAP consists of the overlapper memory and the memory required for Java Virtual Machine environment.
<table-wrap id="Tab3"><label>Table 3</label><caption><p>Time and memory comparison for the 1Gbp datasets</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Genome</th><th align="left">Time (h)</th><th align="left">BLASR</th><th align="left">DALIGNER</th><th align="left">GraphMap</th><th align="left">MHAP</th><th align="left">Minimap</th><th align="left">HISEA</th></tr><tr><th align="left"/><th align="left">Memory (GB)</th><th align="left"/><th align="left"/><th align="left"/><th align="left"/><th align="left"/><th align="left"/></tr></thead><tbody><tr><td align="left">E.coli</td><td align="left">Time</td><td align="left">113.0</td><td align="left">3.0</td><td align="left">0.3</td><td align="left">3.0</td><td align="left"><bold>0.1</bold></td><td align="left">4.0</td></tr><tr><td align="left"/><td align="left">Memory</td><td align="left"><bold>7.1</bold></td><td align="left">124.6</td><td align="left">42.3</td><td align="left">210.0</td><td align="left">8.8</td><td align="left">25.5</td></tr><tr><td align="left">S.cerevisiae</td><td align="left">Time</td><td align="left">283.2</td><td align="left">–</td><td align="left">0.6</td><td align="left">10.6</td><td align="left"><bold>0.3</bold></td><td align="left">23.5</td></tr><tr><td align="left"/><td align="left">Memory</td><td align="left"><bold>13.3</bold></td><td align="left">–</td><td align="left">71.0</td><td align="left">210.0</td><td align="left">15.1</td><td align="left">56.5</td></tr><tr><td align="left">C.elegans</td><td align="left">Time</td><td align="left">333.6</td><td align="left">4.1</td><td align="left">0.6</td><td align="left">4.3</td><td align="left"><bold>0.2</bold></td><td align="left">23.6</td></tr><tr><td align="left"/><td align="left">Memory</td><td align="left">14.5</td><td align="left">248.2</td><td align="left">59.0</td><td align="left">210.0</td><td align="left"><bold>9.8</bold></td><td align="left">46.4</td></tr><tr><td align="left">A.thaliana</td><td align="left">Time</td><td align="left">43.2</td><td align="left">8.1</td><td align="left">0.6</td><td align="left">5.9</td><td align="left"><bold>0.2</bold></td><td align="left">12.2</td></tr><tr><td align="left"/><td align="left">Memory</td><td align="left">10.3</td><td align="left">248.2</td><td align="left">60.0</td><td align="left">210.0</td><td align="left"><bold>9.9</bold></td><td align="left">45.3</td></tr><tr><td align="left">D.melanogaster</td><td align="left">Time</td><td align="left">355.2</td><td align="left">12.5</td><td align="left">0.4</td><td align="left">4.8</td><td align="left"><bold>0.1</bold></td><td align="left">95.1</td></tr><tr><td align="left"/><td align="left">Memory</td><td align="left">16.7</td><td align="left">204.2</td><td align="left">59.0</td><td align="left">210.0</td><td align="left"><bold>9.7</bold></td><td align="left">48.1</td></tr></tbody></table><table-wrap-foot><p>CPU time is in hours and the memory in GB. The best results are in bold</p></table-wrap-foot></table-wrap>
</p>
    </sec>
    <sec id="Sec13">
      <title>Sensitivity variations</title>
      <p>As we have described above, we use a more precise evaluation compared to the one of Berlin et al. [<xref ref-type="bibr" rid="CR11">11</xref>]. As a result the programs exhibit a decrease in sensitivity. It is therefore interesting to compare our procedure with the one of Berlin et al. [<xref ref-type="bibr" rid="CR11">11</xref>]. In Table <xref rid="Tab4" ref-type="table">4</xref>, four ways of evaluating the sensitivity are compared. In our evaluation we check for precise bounds of the alignment; this is given in the rows labelled as “bounds” in the table. We can relax this condition by checking only the length of the alignment; labelled as “length” in the table, this is the closest to the procedure of Berlin et al.. Finally, the weakest check we can have is simply for the “presence” of an alignment between the reads. While there are differences among all these sensitivity modes, HISEA remains clearly the first, followed by DALIGNER and MHAP, and then at some distance by the other three programs. It is interesting to note the very high sensitivity of DALIGNER in the “presence” only scenario.
<table-wrap id="Tab4"><label>Table 4</label><caption><p>Comparison of several types of sensitivity computations on the 1Gbp datasets</p></caption><table frame="hsides" rules="groups"><tbody><tr><td align="left" colspan="2"><inline-graphic xlink:href="12859_2017_1953_Figh_HTML.gif" id="d29e2123"/></td></tr></tbody></table><table-wrap-foot><p>For each dataset, four types of sensitivity computations are used: “presence” only checks for the read pair, “length” also checks the correct length, “bounds” checks for correct alignment bounds (the one used in this paper), and the last one is from Berlin et al. [<xref ref-type="bibr" rid="CR11">11</xref>]</p></table-wrap-foot></table-wrap>
</p>
    </sec>
    <sec id="Sec14">
      <title>MHAP sketch size and Minimap minimizers</title>
      <p>Both MHAP and Minimap can have their parameters adjust to improve sensitivity. We investigate here this effect.</p>
      <p>MHAP uses a technique called MinHash [<xref ref-type="bibr" rid="CR14">14</xref>] in order to compute the overlaps. MinHash reduces a string to a set of fingerprints, called sketch. It is clear that using a larger sketch increases the sensitivity at the cost of speed decrease. Given the excellent speed of MHAP, it is worth investigating the effect of this parameter. Note that we already tested sketch size 1256 instead of the default 512, for improved sensitivity. Table <xref rid="Tab5" ref-type="table">5</xref> shows the results for sketch size increased with increments of 512 from 1256 to 3816. The sensitivity increases slightly but never comes close to that of HISEA. Also, precision decreases and so the <italic>F</italic>
<sub>1</sub>-score increases very little (or decreases dramatically, as it happens for <italic>C.elegans</italic>). Also, the running time increases up to 10 times when changing sketch size from 1256 to 3816. Overall, increasing the sketch size is clearly not improving the performance of MHAP.
<table-wrap id="Tab5"><label>Table 5</label><caption><p>Testing larger sketch sizes for MHAP. Starting with the value we have used for testing, 1256, the sketch size is increased with increments of 512 up to 3816</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Genome</th><th align="left">Parameter</th><th align="left" colspan="6">MHAP skecth size</th></tr></thead><tbody><tr><td align="left"/><td align="left"/><td align="left">1256</td><td align="left">1768</td><td align="left">2280</td><td align="left">2792</td><td align="left">3304</td><td align="left">3816</td></tr><tr><td align="left"><italic>E.coli</italic></td><td align="left">Sensitivity</td><td align="left">83.74</td><td align="left">85.75</td><td align="left">86.52</td><td align="left">86.87</td><td align="left">87.05</td><td align="left">87.16</td></tr><tr><td align="left"/><td align="left">Specificity</td><td align="left">99.90</td><td align="left">99.86</td><td align="left">99.84</td><td align="left">99.82</td><td align="left">99.81</td><td align="left">99.80</td></tr><tr><td align="left"/><td align="left">Precision</td><td align="left">97.15</td><td align="left">96.99</td><td align="left">96.82</td><td align="left">96.89</td><td align="left">96.88</td><td align="left">97.70</td></tr><tr><td align="left"/><td align="left">F1-score</td><td align="left">89.95</td><td align="left">91.02</td><td align="left">91.38</td><td align="left">91.61</td><td align="left">91.70</td><td align="left">92.13</td></tr><tr><td align="left"><italic>S.cerevisiae</italic></td><td align="left">Sensitivity</td><td align="left">62.08</td><td align="left">63.67</td><td align="left">64.32</td><td align="left">64.52</td><td align="left">64.62</td><td align="left">64.69</td></tr><tr><td align="left"/><td align="left">Specificity</td><td align="left">99.77</td><td align="left">99.72</td><td align="left">99.66</td><td align="left">99.63</td><td align="left">99.58</td><td align="left">99.56</td></tr><tr><td align="left"/><td align="left">Precision</td><td align="left">89.29</td><td align="left">88.79</td><td align="left">88.69</td><td align="left">88.62</td><td align="left">88.55</td><td align="left">88.30</td></tr><tr><td align="left"/><td align="left">F1-score</td><td align="left">73.24</td><td align="left">74.16</td><td align="left">74.56</td><td align="left">74.67</td><td align="left">74.72</td><td align="left">74.67</td></tr><tr><td align="left"><italic>C.elegans</italic></td><td align="left">Sensitivity</td><td align="left">80.43</td><td align="left">81.81</td><td align="left">82.37</td><td align="left">82.62</td><td align="left">82.69</td><td align="left">82.73</td></tr><tr><td align="left"/><td align="left">Specificity</td><td align="left">99.97</td><td align="left">99.93</td><td align="left">99.90</td><td align="left">99.88</td><td align="left">99.85</td><td align="left">99.82</td></tr><tr><td align="left"/><td align="left">Precision</td><td align="left">45.46</td><td align="left">35.71</td><td align="left">29.32</td><td align="left">25.80</td><td align="left">23.75</td><td align="left">22.13</td></tr><tr><td align="left"/><td align="left">F1-score</td><td align="left">58.09</td><td align="left">49.72</td><td align="left">43.25</td><td align="left">39.32</td><td align="left">36.90</td><td align="left">34.92</td></tr><tr><td align="left"><italic>A.thaliana</italic></td><td align="left">Sensitivity</td><td align="left">76.19</td><td align="left">77.05</td><td align="left">77.38</td><td align="left">77.49</td><td align="left">77.55</td><td align="left">77.57</td></tr><tr><td align="left"/><td align="left">Specificity</td><td align="left">99.91</td><td align="left">99.87</td><td align="left">99.86</td><td align="left">99.85</td><td align="left">99.84</td><td align="left">99.83</td></tr><tr><td align="left"/><td align="left">Precision</td><td align="left">88.78</td><td align="left">88.50</td><td align="left">88.68</td><td align="left">88.35</td><td align="left">88.55</td><td align="left">88.33</td></tr><tr><td align="left"/><td align="left">F1-score</td><td align="left">82.00</td><td align="left">82.38</td><td align="left">82.65</td><td align="left">82.56</td><td align="left">82.69</td><td align="left">82.60</td></tr><tr><td align="left"><italic>D.melanogaster</italic></td><td align="left">Sensitivity</td><td align="left">71.86</td><td align="left">73.36</td><td align="left">73.89</td><td align="left">74.12</td><td align="left">74.24</td><td align="left">74.30</td></tr><tr><td align="left"/><td align="left">Specificity</td><td align="left">99.94</td><td align="left">99.92</td><td align="left">99.91</td><td align="left">99.88</td><td align="left">99.87</td><td align="left">99.86</td></tr><tr><td align="left"/><td align="left">Precision</td><td align="left">72.47</td><td align="left">72.00</td><td align="left">72.07</td><td align="left">72.46</td><td align="left">71.45</td><td align="left">71.62</td></tr><tr><td align="left"/><td align="left">F1-score</td><td align="left">72.16</td><td align="left">72.67</td><td align="left">72.97</td><td align="left">73.28</td><td align="left">72.82</td><td align="left">72.94</td></tr></tbody></table><table-wrap-foot><p>Note that the results for the first column (sketch size 1256) appear also in Table <xref rid="Tab2" ref-type="table">2</xref>. They are repeated here for comparison convenience</p></table-wrap-foot></table-wrap>
</p>
      <p>Similarly, the sensitivity of Minimap can be increased by using more minimizers. A minimizer is the smallest <italic>k</italic>-mer in a window of <italic>w</italic> consecutive <italic>k</italic>-mers. The default value is <italic>w</italic>=10 but the recommended value by the designers for all-vs-all PacBio read self-mapping is <italic>w</italic>=5 and this is what we used in our tests. We have investigated the effect of increasing the number of minimizers by decreasing <italic>w</italic>. The results are presented in Table <xref rid="Tab6" ref-type="table">6</xref>. The improvement is more significant for Minimap but it starts from lower values. The improved performance is still far from the top programs.
<table-wrap id="Tab6"><label>Table 6</label><caption><p>Testing higher number of minimizers for Minimap. Starting with the value we have used for testing, <italic>w</italic>=5, we increase the number of minimizers by decreasing <italic>w</italic> all the way to the smallest value <italic>w</italic>=1. Note that the results for the first column (<italic>w</italic>=5) appear also in Table <xref rid="Tab2" ref-type="table">2</xref>. They are repeated here for comparison convenience</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Genome</th><th align="left">Parameter</th><th align="left" colspan="5">Minimap window size</th></tr><tr><th align="left"/><th align="left"/><th align="left">5</th><th align="left">4</th><th align="left">3</th><th align="left">2</th><th align="left">1</th></tr></thead><tbody><tr><td align="left"><italic>E.coli</italic></td><td align="left">Sensitivity</td><td align="left">91.80</td><td align="left">93.08</td><td align="left">94.13</td><td align="left">95.24</td><td align="left">96.29</td></tr><tr><td align="left"/><td align="left">Specificity</td><td align="left">99.93</td><td align="left">99.92</td><td align="left">99.93</td><td align="left">99.92</td><td align="left">99.91</td></tr><tr><td align="left"/><td align="left">Precision</td><td align="left">97.13</td><td align="left">97.22</td><td align="left">97.42</td><td align="left">97.51</td><td align="left">97.58</td></tr><tr><td align="left"/><td align="left">F1-score</td><td align="left">94.39</td><td align="left">95.10</td><td align="left">95.75</td><td align="left">96.36</td><td align="left">96.93</td></tr><tr><td align="left"><italic>S.cerevisiae</italic></td><td align="left">Sensitivity</td><td align="left">9.35</td><td align="left">9.64</td><td align="left">9.94</td><td align="left">10.36</td><td align="left">11.00</td></tr><tr><td align="left"/><td align="left">Specificity</td><td align="left">99.98</td><td align="left">99.98</td><td align="left">99.97</td><td align="left">99.97</td><td align="left">99.97</td></tr><tr><td align="left"/><td align="left">Precision</td><td align="left">94.30</td><td align="left">94.18</td><td align="left">93.28</td><td align="left">91.90</td><td align="left">88.58</td></tr><tr><td align="left"/><td align="left">F1-score</td><td align="left">17.01</td><td align="left">17.49</td><td align="left">17.97</td><td align="left">18.62</td><td align="left">19.57</td></tr><tr><td align="left"><italic>C.elegans</italic></td><td align="left">Sensitivity</td><td align="left">85.38</td><td align="left">86.63</td><td align="left">87.63</td><td align="left">88.77</td><td align="left">89.80</td></tr><tr><td align="left"/><td align="left">Specificity</td><td align="left">99.98</td><td align="left">99.98</td><td align="left">99.98</td><td align="left">99.98</td><td align="left">99.97</td></tr><tr><td align="left"/><td align="left">Precision</td><td align="left">89.80</td><td align="left">89.77</td><td align="left">89.05</td><td align="left">88.11</td><td align="left">85.76</td></tr><tr><td align="left"/><td align="left">F1-score</td><td align="left">87.53</td><td align="left">88.17</td><td align="left">88.33</td><td align="left">88.44</td><td align="left">87.73</td></tr><tr><td align="left"><italic>A.thaliana</italic></td><td align="left">Sensitivity</td><td align="left">23.55</td><td align="left">26.90</td><td align="left">31.21</td><td align="left">37.08</td><td align="left">45.56</td></tr><tr><td align="left"/><td align="left">Specificity</td><td align="left">99.97</td><td align="left">99.98</td><td align="left">99.96</td><td align="left">99.96</td><td align="left">99.96</td></tr><tr><td align="left"/><td align="left">Precision</td><td align="left">84.00</td><td align="left">84.77</td><td align="left">85.48</td><td align="left">86.43</td><td align="left">87.94</td></tr><tr><td align="left"/><td align="left">F1-score</td><td align="left">36.79</td><td align="left">40.84</td><td align="left">45.73</td><td align="left">51.90</td><td align="left">60.02</td></tr><tr><td align="left"><italic>D.melanogaster</italic></td><td align="left">Sensitivity</td><td align="left">40.72</td><td align="left">42.82</td><td align="left">45.51</td><td align="left">49.11</td><td align="left">54.00</td></tr><tr><td align="left"/><td align="left">Specificity</td><td align="left">99.99</td><td align="left">99.98</td><td align="left">99.98</td><td align="left">99.98</td><td align="left">99.97</td></tr><tr><td align="left"/><td align="left">Precision</td><td align="left">83.93</td><td align="left">83.12</td><td align="left">82.87</td><td align="left">81.85</td><td align="left">81.25</td></tr><tr><td align="left"/><td align="left">F1-score</td><td align="left">54.84</td><td align="left">56.52</td><td align="left">58.75</td><td align="left">61.39</td><td align="left">64.88</td></tr></tbody></table></table-wrap>
</p>
    </sec>
    <sec id="Sec15">
      <title>Sensitivity vs overlap size</title>
      <p>It is easier to find long overlaps with correct bounds compared to short overlaps. We have plotted in Fig. <xref rid="Fig3" ref-type="fig">3</xref> the aligners’ sensitivity as a function of overlap length. The sensitivity increases with the overlap length for all aligners except DALIGNER. The sensitivity of HISEA remains very high for both short and long overlaps and it improves with longer overlap lengths. MHAP shows a similar trend but its sensitivity for short overlaps is low. BLASR, Minimap, and GraphMap seem to have been optimized for more recent chemistry; note the very low performance on the oldest chemistry P4C2 datasets.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Sensitivity as a function of mean overlap length</p></caption><graphic xlink:href="12859_2017_1953_Fig3_HTML" id="MO9"/></fig>
</p>
    </sec>
    <sec id="Sec16">
      <title>HISEA vs MHAP</title>
      <p>Since sensitivity is the most important parameter, as long as the difference in precision is not too large, we compare for the remaining tests only the top two programs, HISEA and MHAP. It turns out that the way MHAP is run within the Canu assembly pipeline is different from running it in stand alone mode. Therefore, we are comparing again the sensitivity, specificity and precision of the alignment produced by the two programs, this time while run in the pipeline mode.</p>
      <p>We consider the same datasets as above but with higher coverage: 30x and 50x. As mentioned by Koren et al. [<xref ref-type="bibr" rid="CR6">6</xref>], Canu+MHAP pipeline reaches the best assemblies around 50x coverage. Our goal is to produce similar quality assemblies with only 30x coverage. The 30x and 50x coverage datasets were sampled using the utility <italic>fastqSample</italic> available from the Canu pipeline [<xref ref-type="bibr" rid="CR6">6</xref>].</p>
      <p>The alignments computed by MHAP and HISEA while run in the Canu pipeline were extracted and analyzed as above. The results are shown in Table <xref rid="Tab7" ref-type="table">7</xref>. HISEA has better sensitivity, precision, and <italic>F</italic>
<sub>1</sub> score in all tests with very large differences for the 50x coverage datasets. The specificity of both programs is very high for all tests, with HISEA edging ahead for 30x coverage and MHAP for 50x.
<table-wrap id="Tab7"><label>Table 7</label><caption><p>Sensitivity, specificity, precision, and <italic>F</italic>
<sub>1</sub>-score for HISEA and MHAP program output within the Canu pipeline</p></caption><table frame="hsides" rules="groups"><tbody><tr><td align="left" colspan="2"><inline-graphic xlink:href="12859_2017_1953_Figi_HTML.gif" id="d29e3275"/></td></tr></tbody></table><table-wrap-foot><p>Two coverage levels are considered for each dataset: 30x and 50x. The best values are shown in bold. The bottom of the table shows the average values, each computed from the five corresponding values in the table. All values are percentages</p></table-wrap-foot></table-wrap>
</p>
    </sec>
    <sec id="Sec17">
      <title>Assembly comparison</title>
      <p>We have integrated the HISEA program in the Canu assembly pipeline, which is currently the best. Our alignment output is similar to the M4 format used by BLASR and MHAP programs<xref ref-type="fn" rid="Fn1">1</xref>. HISEA can also be integrated in other assembly pipelines, e.g., Miniasm [<xref ref-type="bibr" rid="CR5">5</xref>] and Falcon [<xref ref-type="bibr" rid="CR7">7</xref>], by converting HISEA output to the format required by these pipelines.</p>
      <p>We have assembled the 30x and 50x coverage datasets that we tested above for quality of alignments. The assemblies produced by the two pipelines, Canu+MHAP and Canu+HISEA, have been evaluated using a modified version of our LASER program [<xref ref-type="bibr" rid="CR15">15</xref>], which is a fast implementation of QUAST [<xref ref-type="bibr" rid="CR16">16</xref>] using E-MEM [<xref ref-type="bibr" rid="CR17">17</xref>]. The recent versions of QUAST use E-MEM [<xref ref-type="bibr" rid="CR17">17</xref>] for speed improvement but LASER [<xref ref-type="bibr" rid="CR15">15</xref>] has several other modifications that make it still faster.</p>
      <p>LASER/QUAST compute many parameters for each assembly and the most important ones are presented in Table <xref rid="Tab8" ref-type="table">8</xref>: the number of contigs, NG50, the maximum contig size, the fraction of the genome covered by the assembly, the identity with the reference, and the number of breakpoints (inversions, relocations, and translocations). The Canu+HISEA pipeline has better values in 80% of the tests for the number of contigs, NG50, max contig size, and genome fraction. Generally, the NG50 value for the Canu+HISEA assemblies is much larger than that of the Canu+MHAP ones. Canu+MHAP has fewer breakpoints more often than Canu+HISEA but the difference is usually small. Both pipelines have high identity with the reference. Overall, the assemblies computed by the Canu+HISEA pipeline are better. Moreover, the assemblies computed by Canu+HISEA for 30x coverage are comparable with those produced by Canu+MHAP for 50x coverage. MUMmer plots of all Canu+HISEA assemblies are included in the Additional file <xref rid="MOESM1" ref-type="media">1</xref>.
<table-wrap id="Tab8"><label>Table 8</label><caption><p>Pipeline assembly comparison; Canu assembler is used with MHAP and HISEA as read aligners</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Genome</th><th align="left">Parameter</th><th align="left" colspan="2">Canu + MHAP</th><th align="left" colspan="2">Canu + HISEA</th></tr><tr><th align="left"/><th align="left"/><th align="left">30x</th><th align="left">50x</th><th align="left">30x</th><th align="left">50x</th></tr></thead><tbody><tr><td align="left"><italic>E.coli</italic></td><td align="left">Contig #</td><td align="left"><bold>7</bold></td><td align="left">3</td><td align="left">8</td><td align="left"><bold>1</bold></td></tr><tr><td align="left"/><td align="left">NG50</td><td align="left"><bold>2,771,323</bold></td><td align="left">3,969,196</td><td align="left">1,223,211</td><td align="left"><bold>4,642,165</bold></td></tr><tr><td align="left"/><td align="left">Max contig</td><td align="left"><bold>2,771,323</bold></td><td align="left">3,969,196</td><td align="left">1,525,215</td><td align="left"><bold>4,642,165</bold></td></tr><tr><td align="left"/><td align="left">% Ref</td><td align="left"><bold>99.85</bold></td><td align="left">99.97</td><td align="left">99.82</td><td align="left"><bold>100.00</bold></td></tr><tr><td align="left"/><td align="left">Avg idy</td><td align="left"><bold>99.97</bold></td><td align="left"><bold>99.99</bold></td><td align="left"><bold>99.97</bold></td><td align="left"><bold>99.99</bold></td></tr><tr><td align="left"/><td align="left">Breakpoints</td><td align="left"><bold>3</bold></td><td align="left"><bold>3</bold></td><td align="left"><bold>3</bold></td><td align="left"><bold>3</bold></td></tr><tr><td align="left"><italic>S.cerevisiae</italic></td><td align="left">Contig #</td><td align="left">43</td><td align="left">31</td><td align="left"><bold>35</bold></td><td align="left"><bold>29</bold></td></tr><tr><td align="left"/><td align="left">NG50</td><td align="left">540,299</td><td align="left">687,498</td><td align="left"><bold>682,168</bold></td><td align="left"><bold>774,485</bold></td></tr><tr><td align="left"/><td align="left">Max contig</td><td align="left">964,505</td><td align="left">1,534,125</td><td align="left"><bold>1,537,586</bold></td><td align="left"><bold>1,534,133</bold></td></tr><tr><td align="left"/><td align="left">% Ref</td><td align="left">98.90</td><td align="left">99.35</td><td align="left"><bold>99.12</bold></td><td align="left"><bold>99.58</bold></td></tr><tr><td align="left"/><td align="left">Avg idy</td><td align="left">99.81</td><td align="left"><bold>99.88</bold></td><td align="left"><bold>99.82</bold></td><td align="left"><bold>99.88</bold></td></tr><tr><td align="left"/><td align="left">Breakpoints</td><td align="left"><bold>17</bold></td><td align="left"><bold>14</bold></td><td align="left"><bold>17</bold></td><td align="left"><bold>14</bold></td></tr><tr><td align="left"><italic>C.elegans</italic></td><td align="left">Contig #</td><td align="left">393</td><td align="left">170</td><td align="left"><bold>127</bold></td><td align="left"><bold>133</bold></td></tr><tr><td align="left"/><td align="left">NG50</td><td align="left">636,401</td><td align="left">1,987,017</td><td align="left"><bold>2,140,282</bold></td><td align="left"><bold>2,032,954</bold></td></tr><tr><td align="left"/><td align="left">Max contig</td><td align="left">2,648,207</td><td align="left">4,224,025</td><td align="left"><bold>4,227,561</bold></td><td align="left"><bold>5,669,072</bold></td></tr><tr><td align="left"/><td align="left">% Ref</td><td align="left">96.00</td><td align="left"><bold>99.84</bold></td><td align="left"><bold>99.81</bold></td><td align="left">99.80</td></tr><tr><td align="left"/><td align="left">Avg idy</td><td align="left">99.76</td><td align="left"><bold>99.91</bold></td><td align="left"><bold>99.85</bold></td><td align="left"><bold>99.91</bold></td></tr><tr><td align="left"/><td align="left">Breakpoints</td><td align="left">431</td><td align="left"><bold>423</bold></td><td align="left"><bold>390</bold></td><td align="left">435</td></tr><tr><td align="left"><italic>A.thaliana</italic></td><td align="left">Contig #</td><td align="left">159</td><td align="left"><bold>99</bold></td><td align="left"><bold>140</bold></td><td align="left">122</td></tr><tr><td align="left"/><td align="left">NG50</td><td align="left">3,331,858</td><td align="left">6,715,370</td><td align="left"><bold>5,069,662</bold></td><td align="left"><bold>8,124,422</bold></td></tr><tr><td align="left"/><td align="left">Max contig</td><td align="left"><bold>12,892,206</bold></td><td align="left">14,177,369</td><td align="left">12,890,806</td><td align="left"><bold>15,940,320</bold></td></tr><tr><td align="left"/><td align="left">% Ref</td><td align="left">92.22</td><td align="left"><bold>92.55</bold></td><td align="left"><bold>92.37</bold></td><td align="left">92.51</td></tr><tr><td align="left"/><td align="left">Avg idy</td><td align="left"><bold>99.17</bold></td><td align="left"><bold>99.22</bold></td><td align="left"><bold>99.17</bold></td><td align="left"><bold>99.22</bold></td></tr><tr><td align="left"/><td align="left">Breakpoints</td><td align="left"><bold>2,550</bold></td><td align="left"><bold>2,693</bold></td><td align="left">2,680</td><td align="left">2,704</td></tr><tr><td align="left"><italic>D.melanogaster</italic></td><td align="left">Contig #</td><td align="left">597</td><td align="left">390</td><td align="left"><bold>553</bold></td><td align="left"><bold>372</bold></td></tr><tr><td align="left"/><td align="left">NG50</td><td align="left">1,933,939</td><td align="left">4,983,913</td><td align="left"><bold>6,417,268</bold></td><td align="left"><bold>13,672,005</bold></td></tr><tr><td align="left"/><td align="left">Max contig</td><td align="left">8,238,062</td><td align="left">17,900,724</td><td align="left"><bold>17,366,974</bold></td><td align="left"><bold>25,767,672</bold></td></tr><tr><td align="left"/><td align="left">% Ref</td><td align="left">95.08</td><td align="left">98.55</td><td align="left"><bold>96.47</bold></td><td align="left"><bold>98.65</bold></td></tr><tr><td align="left"/><td align="left">Avg idy</td><td align="left"><bold>99.80</bold></td><td align="left"><bold>99.89</bold></td><td align="left"><bold>99.80</bold></td><td align="left">99.87</td></tr><tr><td align="left"/><td align="left">Breakpoints</td><td align="left"><bold>1,039</bold></td><td align="left"><bold>1,383</bold></td><td align="left">1,254</td><td align="left">1,461</td></tr></tbody></table><table-wrap-foot><p>Two coverage levels, 30x and 50x, are used for each genome. The best results are shown in bold</p></table-wrap-foot></table-wrap>
</p>
      <p>The MHAP program is very fast and it makes the Canu+MHAP pipeline faster, as seen from the time values shown in Table <xref rid="Tab9" ref-type="table">9</xref>. However, as noticed above, similar assemblies are produced by Canu+HISEA for 30x coverage, and those are always faster than those by Canu+MHAP for 50x coverage. The memory consumption is always much lower for the Canu+HISEA pipeline. Note that in Table <xref rid="Tab9" ref-type="table">9</xref> the times are reported as wall clock times, since CPU times for the fraction used by the overlapping programs are not available. Also, only the peak memory used by the entire assembly pipeline is available.
<table-wrap id="Tab9"><label>Table 9</label><caption><p>Assembly time and space comparison; the time is wall clock time in hours, the space is in GB</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Genome</th><th align="left" colspan="4">Canu + MHAP</th><th align="left" colspan="2">MHAP</th><th align="left" colspan="4">Canu + HISEA</th><th align="left" colspan="2">HISEA</th></tr></thead><tbody><tr><td align="left"/><td align="center" colspan="2">30x</td><td align="center" colspan="2">50x</td><td align="center">30x</td><td align="center">50x</td><td align="center" colspan="2">30x</td><td align="center" colspan="2">50x</td><td align="center">30x</td><td align="center">50x</td></tr><tr><td align="left"/><td align="left">Time</td><td align="left">Space</td><td align="left">Time</td><td align="left">Space</td><td align="left">Time</td><td align="left">Time</td><td align="left">Time</td><td align="left">Space</td><td align="left">Time</td><td align="left">Space</td><td align="left">Time</td><td align="left">Time</td></tr><tr><td align="left"><italic>E.coli</italic></td><td align="left"><bold>0.4</bold></td><td align="left">210</td><td align="left"><bold>0.6</bold></td><td align="left">210</td><td align="left"><bold>0.1</bold></td><td align="left"><bold>0.1</bold></td><td align="left"><bold>0.4</bold></td><td align="left"><bold>25</bold></td><td align="left">0.7</td><td align="left"><bold>40</bold></td><td align="left"><bold>0.1</bold></td><td align="left"><bold>0.1</bold></td></tr><tr><td align="left"><italic>S.cerevisiae</italic></td><td align="left"><bold>1.1</bold></td><td align="left">210</td><td align="left"><bold>2.0</bold></td><td align="left">210</td><td align="left">0.3</td><td align="left"><bold>0.4</bold></td><td align="left">1.2</td><td align="left"><bold>63</bold></td><td align="left">2.9</td><td align="left"><bold>76</bold></td><td align="left">0.2</td><td align="left">0.6</td></tr><tr><td align="left"><italic>C.elegans</italic></td><td align="left"><bold>24.5</bold></td><td align="left">210</td><td align="left"><bold>59.6</bold></td><td align="left">210</td><td align="left"><bold>2.4</bold></td><td align="left"><bold>2.5</bold></td><td align="left">37.7</td><td align="left"><bold>83</bold></td><td align="left">75.5</td><td align="left"><bold>82</bold></td><td align="left">11.5</td><td align="left">17.1</td></tr><tr><td align="left"><italic>A.thaliana</italic></td><td align="left"><bold>23.8</bold></td><td align="left">210</td><td align="left"><bold>56.6</bold></td><td align="left">210</td><td align="left"><bold>4.1</bold></td><td align="left"><bold>9.6</bold></td><td align="left">42.3</td><td align="left"><bold>90</bold></td><td align="left">98.0</td><td align="left"><bold>90</bold></td><td align="left">15.3</td><td align="left">35.0</td></tr><tr><td align="left"><italic>D.melanogaster</italic></td><td align="left"><bold>27.0</bold></td><td align="left">210</td><td align="left"><bold>62.4</bold></td><td align="left">210</td><td align="left"><bold>3.4</bold></td><td align="left"><bold>5.2</bold></td><td align="left">51.8</td><td align="left"><bold>94</bold></td><td align="left">112.8</td><td align="left"><bold>94</bold></td><td align="left">19.7</td><td align="left">33.6</td></tr></tbody></table><table-wrap-foot><p>The same setup as in Table <xref rid="Tab8" ref-type="table">8</xref> is used. The best values are in bold</p></table-wrap-foot></table-wrap>
</p>
      <p>The <italic>java</italic> command-line parameter <italic>-Xmx</italic> is used to set the maximum heap size during MHAP invocation from the pipeline. The value of parameter <italic>-Xmx</italic> is set by <italic>corMhapMemory</italic> pipeline parameter which is user configurable. For this evaluation, the value of parameter <italic>corMhapMemory</italic> is set to 200 Gb for all datasets. The peak memory in each case is reported as 210 Gb. Similar configuration for Canu+HISEA pipeline uses much smaller memory footprint (less than 100 Gb) for all datasets.</p>
      <p>The Canu+MHAP pipeline requires more memory in all cases, as seen from the space values shown in Table <xref rid="Tab9" ref-type="table">9</xref>. The peak memory of this pipeline can be reduced by setting a smaller value for <italic>corMhapMemory</italic>. However, it impacts the overall assembly runtime. Similar behavior is expected in modified Canu+HISEA pipeline. To ensure unbiased evaluation, all parameter values are identical for both pipelines.</p>
    </sec>
  </sec>
  <sec id="Sec18" sec-type="discussion">
    <title>Discussion</title>
    <p>The newly introduced HISEA program has been thoroughly tested against several state-of-the-art programs and shown to perform better. HISEA has higher sensitivity, precision, and F1-score. Two competing programs, MHAP and Minimap, have parameters that can be tuned for a trade-off between speed and sensitivity. We pushed both to the limit of their sensitivity and that is still clearly lower than the sensitivity of HISEA. Since we introduced a new, more precise, evaluation of sensitivity, we compared also the programs with respect to the old method of computing sensitivity, as well as two other natural ways. HISEA has the highest sensitivity with respect to all four sensitivity modes. The closest competitor is MHAP and we compared the two programs further, from the point of view of genome assembly. HISEA is significantly more sensitive and produces better genome assemblies in the Canu pipeline.</p>
  </sec>
  <sec id="Sec19" sec-type="conclusion">
    <title>Conclusion</title>
    <p>Pacific Biosciences SMRT technology is a relatively new sequencing method that produces long but noisy reads. The aligners developed for previous sequencing methods do not perform well on this type of data. Our new HISEA algorithm for computing read alignments has introduced several new ideas, such as clustering of <italic>k</italic>-mer matches, estimating and filtering of matches based on error rate, and techniques for extending the alignments with shorter <italic>k</italic>-mer matches.</p>
    <p>The HISEA algorithm currently produces alignments with highest sensitivity and comparable specificity with other algorithms. Integrated in the Canu pipeline [<xref ref-type="bibr" rid="CR6">6</xref>], currently the best for assembling PacBio data, it produces better assemblies than Canu+MHAP. Moreover, the assemblies of Canu+HISEA at lower coverage, 30x, are comparable with those of Canu+MHAP at 50x coverage, while being faster and cheaper. We plan to modify HISEA in the future to work also with Oxford Nanopore sequencing technology [<xref ref-type="bibr" rid="CR18">18</xref>]. The source code of the HISEA aligner and Canu+HISEA assembly pipeline are freely available from: <ext-link ext-link-type="uri" xlink:href="https://github.com/lucian-ilie/HISEA">https://github.com/lucian-ilie/HISEA</ext-link> and <ext-link ext-link-type="uri" xlink:href="https://github.com/lucian-ilie/Canu_HISEA">https://github.com/lucian-ilie/Canu_HISEA</ext-link>, respectively.</p>
  </sec>
</body>
<back>
  <app-group>
    <app id="App1">
      <sec id="Sec20">
        <title>Additional file</title>
        <p>
          <media position="anchor" xlink:href="12859_2017_1953_MOESM1_ESM.pdf" id="MOESM1">
            <label>Additional file 1</label>
            <caption>
              <p>The additional material contains information concerning downloading the datasets, the versions used for each competing program, download websites, and command lines. (PDF 412 kb)</p>
            </caption>
          </media>
        </p>
      </sec>
    </app>
  </app-group>
  <fn-group>
    <fn id="Fn1">
      <label>1</label>
      <p>
        <ext-link ext-link-type="uri" xlink:href="https://github.com/PacificBiosciences/blasr/wiki/Blasr-Output-Format">https://github.com/PacificBiosciences/blasr/wiki/Blasr-Output-Format</ext-link>
      </p>
    </fn>
    <fn>
      <p>
        <bold>Electronic supplementary material</bold>
      </p>
      <p>The online version of this article (doi:10.1186/s12859-017-1953-9) contains supplementary material, which is available to authorized users.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>Performance evaluation has been performed on our Shadowfax cluster, which is part of the Shared Hierarchical Academic Research Computing Network (SHARCNET: <ext-link ext-link-type="uri" xlink:href="http://www.sharcnet.ca">www.sharcnet.ca</ext-link>) and Compute/Calcul Canada.</p>
    <sec id="d29e4631">
      <title>Funding</title>
      <p>L.I. has been partially supported by a Discovery Grant and a Research Tools and Instruments Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC). N.K. has been partially supported by an Ontario Graduate Scholarship (OGS) in Science and Technology.</p>
    </sec>
    <sec id="d29e4636">
      <title>Availability of data and materials</title>
      <p>The source code of the HISEA aligner and Canu+HISEA assembly pipeline are freely available from: <ext-link ext-link-type="uri" xlink:href="https://github.com/lucian-ilie/HISEA">https://github.com/lucian-ilie/HISEA</ext-link>
and <ext-link ext-link-type="uri" xlink:href="https://github.com/lucian-ilie/Canu_HISEA">https://github.com/lucian-ilie/Canu_HISEA</ext-link>, respectively.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>L.I. proposed the problem and the hierarchical seed approach. N.K. and L.I. designed the HISEA algorithm. N.K implemented the HISEA algorithm, installed the competing programs and performed all tests and comparisons. N.K. wrote the manuscript that was reviewed by L.I. Both authors read and approved the final version of the manuscript.</p>
  </notes>
  <notes notes-type="COI-statement">
    <sec id="d29e4657">
      <title>Ethics approval and consent to participate</title>
      <p>Not applicable.</p>
    </sec>
    <sec id="d29e4662">
      <title>Consent for publication</title>
      <p>Not applicable.</p>
    </sec>
    <sec id="d29e4667">
      <title>Competing interests</title>
      <p>The authors declare that they have no competing interests.</p>
    </sec>
    <sec id="d29e4672">
      <title>Publisher’s Note</title>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </sec>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schatz</surname>
            <given-names>MC</given-names>
          </name>
          <name>
            <surname>Delcher</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Assembly of large genomes using second-generation sequencing</article-title>
        <source>Genome Res</source>
        <year>2010</year>
        <volume>20</volume>
        <issue>9</issue>
        <fpage>1165</fpage>
        <lpage>73</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.101360.109</pub-id>
        <?supplied-pmid 20508146?>
        <pub-id pub-id-type="pmid">20508146</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ross</surname>
            <given-names>MG</given-names>
          </name>
          <name>
            <surname>Russ</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Costello</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hollinger</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Lennon</surname>
            <given-names>NJ</given-names>
          </name>
          <name>
            <surname>Hegarty</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Nusbaum</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Jaffe</surname>
            <given-names>DB</given-names>
          </name>
        </person-group>
        <article-title>Characterizing and measuring bias in sequence data</article-title>
        <source>Genome Biol</source>
        <year>2013</year>
        <volume>14</volume>
        <issue>5</issue>
        <fpage>1</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2013-14-5-r51</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goodwin</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>McPherson</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>McCombie</surname>
            <given-names>WR</given-names>
          </name>
        </person-group>
        <article-title>Coming of age: ten years of next-generation sequencing technologies</article-title>
        <source>Nat Rev Genet</source>
        <year>2016</year>
        <volume>17</volume>
        <issue>6</issue>
        <fpage>333</fpage>
        <lpage>51</lpage>
        <pub-id pub-id-type="doi">10.1038/nrg.2016.49</pub-id>
        <?supplied-pmid 27184599?>
        <pub-id pub-id-type="pmid">27184599</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lam</surname>
            <given-names>KK</given-names>
          </name>
          <name>
            <surname>Khalak</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Tse</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Near-optimal assembly for shotgun sequencing with noisy reads</article-title>
        <source>BMC Bioinformatics</source>
        <year>2014</year>
        <volume>15</volume>
        <issue>Suppl 9</issue>
        <fpage>4</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-15-S9-S4</pub-id>
        <pub-id pub-id-type="pmid">24387046</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Minimap and miniasm: fast mapping and de novo assembly for noisy long sequences</article-title>
        <source>Bioinformatics</source>
        <year>2016</year>
        <volume>32</volume>
        <issue>14</issue>
        <fpage>2103</fpage>
        <lpage>10</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btw152</pub-id>
        <?supplied-pmid 27153593?>
        <pub-id pub-id-type="pmid">27153593</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <mixed-citation publication-type="other">Koren S, Walenz BP, Berlin K, Miller JR, Phillippy AM. Canu: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation. bioRxiv. 2016. 071282.</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <mixed-citation publication-type="other">Chin CS, Peluso P, Sedlazeck FJ, Nattestad M, Concepcion GT, Clum A, Dunn C, O’Malley R, Figueroa-Balderas R, Morales-Cruz A, et al. Phased diploid genome assembly with single molecule real-time sequencing. bioRxiv. 2016. 056887.</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chaisson</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Mapping single molecule sequencing reads using basic local alignment with successive refinement (BLASR): application and theory</article-title>
        <source>BMC Bioinformatics</source>
        <year>2012</year>
        <volume>13</volume>
        <issue>1</issue>
        <fpage>238</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-13-238</pub-id>
        <?supplied-pmid 22988817?>
        <pub-id pub-id-type="pmid">22988817</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Efficient local alignment discovery amongst noisy long reads</article-title>
        <source>International Workshop on Algorithms in Bioinformatics</source>
        <year>2014</year>
        <publisher-loc>Berlin</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sović</surname>
            <given-names>I</given-names>
          </name>
          <collab>Šikić M</collab>
          <name>
            <surname>Wilm</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Fenlon</surname>
            <given-names>SN</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Nagarajan</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Fast and sensitive mapping of nanopore sequencing reads with GraphMap</article-title>
        <source>Nat Commun</source>
        <year>2016</year>
        <volume>7</volume>
        <fpage>11307</fpage>
        <pub-id pub-id-type="doi">10.1038/ncomms11307</pub-id>
        <?supplied-pmid 27079541?>
        <pub-id pub-id-type="pmid">27079541</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Berlin</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Chin</surname>
            <given-names>CS</given-names>
          </name>
          <name>
            <surname>Drake</surname>
            <given-names>JP</given-names>
          </name>
          <name>
            <surname>Landolin</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <article-title>Assembling large genomes with single-molecule sequencing and locality-sensitive hashing</article-title>
        <source>Nat Biotechnol</source>
        <year>2015</year>
        <volume>33</volume>
        <issue>6</issue>
        <fpage>623</fpage>
        <lpage>30</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.3238</pub-id>
        <?supplied-pmid 26006009?>
        <pub-id pub-id-type="pmid">26006009</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Antipov</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Korobeynikov</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>McLean</surname>
            <given-names>JS</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
        </person-group>
        <article-title>hybridSPAdes: an algorithm for hybrid assembly of short and long reads</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>32</volume>
        <issue>7</issue>
        <fpage>1009</fpage>
        <lpage>15</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv688</pub-id>
        <?supplied-pmid 26589280?>
        <pub-id pub-id-type="pmid">26589280</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J Mol Biol</source>
        <year>1981</year>
        <volume>147</volume>
        <issue>1</issue>
        <fpage>195</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-2836(81)90087-5</pub-id>
        <?supplied-pmid 7265238?>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <mixed-citation publication-type="other">Broder AZ. On the resemblance and containment of documents. In: Compression and Complexity of Sequences 1997. Proceedings. IEEE: 1997. p. 21–9.</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Khiste</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Ilie</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>LASER: Large genome ASsembly EvaluatoR</article-title>
        <source>BMC Res Notes</source>
        <year>2015</year>
        <volume>8</volume>
        <issue>1</issue>
        <fpage>709</fpage>
        <pub-id pub-id-type="doi">10.1186/s13104-015-1682-y</pub-id>
        <?supplied-pmid 26601933?>
        <pub-id pub-id-type="pmid">26601933</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gurevich</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Saveliev</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Vyahhi</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>QUAST: quality assessment tool for genome assemblies</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <issue>8</issue>
        <fpage>1072</fpage>
        <lpage>5</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btt086</pub-id>
        <?supplied-pmid 23422339?>
        <pub-id pub-id-type="pmid">23422339</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Khiste</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Ilie</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>E-MEM: efficient computation of maximal exact matches for very large genomes</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <issue>4</issue>
        <fpage>509</fpage>
        <lpage>14</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu687</pub-id>
        <?supplied-pmid 25399029?>
        <pub-id pub-id-type="pmid">25399029</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schneider</surname>
            <given-names>GF</given-names>
          </name>
          <name>
            <surname>Dekker</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>DNA sequencing with nanopores</article-title>
        <source>Nat Biotechnol</source>
        <year>2012</year>
        <volume>30</volume>
        <issue>4</issue>
        <fpage>326</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.2181</pub-id>
        <?supplied-pmid 22491281?>
        <pub-id pub-id-type="pmid">22491281</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
