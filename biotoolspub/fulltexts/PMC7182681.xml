<?DTDIdentifier.IdentifierValue -//ES//DTD journal article DTD version 5.6.0//EN//XML?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName art560.dtd?>
<?SourceDTD.Version 5.6.0?>
<?ConverterInfo.XSLTName elsevier2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<?origin publisher?>
<?FILEmeta_HLY3806 xml ?>
<?FILEmain xml ?>
<?FILEmain pdf ?>
<?FILEgr001 jpg ?>
<?FILEgr002 jpg ?>
<?FILEgr003 jpg ?>
<?FILEgr004 jpg ?>
<?FILEgr005 jpg ?>
<?FILEgr006 jpg ?>
<?FILEgr007 jpg ?>
<?FILEgr008 jpg ?>
<?FILEgr009 jpg ?>
<?FILEgr010 jpg ?>
<?FILEgr011 jpg ?>
<?FILEgr012 jpg ?>
<?FILEgr013 jpg ?>
<?FILEgr014 jpg ?>
<?FILEgr015 jpg ?>
<?FILEgr016 jpg ?>
<?FILEgr017 jpg ?>
<?FILEgr018 jpg ?>
<?FILEgr019 jpg ?>
<?FILEgr020 jpg ?>
<?FILEgr021 jpg ?>
<?FILEgr022 jpg ?>
<?FILEgr023 jpg ?>
<?FILEgr024 jpg ?>
<?FILEgr025 jpg ?>
<?FILEgr026 jpg ?>
<?FILEsi1 svg ?>
<?FILEsi2 svg ?>
<?FILEsi3 svg ?>
<?FILEsi4 svg ?>
<?FILEsi5 svg ?>
<?FILEsi6 svg ?>
<?FILEsi7 svg ?>
<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Heliyon</journal-id>
    <journal-id journal-id-type="iso-abbrev">Heliyon</journal-id>
    <journal-title-group>
      <journal-title>Heliyon</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2405-8440</issn>
    <publisher>
      <publisher-name>Elsevier</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7182681</article-id>
    <article-id pub-id-type="publisher-id">S2405-8440(20)30651-4</article-id>
    <article-id pub-id-type="doi">10.1016/j.heliyon.2020.e03806</article-id>
    <article-id pub-id-type="publisher-id">e03806</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>PVC.js: visualizing C programs on web browsers for novices</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="au0010">
        <name>
          <surname>Ishizue</surname>
          <given-names>Ryosuke</given-names>
        </name>
        <email>ishizue@ruri.waseda.jp</email>
        <xref rid="aff0010" ref-type="aff">a</xref>
        <xref rid="cr0010" ref-type="corresp">⁎</xref>
      </contrib>
      <contrib contrib-type="author" id="au0020">
        <name>
          <surname>Sakamoto</surname>
          <given-names>Kazunori</given-names>
        </name>
        <xref rid="aff0010" ref-type="aff">a</xref>
        <xref rid="aff0020" ref-type="aff">b</xref>
        <xref rid="aff0030" ref-type="aff">c</xref>
      </contrib>
      <contrib contrib-type="author" id="au0030">
        <name>
          <surname>Washizaki</surname>
          <given-names>Hironori</given-names>
        </name>
        <xref rid="aff0010" ref-type="aff">a</xref>
        <xref rid="aff0020" ref-type="aff">b</xref>
        <xref rid="aff0040" ref-type="aff">d</xref>
        <xref rid="aff0050" ref-type="aff">e</xref>
      </contrib>
      <contrib contrib-type="author" id="au0040">
        <name>
          <surname>Fukazawa</surname>
          <given-names>Yoshiaki</given-names>
        </name>
        <xref rid="aff0010" ref-type="aff">a</xref>
      </contrib>
      <aff id="aff0010"><label>a</label>Department of Science and Engineering, Waseda University, Tokyo, Japan</aff>
      <aff id="aff0020"><label>b</label>National Institute of Informatics, Tokyo, Japan</aff>
      <aff id="aff0030"><label>c</label>WillBooster Inc., Tokyo, Japan</aff>
      <aff id="aff0040"><label>d</label>SYSTEM INFORMATION CO.,LTD., Tokyo, Japan</aff>
      <aff id="aff0050"><label>e</label>eXmotion Co., Ltd., Tokyo, Japan</aff>
    </contrib-group>
    <author-notes>
      <corresp id="cr0010"><label>⁎</label>Corresponding author. <email>ishizue@ruri.waseda.jp</email></corresp>
    </author-notes>
    <pub-date pub-type="pmc-release">
      <day>23</day>
      <month>4</month>
      <year>2020</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on <pub-date
						pub-type="epub">.-->
    <pub-date pub-type="collection">
      <month>4</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>23</day>
      <month>4</month>
      <year>2020</year>
    </pub-date>
    <volume>6</volume>
    <issue>4</issue>
    <elocation-id>e03806</elocation-id>
    <history>
      <date date-type="received">
        <day>16</day>
        <month>1</month>
        <year>2019</year>
      </date>
      <date date-type="rev-recd">
        <day>14</day>
        <month>12</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>15</day>
        <month>4</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2020 The Authors</copyright-statement>
      <copyright-year>2020</copyright-year>
      <license license-type="CC BY" xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).</license-p>
      </license>
    </permissions>
    <abstract id="ab0010">
      <p>Many researchers have proposed program visualization tools for memory management. Examples include state-of-the-art tools for C languages such as SeeC and Python Tutor (PT). However, three problems hinder the use of these and other tools: capability (P1), installability (P2), and usability (P3). (P1) Tools do not fully support dynamic memory allocation or File Input / Output (I/O) and Standard Input. (P2) Novice programmers often have difficulty installing SeeC due to its dependence on Clang and setting up an offline environment that uses PT. (P3) Revisualization of the modified source code in SeeC requires several steps. To alleviate these issues, we propose a new visualization tool called PlayVisualizerC.js (PVC.js). PVC.js, which is designed for novice C language programmers to provide solutions (S1–3) for P1–3. S1 offers complete support for dynamic memory allocation, standard I/O, and file I/O. S2 involves installation in a user web browser. This system is composed of JavaScript programs, including C language execution functions. S3 reduces the steps required for revisualization. To evaluate PVC.js, we conducted two experiments. The first experiment found that students using PVC solved a set of four programming tasks on average 1.7—times faster and with 19% more correct answers than those using SeeC. The second experiment found that PVC.js has a visualization performance equivalent to PT, and that PVC.js is more effective than existing general debugging tools for novices to understand programs in cases where the values of important variables change and the control flow is complicated.</p>
    </abstract>
    <abstract abstract-type="teaser" id="ab0020">
      <p>Science; C language; Browser application; Visualization</p>
    </abstract>
    <kwd-group id="kws0010">
      <title>Keywords</title>
      <kwd>Science</kwd>
      <kwd>C language</kwd>
      <kwd>Browser application</kwd>
      <kwd>Visualization</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec id="se0010">
    <label>1</label>
    <title>Introduction</title>
    <p id="pr0010">Various visualization techniques have been proposed to aid programmers in understanding the program execution status <xref rid="br0010" ref-type="bibr">[1]</xref>, <xref rid="br0020" ref-type="bibr">[2]</xref>, <xref rid="br0030" ref-type="bibr">[3]</xref>, <xref rid="br0040" ref-type="bibr">[4]</xref>, <xref rid="br0050" ref-type="bibr">[5]</xref>.<xref rid="fn0010" ref-type="fn">1</xref> Most existing debuggers and integrated development environments such as GDB and Eclipse provide limited features to visualize the program execution status. Typically, these applications display simple text outputs, but do not visualize the relationships between variables, pointers, and memory. Learning how to use these tools is often difficult for novice programmers (hereafter referred to as novices).<xref rid="fn0020" ref-type="fn">2</xref> Instead of enhancing the understanding of programming languages, these tools often hinder novices.</p>
    <p id="pr0020">C programming language (C language) is popular and is typically one of the first languages learned by novices. However, mastery of C language requires that users learn a basic but difficult-to-grasp concept of memory management, including pointers and dynamic memory allocation. This can be extremely challenging for novices <xref rid="br0080" ref-type="bibr">[8]</xref>, <xref rid="br0090" ref-type="bibr">[9]</xref>, <xref rid="br0100" ref-type="bibr">[10]</xref>.</p>
    <p id="pr0030">To assist novices, previous studies have proposed tools to visualize the program execution status <xref rid="br0110" ref-type="bibr">[11]</xref>, <xref rid="br0120" ref-type="bibr">[12]</xref>, <xref rid="br0130" ref-type="bibr">[13]</xref>, <xref rid="br0140" ref-type="bibr">[14]</xref>. For example, SeeC and Python Tutor (PT) are state-of-the-art tools that effectively visualize C programs. However, three problems affect these and other tools: <bold>capability (P1), installability (P2), and usability (P3). (P1)</bold> SeeC does not fully support dynamic memory allocation. It displays the size of the allocated memory in bytes, but omits more detailed memory values. PT does not support file Input / Output (I/O) and standard Input. <bold>(P2)</bold> It is difficult for novices to install SeeC due to its dependency on Clang, a compiler. Moreover, students struggle to use PT in an offline environment, and teachers must setup PT for C language on their computer. <bold>(P3)</bold> SeeC is a desktop application consisting of a compiler and a visualizer. Users cannot modify the source code during SeeC's visualization. Thus, SeeC requires many steps to modify and revisualize C programs. PT does not have this problem because it is a web application running on a browser window.</p>
    <p id="pr0040">To solve <bold>P1–3</bold>, we propose PlayVisualizerC.js (PVC.js). PVC.js is an interpreter of C languages and has features to visualize the program execution status. It provides three solutions <bold>(S1–3)</bold> to the aforementioned problems. <bold>(S1)</bold> PVC.js can fully visualize variables, pointers, arrays, dynamically allocated memory, and their relationships. It supports standard I/O and file I/O. <bold>(S2)</bold> PVC.js is implemented as a JavaScript application that works in a browser without a web server. Thus, installation requires only a browser. It does not require a web server or an online environment. <bold>(S3)</bold> PVC.js allows users to revisualize a program after source code modifications using a single button click.</p>
    <p id="pr0050">The novel contributions of this paper are as follows:<list list-type="simple" id="ls0010"><list-item id="li0010"><label>1)</label><p id="pr0060">PVC.js can help novices understand the program execution status and behaviors.</p></list-item><list-item id="li0020"><label>2)</label><p id="pr0070">PVC.js can be used immediately after downloading from <ext-link ext-link-type="uri" xlink:href="https://github.com/RYOSKATE/PlayVisualizerC.js" id="inf0010">https://github.com/RYOSKATE/PlayVisualizerC.js</ext-link>.</p></list-item><list-item id="li0030"><label>3)</label><p id="pr0080">We conducted an experiment and a questionnaire to verify that PVC.js addresses <bold>P1–3</bold>.</p></list-item></list></p>
  </sec>
  <sec id="se0020">
    <label>2</label>
    <title>Related works</title>
    <p id="pr0090">Previous studies have indicated that the concepts of memory and pointer are extremely challenging for novices. For example, Lahtinen et al. investigated the difficulties faced by novices in learning programming languages <xref rid="br0100" ref-type="bibr">[10]</xref> and found that more than 500 students indicated that finding bugs in a program is the most difficult part of learning to program. Moreover, pointers and references are identified as two of the hardest programming concepts.</p>
    <p id="pr0100">Many studies have proposed visualization techniques and tools, which can effectively aid novices' understanding of these programming concepts. Sorva et al. surveyed program visualization systems and tools to teach beginners about the runtime behaviors of computer programs <xref rid="br0150" ref-type="bibr">[15]</xref>. They reported that software visualization can be divided into Program Visualization (PV) and Algorithm Visualization (AV). Furthermore, PV can also be roughly subdivided into visualization of static structures and visualization of runtime dynamics. According to their definition, our research is a visualization of the runtime dynamic.</p>
    <p id="pr0110">Tools that act as debuggers are often used to visualize the runtime dynamics. Debuggers were originally used by programmers to find and remove bugs. However, educators and researchers found that debuggers can help novices learn, and they began to use them as part of classroom lessons. Cross et al. explored the use of an integrated debugger as a tool to aid the understanding of novice Java programming students in CS1 <xref rid="br0160" ref-type="bibr">[16]</xref>. Then they developed a tool called jGRASP <xref rid="br0170" ref-type="bibr">[17]</xref>, <xref rid="br0180" ref-type="bibr">[18]</xref>, <xref rid="br0190" ref-type="bibr">[19]</xref>. jGRASP is an Integrated Development Environment (IDE) that supports the visualization of data structure. It can generate control a structure diagram (CSD) of C and Java languages.</p>
    <p id="pr0120">Some research has focused on visualizing the memory state of C language. Koike and Go proposed SuZMe, which visualizes the memory state by byte unit with a horizontal straight line <xref rid="br0120" ref-type="bibr">[12]</xref>. SuZMe also checks the values of variables and memory allocation in detail. Milne et al. proposed a program visualization tool named OGRE <xref rid="br0010" ref-type="bibr">[1]</xref>. OGRE generates planes to represent memory space such as Global, Heap, main(), and function(). An object is represented as a figure within three-dimensional space and cylinders connecting figures represent references. Egan and McDonald proposed SeeC, which visualizes the running state of a C program <xref rid="br0110" ref-type="bibr">[11]</xref>. Moreno et al. proposed Eliot, which is an interactive animation environment to visualize algorithms written in the C programming language <xref rid="br0200" ref-type="bibr">[20]</xref>.</p>
    <p id="pr0130">Similar to our efforts for PVC.js, previous studies have developed these tools as web applications to improve accessibility. One example is Python Tutor (PT), which is a program visualization tool proposed by Guo that specializes in supporting Python and the embeddability in web-pages <xref rid="br0210" ref-type="bibr">[21]</xref>, <xref rid="br0220" ref-type="bibr">[22]</xref>. Currently, PT supports visualization of other languages, including C language. Our literature investigation revealed that SeeC and PT are currently the most useful and widely available state-of-the-art tools for novices to learn about memory management in C language. In addition, other studies have investigated non-C languages in the field of program visualization research.</p>
    <p id="pr0140">Milne and Rowe also investigated challenges surrounding learning and teaching of object-oriented programming (OOP) <xref rid="br0090" ref-type="bibr">[9]</xref>. Their questionnaire showed that learning copy constructor and virtual function is difficult, primarily due to the fact that memory and pointer are hard concepts to grasp. These studies reveal that understanding memory and pointer are important steps towards progressing in programming ability.</p>
    <p id="pr0150">Other tools such as Jeliot <xref rid="br0230" ref-type="bibr">[23]</xref> and OOP-anime <xref rid="br0020" ref-type="bibr">[2]</xref> support OOP languages such as Java. These tools show the relationship between class, instance, and variable with figures such as lines and boxes.</p>
    <p id="pr0160">These studies seem to visualize the same concept as C memory management and pointer reference. This suggests that proposing such tools to aid in learning and understanding of the concept is worthwhile and should not be limited to a specific language.</p>
  </sec>
  <sec id="se0030">
    <label>3</label>
    <title>Problems with state-of-the-art tools</title>
    <p id="pr0170">Fig. <xref rid="fg0010" ref-type="fig">1</xref> and <xref rid="fg0020" ref-type="fig">2</xref> show the visualization results of SeeC and PT, respectively. The effectiveness of these two visualization expressions are similar. They have three common problems: <bold>capability (P1), installability (P2), and usability (P3).</bold> Table <xref rid="tbl0010" ref-type="table">1</xref> summarizes these programs and compares the features of PVC.js, SeeC, and PT.<fig id="fg0010"><label>Figure 1</label><caption><p>Screenshot of SeeC.</p></caption><alt-text id="at0010">Figure 1</alt-text><graphic xlink:href="gr001"/></fig><fig id="fg0020"><label>Figure 2</label><caption><p>Screenshot of PT.</p></caption><alt-text id="at0020">Figure 2</alt-text><graphic xlink:href="gr002"/></fig><table-wrap position="float" id="tbl0010"><label>Table 1</label><caption><p>Comparison of PVC.js, SeeC, and PT functionalities.</p></caption><alt-text id="at0200">Table 1</alt-text><table frame="hsides" rules="groups"><thead><tr><th>Comparison items</th><th align="center">PVC</th><th align="center">SeeC</th><th align="center">PT</th></tr></thead><tbody><tr><td colspan="4" align="center"><bold>Summary</bold></td></tr><tr><td colspan="4"><hr/></td></tr><tr><td>Capability (P1)</td><td>OK</td><td>(NG) It does not support malloc.</td><td>(NG) It does not support I/O.</td></tr><tr><td>Installability for client (P2)</td><td>(OK) Only a browser</td><td>(NG) Difficult to setup</td><td>(OK) Only a browser</td></tr><tr><td>Installability for server (P2)</td><td>(OK) Not required (or just place HTML files)</td><td>(NG) Not supported (Desktop application)</td><td>(NG) Very difficult to setup</td></tr><tr><td>Usability (P3)</td><td>(OK) Open in a browser, write the code, and press execute button.</td><td>(NG) Compiling is necessary beforehand. Visualizer cannot edit the code.</td><td>(OK) Open in a browser, write the code, and press execute button.</td></tr><tr><td colspan="4" align="left">  </td></tr><tr><td colspan="4" align="center"><bold>Language feature support</bold></td></tr><tr><td colspan="4"><hr/></td></tr><tr><td>malloc</td><td>Y</td><td>N</td><td>Y</td></tr><tr><td>I/O</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td colspan="4" align="left">  </td></tr><tr><td colspan="4" align="center"><bold>Visualization expression</bold></td></tr><tr><td colspan="4"><hr/></td></tr><tr><td>Variables grouped by stack</td><td>Y</td><td>Y</td><td/></tr><tr><td>Pointer references represented by arrows</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Addresses of variables shown</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>Display values of uninitialized variables</td><td>Random number</td><td>! or ? mark</td><td>An emoji</td></tr><tr><td>Visualization method</td><td>Run and create trace data using a proprietary execution environment (Junicoen).</td><td>Create execution trace data using LLVM (Clang).</td><td>Create execution trace data using GCC and a hacked Valgrind.</td></tr></tbody></table></table-wrap></p>
    <p id="pr0180"><bold>Capability (P1)</bold>: SeeC does not support dynamic memory allocation (e.g., malloc) completely. Instead it shows the byte size of dynamically allocated memory in text. Fig. <xref rid="fg0010" ref-type="fig">1</xref> illustrates an example of a visualization result from SeeC, which includes only the line &lt; <italic>n bytes of dynamically allocated memory</italic> &gt;. As this example shows, SeeC users cannot see the content of the memory allocated by programs such as <italic>malloc</italic>. On the other hand, PT does not allow file I/O and standard Input due to security issues. It is inconvenient that these functions cannot be used.</p>
    <p id="pr0190"><bold>Installability (P2)</bold>: The dependency of SeeC on Clang makes installation somewhat difficult. Many novice-oriented visualization tools proposed in previous studies require users to setup an execution environment. This is the main obstacle preventing users from installing these kinds of tools, regardless of a tool's usefulness <xref rid="br0240" ref-type="bibr">[24]</xref>. Moreover, these tools are usually restricted to specific operating systems.</p>
    <p id="pr0200">Another problem with PT is installability on a server computer. Even if students or teachers try to use PT, setting up a server program for C language on their own computer can be burdensome.<xref rid="fn0030" ref-type="fn">3</xref></p>
    <p id="pr0210">For these reasons, SeeC and PT are insufficient for novices to write and visualize their programs in class.</p>
    <p id="pr0220"><bold>Usability (P3)</bold>: Users cannot modify source code during SeeC's visualization because the source code is shown in a read-only text area. To revisualize a program, SeeC requires users to execute the following four steps each time the source code is modified:<list list-type="simple" id="ls0020"><list-item id="li0040"><label>1)</label><p id="pr0230">Modify the source code file with an external editing application.</p></list-item><list-item id="li0050"><label>2)</label><p id="pr0240">Recompile to generate an executable file with SeeC on a terminal or command prompt.</p></list-item><list-item id="li0060"><label>3)</label><p id="pr0250">Open the executable file to generate a recording file for program behavior and execution status visualization.</p></list-item><list-item id="li0070"><label>4)</label><p id="pr0260">Open the recording file in SeeC's viewer.</p></list-item></list> PT does not have such a problem.</p>
  </sec>
  <sec id="se0040">
    <label>4</label>
    <title>Overview of PVC.js</title>
    <p id="pr0270">To overcome <bold>P1–3</bold>, we implemented PVC.js with HTML and JavaScript, including GUIs, a C parser, and a semantic analyzer. All functions work on the client side because it is developed as a JavaScript application. Fig. <xref rid="fg0030" ref-type="fig">3</xref> systematically overviews the program, while Fig. <xref rid="fg0040" ref-type="fig">4</xref> shows a screenshot of PVC.js. To implement our design, we used <italic>ANTLR</italic> to parse the source code, and <italic>unicoen.ts</italic> to create and execute the abstract syntax tree (AST), <italic>UniTree</italic>, in C languages <xref rid="br0250" ref-type="bibr">[25]</xref>. PVC.js is a JavaScript application that simply requires users to open the html file with PVC.js in a web browser. PVC.js does not require a web server. It contains all necessary functions. Additionally, it also does not require an Internet connection. Therefore, PVC.js provides a solution <bold>(S2)</bold> to <bold>installability (P2)</bold>.<fig id="fg0030"><label>Figure 3</label><caption><p>Overview of the PVC.js architecture.</p></caption><alt-text id="at0030">Figure 3</alt-text><graphic xlink:href="gr003"/></fig><fig id="fg0040"><label>Figure 4</label><caption><p>Screenshot of the PVC.js interface.</p></caption><alt-text id="at0040">Figure 4</alt-text><graphic xlink:href="gr004"/></fig></p>
    <sec id="se0050">
      <label>4.1</label>
      <title>Tool usage</title>
      <p id="pr0280">Fig. <xref rid="fg0040" ref-type="fig">4</xref> shows an execution example in PVC.js. PVC.js has five GUI components: (1) editor, (2) execution controller buttons, (3) I/O window, (4) canvas for visualization, and (5) file upload form. Users can write source code in the editor. Clicking on the execution control buttons initiates the step execution. The I/O window shows the content of the standard output written by the program (e.g., <italic>printf</italic>) and accepts standard input (e.g., <italic>scanf</italic>). The canvas shows the program's execution status using tables and figures. PVC.js adaptively changes its layout to correspond with the size of the browser window.</p>
      <p id="pr0290">The top of the GUI in Fig. <xref rid="fg0040" ref-type="fig">4</xref> shows the program's execution controller. The controller includes the following six buttons: (i) change editor font size, (ii) initiate program execution, (iii) stop program execution, (iv) go backward for all step, (v) go backward one step, (vi) go forward one step, and (vii) go forward all steps. A statement unit executes each step.</p>
      <p id="pr0300">Users can also use the local files selected from the user files form. They can use these files via programs such as <italic>fgets, fputc</italic>.</p>
      <p id="pr0310">PVC.js has three steps:<list list-type="simple" id="ls0030"><list-item id="li0080"><label>1)</label><p id="pr0320">Open the html file with PVC.js in a web browser.</p></list-item><list-item id="li0090"><label>2)</label><p id="pr0330">Insert the source code into the editor to visualize it.</p></list-item><list-item id="li0100"><label>3)</label><p id="pr0340">Press the button to execute the program. (The second button from the left in the Execution Controller Buttons initiates program execution)</p></list-item></list> Simply changing the code and pressing the execution button during visualization allows the users to change the program. Thus, PVC.js provides a solution <bold>(S3)</bold> to <bold>usability (P3)</bold>.</p>
    </sec>
    <sec id="se0060">
      <label>4.2</label>
      <title>Visualization features</title>
      <p id="pr0350">PVC.js, SeeC, and PT use a similar approach for visualization. The programs show values, names, and types of variables using arrows and boxes to represent pointer and stack references. For example, colored arrows and variable addresses help users understand that references differ. Movable figures make it easier to see the visualized results, while the display depth of the recursive functions informs users of how many times it has been called.</p>
      <p id="pr0360">Only PVC.js supports the following important features:<list list-type="simple" id="ls0040"><list-item id="li0110"><label>•</label><p id="pr0370">Dynamically allocated memory visualized<xref rid="fn0040" ref-type="fn">4</xref></p></list-item><list-item id="li0120"><label>•</label><p id="pr0380">Memory addresses value displayed in hexadecimal</p></list-item><list-item id="li0130"><label>•</label><p id="pr0390">File and standard I/O</p></list-item></list></p>
      <p id="pr0400">Fig. <xref rid="fg0040" ref-type="fig">4</xref> shows an example of visualization with PVC.js. There are two boxes on the canvas: <inline-formula><mml:math id="M1" altimg="si1.svg"><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M2" altimg="si2.svg"><mml:mi>G</mml:mi><mml:mi>L</mml:mi><mml:mi>O</mml:mi><mml:mi>B</mml:mi><mml:mi>A</mml:mi><mml:mi>L</mml:mi></mml:math></inline-formula>. <inline-formula><mml:math id="M3" altimg="si1.svg"><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:math></inline-formula> represents a stack of the main function, while <inline-formula><mml:math id="M4" altimg="si2.svg"><mml:mi>G</mml:mi><mml:mi>L</mml:mi><mml:mi>O</mml:mi><mml:mi>B</mml:mi><mml:mi>A</mml:mi><mml:mi>L</mml:mi></mml:math></inline-formula> contains dynamic variables for heap memory allocated by <inline-formula><mml:math id="M5" altimg="si3.svg"><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>c</mml:mi></mml:math></inline-formula>. The table columns in the box show (1) type, (2) name, (3) value, and (4) address of each variable. For example, the first line of <inline-formula><mml:math id="M6" altimg="si1.svg"><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:math></inline-formula> refers to a variable of <italic>n</italic>, which is a type <italic>int</italic> and has a value of 3. Moreover, some variables, such as <italic>ptr</italic> and <inline-formula><mml:math id="M7" altimg="si4.svg"><mml:mi>d</mml:mi><mml:mi mathvariant="normal">_</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>r</mml:mi></mml:math></inline-formula>, refer to other variables. The pointer reference is represented as an arrow with the same color as the reference address (e.g., the green arrow from the row containing <italic>ptr</italic> to the row containing <inline-formula><mml:math id="M8" altimg="si5.svg"><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:math></inline-formula>).</p>
      <p id="pr0410">Figs. <xref rid="fg0010" ref-type="fig">1</xref>, <xref rid="fg0020" ref-type="fig">2</xref> and <xref rid="fg0040" ref-type="fig">4</xref> visualize the same code. Although SeeC stops its visualization, PVC.js visualizes the allocated heap memory referred to by the pointer variable <inline-formula><mml:math id="M9" altimg="si6.svg"><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mi>r</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>y</mml:mi></mml:math></inline-formula>, which is not free. Therefore, PVC.js can be used to debug a program with memory leak action calls.</p>
      <p id="pr0420">Figs. <xref rid="fg0050" ref-type="fig">5</xref>, <xref rid="fg0060" ref-type="fig">6</xref>, <xref rid="fg0070" ref-type="fig">7</xref> and <xref rid="fg0080" ref-type="fig">8</xref> show additional examples. Fig. <xref rid="fg0050" ref-type="fig">5</xref> shows function calls whose arguments are passed-by-pointer. Fig. <xref rid="fg0060" ref-type="fig">6</xref> shows the recursive function call where the function <italic>f</italic> is called five times. Recall is represented in the title of each box in the form f, f.1, f.2, f.3, f.4, and f.5. Fig. <xref rid="fg0070" ref-type="fig">7</xref> shows dynamic memory allocations with <inline-formula><mml:math id="M10" altimg="si3.svg"><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>c</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M11" altimg="si7.svg"><mml:mi>f</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi></mml:math></inline-formula>. Finally, Fig. <xref rid="fg0080" ref-type="fig">8</xref> shows a more complex recursive function call.<fig id="fg0050"><label>Figure 5</label><caption><p>Screenshots of the sample code and the visualization results (T1): function calls with pointers.</p></caption><alt-text id="at0050">Figure 5</alt-text><graphic xlink:href="gr005"/></fig><fig id="fg0060"><label>Figure 6</label><caption><p>Screenshots of the sample code and visualization results (T2): recursive function calls.</p></caption><alt-text id="at0060">Figure 6</alt-text><graphic xlink:href="gr006"/></fig><fig id="fg0070"><label>Figure 7</label><caption><p>Screenshots of the sample code and visualization results (T3): dynamic memory allocations.</p></caption><alt-text id="at0070">Figure 7</alt-text><graphic xlink:href="gr007"/></fig><fig id="fg0080"><label>Figure 8</label><caption><p>Screenshots of the sample code and visualization results (T4): complex recursive function calls.</p></caption><alt-text id="at0080">Figure 8</alt-text><graphic xlink:href="gr008"/></fig></p>
      <p id="pr0430">Consequently, PVC.js provides a solution <bold>(S1)</bold> to <bold>capability (P1)</bold>. Thus, PVC.js can visualize pointer and dynamic memory allocation (Fig. <xref rid="fg0040" ref-type="fig">4</xref>). Table <xref rid="tbl0010" ref-type="table">1</xref> summarizes these solutions.</p>
    </sec>
    <sec id="se0070">
      <label>4.3</label>
      <title>Language processing features</title>
      <p id="pr0440">Our system does not use generic compilers like GCC or Clang or debuggers like GDB (Table <xref rid="fg0030" ref-type="fig">3</xref>). Generic compilers and debuggers are avoided because they are responsible for <bold>installability (P2)</bold>.</p>
      <p id="pr0450">We use <italic>unicoen.ts</italic>, which is a TypeScript platform that converts the source code of various programming languages into its own AST (<italic>UniTree</italic>). Fig. <xref rid="fg0090" ref-type="fig">9</xref> shows a class diagram of a UniTree in the UML. We generated a C language parser and a lexer as well as implemented a mapper and a semantic analyzer.<fig id="fg0090"><label>Figure 9</label><caption><p>Class diagram of a UniTree in the UML.</p></caption><alt-text id="at0090">Figure 9</alt-text><graphic xlink:href="gr009"/></fig></p>
      <p id="pr0460">The parser and the lexer are generated by <italic>ANTLR</italic>, which is a powerful generator that creates parser and lexer programs from the language syntax and the lexical definition files. We used the language definition file of C languages published by the ANTLR project. When a C language source code is inputted, the parser generates ANTLR's own AST, which is JavaScript object.</p>
      <p id="pr0470">We implemented the mapper to plot from ANTLR's own AST to UniTree because performing semantic analysis directly using ANTLR's AST is complicated.</p>
      <p id="pr0480">We also implemented the semantic analyzer to execute UniTree like a C language. This can be regarded as a simple C interpreter capable of step executions and generation of debug information.</p>
      <p id="pr0490">These series of processing can be executed in a modern web browser because the transpiled TypeScript program becomes a JavaScript program.</p>
      <p id="pr0950">
        <fig id="fg0200">
          <graphic xlink:href="gr011"/>
        </fig>
      </p>
      <p id="pr0500">For example, when the source code of Listing 1 is inputted to our system, the UniTree in Fig. <xref rid="fg0100" ref-type="fig">10</xref> is generated. In the first step, the semantic analyzer executes the UniTree node surrounded by a red frame like the C language. In the second step, it executes the UniTree node surrounded by a green frame. In the third step, it executes the UniTree node surrounded by a blue frame.<fig id="fg0100"><label>Figure 10</label><caption><p>Example of a UniTree.</p></caption><alt-text id="at0100">Figure 10</alt-text><graphic xlink:href="gr010"/></fig></p>
      <p id="pr0510">In our previous papers <xref rid="br0070" ref-type="bibr">[7]</xref>, language processing occurred using almost the same method in a Java program called Junicoen <xref rid="br0250" ref-type="bibr">[25]</xref> instead of unicoen.ts. Java programs can also be used in various operating systems or environments such as browsers. We conjecture that employing a Java server locally in an offline environment is a simple but elegant solution to <bold>installability (P2)</bold>. However, when using PVC in an online web server, preparing a Java server on the network is burdensome for teachers. Even for use in an offline environment, students have to install Java, which is less burdensome than installing other visualization tools.</p>
      <p id="pr0520">PVC.js can eliminate all of these burdens. To use in an offline environment, a user must simply open the html file with the browser used to download the PVC.js. If PVC.js is used in an online web server (e.g., to publish a customized version of PVC.js), the user simply places the PVC.js files on their web server or uses a free service hosting static webpages such as <italic>GitHub Pages</italic>.</p>
      <p id="pr0530">Therefore, PVC.js provides a solution <bold>(S2)</bold> to <bold>installability (P2)</bold>.</p>
    </sec>
  </sec>
  <sec id="se0080">
    <label>5</label>
    <title>Experiment</title>
    <p id="pr0540">We investigated the following research questions (RQ):<list list-type="simple" id="ls0050"><list-item id="li0140"><label>•</label><p id="pr0550">RQ1 Does PVC.js inform users of the status of the running program?</p></list-item><list-item id="li0150"><label>•</label><p id="pr0560">RQ2 Does PVC.js assist novices who are learning C programming language concepts?</p></list-item><list-item id="li0160"><label>•</label><p id="pr0570">RQ3 Is PVC.js a useful and more accessible application to visualize the status of a running program than similar tools?</p></list-item><list-item id="li0170"><label>•</label><p id="pr0580">RQ4 How does PVC.js support the understanding of programs?</p></list-item></list></p>
    <p id="pr0590">We conducted two experiments. The first experiment evaluated PVC.js with respect to RQ1–3. The second experiment also evaluated PVC.js with respect to RQ1, RQ2, and RQ4.</p>
    <sec id="se0090">
      <label>5.1</label>
      <title>First experiment</title>
      <sec id="se0100">
        <label>5.1.1</label>
        <title>Experimental setting</title>
        <p id="pr0600">The participants were 30 undergraduate or graduate students majoring in computer science and engineering. Ten performed the tasks using PVC,<xref rid="fn0050" ref-type="fn">5</xref> 10 using SeeC,<xref rid="fn0060" ref-type="fn">6</xref> and remaining 10 did not use a visualization tool (viewed the code only and used a pen and paper). After completing the tasks, the participants used PVC and answered a questionnaire.</p>
        <p id="pr0610">The experiment involved four tasks. The source code used in this experiment is the same as the code shown on the site.<xref rid="fn0070" ref-type="fn">7</xref> Table <xref rid="tbl0020" ref-type="table">2</xref> shows the examination questions (T1–4) of each task. Table <xref rid="tbl0030" ref-type="table">3</xref> shows the questions (Q1–4) in the questionnaire. The participants completed the questionnaire upon finishing the tasks using PVC. Prior to the experiment, we explained PVC and provided a tutorial on how to use it. (The explanation was almost identical to that in Fig. <xref rid="fg0040" ref-type="fig">4</xref>.). During the experiment, we measured the time taken to answer each question and checked the answers. Q1 to Q3 were evaluated on a scale from 1 to 5, where 5 is the most positive.<table-wrap position="float" id="tbl0020"><label>Table 2</label><caption><p>Examination questions (T1–4).</p></caption><alt-text id="at0210">Table 2</alt-text><table frame="hsides" rules="groups"><tbody><tr><td>T1</td><td>What are the final values of variables a, b, c, d, e?</td></tr><tr><td>T2</td><td>What are the values of variables n, r, (*pn) when the function f is returned for a third time?</td></tr><tr><td>T3</td><td>What are the final values of heap memory, which has not been freed, and of the pointer variable, which refers to the memory when the main function return?</td></tr><tr><td>T4</td><td>When are the values of n=1, a='B', b='A', c='C'?</td></tr></tbody></table></table-wrap><table-wrap position="float" id="tbl0030"><label>Table 3</label><caption><p>Questions in the questionnaire about the usefulness (Q1–4).</p></caption><alt-text id="at0220">Table 3</alt-text><table frame="hsides" rules="groups"><tbody><tr><td>Q1</td><td>Do you think this visualization tool helps solve the problems in the experiment?</td></tr><tr><td>Q2</td><td>Do you think this visualization tool is useful for C language novices?</td></tr><tr><td>Q3</td><td>Do you think this visualization tool is more accessible than other visualization or debugging tools (e.g., Eclipse, Visual Studio, GDB) that you have used?</td></tr><tr><td>Q4</td><td>In which areas of C language is this visualization program a useful learning tool? (multiple answers allowed) (A. variable, B. pointer, C. array, D. function, E. dynamic memory allocation, F. structure, G. data structures and algorithms, H. other)</td></tr></tbody></table></table-wrap></p>
      </sec>
      <sec id="se0110">
        <label>5.1.2</label>
        <title>Experimental results</title>
        <p id="pr0620">Fig. <xref rid="fg0110" ref-type="fig">11</xref> shows a box plot of the time taken to answer each task, while Fig. <xref rid="fg0120" ref-type="fig">12</xref> shows a bar graph of the percentage of correct answers for the tasks. Figs. <xref rid="fg0130" ref-type="fig">13</xref> and <xref rid="fg0140" ref-type="fig">14</xref> show the questionnaire responses. Fig. <xref rid="fg0130" ref-type="fig">13</xref> shows the participants' answers to Q1–3, which evaluate the usefulness and accessibility of a tool, whereas Fig. <xref rid="fg0140" ref-type="fig">14</xref> shows the answers to Q4, which assesses the utility of PVC. In other words, Fig. <xref rid="fg0130" ref-type="fig">13</xref> represents a measure of the usefulness and accessibility of the PVC program (Q1–3), while Fig. <xref rid="fg0140" ref-type="fig">14</xref> relates the appropriateness of the tool to the application (Q4).<fig id="fg0110"><label>Figure 11</label><caption><p>Box plot of the times required to complete each task.</p></caption><alt-text id="at0110">Figure 11</alt-text><graphic xlink:href="gr012"/></fig><fig id="fg0120"><label>Figure 12</label><caption><p>Percentages of correct answers for T1–T4 (for RQ1).</p></caption><alt-text id="at0120">Figure 12</alt-text><graphic xlink:href="gr013"/></fig><fig id="fg0130"><label>Figure 13</label><caption><p>Results of Q1–3 (for RQ2 and RQ3).</p></caption><alt-text id="at0130">Figure 13</alt-text><graphic xlink:href="gr014"/></fig><fig id="fg0140"><label>Figure 14</label><caption><p>Result of Q4 (for RQ3).</p></caption><alt-text id="at0140">Figure 14</alt-text><graphic xlink:href="gr015"/></fig></p>
        <p id="pr0630"><bold>RQ1</bold>: Figs. <xref rid="fg0110" ref-type="fig">11</xref> and <xref rid="fg0120" ref-type="fig">12</xref> clearly indicate that the group using PVC generally answered the questions more accurately and faster than the other groups. Table <xref rid="tbl0040" ref-type="table">4</xref>, which compares the mean values of these results, shows that the group using PVC answered the questions on average 1.8 times faster and gave 24% more correct responses than the group working without a tool (no tool). Compared to the group working with SeeC, those working with PVC responded 1.7 times faster and provided 19% more correct answers, demonstrating that PVC is well suited to the tasks.<table-wrap position="float" id="tbl0040"><label>Table 4</label><caption><p>Comparison of PVC, SeeC, and no tool in terms of median, mean, and statistical test.</p></caption><alt-text id="at0230">Table 4</alt-text><table frame="hsides" rules="groups"><thead><tr><th/><th/><th>Number of correct answers</th><th>Time to answer [s]</th></tr></thead><tbody><tr><td rowspan="3">Mean</td><td>no tool</td><td>2.5</td><td>1148.4</td></tr><tr><td>SeeC</td><td>2.1</td><td>1045.5</td></tr><tr><td>PVC</td><td>3.1</td><td>623.3</td></tr><tr><td colspan="4" align="left">  </td></tr><tr><td rowspan="3">Median</td><td>no tool</td><td>3</td><td>1002.5</td></tr><tr><td>SeeC</td><td>2</td><td>1030</td></tr><tr><td>PVC</td><td>3</td><td>620.5</td></tr><tr><td colspan="4" align="left">  </td></tr><tr><td rowspan="3">Steel-Dwass test (p-value)</td><td>PVC / no tool</td><td>&lt;0.1</td><td>&lt;0.01</td></tr><tr><td>PVC / SeeC</td><td>&lt;0.05</td><td>&lt;0.05</td></tr><tr><td>no tool / SeeC</td><td>n.s.</td><td>n.s.</td></tr></tbody></table></table-wrap></p>
        <p id="pr0640">Table <xref rid="tbl0040" ref-type="table">4</xref> also shows the <italic>p</italic>-values between the groups and evaluates them using the Steel-Dwass test <xref rid="br0260" ref-type="bibr">[26]</xref>.<xref rid="fn0080" ref-type="fn">8</xref></p>
        <p id="pr0960">A significant difference exists between the groups, except for the relationship between the SeeC and the no tool groups.</p>
        <p id="pr0650">Focusing on the results of T3 and T4 of the SeeC group, the correct answer rates are worse than the no tool group, which was unexpected. Moreover, for T3, the SeeC group took more time on average to answer than the no tool group. We speculate that the reasons for these are as follows: T3 — SeeC does not fully support dynamic memory allocation. Thus, participants become confused or have to switch to working with pen and paper, which is more time-consuming. T4 — PVC can visualize the depth of recursive call as a number, but SeeC cannot. This may lead to the difference in the correct answer rate.</p>
        <p id="pr0660">Moreover, the participants felt that PVC is very useful for solving the problems in the experiment (Q1). (As shown in Fig. <xref rid="fg0130" ref-type="fig">13</xref>, all the participants responded with rankings of 4 or 5.) These results indicate that PVC can convey the status of running programs to programmers in general.</p>
        <p id="pr0670"><bold>RQ2</bold>: About 90% of the participants feel that PVC is useful for novices learning some concepts of C programming language (Fig. <xref rid="fg0130" ref-type="fig">13</xref>, Q2). As expected, most users felt that PVC is a useful aid for learning pointer and dynamic memory allocation (Fig. <xref rid="fg0140" ref-type="fig">14</xref>, Q4). Additionally, participants felt that the program is also useful for functions. Based on these results, we speculate that PVC is useful for checking the answer to T2, which is challenging as it involves a recursive function. Given that task T2 yielded the lowest percentage of correct answers, it is inferred that it is the most challenging part of the experiment.</p>
        <p id="pr0680"><bold>RQ3</bold>: About 80% of the participants felt that PVC is more accessible than other existing visualization or debugging tools (Fig. <xref rid="fg0130" ref-type="fig">13</xref>, Q3).</p>
        <p id="pr0690">Hence, the experiment confirms that PVC mostly satisfies RQ 1–3 proposed at the beginning of the study.</p>
      </sec>
    </sec>
    <sec id="se0120">
      <label>5.2</label>
      <title>Second experiment</title>
      <sec id="se0130">
        <label>5.2.1</label>
        <title>Experimental setting</title>
        <p id="pr0700">We conducted a second experiment to answer RQ4 and reconfirm RQ1 and RQ3 by comparing our visualization tool with Python Tutor (PT) and Visual Studio (VS).<xref rid="fn0090" ref-type="fn">9</xref></p>
        <p id="pr0710">PT is a state-of-the-art tool, and PVC.js is inspired by its visualization. VS is a representative traditional visualization tool. VS is one of the most popular IDEs used to debug and visualize the execution status for C language. This experiment used PLIVET instead of PVC.js. PLIVET is the successor to PVC.js (like a version 2), which aims to support other languages (Java and Python). Its function, usage, and visualization for C language on the browser are exactly the same as or slightly better than PVC.js (e.g., the blurred text in the visualization area is clearer in PLIVET)<xref rid="fn0100" ref-type="fn">10</xref></p>
        <p id="pr0720">The participants were 35 university students with at least one earned C language class credit. Eleven performed the tasks using PLIVET, 12 using VS, and the remaining 12 using PT. After completing the tasks using PLIVET, the participants answered a <italic>User Experience Questionnaire (UEQ)</italic>, which is a standard and reliable questionnaire to measure the user experience of interactive products. UEQ consists of 26 questions and classifies the questions into the following six scales: Attractiveness, Perspicuity, efficiency, Dependability, Stimulation, and Novelty.</p>
        <p id="pr0730">The experiment involved four tasks that were exactly the same as the first experiment. The participants using PLIVET or PT executed and visualized the program with the few simple buttons provided by the tool. VS is more than a visualization tool, it has many features. However, the participants used only basic debugging commands such as <italic>Execute with Debugging</italic>, <italic>Step Over</italic>, <italic>Step In</italic>, and <italic>Step Out</italic>. VS visualizes the variable name, values, and type at that step in the “Local” window.</p>
        <p id="pr0740">Fig. <xref rid="fg0150" ref-type="fig">15</xref> shows the questions (Q1–26) in the UEQ. The participants completed the questionnaire upon finishing the tasks using PLIVET. Q1 – Q26 were evaluated on a scale from 1 to 7. Details of this questionnaire are shown elsewhere.<xref rid="fn0110" ref-type="fn">11</xref><fig id="fg0150"><label>Figure 15</label><caption><p>Twenty-six questions of the User Experience Questionnaire.</p></caption><alt-text id="at0150">Figure 15</alt-text><graphic xlink:href="gr016"/></fig></p>
        <p id="pr0750">In this experiment, we recorded video on the operation of PLIVET while the participants solved the tasks. Additionally, we recorded the UI interactions of the participants such as the orders of mouse click, the number of clicks, and time of each step.<xref rid="fn0120" ref-type="fn">12</xref></p>
      </sec>
      <sec id="se0140">
        <label>5.2.2</label>
        <title>Experimental results</title>
        <p id="pr0760">Fig. <xref rid="fg0160" ref-type="fig">16</xref> shows a box plot of the time taken to answer each task, while Fig. <xref rid="fg0170" ref-type="fig">17</xref> shows a bar graph of the percentage of correct answers for the tasks. Table <xref rid="tbl0060" ref-type="table">5</xref> shows the participants' answers to Q1–26 of UEQ, which is a measure of the user experience of PLIVET.<fig id="fg0160"><label>Figure 16</label><caption><p>Box plot of the time required to complete each task.</p></caption><alt-text id="at0160">Figure 16</alt-text><graphic xlink:href="gr017"/></fig><fig id="fg0170"><label>Figure 17</label><caption><p>Percentages of correct answers for T1–T4 (for RQ1).</p></caption><alt-text id="at0170">Figure 17</alt-text><graphic xlink:href="gr018"/></fig><table-wrap position="float" id="tbl0060"><label>Table 5</label><caption><p>Results of the UEQ. Scale from 1 to 7 is converted from –3 to +3.</p></caption><alt-text id="at0240">Table 5</alt-text><table frame="hsides" rules="groups"><thead><tr><th>Q</th><th>Mean</th><th>Left</th><th>Right</th><th>Scale</th></tr></thead><tbody><tr><td>1</td><td>1.00</td><td>annoying</td><td>enjoyable</td><td>Attractiveness</td></tr><tr><td>2</td><td>0.45</td><td>not understandable</td><td>understandable</td><td>Perspicuity</td></tr><tr><td>3</td><td>1.00</td><td>creative</td><td>dull</td><td>Novelty</td></tr><tr><td>4</td><td>1.82</td><td>easy to learn</td><td>difficult to learn</td><td>Perspicuity</td></tr><tr><td>5</td><td>2.00</td><td>valuable</td><td>inferior</td><td>Stimulation</td></tr><tr><td>6</td><td>0.82</td><td>boring</td><td>exciting</td><td>Stimulation</td></tr><tr><td>7</td><td>0.82</td><td>not interesting</td><td>interesting</td><td>Stimulation</td></tr><tr><td>8</td><td>1.18</td><td>unpredictable</td><td>predictable</td><td>Dependability</td></tr><tr><td>9</td><td>1.18</td><td>fast</td><td>slow</td><td>Efficiency</td></tr><tr><td>10</td><td>1.27</td><td>inventive</td><td>conventional</td><td>Novelty</td></tr><tr><td>11</td><td>2.27</td><td>obstructive</td><td>supportive</td><td>Dependability</td></tr><tr><td>12</td><td>1.73</td><td>good</td><td>bad</td><td>Attractiveness</td></tr><tr><td>13</td><td>-0.09</td><td>complicated</td><td>easy</td><td>Perspicuity</td></tr><tr><td>14</td><td>1.36</td><td>unlikable</td><td>pleasing</td><td>Attractiveness</td></tr><tr><td>15</td><td>-0.09</td><td>usual</td><td>leading edge</td><td>Novelty</td></tr><tr><td>16</td><td>0.73</td><td>unpleasant</td><td>pleasant</td><td>Attractiveness</td></tr><tr><td>17</td><td>1.45</td><td>secure</td><td>not secure</td><td>Dependability</td></tr><tr><td>18</td><td>1.27</td><td>motivating</td><td>demotivating</td><td>Stimulation</td></tr><tr><td>19</td><td>1.18</td><td>meets expectations</td><td>does not meet expectations</td><td>Dependability</td></tr><tr><td>20</td><td>1.09</td><td>inefficient</td><td>efficient</td><td>Efficiency</td></tr><tr><td>21</td><td>1.09</td><td>clear</td><td>confusing</td><td>Perspicuity</td></tr><tr><td>22</td><td>3.00</td><td>impractical</td><td>practical</td><td>Efficiency</td></tr><tr><td>23</td><td>0.82</td><td>organized</td><td>cluttered</td><td>Efficiency</td></tr><tr><td>24</td><td>1.36</td><td>attractive</td><td>unattractive</td><td>Attractiveness</td></tr><tr><td>25</td><td>1.36</td><td>friendly</td><td>unfriendly</td><td>Attractiveness</td></tr><tr><td>26</td><td>0.27</td><td>conservative</td><td>innovative</td><td>Novelty</td></tr></tbody></table></table-wrap></p>
        <p id="pr0770"><bold>RQ1</bold>: Figs. <xref rid="fg0160" ref-type="fig">16</xref> and <xref rid="fg0170" ref-type="fig">17</xref> indicate that there is not much difference between PLIVET and PT. Both are slightly better than VS. Table <xref rid="tbl0050" ref-type="table">6</xref>, which compares the mean values of these results, shows that the group using PLIVET answered the questions on average 1.3 times faster and gave 18% more correct responses than the group working with VS. However, according to the <italic>p</italic>-values, a significant difference does not exist between the PLIVET and the other tools. These results reaffirm the premise of the first experiment, which indicated that our tool and PT have similar visualization performances.<xref rid="fn0130" ref-type="fn">13</xref><table-wrap position="float" id="tbl0050"><label>Table 6</label><caption><p>Comparison of PLIVET, VS, and PT in terms of median, mean, and statistical test.</p></caption><alt-text id="at0250">Table 6</alt-text><table frame="hsides" rules="groups"><thead><tr><th/><th/><th align="left">Number of correct answers</th><th align="left">Time to answer [s]</th></tr></thead><tbody><tr><td rowspan="3">Mean</td><td>PLIVET</td><td>2.6</td><td>1250.4</td></tr><tr><td>VS</td><td>2.2</td><td>1566.4</td></tr><tr><td>PT</td><td>2.8</td><td>1007.6</td></tr><tr><td colspan="4" align="left">  </td></tr><tr><td rowspan="3">Median</td><td>PLIVET</td><td>3</td><td>1110</td></tr><tr><td>VS</td><td>2</td><td>1614.5</td></tr><tr><td>PT</td><td>3</td><td>963.5</td></tr><tr><td colspan="4" align="left">  </td></tr><tr><td rowspan="3" align="left">Steel-Dwass test (p-value)</td><td>PLIVET / VS</td><td>n.s.</td><td>n.s.</td></tr><tr><td>PLIVET / PT</td><td>n.s.</td><td>n.s.</td></tr><tr><td>VS / PT</td><td>n.s.</td><td>&lt;0.1</td></tr></tbody></table></table-wrap></p>
        <p id="pr0780"><bold>RQ3</bold>: Table <xref rid="tbl0070" ref-type="table">7</xref> shows the mean of the UEQ scales for the tools. PLIVET has good efficiency and stimulation. On the other hand, Perspicuity and Novelty are inferior to the others, but received positive evaluations. At all scales, PLIVET and PT show higher points than VS, which represents existing tools. Table <xref rid="tbl0080" ref-type="table">8</xref> shows the statistical significance of the UEQ scales for the tools. There is not a significant difference between PLIVET and PT, but there is a significant difference with VS.<table-wrap position="float" id="tbl0070"><label>Table 7</label><caption><p>Results of the UEQ as the six UEQ scales.</p></caption><alt-text id="at0260">Table 7</alt-text><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">UEQ Scales</th><th colspan="3" align="left">Mean<hr/></th></tr><tr><th>PLIVET</th><th>PT</th><th>VS</th></tr></thead><tbody><tr><td>Attractiveness</td><td>1.26</td><td>2.04</td><td>0.50</td></tr><tr><td>Perspicuity</td><td>0.82</td><td>1.44</td><td>0.08</td></tr><tr><td>Efficiency</td><td>1.52</td><td>1.15</td><td>0.88</td></tr><tr><td>Dependability</td><td>1.52</td><td>1.40</td><td>0.81</td></tr><tr><td>Stimulation</td><td>1.23</td><td>1.96</td><td>0.81</td></tr><tr><td>Novelty</td><td>0.61</td><td>0.85</td><td>0.00</td></tr></tbody></table></table-wrap><table-wrap position="float" id="tbl0080"><label>Table 8</label><caption><p>Steel-Dwass test result (p-value) of the UEQ scales.</p></caption><alt-text id="at0270">Table 8</alt-text><table frame="hsides" rules="groups"><thead><tr><th/><th>Attractiveness</th><th>Perspicuity</th><th>Efficiency</th><th>Dependability</th><th>Stimulation</th><th>Novelty</th></tr></thead><tbody><tr><td>PLIVET / VS</td><td>n.s.</td><td>n.s.</td><td>n.s.</td><td>&lt;0.1</td><td>n.s.</td><td>n.s.</td></tr><tr><td>PLIVET / PT</td><td>n.s.</td><td>n.s.</td><td>n.s.</td><td>n.s.</td><td>n.s.</td><td>n.s.</td></tr><tr><td>VS / PT</td><td>&lt;0.01</td><td>&lt;0.05</td><td>n.s.</td><td>n.s.</td><td>&lt;0.01</td><td>n.s.</td></tr></tbody></table></table-wrap></p>
        <p id="pr0790">Hence, the experiments confirm that PLIVET (PVC.js) is equivalent to the advanced tool PT and it has better visualization capabilities than the existing tool VS. These finding make the answer to RQ1 in the first experiment more robust.<fig id="fg0210"><graphic xlink:href="gr019"/></fig><fig id="fg0220"><graphic xlink:href="gr020"/></fig><fig id="fg0230"><graphic xlink:href="gr021"/></fig><fig id="fg0240"><graphic xlink:href="gr022"/></fig></p>
        <p id="pr0820"><bold>RQ4</bold>: Table <xref rid="tbl0090" ref-type="table">9</xref> shows the average number of times that the execution controller button was clicked in each task. Once the participants clicked <italic>the button to initiate program execution</italic>, they basically used <italic>the button to go forward one step</italic>.<table-wrap position="float" id="tbl0090"><label>Table 9</label><caption><p>Average number of times each button was clicked during a task (T1–4).</p></caption><alt-text id="at0280">Table 9</alt-text><table frame="hsides" rules="groups"><tbody><tr><td>Controller buttons</td><td>T1</td><td>T2</td><td>T3</td><td>T4</td></tr><tr><td>Initiate program execution</td><td>1.3</td><td>1</td><td>1</td><td>1.2</td></tr><tr><td>Stop program execution</td><td>0.1</td><td>0</td><td>0</td><td>0.3</td></tr><tr><td>Go backward for all step</td><td>0.2</td><td>0.5</td><td>0.2</td><td>0.9</td></tr><tr><td>Go backward one step</td><td>0.8</td><td>23</td><td>21.8</td><td>22</td></tr><tr><td>Go forward one step</td><td>27.9</td><td>79.9</td><td>81</td><td>82</td></tr><tr><td>Go forward all steps</td><td>0.5</td><td>0.2</td><td>0.3</td><td>0</td></tr></tbody></table></table-wrap></p>
        <p id="pr0830">Figs. <xref rid="fg0180" ref-type="fig">18</xref>, <xref rid="fg0190" ref-type="fig">19</xref>, <xref rid="fg0270" ref-type="fig">20</xref>, and <xref rid="fg0280" ref-type="fig">21</xref> show the time that the participants stayed at the n-th step of the program for each task. The horizontal axis shows the n-th step of the program. The vertical axis shows the number of seconds the participants stayed at each step. For simplicity, the y-axis is displayed in the range of 30 seconds or less.<fig id="fg0180"><label>Figure 18</label><caption><p>Duration of each step in T1.</p></caption><alt-text id="at0180">Figure 18</alt-text><graphic xlink:href="gr023"/></fig><fig id="fg0190"><label>Figure 19</label><caption><p>Duration of each step in T2.</p></caption><alt-text id="at0300">Figure 19</alt-text><graphic xlink:href="gr024"/></fig><fig id="fg0270"><label>Figure 20</label><caption><p>Duration of each step in T3.</p></caption><alt-text id="at0310">Figure 20</alt-text><graphic xlink:href="gr025"/></fig><fig id="fg0280"><label>Figure 21</label><caption><p>Duration of each step in T4.</p></caption><alt-text id="at0190">Figure 21</alt-text><graphic xlink:href="gr026"/></fig></p>
        <p id="pr0840">For T1 (Listing 2), <italic>the button to go forward one step</italic> was used after clicking <italic>the button to initiate program execution</italic>. The participants stayed for only a few seconds in most steps. However, they stayed longer in the 1st–3rd steps, 6th step, 9th step, and 30th steps. The 1st–3rd steps defined five new variables and the swap function was called for the first time. In the 6th step, processing returned from the swap1 function to the main function. In the 9th step, a value was overwritten by another value. In the 30th step, all function calls were finished and the answer values were visualized. Thus, we expect that the participants were trying to understand the program fully in steps where function calls and the value of a variable changed.</p>
        <p id="pr0850">For T2 (Listing 3), the participants stayed for a long time after the 25th step. This may be because the recursive function was returned in these steps and the answer values were also visualized. All the participants used <italic>the button to go backward one step</italic> several times around the 27th step. Hence, it is considered that the participants tried to understand the program by seeing the difference in the visualization result at each step.</p>
        <p id="pr0860">For T3 (Listing 4), the participants spent a lot of time in the 4th and 29th–33th steps. In the 4th step, the value was assigned to the heap area allocated by the <italic>malloc</italic> function. The heap area was released with the <italic>free</italic> function around the 34th step.</p>
        <p id="pr0870">For T4 (Listing 5), the participants spent a long time in the 8th–11th steps. Before the 12th step, the first <italic>H</italic> whose arguments were <italic>(n-1,a,c,b)</italic> in the function <italic>H</italic> was called recursively and consecutively four times. After that, the second <italic>H</italic> whose arguments are <italic>(n-1,b,a,c)</italic> in the function <italic>H</italic> called in the function <italic>H</italic> called in the third time. The participants also used <italic>the button to go backward one step</italic> several times to understand the program because the control flow was fairly complicated. Moreover, the participants used <italic>the go backward for all step button</italic> most frequently in this task. According to this result, it is speculated that the participants tried to deepen their understanding of the program by repeating the execution of the program.</p>
        <p id="pr0880">Hence, we found that PVC.js supports the understanding of the program by the step forward and back execution functions, especially in cases where the values of important variables change and the control flow is complicated. This is answer to RQ4.</p>
      </sec>
    </sec>
    <sec id="se0150">
      <label>5.3</label>
      <title>Threats to validity</title>
      <p id="pr0890">All the participants in this study had basic knowledge of the C language and we provided a tutorial of PVC.js. However, the degree of proficiency varied within the groups. Some participants used PVC.js very well, while others struggled in the experiment. These attributes may affect the results of the experiment and pose a threat to internal validity.</p>
      <p id="pr0900">Most participants were students of Waseda University and Osaka Institute of Technology. If we repeated this experiment with people belonging to another group or organization, the results may vary. The results may depend on demographics (e.g., age), programming skill level, and experience in the field. These pose a threat to the experiment's external validity.</p>
    </sec>
    <sec id="se0160">
      <label>5.4</label>
      <title>Limitations</title>
      <p id="pr0910">Currently, PVC.js supports most C90 keywords, but it does not support minor language features. <xref rid="tbl0100" ref-type="table">Table 10</xref> shows the keywords supported by current PVC.js.<xref rid="fn0140" ref-type="fn">14</xref> For example, it does not support <italic>union</italic> and external libraries. Other tools such as SeeC and PT support all keywords up to C11 because they use major compilers such as <italic>gcc</italic>. However, PVC.js is designed for novices. We believe that the lack of advanced C features is acceptable as advanced features are unnecessary for novices to learn programming. On the other hand, C98 features are partially supported, such as <italic>bool</italic> type and variable declarations in the middle of function blocks. C11 and C17 features are not supported.<table-wrap position="float" id="tbl0100"><label>Table 10</label><caption><p>C Language keywords supported by the current PVC.js.</p></caption><alt-text id="at0290">Table 10</alt-text><table frame="hsides" rules="groups"><thead><tr><th>C Keywords</th><th>support (Y/N)</th></tr></thead><tbody><tr><td>auto</td><td>N</td></tr><tr><td>break</td><td>Y</td></tr><tr><td>case</td><td>Y</td></tr><tr><td>char</td><td>Y</td></tr><tr><td>const</td><td>Y</td></tr><tr><td>continue</td><td>Y</td></tr><tr><td>default</td><td>Y</td></tr><tr><td>do</td><td>Y</td></tr><tr><td>double</td><td>Y</td></tr><tr><td>else</td><td>Y</td></tr><tr><td>enum</td><td>N</td></tr><tr><td>extern</td><td>ignored</td></tr><tr><td>float</td><td>Y</td></tr><tr><td>for</td><td>Y</td></tr><tr><td>goto</td><td>N</td></tr><tr><td>if</td><td>Y</td></tr><tr><td>int</td><td>Y</td></tr><tr><td>long</td><td>Y</td></tr><tr><td>register</td><td>N</td></tr><tr><td>return</td><td>Y</td></tr><tr><td>short</td><td>Y</td></tr><tr><td>signed</td><td>Y</td></tr><tr><td>sizeof</td><td>Y</td></tr><tr><td>static</td><td>N</td></tr><tr><td>struct</td><td>Y</td></tr><tr><td>switch</td><td>Y</td></tr><tr><td>typedef</td><td>Y</td></tr><tr><td>union</td><td>N</td></tr><tr><td>unsigned</td><td>Y</td></tr><tr><td>void</td><td>Y</td></tr><tr><td>volatile</td><td>ignored</td></tr><tr><td>while</td><td>Y</td></tr><tr><td>_Bool (C99)</td><td>Y (as bool)</td></tr><tr><td>inline (C99)</td><td>ignored</td></tr><tr><td>restrict (C99)</td><td>N</td></tr><tr><td>_Complex (C99)</td><td>N</td></tr><tr><td>_Imaginary (C99)</td><td>N</td></tr><tr><td>_Alignas (C11)</td><td>N</td></tr><tr><td>_Alignof (C11)</td><td>N</td></tr><tr><td>_Atomic (C11)</td><td>N</td></tr><tr><td>_Generic (C11)</td><td>N</td></tr><tr><td>_Noreturn (C11)</td><td>N</td></tr><tr><td>_Static_assert (C11)</td><td>N</td></tr><tr><td>_Thread_local (C11)</td><td>N</td></tr></tbody></table></table-wrap></p>
      <p id="pr0920">Moreover, PVC.js does not display compiler error messages because it is a visualization tool and not a compiler.</p>
    </sec>
  </sec>
  <sec id="se0170">
    <label>6</label>
    <title>Conclusions and future work</title>
    <p id="pr0930">We propose a new visualization technique for C languages called PVC.js. It is a browser-based JavaScript application inspired by previous studies. The application is open-access and free to try at the listed address (see Section <xref rid="se0010" ref-type="sec">1</xref>). The experiment reveals that PVC.js is useful not only to novices, but also to programmers in general.</p>
    <p id="pr0940">In the future, we plan to investigate whether PVC.js can help students learn programming by evaluating users' programming skills after using PVC.js. Moreover, we will continue to develop and improve PVC.js. For example, our visualize application currently supports only C language. It does not support the full range of C language syntax and standard library functions. We are also planning to improve PVC.js to increase the support functions, support multiple programming languages and incorporate some suitable block-based representation (e.g. <bold>blockly</bold><xref rid="fn0150" ref-type="fn">15</xref> can transpile blocks to code). Such block-based representation can make it easier for the learners to avoid using not supported features and also protect them from syntax errors.</p>
  </sec>
  <sec id="se0180">
    <title>Declarations</title>
    <sec id="se0190">
      <title>Author contribution statement</title>
      <p id="pr0970">R. Ishizue, K. Sakamoto: Conceived and designed the experiments; Performed the experiments; Analyzed and interpreted the data; Contributed reagents, materials, analysis tools or data; Wrote the paper.</p>
      <p id="pr0980">H. Washizaki, Y. Fukazawa: Conceived and designed the experiments; Analyzed and interpreted the data.</p>
    </sec>
    <sec id="se0200">
      <title>Funding statement</title>
      <p id="pr0990">This work was partially supported by <funding-source id="gsp0010">Japan Science and Technology Agency</funding-source> (JST) Presto under Grant Number JPMJPR14D4.</p>
    </sec>
    <sec id="se0210">
      <title>Competing interest statement</title>
      <p id="pr1000">The authors declare no conflict of interest.</p>
    </sec>
    <sec id="se0220">
      <title>Additional information</title>
      <p id="pr1010">No additional information is available for this paper.</p>
    </sec>
  </sec>
</body>
<back>
  <ref-list id="bl0010">
    <title>References</title>
    <ref id="br0010">
      <label>1</label>
      <element-citation publication-type="journal" id="bib6FD0DBC2F2696689F2687A984771C308s1">
        <person-group person-group-type="author">
          <name>
            <surname>Milne</surname>
            <given-names>I.</given-names>
          </name>
          <name>
            <surname>Rowe</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>Ogre: three-dimensional program visualization for novice programmers</article-title>
        <source>Educ. Inf. Technol.</source>
        <year>2004</year>
      </element-citation>
    </ref>
    <ref id="br0020">
      <label>2</label>
      <element-citation publication-type="book" id="bib70CB6997FD414781B48D3B4015947BAFs1">
        <person-group person-group-type="author">
          <name>
            <surname>Esteves</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Mendes</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <chapter-title>Oop-anim, a system to support learning of basic object oriented programming concepts</chapter-title>
        <source>Proceedings of the CompSysTech</source>
        <year>2003</year>
      </element-citation>
    </ref>
    <ref id="br0030">
      <label>3</label>
      <element-citation publication-type="book" id="bibB030BE3769BC2B9CFAD9C65BD7A7FEA4s1">
        <person-group person-group-type="author">
          <name>
            <surname>Sundararaman</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Back</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <chapter-title>Hdpv: interactive, faithful, in-vivo runtime state visualization for c/c++ and java</chapter-title>
        <source>Proceedings of the 4th ACM Symposium on Software Visualization</source>
        <year>2008</year>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="br0040">
      <label>4</label>
      <element-citation publication-type="book" id="bib68CBA0683E158493F03C46A482BDBFABs1">
        <person-group person-group-type="author">
          <name>
            <surname>De Pauw</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Jensen</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Mitchell</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Sevitsky</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Vlissides</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <chapter-title>Visualizing the execution of Java programs</chapter-title>
        <source>Software Visualization</source>
        <year>2002</year>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="br0050">
      <label>5</label>
      <element-citation publication-type="book" id="bib15D7C879D22FFFAAC64C2BE001D2B9E5s1">
        <person-group person-group-type="author">
          <name>
            <surname>Baerten</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Van Reeth</surname>
            <given-names>F.</given-names>
          </name>
        </person-group>
        <chapter-title>Using vrml and Java to visualize 3d algorithms in computer graphics education</chapter-title>
        <source>Computer Networks and ISDN Systems</source>
        <year>1998</year>
      </element-citation>
    </ref>
    <ref id="br0060">
      <label>6</label>
      <element-citation publication-type="book" id="bibDDA4B85057941AEDCF0B84F093F47EE1s1">
        <person-group person-group-type="author">
          <name>
            <surname>Ishizue</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Sakamoto</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Washizaki</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Fukazawa</surname>
            <given-names>Y.</given-names>
          </name>
        </person-group>
        <chapter-title>An interactive web application visualizing memory space for novice c programmers (abstract only)</chapter-title>
        <source>Proceedings of the 2017 ACM SIGCSE Technical Symposium on Computer Science Education, ser. SIGCSE '17</source>
        <year>2017</year>
        <publisher-name>ACM</publisher-name>
        <publisher-loc>New York, NY, USA</publisher-loc>
        <fpage>710</fpage>
        <comment>[Online]</comment>
      </element-citation>
    </ref>
    <ref id="br0070">
      <label>7</label>
      <element-citation publication-type="book" id="bib6A282F2FE0D7C22BB1EB80DDCAF4F568s1">
        <person-group person-group-type="author">
          <name>
            <surname>Ishizue</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Sakamoto</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Washizaki</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Fukazawa</surname>
            <given-names>Y.</given-names>
          </name>
        </person-group>
        <chapter-title>Pvc: visualizing c programs on web browsers for novices</chapter-title>
        <source>Proceedings of the 49th ACM Technical Symposium on Computer Science Education, ser. SIGCSE '18</source>
        <year>2018</year>
        <publisher-name>ACM</publisher-name>
        <publisher-loc>New York, NY, USA</publisher-loc>
        <fpage>245</fpage>
        <lpage>250</lpage>
        <comment>[Online]</comment>
      </element-citation>
    </ref>
    <ref id="br0080">
      <label>8</label>
      <element-citation publication-type="book" id="bib565B5BA8112F23AFC953E3A8063847D0s1">
        <person-group person-group-type="author">
          <name>
            <surname>Craig</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Petersen</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <chapter-title>Student difficulties with pointer concepts in c</chapter-title>
        <source>Proceedings of the Australasian Computer Science Week Multiconference</source>
        <year>2016</year>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="br0090">
      <label>9</label>
      <element-citation publication-type="journal" id="bib3DDDB1E26F1C9FA16D4F951BF778E112s1">
        <person-group person-group-type="author">
          <name>
            <surname>Milne</surname>
            <given-names>I.</given-names>
          </name>
          <name>
            <surname>Rowe</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>Difficulties in learning and teaching programming-views of students and tutors</article-title>
        <source>Educ. Inf. Technol.</source>
        <year>2002</year>
      </element-citation>
    </ref>
    <ref id="br0100">
      <label>10</label>
      <element-citation publication-type="book" id="bibE2DC96982742FB75D6800127C17FD8EBs1">
        <person-group person-group-type="author">
          <name>
            <surname>Lahtinen</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Ala-Mutka</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Järvinen</surname>
            <given-names>H.-M.</given-names>
          </name>
        </person-group>
        <chapter-title>A study of the difficulties of novice programmers</chapter-title>
        <source>ACM SIGCSE Bulletin</source>
        <year>2005</year>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="br0110">
      <label>11</label>
      <element-citation publication-type="book" id="bib7EDC2B1BA2CF422A576731E240F66121s1">
        <person-group person-group-type="author">
          <name>
            <surname>Egan</surname>
            <given-names>M.H.</given-names>
          </name>
          <name>
            <surname>McDonald</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <chapter-title>Program visualization and explanation for novice c programmers</chapter-title>
        <source>Proceedings of the Sixteenth Australasian Computing Education Conference-Volume 148</source>
        <year>2014</year>
        <publisher-name>ACS</publisher-name>
      </element-citation>
    </ref>
    <ref id="br0120">
      <label>12</label>
      <element-citation publication-type="journal" id="bib7F6711CF763CF8D5648CB4FD0C3790DFs1">
        <person-group person-group-type="author">
          <name>
            <surname>Koike</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Go</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <article-title>A proposal of interaction on visualization using address space representation in runtime program</article-title>
        <source>Interactions</source>
        <year>2012</year>
      </element-citation>
    </ref>
    <ref id="br0130">
      <label>13</label>
      <element-citation publication-type="book" id="bib13613AF77F006B084A7E0971232C014Fs1">
        <person-group person-group-type="author">
          <name>
            <surname>Jiménez-Peris</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Pareja-Flores</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Patiño-Martínez</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Velázquez-Iturbide</surname>
            <given-names>J.Á.</given-names>
          </name>
        </person-group>
        <chapter-title>The locker metaphor to teach dynamic memory</chapter-title>
        <source>ACM SIGCSE Bulletin</source>
        <year>1997</year>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="br0140">
      <label>14</label>
      <element-citation publication-type="book" id="bib9EE05632EC451B1C260EC15569CC17ACs1">
        <person-group person-group-type="author">
          <name>
            <surname>Null</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Rao</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <chapter-title>Camera: introducing memory concepts via visualization</chapter-title>
        <source>ACM SIGCSE Bulletin</source>
        <year>2005</year>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="br0150">
      <label>15</label>
      <element-citation publication-type="journal" id="bib3AC3A569FF7A4C81AACEA0FAA06140D4s1">
        <person-group person-group-type="author">
          <name>
            <surname>Sorva</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Karavirta</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>Malmi</surname>
            <given-names>L.</given-names>
          </name>
        </person-group>
        <article-title>A review of generic program visualization systems for introductory programming education</article-title>
        <source>Trans. Comput. Educ.</source>
        <volume>13</volume>
        <issue>4</issue>
        <year>Nov. 2013</year>
        <object-id pub-id-type="publisher-id">15</object-id>
        <comment>[Online]</comment>
      </element-citation>
    </ref>
    <ref id="br0160">
      <label>16</label>
      <element-citation publication-type="book" id="bib233F241D6D517B9C505E832C06C0EDFEs1">
        <person-group person-group-type="author">
          <name>
            <surname>Cross</surname>
            <given-names>J.H.I.I.</given-names>
          </name>
          <name>
            <surname>Hendrix</surname>
            <given-names>T.D.</given-names>
          </name>
          <name>
            <surname>Barowski</surname>
            <given-names>L.A.</given-names>
          </name>
        </person-group>
        <chapter-title>Using the debugger as an integral part of teaching cs1</chapter-title>
        <source>32nd Annual Frontiers in Education, vol. 2</source>
        <year>Nov 2002</year>
        <comment>pp. F1G–1–F1G–6 vol. 2</comment>
      </element-citation>
    </ref>
    <ref id="br0170">
      <label>17</label>
      <element-citation publication-type="book" id="bib82530A15FA065208666832B3E61AADA8s1">
        <person-group person-group-type="author">
          <name>
            <surname>Cross</surname>
            <given-names>J.H.</given-names>
            <suffix>II</suffix>
          </name>
          <name>
            <surname>Hendrix</surname>
            <given-names>T.D.</given-names>
          </name>
          <name>
            <surname>Jain</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Barowski</surname>
            <given-names>L.A.</given-names>
          </name>
        </person-group>
        <chapter-title>Dynamic object viewers for data structures</chapter-title>
        <source>Proceedings of the 38th SIGCSE Technical Symposium on Computer Science Education, ser. SIGCSE '07</source>
        <year>2007</year>
        <publisher-name>ACM</publisher-name>
        <publisher-loc>New York, NY, USA</publisher-loc>
        <fpage>4</fpage>
        <lpage>8</lpage>
        <comment>[Online]</comment>
      </element-citation>
    </ref>
    <ref id="br0180">
      <label>18</label>
      <element-citation publication-type="journal" id="bib5BF704F08FBFE35090972975A264702Bs1">
        <person-group person-group-type="author">
          <name>
            <surname>Cross</surname>
            <given-names>J.H.</given-names>
          </name>
          <name>
            <surname>Hendrix</surname>
            <given-names>T.D.</given-names>
          </name>
          <name>
            <surname>Barowski</surname>
            <given-names>L.A.</given-names>
          </name>
        </person-group>
        <article-title>Integrating multiple approaches for interacting with dynamic data structure visualizations</article-title>
        <issue-title>Proceedings of the Fifth Program Visualization Workshop (PVW 2008)</issue-title>
        <source>Electron. Notes Theor. Comput. Sci.</source>
        <volume>224</volume>
        <year>2009</year>
        <fpage>141</fpage>
        <lpage>149</lpage>
        <comment>[Online]. Available:</comment>
        <ext-link ext-link-type="uri" xlink:href="http://www.sciencedirect.com/science/article/pii/S1571066108005215" id="inf0110">http://www.sciencedirect.com/science/article/pii/S1571066108005215</ext-link>
      </element-citation>
    </ref>
    <ref id="br0190">
      <label>19</label>
      <element-citation publication-type="journal" id="bibA590B4CD89A75566AA885722DE61DCE2s1">
        <person-group person-group-type="author">
          <name>
            <surname>Cross</surname>
            <given-names>J.H.</given-names>
            <suffix>II</suffix>
          </name>
          <name>
            <surname>Hendrix</surname>
            <given-names>T.D.</given-names>
          </name>
          <name>
            <surname>Umphress</surname>
            <given-names>D.A.</given-names>
          </name>
          <name>
            <surname>Barowski</surname>
            <given-names>L.A.</given-names>
          </name>
          <name>
            <surname>Jain</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Montgomery</surname>
            <given-names>L.N.</given-names>
          </name>
        </person-group>
        <article-title>Robust generation of dynamic data structure visualizations with multiple interaction approaches</article-title>
        <source>Trans. Comput. Educ.</source>
        <volume>9</volume>
        <issue>2</issue>
        <year>Jun. 2009</year>
        <object-id pub-id-type="publisher-id">13</object-id>
        <comment>[Online]</comment>
      </element-citation>
    </ref>
    <ref id="br0200">
      <label>20</label>
      <element-citation publication-type="journal" id="bibC9C6A1CB7041DD2DFF94812F510D6149s1">
        <person-group person-group-type="author">
          <name>
            <surname>Lahtinen</surname>
            <given-names>S.-P.</given-names>
          </name>
          <name>
            <surname>Sutinen</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Tarhio</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Automated animation of algorithms with eliot</article-title>
        <source>J. Vis. Lang. Comput.</source>
        <volume>9</volume>
        <issue>3</issue>
        <year>1998</year>
        <fpage>337</fpage>
        <lpage>349</lpage>
      </element-citation>
    </ref>
    <ref id="br0210">
      <label>21</label>
      <element-citation publication-type="book" id="bib9B53F281B78178600D320215FBD9747As1">
        <person-group person-group-type="author">
          <name>
            <surname>Guo</surname>
            <given-names>P.J.</given-names>
          </name>
        </person-group>
        <chapter-title>Online python tutor: embeddable web-based program visualization for cs education</chapter-title>
        <source>Proceeding of the 44th ACM Technical Symposium on Computer Science Education</source>
        <year>2013</year>
        <publisher-name>ACM</publisher-name>
        <fpage>579</fpage>
        <lpage>584</lpage>
      </element-citation>
    </ref>
    <ref id="br0220">
      <label>22</label>
      <element-citation publication-type="book" id="bib05548DA972D637A5B71A1450840F5CABs1">
        <person-group person-group-type="author">
          <name>
            <surname>Guo</surname>
            <given-names>P.J.</given-names>
          </name>
          <name>
            <surname>White</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Zanelatto</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <chapter-title>Codechella: multi-user program visualizations for real-time tutoring and collaborative learning</chapter-title>
        <source>Proceedings of the IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC), ser. VL/HCC '15</source>
        <year>Oct 2015</year>
        <fpage>79</fpage>
        <lpage>87</lpage>
      </element-citation>
    </ref>
    <ref id="br0230">
      <label>23</label>
      <element-citation publication-type="book" id="bib74CBACDDF514FAA27F19D8C471F0A153s1">
        <person-group person-group-type="author">
          <name>
            <surname>Moreno</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Myller</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Sutinen</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Ben-Ari</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <chapter-title>Visualizing programs with jeliot 3</chapter-title>
        <source>Proceedings of the Working Conference on Advanced Visual Interfaces</source>
        <year>2004</year>
        <publisher-name>ACM</publisher-name>
        <fpage>373</fpage>
        <lpage>376</lpage>
      </element-citation>
    </ref>
    <ref id="br0240">
      <label>24</label>
      <element-citation publication-type="book" id="bib7E6E43D8244F5A9A350ADBE5C2A4AD01s1">
        <person-group person-group-type="author">
          <name>
            <surname>Edwards</surname>
            <given-names>S.H.</given-names>
          </name>
          <name>
            <surname>Tilden</surname>
            <given-names>D.S.</given-names>
          </name>
          <name>
            <surname>Allevato</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <chapter-title>Pythy: improving the introductory python programming experience</chapter-title>
        <source>Proceedings of the 45th ACM Technical Symposium on Computer Science Education</source>
        <year>2014</year>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="br0250">
      <label>25</label>
      <element-citation publication-type="book" id="bib582D74B3E980C1915E16FE6326BFDA3Ds1">
        <person-group person-group-type="author">
          <name>
            <surname>Matsuzawa</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Sakamoto</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Ohata</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Kakehi</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <chapter-title>A programming language translation system for programming education</chapter-title>
        <source>SIGCE, IPSJ</source>
        <year>2015</year>
      </element-citation>
    </ref>
    <ref id="br0260">
      <label>26</label>
      <element-citation publication-type="book" id="bib6C9C0D088DFC43C096EC18AC370DCF8Es1">
        <person-group person-group-type="author">
          <name>
            <surname>Desu</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Raghavarao</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <chapter-title>Nonparametric Statistical Methods for Complete and Censored Data</chapter-title>
        <year>2003</year>
        <publisher-name>CRC Press</publisher-name>
      </element-citation>
    </ref>
  </ref-list>
  <ack id="ac0010">
    <title>Acknowledgements</title>
    <p>We would like to thank Assistant Professor Kiyoshi Honda and students of Osaka Institute of Technology and students of Waseda University for their help with our research.</p>
  </ack>
  <fn-group>
    <fn id="fn0010">
      <label>1</label>
      <p id="np0010">This paper is an extension a poster “An Interactive Web Application Visualizing Memory Space For Novice C Programmers” <xref rid="br0060" ref-type="bibr">[6]</xref> presented at the 48th ACM Technical Symposium on Computer Science Education (SIGCSE 2017) and a paper “PVC: Visualizing C Programs on Web Browsers for Novices” <xref rid="br0070" ref-type="bibr">[7]</xref> presented at the 49th ACM Technical Symposium on Computer Science Education (SIGCSE 2018). In the previous papers, we solved the problem of installability by using a local Java server in an offline environment. In this paper, we develop a new JavaScript application called PVC.js, which does not require a web server to improve S2. We also provide a more detailed description of the application, conduct another experiment to answer an additional research question, add a detailed description of each experimental task, and compare additional related works. In summary, we propose a new tool, which is easier for novices to use, conduct an additional experiment, and explain the important concepts about tools and experiments in more detail.</p>
    </fn>
    <fn id="fn0020">
      <label>2</label>
      <p id="np0020">A <bold>novice</bold> is defined as a person learning C language who is currently trying to understand the concept of memory management, including pointers and dynamic memory allocation.</p>
    </fn>
    <fn id="fn0030">
      <label>3</label>
      <p id="np0030">Github of PT says “it can be hard to run your own visualizer locally for non-Python languages, since there are complex setups in v4-cokapi/ that I haven't yet cleanly packaged up.”</p>
    </fn>
    <fn id="fn0050">
      <label>5</label>
      <p id="np0050">PVC is published as a web application. Its function, usage, and display on the browser are exactly the same as PVC.js.</p>
    </fn>
    <fn id="fn0060">
      <label>6</label>
      <p id="np0060">For the above reason, we judged that there is no visualization difference between PT and SeeC. Hence, this experiment only employed SeeC.</p>
    </fn>
    <fn id="fn0070">
      <label>7</label>
      <p id="np0070"><ext-link ext-link-type="uri" xlink:href="http://play-visualizer-c.herokuapp.com" id="inf0020">http://play-visualizer-c.herokuapp.com</ext-link>.</p>
    </fn>
    <fn id="fn0080">
      <label>8</label>
      <p id="np0080">We selected the Steel-Dwass test, which is a non-parametric test, because it is difficult to determine whether the scores and times of the tasks follow a normal distribution that strictly avoids multiple test.</p>
    </fn>
    <fn id="fn0090">
      <label>9</label>
      <p id="np0090">The first experiment revealed the difference between PVC.js and SeeC. Hence, SeeC is excluded in this experiment.</p>
    </fn>
    <fn id="fn0100">
      <label>10</label>
      <p id="np0100"><ext-link ext-link-type="uri" xlink:href="https://github.com/RYOSKATE/PLIVET" id="inf0030">https://github.com/RYOSKATE/PLIVET</ext-link>.</p>
    </fn>
    <fn id="fn0110">
      <label>11</label>
      <p id="np0110"><ext-link ext-link-type="uri" xlink:href="https://www.ueq-online.org" id="inf0040">https://www.ueq-online.org</ext-link>.</p>
    </fn>
    <fn id="fn0120">
      <label>12</label>
      <p id="np0120">Since one participant's recorded data was incomplete, 10 participant's data were used.</p>
    </fn>
    <fn id="fn0130">
      <label>13</label>
      <p id="np0130">The time to answer and the number of correct answers are lower than in the first experiment because the second experiment targeted a group with more beginners.</p>
    </fn>
    <fn id="fn0140">
      <label>14</label>
      <p id="np0140">PVC.js is evolving (as PLIVET). The latest supported C keywords can be found at <ext-link ext-link-type="uri" xlink:href="https://github.com/RYOSKATE/PLIVET/wiki" id="inf0050">https://github.com/RYOSKATE/PLIVET/wiki</ext-link>.</p>
    </fn>
    <fn id="fn0150">
      <label>15</label>
      <p id="np0150"><ext-link ext-link-type="uri" xlink:href="https://developers.google.com/blockly" id="inf0060">https://developers.google.com/blockly</ext-link>.</p>
    </fn>
  </fn-group>
  <fn-group>
    <fn id="fn0040">
      <label>4</label>
      <p id="np0040">Dynamically allocated memory can be visualized if <italic>sizeof(type)</italic> is used in the arguments of <italic>malloc</italic>.</p>
    </fn>
  </fn-group>
</back>
