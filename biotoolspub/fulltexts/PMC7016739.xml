<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genes (Basel)</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genes (Basel)</journal-id>
    <journal-id journal-id-type="publisher-id">genes</journal-id>
    <journal-title-group>
      <journal-title>Genes</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2073-4425</issn>
    <publisher>
      <publisher-name>MDPI</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7016739</article-id>
    <article-id pub-id-type="doi">10.3390/genes11010053</article-id>
    <article-id pub-id-type="publisher-id">genes-11-00053</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>SparkRA: Enabling Big Data Scalability for the GATK RNA-seq Pipeline with Apache Spark</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Al-Ars</surname>
          <given-names>Zaid</given-names>
        </name>
        <xref rid="c1-genes-11-00053" ref-type="corresp">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Saiyi</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mushtaq</surname>
          <given-names>Hamid</given-names>
        </name>
      </contrib>
    </contrib-group>
    <aff id="af1-genes-11-00053">Computer Engineering Lab, Delft University of Technology, Mekelweg 5, 2628 CD Delft, The Netherlands; <email>S.Wang-17@student.tudelft.nl</email> (S.W.); <email>H.Mushtaq@tudelft.nl</email> (H.M.)</aff>
    <author-notes>
      <corresp id="c1-genes-11-00053"><label>*</label>Correspondence: <email>z.al-ars@tudelft.nl</email></corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>03</day>
      <month>1</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <month>1</month>
      <year>2020</year>
    </pub-date>
    <volume>11</volume>
    <issue>1</issue>
    <elocation-id>53</elocation-id>
    <history>
      <date date-type="received">
        <day>30</day>
        <month>10</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>10</day>
        <month>12</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2020 by the authors.</copyright-statement>
      <copyright-year>2020</copyright-year>
      <license license-type="open-access">
        <license-p>Licensee MDPI, Basel, Switzerland. This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution (CC BY) license (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>).</license-p>
      </license>
    </permissions>
    <abstract>
      <p>The rapid proliferation of low-cost RNA-seq data has resulted in a growing interest in RNA analysis techniques for various applications, ranging from identifying genotype–phenotype relationships to validating discoveries of other analysis results. However, many practical applications in this field are limited by the available computational resources and associated long computing time needed to perform the analysis. GATK has a popular best practices pipeline specifically designed for variant calling RNA-seq analysis. Some tools in this pipeline are not optimized to scale the analysis to multiple processors or compute nodes efficiently, thereby limiting their ability to process large datasets. In this paper, we present SparkRA, an Apache Spark based pipeline to efficiently scale up the GATK RNA-seq variant calling pipeline on multiple cores in one node or in a large cluster. On a single node with 20 hyper-threaded cores, the original pipeline runs for more than 5 h to process a dataset of 32 GB. In contrast, SparkRA is able to reduce the overall computation time of the pipeline on the same single node by about 4×, reducing the computation time down to 1.3 h. On a cluster with 16 nodes (each with eight single-threaded cores), SparkRA is able to further reduce this computation time by 7.7× compared to a single node. Compared to other scalable state-of-the-art solutions, SparkRA is 1.2× faster while achieving the same accuracy of the results.</p>
    </abstract>
    <kwd-group>
      <kwd>GATK variant calling</kwd>
      <kwd>RNA-seq</kwd>
      <kwd>Apache Spark</kwd>
      <kwd>scalability</kwd>
      <kwd>computation time</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="sec1-genes-11-00053">
    <title>1. Introduction</title>
    <p>With the development of next-generation sequencing (NGS) technologies, both DNA-seq and RNA-seq data are becoming increasingly accessible. Identifying variants from DNA-seq data attracted much attention from the research community, which resulted in the development of a number of tools and computational pipelines to address the problem. One of the most widely-used DNA-seq pipelines is GATK best practices [<xref rid="B1-genes-11-00053" ref-type="bibr">1</xref>], which recommends a sequence of tools to process DNA-seq data from raw reads all the way to variant calls. However, it usually takes many hours to run the complete pipeline, due to the large size of the input data and the poor scalability of some of the tools used.</p>
    <p>In order to improve the performance of DNA pipelines and get results faster, a number of solutions have been proposed: Either by scaling the pipelines on multiple compute nodes in a cluster, or by improving the performance on a single node. In terms of cluster solutions, Churchill [<xref rid="B2-genes-11-00053" ref-type="bibr">2</xref>] adapts GATK and creates a high-performance alternative pipeline with an integrated set of tools to utilize the computational resources more efficiently. Other solutions, like Halvade’s [<xref rid="B3-genes-11-00053" ref-type="bibr">3</xref>], scale up the pipeline using the big data Hadoop MapReduce [<xref rid="B4-genes-11-00053" ref-type="bibr">4</xref>] framework. In contrast, SparkGA [<xref rid="B5-genes-11-00053" ref-type="bibr">5</xref>,<xref rid="B6-genes-11-00053" ref-type="bibr">6</xref>,<xref rid="B7-genes-11-00053" ref-type="bibr">7</xref>] is based on the in-memory big data framework Spark [<xref rid="B8-genes-11-00053" ref-type="bibr">8</xref>]. Both Halvade and SparkGA try to optimize the scalability of the GATK pipeline at a cluster level. The logic behind each of them is the same: The input data are divided into chunks and each step in the pipeline can be performed on those independent chunks to achieve data-parallel computations. The advantage of these two solutions is the ease of implementation of the pipelines on a scalable cluster without having to know the exact details of the cluster setup. In terms of performance improvement on a single node, various solutions have been proposed, ranging from algorithmic optimizations [<xref rid="B9-genes-11-00053" ref-type="bibr">9</xref>] to hardware acceleration [<xref rid="B10-genes-11-00053" ref-type="bibr">10</xref>].</p>
    <p>At the same time, RNA-seq data have emerged as a cheaper and more efficient alternative to DNA sequencing data. While it has primarily been used for novel gene identification, expression quantification and splicing analysis [<xref rid="B11-genes-11-00053" ref-type="bibr">11</xref>], new analysis methods allow using this RNA-seq data for calling variants in the genome. In addition to the lower sequencing costs, variants discovered from RNA-seq data are from expressed genome regions, which provides direct evidence to study the relation between genotypes and phenotypes [<xref rid="B12-genes-11-00053" ref-type="bibr">12</xref>]. Furthermore, calling variants in RNA-seq is also an efficient option to validate the discoveries from whole-genome sequencing (WGS) or whole-exome sequencing (WES) experiments [<xref rid="B13-genes-11-00053" ref-type="bibr">13</xref>].</p>
    <p>A number of tools and pipelines have specifically been proposed to enable RNA-seq data analysis; examples are GSNAP [<xref rid="B14-genes-11-00053" ref-type="bibr">14</xref>], MapSplice [<xref rid="B15-genes-11-00053" ref-type="bibr">15</xref>], TopHat [<xref rid="B16-genes-11-00053" ref-type="bibr">16</xref>] and STAR [<xref rid="B17-genes-11-00053" ref-type="bibr">17</xref>], which address the challenge of spliced reads alignment. In addition, the GATK team released their own best practices computational pipeline tailored for RNA-seq variant discovery [<xref rid="B18-genes-11-00053" ref-type="bibr">18</xref>]. However, variant calling in RNA-seq data has some unique computational challenges, such as the large difference in coverage between chromosomes, and the fact that the reads in RNA-seq data are not contiguous makes alignment and subsequent processing steps more difficult. This results in increasing the processing time of such data. For example, running the GATK RNA-seq pipeline on two paired-end data files of 25 GB each takes about 29 h on a single-core computer. On a system with 20 cores, the pipeline still takes up to 16 h, resulting in a speedup of about 2× rather than the desired 20×. This indicates the poor scalability of this pipeline, and the low efficiency of running it on multiple cores.</p>
    <p>In order to address this issue of limited scalability, Halvade introduced an updated version of their pipeline called Halvade-RNA [<xref rid="B19-genes-11-00053" ref-type="bibr">19</xref>]. This solution starts by dividing the input data into chunks and then runs the GATK RNA-seq pipeline on each of these chunks independently to achieve data-parallel computations. A drawback of Halvade-RNA is that it uses the slow in-disk Hadoop MapReduce computation model, which introduces a large overhead on the computation time of the pipeline.</p>
    <p>In this paper, we present SparkRA (Spark RNA Analysis), a pipeline that enables the GATK RNA-seq pipeline to scale efficiently on multiple nodes in a cluster environment. SparkRA uses the Apache Spark big data in-memory framework to facilitate easy scalability of the pipeline, while ensuring low computational overhead, thereby increasing the performance of the pipeline compared to other state-of-the-art solutions.</p>
    <p>The contributions of this paper are:<list list-type="order"><list-item><p>Introducing SparkRA, a Spark-based pipeline to scale up RNA-seq analysis pipelines easily and efficiently, using the Apache Spark in-memory framework.</p></list-item><list-item><p>Improving the parallelism of the GATK best practices RNA-seq tools by addressing their sequential bottlenecks, and allowing them to take full advantage of the capabilities of SparkRA.</p></list-item><list-item><p>Comparing the performance of SparkRA with other state-of-the-art pipelines, and measuring an overall speedup of 7.7× as SparkRA scales the GATK RNA-seq pipeline from one node to 16. Compared to Halvade-RNA, our solution is about 1.3× faster on a single node and 1.2× faster on a cluster.</p></list-item></list></p>
  </sec>
  <sec sec-type="methods" id="sec2-genes-11-00053">
    <title>2. Methods</title>
    <p>In this section, we discuss the details of SparkRA and how it is able to achieve efficient parallel scalability. First, we present the original GATK RNA-seq pipeline, then we discuss the parallelization and optimization techniques we implemented.</p>
    <sec id="sec2dot1-genes-11-00053">
      <title>2.1. GATK RNA-seq</title>
      <p><xref ref-type="fig" rid="genes-11-00053-f001">Figure 1</xref> shows the tools used in the GATK RNA-seq pipeline and how they process the input files to variant calls at the output. The pipeline is divided into three main parts as highlighted in the figure, each using the following tools: 1. STAR aligner, 2. Picard tools, 3. GATK toolkit.</p>
      <p>The pipeline starts by taking one (or two for paired-end reads) FASTQ file at the input. This file is read by the STAR aligner [<xref rid="B17-genes-11-00053" ref-type="bibr">17</xref>], which is considered as the most accurate aligner for RNA-seq reads [<xref rid="B20-genes-11-00053" ref-type="bibr">20</xref>]. STAR compares the reads to a reference genome encoded in a static genome index file to perform the first mapping pass (mapping pass 1). This mapping produces a SAM output file that contains the mapping location of each read to the reference. This file is discarded since this mapping is not accurate as it does not take into consideration that these RNA reads are spliced (i.e., split) at multiple intermediate locations (so-called junctions). In addition to the SAM file, a splice junction (SJ) file containing the splice junction information is produced by the first mapping pass. The SJ file is used by STAR as a guide in the rebuilding of the genome index (rebuild genome index), which produces a new genome index that includes the needed splice junction information to perform a more accurate mapping of the spliced reads in the FASTQ file. Then, STAR starts a second mapping pass (mapping pass 2) to create an accurate SAM file with read mapping information.</p>
      <p>This SAM file is then used as input to Picard, the second tool in the GATK RNA-seq pipeline. First, Picard sorts the SAM file and creates groups of reads (AddOrReplace-ReadGroups) and compresses SAM to a BAM file for better performance in the rest of the pipeline. Then, Picard identifies repeated reads in the file and marks them as duplicates (MarkDuplicates) in the BAM file.</p>
      <p>The remaining steps in the pipeline are carried out by various tools in the GATK toolkit. First, the Split’N’Trim tool is designed to identify the location of gaps in RNA reads, and to subsequently split a spliced read into exon segments. Then, the BaseRecalibrator tool creates a table to reassign the base quality values of the reads that could be biased by the sequencing machines. Finally, the pipeline ends by the HaplotypeCaller which is a variant calling tool that reads the BAM file and the base quality table to identify the probability of a variant in the reads with respect to the reference, and write these variants to a VCF file.</p>
      <p>In order to identify the scalability bottlenecks in this pipeline, we measured the time taken by the different tools as we scale the number of available CPU threads the tools can use. <xref ref-type="fig" rid="genes-11-00053-f002">Figure 2</xref> shows the measurement results for running STAR on the one hand, and for Picard and GATK combined on the other. Throughout the paper, Picard and GATK are treated as a single component in the pipeline, which a feature of our scalability framework. The figure shows that as the number of threads increases, STAR is able to effectively make good use of these threads and reduce its runtime from about 350 min down to about 70 min. However, the runtime of Picard and GATK hardly ever changes as we increase the number of threads. This is due to the fact that among all the tools used in Picard and GATK, only the BaseRecalibrator can be executed with more than one thread.</p>
      <p>In addition to evaluating the scalability potential of the pipeline, we also investigated the computational bottlenecks of the pipeline. <xref ref-type="fig" rid="genes-11-00053-f003">Figure 3</xref> shows the percentage breakdown of the time taken by each tool in the GATK RNA-seq pipeline when executed on a single node with 40 threads. The figure shows that STAR is the fastest part of the pipeline, taking about 19% of the total time, 12% of which is used for index rebuilding. Picard is slower, taking 21% of the total time. Finally, the GATK toolkit takes most of the runtime consuming 60% of the pipeline. The results in <xref ref-type="fig" rid="genes-11-00053-f002">Figure 2</xref> and <xref ref-type="fig" rid="genes-11-00053-f003">Figure 3</xref> show that in order to get any benefit from scaling up our pipeline to multiple nodes, we will have to address the limited scalability of Picard and GATK.</p>
    </sec>
    <sec id="sec2dot2-genes-11-00053">
      <title>2.2. SparkRA Execution Flow</title>
      <p><xref ref-type="fig" rid="genes-11-00053-f004">Figure 4</xref> shows the general execution flow of our SparkRA pipeline [<xref rid="B21-genes-11-00053" ref-type="bibr">21</xref>]. The general idea behind parallelizing the various tools is to divide the input files of each tool into a number of chunks, and then running multiple instances of each tool in parallel to allow for efficient scalability to multiple threads and multiple nodes. However, there are a couple of challenges that limit the parallel potential of the pipeline. First of all, there are three points in the pipeline (1. merge SJ info, 2. sorting and 3. merge VCF) where the next tool needs to wait on all the instances of the previous tool to finish completely before it can start. These points are called synchronization points. In order to reduce their impact, we need to balance the execution time of the tool instances running in parallel so that they finish in approximately the same time, such that waiting time can be minimized. Secondly, the sorting task itself has a strong sequential component and is therefore difficult to parallelize. As a result, we need to implement it in a very efficient way to ensure that it does not become a bottleneck for the pipeline as it scales.</p>
      <p><xref ref-type="fig" rid="genes-11-00053-f004">Figure 4</xref> shows the various components of the SparkRA pipeline. Before starting the pipeline, the FASTQ files are divided into chunks of nearly equal size. The initial version of the genome index is stored locally on all nodes to allow all tasks to access it. Then multiple instances of STAR aligner are executed to map the reads in the chunks to the reference in parallel. The number of chunks is equal to the number of threads available on the cluster. Next, the first synchronization point is reached, where the splice junction files must be merged into one and used to rebuild the genome index. STAR then uses the new genome index to remap the FASTQ chunks to the reference. The output SAM strings of the second mapping pass have to be sorted and grouped by chromosome before being fed to Picard and GATK. This is the second synchronization point. After grouping by chromosome, bigger chromosomes are divided into regions to even out the distribution of the reads in the SAM file. This creates smaller SAM files with chromosome regions to ensure better load balancing of later stages of the pipeline. Finally, each SAM region is processed by Picard and GATK to identify variant calls, stored in multiple VCF files. This is where the third synchronization point is reached. These VCF files are then merged into one final VCF file used for further analysis.</p>
      <p>The SparkRA pipeline has been implemented in Spark, using the Scala language, with minor utilities written in Java and Python. To maximally use the parallelism available in the pipeline, we implement two load balancing techniques (static and dynamic load balancing) to allow the different parallel processes to overlap their execution as much as possible. The pipeline is separated into three parts.</p>
      <list list-type="simple">
        <list-item>
          <label>Part 1</label>
          <p>does the alignment and performs static load balancing according to the size of each chromosome defined by the reference genome.</p>
        </list-item>
        <list-item>
          <label>Part 2</label>
          <p>performs dynamic load balancing to divide the SAM files according to the actual number of reads mapped to each chromosome.</p>
        </list-item>
        <list-item>
          <label>Part 3</label>
          <p>is represented by Picard and GATK.</p>
        </list-item>
      </list>
      <p>In Part 1, there are two optimizations we can perform to run STAR efficiently. First, since we execute multiple STAR instances, each instance requires to load the full genome index file into memory (about 27 GB of RAM for human RNA), which occupies excessive amounts of memory. In order to reduce memory utilization, STAR allows loading the genome index to a shared memory on each node that can be used by all STAR instances on that specific node. Second, since rebuilding the genome index is a totally sequential step, it becomes an increasingly serious bottleneck as the pipeline scales. Therefore, STAR allows to rebuild an index with a sparse suffix array in a sparse way, which can be built much faster. For example, a suffix array of sparsity 8 (i.e., distance between indices is 8) is 6.3× faster to build than a suffix array of sparsity 1 (39.2 min versus 6.27 min). A sparse suffix array does, however, slow down the second mapping, but since the mapping can be parallelized, it is not a bottleneck for scalability.</p>
    </sec>
    <sec id="sec2dot3-genes-11-00053">
      <title>2.3. Static and Dynamic Load Balancing</title>
      <p>As shown in <xref ref-type="fig" rid="genes-11-00053-f004">Figure 4</xref>, Part 3 (Picard and GATK) of the pipeline is executed fully in parallel. This means that it is important to balance the load of each of the parallel instances to minimize the overall computation time. This can be done by balancing the number of reads in every SAM region provided as input to each pipeline instance in Part 3. Since this in itself a computationally intensive process to be done for the many millions of reads in the SAM file, we divide the process into two stages: Static and dynamic load balancing, as presented by SparkGA [<xref rid="B5-genes-11-00053" ref-type="bibr">5</xref>].</p>
      <sec id="sec2dot3dot1-genes-11-00053">
        <title>2.3.1. Static Load Balancing</title>
        <p>If we assume that the reads are on average distributed equally across the different chromosomes in the DNA, we can approximate the load balancing process by dividing the reads in the SAM file according to the size of the DNA region they belong to. Since this information is known in advance (before the pipeline starts), we can perform it statically for a specific reference genome. If <inline-formula><mml:math id="mm1"><mml:mrow><mml:msub><mml:mi mathvariant="italic">sizeStatic</mml:mi><mml:mi mathvariant="italic">sum</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> represents the total size of the genome in base pairs, and <inline-formula><mml:math id="mm2"><mml:mrow><mml:mi mathvariant="italic">numRegions</mml:mi></mml:mrow></mml:math></inline-formula> represents the number of regions we would like to create (based on the number of parallel instances of the pipeline we would like to create), then the target size of each region used for static load balanced would be
<disp-formula id="FD1-genes-11-00053"><label>(1)</label><mml:math id="mm3"><mml:mrow><mml:mrow><mml:mi mathvariant="italic">avgSizeStatic</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mi mathvariant="italic">sizeStatic</mml:mi><mml:mi mathvariant="italic">sum</mml:mi></mml:msub><mml:mi mathvariant="italic">numRegions</mml:mi></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        <p>However, to make the computation easier, we first create regions along the boundaries of individual chromosomes. Then, we only divide a single chromosome into two or more regions if the size of the chromosome is larger than a multiple of <inline-formula><mml:math id="mm4"><mml:mrow><mml:mi mathvariant="italic">numRegions</mml:mi></mml:mrow></mml:math></inline-formula>. This means that the eventual number of regions actually created is not equal to the targeted <inline-formula><mml:math id="mm5"><mml:mrow><mml:mi mathvariant="italic">numRegions</mml:mi></mml:mrow></mml:math></inline-formula>. We refer to the number of regions actually created during static load balancing as <inline-formula><mml:math id="mm6"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>L</mml:mi><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        <p>Static load balancing requires very limited computation, since all the needed information is already available after STAR mapping of Part 1 completes. This means that we can use this simple heuristic already in Part 1 to improve the performance of Part 3 at a negligible cost. Moreover, the performance of Part 3 can be further improved using dynamic load balancing in Part 2 as discussed in the next section.</p>
      </sec>
      <sec id="sec2dot3dot2-genes-11-00053">
        <title>2.3.2. Dynamic Load Balancing</title>
        <p>Static load balancing is performed without taking in account the actual number of reads mapped to every region of the genome. This is done to simplify the computational complexity of the balancing process. However, after the alignment and sorting takes place, we perform a second load balancing iteration based on the actual number of mapped reads in every region to further optimize the process. This second iteration is referred to as dynamic load balancing, since it uses the mapping information that was just calculated in Part 1 of the pipeline.</p>
        <p>The actual total number of reads (<inline-formula><mml:math id="mm7"><mml:mrow><mml:msub><mml:mi mathvariant="italic">sizeDynamic</mml:mi><mml:mi mathvariant="italic">sum</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) can efficiently be calculated in Spark at run time. The target size of each genome region (<inline-formula><mml:math id="mm8"><mml:mrow><mml:mi mathvariant="italic">avgSizeDynamic</mml:mi></mml:mrow></mml:math></inline-formula>) can be calculated as follows.
<disp-formula id="FD2-genes-11-00053"><label>(2)</label><mml:math id="mm9"><mml:mrow><mml:mrow><mml:mi mathvariant="italic">avgSizeDynamic</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mi mathvariant="italic">sizeDynamic</mml:mi><mml:mi mathvariant="italic">sum</mml:mi></mml:msub><mml:msub><mml:mi mathvariant="italic">R</mml:mi><mml:mi mathvariant="italic">sLB</mml:mi></mml:msub></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        <p>Then, this number is compared with the actual number of reads in each genome region. If the number of reads is larger than a multiple of <inline-formula><mml:math id="mm10"><mml:mrow><mml:mi mathvariant="italic">avgSizeDynamic</mml:mi></mml:mrow></mml:math></inline-formula>, we will divide the genome region into sub-regions to make the load more balanced for Part 3 of the pipeline. We refer to the number of regions actually created during dynamic load balancing as <inline-formula><mml:math id="mm11"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>L</mml:mi><mml:mi>B</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        <p>In many cases, the number of reads in the majority of regions will not exceed a multiple of <inline-formula><mml:math id="mm12"><mml:mrow><mml:mi mathvariant="italic">avgSizeDynamic</mml:mi></mml:mrow></mml:math></inline-formula>. Therefore, this step will not incur much delay in the pipeline. However, in cases where the number of reads in a region does happen to be rather high, dynamic load balancing will succeed in preventing this region from becoming a bottleneck for Part 3 of the pipeline.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="results" id="sec3-genes-11-00053">
    <title>3. Results</title>
    <p>In this section, we discuss the measurement results of our SparkRA pipeline as compared to other state-of-the-art solutions. In these experiments, we use a dataset with two files of 16 GB each: ENCFF005NLJ and ENCFF635CQM. The data are publicly available from the Encyclopedia of DNA Elements (ENCODE) [<xref rid="B22-genes-11-00053" ref-type="bibr">22</xref>]. We used GATK version 3.4 instead of GATK version 4, since the cluster used to run the experiments did not support running GATK version 4.</p>
    <p>First, we present the scaling up results on a single compute node, followed by the results on multiple nodes in a cluster.</p>
    <sec id="sec3dot1-genes-11-00053">
      <title>3.1. Single-Node Performance</title>
      <p>For the single node experiment, we run the pipelines on a node that has two processors, each with 10 physical cores with hyper-threading enabled (two threads per core). The node is able to run 40 threads and has 196 GB of RAM.</p>
      <sec id="sec3dot1dot1-genes-11-00053">
        <title>3.1.1. Impact of Load Balancing</title>
        <p><xref rid="genes-11-00053-t001" ref-type="table">Table 1</xref> lists the relationship between the number of regions requested by the user and the actual number of generated regions during static and dynamic load balancing. The results show that there are always more static regions generated than the requested number of regions. This takes place due to the large difference between the sizes of chromosomes in the human genome. Since we start by creating regions based on chromosomes and subsequently divide these into sub-regions, smaller chromosomes will always have their own region and more regions are added by dividing bigger chromosomes into sub-regions. This effect diminishes gradually as we increase the number of requested regions. The table also shows that there are even more dynamic regions created than static ones (36% to 56% more). This indicates that the number of reads is not uniformly distributed along the genome, but comes rather concentrated in specific regions. This is specifically true for RNA-seq data, as it gets expressed in specific genetic regions only.</p>
        <p>With respect to computation time, the shortest total time is achieved with 72 requested regions. However, the table shows limited impact of the change in the number of regions on the total time. There is a slight decrease in the time of Part 2 as the number of regions increases, which gets offset by a slight increase in the time of Part 3. The limited impact of the number of regions here can be attributed to the limited amount of parallel resources a single node has. Parallelization can help up to the limit of the nodes capabilities. Since our node has 20 cores capable running a total of 40 threads, creating up to 40 regions can help reduce the computation time of the pipeline. However, with 50 regions or more, the computation time is not expected to decrease much. The increased number of regions beyond 40 is chosen here to investigate the impact on the actual number of regions generated during static (<inline-formula><mml:math id="mm13"><mml:mrow><mml:msub><mml:mi mathvariant="italic">R</mml:mi><mml:mi mathvariant="italic">sLB</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) and dynamic (<inline-formula><mml:math id="mm14"><mml:mrow><mml:msub><mml:mi mathvariant="italic">R</mml:mi><mml:mi mathvariant="italic">dLB</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) load balancing.</p>
        <p>To show the effectiveness of our load balancing technique, we compare it with the load balancing method used by Halvade-RNA. <xref ref-type="fig" rid="genes-11-00053-f005">Figure 5</xref> shows a histogram of the size of regions (in MB) generated by SparkRA (left) and Halvade-RNA (right). The static and dynamic load balancing technique used by SparkRA insures that enough regions are generated (depending on the size of the input data), such that the maximum sizes of the regions remain relatively small. This is not the case for Halvade-RNA, which uses a fixed number of regions irrespective of the size of the data. The figure shows that the maximum size of the regions generated by SparkRA for the used dataset is less than 120 MB, while regions can have a size of up to 655 MB for Halvade-RNA. This difference is made possible due to two reasons. On the one hand, SparkRA is able to generate many more regions (161 in this case) compared to Halvade-RNA (only 37 regions) when the size of the dataset is large, thereby keeping the size of each region smaller. On the other hand, SparkRA specifically breaks down larger regions into smaller ones, rather than uniformly dividing the whole DNA in equal sized regions. This results in creating more regions with larger sizes, which increases the utilization of the compute infrastructure, and reduces the number of CPUs that wait idle after processing the smaller regions. The figure shows that most of the regions generated by Halvade-RNA have sizes smaller than 50% of the corresponding maximum region size, while most of the regions generated by SparkRA have sizes larger than 50% of the corresponding maximum region size.</p>
      </sec>
      <sec id="sec3dot1dot2-genes-11-00053">
        <title>3.1.2. Comparison with Existing Solutions</title>
        <p>In this section, we compare the compute capabilities of SparkRA with the computation time of other state-of-the-art solutions in the field: The original GATK RNA-seq pipeline and Halvade-RNA, as shown in <xref rid="genes-11-00053-t002" ref-type="table">Table 2</xref>. The table lists two measurements for GATK: Executed with only 1 thread (GATK1) and with 40 threads (GATK40). The table also lists the time taken by the different parts of each pipeline. For Part 1 (STAR mapping), we provide the time for the first and second STAR aligner passes, in addition to the genome index rebuild step in between. For Part 2 (sorting and dynamic load balancing), we provide only a measurement for SparkRA; the sorting time for GATK and Halvade is included in the time of Part 3 in the table.</p>
        <p><xref ref-type="fig" rid="genes-11-00053-f006">Figure 6</xref> shows the speedup achieved by the 40-thread GATK RNA-seq pipeline, Halvade-RNA and SparkRA over the single-threaded GATK pipeline. We compare Parts 1 and 3 of the pipeline in addition to the total speedup. For SparkRA, we compare the combined time of Parts 2 and 3 to that of Part 3 of GATK1. The figure shows that SparkRA is by far the fastest pipeline, achieving a speedup of 7.8×, followed by Halvade with 5.9×, and finally GATK40 with about 2×, compared to GATK1. This same is true for Parts 1 and 3 of the pipelines individually. Compared to Halvade, SparkRA is about 1.32× faster in total, 1.4× faster for Parts 2 and 3 and 1.24× faster for Part 1. These results indicate that SparkRA makes good use of the parallel capabilities of Spark and allows for easy scalability on a single node.</p>
        <p>Interestingly, <xref rid="genes-11-00053-t002" ref-type="table">Table 2</xref> shows that SparkRA is actually slower than GATK40 for both STAR pass 1 and 2. This has two reasons. On the one hand, STAR is implemented to scale very efficiently on a single node with increasing number of threads (as shown in <xref ref-type="fig" rid="genes-11-00053-f002">Figure 2</xref>). On the other hand, Spark scalability is done by creating multiple independent STAR processes, which creates much more overhead, in addition to extra overhead that the Spark framework itself adds to the computation time to manage the scheduling and resilience of these processes.</p>
      </sec>
    </sec>
    <sec id="sec3dot2-genes-11-00053">
      <title>3.2. Multi-Node Performance</title>
      <p>This section discusses the scalability capabilities of SparkRA in a cluster environment. We use SURFsara, the Dutch national supercomputing infrastructure to run our analysis [<xref rid="B23-genes-11-00053" ref-type="bibr">23</xref>]. Each node we used on the SURFsara cluster has 56 GB of RAM and two processors, each with four single-threaded cores (total eight cores per node). The cluster uses the Hadoop Distributed File System (HDFS) for distributed file storage. We tested SparkRA on 1, 4, 8 and 16 nodes.</p>
      <sec id="sec3dot2dot1-genes-11-00053">
        <title>3.2.1. Scalability of SparkRA</title>
        <p><xref ref-type="fig" rid="genes-11-00053-f007">Figure 7</xref> shows the total speedup achieved by SparkRA and each of its parts on the cluster while running on 1, 4, 8 and 16 nodes. The figure shows that the total speedup of SparkRA scales up to 7.7× for 16 nodes, with Part 3 achieving the highest speedup of 13×, followed by Part 1 with 6.1× and Part 2 scaling the slowest with 5.6×. The high scalability of Part 3 can be attributed to the large amount of parallelism available in the algorithm. The only sequential component in Part 3 is at the end of the pipeline where the relatively small VCF files need to be combined. Part 1 also has a lot of parallelism, but also has a significant sequential component represented by rebuilding the genome index, which reduces the overall scalability of Part 1. The least scalable part of the pipeline is Part 2, which has a communication bottleneck, as the sorting step requires the location of mapped reads computed on a given node to be communicated and compared with the mapped location of all other reads in other nodes on the cluster. This significantly limits the scalability potential, since increasing the number of nodes also increases the number of sources and destinations to communicate with. However, since the time taken by Part 2 is relatively small, it has limited impact on the overall speedup. Still, if we increase the number of nodes even further beyond 16 nodes, this part will eventually become an important bottleneck.</p>
      </sec>
      <sec id="sec3dot2dot2-genes-11-00053">
        <title>3.2.2. Comparison with Existing Solutions</title>
        <p><xref rid="genes-11-00053-t003" ref-type="table">Table 3</xref> lists the time taken by Halvade-RNA and SparkRA on the SURFsara cluster, as well as the speedup achieved by SparkRA for the different parts of the pipeline. The table shows that SparkRA is 1.22× faster than Halvade for the total runtime of the pipelines, bringing the total runtime down from 80.9 to 66.5 min. For Parts 2 and 3, SparkRA is 1.36× faster than Halvade. This underscores the effectiveness of the load balancing capabilities of our pipeline, enabling it to benefit as much as possible from the parallelism in Part 3. For Part 1, our pipeline has a more modest speedup of 1.16× as a result of sequential limitations to scalability of that part.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="discussion" id="sec4-genes-11-00053">
    <title>4. Discussion</title>
    <p>This section provides a discussion of the results and measurements and analyzes the bottlenecks and limitations of the SparkRA pipeline. We start by an analysis of the CPU utilization in the cluster mode, followed by a discussion of the accuracy of the pipeline results.</p>
    <sec id="sec4dot1-genes-11-00053">
      <title>4.1. CPU Utilization</title>
      <p>This section discusses in more details CPU utilization while SparkRA is running in cluster mode. This allows us to understand the efficiency of our solution and potential areas to improve performance even further.</p>
      <p><xref ref-type="fig" rid="genes-11-00053-f008">Figure 8</xref> shows the average CPU utilization in a node on the cluster as it executes the different parts of SparkRA. The figure has three curves, one representing an active CPU (Process), a CPU waiting for I/O access (IOwait), and an idle CPU (Idle). There are two charts in the figure that show the utilization during the three parts of SparkRA. In Part 1, however, there are three steps: STAR mapping pass 1 done in parallel on all nodes, followed by an index regeneration step done sequentially on only one node in the cluster, and finally a second STAR mapping pass done on all nodes. The top chart in the figure shows utilization on the one node in the cluster doing all these three steps including the sequential index regeneration, while the bottom chart shows utilization of one of the other nodes in the cluster doing only the two parallel STAR mapping steps. Parts 2 and 3 take place on all nodes of the cluster, but are not shown in the bottom chart, since they are identical to the top chart.</p>
      <p>Generally, the figure indicates that CPUs in the cluster are highly utilized throughout the execution of the pipeline, since “Process” is close to 100% utilization all the time. There are a number of exceptions, however, specifically during the index regeneration step in Part 1, and during Part 2.</p>
      <p>In Part 1, we can clearly observe different utilization behaviors between mapping pass 1, the index regeneration and mapping pass 2. At the end of STAR pass 1, computation stops and splice junction information is sorted, shuffled and finally collected on one node. This explains the 100% “Idle” time at the end of the STAR pass 1. Then, during the index regeneration step, there is a period (1000 to 2000 s) where only one node has some “process” activity (top chart), while all other nodes are idle (bottom chart). This step ends with I/O wait activity (top chart) as the newly generated index is being copied to other nodes and gets stored in disk. Finally, the STAR pass 2 starts with I/O wait activity in all other nodes (bottom chart), as these nodes read the new index to use it in pass 2. Then there is a period of active STAR mapping, which ends Part 1 at about 5000 s.</p>
      <p>In Part 2, sorting takes place which, as we discussed earlier, has a significant communication component. Therefore, the CPU utilization in this part is the least compared to the other pipeline parts. As the figure shows, the “Idle” curve is elevated throughout this part. In addition, the figure shows a consistently elevated “IOwait” curve, indicating a large I/O access and network access component in this part.</p>
      <p>In Part 3, Picard and GATK tools are used to call variants in the reads. This figure shows that this part has the highest utilization as the “Process” curve is consistently at 100%. This result validates our earlier observation that Part 3 is the most parallelizable and scalable part in the pipeline. This high 100% utilization continues until 7000 s, which is where the VCF files are generated. Then utilization drops gradually until the files are combined together into one file at the end of the pipeline.</p>
      <p>Based on these observations, future work can focus on Part 2 to improve CPU utilization during the sorting part. One possible solution is to partly overlap sorting with mapping in Part 1, by starting the sorting as the reads are mapped by the STAR aligner. Another possibility to improve performance is by optimizing the STAR index regeneration step in Part 1. However, this step is STAR specific and will require changes to the aligners itself.</p>
    </sec>
    <sec id="sec4dot2-genes-11-00053">
      <title>4.2. Pipeline Accuracy</title>
      <p>An important aspect of scaling up a genomics pipeline is to analyze the accuracy characteristics of the computed results. Due to dividing various intermediate files into chunks and the distribution of the computation on multiple nodes, some of the computations might be carried out differently in a distributed pipeline as compared to computing using a centralized pipeline. This happens primarily at the boundaries of genomic regions, since short reads that are commonly 150 base pairs long get sorted into different file chucks depending on their starting map position, without taking overlapping reads in two regions into consideration.</p>
      <p>In this section, the accuracy is evaluated by comparing the variant calls in the VCF files calculated by a given pipeline, as compared to the VCF variants calculated by the baseline GATK pipeline. We define pipeline accuracy using two metrics: Sensitivity and precision. In order to calculate these two metrics, we need to measure the following parameters from the two VCF files: True positive (TP) variants, false positive (FP) variants and false negative (FN) variants. TPs represents variants called by both pipelines, FPs represent variants called by the scalable pipeline but not by GATK. FNs represent variants called by GATK but not by the scalable pipeline. Using these, we can calculate sensitivity and precision as follows:<disp-formula id="FD3-genes-11-00053"><label>(3)</label><mml:math id="mm15"><mml:mrow><mml:mrow><mml:mi>Sensitivity</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi>TP</mml:mi><mml:mrow><mml:mi>TP</mml:mi><mml:mo>+</mml:mo><mml:mi>FN</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD4-genes-11-00053"><label>(4)</label><mml:math id="mm16"><mml:mrow><mml:mrow><mml:mi>Precision</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi>TP</mml:mi><mml:mrow><mml:mi>TP</mml:mi><mml:mo>+</mml:mo><mml:mi>FP</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p><xref rid="genes-11-00053-t004" ref-type="table">Table 4</xref> lists the accuracy of VCF files generated by the cluster deployment of SparkRA and Halvade-RNA as compared with the GATK baseline in terms of precision and sensitivity. The table shows that in general both SparkRA and Halvade have similar sensitivity and precision of about 95% and 94%, respectively. At close inspection, we find that Halvade has a slightly higher sensitivity of 0.23 percentage points than SparkRA, and a slightly higher precision of 0.04 percentage points. This difference can be attributed to the significantly increased number of regions (29% more) created by SparkRA (183 regions) compared to Halvade (142 regions). The increased number of regions of SparkRA allows for the large amount of performance increase as compared to Halvade, albeit at a minor degradation in accuracy.</p>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="sec5-genes-11-00053">
    <title>5. Conclusions</title>
    <p>This paper introduced SparkRA, an RNA-seq analysis pipeline that allows for easy and efficient scalability of the GATK RNA-seq best practices pipeline using the Apache Spark big data framework. SparkRA scales up the computations by dividing data files into chunks that get processed in parallel by executing multiple instances of the GATK pipeline tools. It can help scale performance of the pipeline both on a single compute node, and on a large compute cluster. Our solution is able to limit the imbalance in the computation time between different chunks of the data using a fast heuristic consisting of two load balancing stages: Static and dynamic load balancing. This approach allows for load balancing that is both fast as well as fine tuned to the input data. Experimental results show that SparkRA is effective in utilizing CPU resources keeping CPU of all nodes active at close to 100% utilization most of the time. SparkRA can achieve 7.8× speedup on a single node compared with a single thread run of the GATK pipeline. On a cluster of 16 nodes, SparkRA can achieve further speedup of 7.7× compared to a single node. Compared to existing state-of-the-art solutions, SparkRA is about 1.2× faster, while achieving the same accuracy of results.</p>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgments</title>
    <p>The experiments in this paper have been performed on the Dutch national e-infrastructure with support from the SURF cooperative.</p>
  </ack>
  <notes>
    <title>Author Contributions</title>
    <p>conceptualization, Z.A.-A.; methodology, S.W. and H.M.; software, S.W.; validation, S.W.; investigation, S.W. and H.M.; writing–original draft preparation, Z.A.-A.; writing–review and editing, Z.A.-A.; visualization, S.W. and Z.A.-A.; supervision, Z.A.-A. and H.M. All authors have read and agreed to the published version of the manuscript.</p>
  </notes>
  <notes>
    <title>Funding</title>
    <p>This research received no external funding.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Conflicts of Interest</title>
    <p>The authors declare no conflict of interest.</p>
  </notes>
  <ref-list>
    <title>References</title>
    <ref id="B1-genes-11-00053">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Van der Auwera</surname>
            <given-names>G.A.</given-names>
          </name>
          <name>
            <surname>Carneiro</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Hartl</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Poplin</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>del Angel</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Levy-Moonshine</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Jordan</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Shakir</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Roazen</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Thibault</surname>
            <given-names>J.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>From FastQ Data to High-Confidence Variant Calls: The Genome Analysis Toolkit Best Practices Pipeline</article-title>
        <source>Curr. Protoc. Bioinform.</source>
        <year>2013</year>
        <volume>43</volume>
        <fpage>11.10.1</fpage>
        <lpage>11.10.33</lpage>
      </element-citation>
    </ref>
    <ref id="B2-genes-11-00053">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kelly</surname>
            <given-names>B.J.</given-names>
          </name>
          <name>
            <surname>Fitch</surname>
            <given-names>J.R.</given-names>
          </name>
          <name>
            <surname>Hu</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Corsmeier</surname>
            <given-names>D.J.</given-names>
          </name>
          <name>
            <surname>Zhong</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Wetzel</surname>
            <given-names>A.N.</given-names>
          </name>
          <name>
            <surname>Nordquist</surname>
            <given-names>R.D.</given-names>
          </name>
          <name>
            <surname>Newsom</surname>
            <given-names>D.L.</given-names>
          </name>
          <name>
            <surname>White</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>Churchill: An ultra-fast, deterministic, highly scalable and balanced parallelization strategy for the discovery of human genetic variation in clinical and population-scale genomics</article-title>
        <source>Genome Biol.</source>
        <year>2015</year>
        <volume>16</volume>
        <pub-id pub-id-type="doi">10.1186/s13059-014-0577-x</pub-id>
        <?supplied-pmid 25600152?>
        <pub-id pub-id-type="pmid">25600152</pub-id>
      </element-citation>
    </ref>
    <ref id="B3-genes-11-00053">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Decap</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Reumers</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Herzeel</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Costanza</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Fostier</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Halvade: Scalable sequence analysis with MapReduce</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <fpage>2482</fpage>
        <lpage>2488</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv179</pub-id>
        <pub-id pub-id-type="pmid">25819078</pub-id>
      </element-citation>
    </ref>
    <ref id="B4-genes-11-00053">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dean</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Ghemawat</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>MapReduce: Simplified Data Processing on Large Clusters</article-title>
        <source>Commun. ACM</source>
        <year>2008</year>
        <volume>51</volume>
        <fpage>107</fpage>
        <lpage>113</lpage>
        <pub-id pub-id-type="doi">10.1145/1327452.1327492</pub-id>
      </element-citation>
    </ref>
    <ref id="B5-genes-11-00053">
      <label>5.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Mushtaq</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Costa</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Hofstee</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z.</given-names>
          </name>
        </person-group>
        <article-title>SparkGA: A Spark Framework for Cost Effective, Fast and Accurate DNA Analysis at Scale</article-title>
        <source>Proceedings of the ACM Conference Bioinformatics, Computational Biology and Health Informatics</source>
        <conf-loc>Boston, MA, USA</conf-loc>
        <conf-date>20–23 August 2017</conf-date>
      </element-citation>
    </ref>
    <ref id="B6-genes-11-00053">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mushtaq</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Ahmed</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z.</given-names>
          </name>
        </person-group>
        <article-title>SparkGA2: Production-Quality Memory-Efficient Apache Spark Based Genome Analysis Framework</article-title>
        <source>PLoS ONE</source>
        <year>2019</year>
        <volume>14</volume>
        <elocation-id>e0224784</elocation-id>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0224784</pub-id>
        <pub-id pub-id-type="pmid">31805063</pub-id>
      </element-citation>
    </ref>
    <ref id="B7-genes-11-00053">
      <label>7.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Mushtaq</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z.</given-names>
          </name>
        </person-group>
        <article-title>Cluster-based Apache Spark implementation of the GATK DNA analysis pipeline</article-title>
        <source>Proceedings of the IEEE International Conference on Bioinformatics and Biomedicine (BIBM)</source>
        <conf-loc>Washington, DC, USA</conf-loc>
        <conf-date>9–12 November 2015</conf-date>
        <fpage>1471</fpage>
        <lpage>1477</lpage>
      </element-citation>
    </ref>
    <ref id="B8-genes-11-00053">
      <label>8.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Zaharia</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Chowdhury</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Franklin</surname>
            <given-names>M.J.</given-names>
          </name>
          <name>
            <surname>Shenker</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Stoica</surname>
            <given-names>I.</given-names>
          </name>
        </person-group>
        <article-title>Spark: Cluster computing with working sets</article-title>
        <source>Proceedings of the 2nd USENIX Conference on Hot Topics in Cloud Computing (HotCloud’10)</source>
        <conf-loc>Boston, MA, USA</conf-loc>
        <conf-date>22–25 June 2010</conf-date>
      </element-citation>
    </ref>
    <ref id="B9-genes-11-00053">
      <label>9.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Hasan</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z.</given-names>
          </name>
        </person-group>
        <article-title>An Efficient and High Performance Linear Recursive Variable Expansion Implementation of the Smith-Waterman Algorithm</article-title>
        <source>Proceedings of the IEEE Engineering in Medicine and Biology Conference</source>
        <conf-loc>Minneapolis, MN, USA</conf-loc>
        <conf-date>3–6 September 2009</conf-date>
        <fpage>3845</fpage>
        <lpage>3848</lpage>
      </element-citation>
    </ref>
    <ref id="B10-genes-11-00053">
      <label>10.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Hasan</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z.</given-names>
          </name>
        </person-group>
        <article-title>An Overview of Hardware-based Acceleration of Biological Sequence Alignment</article-title>
        <source>Computational Biology and Applied Bioinformatics</source>
        <publisher-name>InTech</publisher-name>
        <publisher-loc>Rijeka, Croatia</publisher-loc>
        <year>2011</year>
        <fpage>187</fpage>
        <lpage>202</lpage>
      </element-citation>
    </ref>
    <ref id="B11-genes-11-00053">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Han</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Gao</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Muegge</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Bing</surname>
            <given-names>Z.</given-names>
          </name>
        </person-group>
        <article-title>Advanced applications of RNA sequencing and challenges</article-title>
        <source>Bioinform. Biol. Insights</source>
        <year>2015</year>
        <pub-id pub-id-type="doi">10.4137/BBI.S28991</pub-id>
        <?supplied-pmid 26609224?>
        <pub-id pub-id-type="pmid">26609224</pub-id>
      </element-citation>
    </ref>
    <ref id="B12-genes-11-00053">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Piskol</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Ramaswami</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>J.B.</given-names>
          </name>
        </person-group>
        <article-title>Reliable identification of genomic variants from RNA-seq data</article-title>
        <source>Am. J. Hum. Genet.</source>
        <year>2013</year>
        <volume>4</volume>
        <fpage>641</fpage>
        <lpage>651</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ajhg.2013.08.008</pub-id>
        <?supplied-pmid 24075185?>
        <pub-id pub-id-type="pmid">24075185</pub-id>
      </element-citation>
    </ref>
    <ref id="B13-genes-11-00053">
      <label>13.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cummings</surname>
            <given-names>B.B.</given-names>
          </name>
          <name>
            <surname>Marshall</surname>
            <given-names>J.L.</given-names>
          </name>
          <name>
            <surname>Tukiainen</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Lek</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Donkervoort</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Foley</surname>
            <given-names>A.R.</given-names>
          </name>
          <name>
            <surname>Bolduc</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>dell Wa</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Sandaradura</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>O’Grady</surname>
            <given-names>G.L.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Improving genetic diagnosis in mendelian disease with transcriptome sequencing</article-title>
        <source>Sci. Transl. Med.</source>
        <year>2017</year>
        <volume>9</volume>
        <pub-id pub-id-type="doi">10.1126/scitranslmed.aal5209</pub-id>
        <?supplied-pmid 28424332?>
        <pub-id pub-id-type="pmid">28424332</pub-id>
      </element-citation>
    </ref>
    <ref id="B14-genes-11-00053">
      <label>14.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>T.D.</given-names>
          </name>
          <name>
            <surname>Nacu</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>Fast and SNP-tolerant detection of complex variants and splicing in short reads</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>873</fpage>
        <lpage>881</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq057</pub-id>
        <?supplied-pmid 20147302?>
        <pub-id pub-id-type="pmid">20147302</pub-id>
      </element-citation>
    </ref>
    <ref id="B15-genes-11-00053">
      <label>15.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Singh</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Zeng</surname>
            <given-names>Z.</given-names>
          </name>
          <name>
            <surname>Coleman</surname>
            <given-names>S.J.</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Savich</surname>
            <given-names>G.L.</given-names>
          </name>
          <name>
            <surname>He</surname>
            <given-names>X.</given-names>
          </name>
          <name>
            <surname>Mieczkowski</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Grimm</surname>
            <given-names>S.A.</given-names>
          </name>
          <name>
            <surname>Perou</surname>
            <given-names>C.M.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mapsplice: Accurate mapping of rna-seq reads for splice junction discovery</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2010</year>
        <volume>38</volume>
        <fpage>e178</fpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkq622</pub-id>
        <?supplied-pmid 20802226?>
        <pub-id pub-id-type="pmid">20802226</pub-id>
      </element-citation>
    </ref>
    <ref id="B16-genes-11-00053">
      <label>16.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Pertea</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Trapnell</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Pimentel</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Kelley</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>S.L.</given-names>
          </name>
        </person-group>
        <article-title>Tophat2: Accurate alignment of transcriptomes in the presence of insertions, deletions and gene fusions</article-title>
        <source>Genome Biol.</source>
        <year>2013</year>
        <volume>14</volume>
        <fpage>R36</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2013-14-4-r36</pub-id>
        <?supplied-pmid 23618408?>
        <pub-id pub-id-type="pmid">23618408</pub-id>
      </element-citation>
    </ref>
    <ref id="B17-genes-11-00053">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dobin</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>C.A.</given-names>
          </name>
          <name>
            <surname>Schlesinger</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Drenkow</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Zaleski</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Jha</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Batut</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Chaisson</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Gingeras</surname>
            <given-names>T.R.</given-names>
          </name>
        </person-group>
        <article-title>Star: Ultrafast universal rna-seq aligner</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <fpage>15</fpage>
        <lpage>21</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts635</pub-id>
        <?supplied-pmid 23104886?>
        <pub-id pub-id-type="pmid">23104886</pub-id>
      </element-citation>
    </ref>
    <ref id="B18-genes-11-00053">
      <label>18.</label>
      <element-citation publication-type="web">
        <person-group person-group-type="author">
          <collab>GATK</collab>
        </person-group>
        <article-title>Calling Variants in RNAseq</article-title>
        <comment>Available online: <ext-link ext-link-type="uri" xlink:href="https://software.broadinstitute.org/gatk/documentation/article.php?id=3891">https://software.broadinstitute.org/gatk/documentation/article.php?id=3891</ext-link></comment>
        <date-in-citation content-type="access-date" iso-8601-date="2019-10-19">(accessed on 19 October 2019)</date-in-citation>
      </element-citation>
    </ref>
    <ref id="B19-genes-11-00053">
      <label>19.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Decap</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Reumers</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Herzeel</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Costanza</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Fostier</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Halvade-rna: Parallel variant calling from transcriptomic data using mapreduce</article-title>
        <source>PLoS ONE</source>
        <year>2017</year>
        <volume>12</volume>
        <elocation-id>e0174575</elocation-id>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0174575</pub-id>
        <?supplied-pmid 28358893?>
        <pub-id pub-id-type="pmid">28358893</pub-id>
      </element-citation>
    </ref>
    <ref id="B20-genes-11-00053">
      <label>20.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Engstrom</surname>
            <given-names>P.G.</given-names>
          </name>
          <name>
            <surname>Steijger</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Sipos</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Grant</surname>
            <given-names>G.R.</given-names>
          </name>
          <name>
            <surname>Kahles</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Rätsch</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Goldman</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Hubbard</surname>
            <given-names>T.J.</given-names>
          </name>
          <name>
            <surname>Harrow</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Guigó</surname>
            <given-names>R.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Systematic evaluation of spliced alignment programs for rna-seq data</article-title>
        <source>Nat. Methods</source>
        <year>2013</year>
        <volume>10</volume>
        <fpage>1185</fpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.2722</pub-id>
        <?supplied-pmid 24185836?>
        <pub-id pub-id-type="pmid">24185836</pub-id>
      </element-citation>
    </ref>
    <ref id="B21-genes-11-00053">
      <label>21.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <source>Scaling Up the GATK RNA-seq Variant Calling Pipeline with Apache Spark</source>
        <publisher-name>Delft University of Technology</publisher-name>
        <publisher-loc>Delft, The Netherlands</publisher-loc>
        <year>2018</year>
      </element-citation>
    </ref>
    <ref id="B22-genes-11-00053">
      <label>22.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <collab>ENCODE Project Consortium</collab>
        </person-group>
        <article-title>An integrated encyclopedia of dna elements in the human genome</article-title>
        <source>Nature</source>
        <year>2012</year>
        <volume>489</volume>
        <fpage>57</fpage>
        <pub-id pub-id-type="doi">10.1038/nature11247</pub-id>
        <?supplied-pmid 22955616?>
        <pub-id pub-id-type="pmid">22955616</pub-id>
      </element-citation>
    </ref>
    <ref id="B23-genes-11-00053">
      <label>23.</label>
      <element-citation publication-type="web">
        <article-title>SURFsara</article-title>
        <comment>Available online: <ext-link ext-link-type="uri" xlink:href="https://www.surf.nl/en/research-ict">https://www.surf.nl/en/research-ict</ext-link></comment>
        <date-in-citation content-type="access-date" iso-8601-date="2019-10-19">(accessed on 19 October 2019)</date-in-citation>
      </element-citation>
    </ref>
    <ref id="B24-genes-11-00053">
      <label>24.</label>
      <element-citation publication-type="web">
        <article-title>iostat Linux Man Page</article-title>
        <comment>Available online: <ext-link ext-link-type="uri" xlink:href="https://linux.die.net/man/1/iostat">https://linux.die.net/man/1/iostat</ext-link></comment>
        <date-in-citation content-type="access-date" iso-8601-date="2019-10-19">(accessed on 19 October 2019)</date-in-citation>
      </element-citation>
    </ref>
    <ref id="B25-genes-11-00053">
      <label>25.</label>
      <element-citation publication-type="web">
        <article-title>RTG Tools, Real Time Genomics</article-title>
        <comment>Available online: <ext-link ext-link-type="uri" xlink:href="https://www.realtimegenomics.com/products/rtg-tools">https://www.realtimegenomics.com/products/rtg-tools</ext-link></comment>
        <date-in-citation content-type="access-date" iso-8601-date="2019-10-19">(accessed on 19 October 2019)</date-in-citation>
      </element-citation>
    </ref>
  </ref-list>
</back>
<floats-group>
  <fig id="genes-11-00053-f001" orientation="portrait" position="float">
    <label>Figure 1</label>
    <caption>
      <p>Tools used in the GATK RNA-seq pipeline and the way they process the data from input to output.</p>
    </caption>
    <graphic xlink:href="genes-11-00053-g001"/>
  </fig>
  <fig id="genes-11-00053-f002" orientation="portrait" position="float">
    <label>Figure 2</label>
    <caption>
      <p>Scalability bottlenecks of the different tools in the GATK RNA-seq pipeline.</p>
    </caption>
    <graphic xlink:href="genes-11-00053-g002"/>
  </fig>
  <fig id="genes-11-00053-f003" orientation="portrait" position="float">
    <label>Figure 3</label>
    <caption>
      <p>Percentage of time taken by each tool in the GATK RNA-seq pipeline on a single node with 40 threads.</p>
    </caption>
    <graphic xlink:href="genes-11-00053-g003"/>
  </fig>
  <fig id="genes-11-00053-f004" orientation="portrait" position="float">
    <label>Figure 4</label>
    <caption>
      <p>Execution flow of the SparkRA pipeline.</p>
    </caption>
    <graphic xlink:href="genes-11-00053-g004"/>
  </fig>
  <fig id="genes-11-00053-f005" orientation="portrait" position="float">
    <label>Figure 5</label>
    <caption>
      <p>Histogram of the size of regions (in MB) generated by SparkRA (<bold>left</bold>) and Halvade-RNA (<bold>right</bold>).</p>
    </caption>
    <graphic xlink:href="genes-11-00053-g005"/>
  </fig>
  <fig id="genes-11-00053-f006" orientation="portrait" position="float">
    <label>Figure 6</label>
    <caption>
      <p>Single-node speedup of 40-thread GATK RNA-seq (GATK40), Halvade-RNA and SparkRA over single-threaded GATK RNA-seq (GATK1).</p>
    </caption>
    <graphic xlink:href="genes-11-00053-g006"/>
  </fig>
  <fig id="genes-11-00053-f007" orientation="portrait" position="float">
    <label>Figure 7</label>
    <caption>
      <p>Speedup achieved by SparkRA and its parts when running on 1, 4, 8 and 16 nodes in the cluster.</p>
    </caption>
    <graphic xlink:href="genes-11-00053-g007"/>
  </fig>
  <fig id="genes-11-00053-f008" orientation="portrait" position="float">
    <label>Figure 8</label>
    <caption>
      <p>Average CPU utilization of the three different parts of SparkRA on a 16-node cluster. In Part 1, there are three steps: STAR pass 1, STAR index regeneration, and STAR pass 2. The top and bottom charts show utilization in a node with and without genome index regeneration, respectively. Parts 2 and 3 are not shown in the bottom chart, since they are identical to the top chart. Measurements are generated using the iostat profiler [<xref rid="B24-genes-11-00053" ref-type="bibr">24</xref>].</p>
    </caption>
    <graphic xlink:href="genes-11-00053-g008"/>
  </fig>
  <table-wrap id="genes-11-00053-t001" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-11-00053-t001_Table 1</object-id>
    <label>Table 1</label>
    <caption>
      <p>Impact of the user requested number of the regions (<inline-formula><mml:math id="mm17"><mml:mrow><mml:mi mathvariant="italic">numRegions</mml:mi></mml:mrow></mml:math></inline-formula>) on the actual number of regions generated during static (<inline-formula><mml:math id="mm18"><mml:mrow><mml:msub><mml:mi mathvariant="italic">R</mml:mi><mml:mi mathvariant="italic">sLB</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) and dynamic (<inline-formula><mml:math id="mm19"><mml:mrow><mml:msub><mml:mi mathvariant="italic">R</mml:mi><mml:mi mathvariant="italic">dLB</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) load balancing, in addition to the resulting total computation time of the pipeline and that of Parts 1 to 3 (single-node performance).</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="center" valign="middle" style="border-top:solid thin" rowspan="1" colspan="1">
</th>
          <th align="center" valign="middle" style="border-top:solid thin" rowspan="1" colspan="1">
</th>
          <th align="center" valign="middle" style="border-top:solid thin" rowspan="1" colspan="1">
</th>
          <th colspan="4" align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1">Time [minutes]</th>
        </tr>
        <tr>
          <th align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
            <inline-formula>
              <mml:math id="mm20">
                <mml:mrow>
                  <mml:mstyle mathvariant="bold">
                    <mml:mi mathvariant="bold-italic">numRegions</mml:mi>
                  </mml:mstyle>
                </mml:mrow>
              </mml:math>
            </inline-formula>
          </th>
          <th align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
            <inline-formula>
              <mml:math id="mm21">
                <mml:mrow>
                  <mml:mstyle mathvariant="bold">
                    <mml:msub>
                      <mml:mi mathvariant="bold-italic">R</mml:mi>
                      <mml:mi mathvariant="bold-italic">sLB</mml:mi>
                    </mml:msub>
                  </mml:mstyle>
                </mml:mrow>
              </mml:math>
            </inline-formula>
          </th>
          <th align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
            <inline-formula>
              <mml:math id="mm22">
                <mml:mrow>
                  <mml:mstyle mathvariant="bold">
                    <mml:msub>
                      <mml:mi mathvariant="bold-italic">R</mml:mi>
                      <mml:mi mathvariant="bold-italic">dLB</mml:mi>
                    </mml:msub>
                  </mml:mstyle>
                </mml:mrow>
              </mml:math>
            </inline-formula>
          </th>
          <th align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Part 1</th>
          <th align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Part 2</th>
          <th align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Part 3</th>
          <th align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Total</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="center" valign="middle" rowspan="1" colspan="1">180</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">224</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">304</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">39.4</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">9.33</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">32.5</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">81.2</td>
        </tr>
        <tr>
          <td align="center" valign="middle" rowspan="1" colspan="1">144</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">193</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">262</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">39.7</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">10.3</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">30.8</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">80.8</td>
        </tr>
        <tr>
          <td align="center" valign="middle" rowspan="1" colspan="1">108</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">156</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">217</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">40.7</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">11.2</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">29.2</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">81.0</td>
        </tr>
        <tr>
          <td align="center" valign="middle" rowspan="1" colspan="1">72</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">123</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">183</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">39.7</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">11.4</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">29.1</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">80.2</td>
        </tr>
        <tr>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">50</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">103</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">161</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">40.0</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">13.8</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">29.4</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">83.2</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="genes-11-00053-t002" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-11-00053-t002_Table 2</object-id>
    <label>Table 2</label>
    <caption>
      <p>Pipeline computation time (in minutes) comparison of GATK RNA-seq running with one thread (GATK1) and 40 threads (GATK40) with Halvade-RNA and SparkRA (single-node performance).</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th colspan="2" align="left" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1">Pipeline Stage</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">GATK1</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">GATK40</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Halvade</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">SparkRA</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td rowspan="4" align="left" valign="middle" style="border-bottom:solid thin" colspan="1">Part 1:</td>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">STAR (pass 1)</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">92.4</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">9.87</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">9.60</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">10.5</td>
        </tr>
        <tr>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Index rebuild</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">152</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">39.2</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">6.70</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">6.27</td>
        </tr>
        <tr>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">STAR (pass 2)</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">116</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">14.0</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">33.0</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">22.9</td>
        </tr>
        <tr>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Total Part 1</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">360</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">63.1</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">49.3</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">39.7</td>
        </tr>
        <tr>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Part 2:</td>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Sorting</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">n/a</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">n/a</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">n/a</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">11.4</td>
        </tr>
        <tr>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Part 3:</td>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Picard &amp; GATK</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">265</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">255</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">56.8</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">29.1</td>
        </tr>
        <tr>
          <td colspan="2" align="left" valign="middle" style="border-bottom:solid thin" rowspan="1">Total pipeline time</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">625</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">318</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">106</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">80.2</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="genes-11-00053-t003" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-11-00053-t003_Table 3</object-id>
    <label>Table 3</label>
    <caption>
      <p>Pipeline computation time (in minutes) results and speedup of SparkRA compared to Halvade-RNA running on the SURFsara cluster.</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="left" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Pipeline Stage</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Halvade</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">SparkRA</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Speedup</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="left" valign="middle" rowspan="1" colspan="1">Part 1: Mapping</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">54.7</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">47.2</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">1.16</td>
        </tr>
        <tr>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Parts 2 and 3: Sorting, Picard &amp; GATK</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">26.2</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">19.3</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1.36</td>
        </tr>
        <tr>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Total pipeline time</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">80.9</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">66.5</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1.22</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="genes-11-00053-t004" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-11-00053-t004_Table 4</object-id>
    <label>Table 4</label>
    <caption>
      <p>Accuracy of VCF files generated by the cluster deployment of SparkRA and Halvade-RNA as compared with the GATK baseline in terms of sensitivity and precision. The comparison results were generated using RTG Tools [<xref rid="B25-genes-11-00053" ref-type="bibr">25</xref>].</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="left" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Pipeline</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">#Regions</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">TP</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">FP</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">FN</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Sensitivity</th>
          <th align="center" valign="middle" style="border-bottom:solid thin;border-top:solid thin" rowspan="1" colspan="1">Precision</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="left" valign="middle" rowspan="1" colspan="1">SparkRA</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">183</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">109411</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">6886</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">6363</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">94.50%</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">94.08%</td>
        </tr>
        <tr>
          <td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Halvade</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">142</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">109669</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">6850</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">6105</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">94.73%</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">94.12%</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
</floats-group>
