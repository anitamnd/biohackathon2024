<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8355039</article-id>
    <article-id pub-id-type="pmid">32915952</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btaa777</article-id>
    <article-id pub-id-type="publisher-id">btaa777</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Fast gap-affine pairwise alignment using the wavefront algorithm</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-7951-3914</contrib-id>
        <name>
          <surname>Marco-Sola</surname>
          <given-names>Santiago</given-names>
        </name>
        <xref rid="btaa777-cor1" ref-type="corresp"/>
        <aff><institution>Department of Computer Sciences, Barcelona Supercomputing Center</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
        <aff><institution>Departament d’Arquitectura de Computadors i Sistemes Operatius, Universitat Autònoma de Barcelona</institution>, Barcelona 08193, <country country="ES">Spain</country></aff>
        <!--santiagomsola@gmail.com-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Moure</surname>
          <given-names>Juan Carlos</given-names>
        </name>
        <aff><institution>Departament d’Arquitectura de Computadors i Sistemes Operatius, Universitat Autònoma de Barcelona</institution>, Barcelona 08193, <country country="ES">Spain</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Moreto</surname>
          <given-names>Miquel</given-names>
        </name>
        <aff><institution>Department of Computer Sciences, Barcelona Supercomputing Center</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
        <aff><institution>Departament d’Arquitectura de Computadors, Universitat Politècnica de Catalunya</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Espinosa</surname>
          <given-names>Antonio</given-names>
        </name>
        <aff><institution>Departament d’Arquitectura de Computadors i Sistemes Operatius, Universitat Autònoma de Barcelona</institution>, Barcelona 08193, <country country="ES">Spain</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Robinson</surname>
          <given-names>Peter</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btaa777-cor1">To whom correspondence should be addressed. <email>santiagomsola@gmail.com</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <day>15</day>
      <month>2</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2020-09-11">
      <day>11</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>11</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <volume>37</volume>
    <issue>4</issue>
    <fpage>456</fpage>
    <lpage>463</lpage>
    <history>
      <date date-type="received">
        <day>08</day>
        <month>4</month>
        <year>2020</year>
      </date>
      <date date-type="rev-recd">
        <day>22</day>
        <month>7</month>
        <year>2020</year>
      </date>
      <date date-type="editorial-decision">
        <day>26</day>
        <month>8</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>01</day>
        <month>9</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2020</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbynclicense">https://creativecommons.org/licenses/by-nc/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btaa777.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Pairwise alignment of sequences is a fundamental method in modern molecular biology, implemented within multiple bioinformatics tools and libraries. Current advances in sequencing technologies press for the development of faster pairwise alignment algorithms that can scale with increasing read lengths and production yields.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this article, we present the wavefront alignment algorithm (WFA), an exact gap-affine algorithm that takes advantage of homologous regions between the sequences to accelerate the alignment process. As opposed to traditional dynamic programming algorithms that run in quadratic time, the WFA runs in time <italic toggle="yes">O</italic>(<italic toggle="yes">ns</italic>), proportional to the read length <italic toggle="yes">n</italic> and the alignment score <italic toggle="yes">s</italic>, using <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory. Furthermore, our algorithm exhibits simple data dependencies that can be easily vectorized, even by the automatic features of modern compilers, for different architectures, without the need to adapt the code. We evaluate the performance of our algorithm, together with other state-of-the-art implementations. As a result, we demonstrate that the WFA runs 20–300× faster than other methods aligning short Illumina-like sequences, and 10–100× faster using long noisy reads like those produced by Oxford Nanopore Technologies.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The WFA algorithm is implemented within the wavefront-aligner library, and it is publicly available at <ext-link xlink:href="https://github.com/smarco/WFA" ext-link-type="uri">https://github.com/smarco/WFA</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Unions’s Horizon 2020 Framework Programme under the DeepHealth</institution>
          </institution-wrap>
        </funding-source>
        <award-id>825111</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union Regional Development Fund within the framework of the ERDF Operational Program of Catalonia 2014-2020</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>DRAC</institution>
          </institution-wrap>
        </funding-source>
        <award-id>001-P-001723</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>MINECO-Spain</institution>
          </institution-wrap>
        </funding-source>
        <award-id>TIN2017-84553-C2-1-R</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>TIN2015-65316-P</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Catalan government</institution>
          </institution-wrap>
        </funding-source>
        <award-id>2017-SGR-313</award-id>
        <award-id>2017-SGR-1328</award-id>
        <award-id>2017-SGR-1414</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Spanish Ministry of Economy, Industry and Competitiveness</institution>
          </institution-wrap>
        </funding-source>
        <award-id>RYC-2016-21104</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Pairwise alignment of biological sequences is a core component of many bioinformatics tools. In genomics, it is an essential building block for read mapping (<xref rid="btaa777-B12" ref-type="bibr">Langmead and Salzberg, 2012</xref>; <xref rid="btaa777-B13" ref-type="bibr">Li, 2013</xref>; <xref rid="btaa777-B19" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2012</xref>), variant detection (<xref rid="btaa777-B5" ref-type="bibr">DePristo <italic toggle="yes">et al.</italic>, 2011</xref>), <italic toggle="yes">de novo</italic> genome assembly (<xref rid="btaa777-B28" ref-type="bibr">Simpson <italic toggle="yes">et al.</italic>, 2009</xref>), multiple sequence alignment (<xref rid="btaa777-B25" ref-type="bibr">Notredame <italic toggle="yes">et al.</italic>, 2000</xref>) and many other methods. Moreover, it can be adapted to different protocols and applications (e.g. DNA-seq, RNA-seq or bisulfite analysis) using different distance functions (e.g. mismatch, edit, gap-linear or gap-affine), modifying the alignment scope (e.g. global, semi-global or local alignment) or adjusting the scoring penalties. Nevertheless, all these variations share the same algorithmic core.</p>
    <p>Over the last decade, the volume of biological data generated by sequencing technologies has increased exponentially. Besides, third-generation technologies, such as those developed by PacBio and Oxford Nanopore Technologies (ONT), can yield sequences longer than 20K bases; more than 100× longer than those produced by the extensively used Illumina sequencers. This presses for the development of faster algorithms that can keep up with the data production pace and scale with longer read lengths produced by newer sequencing technologies.</p>
    <p>In its most common formulation, the pairwise alignment problem is solved using some variation of the Needleman–Wunsch (NW) algorithm (<xref rid="btaa777-B24" ref-type="bibr">Needleman and Wunsch, 1970</xref>) for gap-linear penalties or the Smith–Waterman–Gotoh (SWG) algorithm (<xref rid="btaa777-B7" ref-type="bibr">Gotoh, 1982</xref>) for gap-affine penalties. These solutions are based on dynamic programming (DP) and consist on first computing the recurrence equations on a DP matrix, and then tracing back the optimal alignment. As a result, they require quadratic time and memory on the length of the sequences.</p>
    <p>Over the years, these algorithms have been extensively studied, and many different techniques and heuristics have been developed to accelerate DP computations. The most successful optimizations focus on vectorization strategies (<xref rid="btaa777-B3" ref-type="bibr">Daily, 2016</xref>) (including bit-parallel encodings <xref rid="btaa777-B18" ref-type="bibr">Loving <italic toggle="yes">et al.</italic>, 2014</xref>), banded computations (<xref rid="btaa777-B30" ref-type="bibr">Suzuki and Kasahara, 2017</xref>) and cut-off techniques (<xref rid="btaa777-B9" ref-type="bibr">Gusfield, 1997</xref>). Notwithstanding these efforts, the quadratic execution time of classical approaches quickly becomes the bottleneck, and these methods fail to scale with longer read lengths. Besides, intrinsic dependencies on the DP recurrences limit the effectiveness of vectorization approaches; what is more, they require <italic toggle="yes">ad hoc</italic> implementations for each different SIMD instruction set. In many cases, practical implementations tend to apply heuristics that can miss the optimal alignment at the expense of faster execution times. Interestingly, all these algorithms are oblivious to the similarities between the sequences. That is, they perform the same computations whether the sequences are highly divergent or completely identical.</p>
    <sec>
      <title>1.1 Previous work</title>
      <p>Over the years, alignment algorithms for the edit distance have been largely studied and optimized due to its simplicity. As a result, many efficient libraries and tools like Edlib (<xref rid="btaa777-B29" ref-type="bibr">Šošić and Šikić, 2017</xref>) [implementing Myers’s bit-vector algorithm (<xref rid="btaa777-B22" ref-type="bibr">Myers, 1999</xref>)], or DAligner (<xref rid="btaa777-B23" ref-type="bibr">Myers, 2014</xref>) [implementing Myers’s O(ND) difference algorithm (<xref rid="btaa777-B21" ref-type="bibr">Myers, 1986</xref>)] are now available. However, the edit distance fails to capture critical properties of the difference between biological sequences. For that reason, gap-affine distance is commonly preferred, and thus many research efforts have been invested on accelerating the SWG algorithm.</p>
      <p>Many of the SWG optimization techniques are focused on exploiting intra-sequence parallelism using tailored vectorization strategies. In this way, <xref rid="btaa777-B34" ref-type="bibr">Wozniak (1997)</xref> first proposed to compute DP cells along the minor diagonal in parallel. Then, Rognes (<xref rid="btaa777-B27" ref-type="bibr">Rognes and Seeberg, 2000</xref>) proposed to vectorize along the query sequence, introducing the query profile technique. Later on, <xref rid="btaa777-B6" ref-type="bibr">Farrar (2007)</xref> proposed to reorganize computations in a striped fashion. Farrar’s method dominated over all other approaches until Daily presented the prefix-scan method (<xref rid="btaa777-B4" ref-type="bibr">Daily <italic toggle="yes">et al.</italic>, 2015</xref>), which in practice outperforms all previous methods. Meanwhile, focusing on further exploiting instruction-level parallelism, the BitPAl algorithm (<xref rid="btaa777-B18" ref-type="bibr">Loving <italic toggle="yes">et al.</italic>, 2014</xref>) was presented as a natural extension of Myers’s bit-vector algorithm restricted to gap-linear penalties. Although it requires generating tailored code for each different set of penalties, it represents an interesting method for computing the alignment distance (i.e. not the full alignment) if all the penalties are fixed and known in advance.</p>
      <p>Recently, <xref rid="btaa777-B31" ref-type="bibr">Suzuki and Kasahara (2018)</xref> proposed a differential encoding of the DP matrix that effectively reduces the size required to store each DP cell to further exploit SIMD operations. Combined with an adaptive-band, that adjusts its size according to the scores computed so far, they developed the Gaba library (<xref rid="btaa777-B30" ref-type="bibr">Suzuki and Kasahara, 2017</xref>). Because of its good performance, this algorithm was re-implemented in the KSW2 library, which is currently used within the core of the Minimap2 mapper (<xref rid="btaa777-B14" ref-type="bibr">Li, 2018</xref>).</p>
      <p>Over the past decade, many libraries implementing efficient SWG algorithms have been developed due to its critical role in several bioinformatics tools and pipelines. The SSW library (<xref rid="btaa777-B35" ref-type="bibr">Zhao <italic toggle="yes">et al.</italic>, 2013</xref>) was one of the first libraries to offer an efficient implementation of the SWG using Farrar’s striped algorithm. Later on, the Parasail library (<xref rid="btaa777-B3" ref-type="bibr">Daily, 2016</xref>), that implements several intra-sequence vectorization strategies, was published. But also, the SeqAn (<xref rid="btaa777-B26" ref-type="bibr">Rahn <italic toggle="yes">et al.</italic>, 2018</xref>) developers have put many efforts into incorporating high-performance and parallel implementations of the SWG among its many algorithms. At the same time, all these libraries implement additional optimizations that can further enhance the presented methods. For instance, the integer saturation strategy, which first computes the alignment using a small integer type, and recomputes the alignment in case an overflow/underflow is detected. In addition, these libraries implement several coarse-grain parallelization techniques that allow performing various independent alignments in parallel. But also, they include tailored implementations for specific SIMD instruction sets than can yield shorter execution times.</p>
      <table-wrap position="float" id="btaa777-T1">
        <label>Table 1.</label>
        <caption>
          <p>Notations</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Symbol</th>
              <th rowspan="1" colspan="1">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1"><italic toggle="yes">q</italic>, <italic toggle="yes">t</italic></td>
              <td rowspan="1" colspan="1">Strings: <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE3">
                  <mml:math id="IM3" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mi>p</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mo>{</mml:mo>
                      <mml:mi>a</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>x</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>o</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>e</mml:mi>
                      <mml:mo>}</mml:mo>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">Gap-affine penalty scores</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"><italic toggle="yes">M</italic>, <italic toggle="yes">I</italic>, <italic toggle="yes">D</italic></td>
              <td rowspan="1" colspan="1">SWG alignment matrices</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE4">
                  <mml:math id="IM4" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi mathvariant="script">F</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:mi>k</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">Furthest-reaching (f.r.) point on diagonal <italic toggle="yes">k</italic> with score <italic toggle="yes">s</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE5">
                  <mml:math id="IM5" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>M</mml:mi>
                            <mml:mo>˜</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                          <mml:mo>,</mml:mo>
                          <mml:mi>k</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">Offset in the diagonal to the corresponding f.r. point <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE7">
                  <mml:math id="IM7" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>I</mml:mi>
                            </mml:mrow>
                            <mml:mi>s</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                        <mml:mo stretchy="false">˜</mml:mo>
                      </mml:mover>
                      <mml:mo>,</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mrow>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>D</mml:mi>
                              </mml:mrow>
                              <mml:mi>s</mml:mi>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mo stretchy="false">˜</mml:mo>
                        </mml:mover>
                      </mml:mrow>
                      <mml:mo>,</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mrow>
                        <mml:mover accent="true">
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>M</mml:mi>
                              </mml:mrow>
                              <mml:mi>s</mml:mi>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mo stretchy="false">˜</mml:mo>
                        </mml:mover>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">Components of the wavefront <italic toggle="yes">WF<sub>s</sub></italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">WF<sub>s</sub></italic>
              </td>
              <td rowspan="1" colspan="1">Wavefront of score <italic toggle="yes">s</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE8">
                  <mml:math id="IM8" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>M</mml:mi>
                            <mml:mo>˜</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>h</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">Index of the rightmost diagonal in the component</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE9">
                  <mml:math id="IM9" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>M</mml:mi>
                            <mml:mo>˜</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>l</mml:mi>
                          <mml:mi>o</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">Index of the lowest diagonal in the component</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">WF<sub>min</sub></italic>
              </td>
              <td rowspan="1" colspan="1">Minimum wavefront length</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">WF<sub>diff</sub></italic>
              </td>
              <td rowspan="1" colspan="1">Maximum difference distance</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Last, it should be noted that there are many other lines of research for accelerating the SWG involving hardware accelerators; including Graphics Processing Units (<xref rid="btaa777-B2" ref-type="bibr">Chacón <italic toggle="yes">et al.</italic>, 2014</xref>; <xref rid="btaa777-B16" ref-type="bibr">Liu <italic toggle="yes">et al.</italic>, 2013</xref>), Field-Programmable Gate Arrays (<xref rid="btaa777-B15" ref-type="bibr">Li <italic toggle="yes">et al.</italic>, 2007</xref>), Cell Broadband Engine (<xref rid="btaa777-B32" ref-type="bibr">Szalkowski <italic toggle="yes">et al.</italic>, 2008</xref>), Xeon Phi processor (<xref rid="btaa777-B17" ref-type="bibr">Liu <italic toggle="yes">et al.</italic>, 2014</xref>) and even custom hardware designs (<xref rid="btaa777-B10" ref-type="bibr">Hasan <italic toggle="yes">et al.</italic>, 2008</xref>).</p>
    </sec>
    <sec>
      <title>1.2 Our contribution</title>
      <p>In this article, we present the wavefront alignment algorithm (WFA) for exact pairwise alignment of sequences. This novel alignment method progressively computes partial alignments of increasing score until the optimal solution is reached. In this way, the WFA algorithm exploits similarities between sequences to accelerate the computation of the optimal alignment. As a result, its time complexity <italic toggle="yes">O</italic>(<italic toggle="yes">ns</italic>) depends on the sequence length <italic toggle="yes">n</italic> and the optimal alignment score <italic toggle="yes">s</italic>. This allows scaling with sequence length provided that the error-rate between the sequences remains moderate. We demonstrate that the WFA algorithm outperforms other state-of-the-art methods, while requiring less memory.</p>
    </sec>
  </sec>
  <sec>
    <title>2 Materials</title>
    <p>In the following sections, we describe the main concepts behind the WFA algorithm. First, we introduce the concept of furthest-reaching points and wavefronts, and then we redefine the recurrent equations of the SWG algorithm in terms of wavefronts. Finally, we prove that the first wavefront that reaches the bottom-right corner of the DP matrix corresponds to the optimal pairwise alignment between the sequences.</p>
    <sec>
      <title>2.1 Pairwise global alignment of sequences</title>
      <p>Let the query <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the text <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> be strings of length <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>q</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>t</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>, respectively (<xref rid="btaa777-T1" ref-type="table">Table 1</xref>). We define the pairwise global alignment problem in terms of computing the alignment [or edit path, <xref rid="btaa777-B21" ref-type="bibr">Myers (1986)</xref>] from (0, 0) to (<italic toggle="yes">n</italic>, <italic toggle="yes">m</italic>) with minimum penalty score, allowing matching bases, substitutions and gaps (i.e. insertions and deletions). Under the gap-affine model, the alignment penalty score is computed based on <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">a</italic> and <italic toggle="yes">x</italic> correspond to the penalty of matching or mismatching two bases, respectively, and the gap-penalty function is expressed as the linear function <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo>·</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> (where <italic toggle="yes">n</italic> is the length of the gap). As stated before, this problem is commonly solved using some variation of the SWG algorithm (<xref rid="btaa777-B7" ref-type="bibr">Gotoh, 1982</xref>). <xref rid="E1" ref-type="disp-formula">Eq. 1</xref> shows the recurrence relations of the DP matrix used in the SWG algorithm. 
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>e</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>e</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Despite its general formulation, in practice, the majority of applications use strictly positive penalties, i.e. <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. And, as in other methods, we focus on the match-mismatch model where the mismatch between every two different bases always has the same penalty, <italic toggle="yes">x</italic>. That is, function <italic toggle="yes">s</italic>(<italic toggle="yes">v</italic>, <italic toggle="yes">h</italic>), for <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>v</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>h</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>, evaluates to <italic toggle="yes">a</italic> if <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">x</italic> otherwise. In addition, our method fixes the match score to zero (<italic toggle="yes">a </italic>=<italic toggle="yes"> </italic>0) to enable exploiting similarities between the sequences and accelerate the alignment process. As we demonstrate later, this allows defining a much simpler and faster method for gap-affine alignment.</p>
    </sec>
    <sec>
      <title>2.2 Wavefront furthest-reaching diagonals</title>
      <p>Restricted to the edit distance, the so-called diagonal-transition algorithms (<xref rid="btaa777-B11" ref-type="bibr">Landau and Vishkin, 1989</xref>; <xref rid="btaa777-B33" ref-type="bibr">Ukkonen, 1985</xref>) exploited the fact that DP diagonals have monotonically increasing scores. In particular, Myers’ <italic toggle="yes">O</italic>(<italic toggle="yes">nd</italic>) algorithm (<xref rid="btaa777-B21" ref-type="bibr">Myers, 1986</xref>), implemented at the core of the Linux diff-tool, computes the longest common subsequence of two sequences taking advantage of stretches of matching characters along the diagonals. Our algorithm extends these ideas to the gap-affine model.</p>
      <p>For each score <italic toggle="yes">s</italic> and diagonal <italic toggle="yes">k</italic>, the furthest-reaching (f.r.) point <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> denotes the DP-cell, on diagonal <italic toggle="yes">k</italic> and with score <italic toggle="yes">s</italic>, that is more far-off from the beginning of the diagonal. Note that a point <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, in the diagonal <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>, is further than other <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>) in the same diagonal. Then, we define <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> as the offset in the diagonal to the f.r. point <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for each of the three SWG matrices <italic toggle="yes">I</italic>, <italic toggle="yes">D</italic> and <italic toggle="yes">M</italic>, respectively. So, for a given score <italic toggle="yes">s</italic>, we define the <italic toggle="yes">s</italic>-wavefront (<italic toggle="yes">WF<sub>s</sub></italic>) as the set of all the f.r. points with score <italic toggle="yes">s</italic>; that is, the set of offsets <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, for all <italic toggle="yes">k</italic>. Likewise, we denote <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, the components of the wavefront <italic toggle="yes">WF<sub>s</sub></italic>. Assuming each component of a wavefront is represented using a vector of offsets centred over the main diagonal (<italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>0), let <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> denote the index of the rightmost diagonal in the component, and <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> the index of the lowest.</p>
      <p>Our goal is to compute the minimum <italic toggle="yes">s</italic> such that any of the f.r. points of <italic toggle="yes">WF<sub>s</sub></italic> reaches (<italic toggle="yes">n</italic>, <italic toggle="yes">m</italic>). We notice that for any <italic toggle="yes">s</italic>, the f.r. points of <italic toggle="yes">WF<sub>s</sub></italic> can only be originated from points whose score is <italic toggle="yes">s</italic> – <italic toggle="yes">o</italic>, <italic toggle="yes">s</italic> – <italic toggle="yes">e</italic> or <italic toggle="yes">s</italic> – <italic toggle="yes">x</italic>; or from a previous point with score <italic toggle="yes">s</italic> solely followed by matches along the diagonal. Considering only insertions, deletions and mismatches; we can redefine <xref rid="E1" ref-type="disp-formula">Eq. 1</xref> in terms of offsets to f.r. points (<xref rid="E2" ref-type="disp-formula">Eq. 2</xref>). 
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>(</mml:mo><mml:mtext>Open</mml:mtext><mml:mo> </mml:mo><mml:mtext>insertion</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>(</mml:mo><mml:mtext>Extend</mml:mtext><mml:mo> </mml:mo><mml:mtext>insertion</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="true">}</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>(</mml:mo><mml:mtext>Open</mml:mtext><mml:mo> </mml:mo><mml:mtext>deletion</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>(</mml:mo><mml:mtext>Extend</mml:mtext><mml:mo> </mml:mo><mml:mtext>deletion</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="true">}</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mrow><mml:mrow><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>(</mml:mo><mml:mtext>Substitution</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>(</mml:mo><mml:mtext>Insertion</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>(</mml:mo><mml:mtext>Deletion</mml:mtext><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="true">}</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>with initial condition <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p>
      <p>Essentially, <xref rid="E2" ref-type="disp-formula">Eq. 2</xref> states that we can compute the set of f.r. points of <italic toggle="yes">WF<sub>s</sub></italic> using <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi>W</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>W</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>W</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. For example, in order to compute the f.r. point <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we only have to consider which f.r. point brings the resulting offset further: a newly opened deletion <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, or an extended one <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (both coming from one diagonal above). Similarly, as to compute the f.r. point <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we only need to compare offsets between the f.r. points corresponding to an insertion <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, a deletion <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and a mismatch from <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Then, we consider matches, and we take advantage of the fact that <italic toggle="yes">a </italic>=<italic toggle="yes"> </italic>0. For that, we extend all the previously computed points by <xref rid="E2" ref-type="disp-formula">Eq. 2</xref>, as far as possible, following matching characters along the diagonal.<statement id="mthst1"><p><sc>Lemma</sc> 2.1. <italic toggle="yes">The resulting points of applying</italic>  <xref rid="E2" ref-type="disp-formula"><italic toggle="yes">Eq. 2</italic></xref>  <italic toggle="yes">and extending them, following matching characters along the diagonal, are the f.r. points for the score s, that is WF<sub>s</sub>.</italic></p><p>Proof. Suppose that point <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mi>W</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (originated by point <italic toggle="yes">q</italic> from a previous <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>W</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>) is not the f.r. point on the diagonal <italic toggle="yes">k</italic>. Then, there must exist a point <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> that is f.r. on that diagonal <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>′</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. For that <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, there must exist a point <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> (with a score <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>) that generated <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> (perhaps, after extension by accounting matches on the diagonal). However, <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> cannot be the f.r. point on the diagonal (i.e. does not belong to <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>W</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>), otherwise, it would have generated <italic toggle="yes">p</italic>. Therefore, <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:math></inline-formula> and thus, it follows that <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>, in the best case (f.r point), <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>. □</p><p>It follows from Lemma 2.1 that the optimal alignment corresponds to the sequence of wavefronts from <italic toggle="yes">WF</italic><sub>0</sub> to <italic toggle="yes">WF<sub>s</sub></italic>, being <italic toggle="yes">WF<sub>s</sub></italic> the wavefront with the smallest <italic toggle="yes">s</italic> that contains a f.r. point that reaches (<italic toggle="yes">n</italic>, <italic toggle="yes">m</italic>).</p></statement></p>
    </sec>
    <sec>
      <title>2.3 Wavefront algorithm</title>
      <p>Using Lemma 2.1 and staring with <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, the WFA algorithm (Algorithm 1) progressively computes wavefronts of increasing score until the cell (<italic toggle="yes">n</italic>, <italic toggle="yes">m</italic>) is reached. <boxed-text id="btaa777-BOX1" position="float"><p><inline-graphic xlink:href="btaa777f3.jpg"/></p></boxed-text>First, for each score <italic toggle="yes">s</italic>, the algorithm extends the points <inline-formula id="IE60"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> following matching characters along the diagonals, using WF_EXTEND(<inline-formula id="IE61"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula>) (Algorithm 2). Then, it checks whether any of the resulting f.r. points of wavefront <italic toggle="yes">WF<sub>s</sub></italic> reaches (<italic toggle="yes">n</italic>, <italic toggle="yes">m</italic>). If not, the algorithm proceeds to compute the next wavefront <inline-formula id="IE62"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>W</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> using WF_NEXT(<inline-formula id="IE63"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>) (Algorithm 3, which applies <xref rid="E2" ref-type="disp-formula">Eq. 2</xref>), and iterates again.</p>
      <p>
        <boxed-text id="btaa777-BOX6" position="float">
          <p>
            <inline-graphic xlink:href="btaa777f4.jpg"/>
          </p>
        </boxed-text>
      </p>
      <p>In the case of global alignment, the algorithm starts with a unitary wavefront (<inline-formula id="IE66"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>). As the algorithm iterates, the length of the wavefronts increases according to <xref rid="E3" ref-type="disp-formula">Eq. 3</xref>. That is, each new wavefront grows to span over one more diagonal on each end (i.e. <inline-formula id="IE67"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi><mml:mrow><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE68"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>) compared to the wavefronts it depends on. As a result, the size of each subsequent wavefront increases proportional to the alignment score between the sequences. Hence, the algorithm requires <inline-formula id="IE69"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory to store all wavefronts. 
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi><mml:mrow><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi><mml:mrow><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi><mml:mrow><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo stretchy="true">{</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="true">}</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo stretchy="true">{</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>s</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="true">}</mml:mo><mml:mo>−</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>Also, note that extending a wavefront (WF_EXTEND function) is bounded by the number of diagonal matching characters (<inline-formula id="IE70"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>) and the length of the wavefront. Similarly, the function WF_NEXT computes each next wavefront in time proportional to the wavefront length. Therefore, the running time of the WFA algorithm, to compute an alignment of score <italic toggle="yes">s</italic>, is bounded in the worst case by <inline-formula id="IE71"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>}</mml:mo><mml:mo>·</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, or <italic toggle="yes">O</italic>(<italic toggle="yes">ns</italic>) assuming that the sequences have the same length.</p>
      <p><xref rid="btaa777-F1" ref-type="fig">Figure 1</xref> shows an example of computing a global gap-affine alignment using a DP matrix and the WFA algorithm. The figure demonstrates that the WFA only needs to compute a minimal number of DP cells to find the optimal alignment. The WFA explores the cells of the DP matrix by increasing score, like seeking for the minimum cost path from (0, 0) to (<italic toggle="yes">n</italic>, <italic toggle="yes">m</italic>). In this way, the algorithm effectively computes an adaptive band without previous knowledge of the alignment error between the sequences. Moreover, it performs this seemingly irregular computation using simple and regular operations over the wavefronts. Furthermore, the algorithm only requires to store a few wavefronts before reaching the bottom right cell of the DP matrix. Considering the penalties used in <xref rid="btaa777-F1" ref-type="fig">Figure 1</xref>, the only score values that can appear in the DP matrix, before reaching the optimal alignment at <italic toggle="yes">s </italic>=<italic toggle="yes"> </italic>8, are <italic toggle="yes">s </italic>=<italic toggle="yes"> </italic>0 and <italic toggle="yes">s </italic>=<italic toggle="yes"> </italic>4. For that reason, the WFA only needs to store the wavefronts <italic toggle="yes">WF</italic><sub>0</sub>, <italic toggle="yes">WF</italic><sub>4</sub> and <italic toggle="yes">WF</italic><sub>8</sub>. And, unlike the DP matrix, these wavefronts avoid storing runs of cells with the same score (byproduct of the matches along the diagonal).</p>
      <fig position="float" id="btaa777-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>(<bold>A</bold>) DP matrices (i.e. <italic toggle="yes">M</italic>, <italic toggle="yes">D</italic> and <italic toggle="yes">I</italic>) depicting the only cells computed by the WFA in order to align <inline-formula id="IE72"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mo>“</mml:mo><mml:mtext>GATACA</mml:mtext><mml:mo>”</mml:mo></mml:mrow></mml:math></inline-formula> against <inline-formula id="IE73"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mo>“</mml:mo><mml:mtext>GAGATA</mml:mtext><mml:mo>”</mml:mo></mml:mrow></mml:math></inline-formula> using the penalties <inline-formula id="IE74"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. The arrows show the f.r. points of the main diagonal in matrix <italic toggle="yes">M</italic> (i.e. <inline-formula id="IE75"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE76"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>8</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>). (<bold>B</bold>) Equivalent representation using wavefronts (i.e. <italic toggle="yes">WF</italic><sub>0</sub>, <italic toggle="yes">WF</italic><sub>4</sub> and <italic toggle="yes">WF</italic><sub>8</sub>)</p>
        </caption>
        <graphic xlink:href="btaa777f1" position="float"/>
      </fig>
      <p>Once the algorithm computes a wavefront that reaches (<italic toggle="yes">n</italic>, <italic toggle="yes">m</italic>), and therefore, the optimal alignment between the sequences, it can retrieve back the path that leads from (0, 0) to (<italic toggle="yes">n</italic>, <italic toggle="yes">m</italic>) (i.e. backtrace). As opposed to DP-based algorithms, the WFA’s backtrace is performed across the wavefronts’ offsets instead of using the DP matrix scores. On each step of the backtrace, the function determines which f.r. point, from the previous wavefronts, originated the current offset. The difference between the actual offset and the source is the total amount of matching characters between the two positions. For example, in <xref rid="btaa777-F1" ref-type="fig">Figure 1</xref>, offset <inline-formula id="IE77"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>8</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula> has been generated from the f.r. point <inline-formula id="IE78"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>. The difference between the two offsets corresponds to the matches from (5, 5) to (6, 6), both included.</p>
      <p>
        <boxed-text id="btaa777-BOX11" position="float">
          <p>
            <inline-graphic xlink:href="btaa777f5.jpg"/>
          </p>
        </boxed-text>
      </p>
    </sec>
    <sec>
      <title>2.4 Adaptive wavefront reduction</title>
      <p>As the WFA algorithm iterates, wavefronts of increasing score span over more and more diagonals. While some of the f.r. points quickly advance towards the solution, others are left behind on their diagonal as they are unlikely to lead to the optimal solution. As a consequence, the WFA algorithm invests a substantial amount of time processing unpromising paths. For that reason, we propose a heuristic version of the algorithm (WFA-Adapt) that removes f.r. points from outer diagonals that are extremely far behind compared to other points in the same wavefront.</p>
      <p>In this way, the WFA-Adapt performs a wavefront pruning (Algorithm 4) after performing each wavefront extension. It determines the distance <italic toggle="yes">d<sub>k</sub></italic> of each diagonal f.r. point to the (<italic toggle="yes">n</italic>, <italic toggle="yes">m</italic>) cell. Then it computes the minimum <inline-formula id="IE81"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and discards outer diagonal points that are more than <italic toggle="yes">WF</italic><sub>diff</sub> cells behind it (i.e. <inline-formula id="IE82"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mi>W</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mtext>diff</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>). Despite its simplicity, computing each <italic toggle="yes">d<sub>k</sub></italic> distance for all the f.r. points of the wavefront carries a non-negligible toll on the total running time of the algorithm. For that reason, we define a minimum wavefront length <italic toggle="yes">WF</italic><sub>min</sub> required to trigger the reduction (WF_REDUCE).</p>
      <p>In practice, the WFA-Adapt heuristic successfully removes distant f.r. points unlikely to be part of the optimal alignment. Therefore, the span of the wavefront is focused on the diagonals closer to the alignment solution, further reducing the amount of memory required by the algorithm. In a way, similar pruning techniques are implemented into DP-based algorithms. These banded methods avoid computing paths beyond a band of diagonals. Unlike those methods, our wavefront reduction method prunes based on the potential of the diagonal to lead to the optimal solution, without previous knowledge of the error between the sequences whatsoever.</p>
      <p>Nonetheless, it is important to highlight that the WFA-Adapt method is no longer exact and might miss some optimal solutions; unlike the WFA. In practice, for a reasonable selection of <inline-formula id="IE83"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>W</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>W</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mtext>diff</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, this is rarely the case, even when aligning long noisy sequences.</p>
      <p>
        <boxed-text id="btaa777-BOX16" position="float">
          <p>
            <inline-graphic xlink:href="btaa777f6.jpg"/>
          </p>
        </boxed-text>
      </p>
    </sec>
    <sec>
      <title>2.5 Efficient computation of wavefronts</title>
      <p>As opposed to traditional DP-based algorithms, the core functions of the wavefront algorithm depict simple data dependencies (<xref rid="btaa777-F2" ref-type="fig">Fig. 2</xref>). This allows the implementation of effective fine-grain parallelization techniques to accelerate the computation of each wavefront.</p>
      <fig position="float" id="btaa777-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>(<bold>A</bold>) Dependencies between DP cells when computing another cell using gap-affine penalties. (<bold>B</bold>) Dependencies between wavefronts as to compute one element of the next wavefront (Algorithm 3)</p>
        </caption>
        <graphic xlink:href="btaa777f2" position="float"/>
      </fig>
      <p>In the case of the WF_NEXT function, the automatic vectorization features of modern compilers can easily detect the dependencies between wavefronts and transparently issue SIMD instructions to significantly accelerate the computation. This represents a major advantage over other methods that rely on specific SIMD intrinsics and custom implementations. These tools not only have limited portability to different computer architectures but also require complicated, time-consuming and error-prone implementations. In contrast, our approach allows transparent vectorization of the algorithm for any SIMD instruction-set and architecture supported by the compiler.</p>
      <p>In the same way, the function WF_EXTEND can be accelerated by means of exploiting bit-level parallelism techniques. That is, instead of comparing characters along the diagonal one at a time, we perform comparisons in blocks of eight characters (i.e. packed in a 64-bit computer word). In this way, the algorithm performs parallel comparisons and extends each diagonal up to eight positions per step. Taking into account that spurious matches between blocks of eight characters are very unlikely to occur, this technique prevents the inner loop of WF_EXTEND from iterating more than once in most cases. Otherwise, it means that the function has detected a stretch of matches which, in turn, favors the overall performance of the algorithm.</p>
      <p>Note that, depending on the penalties selected, some (or even all) of the wavefronts required to compute a wavefront might not exist. That means that there is no possible combination of penalties that can generate the current score. In those cases, the number of operations involved in WF_NEXT gets reduced. Hence, our implementation contains different specializations of this function to accelerate those cases where some source wavefronts are not needed, and thus the complexity can be reduced.</p>
      <p>Notably, the WFA encodes the offsets to the f.r. points on each diagonal, not the actual score values. Therefore, the representation range of each wavefront element is bounded by the length of the sequences, and not by the maximum score possible. In most cases, the WFA can conveniently encode offsets using 16-bit integers (for sequences up to 2<sup>16</sup> characters), or even 8-bit integers (for Illumina-like sequences, no longer than 255 bases). This succinct representation not only allows saving memory but also allows using wider SIMD instructions that can operate over more elements at once. In turn, this further enhances the efficiency of our WFA implementation.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We evaluate the performance of our implementation of the WFA and WFA-Adapt algorithms, together with other widely used libraries that implement optimized versions of well-known pairwise alignment algorithms.</p>
    <sec>
      <title>3.1 Experimental setup</title>
      <p>We select the widely used Parasail library (<xref rid="btaa777-B3" ref-type="bibr">Daily, 2016</xref>) that implements the diagonal method by Wozniak (<xref rid="btaa777-B34" ref-type="bibr">Wozniak, 1997</xref>) (ParaDiag), the striped approach proposed by Farrar (<xref rid="btaa777-B6" ref-type="bibr">Farrar, 2007</xref>) (ParaStrip), the prefix-scan algorithm (<xref rid="btaa777-B4" ref-type="bibr">Daily <italic toggle="yes">et al.</italic>, 2015</xref>) (ParaScan) and the classical banded heuristic method (ParaBand). Also, we evaluate the gap-affine implementation of the SeqAn library (<xref rid="btaa777-B26" ref-type="bibr">Rahn <italic toggle="yes">et al.</italic>, 2018</xref>), the bit-parallel implementation for non-unitary penalties (<xref rid="btaa777-B18" ref-type="bibr">Loving <italic toggle="yes">et al.</italic>, 2014</xref>) (BitPAl) and the adaptive band algorithm from Suzuki (<xref rid="btaa777-B31" ref-type="bibr">Suzuki and Kasahara, 2018</xref>) (Gaba). In addition, we evaluate the performance of the highly optimized SIMD algorithms KSW2-Z2 (ksw2_extz2_sse), and KSW2-D2 (ksw2_extd2_sse), from the KSW2 library, used within Minimap2 (<xref rid="btaa777-B14" ref-type="bibr">Li, 2018</xref>). On top of that, we present the performance results of the Edlib (<xref rid="btaa777-B29" ref-type="bibr">Šošić and Šikić, 2017</xref>) library as a base line for comparison. Because Edlib is restricted to compute the edit-distance alignment, its execution is remarkably fast.</p>
      <p>For the purpose of the evaluation, all the methods have been configured to generate global alignments. These methods are grouped in three categories: ‘Gap-affine (Exact)’ (WFA, KSW2-Z2, SeqAn, ParaStrip, ParaScan and ParaDiag) for exact algorithms that use gap-affine penalties, ‘Gap-affine (Banded)’ (WFA-Adap, Gaba and ParaBand) for approximate algorithms that use gap-affine penalties, and ‘Others’ (Edlib, BitPAl and KSW2-D2) for exact methods that use other penalty models. Note that the gap-affine banded methods are approximated and not guaranteed to find the optimal alignment. Similarly, note that the algorithms ParaBand and BitPAl only compute the alignment score (not the full alignment) and the latter is restricted to linear-gap penalties.</p>
      <p>We discarded other methods from the evaluation as their running time was exceedingly long or because their recall was substantially below par. This is the case of other KSW2 algorithms (like the approximate versions), other edit distance methods [e.g. BPM (<xref rid="btaa777-B22" ref-type="bibr">Myers, 1999</xref>) or DAligner (<xref rid="btaa777-B23" ref-type="bibr">Myers, 2014</xref>)] or custom implementations for hardware accelerators (which fall beyond the scope of this article).</p>
      <p>We choose two real datasets: 100 000 sequences from an Illumina HiSeq 2000 of 100 bp (Accession number ERX069505), and 25 000 ONT MinION sequences from (<xref rid="btaa777-B1" ref-type="bibr">Bowden <italic toggle="yes">et al.</italic>, 2019</xref>) (Accession numbers ERR3278877–ERR3278886). Also, we simulate several datasets of various lengths (i.e. 100, 1K, 10K and 100K bases), with different error rates (i.e. <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>1, 2, 5, 10 and 20% error rate) by means of randomly adding mismatches and indels. For every dataset, we select as many sequences as needed, so that each of them contains a total of 10 million bp.</p>
      <p>All tests are executed on an Intel Xeon Platinum 8160 equipped with 96 GB of RAM, running SuSE Linux Enterprise Server. For each method, we measure execution time and memory consumed. In addition, we verify the results using a basic SWG implementation in order to compute the recall of each method.</p>
    </sec>
    <sec>
      <title>3.2 Evaluation on real data</title>
      <p><xref rid="btaa777-T2" ref-type="table">Table 2</xref> shows the time performance results obtained for all the algorithms evaluated using both real and simulated datasets. On real datasets, the WFA performs many times faster than other methods. In particular, aligning HiSeq sequences, our method is 200–300× faster compared to traditional DP algorithms, and 20–40× faster than the adaptive-band methods. Similarly, when aligning ONT sequences, the WFA performs 28–200× and 6–7× times faster than DP algorithms and adaptive-band methods, respectively. Moreover, it is several times faster than methods that only compute the alignment score. Furthermore, the WFA-Adapt refinement attains an extra 1.6× speedup over the original WFA when aligning long ONT reads.</p>
      <table-wrap position="float" id="btaa777-T2">
        <label>Table 2.</label>
        <caption>
          <p>Time performance of pairwise alignment algorithms</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
            <col valign="top" align="char" char="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th colspan="3" rowspan="1">100<hr/></th>
              <th colspan="3" rowspan="1">1K<hr/></th>
              <th colspan="3" rowspan="1">10K<hr/></th>
              <th colspan="3" rowspan="1">100K<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">HiSeq</th>
              <th rowspan="1" colspan="1">ONT</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 1%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 5%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 20%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 1%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 5%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 20%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 1%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 5%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 20%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 1%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 5%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 20%</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="6" colspan="1">Gap-affine (Exact)</td>
              <td rowspan="1" colspan="1">WFA</td>
              <td rowspan="1" colspan="1">0.06</td>
              <td rowspan="1" colspan="1">2.46</td>
              <td rowspan="1" colspan="1">0.09</td>
              <td rowspan="1" colspan="1">0.37</td>
              <td rowspan="1" colspan="1">1.55</td>
              <td rowspan="1" colspan="1">0.14</td>
              <td rowspan="1" colspan="1">0.93</td>
              <td rowspan="1" colspan="1">6.93</td>
              <td rowspan="1" colspan="1">0.43</td>
              <td rowspan="1" colspan="1">7.28</td>
              <td rowspan="1" colspan="1">66.00</td>
              <td rowspan="1" colspan="1">8.49</td>
              <td rowspan="1" colspan="1">102.00</td>
              <td rowspan="1" colspan="1">2542.00</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">KSW2-Z2</td>
              <td rowspan="1" colspan="1">2.42</td>
              <td rowspan="1" colspan="1">15.23</td>
              <td rowspan="1" colspan="1">2.41</td>
              <td rowspan="1" colspan="1">2.79</td>
              <td rowspan="1" colspan="1">3.06</td>
              <td rowspan="1" colspan="1">16.43</td>
              <td rowspan="1" colspan="1">16.47</td>
              <td rowspan="1" colspan="1">16.64</td>
              <td rowspan="1" colspan="1">188.40</td>
              <td rowspan="1" colspan="1">188.40</td>
              <td rowspan="1" colspan="1">189.00</td>
              <td rowspan="1" colspan="1">2146.00</td>
              <td rowspan="1" colspan="1">2136.00</td>
              <td rowspan="1" colspan="1">2139.00</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">SeqAn</td>
              <td rowspan="1" colspan="1">18.18</td>
              <td rowspan="1" colspan="1">180.60</td>
              <td rowspan="1" colspan="1">18.28</td>
              <td rowspan="1" colspan="1">19.17</td>
              <td rowspan="1" colspan="1">22.64</td>
              <td rowspan="1" colspan="1">184.80</td>
              <td rowspan="1" colspan="1">190.80</td>
              <td rowspan="1" colspan="1">213.60</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParaStrip</td>
              <td rowspan="1" colspan="1">77.40</td>
              <td rowspan="1" colspan="1">530.40</td>
              <td rowspan="1" colspan="1">77.40</td>
              <td rowspan="1" colspan="1">75.60</td>
              <td rowspan="1" colspan="1">70.80</td>
              <td rowspan="1" colspan="1">603.60</td>
              <td rowspan="1" colspan="1">602.40</td>
              <td rowspan="1" colspan="1">572.40</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParaScan</td>
              <td rowspan="1" colspan="1">12.03</td>
              <td rowspan="1" colspan="1">69.00</td>
              <td rowspan="1" colspan="1">11.85</td>
              <td rowspan="1" colspan="1">11.89</td>
              <td rowspan="1" colspan="1">11.99</td>
              <td rowspan="1" colspan="1">75.00</td>
              <td rowspan="1" colspan="1">75.00</td>
              <td rowspan="1" colspan="1">75.00</td>
              <td rowspan="1" colspan="1">746.40</td>
              <td rowspan="1" colspan="1">747.00</td>
              <td rowspan="1" colspan="1">747.00</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParaDiag</td>
              <td rowspan="1" colspan="1">17.80</td>
              <td rowspan="1" colspan="1">130.20</td>
              <td rowspan="1" colspan="1">17.53</td>
              <td rowspan="1" colspan="1">17.58</td>
              <td rowspan="1" colspan="1">17.66</td>
              <td rowspan="1" colspan="1">141.60</td>
              <td rowspan="1" colspan="1">141.60</td>
              <td rowspan="1" colspan="1">141.60</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">Gap-affine (Banded)</td>
              <td rowspan="1" colspan="1">WFA-Adap</td>
              <td rowspan="1" colspan="1">0.07</td>
              <td rowspan="1" colspan="1">1.51</td>
              <td rowspan="1" colspan="1">0.09</td>
              <td rowspan="1" colspan="1">0.50</td>
              <td rowspan="1" colspan="1">2.20</td>
              <td rowspan="1" colspan="1">0.16</td>
              <td rowspan="1" colspan="1">0.68</td>
              <td rowspan="1" colspan="1">2.75</td>
              <td rowspan="1" colspan="1">0.17</td>
              <td rowspan="1" colspan="1">0.68</td>
              <td rowspan="1" colspan="1">3.00</td>
              <td rowspan="1" colspan="1">0.26</td>
              <td rowspan="1" colspan="1">1.53</td>
              <td rowspan="1" colspan="1">6.97</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Gaba</td>
              <td rowspan="1" colspan="1">1.26</td>
              <td align="center" rowspan="1" colspan="1">error</td>
              <td rowspan="1" colspan="1">1.28</td>
              <td rowspan="1" colspan="1">1.33</td>
              <td align="center" rowspan="1" colspan="1">error</td>
              <td rowspan="1" colspan="1">0.68</td>
              <td rowspan="1" colspan="1">0.74</td>
              <td align="center" rowspan="1" colspan="1">error</td>
              <td rowspan="1" colspan="1">0.60</td>
              <td rowspan="1" colspan="1">0.81</td>
              <td align="center" rowspan="1" colspan="1">error</td>
              <td rowspan="1" colspan="1">0.72</td>
              <td rowspan="1" colspan="1">0.76</td>
              <td align="center" rowspan="1" colspan="1">error</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParaBand</td>
              <td rowspan="1" colspan="1">3.71</td>
              <td rowspan="1" colspan="1">8.26</td>
              <td rowspan="1" colspan="1">3.75</td>
              <td rowspan="1" colspan="1">3.89</td>
              <td rowspan="1" colspan="1">4.17</td>
              <td rowspan="1" colspan="1">4.04</td>
              <td rowspan="1" colspan="1">4.51</td>
              <td rowspan="1" colspan="1">5.34</td>
              <td rowspan="1" colspan="1">4.87</td>
              <td rowspan="1" colspan="1">6.39</td>
              <td rowspan="1" colspan="1">8.87</td>
              <td rowspan="1" colspan="1">8.11</td>
              <td rowspan="1" colspan="1">11.81</td>
              <td rowspan="1" colspan="1">20.43</td>
            </tr>
            <tr>
              <td rowspan="3" colspan="1">Others</td>
              <td rowspan="1" colspan="1">Edlib</td>
              <td rowspan="1" colspan="1">1.75</td>
              <td rowspan="1" colspan="1">2.28</td>
              <td rowspan="1" colspan="1">1.73</td>
              <td rowspan="1" colspan="1">1.82</td>
              <td rowspan="1" colspan="1">1.94</td>
              <td rowspan="1" colspan="1">1.95</td>
              <td rowspan="1" colspan="1">2.03</td>
              <td rowspan="1" colspan="1">2.73</td>
              <td rowspan="1" colspan="1">3.67</td>
              <td rowspan="1" colspan="1">4.50</td>
              <td rowspan="1" colspan="1">7.39</td>
              <td rowspan="1" colspan="1">6.95</td>
              <td rowspan="1" colspan="1">19.34</td>
              <td align="center" rowspan="1" colspan="1">error</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BitPAl</td>
              <td rowspan="1" colspan="1">0.47</td>
              <td rowspan="1" colspan="1">2.18</td>
              <td rowspan="1" colspan="1">0.47</td>
              <td rowspan="1" colspan="1">0.47</td>
              <td rowspan="1" colspan="1">0.47</td>
              <td rowspan="1" colspan="1">2.27</td>
              <td rowspan="1" colspan="1">2.31</td>
              <td rowspan="1" colspan="1">2.33</td>
              <td rowspan="1" colspan="1">21.44</td>
              <td rowspan="1" colspan="1">21.44</td>
              <td rowspan="1" colspan="1">21.47</td>
              <td rowspan="1" colspan="1">212.40</td>
              <td rowspan="1" colspan="1">212.40</td>
              <td rowspan="1" colspan="1">212.40</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">KSW2-D2</td>
              <td rowspan="1" colspan="1">2.87</td>
              <td rowspan="1" colspan="1">18.13</td>
              <td rowspan="1" colspan="1">2.86</td>
              <td rowspan="1" colspan="1">3.23</td>
              <td rowspan="1" colspan="1">3.49</td>
              <td rowspan="1" colspan="1">19.56</td>
              <td rowspan="1" colspan="1">19.64</td>
              <td rowspan="1" colspan="1">19.81</td>
              <td rowspan="1" colspan="1">219.60</td>
              <td rowspan="1" colspan="1">219.60</td>
              <td rowspan="1" colspan="1">220.20</td>
              <td rowspan="1" colspan="1">2385.00</td>
              <td rowspan="1" colspan="1">2380.00</td>
              <td rowspan="1" colspan="1">2452.00</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: Running time in seconds obtained by the different pairwise alignment algorithms on real and simulated datasets. Penalties used for all tests <inline-formula id="IE86"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> correspond to the ones used by BWA-MEM. Alignment algorithms have been grouped in three categories: ‘Gap-affine (Exact)’ for exact algorithms that use gap-affine penalties, ‘Gap-affine (Banded)’ for approximate algorithms that use gap-affine penalties, and ‘Others’ for exact algorithms that use other distance models (i.e. edit distance or linear-gap penalties). On simulated datasets, results are broken down by error rate. Experiments whose running time exceeded 2 hours are marked as ‘n/a’. Likewise, runs that consistently failed are labelled with ‘error’. Note that WFA-Adapt was executed using <italic toggle="yes">WF</italic><sub>min</sub> = 10 and <italic toggle="yes">WF</italic><sub>diff</sub> = 50.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>3.3 Evaluation on simulated data</title>
      <p>When aligning simulated datasets, WFA methods consistently outperform other algorithms. Overall, WFA and adaptive-band methods are faster than classical DP algorithms. In particular, as the read length increases, Parasail and SeqAn’s implementations require impractical running times. Notably, BitPAl and ParaBand running times remain reasonably low, but alas, their results are limited to the alignment score. Altogether, these methods prove to be completely insensitive to the error between the sequences. For that reason, WFA and WFA-Adapt methods achieve remarkable speedups when the error rate remains moderate (i.e. <italic toggle="yes">d </italic>=<italic toggle="yes"> </italic>1–5%). For instance, compared to ParaBand, WFA methods run up to 13× and 78× faster for error rates of 1 and 5%, respectively; and up to 138× and 814× faster compared to BitPAl for the same error rates.</p>
      <p>On the other hand, WFA methods prove to be generally faster and more accurate than adaptive-band methods. Although these adaptive algorithms prove to be superior to classical approaches, WFA and WFA-Adapt methods scale better with both the sequence length and the error rate. In particular, executions of the KSW2 library consistently take between 2× and 510× longer than the WFA. In the demanding scenario of aligning reads of 100K bases at just 1% of divergence rate, WFA-Adapt runs more than three orders of magnitude faster than the KSW2 algorithms. It is important to note that KSW2-D2 uses 2-piece affine model (<xref rid="btaa777-B8" ref-type="bibr">Gotoh, 1990</xref>), that is why it is slower than KSW2-Z2 which uses the 1-piece/standard model.</p>
      <p>In general, as the error rate increases, adaptive-band methods either take longer to finish, like KSW2-Z2 and KSW2-D2, or become insensitive reporting suboptimal alignments, like Gaba. <xref rid="btaa777-T3" ref-type="table">Table 3</xref> presents a summary of time and recall results obtained using two broadly used penalty schemes; that is, those used by the ubiquitous mappers BWA-MEM (<xref rid="btaa777-B13" ref-type="bibr">Li, 2013</xref>) and Bowtie2 (<xref rid="btaa777-B12" ref-type="bibr">Langmead and Salzberg, 2012</xref>). In the case of the Gaba algorithm, executions times seem to decrease as the sequence length increases. Nonetheless, this is the result of aggressive heuristics that, in the end, cause a significant drop in the total recall (∼5%) or fail to align noisy sequences (e.g. aligning ONT sequences). Notably, only the WFA methods could successfully align all datasets of 100K bases, whereas other methods took an unreasonable amount of time or failed. Moreover, WFA-Adapt could finish all the executions in less than 7 seconds achieving the maximum possible recall; that is, reporting 100% of the optimal alignments.</p>
      <table-wrap position="float" id="btaa777-T3">
        <label>Table 3.</label>
        <caption>
          <p>Accuracy of pairwise alignment algorithms</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">HiSeq<hr/></th>
              <th colspan="2" rowspan="1">ONT<hr/></th>
              <th colspan="2" rowspan="1"><italic toggle="yes">l</italic> = 1K, <italic toggle="yes">d</italic> = 5%<hr/></th>
              <th colspan="2" rowspan="1"><italic toggle="yes">l</italic> = 10K, <italic toggle="yes">d</italic> = 5%<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Recall</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Recall</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Recall</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">Recall</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="5" colspan="1">BWA-MEM</td>
              <td rowspan="1" colspan="1">WFA</td>
              <td rowspan="1" colspan="1">0.06</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">2.46</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">0.93</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">7.28</td>
              <td rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-Adap</td>
              <td rowspan="1" colspan="1">0.07</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">1.51</td>
              <td rowspan="1" colspan="1">99.8</td>
              <td rowspan="1" colspan="1">0.68</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">0.68</td>
              <td rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Gaba</td>
              <td rowspan="1" colspan="1">1.26</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">error</td>
              <td rowspan="1" colspan="1">error</td>
              <td rowspan="1" colspan="1">0.74</td>
              <td rowspan="1" colspan="1">95.2</td>
              <td rowspan="1" colspan="1">0.81</td>
              <td rowspan="1" colspan="1">94.8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">KSW2-Z2</td>
              <td rowspan="1" colspan="1">2.42</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">15.23</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">16.47</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">188.4</td>
              <td rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">KSW2-D2</td>
              <td rowspan="1" colspan="1">2.87</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">18.13</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">19.64</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">219.6</td>
              <td rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="5" colspan="1">Bowtie2</td>
              <td rowspan="1" colspan="1">WFA</td>
              <td rowspan="1" colspan="1">0.07</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">4.80</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">1.60</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">12.05</td>
              <td rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-Adap</td>
              <td rowspan="1" colspan="1">0.08</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">3.18</td>
              <td rowspan="1" colspan="1">99.8</td>
              <td rowspan="1" colspan="1">1.32</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">1.25</td>
              <td rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Gaba</td>
              <td rowspan="1" colspan="1">1.26</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">error</td>
              <td rowspan="1" colspan="1">error</td>
              <td rowspan="1" colspan="1">0.74</td>
              <td rowspan="1" colspan="1">95.4</td>
              <td rowspan="1" colspan="1">0.66</td>
              <td rowspan="1" colspan="1">95.4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">KSW2-Z2</td>
              <td rowspan="1" colspan="1">2.40</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">15.21</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">16.46</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">190.8</td>
              <td rowspan="1" colspan="1">100</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">KSW2-D2</td>
              <td rowspan="1" colspan="1">2.91</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">18.16</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">19.66</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">220.8</td>
              <td rowspan="1" colspan="1">100</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic toggle="yes">Note</italic>: Time (in seconds) and recall (as percentage of the total sequences aligned) for error-sensitive algorithms. Two different penalty schemes were used: first corresponding to the default values used by BWA-MEM (i.e. <inline-formula id="IE87"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>), and second matching Bowtie2’s end-to-end alignment scores (i.e. <inline-formula id="IE88"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>).</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>In practice, the WFA algorithm seems barely sensitive to the sequence length, but to the alignment score between the sequences. In turn, this is subject to the penalty scores chosen for the alignment. <xref rid="btaa777-T3" ref-type="table">Table 3</xref> reflects how the performance of the WFA methods is affected by different choices of penalty scores. Although the running times remain remarkably low, selecting penalties that increase the final alignment score can negatively impact the performance of the algorithm; in this case, increasing the alignment time up to 2× in the worst case.</p>
    </sec>
    <sec>
      <title>3.4 Memory footprint</title>
      <p><xref rid="btaa777-T4" ref-type="table">Table 4</xref> presents the overall memory consumption of the algorithms evaluated. These results experimentally confirm the reduced memory footprint required by the WFA methods. Moreover, as the read length and error rate increases, the WFA-Adapt method uses 19–36× times less memory than other methods. This not only results in a significant reduction on the overall memory used but also relieves the pressure put in the memory hierarchy by traditional DP-based algorithms.</p>
      <table-wrap position="float" id="btaa777-T4">
        <label>Table 4.</label>
        <caption>
          <p>Memory consumption of pairwise alignment algorithms</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">l = 100<hr/></th>
              <th colspan="2" rowspan="1">l = 1K<hr/></th>
              <th colspan="2" rowspan="1">l = 10K<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">HiSeq</th>
              <th rowspan="1" colspan="1">ONT</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 1%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 20%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 1%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 20%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 1%</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">d</italic> = 20%</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">WFA</td>
              <td rowspan="1" colspan="1">0.5</td>
              <td rowspan="1" colspan="1">3.1</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">1.4</td>
              <td rowspan="1" colspan="1">4.2</td>
              <td rowspan="1" colspan="1">6.2</td>
              <td rowspan="1" colspan="1">269.6</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">KSW2-Z2</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">4.3</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">384.7</td>
              <td rowspan="1" colspan="1">387.1</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">SeqAn</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">2.6</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">2.9</td>
              <td rowspan="1" colspan="1">1.4</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParaStrip</td>
              <td rowspan="1" colspan="1">6.7</td>
              <td rowspan="1" colspan="1">7.9</td>
              <td rowspan="1" colspan="1">68.5</td>
              <td rowspan="1" colspan="1">15.6</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">13.1</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParaScan</td>
              <td rowspan="1" colspan="1">6.8</td>
              <td rowspan="1" colspan="1">7.9</td>
              <td rowspan="1" colspan="1">68.5</td>
              <td rowspan="1" colspan="1">15.4</td>
              <td rowspan="1" colspan="1">6.2</td>
              <td rowspan="1" colspan="1">12.8</td>
              <td rowspan="1" colspan="1">196.1</td>
              <td rowspan="1" colspan="1">202.6</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParaDiag</td>
              <td rowspan="1" colspan="1">6.8</td>
              <td rowspan="1" colspan="1">7.2</td>
              <td rowspan="1" colspan="1">15.6</td>
              <td rowspan="1" colspan="1">15.3</td>
              <td rowspan="1" colspan="1">5.1</td>
              <td rowspan="1" colspan="1">12</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
              <td align="center" rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-Adap</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">2</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.5</td>
              <td rowspan="1" colspan="1">0.9</td>
              <td rowspan="1" colspan="1">1.5</td>
              <td rowspan="1" colspan="1">6.1</td>
              <td rowspan="1" colspan="1">10.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Gaba</td>
              <td rowspan="1" colspan="1">0.7</td>
              <td align="center" rowspan="1" colspan="1">Error</td>
              <td rowspan="1" colspan="1">0.7</td>
              <td align="center" rowspan="1" colspan="1">Error</td>
              <td rowspan="1" colspan="1">4.3</td>
              <td align="center" rowspan="1" colspan="1">Error</td>
              <td rowspan="1" colspan="1">640.9</td>
              <td align="center" rowspan="1" colspan="1">Error</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParaBand</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">0.5</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.5</td>
              <td rowspan="1" colspan="1">0.5</td>
              <td rowspan="1" colspan="1">0.5</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Edlib</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.4</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BitPAl</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.5</td>
              <td rowspan="1" colspan="1">0.5</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.6</td>
              <td rowspan="1" colspan="1">0.7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">KSW2-D2</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">4.7</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">4.3</td>
              <td rowspan="1" colspan="1">4.6</td>
              <td rowspan="1" colspan="1">384.8</td>
              <td rowspan="1" colspan="1">388.5</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn3">
            <p><italic toggle="yes">Note</italic>: Memory usage (MB) of each alignment algorithm for different sequence length and error rate.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this article, we presented a novel algorithm for gap-affine pairwise alignment. Our method exploits the similarities between the sequences to deliver exact alignments while outperforming in time and memory other state-of-the-art algorithms. To this end, our algorithm computes alignments of increasing score using a succinct diagonal-transition representation. As a result, the WFA algorithm runs in <italic toggle="yes">O</italic>(<italic toggle="yes">ns</italic>) time and memory; being <italic toggle="yes">n</italic> the sequence length, and <italic toggle="yes">s</italic> the alignment score between the sequences.</p>
    <p>To date, adaptive-band algorithms dominated over other approaches. In practice, these methods seek to heuristically delimit the alignment path to avoid computing DP cells whose score is too high. Compared to them, the WFA algorithm naturally computes cells of the DP matrix by increasing score without introducing further complexities. Due to its simplicity, the WFA algorithm can be easily vectorized using SIMD instructions, as opposed to traditional DP-based algorithms. Moreover, data dependencies can be automatically understood by modern compilers in order to transparently issue SIMD instructions for any supported vectorial architecture. Furthermore, when aligning moderately long sequences (i.e. less than 255 bases), the WFA can encode diagonal offsets using 8-bit integers, which not only enhances SIMD performance but also further reduces the memory footprint.</p>
    <p>In addition, the WFA algorithm poses no constrain on the alphabet size, nor requires any preprocessing step in advance. Besides, the progressive computation of alignments of increasing score allows the WFA to implement exact cut-offs techniques. And yet, this method does not require any prior estimation of the alignment score between the sequences whatsoever. Also, note that the optimizations presented in this article are focused on intra-sequence parallelization. Consequently, all the experiments were executed using a single thread. Nevertheless, the WFA can be used together with many inter-sequence paralellization techniques in order to exploit the multi-threading capabilities of modern processors. And, although the WFA algorithm has been presented using the gap-affine scoring model, it can be easily adapted to more other scoring models, like the linear-gap model or the piece-wise affine model (<xref rid="btaa777-B8" ref-type="bibr">Gotoh, 1990</xref>; <xref rid="btaa777-B20" ref-type="bibr">Miller and Myers, 1988</xref>). Likewise, it can be adapted to semi-global alignment by adjusting the initial conditions of <xref rid="E2" ref-type="disp-formula">Eq. 2</xref> and the exit condition on Algorithm 1. But also, it can even be used for finding overlaps and local alignments in the spirit of mappers like DAligner (<xref rid="btaa777-B23" ref-type="bibr">Myers, 2014</xref>).</p>
    <p>Undoubtedly, pairwise alignment will remain as a central and critical building-block of many bioinformatics applications. For that reason, our algorithm represents a fast and scalable solution for many sequence analysis tools to cope with the ever-increasing yields of sequencing technologies. In this way, the WFA approach will pave the way for the design of better alignment algorithms in years to come.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This research was supported by the European Unions’s Horizon 2020 Framework Programme under the DeepHealth project [825111], by the European Union Regional Development Fund within the framework of the ERDF Operational Program of Catalonia 2014-2020 with a grant of 50% of total cost eligible under the DRAC project [001-P-001723], by the MINECO-Spain (contracts TIN2017-84553-C2-1-R and TIN2015-65316-P) and by the Catalan government (contracts 2017-SGR-313, 2017-SGR-1328 and 2017-SGR-1414). M.M. was partially supported by the Spanish Ministry of Economy, Industry and Competitiveness under Ramón y Cajal fellowship number RYC-2016-21104.</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btaa777-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bowden</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) 
<article-title>Sequencing of human genomes with nanopore technology</article-title>. <source>Nat. Commun</source>., <volume>10</volume>, <fpage>1</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">30602773</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B2">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chacón</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) Thread-cooperative, bit-parallel computation of levenshtein distance on GPU. In <italic toggle="yes">Proceedings of the 28th ACM international conference on Supercomputing(ICS '14)</italic>. Association for Computing Machinery, New York, NY, USA, pp. <fpage>103</fpage>–<lpage>112</lpage>. <pub-id pub-id-type="doi">10.1145/2597652.2597677</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Daily</surname><given-names>J.</given-names></string-name></person-group> (<year>2016</year>) 
<article-title>Parasail: SIMD C library for global, semi-global, and local pairwise sequence alignments</article-title>. <source>BMC Bioinformatics</source>, <volume>17</volume>, <fpage>81</fpage>.<pub-id pub-id-type="pmid">26864881</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Daily</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) 
<article-title>A work stealing based approach for enabling scalable optimal sequence homology detection</article-title>. <source>J. Parallel Distrib. Comput</source>., <volume>79-80</volume>, <fpage>132</fpage>–<lpage>142</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa777-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>DePristo</surname><given-names>M.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2011</year>) 
<article-title>A framework for variation discovery and genotyping using next-generation DNA sequencing data</article-title>. <source>Nat. Genet</source>., <volume>43</volume>, <fpage>491</fpage>–<lpage>498</lpage>.<pub-id pub-id-type="pmid">21478889</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Farrar</surname><given-names>M.</given-names></string-name></person-group> (<year>2007</year>) 
<article-title>Striped smith–waterman speeds database searches six times over other SIMD implementations</article-title>. <source>Bioinformatics</source>, <volume>23</volume>, <fpage>156</fpage>–<lpage>161</lpage>.<pub-id pub-id-type="pmid">17110365</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gotoh</surname><given-names>O.</given-names></string-name></person-group> (<year>1982</year>) 
<article-title>An improved algorithm for matching biological sequences</article-title>. <source>J. Mol. Biol</source>., <volume>162</volume>, <fpage>705</fpage>–<lpage>708</lpage>.<pub-id pub-id-type="pmid">7166760</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gotoh</surname><given-names>O.</given-names></string-name></person-group> (<year>1990</year>) 
<article-title>Optimal sequence alignment allowing for long gaps</article-title>. <source>Bull. Math. Biol</source>., <volume>52</volume>, <fpage>359</fpage>–<lpage>373</lpage>.<pub-id pub-id-type="pmid">2165832</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gusfield</surname><given-names>D.</given-names></string-name></person-group> (<year>1997</year>) 
<article-title>Algorithms on stings, trees, and sequences: computer science and computational biology</article-title>. <source>ACM Sigact News</source>, <volume>28</volume>, <fpage>41</fpage>–<lpage>60</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa777-B10">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Hasan</surname><given-names>L.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2008</year>) Hardware implementation of the smith-waterman algorithm using recursive variable expansion. In <italic toggle="yes">2008 3rd International Design and Test Workshop,</italic> Monastir, 2008. IEEE, pp. <fpage>135</fpage>–<lpage>140</lpage>. <pub-id pub-id-type="doi">10.1109/IDT.2008.4802483</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Landau</surname><given-names>G.M.</given-names></string-name>, <string-name><surname>Vishkin</surname><given-names>U.</given-names></string-name></person-group> (<year>1989</year>) 
<article-title>Fast parallel and serial approximate string matching</article-title>. <source>J. Algorithms</source>, <volume>10</volume>, <fpage>157</fpage>–<lpage>169</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa777-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Langmead</surname><given-names>B.</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>S.L.</given-names></string-name></person-group> (<year>2012</year>) 
<article-title>Fast gapped-read alignment with bowtie 2</article-title>. <source>Nat. Methods</source>, <volume>9</volume>, <fpage>357</fpage>–<lpage>359</lpage>.<pub-id pub-id-type="pmid">22388286</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2013</year>) Aligning sequence reads, clone sequences and assembly contigs with bwa-mem. <italic toggle="yes">arXiv preprint arXiv: 1303.3997</italic>.</mixed-citation>
    </ref>
    <ref id="btaa777-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2018</year>) 
<article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3094</fpage>–<lpage>3100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>I.T.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2007</year>) 
<article-title>160-fold acceleration of the smith-waterman algorithm using a field programmable gate array (FPGA)</article-title>. <source>BMC Bioinformatics</source>, <volume>8</volume>, <fpage>185</fpage>.<pub-id pub-id-type="pmid">17555593</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>Y.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) 
<article-title>Cudasw++ 3.0: accelerating smith-waterman protein database search by coupling CPU and GPU SIMD instructions</article-title>. <source>BMC Bioinformatics</source>, <volume>14</volume>, <fpage>117</fpage>.<pub-id pub-id-type="pmid">23557111</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B17">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>Y.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) SWAPHI-LS: Smith-waterman algorithm on Xeon Phi coprocessors for long DNA sequences. In <italic toggle="yes">2014 IEEE International Conference on Cluster Computing (CLUSTER)</italic>. 
<publisher-name>IEEE</publisher-name>, pp. <fpage>257</fpage>–<lpage>265</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa777-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Loving</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) 
<article-title>BitPAl: a bit-parallel, general integer-scoring sequence alignment algorithm</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3166</fpage>–<lpage>3173</lpage>.<pub-id pub-id-type="pmid">25075119</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marco-Sola</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) 
<article-title>The gem mapper: fast, accurate and versatile alignment by filtration</article-title>. <source>Nat. Methods</source>, <volume>9</volume>, <fpage>1185</fpage>–<lpage>1188</lpage>.<pub-id pub-id-type="pmid">23103880</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Miller</surname><given-names>W.</given-names></string-name>, <string-name><surname>Myers</surname><given-names>E.W.</given-names></string-name></person-group> (<year>1988</year>) 
<article-title>Sequence comparison with concave weighting functions</article-title>. <source>Bull. Math. Biol</source>., <volume>50</volume>, <fpage>97</fpage>–<lpage>120</lpage>.<pub-id pub-id-type="pmid">3207952</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>E.W.</given-names></string-name></person-group> (<year>1986</year>) 
<article-title>Ano (nd) difference algorithm and its variations</article-title>. <source>Algorithmica</source>, <volume>1</volume>, <fpage>251</fpage>–<lpage>266</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa777-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>G.</given-names></string-name></person-group> (<year>1999</year>) 
<article-title>A fast bit-vector algorithm for approximate string matching based on dynamic programming</article-title>. <source>J. ACM (JACM)</source>, <volume>46</volume>, <fpage>395</fpage>–<lpage>415</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa777-B23">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>G.</given-names></string-name></person-group> (<year>2014</year>) <part-title>Efficient local alignment discovery amongst noisy long reads</part-title>. In <source>International Workshop on Algorithms in Bioinformatics</source>. 
<publisher-name>Springer</publisher-name>, pp. <fpage>52</fpage>–<lpage>67</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa777-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Needleman</surname><given-names>S.B.</given-names></string-name>, <string-name><surname>Wunsch</surname><given-names>C.D.</given-names></string-name></person-group> (<year>1970</year>) 
<article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>. <source>J. Mol. Biol</source>., <volume>48</volume>, <fpage>443</fpage>–<lpage>453</lpage>.<pub-id pub-id-type="pmid">5420325</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Notredame</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2000</year>) 
<article-title>T-coffee: a novel method for fast and accurate multiple sequence alignment</article-title>. <source>J. Mol. Biol</source>., <volume>302</volume>, <fpage>205</fpage>–<lpage>217</lpage>.<pub-id pub-id-type="pmid">10964570</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rahn</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) 
<article-title>Generic accelerated sequence alignment in SeqAn using vectorization and multi-threading</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3437</fpage>–<lpage>3445</lpage>.<pub-id pub-id-type="pmid">29726911</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rognes</surname><given-names>T.</given-names></string-name>, <string-name><surname>Seeberg</surname><given-names>E.</given-names></string-name></person-group> (<year>2000</year>) 
<article-title>Six-fold speed-up of Smith–Waterman sequence database searches using parallel processing on common microprocessors</article-title>. <source>Bioinformatics</source>, <volume>16</volume>, <fpage>699</fpage>–<lpage>706</lpage>.<pub-id pub-id-type="pmid">11099256</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Simpson</surname><given-names>J.T.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2009</year>) 
<article-title>ABySS: a parallel assembler for short read sequence data</article-title>. <source>Genome Res</source>., <volume>19</volume>, <fpage>1117</fpage>–<lpage>1123</lpage>.<pub-id pub-id-type="pmid">19251739</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Šošić</surname><given-names>M.</given-names></string-name>, <string-name><surname>Šikić</surname><given-names>M.</given-names></string-name></person-group> (<year>2017</year>) 
<article-title>Edlib: a C/C++ library for fast, exact sequence alignment using edit distance</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>1394</fpage>–<lpage>1395</lpage>.<pub-id pub-id-type="pmid">28453688</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B30">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Suzuki</surname><given-names>H.</given-names></string-name>, <string-name><surname>Kasahara</surname><given-names>M.</given-names></string-name></person-group> (<year>2017</year>) Acceleration of nucleotide semi-global alignment with adaptive banded dynamic programming. <italic toggle="yes">BioRxiv</italic>, <fpage>130633</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa777-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Suzuki</surname><given-names>H.</given-names></string-name>, <string-name><surname>Kasahara</surname><given-names>M.</given-names></string-name></person-group> (<year>2018</year>) 
<article-title>Introducing difference recurrence relations for faster semi-global alignment of long sequences</article-title>. <source>BMC Bioinformatics</source>, <volume>19</volume>, <fpage>45</fpage>.<pub-id pub-id-type="pmid">29504909</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Szalkowski</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2008</year>) 
<article-title>SWPS3 – fast multi-threaded vectorized Smith-Waterman for IBM cell/BE and ×86/SSE2</article-title>. <source>BMC Res. Notes</source>, <volume>1</volume>, <fpage>107</fpage>.<pub-id pub-id-type="pmid">18959793</pub-id></mixed-citation>
    </ref>
    <ref id="btaa777-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ukkonen</surname><given-names>E.</given-names></string-name></person-group> (<year>1985</year>) 
<article-title>Algorithms for approximate string matching</article-title>. <source>Inf. Control</source>, <volume>64</volume>, <fpage>100</fpage>–<lpage>118</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa777-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wozniak</surname><given-names>A.</given-names></string-name></person-group> (<year>1997</year>) 
<article-title>Using video-oriented instructions to speed up sequence comparison</article-title>. <source>Bioinformatics</source>, <volume>13</volume>, <fpage>145</fpage>–<lpage>150</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa777-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhao</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) 
<article-title>SSW library: an SIMD Smith-Waterman C/C++ library for use in genomic applications</article-title>. <source>PLoS One</source>, <volume>8</volume>, <fpage>e82138</fpage>.<pub-id pub-id-type="pmid">24324759</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
