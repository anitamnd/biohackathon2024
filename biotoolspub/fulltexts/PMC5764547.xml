<?properties open_access?>
<?properties manuscript?>
<?origin nihpa?>
<?iso-abbr Nat. Methods?>
<?submitter-system nihms?>
<?submitter-canonical-name Nature Publishing Group?>
<?submitter-canonical-id NATURE-STRUCTUR?>
<?submitter-userid 8068858?>
<?submitter-authority myNCBI?>
<?submitter-login nature-structure?>
<?submitter-name Nature Publishing Group?>
<?domain nihpa?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-journal-id">101215604</journal-id>
    <journal-id journal-id-type="pubmed-jr-id">32338</journal-id>
    <journal-id journal-id-type="nlm-ta">Nat Methods</journal-id>
    <journal-id journal-id-type="iso-abbrev">Nat. Methods</journal-id>
    <journal-title-group>
      <journal-title>Nature methods</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1548-7091</issn>
    <issn pub-type="epub">1548-7105</issn>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5764547</article-id>
    <article-id pub-id-type="pmid">28825705</article-id>
    <article-id pub-id-type="doi">10.1038/nmeth.4402</article-id>
    <article-id pub-id-type="manuscript">nihpa896903</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Reversed graph embedding resolves complex single-cell trajectories</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Qiu</surname>
          <given-names>Xiaojie</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
        <xref ref-type="aff" rid="A2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mao</surname>
          <given-names>Qi</given-names>
        </name>
        <xref ref-type="aff" rid="A3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tang</surname>
          <given-names>Ying</given-names>
        </name>
        <xref ref-type="aff" rid="A4">4</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Li</given-names>
        </name>
        <xref ref-type="aff" rid="A5">5</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chawla</surname>
          <given-names>Raghav</given-names>
        </name>
        <xref ref-type="aff" rid="A2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Pliner</surname>
          <given-names>Hannah A.</given-names>
        </name>
        <xref ref-type="aff" rid="A2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Trapnell</surname>
          <given-names>Cole</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
        <xref ref-type="aff" rid="A2">2</xref>
        <xref ref-type="author-notes" rid="FN1">*</xref>
      </contrib>
    </contrib-group>
    <aff id="A1"><label>1</label>Molecular &amp; Cellular Biology Program, University of Washington, Seattle, WA, 98195, USA</aff>
    <aff id="A2"><label>2</label>Department of Genome Sciences, University of Washington, Seattle, WA, 98195, USA</aff>
    <aff id="A3"><label>3</label>HERE company, Chicago IL 60606, USA</aff>
    <aff id="A4"><label>4</label>Department of Physics and Astronomy, Shanghai Jiao Tong University, Shanghai 200240, China</aff>
    <aff id="A5"><label>5</label>Department of Mathematics, Statistics and Computer Science, University of Illinois at Chicago, Chicago, USA</aff>
    <author-notes>
      <corresp id="FN1"><label>*</label>Corresponding author: <email>coletrap@uw.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="nihms-submitted">
      <day>25</day>
      <month>9</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>21</day>
      <month>8</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="ppub">
      <month>10</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>21</day>
      <month>2</month>
      <year>2018</year>
    </pub-date>
    <volume>14</volume>
    <issue>10</issue>
    <fpage>979</fpage>
    <lpage>982</lpage>
    <!--elocation-id from pubmed: 10.1038/nmeth.4402-->
    <permissions>
      <license>
        <license-p>Users may view, print, copy, and download text and data-mine the content in such documents, for the purposes of academic research, subject always to the full Conditions of use: 
<uri xlink:type="simple" xlink:href="http://www.nature.com/authors/editorial_policies/license.html#terms">http://www.nature.com/authors/editorial_policies/license.html#terms</uri></license-p>
      </license>
    </permissions>
    <abstract>
      <p id="P1">Single-cell trajectories can unveil how gene regulation governs cell fate decisions. However, learning the structure of complex trajectories with two or more branches remains a challenging computational problem. We present Monocle 2, which uses reversed graph embedding to describe multiple fate decisions in a fully unsupervised manner. Applied to two studies of blood development, Monocle 2 revealed that mutations in key lineage transcription factors diverts cells to alternative fates.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="S1">
    <title>Introduction</title>
    <p id="P2">Most cell state transitions, whether in development, reprogramming, or disease, are characterized by cascades of gene expression changes. We recently introduced a bioinformatics technique called “pseudotemporal ordering”, which applies machine learning to single-cell transcriptome sequencing (RNA-Seq) data to order cells by progression and reconstruct their “trajectory” as they differentiate or undergo some other type of biological transition<sup><xref rid="R1" ref-type="bibr">1</xref></sup>. Despite intense efforts to develop scalable, accurate pseudotime reconstruction algorithms (recently reviewed at<sup><xref rid="R2" ref-type="bibr">2</xref></sup>), state-of-the-art tools have several major limitations. Most pseudotime methods can only reconstruct linear trajectories, while others such as Wishbone<sup><xref rid="R3" ref-type="bibr">3</xref></sup> or DPT<sup><xref rid="R4" ref-type="bibr">4</xref></sup> support branch identification with heuristic procedures, but either are unable to identify more than one branch point in the trajectory or require that the user specify the number of branches and cell fates as an input parameter.</p>
    <p id="P3">Here, we describe Monocle 2 (<xref ref-type="supplementary-material" rid="SD1">Supplementary Software</xref> and <ext-link ext-link-type="uri" xlink:href="https://github.com/cole-trapnell-lab/monocle-release">https://github.com/cole-trapnell-lab/monocle-release</ext-link>), which applies reversed graph embedding (RGE)<sup><xref rid="R5" ref-type="bibr">5</xref>,<xref rid="R6" ref-type="bibr">6</xref></sup>, a recently developed machine learning strategy, to accurately reconstruct complex single-cell trajectories. Monocle 2 requires no <italic>a priori</italic> information about the genes that characterize the biological process, the number of cell fates or branch points in the trajectory, or the design of the experiment. Monocle 2 outperforms not only its previous version but also more recently developed methods, producing more accurate, robust trajectories.</p>
  </sec>
  <sec sec-type="results" id="S2">
    <title>Results</title>
    <p id="P4">Monocle 2 begins by identifying genes that define biological process using an unsupervised procedure we term “dpFeature”. The procedure works by selecting the genes differentially expressed between clusters of cells identified with tSNE dimension reduction followed by density peak clustering. When applied to four different datasets<sup><xref rid="R1" ref-type="bibr">1</xref>,<xref rid="R7" ref-type="bibr">7</xref>–<xref rid="R9" ref-type="bibr">9</xref></sup> most of the genes returned by dpFeature were also recovered by a semi-supervised selection method guided by aspects of the experimental design and were highly enriched for Gene Ontology relevant to myogenesis, confirming that dpFeature is a powerful and general unsupervised feature selection approach. (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figures 1–3</xref>)</p>
    <p id="P5">We next sought to develop a pseudotime trajectory reconstruction algorithm that does not require the number of cell fates or branches as an input parameter. To do so, we employed reversed graph embedding<sup><xref rid="R5" ref-type="bibr">5</xref>,<xref rid="R6" ref-type="bibr">6</xref></sup>, a machine learning technique to learn a parsimonious <italic>principal graph</italic>. Informally, a principal graph is like a principal curve<sup><xref rid="R10" ref-type="bibr">10</xref></sup> that passes through the “middle” of a dataset but is allowed to have branches<sup><xref rid="R11" ref-type="bibr">11</xref></sup>. However, learning a principal graph that describes a population of single-cell RNA-Seq profiles is very challenging because each expressed gene adds an additional dimension to the space. In general, learning geometry is dramatically harder in high-dimensional spaces<sup><xref rid="R12" ref-type="bibr">12</xref></sup>. Reversed graph embedding solves this problem by finding a mapping between the high dimensional gene expression space and a much lower dimensional one while simultaneously learning the structure of the graph in this reduced space.</p>
    <p id="P6">Monocle 2 uses DDRTree<sup><xref rid="R5" ref-type="bibr">5</xref>,<xref rid="R6" ref-type="bibr">6</xref></sup>, a scalable RGE algorithm, to learn a principal tree on a population of single cells by default, asserting that it describes the sequence of changes to global gene expression levels as a cell progresses through the biological process under study (<xref rid="F1" ref-type="fig">Figure 1A</xref>). In contrast to other methods<sup><xref rid="R1" ref-type="bibr">1</xref>,<xref rid="R3" ref-type="bibr">3</xref>,<xref rid="R4" ref-type="bibr">4</xref>,<xref rid="R13" ref-type="bibr">13</xref></sup>, Monocle 2 identifies branch points that describe significant divergences in cellular state automatically. Monocle is also equipped with alternative RGE methods<sup><xref rid="R5" ref-type="bibr">5</xref>,<xref rid="R6" ref-type="bibr">6</xref></sup> including one that in principle can learn cyclical or disjoint trajectories, though doing so requires some degree of parameter optimization on behalf of the user.</p>
    <p id="P7">To assess the Monocle 2’s accuracy, we first applied it to myoblasts, which we previously reported to differentiate along a linear trajectory<sup><xref rid="R1" ref-type="bibr">1</xref></sup> (<xref rid="F1" ref-type="fig">Figure 1B</xref>). Surprisingly, Monocle 2 reconstructed a trajectory with a single branch point leading to two outcomes (<xref rid="F1" ref-type="fig">Figure 1C</xref>). Some genes associated with mitogen withdrawal, such as <italic>CCNB2</italic> showed similar kinetics on both branches, but a number of genes required for muscle contraction were strongly activated only on one of the two branches of the Monocle 2 trajectory (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 4</xref>). A global search for genes with significant branch-dependent expression using Branch Expression Analysis Modeling (BEAM)<sup><xref rid="R14" ref-type="bibr">14</xref></sup> revealed that cells along these two outcomes, F<sub>1</sub> and F<sub>2</sub>, differed in the expression of 887 genes (FDR &lt; 10%), including numerous components of the contractile muscle program. The BEAM analysis suggested that only outcome F<sub>1</sub> represented successful progression to fused myotubes (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 4</xref>), consistent with immunofluorescence measurements of <italic>MYH2</italic>, which show a substantial fraction of isolated nuclei lacking MYH2 and that are not incorporated into myotubes (ref. Figures 1 and 4 of<sup><xref rid="R1" ref-type="bibr">1</xref></sup>).</p>
    <p id="P8">A simulation of differentiation driven by a set of stochastic differential equations controlled by a hypothetical gene regulatory network<sup><xref rid="R15" ref-type="bibr">15</xref></sup> demonstrated that Monocle 2 robustly and accurately reconstructed trajectories with up to three fates (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 5–8, Supplementary Data 1, 2</xref>)<sup><xref rid="R16" ref-type="bibr">16</xref></sup>. In contrast to other methods, Monocle 2 also accurately learned a complex tree with five branches in a fully automatic fashion (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 6B, Supplementary Data 3</xref>).</p>
    <p id="P9">We next sought to compare Monocle 2 to state-of-the art algorithms for inferring single-cell trajectories, including Monocle 1<sup><xref rid="R1" ref-type="bibr">1</xref></sup>, Wishbone<sup><xref rid="R3" ref-type="bibr">3</xref></sup>, Diffusion Pseudotime (DPT)<sup><xref rid="R4" ref-type="bibr">4</xref></sup>, and SLICER<sup><xref rid="R13" ref-type="bibr">13</xref></sup>. Unlike Monocle 2, these methods do not construct an explicit tree. Instead they order cells based on pairwise geodesic distances between them as approximated by a nearest-neighbor graph (Wishbone and SLICER) or minimum spanning tree (Monocle 1) or calculated analytically (DPT). Wishbone, SLICER, and DPT identify branches implicitly by analyzing patterns in the pseudotime orderings that are inconsistent with a linear trajectory. Furthermore, Wishbone assumes the trajectory has exactly one branch point, while DPT can detect more than one, but provides no means of automatically determining how many genuine branches exist in the data. We hypothesized that Monocle 2’s explicit trajectory structure would yield more robust pseudotimes and branch assignments than alternative algorithms.</p>
    <p id="P10">We tested each algorithm using data from Paul et al, who analyzed transcriptomes of several thousand differentiating blood cells<sup><xref rid="R9" ref-type="bibr">9</xref></sup>. Monocle 2, DPT, and Wishbone produced qualitatively similar trajectories, with CMP cells residing upstream of a branch at which GMP and erythroid cells diverge (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 9–11</xref>). SLICER generated a branched trajectory in which the branch occurs within the erythroid population to bifurcate into either CMPs or GMPs. Monocle 2, Wishbone, and DPT produced orderings that were highly correlated with a “reference ordering”, constructed using a panel of markers similar to the approach introduced by Tirosh et al<sup><xref rid="R17" ref-type="bibr">17</xref></sup>, while SLICER and Monocle 1 were less so. Monocle 2 assigned cells to branches as or more accurately than other methods (<xref rid="F1" ref-type="fig">Figure 1D</xref>, <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 10</xref>), but Monocle 2’s assignments were far more consistent when provided with subsampled fractions of the cells (<xref rid="F1" ref-type="fig">Figure 1E</xref>, <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 9F,G</xref>). When run on the myoblast data, DPT positioned most fully differentiated cells along a major branch, with incompletely differentiated cells split along a minor branch or not assigned to either, while Wishbone failed to discriminate correctly between the two outcomes (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 12</xref>). Although Monocle 2 can be tuned for several user-specified parameters, its results were similar to the defaults over widely varying values (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figures 13–14</xref>). Monocle 2’s running time scaled linearly in the number of input cells, consistent with its linear algorithmic complexity, processing 8365 cells in 9 minutes (<xref ref-type="supplementary-material" rid="SD1">Supplemental Figures 13C</xref>) These benchmarks demonstrate that Monocle 2 produces trajectories that are as accurate and more robust than state-of-art methods and yet makes fewer assumptions regarding the number of cell fates generated by the trajectory.</p>
    <p id="P11">We also assessed Monocle 2’s alternative algorithms for dimensionality reduction and graph learning. DDRTree, SimplePPT and SGL-tree, which implement RGE to learn principal trees reported highly concordant trajectories when the data was initially reduced with PCA, ICA, and diffusion maps (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 15</xref>. LLE, a reduction technique known to be highly sensitive to tuning parameters, sometimes led to incorrect reconstructions with SimplePPT. L1-graph, an RGE algorithm that can learn graphs with multiple components or cycles, often reported less refined graphs with numerous minor branches, but captured the overall trajectory structure accurately.</p>
    <p id="P12">Because Monocle 2 can in principle learn complex trajectories with many branches, we reanalyzed the data from Paul et al. in 10 dimensions (selected based on variance explained by PCs) rather than the default of two. This higher-dimensional trajectory contained five branching events leading to six different outcomes, with cells classified by Paul et al. as fully differentiated monocytes, neutrophils, eosinophil, basophils, dendritic cells, megakaryocytes, and erythrocytes confined to distinct outcomes (<xref ref-type="supplementary-material" rid="SD1">Supplemental Figure 16</xref>). Thus, Monocle 2 can resolve complex branching processes.</p>
    <p id="P13">Although Monocle 2’s trajectories for differentiating myoblasts and common myeloid progenitors were broadly consistent with the known sequence of regulatory events governing those processes, we sought further experimental means of validating the structure of the algorithm’s trajectories. Recently, Olsson <italic>et al</italic> profiled several hundred FACS-sorted cells during various stages of murine myelopoeisis, <italic>i.e.</italic> LSK, CMP, GMP and LKCD34+ cells. We analyzed these cells with Monocle 2 and reconstructed a trajectory with two major branches and three distinct fates (<xref rid="F2" ref-type="fig">Figure 2</xref>, <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 17, 18</xref>). Lin−/Sca1+/c-Kit+ (LSK) cells were concentrated at one tip of the tree, which we designated the root, with CMP, GMP, and LKCD34+ cells distributed over the remainder of the tree (<xref rid="F2" ref-type="fig">Figure 2A</xref>, <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 17A</xref>).</p>
    <p id="P14">Monocle 2 placed cells classified as erythrocytes or megakaryocytes on a path to outcome F<sub>E</sub>, while granulocytes and monocytes by Olsson <italic>et al</italic> were confined to outcomes F<sub>G</sub> and F<sub>M</sub> respectively. Genes associated with the granulocytic and monocytic programs became progressively more differentially expressed following the second branch (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 17B, C</xref>). Many of the genes with significantly branch-dependent expression (BEAM test<sup><xref rid="R14" ref-type="bibr">14</xref></sup>, FDR &lt; 1%), were bound at their promoters by Irf8 or Gfi1, key activators of the monocytic and granulocytic expression programs, respectively (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 17D, E</xref>).</p>
    <p id="P15">Providing cells from mice lacking <italic>Gfi1</italic> or <italic>Irf8</italic> to Monocle 2 did not substantially alter the structure of the myeloid differentiation trajectory (<xref rid="F2" ref-type="fig">Figure 2B</xref>). However, cells from <italic>Gfi1</italic>−/− mice were largely excluded from the branch occupied by wild-type granulocytes, and Irf8−/− cells were depleted from the wild-type monocyte branch. That is, the loss of a gene known to activate a fate-specific expression program appeared to divert cells to the opposite fate. Cells from double knockout mice (<italic>Gfi1</italic>−/− <italic>Irf8</italic>−/−) were present on both monocyte and granulocyte branches, but concentrated closer to the branch point and away from the tips of the tree, suggesting that they did not fully differentiate (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 19A</xref>).</p>
    <p id="P16">Testing whether <italic>Gfi1</italic>−/− or <italic>Irf8</italic>−/− had fully adopted the monocyte and granulocyte expression programs, revealed that <italic>Gfi1</italic>−/− cells on the branch to F<sub>M</sub> express higher levels of genes from normally associated with granulocytes than wild-type monocytes (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 19</xref>, <bold>Methods</bold>). Likewise, cells from <italic>Irf8</italic>−/− mice on the branch to F<sub>G</sub> showed aberrantly high levels of monocytic genes. Analysis of genetic perturbations from the large-scale transcriptomic study of hematopoiesis reported by Paul <italic>et al</italic> also revealed diversions of cells onto specific branches of the trajectory, suggesting that diversion of cells from one fate to another may be a consequence of losing a key fate regulator (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 19G, H</xref>).</p>
    <p id="P17">In addition to known differentiated cell types, Olsson <italic>et al.</italic> detected cells that express a mix of genes specific to different terminal cell fates. They also reported rare, transient cell states that mix hematopoietic/multipotent markers with differentiated markers. They concluded that both types of “mixed lineage” cells reside in the developmental hierarchy downstream of long-term and short-term HSCs but upstream of cells that have committed to a lineage. Consistent with this interpretation, Monocle 2 positioned mixed-lineage cells and rare transient cells (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 20</xref>) upstream of the the granulocyte-monocyte branch.</p>
  </sec>
  <sec sec-type="discussion" id="S3">
    <title>Discussion</title>
    <p id="P18">Single-cell RNA-Seq has spurred an explosion of computational methods to infer the precise sequence of gene regulatory events that drive transitions from one cellular state to another. However, most current methods rely on strong assumptions about the structure of a biological trajectory. Many also require the user to supervise trajectory inference, inject large amounts of <italic>a priori</italic> biological knowledge, or both.</p>
    <p id="P19">Monocle 2 learns complex cellular trajectories with multiple branches in a fully data-driven, unsupervised fashion with only limited assumptions regarding its structure. It employs a class of manifold learning algorithms that aim to embed a principal graph amongst the high-dimensional single-cell RNA-seq data. In contrast to previous methods that infer branch structure using heuristic analyses of pairwise distances between cells, Monocle 2 can use this graph to directly identify developmental fate decisions. We have demonstrated through extensive benchmarking that Monocle 2 compares favorably with other tools such as Wishbone without requiring the user to specify the structure of the trajectory.</p>
    <p id="P20">Analysis of multiple real and synthetic datasets demonstrated that Monocle 2 reconstructs trajectories that faithfully characterize cellular differentiation. Previously, we showed that loss of interferon signaling can create a new branch in an otherwise linear trajectory that reflects the response of dendritic cells to antigen<sup><xref rid="R14" ref-type="bibr">14</xref></sup>. Here, we show that cells from mice that lack transcription factors required for establishing specific myeloid fates were diverted onto alternative fates of the same trajectory without altering its structure. Why some loss of function mutations create branches while others divert cells along existing ones is unclear, but this question underscores the increasing power of analyzing single-cell trajectories. We also anticipate that Monocle 2 will be useful not just for expression data, but for single-cell chromatin accessibility<sup><xref rid="R18" ref-type="bibr">18</xref></sup> or 3D structure<sup><xref rid="R19" ref-type="bibr">19</xref></sup> analysis as well. We are confident that Monocle 2 will help reveal how various layers of gene regulation coordinate developmental decision making within individual cells.</p>
  </sec>
  <sec id="S4" specific-use="web-only">
    <title>Online Methods</title>
    <sec id="S5">
      <title>Reversed graph embedding</title>
      <p id="P21">Monocle 2 uses a technique called reversed graph embedding<sup><xref rid="R5" ref-type="bibr">5</xref>,<xref rid="R6" ref-type="bibr">6</xref>, <xref rid="R20" ref-type="bibr">20</xref></sup> (RGE) to learn a graph structure that describes a single-cell experiment. RGE simultaneously learns a principal graph that represents the cell trajectory, as well as a function that maps points on the trajectory (which is embedded in low dimensions) back to the original high dimensional space. RGE aims to learn both a set of latent points 
<inline-formula><mml:math id="M1" display="inline" overflow="scroll"><mml:mi mathvariant="script">Z</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula> where 
<inline-formula><mml:math id="M2" display="inline" overflow="scroll"><mml:mi>N</mml:mi></mml:math></inline-formula> is the number of the set (or cell numbers) and an undirected graph 
<inline-formula><mml:math id="M3" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> that connects these latent points. The latent points 
<inline-formula><mml:math id="M4" display="inline" overflow="scroll"><mml:mi mathvariant="script">Z</mml:mi></mml:math></inline-formula> in the low-dimensional space corresponds to the input data 
<inline-formula><mml:math id="M5" display="inline" overflow="scroll"><mml:mi mathvariant="script">X</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula> in the high-dimensional space. The graph 
<inline-formula><mml:math id="M6" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">V</mml:mi><mml:mo>,</mml:mo><mml:mi>ℰ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> contains a set of vertexes 
<inline-formula><mml:math id="M7" display="inline" overflow="scroll"><mml:mi mathvariant="script">V</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula> and a set of weighted, undirected edges 
<inline-formula><mml:math id="M8" display="inline" overflow="scroll"><mml:mi>ℰ</mml:mi></mml:math></inline-formula>, where each 
<inline-formula><mml:math id="M9" display="inline" overflow="scroll"><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> corresponds to latent point 
<inline-formula><mml:math id="M10" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula>, so the graph also resides in the latent, low-dimensional space.</p>
      <p id="P22">In the context of the single-cell trajectory construction problem, 
<inline-formula><mml:math id="M11" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> is typically a vector of the feature genes’ expression values (for example, based on dpFeature selection, see <xref ref-type="supplementary-material" rid="SD1">Supplementary Notes</xref>) of the 
<inline-formula><mml:math id="M12" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula>th cell in a single-cell RNA-Seq experiment, 
<inline-formula><mml:math id="M13" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> is the learned trajectory (for example, a tree) along which the cells transit, and 
<inline-formula><mml:math id="M14" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> is the principal point on 
<inline-formula><mml:math id="M15" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> corresponding to the cell 
<inline-formula><mml:math id="M16" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula>.</p>
      <p id="P23">RGE learns the graph 
<inline-formula><mml:math id="M17" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula> as well as a function that maps back to the input data space. Let 
<inline-formula><mml:math id="M18" display="inline" overflow="scroll"><mml:msub><mml:mi>b</mml:mi><mml:mi mathvariant="italic">ij</mml:mi></mml:msub></mml:math></inline-formula> denote the weight of edge 
<inline-formula><mml:math id="M19" display="inline" overflow="scroll"><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, which represents the connectivity between 
<inline-formula><mml:math id="M20" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> and
<inline-formula><mml:math id="M21" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula>. In other words, 
<inline-formula><mml:math id="M22" display="inline" overflow="scroll"><mml:msub><mml:mi>b</mml:mi><mml:mi mathvariant="italic">ij</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> means that edge 
<inline-formula><mml:math id="M23" display="inline" overflow="scroll"><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> exists in 
<inline-formula><mml:math id="M24" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>, and 0 otherwise. Define 
<inline-formula><mml:math id="M25" display="inline" overflow="scroll"><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub></mml:math></inline-formula> as the projection function from 
<inline-formula><mml:math id="M26" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> to some point in the high-dimensional space. To learn 
<inline-formula><mml:math id="M27" display="inline" overflow="scroll"><mml:mi mathvariant="script">G</mml:mi></mml:math></inline-formula>, 
<inline-formula><mml:math id="M28" display="inline" overflow="scroll"><mml:mi mathvariant="script">Z</mml:mi></mml:math></inline-formula> and 
<inline-formula><mml:math id="M29" display="inline" overflow="scroll"><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub></mml:math></inline-formula>, we need to optimize
<disp-formula id="FD1"><mml:math id="M30" display="block" overflow="scroll"><mml:munder><mml:mi mathvariant="italic">min</mml:mi><mml:mrow><mml:mi mathvariant="script">G</mml:mi><mml:mo mathvariant="normal">∈</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:munder><mml:munder><mml:mi mathvariant="italic">min</mml:mi><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mo mathvariant="normal">∈</mml:mo><mml:mi>ℱ</mml:mi></mml:mrow></mml:munder><mml:munder><mml:mi mathvariant="italic">min</mml:mi><mml:mi mathvariant="script">Z</mml:mi></mml:munder><mml:munder><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo mathvariant="normal">∈</mml:mo><mml:mi>ℰ</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:math></disp-formula>where 
<inline-formula><mml:math id="M31" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">b</mml:mi></mml:msub></mml:math></inline-formula> is a set of feasible graph structures parameterized 
<inline-formula><mml:math id="M32" display="inline" overflow="scroll"><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi mathvariant="normal">b</mml:mi><mml:mrow><mml:mi mathvariant="normal">i</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal">∀</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="normal">j</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula>, and 
<inline-formula><mml:math id="M33" display="inline" overflow="scroll"><mml:mi>ℱ</mml:mi></mml:math></inline-formula> is a set of functions mapping a latent, low-dimensional point to a point in the original, high-dimensional space.</p>
      <p id="P24">As shown in<sup><xref rid="R5" ref-type="bibr">5</xref></sup>, the above optimization will learn graph structures in the latent space, but it does not measure the deviations of latent points to the observed data. That is, no effort is made to ensure that the graph nodes are embedded in a way relevant to the cloud of observed data points. To ensure the graph describes the overall structure of the observed data, RGE aims to position the latent points such that their image under the function 
<inline-formula><mml:math id="M34" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="normal">f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub></mml:math></inline-formula> (that is, their corresponding positions in the high-dimensional space) will be close to the input data while also ensures neighbor points on low dimensional principal graph be “neighbors” in the input dimension. The optimization problem is formulated as
<disp-formula id="FD2"><mml:math id="M35" display="block" overflow="scroll"><mml:munder><mml:mi mathvariant="italic">min</mml:mi><mml:mrow><mml:mi mathvariant="script">G</mml:mi><mml:mi mathvariant="normal">∈</mml:mi><mml:msub><mml:mi>G</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:munder><mml:munder><mml:mi mathvariant="italic">min</mml:mi><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mi mathvariant="normal">∈</mml:mi><mml:mi>ℱ</mml:mi></mml:mrow></mml:munder><mml:munder><mml:mi mathvariant="italic">min</mml:mi><mml:mi mathvariant="script">Z</mml:mi></mml:munder><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mfrac><mml:mi>λ</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:munder><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>V</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">∈</mml:mi><mml:mi>ℰ</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:math></disp-formula>where 
<inline-formula><mml:math id="M36" display="inline" overflow="scroll"><mml:mi>λ</mml:mi></mml:math></inline-formula> is a parameter that adjusts the relative strength of these two summations. In practice, implementing reversed graph embedding requires that we place some constraints on 
<inline-formula><mml:math id="M37" display="inline" overflow="scroll"><mml:msub><mml:mi>G</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:math></inline-formula> and 
<inline-formula><mml:math id="M38" display="inline" overflow="scroll"><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub></mml:math></inline-formula>, as summarized briefly in the following sections.</p>
    </sec>
    <sec id="S6">
      <title>SimplePPT: A simple principal tree algorithm</title>
      <p id="P25">SimplePPT is the first RGE technique proposed by Mao et al for learning a tree structure to describe a set of observed data points. The tree can be learned in the original space or in some lower dimension retrieved by dimensionality reduction methods such as PCA<sup><xref rid="R20" ref-type="bibr">20</xref></sup>. SimplePPT makes some choices that simplify the optimization problem. Notably, 
<inline-formula><mml:math id="M39" display="inline" overflow="scroll"><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is optimized as one single variable instead of two separate sets of variables. Moreover, the loss function in the reversed graph embedding is replaced by the empirical quantization error, which serves as the measurement between the 
<inline-formula><mml:math id="M40" display="inline" overflow="scroll"><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> and its corresponding observed points 
<inline-formula><mml:math id="M41" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula>. The joint optimization of 
<inline-formula><mml:math id="M42" display="inline" overflow="scroll"><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is efficient from the perspective of optimization with respect to 
<inline-formula><mml:math id="M43" display="inline" overflow="scroll"><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi mathvariant="italic">ij</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula>, which is solved by simply finding the minimum spanning tree.</p>
    </sec>
    <sec id="S7">
      <title>The principal 
<inline-formula><mml:math id="M44" display="inline" overflow="scroll"><mml:msub><mml:mi>ℒ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> graph algorithm</title>
      <p id="P26">Mao et al later proposed an extension of SimplePPT that can learn arbitrary graphs, rather than just trees, which describes large datasets embedded in the same space as the input<sup><xref rid="R6" ref-type="bibr">6</xref></sup>. An 
<inline-formula><mml:math id="M45" display="inline" overflow="scroll"><mml:msub><mml:mi>ℒ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> graph is a sparse graph which is based on the assumption that each data point (or cell) has a small number of neighborhoods in which the minimum number of points that span a low-dimensional affine subspace<sup><xref rid="R21" ref-type="bibr">21</xref></sup> passing through that point. In addition, there may exist noise in certain elements of 
<inline-formula><mml:math id="M46" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> and a natural idea is to estimate the edge weights by tolerating these errors. In general, a sparse solution is more robust and facilitates the consequent identification of test sample (or sequenced single-cell samples). Unlike SimplePPT, this method learns the graph by formulating the optimization as a linear programming problem.</p>
      <p id="P27">In the same work<sup><xref rid="R6" ref-type="bibr">6</xref></sup>, they also proposed a generalization of SimplePPT, which we term as SGL-tree (Principal Graph and Structure Learning for tree), to learn tree structure for large dataset by similarly considering clustering of data points as in DDRTree. Principal 
<inline-formula><mml:math id="M47" display="inline" overflow="scroll"><mml:msub><mml:mi>ℒ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:math></inline-formula> graph and SGL-tree are all treated as SGL in this study.</p>
    </sec>
    <sec id="S8">
      <title>DDRTree: Discriminative dimensionality reduction via learning a tree</title>
      <p id="P28">DDRTree<sup><xref rid="R5" ref-type="bibr">5</xref></sup>, the default RGE technique used by Monocle 2, provides two key features not offered by SimplePPT learning framework. First, DDRTree does not assume the graph resides in the input space, and can reduce its dimensionality while learning the trajectory. Second, it also does not require that there be one node in the graph per data point, which greatly accelerates the algorithm and reduces its memory footprint.</p>
      <p id="P29">Like SimplePPT, DDRTree learns a latent point for each cell, along with a linear projection function 
<inline-formula><mml:math id="M48" display="inline" overflow="scroll"><mml:msub><mml:mi>f</mml:mi><mml:mi mathvariant="script">G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">Wz</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula>, where 
<inline-formula><mml:math id="M49" display="inline" overflow="scroll"><mml:mi mathvariant="bold-italic">W</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">w</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">w</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mi mathvariant="normal">∈</mml:mi><mml:msup><mml:mi>R</mml:mi><mml:mrow><mml:mi>D</mml:mi><mml:mo>×</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> is a matrix with columns that form an orthogonal basis 
<inline-formula><mml:math id="M50" display="inline" overflow="scroll"><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">w</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">w</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula> (
<inline-formula><mml:math id="M51" display="inline" overflow="scroll"><mml:mi>D</mml:mi></mml:math></inline-formula> is the dimension of feature genes, 
<inline-formula><mml:math id="M52" display="inline" overflow="scroll"><mml:mi>d</mml:mi></mml:math></inline-formula> is the dimension of latent space). DDRTree simultaneously learns a graph on a second set of latent points
<inline-formula><mml:math id="M53" display="inline" overflow="scroll"><mml:mi mathvariant="script">Y</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:math></inline-formula>. These points are treated as the centroids of 
<inline-formula><mml:math id="M54" display="inline" overflow="scroll"><mml:msubsup><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:math></inline-formula> where 
<inline-formula><mml:math id="M55" display="inline" overflow="scroll"><mml:mi>K</mml:mi><mml:mo>≤</mml:mo><mml:mi>N</mml:mi></mml:math></inline-formula> and the principal graph is the spanning tree of those centroids. The DDRTree scheme works by optimizing
<disp-formula id="FD3"><mml:math id="M56" display="block" overflow="scroll"><mml:munder><mml:mi mathvariant="normal">min</mml:mi><mml:mrow><mml:mi mathvariant="bold-italic">W</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">B</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold-italic">R</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Z</mml:mi></mml:mrow></mml:munder><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">Wz</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mfrac><mml:mi>λ</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:munder><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:munder><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo>‖</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">Wy</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">Wy</mml:mi><mml:msup><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>γ</mml:mi><mml:mo>[</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">‖</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi mathvariant="bold-italic">y</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>σ</mml:mi><mml:mi mathvariant="normal">log</mml:mi><mml:mspace width="0.2em"/><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>]</mml:mo><mml:mspace width="0.4em"/><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>t</mml:mi><mml:mo>.</mml:mo><mml:mspace width="0.3em"/><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">}</mml:mo><mml:mspace width="0.3em"/><mml:mi mathvariant="italic">is</mml:mi><mml:mspace width="0.2em"/><mml:mi mathvariant="normal">a</mml:mi><mml:mspace width="0.2em"/><mml:mi mathvariant="normal">spanning</mml:mi><mml:mspace width="0.2em"/><mml:mi mathvariant="normal">tree</mml:mi><mml:mspace width="0.4em"/><mml:msup><mml:mi mathcolor="#44546A" mathvariant="bold-italic">W</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi mathcolor="#44546A" mathvariant="bold-italic">W</mml:mi><mml:mo>=</mml:mo><mml:mi mathcolor="#44546A" mathvariant="bold-italic">I</mml:mi></mml:math></disp-formula>
<disp-formula id="FD4"><mml:math id="M57" display="block" overflow="scroll"><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo mathvariant="normal">∀</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:math></disp-formula></p>
      <p id="P30">In effect, the algorithm acts as soft 
<inline-formula><mml:math id="M58" display="inline" overflow="scroll"><mml:mi>K</mml:mi></mml:math></inline-formula>-means clustering on points 
<inline-formula><mml:math id="M59" display="inline" overflow="scroll"><mml:mi mathvariant="script">Z</mml:mi></mml:math></inline-formula>, and jointly learns a graph on the 
<inline-formula><mml:math id="M60" display="inline" overflow="scroll"><mml:mi>K</mml:mi></mml:math></inline-formula> cluster centers. The matrix 
<inline-formula><mml:math id="M61" display="inline" overflow="scroll"><mml:mi mathvariant="bold-italic">R</mml:mi></mml:math></inline-formula> with the 
<inline-formula><mml:math id="M62" display="inline" overflow="scroll"><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>th element as 
<inline-formula><mml:math id="M63" display="inline" overflow="scroll"><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> transforms the hard assignments used in 
<inline-formula><mml:math id="M64" display="inline" overflow="scroll"><mml:mi>K</mml:mi></mml:math></inline-formula>-means into soft assignments with 
<inline-formula><mml:math id="M65" display="inline" overflow="scroll"><mml:mi>σ</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> as a regularization parameter. The above problem contains a number of analytical steps, and can be solved by alternating optimization until convergence. Moreover, because some of the more expensive numerical operations involve matrices that are 
<inline-formula><mml:math id="M66" display="inline" overflow="scroll"><mml:mi>K</mml:mi></mml:math></inline-formula> dimensional (instead of 
<inline-formula><mml:math id="M67" display="inline" overflow="scroll"><mml:mi>N</mml:mi></mml:math></inline-formula> dimensional), they have complexity that is invariant of the size of the input data for a small fixed 
<inline-formula><mml:math id="M68" display="inline" overflow="scroll"><mml:mi>K</mml:mi></mml:math></inline-formula>. In Monocle 2, we provide a procedure to automatically chooses a value of 
<inline-formula><mml:math id="M69" display="inline" overflow="scroll"><mml:mi>K</mml:mi></mml:math></inline-formula> that should work well for a wide range of datasets based on the number of cells 
<inline-formula><mml:math id="M70" display="inline" overflow="scroll"><mml:mi>N</mml:mi></mml:math></inline-formula> in the experiment:
<disp-formula id="FD5"><mml:math id="M71" display="block" overflow="scroll"><mml:mi mathcolor="#44546A">K</mml:mi><mml:mo mathcolor="#44546A">=</mml:mo><mml:mo mathcolor="#44546A">{</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A">N</mml:mi><mml:mo mathcolor="#44546A">,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mfrac><mml:mrow><mml:mn mathcolor="#44546A">2</mml:mn><mml:mo mathcolor="#44546A">⋅</mml:mo><mml:mn mathcolor="#44546A">100</mml:mn><mml:mo mathcolor="#44546A">⋅</mml:mo><mml:mi mathcolor="#44546A" mathvariant="italic">log</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mi mathcolor="#44546A">N</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo></mml:mrow><mml:mrow><mml:mi mathcolor="#44546A" mathvariant="italic">log</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mi mathcolor="#44546A">N</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">+</mml:mo><mml:mi mathcolor="#44546A" mathvariant="italic">log</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mn mathcolor="#44546A">100</mml:mn><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable><mml:mtable><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A" mathvariant="italic">if</mml:mi><mml:mspace width="0.2em"/><mml:mi mathcolor="#44546A">N</mml:mi><mml:mo mathcolor="#44546A">&lt;</mml:mo><mml:mn mathcolor="#44546A">100</mml:mn><mml:mo mathcolor="#44546A">,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A" mathvariant="italic">otherwise</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>During the first optimization iteration, these 
<inline-formula><mml:math id="M72" display="inline" overflow="scroll"><mml:mi>K</mml:mi></mml:math></inline-formula> centroids are initialized by using 
<inline-formula><mml:math id="M73" display="inline" overflow="scroll"><mml:mi>k</mml:mi></mml:math></inline-formula>-mediods clustering in the low-dimensional space.</p>
    </sec>
    <sec id="S9">
      <title>Pseudotime calculation and branch assignment</title>
      <p id="P31">By default, Monocle 2 calls DDRTree to learn the principal tree describing a single cell experiment, and then projects each cell onto its nearest location on the tree. Monocle 2 allows users to conveniently select a tip of the tree as the root and then transverses the tree from the root, computing the geodesic distance of each cell to the root cell, which is taken as its pseudotime, and assign branch or segment simultaneously.</p>
      <p id="P32">DDRTree returns a principal tree of the centroids of cell clusters in low dimension. To calculate pseudotimes, Monocle 2 projects the cell’s latent points 
<inline-formula><mml:math id="M74" display="inline" overflow="scroll"><mml:mi mathvariant="script">Z</mml:mi></mml:math></inline-formula>, to the principal graph formed by principal points, 
<inline-formula><mml:math id="M75" display="inline" overflow="scroll"><mml:mi mathvariant="script">Y</mml:mi></mml:math></inline-formula>. For latent points not near tip principal points (end nodes of the principal tree), Monocle 2 finds the nearest line segment on the principal tree and then project them to the nearest point on that segment. More formally, we can define a vector between a cell 
<inline-formula><mml:math id="M76" display="inline" overflow="scroll"><mml:mi>c</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, where 
<inline-formula><mml:math id="M77" display="inline" overflow="scroll"><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:math></inline-formula> denotes the coordinates of the cell in the latent space, to the nearest principal point 
<inline-formula><mml:math id="M78" display="inline" overflow="scroll"><mml:mi>A</mml:mi></mml:math></inline-formula> by 
<inline-formula><mml:math id="M79" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mi mathvariant="italic">Ac</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:math></inline-formula>. The line segment formed by the two nearest principal points 
<inline-formula><mml:math id="M80" display="inline" overflow="scroll"><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>A</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> is 
<inline-formula><mml:math id="M81" display="inline" overflow="scroll"><mml:mover accent="true"><mml:mi mathvariant="italic">AB</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:math></inline-formula>. Then we can calculate 
<inline-formula><mml:math id="M82" display="inline" overflow="scroll"><mml:mi>t</mml:mi></mml:math></inline-formula> as 
<inline-formula><mml:math id="M83" display="inline" overflow="scroll"><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="italic">Ac</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo>⋅</mml:mo><mml:mover accent="true"><mml:mi mathvariant="italic">AB</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="italic">AB</mml:mi><mml:mo>|</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:math></inline-formula>. The projection can be calculated as:
<disp-formula id="FD6"><mml:math id="M84" display="block" overflow="scroll"><mml:mi mathcolor="#44546A">p</mml:mi><mml:mo mathcolor="#44546A">=</mml:mo><mml:mo mathcolor="#44546A">{</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A">A</mml:mi></mml:mtd><mml:mtd columnalign="left"><mml:mi mathcolor="#44546A" mathvariant="italic">if</mml:mi><mml:mspace width="0.2em"/><mml:mi>t</mml:mi><mml:mo mathcolor="#44546A">&lt;</mml:mo><mml:mn mathcolor="#44546A">0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>B</mml:mi></mml:mtd><mml:mtd columnalign="left"><mml:mi mathcolor="#44546A" mathvariant="italic">if</mml:mi><mml:mspace width="0.2em"/><mml:mi mathcolor="#44546A">t</mml:mi><mml:mo mathcolor="#44546A">&gt;</mml:mo><mml:mn mathcolor="#44546A">1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A">A</mml:mi><mml:mo mathcolor="#44546A">+</mml:mo><mml:mi mathcolor="#44546A">t</mml:mi><mml:mo mathcolor="#44546A">⋅</mml:mo><mml:mover accent="true"><mml:mi mathcolor="#44546A" mathvariant="italic">AB</mml:mi><mml:mo mathcolor="#44546A">⇀</mml:mo></mml:mover></mml:mtd><mml:mtd columnalign="left"><mml:mi mathcolor="#44546A" mathvariant="italic">if</mml:mi><mml:mspace width="0.2em"/><mml:mn mathcolor="#44546A">0</mml:mn><mml:mo mathcolor="#44546A">≤</mml:mo><mml:mi mathcolor="#44546A">t</mml:mi><mml:mo mathcolor="#44546A">≤</mml:mo><mml:mn mathcolor="#44546A">1</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>For latent points near the tip principal points, we will orthogonally project the latent point to the line segment formed by extending the tip principal point and its nearest neighbor principal point in the graph to obtain the projection point, that is,
<inline-formula><mml:math id="M85" display="inline" overflow="scroll"><mml:mi>A</mml:mi><mml:mo>+</mml:mo><mml:mi>t</mml:mi><mml:mo>⋅</mml:mo><mml:mover accent="true"><mml:mi mathvariant="italic">AB</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:math></inline-formula>.</p>
      <p id="P33">We then calculate the distance between all the projection points and construct a minimal spanning tree (MST) on the projection points. To avoid zero values of distance between cells projected to the same principal points, which prevents the calculation of a MST, the smallest positive distance between all cell pairs is added to all distance values. This MST is used to assign pseudotime for each cell (See below).</p>
      <p id="P34">To encode the position of each cell within the branching structure of the trajectory, Monocle 2 performs a depth-first traversal of the principal tree learned during RGE. Without loss of generality, we assume one principal point corresponds to one latent point (for example, in the case we set 
<inline-formula><mml:math id="M86" display="inline" overflow="scroll"><mml:mi mathvariant="italic">ncenter</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="italic">NULL</mml:mi></mml:math></inline-formula> or each cell corresponds to its own cluster). Following the definition introduced in<sup><xref rid="R1" ref-type="bibr">1</xref></sup>, an ordering of cells (principal points) is obtained through a depth first search (DFS) of the learned principal tree starting from the root cell. We can then assign each cell to a trajectory segment, 
<inline-formula><mml:math id="M87" display="inline" overflow="scroll"><mml:msub><mml:mi>b</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>π</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula> which specifies the segment 
<inline-formula><mml:math id="M88" display="inline" overflow="scroll"><mml:msub><mml:mi>b</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> by where the cell 
<inline-formula><mml:math id="M89" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula> is located based on the ordering list, 
<inline-formula><mml:math id="M90" display="inline" overflow="scroll"><mml:mi>π</mml:mi></mml:math></inline-formula>, and the graph structure, 
<inline-formula><mml:math id="M91" display="inline" overflow="scroll"><mml:mi>G</mml:mi></mml:math></inline-formula>. We set 
<inline-formula><mml:math id="M92" display="inline" overflow="scroll"><mml:msub><mml:mi>b</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> at the root cell and increase a segment counter 
<inline-formula><mml:math id="M93" display="inline" overflow="scroll"><mml:msub><mml:mi>b</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> every time we reach a new branch point. More formally, we can write the formula of segment assignment as:
<disp-formula id="FD7"><mml:math id="M94" display="block" overflow="scroll"><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">x</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mi mathcolor="#44546A">G</mml:mi><mml:mo mathcolor="#44546A">,</mml:mo><mml:mi mathcolor="#44546A">π</mml:mi><mml:mo mathcolor="#44546A">,</mml:mo><mml:mi mathcolor="#44546A">i</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">=</mml:mo><mml:mo mathcolor="#44546A">{</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn mathcolor="#44546A">1</mml:mn><mml:mo mathcolor="#44546A">,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A" mathvariant="italic">max</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">x</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mi mathcolor="#44546A">G</mml:mi><mml:mo mathcolor="#44546A">,</mml:mo><mml:mi mathcolor="#44546A">π</mml:mi><mml:mo mathcolor="#44546A">,</mml:mo><mml:mi mathcolor="#44546A">j</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">,</mml:mo><mml:mi mathcolor="#44546A">j</mml:mi><mml:mo mathcolor="#44546A">≼</mml:mo><mml:mi mathcolor="#44546A">i</mml:mi><mml:mo mathcolor="#44546A">,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A" mathvariant="italic">max</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">x</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mi mathcolor="#44546A">G</mml:mi><mml:mo mathcolor="#44546A">,</mml:mo><mml:mi mathcolor="#44546A">π</mml:mi><mml:mo mathcolor="#44546A">,</mml:mo><mml:mi mathcolor="#44546A">j</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">+</mml:mo><mml:mn mathcolor="#44546A">1</mml:mn><mml:mo mathcolor="#44546A">,</mml:mo><mml:mi mathcolor="#44546A">j</mml:mi><mml:mo mathcolor="#44546A">≼</mml:mo><mml:mi mathcolor="#44546A">i</mml:mi><mml:mo mathcolor="#44546A">,</mml:mo></mml:mtd></mml:mtr></mml:mtable><mml:mtable><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A" mathvariant="italic">if</mml:mi><mml:mspace width="0.2em"/><mml:mi mathcolor="#44546A">i</mml:mi><mml:mo mathcolor="#44546A">=</mml:mo><mml:mn mathcolor="#44546A">0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A" mathvariant="italic">if</mml:mi><mml:mspace width="0.2em"/><mml:mo mathcolor="#44546A">|</mml:mo><mml:mi mathcolor="#44546A">E</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:msub><mml:mi mathcolor="#44546A">G</mml:mi><mml:mi mathcolor="#44546A">j</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">|</mml:mo><mml:mo mathcolor="#44546A">≤</mml:mo><mml:mn mathcolor="#44546A">2</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A" mathvariant="italic">if</mml:mi><mml:mspace width="0.2em"/><mml:mo mathcolor="#44546A">|</mml:mo><mml:mi mathcolor="#44546A">E</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:msub><mml:mi mathcolor="#44546A">G</mml:mi><mml:mi mathcolor="#44546A">j</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">|</mml:mo><mml:mo mathcolor="#44546A">=</mml:mo><mml:mn mathcolor="#44546A">3</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>where 
<inline-formula><mml:math id="M95" display="inline" overflow="scroll"><mml:mi>j</mml:mi><mml:mo>≼</mml:mo><mml:mi>i</mml:mi></mml:math></inline-formula> represents all precedents 
<inline-formula><mml:math id="M96" display="inline" overflow="scroll"><mml:mi>j</mml:mi></mml:math></inline-formula> of 
<inline-formula><mml:math id="M97" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula> in the ordering 
<inline-formula><mml:math id="M98" display="inline" overflow="scroll"><mml:mi>π</mml:mi></mml:math></inline-formula>, 
<inline-formula><mml:math id="M99" display="inline" overflow="scroll"><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>G</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:math></inline-formula>represents the degree of cell 
<inline-formula><mml:math id="M100" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula>. T. For the general cases where the principal points is less than the cell numbers, cells will inherit the segment assignment of their nearest principal point.</p>
      <p id="P35">Similar to our previous definition of pseudotime<sup><xref rid="R1" ref-type="bibr">1</xref></sup>, Monocle 2 calculates pseudotime based on the geodesic distance of each cell to the root cells on the MST of the projection points. Define pseudotime of cell 
<inline-formula><mml:math id="M101" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula> from a branching biological process 
<inline-formula><mml:math id="M102" display="inline" overflow="scroll"><mml:mi>s</mml:mi></mml:math></inline-formula> with branches given by 
<inline-formula><mml:math id="M103" display="inline" overflow="scroll"><mml:msub><mml:mi>b</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:math></inline-formula> as 
<inline-formula><mml:math id="M104" display="inline" overflow="scroll"><mml:msub><mml:mi>φ</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>, we can calculate its pseudotime recursively by adding the pseudotime of its parent cell on the MST of the projection points (closest cell on the same branch) with the Euclidean distance, 
<inline-formula><mml:math id="M105" display="inline" overflow="scroll"><mml:msub><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Parent</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>‖</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:math></inline-formula>, between current and the parent on the MST, by setting the root cell as pseudotime 0. That is,
<disp-formula id="FD8"><mml:math id="M106" display="block" overflow="scroll"><mml:msub><mml:mi mathcolor="#44546A">φ</mml:mi><mml:mi mathcolor="#44546A">t</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">x</mml:mi></mml:msub><mml:mo mathcolor="#44546A">,</mml:mo><mml:msub><mml:mi mathcolor="#44546A">s</mml:mi><mml:mi mathcolor="#44546A">i</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">=</mml:mo><mml:mo mathcolor="#44546A">{</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn mathcolor="#44546A">0</mml:mn><mml:mo mathcolor="#44546A">,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi mathcolor="#44546A">φ</mml:mi><mml:mi mathcolor="#44546A">t</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mi mathcolor="#44546A" mathvariant="italic">Parent</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">x</mml:mi></mml:msub><mml:mo mathcolor="#44546A">,</mml:mo><mml:msub><mml:mi mathcolor="#44546A">s</mml:mi><mml:mi mathcolor="#44546A">i</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">+</mml:mo><mml:msub><mml:mrow><mml:mo>‖</mml:mo><mml:mover accent="true"><mml:mi mathcolor="#44546A">p</mml:mi><mml:mo mathcolor="#44546A">→</mml:mo></mml:mover><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">x</mml:mi></mml:msub><mml:mo mathcolor="#44546A">,</mml:mo><mml:msub><mml:mi mathcolor="#44546A">s</mml:mi><mml:mi mathcolor="#44546A">i</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">,</mml:mo><mml:mover accent="true"><mml:mi mathcolor="#44546A">p</mml:mi><mml:mo mathcolor="#44546A">→</mml:mo></mml:mover><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mi mathcolor="#44546A" mathvariant="italic">Parent</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">x</mml:mi></mml:msub><mml:mo mathcolor="#44546A">,</mml:mo><mml:msub><mml:mi mathcolor="#44546A">s</mml:mi><mml:mi mathcolor="#44546A">i</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo>‖</mml:mo></mml:mrow><mml:mn mathcolor="#44546A">2</mml:mn></mml:msub><mml:mo mathcolor="#44546A">,</mml:mo></mml:mtd></mml:mtr></mml:mtable><mml:mtable><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A" mathvariant="italic">if</mml:mi><mml:mspace width="0.2em"/><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">x</mml:mi></mml:msub><mml:mo mathcolor="#44546A">=</mml:mo><mml:mn mathcolor="#44546A">1</mml:mn><mml:mo mathcolor="#44546A">,</mml:mo><mml:mi mathcolor="#44546A">i</mml:mi><mml:mo mathcolor="#44546A">=</mml:mo><mml:mn mathcolor="#44546A">0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathcolor="#44546A" mathvariant="italic">if</mml:mi><mml:mspace width="0.2em"/><mml:mi mathcolor="#44546A">i</mml:mi><mml:mo mathcolor="#44546A">&gt;</mml:mo><mml:mn mathcolor="#44546A">0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
    </sec>
    <sec id="S10">
      <title>Assessing accuracy or robustness of pseudotime and branch assignments</title>
      <p id="P36">We assessed the accuracy and robustness of each algorithm’s pseudotime assignment against the reference ordering by two measures of correlation (Pearson’s Rho (default) and Kendall’s Tau) between their pseudotime values.</p>
      <p id="P37">We used adjusted Rand index (ARI)<sup><xref rid="R22" ref-type="bibr">22</xref></sup>, a common metric used for measuring clustering accuracy, to measure the accuracy or robustness of tree segment assignment. Given the number of common cells, denoted as 
<inline-formula><mml:math id="M107" display="inline" overflow="scroll"><mml:mi>S</mml:mi></mml:math></inline-formula>, between the reference ordering and the ordering based on an algorithm (Monocle 2, Monocle 1, DPT, Wishbone or SLICER (when available)), and corresponding trajectory segment assignments for reference ordering and ordering based on a different algorithm, 
<inline-formula><mml:math id="M108" display="inline" overflow="scroll"><mml:mi mathvariant="script">X</mml:mi></mml:math></inline-formula> and 
<inline-formula><mml:math id="M109" display="inline" overflow="scroll"><mml:mi mathvariant="script">Y</mml:mi></mml:math></inline-formula>, namely, 
<inline-formula><mml:math id="M110" display="inline" overflow="scroll"><mml:mi mathvariant="script">X</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula> and 
<inline-formula><mml:math id="M111" display="inline" overflow="scroll"><mml:mi mathvariant="script">Y</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula>. The overlap between cells from segment 
<inline-formula><mml:math id="M112" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula> (
<inline-formula><mml:math id="M113" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula>) and cells from segment 
<inline-formula><mml:math id="M114" display="inline" overflow="scroll"><mml:mi>j</mml:mi></mml:math></inline-formula> (
<inline-formula><mml:math id="M115" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:math></inline-formula>) in each of the two orderings is represented by the number 
<inline-formula><mml:math id="M116" display="inline" overflow="scroll"><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> of cells in common, i.e. 
<inline-formula><mml:math id="M117" display="inline" overflow="scroll"><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∩</mml:mo></mml:mstyle><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:math></inline-formula>. Define the number of cells with segment 
<inline-formula><mml:math id="M118" display="inline" overflow="scroll"><mml:mi>i</mml:mi></mml:math></inline-formula> from reference ordering is 
<inline-formula><mml:math id="M119" display="inline" overflow="scroll"><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>s</mml:mi></mml:munderover><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> and the number of cells with segment 
<inline-formula><mml:math id="M120" display="inline" overflow="scroll"><mml:mi>j</mml:mi></mml:math></inline-formula> from ordering based on an algorithm is 
<inline-formula><mml:math id="M121" display="inline" overflow="scroll"><mml:msub><mml:mi>b</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:msub><mml:mi>n</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>. The adjusted Rand Index is then formulated as
<disp-formula id="FD9"><mml:math id="M122" display="block" overflow="scroll"><mml:mi mathcolor="#44546A" mathvariant="italic">ARI</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mi mathvariant="script" mathcolor="#44546A">X</mml:mi><mml:mo mathcolor="#44546A">,</mml:mo><mml:mi mathvariant="script" mathcolor="#44546A">Y</mml:mi><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo mathcolor="#44546A">∑</mml:mo></mml:mstyle><mml:mi mathcolor="#44546A" mathvariant="italic">ij</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mfrac linethickness="0"><mml:msub><mml:mi mathcolor="#44546A">n</mml:mi><mml:mi mathcolor="#44546A" mathvariant="italic">ij</mml:mi></mml:msub><mml:mn mathcolor="#44546A">2</mml:mn></mml:mfrac><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">−</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">[</mml:mo><mml:msub><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo mathcolor="#44546A">∑</mml:mo></mml:mstyle><mml:mi mathcolor="#44546A">i</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mfrac linethickness="0"><mml:msub><mml:mi mathcolor="#44546A">a</mml:mi><mml:mi mathcolor="#44546A">i</mml:mi></mml:msub><mml:mn mathcolor="#44546A">2</mml:mn></mml:mfrac><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:msub><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo mathcolor="#44546A">∑</mml:mo></mml:mstyle><mml:mi mathcolor="#44546A">j</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mfrac linethickness="0"><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">j</mml:mi></mml:msub><mml:mn mathcolor="#44546A">2</mml:mn></mml:mfrac><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">]</mml:mo><mml:mo mathcolor="#44546A">/</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mfrac linethickness="0"><mml:mi mathcolor="#44546A">n</mml:mi><mml:mn mathcolor="#44546A">2</mml:mn></mml:mfrac><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo></mml:mrow><mml:mrow><mml:mfrac><mml:mn mathcolor="#44546A">1</mml:mn><mml:mn mathcolor="#44546A">2</mml:mn></mml:mfrac><mml:mo stretchy="false" mathcolor="#44546A">[</mml:mo><mml:msub><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo mathcolor="#44546A">∑</mml:mo></mml:mstyle><mml:mi mathcolor="#44546A">i</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mfrac linethickness="0"><mml:msub><mml:mi mathcolor="#44546A">a</mml:mi><mml:mi mathcolor="#44546A">i</mml:mi></mml:msub><mml:mn mathcolor="#44546A">2</mml:mn></mml:mfrac><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo mathcolor="#44546A">+</mml:mo><mml:msub><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo mathcolor="#44546A">∑</mml:mo></mml:mstyle><mml:mi mathcolor="#44546A">j</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mfrac linethickness="0"><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">j</mml:mi></mml:msub><mml:mn mathcolor="#44546A">2</mml:mn></mml:mfrac><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">]</mml:mo><mml:mo mathcolor="#44546A">−</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">[</mml:mo><mml:msub><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo mathcolor="#44546A">∑</mml:mo></mml:mstyle><mml:mi mathcolor="#44546A">i</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mfrac linethickness="0"><mml:msub><mml:mi mathcolor="#44546A">a</mml:mi><mml:mi mathcolor="#44546A">i</mml:mi></mml:msub><mml:mn mathcolor="#44546A">2</mml:mn></mml:mfrac><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:msub><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo mathcolor="#44546A">∑</mml:mo></mml:mstyle><mml:mi mathcolor="#44546A">j</mml:mi></mml:msub><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mfrac linethickness="0"><mml:msub><mml:mi mathcolor="#44546A">b</mml:mi><mml:mi mathcolor="#44546A">j</mml:mi></mml:msub><mml:mn mathcolor="#44546A">2</mml:mn></mml:mfrac><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">]</mml:mo><mml:mo mathcolor="#44546A">/</mml:mo><mml:mo stretchy="false" mathcolor="#44546A">(</mml:mo><mml:mfrac linethickness="0"><mml:mi mathcolor="#44546A">n</mml:mi><mml:mn mathcolor="#44546A">2</mml:mn></mml:mfrac><mml:mo stretchy="false" mathcolor="#44546A">)</mml:mo></mml:mrow></mml:mfrac></mml:math></disp-formula>which is a measure of the similarity between two data clusterings (or segment assignment in this case). When ARI is closer to 1, the segment assignment is more consistent between the two orderings.</p>
      <p id="P38">For calculating the accuracy of pseudotime and branch assignment of the simulation (neuron/astro-genesis) and Paul dataset, the reference ordering corresponds to the real simulation and branches assignment based on manual assessment (see <xref ref-type="supplementary-material" rid="SD1">Supplementary Notes</xref>) or the pseudotime and branch (or cell type suggested from the original study<sup><xref rid="R17" ref-type="bibr">17</xref></sup>) from the marker-based ordering (see next section).</p>
      <p id="P39">For calculating the robustness, the reference ordering is defined in the context of downsampling. We apply two different downsampling strategies. First, we downsample the full dataset, including the simulation data for neuron/astro-genesis, Paul dataset and the lung dataset, selecting 
<inline-formula><mml:math id="M123" display="inline" overflow="scroll"><mml:mn>80</mml:mn><mml:mo>%</mml:mo></mml:math></inline-formula> of the cells from the full dataset 25 times without replacement. Then we run Monocle 2, Monocle 1, DPT, and Wishbone to construct branched trajectory. SLICER was excluded from the downsampling analysis on account of its long running times and instability on occasional down-sample runs. Then we compare all pairs of downsamples by the metrics discussed above. We also progressively downsample all the full dataset over a range of increasing fractions of cells from the full dataset. Sampling is performed without replacement and three different subsets are generated for each proportion to serve as replicates. Then we run each software, including Monocle 1, Monocle 2, DPT, Wishbone, to construct branched trajectories for each fraction, which are compared to the corresponding trajectory built from the full dataset. ARI, Pearson’s Rho, Kendal’s Tau for all cases are then calculated as above.</p>
      <p id="P40">In order to assess the robustness of Monocle 2 over different parameters choices, we run Monocle 2 and sample a large range for each parameter used in DDRTree, including, Dimension, lambda, maxIter, ncenter, param:gamm, sigma while keeping other parameters as default and compare the result to the ordering obtained by running Monocle 2 with all default parameters. Pearson’s Rho and ARI are used to calculate the robustness.</p>
    </sec>
    <sec id="S11">
      <title>Comparing different algorithms to a marker-based ordering</title>
      <p id="P41">In order to test the accuracy of each trajectory reconstruction algorithm, we compared their trajec-tories to an empirical ordering based on marker genes. Relying on results from Paul et al [8], we first select <italic>Pf4, Apoe, Flt3, Cd74</italic> as CMP specific genes, <italic>Hba-a2, Car2, Cited4, Klf1</italic> as MEP specific genes and <italic>Mpo, Prg2, Prtn3, Ctsg</italic> as GMP specific genes. Following the approach of Tirosh et al [9], we then select 100 other genes with expression correlated to these marker genes to calculate a stemness score and GMP or MEP lineage score. We define cells with stemness score larger than 0 as CMP cell and any cells with positive lineage score as MEP cells and negative score as GMP cells. This grouping of cells is used for branch assignment accuracy evaluation in <xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 9</xref>. We then define the reference pseudotime for each cell as:
<disp-formula id="FD10"><mml:math id="M124" display="block" overflow="scroll"><mml:msub><mml:mi>φ</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn mathvariant="bold">0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi mathvariant="italic">Max</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo mathvariant="normal">∈</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi mathvariant="italic">CMP</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn mathvariant="bold">0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn mathvariant="bold">0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable><mml:mtable><mml:mtr><mml:mtd><mml:mi mathvariant="italic">if</mml:mi><mml:mspace width="0.2em"/><mml:mi>i</mml:mi><mml:mo mathvariant="normal">∈</mml:mo><mml:mo stretchy="false">{</mml:mo><mml:mi mathvariant="italic">CMP</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathvariant="italic">otherwise</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>where 
<inline-formula><mml:math id="M125" display="inline" overflow="scroll"><mml:mn mathvariant="bold">0</mml:mn></mml:math></inline-formula> corresponds to the origin 
<inline-formula><mml:math id="M126" display="inline" overflow="scroll"><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:math></inline-formula>
<inline-formula><mml:math id="M127" display="inline" overflow="scroll"><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> corresponds to the stemness score and 
<inline-formula><mml:math id="M128" display="inline" overflow="scroll"><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> the lineage score for the lineage to which each cell is assigned, 
<inline-formula><mml:math id="M129" display="inline" overflow="scroll"><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>⋅</mml:mo><mml:mo>,</mml:mo><mml:mo>⋅</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula>represents the Euclidean distance between two points, and 
<inline-formula><mml:math id="M130" display="inline" overflow="scroll"><mml:mo stretchy="false">{</mml:mo><mml:mi mathvariant="italic">CMP</mml:mi><mml:mo stretchy="false">}</mml:mo></mml:math></inline-formula> indicates the set of CMP cells.</p>
      <p id="P42">Pseudotime correlations were computed on the paths from the root to each fate based on the reference ordering separately and then averaged. Since the empirical ordering based on marker genes is not perfect, we also investigate the accuracy of the ordering in terms of the absolute lag-1 autocorrelation of fitted spline curve for the selected marker genes. We first select the trajectory segments corresponding to the transition from the CMP cells to either MEP or GMP cells and then fit a kinetic curve for each marker gene for each transition with a spline curve with three degree of freedom. We then calculate the the absolute lag-1 autocorrelation r, which is defined as following:
<disp-formula id="FD11"><mml:math id="M131" display="block" overflow="scroll"><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width="0.2em"/><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>∑</mml:mo></mml:mstyle><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:math></disp-formula>where 
<inline-formula><mml:math id="M132" display="inline" overflow="scroll"><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:math></inline-formula> represents the gene expression at time stamp 
<inline-formula><mml:math id="M133" display="inline" overflow="scroll"><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi></mml:math></inline-formula> is the mean expression across the pseudotime series for that gene. Higher autocorrelation value implies smoother gene expression dynamics based on the ordering. Those 300 cells are also used to calculate the accuracy of branch assignment with the branch assignment from the marker-based ordering.</p>
      <p id="P43">Although a reference ordering based on markers from literature can serve as a reasonable gold-standard, it also introduces bias in a benchmarking analysis. Algorithms that order cells based on a small set of informative genes (which include or correlate the marker genes) will likely match it better than algorithms that order cells based on all genes. We therefore explored orthogonal means of measuring accuracy of each programs ordering based on the neuron simulation data (see <xref ref-type="supplementary-material" rid="SD1">Supplementary Notes</xref>).</p>
    </sec>
    <sec id="S12">
      <title>Reconstruct complex haemopoiesis hierarchy</title>
      <p id="P44">We check the scree plot to choose ten dimension as the intrinsic dimensions to reconstruct the developmental trajectory for the Paul dataset (cells used in <xref rid="F1" ref-type="fig">Figure 1</xref> of the original study<sup><xref rid="R9" ref-type="bibr">9</xref></sup>). Five branch points and six terminal lineages (monocytes, neutrophils or eosinophil, basophils, dendritic cells, megakaryocytes, and erythrocytes) are revealed. We ordered the cells using genes Paul et al. used to cluster their data rather than the genes from dpFeature, for the sake of consistency with their clusetering analysis. Similarly, we reconstruct Olsson datasets in four dimensions. The major bifurcation between the granulocyte and monocyte branch (GMP) as well as the intricate branch between GMP and megakaryocyte/erythrocyte (Ery/Meg) are revealed. Top 1, 000 genes from dpFeature based on WT cells are used in both of the WT and full datasets. The distribution (related to confusion matrix) of percentages of cells in each cluster from the original papers over each segment (state in Monocle 2) of the principal graph are calculated and visualized in the heatmap.</p>
      <p id="P45">We applied BEAM analysis to identify genes significantly bifurcating between Ery/Meg and GMP branch on the Olsson wildtype dataset. We then calculate the instant log ratios (ILRs) of gene expression between Ery/Meg and GMP branch and find genes have mean ILR larger than 0.5. The ILRs are defined as:
<disp-formula id="FD12"><mml:math id="M134" display="block" overflow="scroll"><mml:msub><mml:mi mathvariant="italic">ILR</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">log</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:msubsup><mml:mi>Y</mml:mi><mml:mn>1</mml:mn><mml:mi>t</mml:mi></mml:msubsup><mml:msubsup><mml:mi>Y</mml:mi><mml:mn>2</mml:mn><mml:mi>t</mml:mi></mml:msubsup></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:math></disp-formula></p>
      <p id="P46">So 
<inline-formula><mml:math id="M135" display="inline" overflow="scroll"><mml:msub><mml:mi>ILR</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:math></inline-formula> is calculated as the log ratio of fitted value at interpolated pseudotime point 
<inline-formula><mml:math id="M136" display="inline" overflow="scroll"><mml:mi>t</mml:mi></mml:math></inline-formula> for the Ery/Meg lineage and that for the GMP lineage. Those genes are used to calculate the lineage score (simply calculated as average expression of those genes in each cell, same as stemness score below) for both of the Olsson and the Paul dataset which is used to color the cells in a tree plot transformed from the high dimensional principal graph (see <xref ref-type="supplementary-material" rid="SD1">Supplementary Notes</xref>). The same genes are used to create the multi-way heatmap for both of the Paul and Olsson dataset (see <italic>plot multiple_branches_heatmap</italic> function). Critical functional genes from this procedure are identified. <italic>Car1, Car2</italic> (important erythroid functional genes for reversible hydration of carbon dioxide) as well as <italic>Elane, Prtn3</italic> (important proteases hydrolyze proteins within specialized neutrophil lysosomes as well as proteins of the extracellular matrix) are randomly chosen as example for creating multi-lineage kinetic curves in both of the Olsson and Paul dataset (see <italic>plot_multiple_branches_pseudotime</italic> function).</p>
      <p id="P47">In addition, pseudotime dependent genes for the Ery/Meg and GMP branch are identified in the Olsson wildtype dataset. All genes that always have lower expression from both lineages than the average in the progenitor cells are selected. Those genes are used to calculate the stemness score for both of the Olsson and the Paul dataset which is used to color the cells in the tree plot.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material" id="S13">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="SD1">
      <label>1</label>
      <caption>
        <p id="P48">Supplementary Data 1. Zipped file for the neuron simulation data.</p>
      </caption>
      <media xlink:href="NIHMS896903-supplement-1.pdf" orientation="portrait" xlink:type="simple" id="d36e3691" position="anchor"/>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="SD2">
      <label>2</label>
      <caption>
        <p id="P49">Supplementary Data 2. Zipped file for the least action path data.</p>
      </caption>
      <media xlink:href="NIHMS896903-supplement-2.pdf" orientation="portrait" xlink:type="simple" id="d36e3698" position="anchor"/>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="SD3">
      <label>3</label>
      <caption>
        <p id="P50">Supplementary Data 3. Zipped file for the complicate tree structure.</p>
      </caption>
      <media xlink:href="NIHMS896903-supplement-3.pdf" orientation="portrait" xlink:type="simple" id="d36e3705" position="anchor"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="S14">
    <p>We thank I. Tirosh for discussion on marker-based ordering, F. Theis and F. A. Wolf for discussion on Paul et. al data analysis with DPT, and members of the Trapnell laboratory for comments on the manuscript. This work was supported by US National Institutes of Health (NIH) grant DP2 HD088158. C.T. is partly supported by a Dale. F. Frey Award for Breakthrough Scientists and an Alfred P. Sloan Foundation Research Fellowship. H. A. P. is supported by a National Science Foundation (NSF) Graduate Research Fellowship (grant: DGE-1256082).</p>
  </ack>
  <fn-group>
    <fn id="FN2" fn-type="con">
      <p>
        <bold>Author Contributions</bold>
      </p>
      <p>X.Q., Q.M., and C.T. designed and implemented Monocle 2. X.Q. performed the analysis. Y.T. and L.W. contributed to technical design. R.C. and H.P. performed testing. C.T. conceived the project. All authors wrote the manuscript.</p>
    </fn>
    <fn id="FN3">
      <p>
        <bold>Competing Final Interests Statement</bold>
      </p>
      <p>The authors declare no competing financial interests.</p>
    </fn>
    <fn id="FN4">
      <p><bold>Code availability.</bold> A version of monocle 2 (version: 2.2.0) used in this study is provided as <xref ref-type="supplementary-material" rid="SD1">Supplementary Software</xref>. The newest Monocle 2 is available through Bioconductor as well as GitHub (<ext-link ext-link-type="uri" xlink:href="https://github.com/cole-trapnell-lab/monocle-release">https://github.com/cole-trapnell-lab/monocle-release</ext-link>). DDRTree, SimplePPT, SGL-tree/L1 graph are implemented in DDRTree (version: 0.1.5), simplePPT (version 0.1.0) and L1Graph (version: 0.1.0), respectively (Available (DDRTree) or will be (simplePPT, L1Graph) available from CRAN). Density peak algorithm is available from <ext-link ext-link-type="uri" xlink:href="https://github.com/Xiaojieqiu/densityClust/tree/knn_dp">https://github.com/Xiaojieqiu/densityClust/tree/knn_dp</ext-link> (densityClust: version 0.3). All those packages are included in <xref ref-type="supplementary-material" rid="SD1">Supplementary Software</xref>, which also includes a helper package, xacHelper, containing helper functions as well as all other analysis code that can be used to reproduce all figures and data in this study. Jupyter notebooks for reproducing analysis related Olsson and Paul datasets are included in <xref ref-type="supplementary-material" rid="SD1">Supplementary Software</xref> too. In addition, we deposited the same data at <ext-link ext-link-type="uri" xlink:href="https://github.com/cole-trapnell-lab/monocle2-rge-paper">https://github.com/cole-trapnell-lab/monocle2-rge-paper</ext-link>.</p>
    </fn>
    <fn id="FN5">
      <p><bold>Data availability.</bold> Four public sc RNA-seq data sets are used in this study. HSMM dataset: GSE52529<sup><xref rid="R1" ref-type="bibr">1</xref></sup>; Lung dataset: GSE52583<sup><xref rid="R7" ref-type="bibr">7</xref></sup>; Paul et. al dataset<sup><xref rid="R9" ref-type="bibr">9</xref></sup> : <ext-link ext-link-type="uri" xlink:href="http://compgenomics.weizmann.ac.il/tanay/?page">http://compgenomics.weizmann.ac.il/tanay/?page</ext-link> id=649. Olsson dataset<sup><xref rid="R8" ref-type="bibr">8</xref></sup>: synapse id <underline>syn4975060</underline>. Data for neuron simulation, results of least action paths as well as the complicate tree structure are included as <xref ref-type="supplementary-material" rid="SD1">Supplementary Data 1, 2, 3</xref>, respectively.</p>
    </fn>
  </fn-group>
  <ref-list>
    <ref id="R1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells</article-title>
        <source>Nat Biotechnol</source>
        <volume>32</volume>
        <fpage>381</fpage>
        <lpage>386</lpage>
        <year>2014</year>
        <pub-id pub-id-type="pmid">24658644</pub-id>
      </element-citation>
    </ref>
    <ref id="R2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kumar</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Tan</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Cahan</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Understanding development and stem cells using single cell-based analyses of gene expression</article-title>
        <source>Development</source>
        <volume>144</volume>
        <fpage>17</fpage>
        <lpage>32</lpage>
        <year>2017</year>
        <pub-id pub-id-type="pmid">28049689</pub-id>
      </element-citation>
    </ref>
    <ref id="R3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Setty</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Wishbone identifies bifurcating developmental trajectories from single-cell data</article-title>
        <source>Nat Biotechnol</source>
        <volume>34</volume>
        <fpage>637</fpage>
        <lpage>645</lpage>
        <year>2016</year>
        <pub-id pub-id-type="pmid">27136076</pub-id>
      </element-citation>
    </ref>
    <ref id="R4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Haghverdi</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Büttner</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Wolf</surname>
            <given-names>FA</given-names>
          </name>
          <name>
            <surname>Buettner</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Theis</surname>
            <given-names>FJ</given-names>
          </name>
        </person-group>
        <article-title>Diffusion pseudotime robustly reconstructs lineage branching</article-title>
        <source>Nat Methods</source>
        <volume>13</volume>
        <fpage>845</fpage>
        <lpage>848</lpage>
        <year>2016</year>
        <pub-id pub-id-type="pmid">27571553</pub-id>
      </element-citation>
    </ref>
    <ref id="R5">
      <label>5</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Mao</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Goodison</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Sun</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>Dimensionality Reduction Via Graph Structure Learning</article-title>
        <source>Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</source>
        <fpage>765</fpage>
        <lpage>774</lpage>
        <publisher-name>ACM</publisher-name>
        <year>2015</year>
      </element-citation>
    </ref>
    <ref id="R6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mao</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Tsang</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Sun</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>Principal Graph and Structure Learning Based on Reversed Graph Embedding</article-title>
        <source>IEEE Trans Pattern Anal Mach Intell</source>
        <year>2016</year>
        <pub-id pub-id-type="doi">10.1109/TPAMI.2016.2635657</pub-id>
      </element-citation>
    </ref>
    <ref id="R7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Treutlein</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Reconstructing lineage hierarchies of the distal lung epithelium using single-cell RNA-seq</article-title>
        <source>Nature</source>
        <volume>509</volume>
        <fpage>371</fpage>
        <lpage>375</lpage>
        <year>2014</year>
        <pub-id pub-id-type="pmid">24739965</pub-id>
      </element-citation>
    </ref>
    <ref id="R8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Olsson</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Single-cell analysis of mixed-lineage states leading to a binary cell fate choice</article-title>
        <source>Nature</source>
        <volume>537</volume>
        <fpage>698</fpage>
        <lpage>702</lpage>
        <year>2016</year>
        <pub-id pub-id-type="pmid">27580035</pub-id>
      </element-citation>
    </ref>
    <ref id="R9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Paul</surname>
            <given-names>F</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Transcriptional Heterogeneity and Lineage Commitment in Myeloid Progenitors</article-title>
        <source>Cell</source>
        <volume>163</volume>
        <fpage>1663</fpage>
        <lpage>1677</lpage>
        <year>2015</year>
        <pub-id pub-id-type="pmid">26627738</pub-id>
      </element-citation>
    </ref>
    <ref id="R10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hastie</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Stuetzle</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Principal Curves</article-title>
        <source>J Am Stat Assoc</source>
        <volume>84</volume>
        <fpage>502</fpage>
        <lpage>516</lpage>
        <year>1989</year>
      </element-citation>
    </ref>
    <ref id="R11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gorban</surname>
            <given-names>AN</given-names>
          </name>
          <name>
            <surname>Zinovyev</surname>
            <given-names>AY</given-names>
          </name>
        </person-group>
        <article-title>Principal graphs and manifolds</article-title>
        <source>Handbook of Research on Machine Learning Applications and Trends: Algorithms, Methods and Techniques</source>
        <fpage>28</fpage>
        <lpage>59</lpage>
        <year>2009</year>
      </element-citation>
    </ref>
    <ref id="R12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bellman</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>The theory of dynamic programming</article-title>
        <source>DTIC Document</source>
        <year>1954</year>
      </element-citation>
    </ref>
    <ref id="R13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Welch</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>Hartemink</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Prins</surname>
            <given-names>JF</given-names>
          </name>
        </person-group>
        <article-title>SLICER: inferring branched, nonlinearcellular trajectories from single cell RNA-seq data</article-title>
        <source>Genome Biol</source>
        <volume>17</volume>
        <fpage>106</fpage>
        <year>2016</year>
        <pub-id pub-id-type="pmid">27215581</pub-id>
      </element-citation>
    </ref>
    <ref id="R14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Qiu</surname>
            <given-names>X</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Single-cell mRNA quantification and differential analysis with Census</article-title>
        <source>Nat Methods</source>
        <year>2017</year>
        <pub-id pub-id-type="doi">10.1038/nmeth.4150</pub-id>
      </element-citation>
    </ref>
    <ref id="R15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Qiu</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Ding</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Shi</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>From understanding the development landscape of the canonical fate-switch pair to constructing a dynamic landscape for two-step neural differentiation</article-title>
        <source>PLoS One</source>
        <volume>7</volume>
        <fpage>e49271</fpage>
        <year>2012</year>
        <pub-id pub-id-type="pmid">23300518</pub-id>
      </element-citation>
    </ref>
    <ref id="R16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tang</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Yuan</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Ao</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <source>Potential landscape of high dimensional nonlinear stochastic dynamics and rare transitions with large noise</source>
        <comment>arXiv [cond-mat.stat-mech]</comment>
        <year>2016</year>
      </element-citation>
    </ref>
    <ref id="R17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tirosh</surname>
            <given-names>I</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Single-cell RNA-seq supports a developmental hierarchy in human oligodendroglioma</article-title>
        <source>Nature</source>
        <volume>539</volume>
        <fpage>309</fpage>
        <lpage>313</lpage>
        <year>2016</year>
        <pub-id pub-id-type="pmid">27806376</pub-id>
      </element-citation>
    </ref>
    <ref id="R18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cusanovich</surname>
            <given-names>DA</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Multiplex single cell profiling of chromatin accessibility by combinatorial cellular indexing</article-title>
        <source>Science</source>
        <volume>348</volume>
        <fpage>910</fpage>
        <lpage>914</lpage>
        <year>2015</year>
        <pub-id pub-id-type="pmid">25953818</pub-id>
      </element-citation>
    </ref>
    <ref id="R19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ramani</surname>
            <given-names>V</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Massively multiplex single-cell Hi-C</article-title>
        <source>Nat Methods</source>
        <year>2017</year>
        <pub-id pub-id-type="doi">10.1038/nmeth.4155cc</pub-id>
      </element-citation>
    </ref>
    <ref id="R20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mao</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Goodison</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Sun</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>SimplePPT: A Simple Principal Tree Algorithm</article-title>
        <source>Proceedings of the 2015 SIAM International Conference on Data Mining</source>
        <fpage>792</fpage>
        <lpage>800</lpage>
      </element-citation>
    </ref>
    <ref id="R21">
      <label>21</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Boyd</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Vandenberghe</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <source>Convex Optimization en</source>
        <publisher-name>Cambridge University Press</publisher-name>
        <comment>25 03</comment>
        <year>2004</year>
      </element-citation>
    </ref>
    <ref id="R22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rand</surname>
            <given-names>WM</given-names>
          </name>
        </person-group>
        <article-title>Objective Criteria for the Evaluation of Clustering Methods</article-title>
        <source>J Am Stat Assoc</source>
        <volume>66</volume>
        <fpage>846</fpage>
        <lpage>850</lpage>
        <year>1971</year>
      </element-citation>
    </ref>
  </ref-list>
</back>
<floats-group>
  <fig id="F1" orientation="portrait" position="float">
    <label>Figure 1</label>
    <caption>
      <title>Monocle 2 discovers a cryptic alternative outcome in myoblast differentiation</title>
      <p>(<bold>A</bold>) Monocle 2 learns single-cell trajectories by reversed graph embedding. Each cell can be represented as a point in a high-dimensional space where each dimension corresponds to the expression level of an ordering gene. The high dimensional data are first projected to a lower dimensional space (Z) by any of several dimension reduction methods such as PCA (default), diffusion maps, etc. Monocle 2 then constructs a spanning tree on an automatically selected set of centroids of the data. The number of centroids (black diamonds) is determined using a formula that scales sublinearly in the number of cells. These centroids are chosen automatically using k-medoids clustering in the initialized low-dimensional space. The algorithm then moves the cells towards their nearest vertex of the tree, updates the positions of the vertices to “fit” the cells, learns a new spanning tree, and iteratively continues this process until the tree and the positions of the cells have converged (see <xref ref-type="disp-formula" rid="FD3">Equation 3</xref> in <bold>Methods</bold>). Throughout this process, Monocle 2 maintains an invertible map between the high-dimensional space and the low-dimensional one, thus both learning the trajectory and reducing the dimensionality of the data. In effect, the algorithm acts as soft K-means clustering on points Z that maps them to the centroids, and jointly learns a graph on the centroids. Once Monocle 2 learns the tree, the user selects a tip as the “root”. Each cell’s pseudotime is calculated as its geodesic distance along the tree to the root, and its branch is automatically assigned based on the principal graph. (<bold>B</bold>) Monocle 1 reconstructs a linear trajectory for differentiating human skeletal myoblasts (HSMM)<sup><xref rid="R1" ref-type="bibr">1</xref></sup>. (<bold>C</bold>) Monocle 2 automatically learns the underlying trajectory and detects that cells from 24–72 hours are divided into two branches. The same genes selected with dpFeature (<xref ref-type="supplementary-material" rid="SD1">Supplementary Figure 1</xref>; Methods) were used for ordering for both of Monocle 1 and Monocle 2. (<bold>D</bold>) Accuracy of pseudotime calculation or branch assignments from each algorithm under repeated subsamples of 80% of the cells on the Paul dataset<sup><xref rid="R9" ref-type="bibr">9</xref></sup>. A marker based ordering (see <bold>Methods</bold>) is used as ground truth for results from each software in all downsamplings to compare with. (<bold>E</bold>) Consistency of pseudotime calculation or branch assignments from each algorithm under repeated subsamples of 80% of the cells on the Paul dataset<sup><xref rid="R9" ref-type="bibr">9</xref></sup>. All pairwise downsamplings are used to calculate the Pearson’s Rho and adjusted Rand index (ARI). Monocle 2, DPT, and Wishbone all use the full dataset for benchmark while Monocle 1 only uses a random downsampled 300 cells as for benchmarking.</p>
    </caption>
    <graphic xlink:href="nihms896903f1"/>
  </fig>
  <fig id="F2" orientation="portrait" position="float">
    <label>Figure 2</label>
    <caption>
      <title>Genetic perturbations divert cells to alternative outcomes in Monocle 2 trajectories</title>
      <p>(<bold>A</bold>) Monocle 2 trajectory of differentiating blood cells collected by Olsson et al<sup><xref rid="R8" ref-type="bibr">8</xref></sup>. Each subpanel corresponds to cells collected from a particular FACS gate in the experiment. Cells are colored according to their classification by the authors of the original study. (<bold>B</bold>) Cells with a single knockout of Irf8 or Gfi1 are diverted into the alternative granulocyte or monocyte branch, respectively. Double knockout cells are localized to both granulocyte and monocyte branches but concentrated near the branch point. Two branch points are identified, one that divides the erythroid or megakaryocyte outcome (F<sub>E</sub>) from the granulocyte/monocyte progenitors (GMP), which then branches to the monocyte (F<sub>M</sub>) and granulocyte (F<sub>G</sub>) outcomes. All trajectories are reconstructed in four dimensions selected based variance explained by each PCA but rendered in two dimensions using 
<monospace>layout_as_tree()</monospace> from the igraph package.</p>
    </caption>
    <graphic xlink:href="nihms896903f2"/>
  </fig>
</floats-group>
