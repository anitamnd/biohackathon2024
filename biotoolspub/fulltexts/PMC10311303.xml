<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311303</article-id>
    <article-id pub-id-type="pmid">37387146</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad268</article-id>
    <article-id pub-id-type="publisher-id">btad268</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A multilocus approach for accurate variant calling in low-copy repeats using whole-genome sequencing</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-7469-6651</contrib-id>
        <name>
          <surname>Prodanov</surname>
          <given-names>Timofey</given-names>
        </name>
        <aff><institution>Bioinformatics and Systems Biology Graduate Program, University of California San Diego</institution>, La Jolla, CA 92093, <country country="US">United States</country></aff>
        <aff><institution>Institute for Medical Biometry and Bioinformatics, Medical Faculty, Heinrich Heine University</institution>, Düsseldorf 40225, <country country="DE">Germany</country></aff>
        <aff><institution>Center for Digital Medicine, Heinrich Heine University</institution>, Düsseldorf 40225, <country country="DE">Germany</country></aff>
        <xref rid="btad268-cor1" ref-type="corresp"/>
        <!--timofey.prodanov@hhu.de-->
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-6684-5335</contrib-id>
        <name>
          <surname>Bansal</surname>
          <given-names>Vikas</given-names>
        </name>
        <aff><institution>School of Medicine, University of California San Diego</institution>, La Jolla, CA 92093, <country country="US">United States</country></aff>
        <xref rid="btad268-cor1" ref-type="corresp"/>
        <!--vibansal@ucsd.edu-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad268-cor1">Corresponding authors. Institute for Medical Biometry and Bioinformatics, Medical Faculty, Heinrich Heine University, Düsseldorf 40225, Germany. E-mail: <email>timofey.prodanov@hhu.de</email> (T.P.); Bioinformatics and Systems Biology Graduate Program, University of California San Diego, La Jolla, CA 92093, USA. E-mail: <email>vibansal@ucsd.edu</email> (V.B.).</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i279</fpage>
    <lpage>i287</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad268.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Low-copy repeats (LCRs) or segmental duplications are long segments of duplicated DNA that cover <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mo>&gt;</mml:mo></mml:math></inline-formula> 5% of the human genome. Existing tools for variant calling using short reads exhibit low accuracy in LCRs due to ambiguity in read mapping and extensive copy number variation. Variants in more than 150 genes overlapping LCRs are associated with risk for human diseases.</p>
      </sec>
      <sec id="s2">
        <title>Methods</title>
        <p>We describe a short-read variant calling method, ParascopyVC, that performs variant calling jointly across all repeat copies and utilizes reads independent of mapping quality in LCRs. To identify candidate variants, ParascopyVC aggregates reads mapped to different repeat copies and performs polyploid variant calling. Subsequently, paralogous sequence variants that can differentiate repeat copies are identified using population data and used for estimating the genotype of variants for each repeat copy.</p>
      </sec>
      <sec id="s3">
        <title>Results</title>
        <p>On simulated whole-genome sequence data, ParascopyVC achieved higher precision (0.997) and recall (0.807) than three state-of-the-art variant callers (best precision = 0.956 for DeepVariant and best recall = 0.738 for GATK) in 167 LCR regions. Benchmarking of ParascopyVC using the genome-in-a-bottle high-confidence variant calls for HG002 genome showed that it achieved a very high precision of 0.991 and a high recall of 0.909 across LCR regions, significantly better than FreeBayes (precision = 0.954 and recall = 0.822), GATK (precision = 0.888 and recall = 0.873) and DeepVariant (precision = 0.983 and recall = 0.861). ParascopyVC demonstrated a consistently higher accuracy (mean <italic toggle="yes">F</italic><sub>1</sub> = 0.947) than other callers (best <italic toggle="yes">F</italic><sub>1</sub> = 0.908) across seven human genomes.</p>
      </sec>
      <sec id="s4">
        <title>Availability and implementation</title>
        <p>ParascopyVC is implemented in Python and is freely available at <ext-link xlink:href="https://github.com/tprodanov/ParascopyVC" ext-link-type="uri">https://github.com/tprodanov/ParascopyVC</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Human Genome Research Institute</institution>
            <institution-id institution-id-type="DOI">10.13039/100000051</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>NIH</institution>
            <institution-id institution-id-type="DOI">10.13039/100000002</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>R01HG010149</award-id>
        <award-id>R01HG010759</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Advances in DNA sequencing technologies have transformed the ability to sequence genomes, particularly human genomes. Accurate variant calling is of crucial importance for virtually all applications of high-throughput DNA sequencing including disease genetics and cancer. Small variants such as single nucleotide variants (SNVs) and short indels represent the most abundant type of variants in human genomes and a number of methods (e.g. Samtools, FreeBayes, GATK) have been developed to call such variants from DNA sequence data (<xref rid="btad268-B10" ref-type="bibr">DePristo et al. 2011</xref>; <xref rid="btad268-B21" ref-type="bibr">Li 2011</xref>; <xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>; <xref rid="btad268-B17" ref-type="bibr">Kim et al. 2018</xref>; <xref rid="btad268-B28" ref-type="bibr">Poplin et al. 2018a</xref>). Most of these methods leverage statistical techniques to discriminate true genetic variants from artifacts due to errors in reads and exhibit high accuracy in unique regions of the human genome that are callable using short reads. The Genome-in-a-Bottle Consortium (GIAB) has developed benchmark sets for small variants across seven genomes that are useful for benchmarking and optimizing variant calling methods (<xref rid="btad268-B36" ref-type="bibr">Zook et al. 2014</xref>, <xref rid="btad268-B37" ref-type="bibr">2016</xref>, <xref rid="btad268-B38" ref-type="bibr">2019</xref>).</p>
    <p>However, a significant portion of the human genome is repetitive (<xref rid="btad268-B32" ref-type="bibr">Treangen and Salzberg, 2011</xref>) and remains challenging for variant calling using short read sequencing. In particular, segmental duplications—also known as low-copy repeats—that have been estimated to cover <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mo>∼</mml:mo></mml:math></inline-formula>5% of the human genome (<xref rid="btad268-B2" ref-type="bibr">Bailey et al. 2002</xref>), are problematic for variant calling due to ambiguity in read mapping (<xref rid="btad268-B18" ref-type="bibr">Koboldt 2020</xref>). Recent analysis of segmental duplications in a complete human genome (T2T-CHM13) has revealed that such repeats cover an estimated 7% of the genome (<xref rid="btad268-B33" ref-type="bibr">Vollger et al. 2022</xref>). Short reads derived from such regions align to multiple locations and are assigned low mapping quality scores by mapping tools (<xref rid="btad268-B24" ref-type="bibr">Li and Durbin 2009</xref>; <xref rid="btad268-B23" ref-type="bibr">Li 2018</xref>). Such reads are typically discarded during variant calling to avoid false-positive variant calls (<xref rid="btad268-B10" ref-type="bibr">DePristo et al. 2011</xref>; <xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>) resulting in low sensitivity. Until recently, the GIAB benchmark calls excluded most of these low-copy repeat (LCR) regions due to the difficulty in accurate variant calling. As a result, the SNV concordance of two state-of-the-art variant callers was observed to be 99.7% within GIAB high-confidence regions compared to 76.5% outside (<xref rid="btad268-B19" ref-type="bibr">Krusche et al. 2019</xref>).</p>
    <p>LCRs overlap hundreds of protein-coding genes (<xref rid="btad268-B2" ref-type="bibr">Bailey et al. 2002</xref>) in the human genome. A recent analysis of sequence homology for coding regions in the human genome identified 7691 exons in 1168 genes, which have partial or complete sequence homology (<inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>98</mml:mn></mml:mrow></mml:math></inline-formula>%) to one or more loci (<xref rid="btad268-B26" ref-type="bibr">Mandelker et al. 2016</xref>). Copy number and sequence variants in 193 of these 1168 genes are associated with rare Mendelian disorders, inherited cancers and complex diseases. Therefore, improving the accuracy of variant calling in LCRs has great clinical importance. One well-studied example of a disease-associated gene that overlaps a LCR is the <italic toggle="yes">SMN1</italic> gene—mutations in this gene cause spinal muscular atrophy, a severe childhood disease. <italic toggle="yes">SMN1</italic> is entirely duplicated and has close to 99.9% sequence similarity with its homologous gene <italic toggle="yes">SMN2</italic> (<xref rid="btad268-B20" ref-type="bibr">Lefebvre et al. 1995</xref>). Furthermore, <italic toggle="yes">SMN1/2</italic> is prone to frequent copy number changes which further complicates the task of small variant calling (<xref rid="btad268-B4" ref-type="bibr">Chen et al. 2020</xref>; <xref rid="btad268-B25" ref-type="bibr">Lopez-Lopez et al. 2020</xref>).</p>
    <p>Sequence differences between the different repeat copies of an LCR are commonly referred to as paralogous sequence variants (PSVs). PSVs represent the only source of information to differentiate between repeat copies of a LCR and read mappers implicitly use PSVs to map reads in LCRs. However, not all PSVs represent fixed differences between repeat copies and many correspond to common variants (<xref rid="btad268-B31" ref-type="bibr">Sudmant et al. 2010</xref>; <xref rid="btad268-B27" ref-type="bibr">Mueller et al. 2013</xref>). For example, the reference human genome sequence for the <italic toggle="yes">SMN1</italic> gene differs from <italic toggle="yes">SMN2</italic> gene at 24 positions across 28 kb of DNA sequence (sequence similarity <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0.999</mml:mn></mml:mrow></mml:math></inline-formula>), but only 8 of these 24 positions correspond to fixed differences in human populations (<xref rid="btad268-B4" ref-type="bibr">Chen et al. 2020</xref>). A similar phenomenon has been observed for another disease-associated gene, <italic toggle="yes">PMS2</italic>, that frequently exchanges DNA sequence with its nearby pseudogene, <italic toggle="yes">PMS2CL</italic>, making it difficult to distinguish between the two repeat copies (<xref rid="btad268-B7" ref-type="bibr">Clendenning et al. 2006</xref>; <xref rid="btad268-B13" ref-type="bibr">Gould et al. 2018</xref>). Using polymorphic PSVs for mapping reads in LCRs can result in incorrect read mapping and reduce the accuracy of variant calling. We have recently developed a probabilistic method for estimating the paralog-specific copy number of genes at LCRs that also estimates the reference allele frequencies at PSVs (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>) using population data. Our analysis of 2500 genomes from the 1000 Genomes Project (<xref rid="btad268-B1" ref-type="bibr">1000 Genomes Project Consortium et al. 2015</xref>) showed that the frequency of PSVs that represent fixed or almost fixed differences between repeat copies varies widely across LCR loci and also across populations at the same locus (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>).</p>
    <p>All state-of-the-art variant calling methods are designed to analyze genomic regions individually and discard or downweight reads with low mapping quality. In LCRs, a significant fraction of reads can be mapped to the incorrect location or have zero mapping quality. Therefore, variant calling on each repeat copy individually cannot achieve high precision and recall. For high accuracy, joint analysis of reads mapped to all homologous repeat copies is necessary. This strategy has proven to be successful in estimating copy number with high accuracy at LCR loci (<xref rid="btad268-B31" ref-type="bibr">Sudmant et al. 2010</xref>; <xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>). Several approaches that re-map reads to a single copy of the repeat (and mask out other copies before read mapping) and perform variant calling with higher ploidy (<xref rid="btad268-B8" ref-type="bibr">Cummings et al. 2017</xref>; <xref rid="btad268-B13" ref-type="bibr">Gould et al. 2018</xref>; <xref rid="btad268-B3" ref-type="bibr">Boisson et al. 2019</xref>; <xref rid="btad268-B11" ref-type="bibr">Ebbert et al. 2019</xref>) have been developed to enable the detection of disease mutations in duplicated genes. Although this approach increases sensitivity for variant detection, it is challenging to estimate the genotypes for each variant across the different repeat copies.</p>
    <p>In this article, we describe a multilocus variant calling method, ParascopyVC, that addresses three challenges associated with variant calling in LCRs: (i) ambiguity in read mapping, (ii) presence of PSVs that are polymorphic, and (iii) presence of copy number changes. ParascopyVC combines two methodological innovations: (i) aggregating reads mapped to different repeat copies to enable highly sensitive detection of variant sites and (ii) identification of informative PSVs that can differentiate repeat copies for paralog-specific genotyping at variant sites. For variant discovery, it leverages an existing variant calling tool, FreeBayes, to jointly analyze all reads mapped to the different repeat copies. ParascopyVC uses paralog-specific copy number estimated from WGS reads using Parascopy (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>) to model the ploidy of paralog-specific genotypes. We benchmarked ParascopyVC using simulated data and whole-genome WGS data for seven human individuals, for which high-quality variant call sets in LCRs were recently published by the GIAB consortium. Our results demonstrate that ParascopyVC significantly outperforms state-of-the-art variant callers both in precision and recall in LCR regions.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>We consider a LCR region <italic toggle="yes">L</italic> with a total of <italic toggle="yes">n</italic> repeat copies (including the region <italic toggle="yes">L</italic>) in the reference genome. The input data are a set of WGS reads mapped to the reference genome (assumed to be diploid for our method). Let <italic toggle="yes">R</italic> denote the subset of reads that overlap any of the repeat copies of <italic toggle="yes">L</italic>. The goal of small variant calling is to identify positions in the regions of interest (the repeat copies) that differ from the reference and to estimate the most probable genotype for each variant. Standard variant calling tools analyze each repeat copy separately and identify variants by examining reads aligned to the reference genome. However, in LCRs, many reads are mapped ambiguously (multiple identical alignment possibilities) or even mapped to an incorrect repeat copy. This results in a large number of both false negative and false positive variant calls. To solve this problem, ParascopyVC jointly analyzes reads mapped to all repeat copies for variant discovery and genotyping.</p>
    <sec>
      <title>2.1 Definitions</title>
      <p>We introduce a set of terms and notations that will be useful for the description of ParascopyVC. Since we consider variants jointly across all repeat copies, a variant is characterized by an <italic toggle="yes">n</italic>-tuple of genomic positions (one for each repeat copy) and an allele set <italic toggle="yes">A</italic>. These “paralogous positions” can be identified using multiple sequence alignment of the reference sequence for the repeat copies (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>). In the reference genome, variant <italic toggle="yes">v</italic> exhibits allele <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> on <italic toggle="yes">i</italic>th repeat copy of the duplication. If the variant <italic toggle="yes">v</italic> is a PSV, then <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>≠</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> for some <italic toggle="yes">i</italic>, <italic toggle="yes">j</italic>. For a PSV <italic toggle="yes">v</italic>, <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the frequency of the reference allele <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> in the population on the <italic toggle="yes">i</italic>th repeat copy.</p>
      <p>Paralog-specific copy number of a sample <italic toggle="yes">s</italic> is a tuple <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">N</mml:mi></mml:mrow><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Each element of the tuple <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> stands for the number of times the <italic toggle="yes">i</italic>th repeat copy appears in the genomic sequence of the sample. Aggregate copy number <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the sum of paralog-specific copy numbers across all repeat copies. In certain cases, paralog-specific copy number values are not available for all repeat copies. In such cases, we call variants on <italic toggle="yes">extended</italic> repeat copies (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods 2.1</xref> for details).</p>
      <p>Aggregate genotype <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of a variant <italic toggle="yes">v</italic> in the sample <italic toggle="yes">s</italic> is a multiset of <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> alleles—such genotype collects variant alleles across all repeat copies without any specific order and can contain the same allele many times. A paralog-specific genotype <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is a tuple of <italic toggle="yes">n</italic> allele multisets, where the <italic toggle="yes">i</italic>th multiset contains <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> alleles. Paralog-specific genotype of a variant refers to the <italic toggle="yes">n</italic>-tuple of genotypes for the variant across the <italic toggle="yes">n</italic> repeat copies. We will use multiplicity function <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mo>μ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to denote the number of occurrences of an element <italic toggle="yes">z</italic> in the multiset <italic toggle="yes">Z</italic>.</p>
      <p>As an example, consider a two-copy LCR and a sample <italic toggle="yes">s</italic> with aggregate copy number <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> and paralog-specific copy number <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. One possible aggregate genotype of a variant <italic toggle="yes">v</italic> with two alleles <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> would be <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>G</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula> and one possible paralog-specific genotype would be <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>G</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Each paralog-specific genotype is associated with a single aggregate genotype, obtained by combining all multisets <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">vsi</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. A paralog-specific genotype <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is <italic toggle="yes">reference-compatible</italic>, if, for all <italic toggle="yes">i</italic>, multiset <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">vsi</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> contains only the reference allele <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>; in other words, if <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mo>μ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">vsi</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.2 Algorithm</title>
      <p>We assume that PSVs have been identified in advance using multiple sequence alignment of the reference sequences for the repeat copies. We also assume that paralog-specific and aggregate copy numbers for the repeat copies are known for the sample. Our previously developed copy number estimation tool, Parascopy (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>), identifies PSVs; estimates allele frequencies <italic toggle="yes">f</italic> for each PSV; and calculates paralog-specific copy number using WGS data. For a region <italic toggle="yes">L</italic> with <italic toggle="yes">n</italic> copies, variant calling using ParascopyVC proceeds in three steps.</p>
      <p>The first step is the identification of candidate variant sites with high sensitivity using “aggregate variant calling”. For this, we re-map reads from all repeat copies to a single copy (<italic toggle="yes">L</italic>) and use polyploid variant calling—with ploidy equal to the aggregate copy number—to call variants. Note that this re-mapping is done locally and does not involve global re-mapping of reads. This process is illustrated in <xref rid="btad268-F1" ref-type="fig">Fig. 1a</xref> for a two-copy duplication. This enables the use of all reads, regardless of mapping quality, for sensitive variant detection.</p>
      <fig position="float" id="btad268-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Illustration of multilocus variant calling approach in LCRs. The figure shows a two-copy LCR with repeat copies A (blue) and B (yellow). (a) The reads initially aligned to Copy B are remapped to Copy A for aggregate variant calling and three variants (<inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>) are identified. (b) Reference sequences of copies A and B differ at two PSVs (<inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>). Using population reference allele frequencies and aggregate genotype information, the PSV <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is determined to be informative while <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is not. Reads that overlap variant <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and the informative PSV <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> indicate that the <italic toggle="yes">G</italic> allele of variant <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is present on copy <italic toggle="yes">A</italic> (paralog-specific genotype for <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). Paralog-specific genotype for variant <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is not inferred due to the lack of an informative PSV.</p>
        </caption>
        <graphic xlink:href="btad268f1" position="float"/>
      </fig>
      <p>Second, we “identify informative PSVs”—PSVs whose paralog-specific genotypes are identical to the reference for the sample. For each variant <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, we estimate the most likely aggregate genotype <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> using the aggregated reads independent of other variants. For PSVs, we calculate paralog-specific genotype probabilities based on the aggregate genotype likelihoods and by using reference allele frequencies <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in order to calculate paralog-specific genotype priors. PSVs with reference-compatible paralog genotypes are marked as <italic toggle="yes">informative</italic>. In the example shown in <xref rid="btad268-F1" ref-type="fig">Fig. 1b</xref>, PSV <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is informative (paralog-specific genotype = <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>/</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, same as reference), while PSV <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is not.</p>
      <p>The third and final step in ParascopyVC is “paralog-specific genotyping” of all variants using informative PSVs and paired reads that overlap both informative PSVs and variants. For variant <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> in <xref rid="btad268-F1" ref-type="fig">Fig. 1b</xref>, the most-likely aggregate genotype is <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:math></inline-formula>. Hence, there are two possible paralog-specific genotypes: <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for this variant. Since there are reads that overlap both PSV <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and variant <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> have the alleles <italic toggle="yes">G</italic> and <italic toggle="yes">T</italic> at the two sites respectively, we can estimate the paralog-specific genotypes for <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> to be <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Note that paralog-specific genotypes cannot be estimated for variants that are not covered by reads that also overlap informative PSVs, e.g. variant <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> in <xref rid="btad268-F1" ref-type="fig">Fig. 1b</xref>.</p>
      <p>Next, we describe the mathematical details of the three steps of the algorithm.</p>
    </sec>
    <sec>
      <title>2.3 Step 1: aggregate variant calling</title>
      <p>During its first stage, the copy number estimation method Parascopy (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>) identifies regions homologous to <italic toggle="yes">L</italic> using a pre-computed homology table and re-maps reads from them back to <italic toggle="yes">L</italic>. Our variant calling method, ParascopyVC, uses this same approach to re-map reads and then runs an existing variant calling tool FreeBayes (<xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>) on the pooled reads with ploidy <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We modify the resulting set of aggregate variants by removing all variants with low quality (<inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>), and by extending the set to include all PSVs. For each variant <italic toggle="yes">v</italic>, we calculate the allelic read depth <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> across the variant alleles <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in the pooled reads <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> overlapping the variant. The aggregate genotype probabilities are calculated using <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the multinomial distribution (MN) as follows:
and where <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula> is the error rate, <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the full set of alleles, <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>r</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is mean read length, <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>a</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is the allele length, and <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mo>μ</mml:mo></mml:math></inline-formula> is the multiplicity function. The calculations are consistent with the polyploid genotype likelihood calculations used in FreeBayes (<xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>). Finally, we use Bayes’ theorem to get the aggregate genotype probability:
</p>
      <disp-formula id="E1">
        <label>(1)</label>
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>P</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>X</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo> </mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>g</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>P</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mtext>MN</mml:mtext>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>X</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>;</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="fraktur">p</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>a</mml:mi>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>g</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:mo>…</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:mi mathvariant="fraktur">p</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>a</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mo>|</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>A</mml:mi>
                  </mml:mrow>
                  <mml:mi>v</mml:mi>
                </mml:msub>
                <mml:mo>|</mml:mo>
              </mml:mrow>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>g</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E2">
        <label>(2)</label>
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtext>where</mml:mtext>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="fraktur">p</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>a</mml:mi>
            <mml:mo>,</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mrow>
              <mml:mover accent="true">
                <mml:mi>g</mml:mi>
                <mml:mo>^</mml:mo>
              </mml:mover>
            </mml:mrow>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>r</mml:mi>
                    <mml:mo>¯</mml:mo>
                  </mml:mover>
                </mml:mrow>
                <mml:mo>|</mml:mo>
                <mml:mo>−</mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mi>a</mml:mi>
                <mml:mo>|</mml:mo>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>⋅</mml:mo>
                <mml:mi>max</mml:mi>
                <mml:mrow>
                  <mml:mo>{</mml:mo>
                  <mml:mrow>
                    <mml:mo>ϵ</mml:mo>
                    <mml:mo>⋅</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>c</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:mo>μ</mml:mo>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>a</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                      </mml:mrow>
                      <mml:mo>′</mml:mo>
                    </mml:msup>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>A</mml:mi>
                      </mml:mrow>
                      <mml:mi>v</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mi>r</mml:mi>
                      <mml:mo>¯</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mo>|</mml:mo>
                  <mml:mo>−</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                    </mml:mrow>
                    <mml:mo>′</mml:mo>
                  </mml:msup>
                  <mml:mo>|</mml:mo>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>⋅</mml:mo>
                <mml:mi>max</mml:mi>
                <mml:mrow>
                  <mml:mo>{</mml:mo>
                  <mml:mrow>
                    <mml:mo>ϵ</mml:mo>
                    <mml:mo>⋅</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>c</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:mo>μ</mml:mo>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                      </mml:mrow>
                      <mml:mo>′</mml:mo>
                    </mml:msup>
                    <mml:mo>,</mml:mo>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
              </mml:mrow>
            </mml:mfrac>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E3">
        <label>(3)</label>
        <mml:math id="M3" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>P</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>g</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo> </mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>X</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:mi>p</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>⋅</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>X</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>g</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>′</mml:mo>
                    </mml:msup>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>G</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>p</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo>′</mml:mo>
                </mml:msup>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>⋅</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>X</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo>′</mml:mo>
                </mml:msup>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Note that the set of aggregate genotypes <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> depends on the set of alleles <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and aggregate copy number <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Additionally, we select equal aggregate genotype priors <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. In order to improve genotyping accuracy, allele observations with base qualities less than 10 and all partial allele observations are discarded.</p>
    </sec>
    <sec>
      <title>2.4 Step 2: identify informative PSVs</title>
      <p>For PSVs, the prior probability of paralog-specific genotypes can be obtained using the PSV reference allele frequencies <italic toggle="yes">f</italic>:
</p>
      <disp-formula id="E4">
        <label>(4)</label>
        <mml:math id="M4" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>P</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>g</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>;</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>f</mml:mi>
              </mml:mrow>
              <mml:mi>v</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munderover>
              <mml:mo>∏</mml:mo>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mi>n</mml:mi>
            </mml:munderover>
            <mml:mrow>
              <mml:msubsup>
                <mml:mrow>
                  <mml:mi>f</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>v</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo> </mml:mo>
                  <mml:mo>μ</mml:mo>
                  <mml:mrow>
                    <mml:mo>(</mml:mo>
                    <mml:mrow>
                      <mml:msubsup>
                        <mml:mrow>
                          <mml:mi>a</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>v</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                        <mml:mo>*</mml:mo>
                      </mml:msubsup>
                      <mml:mo>,</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>g</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="italic">vsi</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mo>)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
              </mml:msubsup>
            </mml:mrow>
            <mml:mo>×</mml:mo>
            <mml:msup>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>−</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>f</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>v</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mo> </mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>c</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>s</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>−</mml:mo>
                <mml:mo>μ</mml:mo>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mo>*</mml:mo>
                    </mml:msubsup>
                    <mml:mo>,</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>g</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="italic">vsi</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
            </mml:msup>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>In other words, the prior of the paralog-specific genotype <italic toggle="yes">g</italic> is a product of either <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> depending on the match between the genotype alleles and the reference alleles of the PSV <italic toggle="yes">v</italic>.</p>
      <p>For each PSV, we calculate the probability of paralog-specific genotype <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> based on the PSV allele frequencies <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the probability of its associate aggregate genotype <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>:
where <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the full set of paralog-specific genotypes associated with the aggregate genotype <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
      <disp-formula id="E5">
        <label>(5)</label>
        <mml:math id="M5" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtable>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>g</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo> </mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>X</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>;</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>f</mml:mi>
                      </mml:mrow>
                      <mml:mi>v</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>g</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo> </mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>X</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>⋅</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>g</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo> </mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>g</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>g</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo> </mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>X</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>⋅</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mi>P</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>g</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>v</mml:mi>
                            <mml:mi>s</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>;</mml:mo>
                        <mml:mo> </mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>f</mml:mi>
                          </mml:mrow>
                          <mml:mi>v</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:munder>
                          <mml:mo>∑</mml:mo>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi>g</mml:mi>
                              </mml:mrow>
                              <mml:mo>′</mml:mo>
                            </mml:msup>
                            <mml:mo>∈</mml:mo>
                            <mml:mi>G</mml:mi>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mover accent="true">
                                    <mml:mi>g</mml:mi>
                                    <mml:mo>^</mml:mo>
                                  </mml:mover>
                                </mml:mrow>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>v</mml:mi>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:munder>
                        <mml:mi>P</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>g</mml:mi>
                          </mml:mrow>
                          <mml:mo>′</mml:mo>
                        </mml:msup>
                        <mml:mo>;</mml:mo>
                        <mml:mo> </mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>f</mml:mi>
                          </mml:mrow>
                          <mml:mi>v</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mfrac>
                    <mml:mo>.</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>We say that the PSV <italic toggle="yes">v</italic> is <italic toggle="yes">informative</italic> for a sample <italic toggle="yes">s</italic> if the most likely paralog-specific genotype for sample <italic toggle="yes">s</italic> has high posterior probability (<inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0.99</mml:mn></mml:mrow></mml:math></inline-formula> by default) and is reference-compatible. Such PSVs can be used to differentiate reads originating from different repeat copies with high confidence.</p>
      <p>Filtering out noninformative PSVs:</p>
      <p>The estimation of paralog-specific genotypes for PSVs does not utilize information from read-pairs that cover more than one PSV since this greatly increases the computational complexity of the likelihood calculations. As a result, read-pairs that cover multiple informative PSVs can sometimes conflict with the reference genotype for a pair of informative PSVs. Such conflicts indicate that one of the two PSVs is not informative. For each pair of informative PSVs covered by at least three reads, we tabulate the read-allele counts for the pair and use a one-tailed Binomial test (<inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>ϵ</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>ϵ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">P</italic> value threshold of <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) to identify conflicting PSVs.</p>
      <p>Next, we construct an undirected graph on the set of informative PSVs with edges between conflicting PSVs. Then we aim to keep a subset of informative PSVs such that the remaining graph contains no edges and <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is maximal, where <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>—the minimal frequency <italic toggle="yes">f</italic> of the PSV <italic toggle="yes">v</italic> across all repeat copies. This problem is equivalent to an NP-complete weighted maximum clique problem (<xref rid="btad268-B15" ref-type="bibr">Karp 1972</xref>). Therefore, we employ the following greedy heuristic: until the graph is edgeless, we iteratively remove the PSV <italic toggle="yes">v</italic> that has the maximal number of edges multiplied by <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.5 Step 3: estimate paralog-specific genotypes</title>
      <p>For new variants, we infer paralog-specific genotypes using read-pairs that overlap the variant and an informative PSV (or, possibly, a nonduplicated region of the genome). For each read-pair <italic toggle="yes">r</italic>, we determine the set of possible read locations (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods 2.2</xref>) across all repeat copies, and then estimate read-pair location probabilities <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using the informative PSVs (denoted by <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) covered by the read pair <italic toggle="yes">r</italic>. Here, <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the probability that location <italic toggle="yes">i</italic> is the true origin of read-pair <italic toggle="yes">r</italic>. Suppose a PSV <italic toggle="yes">v</italic> has allele <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> on the <italic toggle="yes">i</italic>th repeat copy, then we assign <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to either <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mo>ϵ</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula> (error rate) depending upon whether the read sequence matches or does not match the allele <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, respectively. Location priors are estimated based on the paralog-specific copy numbers <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which results in the following formula for <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>:
</p>
      <disp-formula id="E6">
        <label>(6)</label>
        <mml:math id="M6" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>p</mml:mi>
              </mml:mrow>
              <mml:mi>r</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>c</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>s</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:munder>
                  <mml:mo>∏</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>W</mml:mi>
                      </mml:mrow>
                      <mml:mi>r</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>a</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mi>r</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:munderover>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mi>n</mml:mi>
                </mml:munderover>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:munder>
                  <mml:mo>∏</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>W</mml:mi>
                      </mml:mrow>
                      <mml:mi>r</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>a</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mi>r</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>If a PSV <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is missing from one of the repeat copies <italic toggle="yes">j</italic> because the copy is shorter than others, we penalize location probability <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by setting <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to a small number (<inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>ϵ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> by default).</p>
      <p>Finally, paralog-specific genotype probabilities are calculated according to the read-pair location probabilities <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and the read–variant allele observations. Suppose the read-pair <italic toggle="yes">r</italic> has sequence <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> aligned to the variant <italic toggle="yes">v</italic>, then we can describe the probability of read-pair <italic toggle="yes">r</italic> according to the paralog-specific genotype <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>:
</p>
      <disp-formula id="E7">
        <label>(7)</label>
        <mml:math id="M7" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>P</mml:mi>
            <mml:mo>(</mml:mo>
            <mml:mi>r</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mi>g</mml:mi>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munderover>
              <mml:mo>∑</mml:mo>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mi>n</mml:mi>
            </mml:munderover>
            <mml:mfrac>
              <mml:mrow>
                <mml:msub>
                  <mml:mi>p</mml:mi>
                  <mml:mi>r</mml:mi>
                </mml:msub>
                <mml:mo>(</mml:mo>
                <mml:mi>i</mml:mi>
                <mml:mo>)</mml:mo>
              </mml:mrow>
              <mml:msub>
                <mml:mi>c</mml:mi>
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
            </mml:mfrac>
            <mml:mo> </mml:mo>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mo>(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:mo>ϵ</mml:mo>
              <mml:mo>)</mml:mo>
              <mml:mo>⋅</mml:mo>
              <mml:mo>μ</mml:mo>
              <mml:mrow>
                <mml:mo>(</mml:mo>
                <mml:msub>
                  <mml:mi>a</mml:mi>
                  <mml:mi>r</mml:mi>
                </mml:msub>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mi>g</mml:mi>
                  <mml:mi mathvariant="italic">vsi</mml:mi>
                </mml:msub>
                <mml:mo>)</mml:mo>
              </mml:mrow>
              <mml:mo>+</mml:mo>
              <mml:mo>ϵ</mml:mo>
              <mml:mo>⋅</mml:mo>
              <mml:mo>[</mml:mo>
              <mml:msub>
                <mml:mi>c</mml:mi>
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>−</mml:mo>
              <mml:mo>μ</mml:mo>
              <mml:mrow>
                <mml:mo>(</mml:mo>
                <mml:msub>
                  <mml:mi>a</mml:mi>
                  <mml:mi>r</mml:mi>
                </mml:msub>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mi>g</mml:mi>
                  <mml:mi mathvariant="italic">vsi</mml:mi>
                </mml:msub>
                <mml:mo>)</mml:mo>
              </mml:mrow>
              <mml:mo>]</mml:mo>
              <mml:mo>)</mml:mo>
              <mml:mo>.</mml:mo>
            </mml:mrow>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Additionally, we can evaluate the probability of each genotype <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> given the set of read pairs <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that cover the variant <italic toggle="yes">v</italic>:
</p>
      <disp-formula id="E8">
        <label>(8)</label>
        <mml:math id="M8" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>P</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>g</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo> </mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>R</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:mi>p</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>⋅</mml:mo>
                <mml:munder>
                  <mml:mo>∏</mml:mo>
                  <mml:mrow>
                    <mml:mi>r</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>r</mml:mi>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mi>g</mml:mi>
                </mml:munder>
                <mml:mi>p</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>g</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>⋅</mml:mo>
                <mml:munder>
                  <mml:mo>∏</mml:mo>
                  <mml:mrow>
                    <mml:mi>r</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>r</mml:mi>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mi>g</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Paralog-specific genotype probabilities <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are later converted into genotype and variant qualities (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods 2.3</xref>). Paralog-specific genotype priors for PSVs are described in <xref rid="E4" ref-type="disp-formula">Equation (4)</xref>. For novel non-PSV variants, we define priors <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in the following way:
</p>
      <disp-formula id="E9">
        <label>(9)</label>
        <mml:math id="M9" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>p</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>g</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munderover>
              <mml:mo>∏</mml:mo>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mi>n</mml:mi>
            </mml:munderover>
            <mml:mrow>
              <mml:mrow>
                <mml:mo stretchy="true">{</mml:mo>
                <mml:mrow>
                  <mml:mtable>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mn>1</mml:mn>
                          <mml:mo>−</mml:mo>
                          <mml:mo>ξ</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mtext>if</mml:mtext>
                          <mml:mo> </mml:mo>
                          <mml:mo>μ</mml:mo>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:msubsup>
                            <mml:mrow>
                              <mml:mi>a</mml:mi>
                            </mml:mrow>
                            <mml:mi>v</mml:mi>
                            <mml:mo>*</mml:mo>
                          </mml:msubsup>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>g</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi mathvariant="italic">vsi</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>=</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>c</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>s</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo>,</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mo>ξ</mml:mo>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mtext>if</mml:mtext>
                          <mml:mo> </mml:mo>
                          <mml:mo>μ</mml:mo>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:msubsup>
                            <mml:mrow>
                              <mml:mi>a</mml:mi>
                            </mml:mrow>
                            <mml:mi>v</mml:mi>
                            <mml:mo>*</mml:mo>
                          </mml:msubsup>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>g</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi mathvariant="italic">vsi</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>≠</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>c</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>s</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo>.</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mrow>
              </mml:mrow>
            </mml:mrow>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>In other words, each repeat copy genotype <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">vsi</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is penalized by the mutation rate <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mo>ξ</mml:mo></mml:math></inline-formula> (default: <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) if nonreference allele is present, and where homozygous and heterozygous genotypes are penalized equally.</p>
      <p>To reduce the number of false positive variants due to strand-bias in sequencing data (<xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>), we apply Fisher’s exact test (FET) to the <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> table corresponding to the reads counts for the reference and nonreference alleles on the two DNA strands. Variants with a FET <italic toggle="yes">P</italic> value less than .01 are filtered out.</p>
    </sec>
    <sec>
      <title>2.6 Simulated and real WGS datasets</title>
      <p>To benchmark the accuracy of ParascopyVC, we generated two simulated WGS datasets, one with and the other without polymorphic PSVs, which we denote as SIM-Poly and SIM-Fixed, respectively. We did not simulate changes in copy number since variant callers such as DeepVariant (<xref rid="btad268-B28" ref-type="bibr">Poplin et al. 2018a</xref>)—which we used for benchmarking—only support variant calling in diploid genomes. In case of the SIM-Fixed dataset, we simulated a diploid genome by adding artificial sequence variants every one kilobase on average (80% substitutions, 10% insertions, and 10% deletions; 61.5% heterozygous variants). Rates of different variant types were selected to be similar to the variant rates in the GIAB high-confidence variant calls for the HG002 individual (<xref rid="btad268-B36" ref-type="bibr">Zook et al. 2014</xref>, <xref rid="btad268-B37" ref-type="bibr">2016</xref>, <xref rid="btad268-B38" ref-type="bibr">2019</xref>). All simulated variants overlapping PSVs were discarded.</p>
      <p>For the SIM-Poly dataset—designed to assess the accuracy of variant calling in the presence of polymorphic PSVs—we simulated WGS reads from a diploid genome with variants that overlapped PSVs. Polymorphic PSVs were simulated according to PSV reference allele frequencies (<italic toggle="yes">f</italic>) in the 503 European ancestry samples from the 1000 Genomes Project (1 kGP) (<xref rid="btad268-B1" ref-type="bibr">1000 Genomes Project Consortium et al. 2015</xref>), calculated by Parascopy <monospace>v1.7</monospace> (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>). Next, we combined the resulting variant set with the SIM-Fixed variant set to obtain <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.75</mml:mn><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> variants. Finally, for both datasets we used ART Illumina (<xref rid="btad268-B14" ref-type="bibr">Huang et al. 2012</xref>) read simulator tool <monospace>v2016-06-05</monospace> to generate two diploid paired-end datasets for chromosomes 1–22 with 150 bp reads, <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mn>30</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> coverage and mean fragment size = 500 bp. We then used BWA-MEM <monospace>v0.7.17</monospace> (<xref rid="btad268-B24" ref-type="bibr">Li and Durbin 2009</xref>; <xref rid="btad268-B22" ref-type="bibr">Li 2013</xref>) to map the simulated reads to the GRCh38 reference genome.</p>
      <p>In addition to the simulated WGS datasets, we utilized high-confidence variant call sets for seven human genomes (HG001–HG007) constructed by the GIAB Consortium (<xref rid="btad268-B36" ref-type="bibr">Zook et al. 2014</xref>, <xref rid="btad268-B37" ref-type="bibr">2016</xref>, <xref rid="btad268-B38" ref-type="bibr">2019</xref>). The latest version (v4.2.1) of these variant calls leverage long-read sequence datasets to enable accurate variant calls in repetitive regions of the genome that include a large number of LCRs (<xref rid="btad268-B34" ref-type="bibr">Wagner et al. 2022</xref>). For each individual genome, we analyzed Illumina WGS data that is also made available by the GIAB. The WGS datasets for HG005, HG006, and HG007 genomes had very high coverage (<inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>100</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula>) and were sub-sampled using samtools <monospace>v1.14</monospace> (<xref rid="btad268-B9" ref-type="bibr">Danecek et al. 2021</xref>) to obtain <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>30</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> sequence coverage. We mapped all WGS datasets to the GRCh38 reference genome using BWA-MEM <monospace>v0.7.17</monospace>. PacBio HiFi WGS data for HG002 (30-fold coverage, mapped to GRCh38) was also obtained from the GIAB.</p>
    </sec>
    <sec>
      <title>2.7 Variant calling benchmarking</title>
      <p>In order to evaluate variant calling, we utilized a set of 167 LCR loci that we previously compiled for copy number analysis (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>). These LCR loci were selected from a genome-wide analysis and each locus in this set overlaps at least one protein-coding gene. Across all repeat copies, the 167 loci span 10.95 Mb of DNA sequence and overlap 380 protein-coding genes. Three variant calling tools—FreeBayes <monospace>v1.3.5</monospace> (<xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>), GATK HaplotypeCaller <monospace>v4.2.2</monospace> (<xref rid="btad268-B29" ref-type="bibr">Poplin et al. 2018b</xref>), and DeepVariant <monospace>v1.4</monospace> (<xref rid="btad268-B28" ref-type="bibr">Poplin et al. 2018a</xref>)—were used for comparison with ParascopyVC. For the HG002 genome, we additionally benchmarked variant calling accuracy on all LCR regions from chromosomes 15, 16, and 17.</p>
      <p>We calculated precision and recall using RTG tools <monospace>v3.12.1</monospace> (<xref rid="btad268-B5" ref-type="bibr">Cleary et al. 2014</xref>, <xref rid="btad268-B6" ref-type="bibr">2015</xref>). To compare precision and recall values across different callers, we selected a single variant quality threshold for each caller separately that maximized its average accuracy across seven benchmarking WGS datasets (HG001–HG007). In LCR loci, small precision improvements are achieved at a cost of large decrease in recall; consequently, the best average <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score was obtained at very low-quality thresholds for the three existing variant callers (<inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, corresponding to virtually no filtering). Therefore, we selected optimal variant quality thresholds based on the <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mn>0.5</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> score, which favors precision over recall. These criteria produced reasonable quality thresholds of 6, 33, 5, and 21 for GATK, FreeBayes, DeepVariant, and ParascopyVC, respectively. These thresholds were used for comparing precision-recall of different methods across all evaluations.</p>
      <p>For ParascopyVC, we calculated aggregate and paralog-specific copy number profiles using Parascopy <monospace>v1.7</monospace> (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>) for each dataset (both simulated and real) prior to variant calling. For each dataset, we selected a set of paralog-specific regions that overlap the high-confidence benchmarking regions for the dataset. Additionally, we filtered out LCRs, for which paralog-specific copy number was not estimated by Parascopy (such as LCRs with five or more copies); and excluded LCRs, for which paralog-specific copy number was different than 2. For each sample, benchmarking was limited to the same regions across all variant calling methods.</p>
      <p>For running ParascopyVC on the SIM-Fixed dataset, we used PSV allele frequencies equal to 0.9999 to model the fact that PSVs were not polymorphic. For the SIM-Poly dataset, we used PSV allele frequencies obtained from the European ancestry samples in the 1000 Genomes project (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>). For the HG001–HG004 and HG005–HG007 datasets, we used PSV allele frequencies obtained from European and East-Asian ancestry samples, respectively. This was consistent with the reported ancestry of these individuals (HG001 is of European ancestry, HG002–HG004 represents an Ashkenazim trio, and HG005–HG007 represent a Han Chinese trio).</p>
      <p>To compare the runtime and memory usage for different methods, we called variants for a single individual across 167 duplicated loci. ParascopyVC uses multiple threads to analyze disjoint duplicated loci, so we tabulated run-time using 1 and 16 threads. Similarly, GATK and DeepVariant allow to use multiple threads. FreeBayes uses only one thread, although it can be externally parallelized over independent loci.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Accuracy of variant calling on simulated data</title>
      <p>For the SIM-Fixed dataset (no polymorphic PSVs), the benchmarking regions covered 9.9 Mb of DNA sequence and included 9254 ground truth variants. On this dataset, FreeBayes, GATK, and ParascopyVC had very high precision (0.997) and similar recall (0.835, 0.886, and 0.872, respectively) (see <xref rid="btad268-F2" ref-type="fig">Fig. 2a</xref>). This was not surprising since standard variant calling methods rely on accurately mapped reads and in the absence of polymorphic PSVs and copy number variation, read mapping is reliable. DeepVariant had slightly lower precision (0.995) and recall (0.815) values.</p>
      <fig position="float" id="btad268-F2">
        <label>Figure 2.</label>
        <caption>
          <p>Precision and recall of variant calling for four variant callers (GATK, FreeBayes, DeepVariant, and ParascopyVC) on two simulated WGS datasets. Variant quality thresholds used for comparing precision/recall are marked with circles on each curve. (a) Simulated dataset SIM-Fixed (all PSVs are nonpolymorphic). (b) Simulated dataset SIM-Poly (some PSVs are polymorphic). The solid (dashed) yellow line shows the precision–recall curve for ParascopyVC using PSV allele frequencies from the European (East Asian) population.</p>
        </caption>
        <graphic xlink:href="btad268f2" position="float"/>
      </fig>
      <p>On the SIM-Poly dataset (18 997 baseline variants) that included polymorphic PSVs, the accuracy of state-of-the-art variant callers was drastically lower than for the SIM-Fixed dataset. GATK, FreeBayes, and DeepVariant had low precision (0.832, 0.920, and 0.956, respectively) and recall (0.738, 0.684, and 0.706) (see <xref rid="btad268-F2" ref-type="fig">Fig. 2b</xref>). ParascopyVC significantly outperformed all methods and achieved high recall (0.807) and very high precision (0.997).</p>
      <p>Since ParascopyVC uses population reference allele frequencies of PSVs for variant calling, the choice of population can potentially impact the accuracy of variant calling. To assess this, we ran ParascopyVC using PSV allele frequencies derived from the East Asian population in the 1000 Genomes Project. ParascopyVC’s accuracy was slightly lower (dashed yellow line in <xref rid="btad268-F2" ref-type="fig">Fig. 2b</xref>) than the accuracy using European allele frequencies but was significantly better than all other methods.</p>
    </sec>
    <sec>
      <title>3.2 Accuracy of variant calling on the HG002 genome</title>
      <p>The GIAB has compiled high-confidence variant call sets for seven human individuals by careful aggregation of variant call sets derived from numerous variant calling tools and multiple sequencing technologies (<xref rid="btad268-B36" ref-type="bibr">Zook et al. 2014</xref>, <xref rid="btad268-B37" ref-type="bibr">2016</xref>, <xref rid="btad268-B38" ref-type="bibr">2019</xref>). The HG002 genome is the most studied of the seven GIAB datasets and therefore, we first benchmarked our method on this genome. The overlap between the GIAB high-confidence benchmarking regions for the HG002 genome and the 167 LCR loci covered 7.35 Mb of DNA sequence. After excluded regions where Parascopy estimated nonreference paralog-specific copy number (0.39 Mb) or was unable to estimate paralog-specific copy number (0.70 Mb), the benchmarking regions covered 6.26 Mb of DNA sequence and contained 7985 ground truth variants.</p>
      <p>Comparison of the variant calling accuracy for the four methods (<xref rid="btad268-F3" ref-type="fig">Fig. 3a</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>) showed that Freebayes and GATK (<inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> scores of 0.883 and 0.880 respectively) had much lower precision and recall values than DeepVariant and ParascopyVC. ParascopyVC correctly called 7255 variants (recall = 0.909) and incorrectly called only 65 variants (precision = 0.991), resulting in a very high <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score of 0.948. In comparison, DeepVariant could achieve high precision (0.983) but had lower recall (0.861) than ParascopyVC, achieving <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score of 0.918. For comparison, we also evaluated the accuracy of DeepVariant calls on <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mn>30</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> long-read HiFi WGS data for the HG002 genome. The HiFi calls had very high precision (0.9985, 12 false positives) and recall (0.991, 73 false negatives).</p>
      <fig position="float" id="btad268-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Precision and recall of variant calling using four callers (GATK, FreeBayes, DeepVariant, ParascopyVC) on the HG002 benchmark dataset. For each caller, circles denote the quality thresholds that maximize the average accuracy across seven human genomes. (a) Precision–recall values across all LCR regions. (b) Precision–recall values across LCR regions split into four groups based on sequence similarity (0.97–0.98, 0.98–0.99, 0.99–0.995, and 0.995–1.0).</p>
        </caption>
        <graphic xlink:href="btad268f3" position="float"/>
      </fig>
      <p>Comparison of the accuracy for SNVs and short indels separately showed that ParascopyVC achieved the best precision (0.995) and best recall (0.914) among all methods for SNVs (<xref rid="btad268-T1" ref-type="table">Table 1</xref>). ParascopyVC’s SNV <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score was 0.953 while the next best <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score (0.919) was achieved by DeepVariant. For indels, DeepVariant had higher precision (0.978) compared to ParascopyVC (0.972) while both methods had the same recall.</p>
      <table-wrap position="float" id="btad268-T1">
        <label>Table 1.</label>
        <caption>
          <p>Variant calling accuracy for single-nucleotide variants (SNVs) and insertions or deletions (indels) on the HG002 benchmarking WGS dataset.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Variants</th>
              <th rowspan="1" colspan="1">Method</th>
              <th align="center" rowspan="1" colspan="1">FP</th>
              <th align="center" rowspan="1" colspan="1">FN</th>
              <th align="center" rowspan="1" colspan="1">Precision</th>
              <th align="center" rowspan="1" colspan="1">Recall</th>
              <th align="center" rowspan="1" colspan="1">
                <inline-formula id="IE121">
                  <mml:math id="IM121" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi mathvariant="italic">F</mml:mi>
                        </mml:mrow>
                        <mml:mn>1</mml:mn>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="4" colspan="1">SNPs</td>
              <td rowspan="1" colspan="1">GATK</td>
              <td rowspan="1" colspan="1">821</td>
              <td rowspan="1" colspan="1">920</td>
              <td rowspan="1" colspan="1">0.887</td>
              <td rowspan="1" colspan="1">0.875</td>
              <td rowspan="1" colspan="1">0.881</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FreeBayes</td>
              <td rowspan="1" colspan="1">276</td>
              <td rowspan="1" colspan="1">1263</td>
              <td rowspan="1" colspan="1">0.954</td>
              <td rowspan="1" colspan="1">0.828</td>
              <td rowspan="1" colspan="1">0.887</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">DeepVariant</td>
              <td rowspan="1" colspan="1">104</td>
              <td rowspan="1" colspan="1">1017</td>
              <td rowspan="1" colspan="1">0.984</td>
              <td rowspan="1" colspan="1">0.862</td>
              <td rowspan="1" colspan="1">0.919</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParascopyVC</td>
              <td rowspan="1" colspan="1">
                <bold>31</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>634</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.995</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.914</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.953</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="4" colspan="1">Indels</td>
              <td rowspan="1" colspan="1">GATK</td>
              <td rowspan="1" colspan="1">62</td>
              <td rowspan="1" colspan="1">95</td>
              <td rowspan="1" colspan="1">0.895</td>
              <td rowspan="1" colspan="1">0.848</td>
              <td rowspan="1" colspan="1">0.871</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FreeBayes</td>
              <td rowspan="1" colspan="1">33</td>
              <td rowspan="1" colspan="1">147</td>
              <td rowspan="1" colspan="1">0.950</td>
              <td rowspan="1" colspan="1">0.765</td>
              <td rowspan="1" colspan="1">0.848</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">DeepVariant</td>
              <td rowspan="1" colspan="1">
                <bold>12</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>90</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.978</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.856</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.913</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParascopyVC</td>
              <td rowspan="1" colspan="1">34</td>
              <td rowspan="1" colspan="1">
                <bold>90</bold>
              </td>
              <td rowspan="1" colspan="1">0.972</td>
              <td rowspan="1" colspan="1">
                <bold>0.856</bold>
              </td>
              <td rowspan="1" colspan="1">0.911</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p>The table shows the number of false positive (FP) and negative (FN) variant calls, precision, recall, and <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> scores for 7361 baseline SNPs and 624 baseline indels. Best value in each subtable is printed in bold.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>Next, we evaluated the accuracy of variant calling in LCR regions stratified by sequence similarity. For this, we split the LCR regions into four groups (sequence similarity in the range 0.97–0.98, 0.98–0.99, 0.99–0.995, and 0.995–1.0). The comparison of precision-recall for the different methods showed that ParascopyVC’s accuracy, was greater for LCR regions with higher sequence similarity relative to other methods (<xref rid="btad268-F3" ref-type="fig">Fig. 3b</xref>). Compared to the other three variant callers, ParascopyVC maintained high precision across LCR regions with different sequence similarity. The HG002 high-confidence variant calls included 1016 variants in LCR regions with <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>99</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> sequence similarity. In these regions, ParascopyVC had a very high precision (0.991) and high recall (0.792). DeepVariant’s recall (0.651) and precision (0.959) in these regions were lower compared to its overall recall (0.861) and precision (0.983). The high recall for ParascopyVC in LCR regions with very high sequence similarity is likely because it utilizes all reads (even with a mapping quality of zero) for variant discovery and genotyping.</p>
      <p>To assess the accuracy of ParascopyVC in noncoding LCRs, we performed variant calling in all LCR regions from chromosomes 15, 16, and 17. The benchmarking regions covered 5.85 Mb of DNA sequence and included 6724 high-confidence variants. The relative performance of the different variant callers was similar to that observed in the 167 coding LCRs. ParascopyVC had the best overall precision (0.982) and recall (0.864), DeepVariant achieved similar precision (0.975) but lower recall (0.805) while GATK and Freebayes had much lower accuracy than DeepVariant and ParascopyVC (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref>).</p>
    </sec>
    <sec>
      <title>3.3 Benchmarking variant calling on additional human genomes</title>
      <p>We benchmarked ParascopyVC on the six additional human genomes for which the GIAB consortium has generated high-confidence variant calls. Benchmarking regions across all seven GIAB variant call sets (HG001–HG007) covered between 6.26 Mb and 6.46 Mb of LCR regions and contained between 7.8 and 9.5 thousand variants (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). The precision-recall curves for the six genomes (<xref rid="btad268-F4" ref-type="fig">Fig. 4</xref>) were very similar to that for the HG002 genome and showed that ParascopyVC had consistently higher precision and recall than both GATK and Freebayes. The average precision for ParascopyVC across the seven genomes was 0.987 compared to 0.876, 0.941, and 0.983 for GATK, Freebayes, and DeepVariant, respectively (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). Although the precision for DeepVariant was comparable to that for ParascopyVC, the average recall for DeepVariant (0.844) was much lower than that for ParascopyVC (0.911).</p>
      <fig position="float" id="btad268-F4">
        <label>Figure 4.</label>
        <caption>
          <p>Precision and recall of variant calling using four callers (GATK, FreeBayes, DeepVariant, ParascopyVC) in LCR regions across six human genomes. For each caller, circles denote the quality thresholds that maximize the average accuracy across seven genomes (including HG002).</p>
        </caption>
        <graphic xlink:href="btad268f4" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.4 Run time and memory usage</title>
      <p>On a single individual (HG002) and 167 duplicated loci, FreeBayes called variants in 04:41 (mm: ss) and used approximately 0.5 Gb memory. GATK HaplotypeCaller consumed 10 Gb memory and called variants in 10:21 (1 thread) or 08:57 (16 threads). DeepVariant had similar performance: 3 Gb memory usage and a run-time of 13:09 (1 thread) or 3:25 (16 threads). ParascopyVC required 7 Gb memory and called variants in 80:28 (1 thread) or 16:36 (16 threads). In contrast to existing variant calling tools which run diploid variant calling for human genomes, ParascopyVC performs polyploid variant calling using FreeBayes. Polyploid variant calling and genotyping requires more calculations than diploid variant calling since the number of possible genotypes for a variant site is combinatorial in the ploidy and number of alleles. Consequently, ParascopyVC requires more time compared to other methods.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this article, we have described a new computational method specifically designed for variant calling in LCRs using WGS data. We have demonstrated—using both simulated and real WGS datasets—that this approach significantly improves accuracy of variant calling in LCRs in human genomes. Compared to existing variant callers that call variants in each copy of LCRs separately, ParascopyVC jointly analyzes reads mapped to all repeat copies to first identify candidate variants. Although several methods have previously utilized a similar strategy of aggregating read information for variant calling in LCRs (<xref rid="btad268-B16" ref-type="bibr">Kerzendorfer et al. 2015</xref>; <xref rid="btad268-B11" ref-type="bibr">Ebbert et al. 2019</xref>), ParascopyVC implements an end-to-end variant calling approach that starts from aligned reads (BAM/CRAM files) as input and output variant calls (VCF files). A key feature of ParascopyVC is that it does not assume correctness of the reference genome at PSVs for variant calling. Instead, it leverages population-based reference allele frequencies and read-level information at PSVs to identify those PSVs that can be used to distinguish repeat copies.</p>
    <p>Benchmarking of multiple variant callers in LCR regions showed that DeepVariant had higher precision than both GATK and FreeBayes. DeepVariant is a neural network based variant caller that has been trained using GIAB benchmark calls for human genomes. As per the DeepVariant github FAQ, DeepVariant has potentially learned to filter out false positives in LCRs based on signatures such as excessive read depth, allele bias, or clustering of variants. Nevertheless, ParascopyVC obtains significantly higher recall than DeepVariant while achieving similar precision indicating that direct modeling of LCRs enables high precision and recall.</p>
    <p>ParascopyVC has been developed to complement existing variant calling tools in LCR regions and not replace them. Indeed, it leverages an existing variant caller, FreeBayes, for variant discovery. Currently, it uses a simple constant error-rate based model for calculating genotype likelihoods for indels. This reduces the indel calling precision, particularly in low-complexity sequences with high indel error rate. The indel calling precision can be improved by leveraging error models or annotations from existing variant callers.</p>
    <p>ParascopyVC leverages population reference allele frequencies for PSVs for variant calling. As a result, it does not call variants in regions for which these frequencies are not available. In such regions, variant calling using existing state-of-the-art tools is likely to have low accuracy since a large fraction of PSVs are polymorphic. Our previous analysis of 167 LCR loci (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>) using 1000 Genomes WGS data has shown that PSV frequencies cannot be estimated for 10–15% of loci. In the future, as long read sequencing data and high-quality genome assemblies become available for a large number of human genomes (<xref rid="btad268-B35" ref-type="bibr">Wang et al. 2022</xref>), these can potentially be used to obtain PSV reference allele frequencies for such loci and improve the accuracy of variant calling.</p>
    <p>ParascopyVC uses estimates of paralog-specific copy number as input and can call variants in the presence of copy number variants. However, we did not evaluate its accuracy in the presence of copy number changes in this article. Benchmarking variant calling in the presence of copy number variants is challenging with short reads since it requires accurate estimates of copy number in addition to accurate variant calls. We plan to explore this in future work.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad268_Supplementary_Data</label>
      <media xlink:href="btad268_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The analyses presented in this article are based on the high-coverage whole genome sequencing data of 1000 Genomes Project samples, available via ENA Study <ext-link xlink:href="https://www.ebi.ac.uk/ena/browser/view/PRJEB31736" ext-link-type="uri">PRJEB31736</ext-link> and <ext-link xlink:href="https://www.ebi.ac.uk/ena/browser/view/PRJEB36890" ext-link-type="uri">PRJEB36890</ext-link>.</p>
  </sec>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> is available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by grants from the National Human Genome Research Institute [NIH; R01HG010149 and R01HG010759].</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad268-B1">
      <mixed-citation publication-type="journal"><collab>1000 Genomes Project Consortium</collab><etal>et al</etal><article-title>A global reference for human genetic variation</article-title>. <source>Nature</source><year>2015</year>;<volume>526</volume>:<fpage>68</fpage>.<pub-id pub-id-type="pmid">26432245</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bailey</surname><given-names>JA</given-names></string-name>, <string-name><surname>Gu</surname><given-names>Z</given-names></string-name>, <string-name><surname>Clark</surname><given-names>RA</given-names></string-name></person-group><etal>et al</etal><article-title>Recent segmental duplications in the human genome</article-title>. <source>Science</source><year>2002</year>;<volume>297</volume>:<fpage>1003</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">12169732</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Boisson</surname><given-names>B</given-names></string-name>, <string-name><surname>Honda</surname><given-names>Y</given-names></string-name>, <string-name><surname>Ajiro</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Rescue of recurrent deep intronic mutation underlying cell type-dependent quantitative NEMO deficiency</article-title>. <source>J Clin Invest</source><year>2019</year>;<volume>129</volume>:<fpage>583</fpage>–<lpage>97</lpage>.<pub-id pub-id-type="pmid">30422821</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>X</given-names></string-name>, <string-name><surname>Sanchis-Juan</surname><given-names>A</given-names></string-name>, <string-name><surname>French</surname><given-names>CE</given-names></string-name></person-group><etal>et al</etal><article-title>Spinal muscular atrophy diagnosis and carrier screening from genome sequencing data</article-title>. <source>Genet Med</source><year>2020</year>;<volume>22</volume>:<fpage>945</fpage>–<lpage>53</lpage>.<pub-id pub-id-type="pmid">32066871</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cleary</surname><given-names>JG</given-names></string-name>, <string-name><surname>Braithwaite</surname><given-names>R</given-names></string-name>, <string-name><surname>Gaastra</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Joint variant and <italic toggle="yes">de novo</italic> mutation identification on pedigrees from high-throughput sequencing data</article-title>. <source>J Comput Biol</source><year>2014</year>;<volume>21</volume>:<fpage>405</fpage>–<lpage>19</lpage>.<pub-id pub-id-type="pmid">24874280</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cleary</surname><given-names>JG</given-names></string-name>, <string-name><surname>Braithwaite</surname><given-names>R</given-names></string-name>, <string-name><surname>Gaastra</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Comparing variant call files for performance benchmarking of next-generation sequencing variant calling pipelines</article-title>. bioRxiv <year>2015</year>;<volume>8</volume>:<fpage>023754</fpage>.</mixed-citation>
    </ref>
    <ref id="btad268-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Clendenning</surname><given-names>M</given-names></string-name>, <string-name><surname>Hampel</surname><given-names>H</given-names></string-name>, <string-name><surname>LaJeunesse</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Long-range PCR facilitates the identification of <italic toggle="yes">PMS2</italic>-specific mutations</article-title>. <source>Hum Mutat</source><year>2006</year>;<volume>27</volume>:<fpage>490</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">16619239</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cummings</surname><given-names>BB</given-names></string-name>, <string-name><surname>Marshall</surname><given-names>JL</given-names></string-name>, <string-name><surname>Tukiainen</surname><given-names>T</given-names></string-name></person-group><etal>et al</etal><article-title>Improving genetic diagnosis in Mendelian disease with transcriptome sequencing</article-title>. <source>Sci Transl Med</source><year>2017</year>;<volume>9</volume>:<fpage>eaal5209</fpage>.<pub-id pub-id-type="pmid">28424332</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Danecek</surname><given-names>P</given-names></string-name>, <string-name><surname>Bonfield</surname><given-names>JK</given-names></string-name>, <string-name><surname>Liddle</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Twelve years of SAMtools and BCFtools</article-title>. <source>GigaScience</source><year>2021</year>;<volume>10</volume>:<fpage>giab008</fpage>.<pub-id pub-id-type="pmid">33590861</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>DePristo</surname><given-names>MA</given-names></string-name>, <string-name><surname>Banks</surname><given-names>E</given-names></string-name>, <string-name><surname>Poplin</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>A framework for variation discovery and genotyping using next-generation DNA sequencing data</article-title>. <source>Nat Genet</source><year>2011</year>;<volume>43</volume>:<fpage>491</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">21478889</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ebbert</surname><given-names>MT</given-names></string-name>, <string-name><surname>Jensen</surname><given-names>TD</given-names></string-name>, <string-name><surname>Jansen-West</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Systematic analysis of dark and camouflaged genes reveals disease-relevant genes hiding in plain sight</article-title>. <source>Genome Biol</source><year>2019</year>;<volume>20</volume>:<fpage>97</fpage>.<pub-id pub-id-type="pmid">31104630</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Garrison</surname><given-names>E</given-names></string-name>, <string-name><surname>Marth</surname><given-names>G.</given-names></string-name></person-group><article-title>Haplotype-based variant detection from short-read sequencing</article-title>. <year>2012</year>;<volume>7</volume></mixed-citation>
    </ref>
    <ref id="btad268-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gould</surname><given-names>GM</given-names></string-name>, <string-name><surname>Grauman</surname><given-names>PV</given-names></string-name>, <string-name><surname>Theilmann</surname><given-names>MR</given-names></string-name></person-group><etal>et al</etal><article-title>Detecting clinically actionable variants in the 3’ exons of <italic toggle="yes">PMS2</italic> via a reflex workflow based on equivalent hybrid capture of the gene and its pseudogene</article-title>. <source>BMC Med Genet</source><year>2018</year>;<volume>19</volume>:<fpage>176</fpage>.<pub-id pub-id-type="pmid">30268105</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Huang</surname><given-names>W</given-names></string-name>, <string-name><surname>Li</surname><given-names>L</given-names></string-name>, <string-name><surname>Myers</surname><given-names>JR</given-names></string-name></person-group><etal>et al</etal><article-title>ART: a next-generation sequencing read simulator</article-title>. <source>Bioinformatics</source><year>2012</year>;<volume>28</volume>:<fpage>593</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">22199392</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Karp</surname><given-names>RM.</given-names></string-name></person-group><part-title>Reducibility among combinatorial problems</part-title>. In: Miller, RE and Thatcher, JW (eds.) <source>Complexity of Computer Computations</source>, Plenum Press, <year>1972</year>, <fpage>85</fpage>–<lpage>103</lpage>.</mixed-citation>
    </ref>
    <ref id="btad268-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kerzendorfer</surname><given-names>C</given-names></string-name>, <string-name><surname>Konopka</surname><given-names>T</given-names></string-name>, <string-name><surname>Nijman</surname><given-names>SM.</given-names></string-name></person-group><article-title>A thesaurus of genetic variation for interrogation of repetitive genomic regions</article-title>. <source>Nucleic Acids Res</source><year>2015</year>;<volume>43</volume>:<fpage>e68</fpage>.<pub-id pub-id-type="pmid">25820428</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kim</surname><given-names>S</given-names></string-name>, <string-name><surname>Scheffler</surname><given-names>K</given-names></string-name>, <string-name><surname>Halpern</surname><given-names>AL</given-names></string-name></person-group><etal>et al</etal><article-title>Strelka2: fast and accurate calling of germline and somatic variants</article-title>. <source>Nat Methods</source><year>2018</year>;<volume>15</volume>:<fpage>591</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">30013048</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Koboldt</surname><given-names>DC.</given-names></string-name></person-group><article-title>Best practices for variant calling in clinical sequencing</article-title>. <source>Genome Med</source><year>2020</year>;<volume>12</volume>:<fpage>91</fpage>.<pub-id pub-id-type="pmid">33106175</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Krusche</surname><given-names>P</given-names></string-name>, <string-name><surname>Trigg</surname><given-names>L</given-names></string-name>, <string-name><surname>Boutros</surname><given-names>PC</given-names></string-name></person-group><etal>et al</etal><article-title>Best practices for benchmarking germline small-variant calls in human genomes</article-title>. <source>Nat Biotechnol</source><year>2019</year>;<volume>37</volume>:<fpage>555</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">30858580</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lefebvre</surname><given-names>S</given-names></string-name>, <string-name><surname>Bürglen</surname><given-names>L</given-names></string-name>, <string-name><surname>Reboullet</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Identification and characterization of a spinal muscular atrophy-determining gene</article-title>. <source>Cell</source><year>1995</year>;<volume>80</volume>:<fpage>155</fpage>–<lpage>65</lpage>.<pub-id pub-id-type="pmid">7813012</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>A statistical framework for SNP calling, mutation discovery, association mapping and population genetical parameter estimation from sequencing data</article-title>. <source>Bioinformatics</source><year>2011</year>;<volume>27</volume>:<fpage>2987</fpage>–<lpage>93</lpage>.<pub-id pub-id-type="pmid">21903627</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM</article-title>. arXiv <year>2013</year>;<volume>4</volume>:<fpage>1303</fpage>.3997.</mixed-citation>
    </ref>
    <ref id="btad268-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>3094</fpage>–<lpage>100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H</given-names></string-name>, <string-name><surname>Durbin</surname><given-names>R.</given-names></string-name></person-group><article-title>Fast and accurate short read alignment with Burrows–Wheeler transform</article-title>. <source>Bioinformatics</source><year>2009</year>;<volume>25</volume>:<fpage>1754</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lopez-Lopez</surname><given-names>D</given-names></string-name>, <string-name><surname>Loucera</surname><given-names>C</given-names></string-name>, <string-name><surname>Carmona</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title><italic toggle="yes">SMN1</italic> copy-number and sequence variant analysis from next-generation sequencing data</article-title>. <source>Hum Mutat</source><year>2020</year>;<volume>41</volume>:<fpage>2073</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">33058415</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mandelker</surname><given-names>D</given-names></string-name>, <string-name><surname>Schmidt</surname><given-names>RJ</given-names></string-name>, <string-name><surname>Ankala</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Navigating highly homologous genes in a molecular diagnostic setting: a resource for clinical next-generation sequencing</article-title>. <source>Genet Med</source><year>2016</year>;<volume>18</volume>:<fpage>1282</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">27228465</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mueller</surname><given-names>M</given-names></string-name>, <string-name><surname>Barros</surname><given-names>P</given-names></string-name>, <string-name><surname>Witherden</surname><given-names>AS</given-names></string-name></person-group><etal>et al</etal><article-title>Genomic pathology of SLE-associated copy-number variation at the <italic toggle="yes">FCGR2C</italic>/<italic toggle="yes">FCGR3B</italic>/<italic toggle="yes">FCGR2B</italic> locus</article-title>. <source>Am J Hum Genet</source><year>2013</year>;<volume>92</volume>:<fpage>28</fpage>–<lpage>40</lpage>.<pub-id pub-id-type="pmid">23261299</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Poplin</surname><given-names>R</given-names></string-name>, <string-name><surname>Chang</surname><given-names>PC</given-names></string-name>, <string-name><surname>Alexander</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>A universal SNP and small-indel variant caller using deep neural networks</article-title>. <source>Nat Biotechnol</source><year>2018a</year>;<volume>36</volume>:<fpage>983</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">30247488</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Poplin</surname><given-names>R</given-names></string-name>, <string-name><surname>Ruano-Rubio</surname><given-names>V</given-names></string-name>, <string-name><surname>DePristo</surname><given-names>MA</given-names></string-name></person-group><etal>et al</etal><article-title>Scaling accurate genetic variant discovery to tens of thousands of samples</article-title>. bioRxiv <year>2018b</year>;<volume>7</volume>:<fpage>201178</fpage>.</mixed-citation>
    </ref>
    <ref id="btad268-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Prodanov</surname><given-names>T</given-names></string-name>, <string-name><surname>Bansal</surname><given-names>V.</given-names></string-name></person-group><article-title>Robust and accurate estimation of paralog-specific copy number for duplicated genes using whole-genome sequencing</article-title>. <source>Nat Commun</source><year>2022</year>;<volume>13</volume>:<fpage>3221</fpage>.<pub-id pub-id-type="pmid">35680869</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sudmant</surname><given-names>PH</given-names></string-name>, <string-name><surname>Kitzman</surname><given-names>JO</given-names></string-name>, <string-name><surname>Antonacci</surname><given-names>F</given-names></string-name></person-group><etal>et al</etal><article-title>Diversity of human copy number variation and multicopy genes</article-title>. <source>Science</source><year>2010</year>;<volume>330</volume>:<fpage>641</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">21030649</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Treangen</surname><given-names>TJ</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>SL.</given-names></string-name></person-group><article-title>Repetitive DNA and next-generation sequencing: computational challenges and solutions</article-title>. <source>Nat Rev Genet</source><year>2011</year>;<volume>13</volume>:<fpage>36</fpage>–<lpage>46</lpage>.<pub-id pub-id-type="pmid">22124482</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vollger</surname><given-names>MR</given-names></string-name>, <string-name><surname>Guitart</surname><given-names>X</given-names></string-name>, <string-name><surname>Dishuck</surname><given-names>PC</given-names></string-name></person-group><etal>et al</etal><article-title>Segmental duplications and their variation in a complete human genome</article-title>. <source>Science</source><year>2022</year>;<volume>376</volume>:<fpage>eabj6965</fpage>.<pub-id pub-id-type="pmid">35357917</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wagner</surname><given-names>J</given-names></string-name>, <string-name><surname>Olson</surname><given-names>ND</given-names></string-name>, <string-name><surname>Harris</surname><given-names>L</given-names></string-name></person-group><etal>et al</etal><article-title>Curated variation benchmarks for challenging medically relevant autosomal genes</article-title>. <source>Nat Biotechnol</source><year>2022</year>;<volume>40</volume>:<fpage>672</fpage>–<lpage>80</lpage>.<pub-id pub-id-type="pmid">35132260</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname><given-names>T</given-names></string-name>, <string-name><surname>Antonacci-Fulton</surname><given-names>L</given-names></string-name>, <string-name><surname>Howe</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>The human pangenome project: a global resource to map genomic diversity</article-title>. <source>Nature</source><year>2022</year>;<volume>604</volume>:<fpage>437</fpage>–<lpage>46</lpage>.<pub-id pub-id-type="pmid">35444317</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zook</surname><given-names>JM</given-names></string-name>, <string-name><surname>Chapman</surname><given-names>B</given-names></string-name>, <string-name><surname>Wang</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Integrating human sequence data sets provides a resource of benchmark SNP and indel genotype calls</article-title>. <source>Nat Biotechnol</source><year>2014</year>;<volume>32</volume>:<fpage>246</fpage>–<lpage>51</lpage>.<pub-id pub-id-type="pmid">24531798</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zook</surname><given-names>JM</given-names></string-name>, <string-name><surname>Catoe</surname><given-names>D</given-names></string-name>, <string-name><surname>McDaniel</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Extensive sequencing of seven human genomes to characterize benchmark reference materials</article-title>. <source>Sci Data</source><year>2016</year>;<volume>3</volume>:<fpage>160025</fpage>.<pub-id pub-id-type="pmid">27271295</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zook</surname><given-names>JM</given-names></string-name>, <string-name><surname>McDaniel</surname><given-names>J</given-names></string-name>, <string-name><surname>Olson</surname><given-names>ND</given-names></string-name></person-group><etal>et al</etal><article-title>An open resource for accurately benchmarking small variant and reference calls</article-title>. <source>Nat Biotechnol</source><year>2019</year>;<volume>37</volume>:<fpage>561</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">30936564</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311303</article-id>
    <article-id pub-id-type="pmid">37387146</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad268</article-id>
    <article-id pub-id-type="publisher-id">btad268</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A multilocus approach for accurate variant calling in low-copy repeats using whole-genome sequencing</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-7469-6651</contrib-id>
        <name>
          <surname>Prodanov</surname>
          <given-names>Timofey</given-names>
        </name>
        <aff><institution>Bioinformatics and Systems Biology Graduate Program, University of California San Diego</institution>, La Jolla, CA 92093, <country country="US">United States</country></aff>
        <aff><institution>Institute for Medical Biometry and Bioinformatics, Medical Faculty, Heinrich Heine University</institution>, Düsseldorf 40225, <country country="DE">Germany</country></aff>
        <aff><institution>Center for Digital Medicine, Heinrich Heine University</institution>, Düsseldorf 40225, <country country="DE">Germany</country></aff>
        <xref rid="btad268-cor1" ref-type="corresp"/>
        <!--timofey.prodanov@hhu.de-->
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-6684-5335</contrib-id>
        <name>
          <surname>Bansal</surname>
          <given-names>Vikas</given-names>
        </name>
        <aff><institution>School of Medicine, University of California San Diego</institution>, La Jolla, CA 92093, <country country="US">United States</country></aff>
        <xref rid="btad268-cor1" ref-type="corresp"/>
        <!--vibansal@ucsd.edu-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad268-cor1">Corresponding authors. Institute for Medical Biometry and Bioinformatics, Medical Faculty, Heinrich Heine University, Düsseldorf 40225, Germany. E-mail: <email>timofey.prodanov@hhu.de</email> (T.P.); Bioinformatics and Systems Biology Graduate Program, University of California San Diego, La Jolla, CA 92093, USA. E-mail: <email>vibansal@ucsd.edu</email> (V.B.).</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i279</fpage>
    <lpage>i287</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad268.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Low-copy repeats (LCRs) or segmental duplications are long segments of duplicated DNA that cover <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mo>&gt;</mml:mo></mml:math></inline-formula> 5% of the human genome. Existing tools for variant calling using short reads exhibit low accuracy in LCRs due to ambiguity in read mapping and extensive copy number variation. Variants in more than 150 genes overlapping LCRs are associated with risk for human diseases.</p>
      </sec>
      <sec id="s2">
        <title>Methods</title>
        <p>We describe a short-read variant calling method, ParascopyVC, that performs variant calling jointly across all repeat copies and utilizes reads independent of mapping quality in LCRs. To identify candidate variants, ParascopyVC aggregates reads mapped to different repeat copies and performs polyploid variant calling. Subsequently, paralogous sequence variants that can differentiate repeat copies are identified using population data and used for estimating the genotype of variants for each repeat copy.</p>
      </sec>
      <sec id="s3">
        <title>Results</title>
        <p>On simulated whole-genome sequence data, ParascopyVC achieved higher precision (0.997) and recall (0.807) than three state-of-the-art variant callers (best precision = 0.956 for DeepVariant and best recall = 0.738 for GATK) in 167 LCR regions. Benchmarking of ParascopyVC using the genome-in-a-bottle high-confidence variant calls for HG002 genome showed that it achieved a very high precision of 0.991 and a high recall of 0.909 across LCR regions, significantly better than FreeBayes (precision = 0.954 and recall = 0.822), GATK (precision = 0.888 and recall = 0.873) and DeepVariant (precision = 0.983 and recall = 0.861). ParascopyVC demonstrated a consistently higher accuracy (mean <italic toggle="yes">F</italic><sub>1</sub> = 0.947) than other callers (best <italic toggle="yes">F</italic><sub>1</sub> = 0.908) across seven human genomes.</p>
      </sec>
      <sec id="s4">
        <title>Availability and implementation</title>
        <p>ParascopyVC is implemented in Python and is freely available at <ext-link xlink:href="https://github.com/tprodanov/ParascopyVC" ext-link-type="uri">https://github.com/tprodanov/ParascopyVC</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Human Genome Research Institute</institution>
            <institution-id institution-id-type="DOI">10.13039/100000051</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>NIH</institution>
            <institution-id institution-id-type="DOI">10.13039/100000002</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>R01HG010149</award-id>
        <award-id>R01HG010759</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Advances in DNA sequencing technologies have transformed the ability to sequence genomes, particularly human genomes. Accurate variant calling is of crucial importance for virtually all applications of high-throughput DNA sequencing including disease genetics and cancer. Small variants such as single nucleotide variants (SNVs) and short indels represent the most abundant type of variants in human genomes and a number of methods (e.g. Samtools, FreeBayes, GATK) have been developed to call such variants from DNA sequence data (<xref rid="btad268-B10" ref-type="bibr">DePristo et al. 2011</xref>; <xref rid="btad268-B21" ref-type="bibr">Li 2011</xref>; <xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>; <xref rid="btad268-B17" ref-type="bibr">Kim et al. 2018</xref>; <xref rid="btad268-B28" ref-type="bibr">Poplin et al. 2018a</xref>). Most of these methods leverage statistical techniques to discriminate true genetic variants from artifacts due to errors in reads and exhibit high accuracy in unique regions of the human genome that are callable using short reads. The Genome-in-a-Bottle Consortium (GIAB) has developed benchmark sets for small variants across seven genomes that are useful for benchmarking and optimizing variant calling methods (<xref rid="btad268-B36" ref-type="bibr">Zook et al. 2014</xref>, <xref rid="btad268-B37" ref-type="bibr">2016</xref>, <xref rid="btad268-B38" ref-type="bibr">2019</xref>).</p>
    <p>However, a significant portion of the human genome is repetitive (<xref rid="btad268-B32" ref-type="bibr">Treangen and Salzberg, 2011</xref>) and remains challenging for variant calling using short read sequencing. In particular, segmental duplications—also known as low-copy repeats—that have been estimated to cover <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mo>∼</mml:mo></mml:math></inline-formula>5% of the human genome (<xref rid="btad268-B2" ref-type="bibr">Bailey et al. 2002</xref>), are problematic for variant calling due to ambiguity in read mapping (<xref rid="btad268-B18" ref-type="bibr">Koboldt 2020</xref>). Recent analysis of segmental duplications in a complete human genome (T2T-CHM13) has revealed that such repeats cover an estimated 7% of the genome (<xref rid="btad268-B33" ref-type="bibr">Vollger et al. 2022</xref>). Short reads derived from such regions align to multiple locations and are assigned low mapping quality scores by mapping tools (<xref rid="btad268-B24" ref-type="bibr">Li and Durbin 2009</xref>; <xref rid="btad268-B23" ref-type="bibr">Li 2018</xref>). Such reads are typically discarded during variant calling to avoid false-positive variant calls (<xref rid="btad268-B10" ref-type="bibr">DePristo et al. 2011</xref>; <xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>) resulting in low sensitivity. Until recently, the GIAB benchmark calls excluded most of these low-copy repeat (LCR) regions due to the difficulty in accurate variant calling. As a result, the SNV concordance of two state-of-the-art variant callers was observed to be 99.7% within GIAB high-confidence regions compared to 76.5% outside (<xref rid="btad268-B19" ref-type="bibr">Krusche et al. 2019</xref>).</p>
    <p>LCRs overlap hundreds of protein-coding genes (<xref rid="btad268-B2" ref-type="bibr">Bailey et al. 2002</xref>) in the human genome. A recent analysis of sequence homology for coding regions in the human genome identified 7691 exons in 1168 genes, which have partial or complete sequence homology (<inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>98</mml:mn></mml:mrow></mml:math></inline-formula>%) to one or more loci (<xref rid="btad268-B26" ref-type="bibr">Mandelker et al. 2016</xref>). Copy number and sequence variants in 193 of these 1168 genes are associated with rare Mendelian disorders, inherited cancers and complex diseases. Therefore, improving the accuracy of variant calling in LCRs has great clinical importance. One well-studied example of a disease-associated gene that overlaps a LCR is the <italic toggle="yes">SMN1</italic> gene—mutations in this gene cause spinal muscular atrophy, a severe childhood disease. <italic toggle="yes">SMN1</italic> is entirely duplicated and has close to 99.9% sequence similarity with its homologous gene <italic toggle="yes">SMN2</italic> (<xref rid="btad268-B20" ref-type="bibr">Lefebvre et al. 1995</xref>). Furthermore, <italic toggle="yes">SMN1/2</italic> is prone to frequent copy number changes which further complicates the task of small variant calling (<xref rid="btad268-B4" ref-type="bibr">Chen et al. 2020</xref>; <xref rid="btad268-B25" ref-type="bibr">Lopez-Lopez et al. 2020</xref>).</p>
    <p>Sequence differences between the different repeat copies of an LCR are commonly referred to as paralogous sequence variants (PSVs). PSVs represent the only source of information to differentiate between repeat copies of a LCR and read mappers implicitly use PSVs to map reads in LCRs. However, not all PSVs represent fixed differences between repeat copies and many correspond to common variants (<xref rid="btad268-B31" ref-type="bibr">Sudmant et al. 2010</xref>; <xref rid="btad268-B27" ref-type="bibr">Mueller et al. 2013</xref>). For example, the reference human genome sequence for the <italic toggle="yes">SMN1</italic> gene differs from <italic toggle="yes">SMN2</italic> gene at 24 positions across 28 kb of DNA sequence (sequence similarity <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0.999</mml:mn></mml:mrow></mml:math></inline-formula>), but only 8 of these 24 positions correspond to fixed differences in human populations (<xref rid="btad268-B4" ref-type="bibr">Chen et al. 2020</xref>). A similar phenomenon has been observed for another disease-associated gene, <italic toggle="yes">PMS2</italic>, that frequently exchanges DNA sequence with its nearby pseudogene, <italic toggle="yes">PMS2CL</italic>, making it difficult to distinguish between the two repeat copies (<xref rid="btad268-B7" ref-type="bibr">Clendenning et al. 2006</xref>; <xref rid="btad268-B13" ref-type="bibr">Gould et al. 2018</xref>). Using polymorphic PSVs for mapping reads in LCRs can result in incorrect read mapping and reduce the accuracy of variant calling. We have recently developed a probabilistic method for estimating the paralog-specific copy number of genes at LCRs that also estimates the reference allele frequencies at PSVs (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>) using population data. Our analysis of 2500 genomes from the 1000 Genomes Project (<xref rid="btad268-B1" ref-type="bibr">1000 Genomes Project Consortium et al. 2015</xref>) showed that the frequency of PSVs that represent fixed or almost fixed differences between repeat copies varies widely across LCR loci and also across populations at the same locus (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>).</p>
    <p>All state-of-the-art variant calling methods are designed to analyze genomic regions individually and discard or downweight reads with low mapping quality. In LCRs, a significant fraction of reads can be mapped to the incorrect location or have zero mapping quality. Therefore, variant calling on each repeat copy individually cannot achieve high precision and recall. For high accuracy, joint analysis of reads mapped to all homologous repeat copies is necessary. This strategy has proven to be successful in estimating copy number with high accuracy at LCR loci (<xref rid="btad268-B31" ref-type="bibr">Sudmant et al. 2010</xref>; <xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>). Several approaches that re-map reads to a single copy of the repeat (and mask out other copies before read mapping) and perform variant calling with higher ploidy (<xref rid="btad268-B8" ref-type="bibr">Cummings et al. 2017</xref>; <xref rid="btad268-B13" ref-type="bibr">Gould et al. 2018</xref>; <xref rid="btad268-B3" ref-type="bibr">Boisson et al. 2019</xref>; <xref rid="btad268-B11" ref-type="bibr">Ebbert et al. 2019</xref>) have been developed to enable the detection of disease mutations in duplicated genes. Although this approach increases sensitivity for variant detection, it is challenging to estimate the genotypes for each variant across the different repeat copies.</p>
    <p>In this article, we describe a multilocus variant calling method, ParascopyVC, that addresses three challenges associated with variant calling in LCRs: (i) ambiguity in read mapping, (ii) presence of PSVs that are polymorphic, and (iii) presence of copy number changes. ParascopyVC combines two methodological innovations: (i) aggregating reads mapped to different repeat copies to enable highly sensitive detection of variant sites and (ii) identification of informative PSVs that can differentiate repeat copies for paralog-specific genotyping at variant sites. For variant discovery, it leverages an existing variant calling tool, FreeBayes, to jointly analyze all reads mapped to the different repeat copies. ParascopyVC uses paralog-specific copy number estimated from WGS reads using Parascopy (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>) to model the ploidy of paralog-specific genotypes. We benchmarked ParascopyVC using simulated data and whole-genome WGS data for seven human individuals, for which high-quality variant call sets in LCRs were recently published by the GIAB consortium. Our results demonstrate that ParascopyVC significantly outperforms state-of-the-art variant callers both in precision and recall in LCR regions.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>We consider a LCR region <italic toggle="yes">L</italic> with a total of <italic toggle="yes">n</italic> repeat copies (including the region <italic toggle="yes">L</italic>) in the reference genome. The input data are a set of WGS reads mapped to the reference genome (assumed to be diploid for our method). Let <italic toggle="yes">R</italic> denote the subset of reads that overlap any of the repeat copies of <italic toggle="yes">L</italic>. The goal of small variant calling is to identify positions in the regions of interest (the repeat copies) that differ from the reference and to estimate the most probable genotype for each variant. Standard variant calling tools analyze each repeat copy separately and identify variants by examining reads aligned to the reference genome. However, in LCRs, many reads are mapped ambiguously (multiple identical alignment possibilities) or even mapped to an incorrect repeat copy. This results in a large number of both false negative and false positive variant calls. To solve this problem, ParascopyVC jointly analyzes reads mapped to all repeat copies for variant discovery and genotyping.</p>
    <sec>
      <title>2.1 Definitions</title>
      <p>We introduce a set of terms and notations that will be useful for the description of ParascopyVC. Since we consider variants jointly across all repeat copies, a variant is characterized by an <italic toggle="yes">n</italic>-tuple of genomic positions (one for each repeat copy) and an allele set <italic toggle="yes">A</italic>. These “paralogous positions” can be identified using multiple sequence alignment of the reference sequence for the repeat copies (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>). In the reference genome, variant <italic toggle="yes">v</italic> exhibits allele <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> on <italic toggle="yes">i</italic>th repeat copy of the duplication. If the variant <italic toggle="yes">v</italic> is a PSV, then <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>≠</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> for some <italic toggle="yes">i</italic>, <italic toggle="yes">j</italic>. For a PSV <italic toggle="yes">v</italic>, <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the frequency of the reference allele <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> in the population on the <italic toggle="yes">i</italic>th repeat copy.</p>
      <p>Paralog-specific copy number of a sample <italic toggle="yes">s</italic> is a tuple <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">N</mml:mi></mml:mrow><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Each element of the tuple <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> stands for the number of times the <italic toggle="yes">i</italic>th repeat copy appears in the genomic sequence of the sample. Aggregate copy number <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the sum of paralog-specific copy numbers across all repeat copies. In certain cases, paralog-specific copy number values are not available for all repeat copies. In such cases, we call variants on <italic toggle="yes">extended</italic> repeat copies (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods 2.1</xref> for details).</p>
      <p>Aggregate genotype <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of a variant <italic toggle="yes">v</italic> in the sample <italic toggle="yes">s</italic> is a multiset of <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> alleles—such genotype collects variant alleles across all repeat copies without any specific order and can contain the same allele many times. A paralog-specific genotype <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is a tuple of <italic toggle="yes">n</italic> allele multisets, where the <italic toggle="yes">i</italic>th multiset contains <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> alleles. Paralog-specific genotype of a variant refers to the <italic toggle="yes">n</italic>-tuple of genotypes for the variant across the <italic toggle="yes">n</italic> repeat copies. We will use multiplicity function <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mo>μ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to denote the number of occurrences of an element <italic toggle="yes">z</italic> in the multiset <italic toggle="yes">Z</italic>.</p>
      <p>As an example, consider a two-copy LCR and a sample <italic toggle="yes">s</italic> with aggregate copy number <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> and paralog-specific copy number <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. One possible aggregate genotype of a variant <italic toggle="yes">v</italic> with two alleles <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> would be <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>G</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula> and one possible paralog-specific genotype would be <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>G</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Each paralog-specific genotype is associated with a single aggregate genotype, obtained by combining all multisets <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">vsi</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. A paralog-specific genotype <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is <italic toggle="yes">reference-compatible</italic>, if, for all <italic toggle="yes">i</italic>, multiset <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">vsi</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> contains only the reference allele <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>; in other words, if <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mo>μ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">vsi</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.2 Algorithm</title>
      <p>We assume that PSVs have been identified in advance using multiple sequence alignment of the reference sequences for the repeat copies. We also assume that paralog-specific and aggregate copy numbers for the repeat copies are known for the sample. Our previously developed copy number estimation tool, Parascopy (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>), identifies PSVs; estimates allele frequencies <italic toggle="yes">f</italic> for each PSV; and calculates paralog-specific copy number using WGS data. For a region <italic toggle="yes">L</italic> with <italic toggle="yes">n</italic> copies, variant calling using ParascopyVC proceeds in three steps.</p>
      <p>The first step is the identification of candidate variant sites with high sensitivity using “aggregate variant calling”. For this, we re-map reads from all repeat copies to a single copy (<italic toggle="yes">L</italic>) and use polyploid variant calling—with ploidy equal to the aggregate copy number—to call variants. Note that this re-mapping is done locally and does not involve global re-mapping of reads. This process is illustrated in <xref rid="btad268-F1" ref-type="fig">Fig. 1a</xref> for a two-copy duplication. This enables the use of all reads, regardless of mapping quality, for sensitive variant detection.</p>
      <fig position="float" id="btad268-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Illustration of multilocus variant calling approach in LCRs. The figure shows a two-copy LCR with repeat copies A (blue) and B (yellow). (a) The reads initially aligned to Copy B are remapped to Copy A for aggregate variant calling and three variants (<inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>) are identified. (b) Reference sequences of copies A and B differ at two PSVs (<inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>). Using population reference allele frequencies and aggregate genotype information, the PSV <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is determined to be informative while <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is not. Reads that overlap variant <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and the informative PSV <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> indicate that the <italic toggle="yes">G</italic> allele of variant <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is present on copy <italic toggle="yes">A</italic> (paralog-specific genotype for <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). Paralog-specific genotype for variant <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is not inferred due to the lack of an informative PSV.</p>
        </caption>
        <graphic xlink:href="btad268f1" position="float"/>
      </fig>
      <p>Second, we “identify informative PSVs”—PSVs whose paralog-specific genotypes are identical to the reference for the sample. For each variant <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, we estimate the most likely aggregate genotype <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> using the aggregated reads independent of other variants. For PSVs, we calculate paralog-specific genotype probabilities based on the aggregate genotype likelihoods and by using reference allele frequencies <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in order to calculate paralog-specific genotype priors. PSVs with reference-compatible paralog genotypes are marked as <italic toggle="yes">informative</italic>. In the example shown in <xref rid="btad268-F1" ref-type="fig">Fig. 1b</xref>, PSV <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is informative (paralog-specific genotype = <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>/</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, same as reference), while PSV <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is not.</p>
      <p>The third and final step in ParascopyVC is “paralog-specific genotyping” of all variants using informative PSVs and paired reads that overlap both informative PSVs and variants. For variant <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> in <xref rid="btad268-F1" ref-type="fig">Fig. 1b</xref>, the most-likely aggregate genotype is <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:math></inline-formula>. Hence, there are two possible paralog-specific genotypes: <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for this variant. Since there are reads that overlap both PSV <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and variant <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> have the alleles <italic toggle="yes">G</italic> and <italic toggle="yes">T</italic> at the two sites respectively, we can estimate the paralog-specific genotypes for <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> to be <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>/</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Note that paralog-specific genotypes cannot be estimated for variants that are not covered by reads that also overlap informative PSVs, e.g. variant <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> in <xref rid="btad268-F1" ref-type="fig">Fig. 1b</xref>.</p>
      <p>Next, we describe the mathematical details of the three steps of the algorithm.</p>
    </sec>
    <sec>
      <title>2.3 Step 1: aggregate variant calling</title>
      <p>During its first stage, the copy number estimation method Parascopy (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>) identifies regions homologous to <italic toggle="yes">L</italic> using a pre-computed homology table and re-maps reads from them back to <italic toggle="yes">L</italic>. Our variant calling method, ParascopyVC, uses this same approach to re-map reads and then runs an existing variant calling tool FreeBayes (<xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>) on the pooled reads with ploidy <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We modify the resulting set of aggregate variants by removing all variants with low quality (<inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>), and by extending the set to include all PSVs. For each variant <italic toggle="yes">v</italic>, we calculate the allelic read depth <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> across the variant alleles <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in the pooled reads <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> overlapping the variant. The aggregate genotype probabilities are calculated using <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the multinomial distribution (MN) as follows:
and where <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula> is the error rate, <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the full set of alleles, <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>r</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is mean read length, <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>a</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is the allele length, and <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mo>μ</mml:mo></mml:math></inline-formula> is the multiplicity function. The calculations are consistent with the polyploid genotype likelihood calculations used in FreeBayes (<xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>). Finally, we use Bayes’ theorem to get the aggregate genotype probability:
</p>
      <disp-formula id="E1">
        <label>(1)</label>
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>P</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>X</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo> </mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>g</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>P</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mtext>MN</mml:mtext>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>X</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>;</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="fraktur">p</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>a</mml:mi>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>g</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:mo>…</mml:mo>
            <mml:mo>,</mml:mo>
            <mml:mi mathvariant="fraktur">p</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>a</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mo>|</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>A</mml:mi>
                  </mml:mrow>
                  <mml:mi>v</mml:mi>
                </mml:msub>
                <mml:mo>|</mml:mo>
              </mml:mrow>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>g</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E2">
        <label>(2)</label>
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtext>where</mml:mtext>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="fraktur">p</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>a</mml:mi>
            <mml:mo>,</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mrow>
              <mml:mover accent="true">
                <mml:mi>g</mml:mi>
                <mml:mo>^</mml:mo>
              </mml:mover>
            </mml:mrow>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>r</mml:mi>
                    <mml:mo>¯</mml:mo>
                  </mml:mover>
                </mml:mrow>
                <mml:mo>|</mml:mo>
                <mml:mo>−</mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mi>a</mml:mi>
                <mml:mo>|</mml:mo>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>⋅</mml:mo>
                <mml:mi>max</mml:mi>
                <mml:mrow>
                  <mml:mo>{</mml:mo>
                  <mml:mrow>
                    <mml:mo>ϵ</mml:mo>
                    <mml:mo>⋅</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>c</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:mo>μ</mml:mo>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>a</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                      </mml:mrow>
                      <mml:mo>′</mml:mo>
                    </mml:msup>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>A</mml:mi>
                      </mml:mrow>
                      <mml:mi>v</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:mrow>
                    <mml:mover accent="true">
                      <mml:mi>r</mml:mi>
                      <mml:mo>¯</mml:mo>
                    </mml:mover>
                  </mml:mrow>
                  <mml:mo>|</mml:mo>
                  <mml:mo>−</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                    </mml:mrow>
                    <mml:mo>′</mml:mo>
                  </mml:msup>
                  <mml:mo>|</mml:mo>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>⋅</mml:mo>
                <mml:mi>max</mml:mi>
                <mml:mrow>
                  <mml:mo>{</mml:mo>
                  <mml:mrow>
                    <mml:mo>ϵ</mml:mo>
                    <mml:mo>⋅</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>c</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mi>s</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:mo>μ</mml:mo>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                      </mml:mrow>
                      <mml:mo>′</mml:mo>
                    </mml:msup>
                    <mml:mo>,</mml:mo>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
              </mml:mrow>
            </mml:mfrac>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E3">
        <label>(3)</label>
        <mml:math id="M3" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>P</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mrow>
                  <mml:mover accent="true">
                    <mml:mi>g</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo> </mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>X</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:mi>p</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>⋅</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>X</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>g</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>′</mml:mo>
                    </mml:msup>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>G</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>p</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo>′</mml:mo>
                </mml:msup>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>⋅</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>X</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:msup>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mi>g</mml:mi>
                        <mml:mo>^</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo>′</mml:mo>
                </mml:msup>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Note that the set of aggregate genotypes <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> depends on the set of alleles <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and aggregate copy number <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Additionally, we select equal aggregate genotype priors <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>G</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. In order to improve genotyping accuracy, allele observations with base qualities less than 10 and all partial allele observations are discarded.</p>
    </sec>
    <sec>
      <title>2.4 Step 2: identify informative PSVs</title>
      <p>For PSVs, the prior probability of paralog-specific genotypes can be obtained using the PSV reference allele frequencies <italic toggle="yes">f</italic>:
</p>
      <disp-formula id="E4">
        <label>(4)</label>
        <mml:math id="M4" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>P</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>g</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>;</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>f</mml:mi>
              </mml:mrow>
              <mml:mi>v</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munderover>
              <mml:mo>∏</mml:mo>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mi>n</mml:mi>
            </mml:munderover>
            <mml:mrow>
              <mml:msubsup>
                <mml:mrow>
                  <mml:mi>f</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>v</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo> </mml:mo>
                  <mml:mo>μ</mml:mo>
                  <mml:mrow>
                    <mml:mo>(</mml:mo>
                    <mml:mrow>
                      <mml:msubsup>
                        <mml:mrow>
                          <mml:mi>a</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>v</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                        <mml:mo>*</mml:mo>
                      </mml:msubsup>
                      <mml:mo>,</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>g</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi mathvariant="italic">vsi</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mo>)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
              </mml:msubsup>
            </mml:mrow>
            <mml:mo>×</mml:mo>
            <mml:msup>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>−</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>f</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>v</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mo> </mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>c</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>s</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>−</mml:mo>
                <mml:mo>μ</mml:mo>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:msubsup>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mo>*</mml:mo>
                    </mml:msubsup>
                    <mml:mo>,</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>g</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="italic">vsi</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
            </mml:msup>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>In other words, the prior of the paralog-specific genotype <italic toggle="yes">g</italic> is a product of either <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> depending on the match between the genotype alleles and the reference alleles of the PSV <italic toggle="yes">v</italic>.</p>
      <p>For each PSV, we calculate the probability of paralog-specific genotype <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> based on the PSV allele frequencies <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the probability of its associate aggregate genotype <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>:
where <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the full set of paralog-specific genotypes associated with the aggregate genotype <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>g</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
      <disp-formula id="E5">
        <label>(5)</label>
        <mml:math id="M5" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtable>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>g</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo> </mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>X</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>;</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>f</mml:mi>
                      </mml:mrow>
                      <mml:mi>v</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>g</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo> </mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>X</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>⋅</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>g</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo> </mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>g</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mover accent="true">
                            <mml:mi>g</mml:mi>
                            <mml:mo>^</mml:mo>
                          </mml:mover>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo> </mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mo> </mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>X</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>⋅</mml:mo>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mi>P</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>g</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>v</mml:mi>
                            <mml:mi>s</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>;</mml:mo>
                        <mml:mo> </mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>f</mml:mi>
                          </mml:mrow>
                          <mml:mi>v</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:munder>
                          <mml:mo>∑</mml:mo>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mi>g</mml:mi>
                              </mml:mrow>
                              <mml:mo>′</mml:mo>
                            </mml:msup>
                            <mml:mo>∈</mml:mo>
                            <mml:mi>G</mml:mi>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mrow>
                                  <mml:mover accent="true">
                                    <mml:mi>g</mml:mi>
                                    <mml:mo>^</mml:mo>
                                  </mml:mover>
                                </mml:mrow>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>v</mml:mi>
                                <mml:mi>s</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:munder>
                        <mml:mi>P</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mi>g</mml:mi>
                          </mml:mrow>
                          <mml:mo>′</mml:mo>
                        </mml:msup>
                        <mml:mo>;</mml:mo>
                        <mml:mo> </mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>f</mml:mi>
                          </mml:mrow>
                          <mml:mi>v</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mfrac>
                    <mml:mo>.</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>We say that the PSV <italic toggle="yes">v</italic> is <italic toggle="yes">informative</italic> for a sample <italic toggle="yes">s</italic> if the most likely paralog-specific genotype for sample <italic toggle="yes">s</italic> has high posterior probability (<inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>0.99</mml:mn></mml:mrow></mml:math></inline-formula> by default) and is reference-compatible. Such PSVs can be used to differentiate reads originating from different repeat copies with high confidence.</p>
      <p>Filtering out noninformative PSVs:</p>
      <p>The estimation of paralog-specific genotypes for PSVs does not utilize information from read-pairs that cover more than one PSV since this greatly increases the computational complexity of the likelihood calculations. As a result, read-pairs that cover multiple informative PSVs can sometimes conflict with the reference genotype for a pair of informative PSVs. Such conflicts indicate that one of the two PSVs is not informative. For each pair of informative PSVs covered by at least three reads, we tabulate the read-allele counts for the pair and use a one-tailed Binomial test (<inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mo>π</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>ϵ</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>ϵ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">P</italic> value threshold of <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) to identify conflicting PSVs.</p>
      <p>Next, we construct an undirected graph on the set of informative PSVs with edges between conflicting PSVs. Then we aim to keep a subset of informative PSVs such that the remaining graph contains no edges and <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is maximal, where <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>—the minimal frequency <italic toggle="yes">f</italic> of the PSV <italic toggle="yes">v</italic> across all repeat copies. This problem is equivalent to an NP-complete weighted maximum clique problem (<xref rid="btad268-B15" ref-type="bibr">Karp 1972</xref>). Therefore, we employ the following greedy heuristic: until the graph is edgeless, we iteratively remove the PSV <italic toggle="yes">v</italic> that has the maximal number of edges multiplied by <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.5 Step 3: estimate paralog-specific genotypes</title>
      <p>For new variants, we infer paralog-specific genotypes using read-pairs that overlap the variant and an informative PSV (or, possibly, a nonduplicated region of the genome). For each read-pair <italic toggle="yes">r</italic>, we determine the set of possible read locations (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods 2.2</xref>) across all repeat copies, and then estimate read-pair location probabilities <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using the informative PSVs (denoted by <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) covered by the read pair <italic toggle="yes">r</italic>. Here, <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the probability that location <italic toggle="yes">i</italic> is the true origin of read-pair <italic toggle="yes">r</italic>. Suppose a PSV <italic toggle="yes">v</italic> has allele <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> on the <italic toggle="yes">i</italic>th repeat copy, then we assign <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to either <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mo>ϵ</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula> (error rate) depending upon whether the read sequence matches or does not match the allele <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, respectively. Location priors are estimated based on the paralog-specific copy numbers <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which results in the following formula for <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>:
</p>
      <disp-formula id="E6">
        <label>(6)</label>
        <mml:math id="M6" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msub>
              <mml:mrow>
                <mml:mi>p</mml:mi>
              </mml:mrow>
              <mml:mi>r</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>c</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>s</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:munder>
                  <mml:mo>∏</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>W</mml:mi>
                      </mml:mrow>
                      <mml:mi>r</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>a</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mi>r</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:munderover>
                  <mml:mo>∑</mml:mo>
                  <mml:mrow>
                    <mml:mi>j</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mi>n</mml:mi>
                </mml:munderover>
                <mml:mrow>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>c</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>s</mml:mi>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:munder>
                  <mml:mo>∏</mml:mo>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>W</mml:mi>
                      </mml:mrow>
                      <mml:mi>r</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>a</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mi>r</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>If a PSV <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is missing from one of the repeat copies <italic toggle="yes">j</italic> because the copy is shorter than others, we penalize location probability <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by setting <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to a small number (<inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>ϵ</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> by default).</p>
      <p>Finally, paralog-specific genotype probabilities are calculated according to the read-pair location probabilities <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and the read–variant allele observations. Suppose the read-pair <italic toggle="yes">r</italic> has sequence <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> aligned to the variant <italic toggle="yes">v</italic>, then we can describe the probability of read-pair <italic toggle="yes">r</italic> according to the paralog-specific genotype <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>:
</p>
      <disp-formula id="E7">
        <label>(7)</label>
        <mml:math id="M7" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>P</mml:mi>
            <mml:mo>(</mml:mo>
            <mml:mi>r</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mi>g</mml:mi>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo>)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munderover>
              <mml:mo>∑</mml:mo>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mi>n</mml:mi>
            </mml:munderover>
            <mml:mfrac>
              <mml:mrow>
                <mml:msub>
                  <mml:mi>p</mml:mi>
                  <mml:mi>r</mml:mi>
                </mml:msub>
                <mml:mo>(</mml:mo>
                <mml:mi>i</mml:mi>
                <mml:mo>)</mml:mo>
              </mml:mrow>
              <mml:msub>
                <mml:mi>c</mml:mi>
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
            </mml:mfrac>
            <mml:mo> </mml:mo>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mo>(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:mo>ϵ</mml:mo>
              <mml:mo>)</mml:mo>
              <mml:mo>⋅</mml:mo>
              <mml:mo>μ</mml:mo>
              <mml:mrow>
                <mml:mo>(</mml:mo>
                <mml:msub>
                  <mml:mi>a</mml:mi>
                  <mml:mi>r</mml:mi>
                </mml:msub>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mi>g</mml:mi>
                  <mml:mi mathvariant="italic">vsi</mml:mi>
                </mml:msub>
                <mml:mo>)</mml:mo>
              </mml:mrow>
              <mml:mo>+</mml:mo>
              <mml:mo>ϵ</mml:mo>
              <mml:mo>⋅</mml:mo>
              <mml:mo>[</mml:mo>
              <mml:msub>
                <mml:mi>c</mml:mi>
                <mml:mrow>
                  <mml:mi>s</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mrow>
              </mml:msub>
              <mml:mo>−</mml:mo>
              <mml:mo>μ</mml:mo>
              <mml:mrow>
                <mml:mo>(</mml:mo>
                <mml:msub>
                  <mml:mi>a</mml:mi>
                  <mml:mi>r</mml:mi>
                </mml:msub>
                <mml:mo>,</mml:mo>
                <mml:msub>
                  <mml:mi>g</mml:mi>
                  <mml:mi mathvariant="italic">vsi</mml:mi>
                </mml:msub>
                <mml:mo>)</mml:mo>
              </mml:mrow>
              <mml:mo>]</mml:mo>
              <mml:mo>)</mml:mo>
              <mml:mo>.</mml:mo>
            </mml:mrow>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Additionally, we can evaluate the probability of each genotype <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> given the set of read pairs <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that cover the variant <italic toggle="yes">v</italic>:
</p>
      <disp-formula id="E8">
        <label>(8)</label>
        <mml:math id="M8" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>P</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>g</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo> </mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>R</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mfrac>
              <mml:mrow>
                <mml:mi>p</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>⋅</mml:mo>
                <mml:munder>
                  <mml:mo>∏</mml:mo>
                  <mml:mrow>
                    <mml:mi>r</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>r</mml:mi>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>g</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>v</mml:mi>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
              <mml:mrow>
                <mml:munder>
                  <mml:mo>∑</mml:mo>
                  <mml:mi>g</mml:mi>
                </mml:munder>
                <mml:mi>p</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>g</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>⋅</mml:mo>
                <mml:munder>
                  <mml:mo>∏</mml:mo>
                  <mml:mrow>
                    <mml:mi>r</mml:mi>
                    <mml:mo>∈</mml:mo>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mi>s</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:munder>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>r</mml:mi>
                <mml:mo> </mml:mo>
                <mml:mo>|</mml:mo>
                <mml:mo> </mml:mo>
                <mml:mi>g</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:mfrac>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Paralog-specific genotype probabilities <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are later converted into genotype and variant qualities (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods 2.3</xref>). Paralog-specific genotype priors for PSVs are described in <xref rid="E4" ref-type="disp-formula">Equation (4)</xref>. For novel non-PSV variants, we define priors <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in the following way:
</p>
      <disp-formula id="E9">
        <label>(9)</label>
        <mml:math id="M9" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>p</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>g</mml:mi>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>v</mml:mi>
                <mml:mi>s</mml:mi>
              </mml:mrow>
            </mml:msub>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:munderover>
              <mml:mo>∏</mml:mo>
              <mml:mrow>
                <mml:mi>i</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mi>n</mml:mi>
            </mml:munderover>
            <mml:mrow>
              <mml:mrow>
                <mml:mo stretchy="true">{</mml:mo>
                <mml:mrow>
                  <mml:mtable>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mn>1</mml:mn>
                          <mml:mo>−</mml:mo>
                          <mml:mo>ξ</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mtext>if</mml:mtext>
                          <mml:mo> </mml:mo>
                          <mml:mo>μ</mml:mo>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:msubsup>
                            <mml:mrow>
                              <mml:mi>a</mml:mi>
                            </mml:mrow>
                            <mml:mi>v</mml:mi>
                            <mml:mo>*</mml:mo>
                          </mml:msubsup>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>g</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi mathvariant="italic">vsi</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>=</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>c</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>s</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo>,</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr columnalign="left">
                      <mml:mtd columnalign="left">
                        <mml:mo>ξ</mml:mo>
                      </mml:mtd>
                      <mml:mtd columnalign="left">
                        <mml:mrow>
                          <mml:mtext>if</mml:mtext>
                          <mml:mo> </mml:mo>
                          <mml:mo>μ</mml:mo>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:msubsup>
                            <mml:mrow>
                              <mml:mi>a</mml:mi>
                            </mml:mrow>
                            <mml:mi>v</mml:mi>
                            <mml:mo>*</mml:mo>
                          </mml:msubsup>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>g</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi mathvariant="italic">vsi</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>≠</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>c</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>s</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo>.</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mrow>
              </mml:mrow>
            </mml:mrow>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>In other words, each repeat copy genotype <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">vsi</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is penalized by the mutation rate <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mo>ξ</mml:mo></mml:math></inline-formula> (default: <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) if nonreference allele is present, and where homozygous and heterozygous genotypes are penalized equally.</p>
      <p>To reduce the number of false positive variants due to strand-bias in sequencing data (<xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>), we apply Fisher’s exact test (FET) to the <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> table corresponding to the reads counts for the reference and nonreference alleles on the two DNA strands. Variants with a FET <italic toggle="yes">P</italic> value less than .01 are filtered out.</p>
    </sec>
    <sec>
      <title>2.6 Simulated and real WGS datasets</title>
      <p>To benchmark the accuracy of ParascopyVC, we generated two simulated WGS datasets, one with and the other without polymorphic PSVs, which we denote as SIM-Poly and SIM-Fixed, respectively. We did not simulate changes in copy number since variant callers such as DeepVariant (<xref rid="btad268-B28" ref-type="bibr">Poplin et al. 2018a</xref>)—which we used for benchmarking—only support variant calling in diploid genomes. In case of the SIM-Fixed dataset, we simulated a diploid genome by adding artificial sequence variants every one kilobase on average (80% substitutions, 10% insertions, and 10% deletions; 61.5% heterozygous variants). Rates of different variant types were selected to be similar to the variant rates in the GIAB high-confidence variant calls for the HG002 individual (<xref rid="btad268-B36" ref-type="bibr">Zook et al. 2014</xref>, <xref rid="btad268-B37" ref-type="bibr">2016</xref>, <xref rid="btad268-B38" ref-type="bibr">2019</xref>). All simulated variants overlapping PSVs were discarded.</p>
      <p>For the SIM-Poly dataset—designed to assess the accuracy of variant calling in the presence of polymorphic PSVs—we simulated WGS reads from a diploid genome with variants that overlapped PSVs. Polymorphic PSVs were simulated according to PSV reference allele frequencies (<italic toggle="yes">f</italic>) in the 503 European ancestry samples from the 1000 Genomes Project (1 kGP) (<xref rid="btad268-B1" ref-type="bibr">1000 Genomes Project Consortium et al. 2015</xref>), calculated by Parascopy <monospace>v1.7</monospace> (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>). Next, we combined the resulting variant set with the SIM-Fixed variant set to obtain <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.75</mml:mn><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> variants. Finally, for both datasets we used ART Illumina (<xref rid="btad268-B14" ref-type="bibr">Huang et al. 2012</xref>) read simulator tool <monospace>v2016-06-05</monospace> to generate two diploid paired-end datasets for chromosomes 1–22 with 150 bp reads, <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mn>30</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> coverage and mean fragment size = 500 bp. We then used BWA-MEM <monospace>v0.7.17</monospace> (<xref rid="btad268-B24" ref-type="bibr">Li and Durbin 2009</xref>; <xref rid="btad268-B22" ref-type="bibr">Li 2013</xref>) to map the simulated reads to the GRCh38 reference genome.</p>
      <p>In addition to the simulated WGS datasets, we utilized high-confidence variant call sets for seven human genomes (HG001–HG007) constructed by the GIAB Consortium (<xref rid="btad268-B36" ref-type="bibr">Zook et al. 2014</xref>, <xref rid="btad268-B37" ref-type="bibr">2016</xref>, <xref rid="btad268-B38" ref-type="bibr">2019</xref>). The latest version (v4.2.1) of these variant calls leverage long-read sequence datasets to enable accurate variant calls in repetitive regions of the genome that include a large number of LCRs (<xref rid="btad268-B34" ref-type="bibr">Wagner et al. 2022</xref>). For each individual genome, we analyzed Illumina WGS data that is also made available by the GIAB. The WGS datasets for HG005, HG006, and HG007 genomes had very high coverage (<inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>100</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula>) and were sub-sampled using samtools <monospace>v1.14</monospace> (<xref rid="btad268-B9" ref-type="bibr">Danecek et al. 2021</xref>) to obtain <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>30</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> sequence coverage. We mapped all WGS datasets to the GRCh38 reference genome using BWA-MEM <monospace>v0.7.17</monospace>. PacBio HiFi WGS data for HG002 (30-fold coverage, mapped to GRCh38) was also obtained from the GIAB.</p>
    </sec>
    <sec>
      <title>2.7 Variant calling benchmarking</title>
      <p>In order to evaluate variant calling, we utilized a set of 167 LCR loci that we previously compiled for copy number analysis (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>). These LCR loci were selected from a genome-wide analysis and each locus in this set overlaps at least one protein-coding gene. Across all repeat copies, the 167 loci span 10.95 Mb of DNA sequence and overlap 380 protein-coding genes. Three variant calling tools—FreeBayes <monospace>v1.3.5</monospace> (<xref rid="btad268-B12" ref-type="bibr">Garrison and Marth 2012</xref>), GATK HaplotypeCaller <monospace>v4.2.2</monospace> (<xref rid="btad268-B29" ref-type="bibr">Poplin et al. 2018b</xref>), and DeepVariant <monospace>v1.4</monospace> (<xref rid="btad268-B28" ref-type="bibr">Poplin et al. 2018a</xref>)—were used for comparison with ParascopyVC. For the HG002 genome, we additionally benchmarked variant calling accuracy on all LCR regions from chromosomes 15, 16, and 17.</p>
      <p>We calculated precision and recall using RTG tools <monospace>v3.12.1</monospace> (<xref rid="btad268-B5" ref-type="bibr">Cleary et al. 2014</xref>, <xref rid="btad268-B6" ref-type="bibr">2015</xref>). To compare precision and recall values across different callers, we selected a single variant quality threshold for each caller separately that maximized its average accuracy across seven benchmarking WGS datasets (HG001–HG007). In LCR loci, small precision improvements are achieved at a cost of large decrease in recall; consequently, the best average <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score was obtained at very low-quality thresholds for the three existing variant callers (<inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, corresponding to virtually no filtering). Therefore, we selected optimal variant quality thresholds based on the <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mn>0.5</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> score, which favors precision over recall. These criteria produced reasonable quality thresholds of 6, 33, 5, and 21 for GATK, FreeBayes, DeepVariant, and ParascopyVC, respectively. These thresholds were used for comparing precision-recall of different methods across all evaluations.</p>
      <p>For ParascopyVC, we calculated aggregate and paralog-specific copy number profiles using Parascopy <monospace>v1.7</monospace> (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>) for each dataset (both simulated and real) prior to variant calling. For each dataset, we selected a set of paralog-specific regions that overlap the high-confidence benchmarking regions for the dataset. Additionally, we filtered out LCRs, for which paralog-specific copy number was not estimated by Parascopy (such as LCRs with five or more copies); and excluded LCRs, for which paralog-specific copy number was different than 2. For each sample, benchmarking was limited to the same regions across all variant calling methods.</p>
      <p>For running ParascopyVC on the SIM-Fixed dataset, we used PSV allele frequencies equal to 0.9999 to model the fact that PSVs were not polymorphic. For the SIM-Poly dataset, we used PSV allele frequencies obtained from the European ancestry samples in the 1000 Genomes project (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>). For the HG001–HG004 and HG005–HG007 datasets, we used PSV allele frequencies obtained from European and East-Asian ancestry samples, respectively. This was consistent with the reported ancestry of these individuals (HG001 is of European ancestry, HG002–HG004 represents an Ashkenazim trio, and HG005–HG007 represent a Han Chinese trio).</p>
      <p>To compare the runtime and memory usage for different methods, we called variants for a single individual across 167 duplicated loci. ParascopyVC uses multiple threads to analyze disjoint duplicated loci, so we tabulated run-time using 1 and 16 threads. Similarly, GATK and DeepVariant allow to use multiple threads. FreeBayes uses only one thread, although it can be externally parallelized over independent loci.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Accuracy of variant calling on simulated data</title>
      <p>For the SIM-Fixed dataset (no polymorphic PSVs), the benchmarking regions covered 9.9 Mb of DNA sequence and included 9254 ground truth variants. On this dataset, FreeBayes, GATK, and ParascopyVC had very high precision (0.997) and similar recall (0.835, 0.886, and 0.872, respectively) (see <xref rid="btad268-F2" ref-type="fig">Fig. 2a</xref>). This was not surprising since standard variant calling methods rely on accurately mapped reads and in the absence of polymorphic PSVs and copy number variation, read mapping is reliable. DeepVariant had slightly lower precision (0.995) and recall (0.815) values.</p>
      <fig position="float" id="btad268-F2">
        <label>Figure 2.</label>
        <caption>
          <p>Precision and recall of variant calling for four variant callers (GATK, FreeBayes, DeepVariant, and ParascopyVC) on two simulated WGS datasets. Variant quality thresholds used for comparing precision/recall are marked with circles on each curve. (a) Simulated dataset SIM-Fixed (all PSVs are nonpolymorphic). (b) Simulated dataset SIM-Poly (some PSVs are polymorphic). The solid (dashed) yellow line shows the precision–recall curve for ParascopyVC using PSV allele frequencies from the European (East Asian) population.</p>
        </caption>
        <graphic xlink:href="btad268f2" position="float"/>
      </fig>
      <p>On the SIM-Poly dataset (18 997 baseline variants) that included polymorphic PSVs, the accuracy of state-of-the-art variant callers was drastically lower than for the SIM-Fixed dataset. GATK, FreeBayes, and DeepVariant had low precision (0.832, 0.920, and 0.956, respectively) and recall (0.738, 0.684, and 0.706) (see <xref rid="btad268-F2" ref-type="fig">Fig. 2b</xref>). ParascopyVC significantly outperformed all methods and achieved high recall (0.807) and very high precision (0.997).</p>
      <p>Since ParascopyVC uses population reference allele frequencies of PSVs for variant calling, the choice of population can potentially impact the accuracy of variant calling. To assess this, we ran ParascopyVC using PSV allele frequencies derived from the East Asian population in the 1000 Genomes Project. ParascopyVC’s accuracy was slightly lower (dashed yellow line in <xref rid="btad268-F2" ref-type="fig">Fig. 2b</xref>) than the accuracy using European allele frequencies but was significantly better than all other methods.</p>
    </sec>
    <sec>
      <title>3.2 Accuracy of variant calling on the HG002 genome</title>
      <p>The GIAB has compiled high-confidence variant call sets for seven human individuals by careful aggregation of variant call sets derived from numerous variant calling tools and multiple sequencing technologies (<xref rid="btad268-B36" ref-type="bibr">Zook et al. 2014</xref>, <xref rid="btad268-B37" ref-type="bibr">2016</xref>, <xref rid="btad268-B38" ref-type="bibr">2019</xref>). The HG002 genome is the most studied of the seven GIAB datasets and therefore, we first benchmarked our method on this genome. The overlap between the GIAB high-confidence benchmarking regions for the HG002 genome and the 167 LCR loci covered 7.35 Mb of DNA sequence. After excluded regions where Parascopy estimated nonreference paralog-specific copy number (0.39 Mb) or was unable to estimate paralog-specific copy number (0.70 Mb), the benchmarking regions covered 6.26 Mb of DNA sequence and contained 7985 ground truth variants.</p>
      <p>Comparison of the variant calling accuracy for the four methods (<xref rid="btad268-F3" ref-type="fig">Fig. 3a</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>) showed that Freebayes and GATK (<inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> scores of 0.883 and 0.880 respectively) had much lower precision and recall values than DeepVariant and ParascopyVC. ParascopyVC correctly called 7255 variants (recall = 0.909) and incorrectly called only 65 variants (precision = 0.991), resulting in a very high <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score of 0.948. In comparison, DeepVariant could achieve high precision (0.983) but had lower recall (0.861) than ParascopyVC, achieving <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score of 0.918. For comparison, we also evaluated the accuracy of DeepVariant calls on <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mn>30</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> long-read HiFi WGS data for the HG002 genome. The HiFi calls had very high precision (0.9985, 12 false positives) and recall (0.991, 73 false negatives).</p>
      <fig position="float" id="btad268-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Precision and recall of variant calling using four callers (GATK, FreeBayes, DeepVariant, ParascopyVC) on the HG002 benchmark dataset. For each caller, circles denote the quality thresholds that maximize the average accuracy across seven human genomes. (a) Precision–recall values across all LCR regions. (b) Precision–recall values across LCR regions split into four groups based on sequence similarity (0.97–0.98, 0.98–0.99, 0.99–0.995, and 0.995–1.0).</p>
        </caption>
        <graphic xlink:href="btad268f3" position="float"/>
      </fig>
      <p>Comparison of the accuracy for SNVs and short indels separately showed that ParascopyVC achieved the best precision (0.995) and best recall (0.914) among all methods for SNVs (<xref rid="btad268-T1" ref-type="table">Table 1</xref>). ParascopyVC’s SNV <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score was 0.953 while the next best <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> score (0.919) was achieved by DeepVariant. For indels, DeepVariant had higher precision (0.978) compared to ParascopyVC (0.972) while both methods had the same recall.</p>
      <table-wrap position="float" id="btad268-T1">
        <label>Table 1.</label>
        <caption>
          <p>Variant calling accuracy for single-nucleotide variants (SNVs) and insertions or deletions (indels) on the HG002 benchmarking WGS dataset.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Variants</th>
              <th rowspan="1" colspan="1">Method</th>
              <th align="center" rowspan="1" colspan="1">FP</th>
              <th align="center" rowspan="1" colspan="1">FN</th>
              <th align="center" rowspan="1" colspan="1">Precision</th>
              <th align="center" rowspan="1" colspan="1">Recall</th>
              <th align="center" rowspan="1" colspan="1">
                <inline-formula id="IE121">
                  <mml:math id="IM121" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi mathvariant="italic">F</mml:mi>
                        </mml:mrow>
                        <mml:mn>1</mml:mn>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="4" colspan="1">SNPs</td>
              <td rowspan="1" colspan="1">GATK</td>
              <td rowspan="1" colspan="1">821</td>
              <td rowspan="1" colspan="1">920</td>
              <td rowspan="1" colspan="1">0.887</td>
              <td rowspan="1" colspan="1">0.875</td>
              <td rowspan="1" colspan="1">0.881</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FreeBayes</td>
              <td rowspan="1" colspan="1">276</td>
              <td rowspan="1" colspan="1">1263</td>
              <td rowspan="1" colspan="1">0.954</td>
              <td rowspan="1" colspan="1">0.828</td>
              <td rowspan="1" colspan="1">0.887</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">DeepVariant</td>
              <td rowspan="1" colspan="1">104</td>
              <td rowspan="1" colspan="1">1017</td>
              <td rowspan="1" colspan="1">0.984</td>
              <td rowspan="1" colspan="1">0.862</td>
              <td rowspan="1" colspan="1">0.919</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParascopyVC</td>
              <td rowspan="1" colspan="1">
                <bold>31</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>634</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.995</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.914</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.953</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="4" colspan="1">Indels</td>
              <td rowspan="1" colspan="1">GATK</td>
              <td rowspan="1" colspan="1">62</td>
              <td rowspan="1" colspan="1">95</td>
              <td rowspan="1" colspan="1">0.895</td>
              <td rowspan="1" colspan="1">0.848</td>
              <td rowspan="1" colspan="1">0.871</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FreeBayes</td>
              <td rowspan="1" colspan="1">33</td>
              <td rowspan="1" colspan="1">147</td>
              <td rowspan="1" colspan="1">0.950</td>
              <td rowspan="1" colspan="1">0.765</td>
              <td rowspan="1" colspan="1">0.848</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">DeepVariant</td>
              <td rowspan="1" colspan="1">
                <bold>12</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>90</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.978</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.856</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.913</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ParascopyVC</td>
              <td rowspan="1" colspan="1">34</td>
              <td rowspan="1" colspan="1">
                <bold>90</bold>
              </td>
              <td rowspan="1" colspan="1">0.972</td>
              <td rowspan="1" colspan="1">
                <bold>0.856</bold>
              </td>
              <td rowspan="1" colspan="1">0.911</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p>The table shows the number of false positive (FP) and negative (FN) variant calls, precision, recall, and <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> scores for 7361 baseline SNPs and 624 baseline indels. Best value in each subtable is printed in bold.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>Next, we evaluated the accuracy of variant calling in LCR regions stratified by sequence similarity. For this, we split the LCR regions into four groups (sequence similarity in the range 0.97–0.98, 0.98–0.99, 0.99–0.995, and 0.995–1.0). The comparison of precision-recall for the different methods showed that ParascopyVC’s accuracy, was greater for LCR regions with higher sequence similarity relative to other methods (<xref rid="btad268-F3" ref-type="fig">Fig. 3b</xref>). Compared to the other three variant callers, ParascopyVC maintained high precision across LCR regions with different sequence similarity. The HG002 high-confidence variant calls included 1016 variants in LCR regions with <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>99</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> sequence similarity. In these regions, ParascopyVC had a very high precision (0.991) and high recall (0.792). DeepVariant’s recall (0.651) and precision (0.959) in these regions were lower compared to its overall recall (0.861) and precision (0.983). The high recall for ParascopyVC in LCR regions with very high sequence similarity is likely because it utilizes all reads (even with a mapping quality of zero) for variant discovery and genotyping.</p>
      <p>To assess the accuracy of ParascopyVC in noncoding LCRs, we performed variant calling in all LCR regions from chromosomes 15, 16, and 17. The benchmarking regions covered 5.85 Mb of DNA sequence and included 6724 high-confidence variants. The relative performance of the different variant callers was similar to that observed in the 167 coding LCRs. ParascopyVC had the best overall precision (0.982) and recall (0.864), DeepVariant achieved similar precision (0.975) but lower recall (0.805) while GATK and Freebayes had much lower accuracy than DeepVariant and ParascopyVC (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref>).</p>
    </sec>
    <sec>
      <title>3.3 Benchmarking variant calling on additional human genomes</title>
      <p>We benchmarked ParascopyVC on the six additional human genomes for which the GIAB consortium has generated high-confidence variant calls. Benchmarking regions across all seven GIAB variant call sets (HG001–HG007) covered between 6.26 Mb and 6.46 Mb of LCR regions and contained between 7.8 and 9.5 thousand variants (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). The precision-recall curves for the six genomes (<xref rid="btad268-F4" ref-type="fig">Fig. 4</xref>) were very similar to that for the HG002 genome and showed that ParascopyVC had consistently higher precision and recall than both GATK and Freebayes. The average precision for ParascopyVC across the seven genomes was 0.987 compared to 0.876, 0.941, and 0.983 for GATK, Freebayes, and DeepVariant, respectively (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). Although the precision for DeepVariant was comparable to that for ParascopyVC, the average recall for DeepVariant (0.844) was much lower than that for ParascopyVC (0.911).</p>
      <fig position="float" id="btad268-F4">
        <label>Figure 4.</label>
        <caption>
          <p>Precision and recall of variant calling using four callers (GATK, FreeBayes, DeepVariant, ParascopyVC) in LCR regions across six human genomes. For each caller, circles denote the quality thresholds that maximize the average accuracy across seven genomes (including HG002).</p>
        </caption>
        <graphic xlink:href="btad268f4" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.4 Run time and memory usage</title>
      <p>On a single individual (HG002) and 167 duplicated loci, FreeBayes called variants in 04:41 (mm: ss) and used approximately 0.5 Gb memory. GATK HaplotypeCaller consumed 10 Gb memory and called variants in 10:21 (1 thread) or 08:57 (16 threads). DeepVariant had similar performance: 3 Gb memory usage and a run-time of 13:09 (1 thread) or 3:25 (16 threads). ParascopyVC required 7 Gb memory and called variants in 80:28 (1 thread) or 16:36 (16 threads). In contrast to existing variant calling tools which run diploid variant calling for human genomes, ParascopyVC performs polyploid variant calling using FreeBayes. Polyploid variant calling and genotyping requires more calculations than diploid variant calling since the number of possible genotypes for a variant site is combinatorial in the ploidy and number of alleles. Consequently, ParascopyVC requires more time compared to other methods.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this article, we have described a new computational method specifically designed for variant calling in LCRs using WGS data. We have demonstrated—using both simulated and real WGS datasets—that this approach significantly improves accuracy of variant calling in LCRs in human genomes. Compared to existing variant callers that call variants in each copy of LCRs separately, ParascopyVC jointly analyzes reads mapped to all repeat copies to first identify candidate variants. Although several methods have previously utilized a similar strategy of aggregating read information for variant calling in LCRs (<xref rid="btad268-B16" ref-type="bibr">Kerzendorfer et al. 2015</xref>; <xref rid="btad268-B11" ref-type="bibr">Ebbert et al. 2019</xref>), ParascopyVC implements an end-to-end variant calling approach that starts from aligned reads (BAM/CRAM files) as input and output variant calls (VCF files). A key feature of ParascopyVC is that it does not assume correctness of the reference genome at PSVs for variant calling. Instead, it leverages population-based reference allele frequencies and read-level information at PSVs to identify those PSVs that can be used to distinguish repeat copies.</p>
    <p>Benchmarking of multiple variant callers in LCR regions showed that DeepVariant had higher precision than both GATK and FreeBayes. DeepVariant is a neural network based variant caller that has been trained using GIAB benchmark calls for human genomes. As per the DeepVariant github FAQ, DeepVariant has potentially learned to filter out false positives in LCRs based on signatures such as excessive read depth, allele bias, or clustering of variants. Nevertheless, ParascopyVC obtains significantly higher recall than DeepVariant while achieving similar precision indicating that direct modeling of LCRs enables high precision and recall.</p>
    <p>ParascopyVC has been developed to complement existing variant calling tools in LCR regions and not replace them. Indeed, it leverages an existing variant caller, FreeBayes, for variant discovery. Currently, it uses a simple constant error-rate based model for calculating genotype likelihoods for indels. This reduces the indel calling precision, particularly in low-complexity sequences with high indel error rate. The indel calling precision can be improved by leveraging error models or annotations from existing variant callers.</p>
    <p>ParascopyVC leverages population reference allele frequencies for PSVs for variant calling. As a result, it does not call variants in regions for which these frequencies are not available. In such regions, variant calling using existing state-of-the-art tools is likely to have low accuracy since a large fraction of PSVs are polymorphic. Our previous analysis of 167 LCR loci (<xref rid="btad268-B30" ref-type="bibr">Prodanov and Bansal 2022</xref>) using 1000 Genomes WGS data has shown that PSV frequencies cannot be estimated for 10–15% of loci. In the future, as long read sequencing data and high-quality genome assemblies become available for a large number of human genomes (<xref rid="btad268-B35" ref-type="bibr">Wang et al. 2022</xref>), these can potentially be used to obtain PSV reference allele frequencies for such loci and improve the accuracy of variant calling.</p>
    <p>ParascopyVC uses estimates of paralog-specific copy number as input and can call variants in the presence of copy number variants. However, we did not evaluate its accuracy in the presence of copy number changes in this article. Benchmarking variant calling in the presence of copy number variants is challenging with short reads since it requires accurate estimates of copy number in addition to accurate variant calls. We plan to explore this in future work.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad268_Supplementary_Data</label>
      <media xlink:href="btad268_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The analyses presented in this article are based on the high-coverage whole genome sequencing data of 1000 Genomes Project samples, available via ENA Study <ext-link xlink:href="https://www.ebi.ac.uk/ena/browser/view/PRJEB31736" ext-link-type="uri">PRJEB31736</ext-link> and <ext-link xlink:href="https://www.ebi.ac.uk/ena/browser/view/PRJEB36890" ext-link-type="uri">PRJEB36890</ext-link>.</p>
  </sec>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> is available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by grants from the National Human Genome Research Institute [NIH; R01HG010149 and R01HG010759].</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad268-B1">
      <mixed-citation publication-type="journal"><collab>1000 Genomes Project Consortium</collab><etal>et al</etal><article-title>A global reference for human genetic variation</article-title>. <source>Nature</source><year>2015</year>;<volume>526</volume>:<fpage>68</fpage>.<pub-id pub-id-type="pmid">26432245</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bailey</surname><given-names>JA</given-names></string-name>, <string-name><surname>Gu</surname><given-names>Z</given-names></string-name>, <string-name><surname>Clark</surname><given-names>RA</given-names></string-name></person-group><etal>et al</etal><article-title>Recent segmental duplications in the human genome</article-title>. <source>Science</source><year>2002</year>;<volume>297</volume>:<fpage>1003</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">12169732</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Boisson</surname><given-names>B</given-names></string-name>, <string-name><surname>Honda</surname><given-names>Y</given-names></string-name>, <string-name><surname>Ajiro</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Rescue of recurrent deep intronic mutation underlying cell type-dependent quantitative NEMO deficiency</article-title>. <source>J Clin Invest</source><year>2019</year>;<volume>129</volume>:<fpage>583</fpage>–<lpage>97</lpage>.<pub-id pub-id-type="pmid">30422821</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>X</given-names></string-name>, <string-name><surname>Sanchis-Juan</surname><given-names>A</given-names></string-name>, <string-name><surname>French</surname><given-names>CE</given-names></string-name></person-group><etal>et al</etal><article-title>Spinal muscular atrophy diagnosis and carrier screening from genome sequencing data</article-title>. <source>Genet Med</source><year>2020</year>;<volume>22</volume>:<fpage>945</fpage>–<lpage>53</lpage>.<pub-id pub-id-type="pmid">32066871</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cleary</surname><given-names>JG</given-names></string-name>, <string-name><surname>Braithwaite</surname><given-names>R</given-names></string-name>, <string-name><surname>Gaastra</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Joint variant and <italic toggle="yes">de novo</italic> mutation identification on pedigrees from high-throughput sequencing data</article-title>. <source>J Comput Biol</source><year>2014</year>;<volume>21</volume>:<fpage>405</fpage>–<lpage>19</lpage>.<pub-id pub-id-type="pmid">24874280</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cleary</surname><given-names>JG</given-names></string-name>, <string-name><surname>Braithwaite</surname><given-names>R</given-names></string-name>, <string-name><surname>Gaastra</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Comparing variant call files for performance benchmarking of next-generation sequencing variant calling pipelines</article-title>. bioRxiv <year>2015</year>;<volume>8</volume>:<fpage>023754</fpage>.</mixed-citation>
    </ref>
    <ref id="btad268-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Clendenning</surname><given-names>M</given-names></string-name>, <string-name><surname>Hampel</surname><given-names>H</given-names></string-name>, <string-name><surname>LaJeunesse</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Long-range PCR facilitates the identification of <italic toggle="yes">PMS2</italic>-specific mutations</article-title>. <source>Hum Mutat</source><year>2006</year>;<volume>27</volume>:<fpage>490</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">16619239</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cummings</surname><given-names>BB</given-names></string-name>, <string-name><surname>Marshall</surname><given-names>JL</given-names></string-name>, <string-name><surname>Tukiainen</surname><given-names>T</given-names></string-name></person-group><etal>et al</etal><article-title>Improving genetic diagnosis in Mendelian disease with transcriptome sequencing</article-title>. <source>Sci Transl Med</source><year>2017</year>;<volume>9</volume>:<fpage>eaal5209</fpage>.<pub-id pub-id-type="pmid">28424332</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Danecek</surname><given-names>P</given-names></string-name>, <string-name><surname>Bonfield</surname><given-names>JK</given-names></string-name>, <string-name><surname>Liddle</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Twelve years of SAMtools and BCFtools</article-title>. <source>GigaScience</source><year>2021</year>;<volume>10</volume>:<fpage>giab008</fpage>.<pub-id pub-id-type="pmid">33590861</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>DePristo</surname><given-names>MA</given-names></string-name>, <string-name><surname>Banks</surname><given-names>E</given-names></string-name>, <string-name><surname>Poplin</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>A framework for variation discovery and genotyping using next-generation DNA sequencing data</article-title>. <source>Nat Genet</source><year>2011</year>;<volume>43</volume>:<fpage>491</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">21478889</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ebbert</surname><given-names>MT</given-names></string-name>, <string-name><surname>Jensen</surname><given-names>TD</given-names></string-name>, <string-name><surname>Jansen-West</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Systematic analysis of dark and camouflaged genes reveals disease-relevant genes hiding in plain sight</article-title>. <source>Genome Biol</source><year>2019</year>;<volume>20</volume>:<fpage>97</fpage>.<pub-id pub-id-type="pmid">31104630</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Garrison</surname><given-names>E</given-names></string-name>, <string-name><surname>Marth</surname><given-names>G.</given-names></string-name></person-group><article-title>Haplotype-based variant detection from short-read sequencing</article-title>. <year>2012</year>;<volume>7</volume></mixed-citation>
    </ref>
    <ref id="btad268-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gould</surname><given-names>GM</given-names></string-name>, <string-name><surname>Grauman</surname><given-names>PV</given-names></string-name>, <string-name><surname>Theilmann</surname><given-names>MR</given-names></string-name></person-group><etal>et al</etal><article-title>Detecting clinically actionable variants in the 3’ exons of <italic toggle="yes">PMS2</italic> via a reflex workflow based on equivalent hybrid capture of the gene and its pseudogene</article-title>. <source>BMC Med Genet</source><year>2018</year>;<volume>19</volume>:<fpage>176</fpage>.<pub-id pub-id-type="pmid">30268105</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Huang</surname><given-names>W</given-names></string-name>, <string-name><surname>Li</surname><given-names>L</given-names></string-name>, <string-name><surname>Myers</surname><given-names>JR</given-names></string-name></person-group><etal>et al</etal><article-title>ART: a next-generation sequencing read simulator</article-title>. <source>Bioinformatics</source><year>2012</year>;<volume>28</volume>:<fpage>593</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">22199392</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Karp</surname><given-names>RM.</given-names></string-name></person-group><part-title>Reducibility among combinatorial problems</part-title>. In: Miller, RE and Thatcher, JW (eds.) <source>Complexity of Computer Computations</source>, Plenum Press, <year>1972</year>, <fpage>85</fpage>–<lpage>103</lpage>.</mixed-citation>
    </ref>
    <ref id="btad268-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kerzendorfer</surname><given-names>C</given-names></string-name>, <string-name><surname>Konopka</surname><given-names>T</given-names></string-name>, <string-name><surname>Nijman</surname><given-names>SM.</given-names></string-name></person-group><article-title>A thesaurus of genetic variation for interrogation of repetitive genomic regions</article-title>. <source>Nucleic Acids Res</source><year>2015</year>;<volume>43</volume>:<fpage>e68</fpage>.<pub-id pub-id-type="pmid">25820428</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kim</surname><given-names>S</given-names></string-name>, <string-name><surname>Scheffler</surname><given-names>K</given-names></string-name>, <string-name><surname>Halpern</surname><given-names>AL</given-names></string-name></person-group><etal>et al</etal><article-title>Strelka2: fast and accurate calling of germline and somatic variants</article-title>. <source>Nat Methods</source><year>2018</year>;<volume>15</volume>:<fpage>591</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">30013048</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Koboldt</surname><given-names>DC.</given-names></string-name></person-group><article-title>Best practices for variant calling in clinical sequencing</article-title>. <source>Genome Med</source><year>2020</year>;<volume>12</volume>:<fpage>91</fpage>.<pub-id pub-id-type="pmid">33106175</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Krusche</surname><given-names>P</given-names></string-name>, <string-name><surname>Trigg</surname><given-names>L</given-names></string-name>, <string-name><surname>Boutros</surname><given-names>PC</given-names></string-name></person-group><etal>et al</etal><article-title>Best practices for benchmarking germline small-variant calls in human genomes</article-title>. <source>Nat Biotechnol</source><year>2019</year>;<volume>37</volume>:<fpage>555</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">30858580</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lefebvre</surname><given-names>S</given-names></string-name>, <string-name><surname>Bürglen</surname><given-names>L</given-names></string-name>, <string-name><surname>Reboullet</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Identification and characterization of a spinal muscular atrophy-determining gene</article-title>. <source>Cell</source><year>1995</year>;<volume>80</volume>:<fpage>155</fpage>–<lpage>65</lpage>.<pub-id pub-id-type="pmid">7813012</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>A statistical framework for SNP calling, mutation discovery, association mapping and population genetical parameter estimation from sequencing data</article-title>. <source>Bioinformatics</source><year>2011</year>;<volume>27</volume>:<fpage>2987</fpage>–<lpage>93</lpage>.<pub-id pub-id-type="pmid">21903627</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM</article-title>. arXiv <year>2013</year>;<volume>4</volume>:<fpage>1303</fpage>.3997.</mixed-citation>
    </ref>
    <ref id="btad268-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>3094</fpage>–<lpage>100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H</given-names></string-name>, <string-name><surname>Durbin</surname><given-names>R.</given-names></string-name></person-group><article-title>Fast and accurate short read alignment with Burrows–Wheeler transform</article-title>. <source>Bioinformatics</source><year>2009</year>;<volume>25</volume>:<fpage>1754</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lopez-Lopez</surname><given-names>D</given-names></string-name>, <string-name><surname>Loucera</surname><given-names>C</given-names></string-name>, <string-name><surname>Carmona</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title><italic toggle="yes">SMN1</italic> copy-number and sequence variant analysis from next-generation sequencing data</article-title>. <source>Hum Mutat</source><year>2020</year>;<volume>41</volume>:<fpage>2073</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">33058415</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mandelker</surname><given-names>D</given-names></string-name>, <string-name><surname>Schmidt</surname><given-names>RJ</given-names></string-name>, <string-name><surname>Ankala</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Navigating highly homologous genes in a molecular diagnostic setting: a resource for clinical next-generation sequencing</article-title>. <source>Genet Med</source><year>2016</year>;<volume>18</volume>:<fpage>1282</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">27228465</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mueller</surname><given-names>M</given-names></string-name>, <string-name><surname>Barros</surname><given-names>P</given-names></string-name>, <string-name><surname>Witherden</surname><given-names>AS</given-names></string-name></person-group><etal>et al</etal><article-title>Genomic pathology of SLE-associated copy-number variation at the <italic toggle="yes">FCGR2C</italic>/<italic toggle="yes">FCGR3B</italic>/<italic toggle="yes">FCGR2B</italic> locus</article-title>. <source>Am J Hum Genet</source><year>2013</year>;<volume>92</volume>:<fpage>28</fpage>–<lpage>40</lpage>.<pub-id pub-id-type="pmid">23261299</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Poplin</surname><given-names>R</given-names></string-name>, <string-name><surname>Chang</surname><given-names>PC</given-names></string-name>, <string-name><surname>Alexander</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>A universal SNP and small-indel variant caller using deep neural networks</article-title>. <source>Nat Biotechnol</source><year>2018a</year>;<volume>36</volume>:<fpage>983</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">30247488</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Poplin</surname><given-names>R</given-names></string-name>, <string-name><surname>Ruano-Rubio</surname><given-names>V</given-names></string-name>, <string-name><surname>DePristo</surname><given-names>MA</given-names></string-name></person-group><etal>et al</etal><article-title>Scaling accurate genetic variant discovery to tens of thousands of samples</article-title>. bioRxiv <year>2018b</year>;<volume>7</volume>:<fpage>201178</fpage>.</mixed-citation>
    </ref>
    <ref id="btad268-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Prodanov</surname><given-names>T</given-names></string-name>, <string-name><surname>Bansal</surname><given-names>V.</given-names></string-name></person-group><article-title>Robust and accurate estimation of paralog-specific copy number for duplicated genes using whole-genome sequencing</article-title>. <source>Nat Commun</source><year>2022</year>;<volume>13</volume>:<fpage>3221</fpage>.<pub-id pub-id-type="pmid">35680869</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sudmant</surname><given-names>PH</given-names></string-name>, <string-name><surname>Kitzman</surname><given-names>JO</given-names></string-name>, <string-name><surname>Antonacci</surname><given-names>F</given-names></string-name></person-group><etal>et al</etal><article-title>Diversity of human copy number variation and multicopy genes</article-title>. <source>Science</source><year>2010</year>;<volume>330</volume>:<fpage>641</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">21030649</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Treangen</surname><given-names>TJ</given-names></string-name>, <string-name><surname>Salzberg</surname><given-names>SL.</given-names></string-name></person-group><article-title>Repetitive DNA and next-generation sequencing: computational challenges and solutions</article-title>. <source>Nat Rev Genet</source><year>2011</year>;<volume>13</volume>:<fpage>36</fpage>–<lpage>46</lpage>.<pub-id pub-id-type="pmid">22124482</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vollger</surname><given-names>MR</given-names></string-name>, <string-name><surname>Guitart</surname><given-names>X</given-names></string-name>, <string-name><surname>Dishuck</surname><given-names>PC</given-names></string-name></person-group><etal>et al</etal><article-title>Segmental duplications and their variation in a complete human genome</article-title>. <source>Science</source><year>2022</year>;<volume>376</volume>:<fpage>eabj6965</fpage>.<pub-id pub-id-type="pmid">35357917</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wagner</surname><given-names>J</given-names></string-name>, <string-name><surname>Olson</surname><given-names>ND</given-names></string-name>, <string-name><surname>Harris</surname><given-names>L</given-names></string-name></person-group><etal>et al</etal><article-title>Curated variation benchmarks for challenging medically relevant autosomal genes</article-title>. <source>Nat Biotechnol</source><year>2022</year>;<volume>40</volume>:<fpage>672</fpage>–<lpage>80</lpage>.<pub-id pub-id-type="pmid">35132260</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname><given-names>T</given-names></string-name>, <string-name><surname>Antonacci-Fulton</surname><given-names>L</given-names></string-name>, <string-name><surname>Howe</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>The human pangenome project: a global resource to map genomic diversity</article-title>. <source>Nature</source><year>2022</year>;<volume>604</volume>:<fpage>437</fpage>–<lpage>46</lpage>.<pub-id pub-id-type="pmid">35444317</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zook</surname><given-names>JM</given-names></string-name>, <string-name><surname>Chapman</surname><given-names>B</given-names></string-name>, <string-name><surname>Wang</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Integrating human sequence data sets provides a resource of benchmark SNP and indel genotype calls</article-title>. <source>Nat Biotechnol</source><year>2014</year>;<volume>32</volume>:<fpage>246</fpage>–<lpage>51</lpage>.<pub-id pub-id-type="pmid">24531798</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zook</surname><given-names>JM</given-names></string-name>, <string-name><surname>Catoe</surname><given-names>D</given-names></string-name>, <string-name><surname>McDaniel</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Extensive sequencing of seven human genomes to characterize benchmark reference materials</article-title>. <source>Sci Data</source><year>2016</year>;<volume>3</volume>:<fpage>160025</fpage>.<pub-id pub-id-type="pmid">27271295</pub-id></mixed-citation>
    </ref>
    <ref id="btad268-B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zook</surname><given-names>JM</given-names></string-name>, <string-name><surname>McDaniel</surname><given-names>J</given-names></string-name>, <string-name><surname>Olson</surname><given-names>ND</given-names></string-name></person-group><etal>et al</etal><article-title>An open resource for accurately benchmarking small variant and reference calls</article-title>. <source>Nat Biotechnol</source><year>2019</year>;<volume>37</volume>:<fpage>561</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">30936564</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
