<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, CA USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6306216</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-18-19394</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0209358</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Computing Systems</subject>
          <subj-group>
            <subject>Quantum Computing</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Programming Languages</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Physics</subject>
          <subj-group>
            <subject>Quantum Mechanics</subject>
            <subj-group>
              <subject>Quantum State</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Mathematics</subject>
          <subj-group>
            <subject>Algebra</subject>
            <subj-group>
              <subject>Linear Algebra</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Physics</subject>
          <subj-group>
            <subject>Quantum Mechanics</subject>
            <subj-group>
              <subject>Quantum Entanglement</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Mathematics</subject>
          <subj-group>
            <subject>Algebra</subject>
            <subj-group>
              <subject>Linear Algebra</subject>
              <subj-group>
                <subject>Eigenvalues</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Physics</subject>
          <subj-group>
            <subject>Thermodynamics</subject>
            <subj-group>
              <subject>Entropy</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Neuroscience</subject>
          <subj-group>
            <subject>Cognitive Science</subject>
            <subj-group>
              <subject>Cognitive Psychology</subject>
              <subj-group>
                <subject>Language</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Psychology</subject>
          <subj-group>
            <subject>Cognitive Psychology</subject>
            <subj-group>
              <subject>Language</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Social Sciences</subject>
        <subj-group>
          <subject>Psychology</subject>
          <subj-group>
            <subject>Cognitive Psychology</subject>
            <subj-group>
              <subject>Language</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>QuantumInformation.jl—A Julia package for numerical computation in quantum information theory</article-title>
      <alt-title alt-title-type="running-head">QuantumInformation.jl—A Julia package for numerical computation in quantum information theory</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Gawron</surname>
          <given-names>Piotr</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Formal analysis</role>
        <role content-type="http://credit.casrai.org/">Funding acquisition</role>
        <role content-type="http://credit.casrai.org/">Investigation</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Supervision</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001"/>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Kurzyk</surname>
          <given-names>Dariusz</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Data curation</role>
        <role content-type="http://credit.casrai.org/">Formal analysis</role>
        <role content-type="http://credit.casrai.org/">Investigation</role>
        <role content-type="http://credit.casrai.org/">Resources</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Supervision</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001"/>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes">
        <contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-0476-7132</contrib-id>
        <name>
          <surname>Pawela</surname>
          <given-names>Łukasz</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Data curation</role>
        <role content-type="http://credit.casrai.org/">Formal analysis</role>
        <role content-type="http://credit.casrai.org/">Investigation</role>
        <role content-type="http://credit.casrai.org/">Resources</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Validation</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001"/>
        <xref ref-type="corresp" rid="cor001">*</xref>
      </contrib>
    </contrib-group>
    <aff id="aff001">
      <addr-line>Institute of Theoretical and Applied Informatics, Polish Academy of Sciences, Bałtycka 5, 44-100 Gliwice, Poland</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Chancellor</surname>
          <given-names>Nicholas</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>Durham University, UNITED KINGDOM</addr-line>
    </aff>
    <author-notes>
      <fn fn-type="COI-statement" id="coi001">
        <p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p>
      </fn>
      <corresp id="cor001">* E-mail: <email>lpawela@iitis.pl</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>26</day>
      <month>12</month>
      <year>2018</year>
    </pub-date>
    <volume>13</volume>
    <issue>12</issue>
    <elocation-id>e0209358</elocation-id>
    <history>
      <date date-type="received">
        <day>29</day>
        <month>6</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>4</day>
        <month>12</month>
        <year>2018</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2018 Gawron et al</copyright-statement>
      <copyright-year>2018</copyright-year>
      <copyright-holder>Gawron et al</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="pone.0209358.pdf"/>
    <abstract>
      <p>Numerical investigations are an important research tool in quantum information theory. There already exists a wide range of computational tools for quantum information theory implemented in various programming languages. However, there is little effort in implementing this kind of tools in the <monospace>Julia</monospace> language. <monospace>Julia</monospace> is a modern programming language designed for numerical computation with excellent support for vector and matrix algebra, extended type system that allows for implementation of elegant application interfaces and support for parallel and distributed computing. <monospace>QuantumInformation.jl</monospace> is a new quantum information theory library implemented in <monospace>Julia</monospace> that provides functions for creating and analyzing quantum states, and for creating quantum operations in various representations. An additional feature of the library is a collection of functions for sampling random quantum states and operations such as unitary operations and generic quantum channels.</p>
    </abstract>
    <funding-group>
      <award-group id="award001">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/501100004281</institution-id>
            <institution>Narodowe Centrum Nauki</institution>
          </institution-wrap>
        </funding-source>
        <award-id>2015/17/B/ST6/01872</award-id>
        <principal-award-recipient>
          <contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-0476-7132</contrib-id>
          <name>
            <surname>Pawela</surname>
            <given-names>Łukasz</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award002">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/501100004281</institution-id>
            <institution>Narodowe Centrum Nauki</institution>
          </institution-wrap>
        </funding-source>
        <award-id>2016/22/E/ST6/00062</award-id>
        <principal-award-recipient>
          <name>
            <surname>Kurzyk</surname>
            <given-names>Dariusz</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group id="award003">
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/501100004281</institution-id>
            <institution>Narodowe Centrum Nauki</institution>
          </institution-wrap>
        </funding-source>
        <award-id>2014/15/B/ST6/05204</award-id>
        <principal-award-recipient>
          <name>
            <surname>Gawron</surname>
            <given-names>Piotr</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <funding-statement>PG was supported by Polish National Science Centre grant number 2014/15/B/ST6/05204. DK was supported by Polish National Science Centre grant number 2016/22/E/ST6/00062. ŁP was supported by Polish National Science Centre grant number 2015/17/B/ST6/01872. The website of the Polish National Science Centre is <ext-link ext-link-type="uri" xlink:href="http://www.ncn.gov.pl">www.ncn.gov.pl</ext-link>.</funding-statement>
    </funding-group>
    <counts>
      <fig-count count="8"/>
      <table-count count="0"/>
      <page-count count="45"/>
    </counts>
    <custom-meta-group>
      <custom-meta id="data-availability">
        <meta-name>Data Availability</meta-name>
        <meta-value>The QuantumInformation.jl package code is available on GitHub at the URL <ext-link ext-link-type="uri" xlink:href="https://github.com/ZKSI/QuantumInformation.jl">https://github.com/ZKSI/QuantumInformation.jl</ext-link>.</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <title>Data Availability</title>
    <p>The QuantumInformation.jl package code is available on GitHub at the URL <ext-link ext-link-type="uri" xlink:href="https://github.com/ZKSI/QuantumInformation.jl">https://github.com/ZKSI/QuantumInformation.jl</ext-link>.</p>
  </notes>
</front>
<body>
  <sec sec-type="intro" id="sec001">
    <title>Introduction</title>
    <p>Numerical investigations are prevalent in quantum information theory. Numerical experiments can be used to find counter examples for theorems, to test hypotheses or to gain insight about quantum objects and operations.</p>
    <p>The variety of software that supports investigations in quantum information theory is very large. Yet there are niches that are not well covered. The purpose of <monospace>QuantumInformation.jl</monospace> library is to provide functions to create quantum states, manipulate them with quantum channels, calculate functionals on these objects and sample them randomly from various distributions. <monospace>QuantumInformation.jl</monospace> package is available on-line at <ext-link ext-link-type="uri" xlink:href="https://github.com/ZKSI/QuantumInformation.jl">https://github.com/ZKSI/QuantumInformation.jl</ext-link> and stored at Zenodo repository [<xref rid="pone.0209358.ref001" ref-type="bibr">1</xref>]. It is published under GNU General Public License v3.0.</p>
    <sec id="sec002">
      <title>Related work</title>
      <p>A comprehensive collection of software related to quantum mechanics, computation and information can be found at Quantiki [<xref rid="pone.0209358.ref002" ref-type="bibr">2</xref>]—an on-line resource for quantum information research community. There exist several notable libraries aimed at numerical and symbolic computation for quantum information theory. Two <monospace>Mathemetica</monospace> libraries—<monospace>QI</monospace> [<xref rid="pone.0209358.ref003" ref-type="bibr">3</xref>] and <monospace>TRQS</monospace> [<xref rid="pone.0209358.ref004" ref-type="bibr">4</xref>]—were an inspiration for creation of <monospace>QuantumInformation.jl</monospace>. Additionally the <monospace>QUANTUM</monospace> [<xref rid="pone.0209358.ref005" ref-type="bibr">5</xref>] library was implemented in <monospace>Mathematica</monospace>. A library called <monospace>FEYNMAN</monospace> implemented in <monospace>Maple</monospace>, described in a series of papers [<xref rid="pone.0209358.ref006" ref-type="bibr">6</xref>–<xref rid="pone.0209358.ref010" ref-type="bibr">10</xref>], provides a wide variety of functions. The above-mentioned libraries rely on non-free software and therefore their use can be very limited as use of this software requires acquiring expensive licenses and its source code cannot be studied by researchers. Therefore any results obtained using this software rely on trust to the companies that produced it. Hence non-free software creates barriers for reproducibility of scientific results [<xref rid="pone.0209358.ref011" ref-type="bibr">11</xref>].</p>
      <p>A widely celebrated and used framework <monospace>QuTiP</monospace> [<xref rid="pone.0209358.ref012" ref-type="bibr">12</xref>, <xref rid="pone.0209358.ref013" ref-type="bibr">13</xref>] was written in <monospace>Python</monospace>. <monospace>Python</monospace> posses many scientific computation libraries. It is free software and is widely used for scientific computation. Nevertheless, as a general purpose programming language it has its limits. In <monospace>Python</monospace>, implementations of multidimensional arrays and linear algebra routines are provided by <monospace>NumPy</monospace> [<xref rid="pone.0209358.ref014" ref-type="bibr">14</xref>] and <monospace>SciPy</monospace> [<xref rid="pone.0209358.ref015" ref-type="bibr">15</xref>] respectively. Unfortunately, due to low efficiency of <monospace>Python</monospace>, many of the underling functions are implemented in <monospace>C</monospace> or <monospace>Fortran</monospace> programming languages. Therefore, study and development of these routines is difficult and requires familiarity with these low-level languages.</p>
      <p><monospace>Julia</monospace> [<xref rid="pone.0209358.ref016" ref-type="bibr">16</xref>], being a high-level just-in-time compiled language, is very efficient and therefore extremely useful for scientific computing. There are several libraries related to quantum mechanics and quantum information written in Julia. Those are: <monospace>QuantumInfo.jl</monospace> [<xref rid="pone.0209358.ref017" ref-type="bibr">17</xref>], <monospace>Quantum.jl</monospace> [<xref rid="pone.0209358.ref018" ref-type="bibr">18</xref>] and a collection of packages developed as a part of <monospace>JuliaQuantum</monospace> project [<xref rid="pone.0209358.ref019" ref-type="bibr">19</xref>]. Unfortunately these development efforts stalled a couple of years ago. <monospace>JuliaQuantum</monospace> project is very ambitious, but its scope seems to be too large to be implemented fully in a relatively short amount of time. The only package whose development was successful is <monospace>QuantumOptics.jl</monospace>—a <monospace>Julia</monospace> framework for simulating open quantum systems [<xref rid="pone.0209358.ref020" ref-type="bibr">20</xref>]. Yet the applicability scope of this package is different than the one of <monospace>QuantumInformation.jl</monospace>.</p>
    </sec>
    <sec id="sec003">
      <title>Design principles</title>
      <p>Our goal while designing <monospace>QuantumInformation.jl</monospace> library was to follow the principles presented in the book “Geometry of Quantum States” [<xref rid="pone.0209358.ref021" ref-type="bibr">21</xref>]. We work with column vectors representing kets and row vectors representing bras. We fix our basis to the computational one. Density matrices and quantum channels are represented as two-dimensional arrays in the same fixed basis. This approach allows us to obtain a low level of complexity of our code, high flexibility and excellent computational efficiency. The design choices were highly motivated by the properties of the language in which our library was implemented, namely <monospace>Julia</monospace> [<xref rid="pone.0209358.ref022" ref-type="bibr">22</xref>].</p>
      <p><monospace>Julia</monospace> is a novel scientific programming language mainly influenced by <monospace>Python</monospace>, <monospace>Matlab</monospace> and <monospace>Lisp</monospace> programming languages. One of the main concepts widely used in <monospace>Julia</monospace> is multiple dispatch <italic>i.e.</italic> an ability to dispatch function calls to different methods depending on the types of all function arguments. The multiple dispatch mechanism together with a simple yet flexible type system allows to build clean and easy to use programming interfaces. <monospace>Julia</monospace> is just-in-time compiled to machine code using <monospace>LLVM</monospace> [<xref rid="pone.0209358.ref023" ref-type="bibr">23</xref>] therefore, despite being a high-level programming language, it can reach computation efficiency similar to <monospace>C</monospace> or <monospace>Fortran</monospace>. <monospace>Julia</monospace> natively supports parallel and distributed computing techniques. Therefore it is easy to write programs for Monte-Carlo sampling in <monospace>Julia</monospace>.</p>
      <p>In <monospace>Julia</monospace> arrays are first class objects [<xref rid="pone.0209358.ref024" ref-type="bibr">24</xref>], and linear algebra operations are integrated into the language standard library. The array system in <monospace>Julia</monospace> is designed in a way that minimizes the amount of memory copying operations during transformations of arrays. <monospace>Julia</monospace> supports various representations of vectors and matrices. For these reasons a design decision was made not to create library specific types but to rely on built-in standard library abstract array types.</p>
      <p>The <monospace>QuantumInformation.jl</monospace> library was initially developed in <monospace>Julia</monospace> 0.6 but then subsequently it was ported to <monospace>Julia</monospace> version 1.0. Part of the functionality of the library, namely the function that calculates the diamond norm of a quantum channel relies on <monospace>Convex.jl</monospace> library [<xref rid="pone.0209358.ref025" ref-type="bibr">25</xref>]. Partial traces are implemented using <monospace>TensorOperations.jl</monospace> library [<xref rid="pone.0209358.ref026" ref-type="bibr">26</xref>] that provides basic tensor contractions primitives.</p>
    </sec>
    <sec id="sec004">
      <title>Testing</title>
      <p>The <monospace>QuantumInformation.jl</monospace> library was tested using standard <monospace>Julia</monospace> framework. Tests where performed using three distinct approaches. In case of most of the functions the basic properties, such as e.g. dimensions, norms, hermititicty, positivity, trace are tested, where it was appropriate. Additionally some test cases where manually computed and used to verify the obtained results. In the case of methods generating random objects such as random matrices statistical properties of results are tested. For example in case of random unitary matrices sampling we test phases distribution [<xref rid="pone.0209358.ref027" ref-type="bibr">27</xref>] of obtained matrices in order to ensure that the unitary matrices are drawn according to the Haar measure.</p>
    </sec>
    <sec id="sec005">
      <title>Organization of the paper</title>
      <p>In the section <bold>Linear algebra in Julia</bold>, we describe briefly how the linear algebra routines are implemented in <monospace>Julia</monospace>. Next, in the section <bold>States and channels</bold>, we introduce the notions of <italic>quantum states</italic> and <italic>quantum channels</italic> and we discuss how we implement these concepts in <monospace>Julia</monospace>. Subsequently, the section <bold>Functionals</bold> focuses on functionals related with quantum information processing, <italic>i.e.</italic>
<italic>trace norm, diamond norm, entropy, fidelity</italic> or the <italic>PPT criterion</italic>. Afterward, we show the usage of <monospace>QuantumInformation.jl</monospace> for modeling and application of the <italic>quantum measurements</italic>. The section <bold>Random quantum objects</bold> introduces probabilistic measures on quatum states and channels and their implementation in <monospace>Julia</monospace>. Additionally, we introduce some common random matrix ensembles. In section <bold>Benchmarks</bold> we provide a comparison, in terms of code clarity and execution speed, of our library with the latest version of QuTiP [<xref rid="pone.0209358.ref012" ref-type="bibr">12</xref>, <xref rid="pone.0209358.ref013" ref-type="bibr">13</xref>]. Finally, in the section <bold>Conclusions and future work</bold> we present the final remarks and outline possible future work.</p>
    </sec>
  </sec>
  <sec id="sec006">
    <title>Linear algebra in Julia</title>
    <p>A basic construction of vector in <monospace>Julia</monospace> creates a full one-index array containing elements of a number type as presented below.</p>
    <boxed-text id="pone.0209358.box001" position="anchor" orientation="portrait">
      <p>
        <monospace>julia&gt; x = [0.0, 1.0im]</monospace>
      </p>
      <p>
        <monospace>2-element Array{Complex{Float64},1}:</monospace>
      </p>
      <p>
        <monospace> 0.0 + 0.0im</monospace>
      </p>
      <p>
        <monospace> 0.0 + 1.0im</monospace>
      </p>
    </boxed-text>
    <p specific-use="continuation">A transposition of a column vector returns an object of type <monospace>LinearAlgebra.Transpose</monospace> as shown below</p>
    <boxed-text id="pone.0209358.box002" position="anchor" orientation="portrait">
      <p>
        <monospace>julia&gt; xt = transpose(x)</monospace>
      </p>
      <p>
        <monospace>1×2 LinearAlgebra.Transpose{Complex{Float64},Array{Complex{Float64},1}}:</monospace>
      </p>
      <p>
        <monospace> 0.0 + 0.0im 0.0 + 1.0im</monospace>
      </p>
    </boxed-text>
    <p specific-use="continuation">While a Hermitian conjugate of the same vector returns a <monospace>LinearAlgebra.Adjoint</monospace> parametrized by the type <monospace>Array</monospace>:</p>
    <boxed-text id="pone.0209358.box003" position="anchor" orientation="portrait">
      <p>
        <monospace>julia&gt; xc = [0.0, 1.0im]’</monospace>
      </p>
      <p>
        <monospace>1×2 LinearAlgebra.Adjoint{Complex{Float64},Array{Complex{Float64},1}}:</monospace>
      </p>
      <p>
        <monospace> 0.0-0.0im 0.0-1.0im</monospace>
      </p>
    </boxed-text>
    <p specific-use="continuation">Values of variables <monospace>xt</monospace> and <monospace>xc</monospace> are views of the value of variable <monospace>x</monospace>. The column and row vectors behave like bras and kets, for example <monospace>xc*x</monospace> denotes the inner product of ‘bra’ <monospace>xc</monospace> and ‘ket’ <monospace>x</monospace>, while <monospace>x*xc</monospace> denotes their outer product resulting in a two-index array.</p>
    <p>The linear algebra library in <monospace>Julia</monospace> provides standard operations on matrices and vectors that are designed to take into account the types of the objects.</p>
  </sec>
  <sec id="sec007">
    <title>States and channels</title>
    <p>In this and the following sections we will denote complex Euclidean spaces ℂ<sup><italic>d</italic></sup> with <inline-formula id="pone.0209358.e001"><alternatives><graphic xlink:href="pone.0209358.e001.jpg" id="pone.0209358.e001g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M1"><mml:mi mathvariant="script">X</mml:mi></mml:math></alternatives></inline-formula>, <inline-formula id="pone.0209358.e002"><alternatives><graphic xlink:href="pone.0209358.e002.jpg" id="pone.0209358.e002g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M2"><mml:mi mathvariant="script">Y</mml:mi></mml:math></alternatives></inline-formula>, <inline-formula id="pone.0209358.e003"><alternatives><graphic xlink:href="pone.0209358.e003.jpg" id="pone.0209358.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:mi>𝒵</mml:mi></mml:math></alternatives></inline-formula> etc. When needed the dimension of a space <inline-formula id="pone.0209358.e004"><alternatives><graphic xlink:href="pone.0209358.e004.jpg" id="pone.0209358.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:mi mathvariant="script">X</mml:mi></mml:math></alternatives></inline-formula> will be denoted <inline-formula id="pone.0209358.e005"><alternatives><graphic xlink:href="pone.0209358.e005.jpg" id="pone.0209358.e005g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M5"><mml:mrow><mml:mtext>dim</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. The set of matrices transforming vectors from <inline-formula id="pone.0209358.e006"><alternatives><graphic xlink:href="pone.0209358.e006.jpg" id="pone.0209358.e006g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M6"><mml:mi mathvariant="script">X</mml:mi></mml:math></alternatives></inline-formula> to <inline-formula id="pone.0209358.e007"><alternatives><graphic xlink:href="pone.0209358.e007.jpg" id="pone.0209358.e007g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M7"><mml:mi mathvariant="script">Y</mml:mi></mml:math></alternatives></inline-formula> will be denoted <inline-formula id="pone.0209358.e008"><alternatives><graphic xlink:href="pone.0209358.e008.jpg" id="pone.0209358.e008g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M8"><mml:mrow><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. For simplicity we will write <inline-formula id="pone.0209358.e009"><alternatives><graphic xlink:href="pone.0209358.e009.jpg" id="pone.0209358.e009g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M9"><mml:mrow><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>≡</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
    <sec id="sec008">
      <title>States</title>
      <p>By <inline-formula id="pone.0209358.e010"><alternatives><graphic xlink:href="pone.0209358.e010.jpg" id="pone.0209358.e010g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M10"><mml:mrow><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">X</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> we denote a normed column vector. Notice that any |<italic>ψ</italic>〉 can be expressed as <inline-formula id="pone.0209358.e011"><alternatives><graphic xlink:href="pone.0209358.e011.jpg" id="pone.0209358.e011g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M11"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula id="pone.0209358.e012"><alternatives><graphic xlink:href="pone.0209358.e012.jpg" id="pone.0209358.e012g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M12"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msup><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> and the set <inline-formula id="pone.0209358.e013"><alternatives><graphic xlink:href="pone.0209358.e013.jpg" id="pone.0209358.e013g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M13"><mml:msubsup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> is the computational basis.</p>
      <boxed-text id="pone.0209358.box004" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; ket(1,2)</monospace>
        </p>
        <p>
          <monospace>2-element Array{Complex{Float64},1}:</monospace>
        </p>
        <p>
          <monospace> 1.0 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0 + 0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; (1/sqrt(2)) * (ket(1,2) + ket(2,2))</monospace>
        </p>
        <p>
          <monospace>2-element Array{Complex{Float64},1}:</monospace>
        </p>
        <p>
          <monospace> 0.7071067811865475 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.7071067811865475 + 0.0im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">According to common academic convention, we count the indices of states starting from one. Following the standard Dirac notation the symbol 〈<italic>ψ</italic>| denotes the row vector dual to |<italic>ψ</italic>〉. Therefore |<italic>ψ</italic>〉 = 〈<italic>ψ</italic>|<sup>†</sup>, where the symbol <sup>†</sup> denotes the Hermitian conjugation.</p>
      <boxed-text id="pone.0209358.box005" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; bra(2,3)</monospace>
        </p>
        <p>
          <monospace>1×3 LinearAlgebra.Adjoint{Complex{Float64},Array{Complex{Float64},1}}:</monospace>
        </p>
        <p>
          <monospace> 0.0-0.0im 1.0-0.0im 0.0-0.0im</monospace>
        </p>
      </boxed-text>
      <p>The inner product of <inline-formula id="pone.0209358.e014"><alternatives><graphic xlink:href="pone.0209358.e014.jpg" id="pone.0209358.e014g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M14"><mml:mrow><mml:mo>|</mml:mo><mml:mi>ϕ</mml:mi><mml:mo>〉</mml:mo><mml:mo>,</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">X</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> is denoted by 〈<italic>ψ</italic>|<italic>ϕ</italic>〉 and the norm is defined as <inline-formula id="pone.0209358.e015"><alternatives><graphic xlink:href="pone.0209358.e015.jpg" id="pone.0209358.e015g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M15"><mml:mrow><mml:mrow><mml:mo>∥</mml:mo><mml:mspace width="1pt"/><mml:mo>|</mml:mo><mml:mi>ϕ</mml:mi><mml:mo>〉</mml:mo><mml:mo>∥</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mo>〈</mml:mo><mml:mi>ϕ</mml:mi><mml:mo>|</mml:mo><mml:mi>ϕ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <boxed-text id="pone.0209358.box006" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; <italic>ψ</italic> = (1/sqrt(2)) * (ket(1,2) + ket(2,2))</monospace>
        </p>
        <p>
          <monospace>2-element Array{Complex{Float64},1}:</monospace>
        </p>
        <p>
          <monospace> 0.7071067811865475 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.7071067811865475 + 0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; <italic>ϕ</italic> = (1/2) * ket(1,2) + (sqrt(3)/2) * ket(2,2)</monospace>
        </p>
        <p>
          <monospace>2-element Array{Complex{Float64},1}:</monospace>
        </p>
        <p>
          <monospace> 0.5 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.8660254037844386 + 0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; <italic>ϕ</italic>’ * <italic>ψ</italic></monospace>
        </p>
        <p>
          <monospace> 0.9659258262890682 + 0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; sqrt(<italic>ϕ</italic>’ * <italic>ϕ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.9999999999999999 + 0.0im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The form <inline-formula id="pone.0209358.e016"><alternatives><graphic xlink:href="pone.0209358.e016.jpg" id="pone.0209358.e016g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M16"><mml:mrow><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>〈</mml:mo><mml:mi>ϕ</mml:mi><mml:mo>|</mml:mo><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> denotes outer product of <inline-formula id="pone.0209358.e017"><alternatives><graphic xlink:href="pone.0209358.e017.jpg" id="pone.0209358.e017g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M17"><mml:mrow><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">Y</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209358.e018"><alternatives><graphic xlink:href="pone.0209358.e018.jpg" id="pone.0209358.e018g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M18"><mml:mrow><mml:mo>|</mml:mo><mml:mi>ϕ</mml:mi><mml:mo>〉</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">X</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <boxed-text id="pone.0209358.box007" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; ketbra(2,3,4)</monospace>
        </p>
        <p>
          <monospace>4×4 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 1.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">Specifically, |<italic>ψ</italic>〉〈<italic>ψ</italic>| is a rank-one projection operator called a <italic>pure state</italic>. Generally, any <italic>quantum state</italic>
<italic>ρ</italic> can be expressed as <inline-formula id="pone.0209358.e019"><alternatives><graphic xlink:href="pone.0209358.e019.jpg" id="pone.0209358.e019g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M19"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mi>q</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>〉</mml:mo><mml:mo>〈</mml:mo></mml:mrow><mml:msub><mml:mi>ψ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula id="pone.0209358.e020"><alternatives><graphic xlink:href="pone.0209358.e020.jpg" id="pone.0209358.e020g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M20"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mi>q</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> and |<italic>ψ</italic><sub><italic>i</italic></sub>〉〈<italic>ψ</italic><sub><italic>i</italic></sub>| are rank-one projectors. Notice that <italic>ρ</italic> is a trace-one positive semi-definite linear operator <italic>i.e.</italic>: <italic>ρ</italic> = <italic>ρ</italic><sup>†</sup>, <italic>ρ</italic> ≥ 0 and tr<italic>ρ</italic> = 1.</p>
      <boxed-text id="pone.0209358.box008" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; proj(ψ)</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2:</monospace>
        </p>
        <p>
          <monospace> 0.5+0.0im 0.5+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.5+0.0im 0.5+0.0im</monospace>
        </p>
      </boxed-text>
      <p>For convenience, the <monospace>QuantumInformation.jl</monospace> library provides the implementations of maximally mixed, maximally entangled and Werner states.</p>
      <boxed-text id="pone.0209358.box009" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; max_entangled(4)</monospace>
        </p>
        <p>
          <monospace>4-element reshape(::Diagonal{Complex{Float64},Array{Complex{Float64},1}},4)</monospace>
        </p>
        <p>
          <monospace>with eltype {Complex{Float64}:</monospace>
        </p>
        <p>
          <monospace> 0.7071067811865475 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.7071067811865475 + 0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; max_mixed(4)</monospace>
        </p>
        <p>
          <monospace>4×4 Array{Float64,2}:</monospace>
        </p>
        <p>
          <monospace>0.25 0.0 0.0 0.0</monospace>
        </p>
        <p>
          <monospace>0.0 0.25 0.0 0.0</monospace>
        </p>
        <p>
          <monospace>0.0 0.0 0.25 0.0</monospace>
        </p>
        <p>
          <monospace>0.0 0.0 0.0 0.25</monospace>
        </p>
        <p>
          <monospace>julia&gt; werner_state(4, 0.4)</monospace>
        </p>
        <p>
          <monospace>4×4 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.35+0.0im 0.0+0.0im 0.0+0.0im 0.2+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.15+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.15+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.2+0.0im 0.0+0.0im 0.0+0.0im 0.35+0.0im</monospace>
        </p>
      </boxed-text>
    </sec>
    <sec id="sec009">
      <title>Non-standard matrix transformations</title>
      <p>We will now introduce reshaping operators, which map matrices to vectors and vice versa. We start with the mapping <inline-formula id="pone.0209358.e021"><alternatives><graphic xlink:href="pone.0209358.e021.jpg" id="pone.0209358.e021g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M21"><mml:mrow><mml:mtext>res</mml:mtext><mml:mo>:</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo><mml:mo>→</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="script">X</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>, which transforms the matrix <italic>ρ</italic> into a vector row by row. More precisely, for dyadic operators |<italic>ψ</italic>〉〈<italic>ϕ</italic>|, where <inline-formula id="pone.0209358.e022"><alternatives><graphic xlink:href="pone.0209358.e022.jpg" id="pone.0209358.e022g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M22"><mml:mrow><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">Y</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pone.0209358.e023"><alternatives><graphic xlink:href="pone.0209358.e023.jpg" id="pone.0209358.e023g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M23"><mml:mrow><mml:mo>|</mml:mo><mml:mi>ϕ</mml:mi><mml:mo>〉</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">X</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> the operation <italic>res</italic> is defined as <inline-formula id="pone.0209358.e024"><alternatives><graphic xlink:href="pone.0209358.e024.jpg" id="pone.0209358.e024g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M24"><mml:mrow><mml:mtext>res</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>ϕ</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>|</mml:mo></mml:mrow><mml:mover><mml:mi>ϕ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> and can be uniquely extend to the whole space <inline-formula id="pone.0209358.e025"><alternatives><graphic xlink:href="pone.0209358.e025.jpg" id="pone.0209358.e025g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M25"><mml:mrow><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> by linearity.</p>
      <boxed-text id="pone.0209358.box010" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; res(ketbra(1,2,2))</monospace>
        </p>
        <p>
          <monospace>4-element reshape(::LinearAlgebra.Transpose{Complex{Float64},Array{Complex{Float64},2}}, 4)</monospace>
        </p>
        <p>
          <monospace>with eltype {Complex{Float64}:</monospace>
        </p>
        <p>
          <monospace> 0.0 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 1.0 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0 + 0.0im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The inverse operation to res is <inline-formula id="pone.0209358.e026"><alternatives><graphic xlink:href="pone.0209358.e026.jpg" id="pone.0209358.e026g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M26"><mml:mrow><mml:mtext>unres</mml:mtext><mml:mo>:</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>→</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, which transforms the vector into a matrix. It is defined as the unique linear mapping satisfying <italic>ρ</italic> = unres(res(<italic>ρ</italic>)).</p>
      <boxed-text id="pone.0209358.box011" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; unres(res(ketbra(1,2,2)))</monospace>
        </p>
        <p>
          <monospace>2×2 LinearAlgebra.Transpose{Complex{Float64},Base.ReshapedArray{Complex{Float64},2,LinearAlgebra.</monospace>
        </p>
        <p>
          <monospace>Transpose{Complex{Float64},Array{Complex{Float64},2}},</monospace>
        </p>
        <p>
          <monospace>Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}}:</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 1.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">Let us recall that trace is a mapping <inline-formula id="pone.0209358.e027"><alternatives><graphic xlink:href="pone.0209358.e027.jpg" id="pone.0209358.e027g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M27"><mml:mrow><mml:mtext>Tr</mml:mtext><mml:mo>:</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>→</mml:mo><mml:mi mathvariant="double-struck">C</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> given by <inline-formula id="pone.0209358.e028"><alternatives><graphic xlink:href="pone.0209358.e028.jpg" id="pone.0209358.e028g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M28"><mml:mrow><mml:mtext>Tr</mml:mtext><mml:mo>:</mml:mo><mml:mi>ρ</mml:mi><mml:mo>↦</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mtext>dim</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mo>〈</mml:mo></mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:mi>ρ</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, where {|<italic>e</italic><sub><italic>i</italic></sub>〉} is an orthonormal basis of <inline-formula id="pone.0209358.e029"><alternatives><graphic xlink:href="pone.0209358.e029.jpg" id="pone.0209358.e029g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M29"><mml:mi mathvariant="script">X</mml:mi></mml:math></alternatives></inline-formula>. According to this, <italic>partial trace</italic> is a mapping <inline-formula id="pone.0209358.e030"><alternatives><graphic xlink:href="pone.0209358.e030.jpg" id="pone.0209358.e030g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M30"><mml:mrow><mml:msub><mml:mtext>Tr</mml:mtext><mml:mi mathvariant="script">X</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>→</mml:mo><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> such that <inline-formula id="pone.0209358.e031"><alternatives><graphic xlink:href="pone.0209358.e031.jpg" id="pone.0209358.e031g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M31"><mml:mrow><mml:msub><mml:mtext>Tr</mml:mtext><mml:mi mathvariant="script">X</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mo>↦</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mtext>Tr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula id="pone.0209358.e032"><alternatives><graphic xlink:href="pone.0209358.e032.jpg" id="pone.0209358.e032g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M32"><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pone.0209358.e033"><alternatives><graphic xlink:href="pone.0209358.e033.jpg" id="pone.0209358.e033g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M33"><mml:mrow><mml:msub><mml:mi>ρ</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. As this is a linear map, it may be uniquely extended to the case of operators which are not in a tensor product form.</p>
      <boxed-text id="pone.0209358.box012" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; <italic>ρ</italic> = [0.25 0.25im; -0.25im 0.75]</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.25+0.0im 0.0+0.25im</monospace>
        </p>
        <p>
          <monospace> -0.0-0.25im 0.75+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; <italic>σ</italic> = [0.4 0.1im; -0.1im 0.6]</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2:</monospace>
        </p>
        <p>
          <monospace> 0.4+0.0im 0.0+0.1im</monospace>
        </p>
        <p>
          <monospace> -0.0-0.1im 0.6+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; ptrace(<italic>ρ</italic> ⊗ <italic>σ</italic>, [2, 2], [2])</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.25+0.0im 0.0+0.25im</monospace>
        </p>
        <p>
          <monospace> 0.0-0.25im 0.75+0.0im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">Matrix transposition is a mapping <inline-formula id="pone.0209358.e034"><alternatives><graphic xlink:href="pone.0209358.e034.jpg" id="pone.0209358.e034g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M34"><mml:mrow><mml:msup><mml:mrow/><mml:mi>T</mml:mi></mml:msup><mml:mo>:</mml:mo><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>→</mml:mo><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> such that (<italic>ρ</italic><sup><italic>T</italic></sup>)<sub><italic>ij</italic></sub> = <italic>ρ</italic><sub><italic>ji</italic></sub>, where <italic>ρ</italic><sub><italic>ij</italic></sub> is a <italic>i</italic>-th row, <italic>j</italic>-th column element of matrix <italic>ρ</italic>. Following this, we may introduce <italic>partial transposition</italic>
<inline-formula id="pone.0209358.e035"><alternatives><graphic xlink:href="pone.0209358.e035.jpg" id="pone.0209358.e035g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M35"><mml:mrow><mml:msup><mml:mrow/><mml:msub><mml:mo>Γ</mml:mo><mml:mi>B</mml:mi></mml:msub></mml:msup><mml:mo>:</mml:mo><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>→</mml:mo><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, which for a product state <italic>ρ</italic><sub><italic>A</italic></sub> ⊗ <italic>ρ</italic><sub><italic>B</italic></sub> is given by <inline-formula id="pone.0209358.e036"><alternatives><graphic xlink:href="pone.0209358.e036.jpg" id="pone.0209358.e036g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M36"><mml:mrow><mml:msup><mml:mrow/><mml:msub><mml:mo>Γ</mml:mo><mml:mi>B</mml:mi></mml:msub></mml:msup><mml:mo>:</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mo>↦</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msubsup><mml:mi>ρ</mml:mi><mml:mi>B</mml:mi><mml:mi>T</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>. The definition of partial transposition can be uniquely extended for all operators from linearity.</p>
      <boxed-text id="pone.0209358.box013" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; ptranspose(<italic>ρ</italic> ⊗ <italic>σ</italic>, [2, 2], [1])</monospace>
        </p>
        <p>
          <monospace>4×4 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.1+0.0im 0.0+0.025im 0.0-0.1im 0.025-0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0-0.025im 0.15+0.0im -0.025+0.0im 0.0-0.15im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.1im -0.025+0.0im 0.3+0.0im 0.0+0.075im</monospace>
        </p>
        <p>
          <monospace> 0.025-0.0im 0.0+0.15im 0.0-0.075im 0.45+0.0im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">For given multiindexed matrix <italic>ρ</italic><sub>(<italic>m</italic>,<italic>μ</italic>),(<italic>n</italic>,<italic>ν</italic>)</sub> = 〈<italic>mμ</italic>|<italic>ρ</italic>|<italic>nν</italic>〉, the reshuffle operation is defined as <inline-formula id="pone.0209358.e037"><alternatives><graphic xlink:href="pone.0209358.e037.jpg" id="pone.0209358.e037g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M37"><mml:mrow><mml:msubsup><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>μ</mml:mi><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>R</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>ρ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mo>(</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <boxed-text id="pone.0209358.box014" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; reshuffle(<italic>ρ</italic> ⊗ σ)</monospace>
        </p>
        <p>
          <monospace>4×4 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.1+0.0im 0.0+0.025im 0.0-0.025im 0.15+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.1im -0.025+0.0im 0.025-0.0im 0.0+0.15im</monospace>
        </p>
        <p>
          <monospace> 0.0-0.1im 0.025-0.0im -0.025+0.0im 0.0-0.15im</monospace>
        </p>
        <p>
          <monospace> 0.3+0.0im 0.0+0.075im 0.0-0.075im 0.45+0.0im</monospace>
        </p>
      </boxed-text>
    </sec>
    <sec id="sec010">
      <title>Channels</title>
      <p>Physical transformations of quantum states into quantum states are called quantum channels <italic>i.e.</italic> linear Completely Positive Trace Preserving (CP-TP) transformations. Probabilistic transformations of quantum states are called quantum operations and mathematically they are defined as linear Completely Positive Trace Non-increasing (CP-TNI) maps. For the sake of simplicity we will refer to both CP-TP and CP-TNI maps as quantum channels when it will not cause confusion.</p>
      <p>There exists various representations of quantum channels such as:</p>
      <list list-type="bullet">
        <list-item>
          <p>Kraus operators,</p>
        </list-item>
        <list-item>
          <p>natural representation, also called superoperator representation,</p>
        </list-item>
        <list-item>
          <p>Stinespring representation,</p>
        </list-item>
        <list-item>
          <p>Choi-Jamiołkowski matrices, sometimes called dynamical matrices.</p>
        </list-item>
      </list>
      <p>Formally, properties of quantum channels can be stated as follows [<xref rid="pone.0209358.ref028" ref-type="bibr">28</xref>]. First, we introduce the notion of <italic>superoperator</italic> as a linear mapping acting on linear operators <inline-formula id="pone.0209358.e038"><alternatives><graphic xlink:href="pone.0209358.e038.jpg" id="pone.0209358.e038g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M38"><mml:mrow><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and transforming them into operators acting on <inline-formula id="pone.0209358.e039"><alternatives><graphic xlink:href="pone.0209358.e039.jpg" id="pone.0209358.e039g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M39"><mml:mrow><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. The set of all such mapping will be denoted by <inline-formula id="pone.0209358.e040"><alternatives><graphic xlink:href="pone.0209358.e040.jpg" id="pone.0209358.e040g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M40"><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209358.e041"><alternatives><graphic xlink:href="pone.0209358.e041.jpg" id="pone.0209358.e041g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M41"><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>≡</mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. In mathematical terms, a quantum channel is a superoperator <inline-formula id="pone.0209358.e042"><alternatives><graphic xlink:href="pone.0209358.e042.jpg" id="pone.0209358.e042g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M42"><mml:mrow><mml:mo>Φ</mml:mo><mml:mo>:</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>→</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> that is</p>
      <list list-type="bullet">
        <list-item>
          <p><italic>trace-preserving</italic> (<inline-formula id="pone.0209358.e043"><alternatives><graphic xlink:href="pone.0209358.e043.jpg" id="pone.0209358.e043g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M43"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>ρ</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mspace width="1.em"/><mml:mtext>Tr</mml:mtext><mml:mo>(</mml:mo><mml:mo>Φ</mml:mo><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mtext>Tr</mml:mtext><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>) and</p>
        </list-item>
        <list-item>
          <p><italic>completely positive</italic> (<inline-formula id="pone.0209358.e044"><alternatives><graphic xlink:href="pone.0209358.e044.jpg" id="pone.0209358.e044g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M44"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>𝒵</mml:mi><mml:mo>∀</mml:mo><mml:mi>ρ</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>⊗</mml:mo><mml:mi>𝒵</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>ρ</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>Φ</mml:mo><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mrow><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi>𝒵</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>).</p>
        </list-item>
      </list>
      <p>The product of superoperators <inline-formula id="pone.0209358.e045"><alternatives><graphic xlink:href="pone.0209358.e045.jpg" id="pone.0209358.e045g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M45"><mml:mrow><mml:msub><mml:mo>Φ</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pone.0209358.e046"><alternatives><graphic xlink:href="pone.0209358.e046.jpg" id="pone.0209358.e046g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M46"><mml:mrow><mml:msub><mml:mo>Φ</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> is a mapping <inline-formula id="pone.0209358.e047"><alternatives><graphic xlink:href="pone.0209358.e047.jpg" id="pone.0209358.e047g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M47"><mml:mrow><mml:msub><mml:mo>Φ</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mo>Φ</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="script">X</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="script">Y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> that satisfies (Φ<sub>1</sub> ⊗ Φ<sub>2</sub>)(<italic>ρ</italic><sub>1</sub> ⊗ <italic>ρ</italic><sub>2</sub>) = Φ<sub>1</sub>(<italic>ρ</italic><sub>1</sub>) ⊗ Φ<sub>2</sub>(<italic>ρ</italic><sub>2</sub>). For the operators that are not in a tensor product form this notion can be uniquely extended from linearity.</p>
      <p>According to Kraus’ theorem, any completely positive trace-preserving (CP-TP) map Φ can always be written as <inline-formula id="pone.0209358.e048"><alternatives><graphic xlink:href="pone.0209358.e048.jpg" id="pone.0209358.e048g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M48"><mml:mrow><mml:mo>Φ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>ρ</mml:mi><mml:msubsup><mml:mi>K</mml:mi><mml:mi>i</mml:mi><mml:mo>†</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for some set of operators <inline-formula id="pone.0209358.e049"><alternatives><graphic xlink:href="pone.0209358.e049.jpg" id="pone.0209358.e049g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M49"><mml:msubsup><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> satisfying <inline-formula id="pone.0209358.e050"><alternatives><graphic xlink:href="pone.0209358.e050.jpg" id="pone.0209358.e050g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M50"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:msubsup><mml:mi>K</mml:mi><mml:mi>i</mml:mi><mml:mo>†</mml:mo></mml:msubsup><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mi mathvariant="script">X</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, where <italic>r</italic> is the rank of superoperator Φ.</p>
      <p>Another way to represent the quantum channel is based on Choi-Jamiołkowski isomorphism. Consider mapping <inline-formula id="pone.0209358.e051"><alternatives><graphic xlink:href="pone.0209358.e051.jpg" id="pone.0209358.e051g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M51"><mml:mrow><mml:mi>J</mml:mi><mml:mo>:</mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo><mml:mo>→</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> such that <inline-formula id="pone.0209358.e052"><alternatives><graphic xlink:href="pone.0209358.e052.jpg" id="pone.0209358.e052g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M52"><mml:mrow><mml:mi>J</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>Φ</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mo>Φ</mml:mo><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mrow><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtext>res</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mi mathvariant="script">X</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mtext>res</mml:mtext><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mi mathvariant="script">X</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>†</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. Equivalently <inline-formula id="pone.0209358.e053"><alternatives><graphic xlink:href="pone.0209358.e053.jpg" id="pone.0209358.e053g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M53"><mml:mrow><mml:mi>J</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>Φ</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mtext>dim</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msubsup><mml:mo>Φ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>j</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>⊗</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>〉</mml:mo><mml:mo>〈</mml:mo><mml:mi>j</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. The action of a superoperator in the Choi representation is given by <inline-formula id="pone.0209358.e054"><alternatives><graphic xlink:href="pone.0209358.e054.jpg" id="pone.0209358.e054g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M54"><mml:mrow><mml:mo>Φ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mtext>Tr</mml:mtext><mml:mi mathvariant="script">X</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>J</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>Φ</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mi mathvariant="script">Y</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mi>ρ</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>The natural representation of a quantum channel <inline-formula id="pone.0209358.e055"><alternatives><graphic xlink:href="pone.0209358.e055.jpg" id="pone.0209358.e055g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M55"><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is a mapping res(<italic>ρ</italic>) ↦ res(Φ(<italic>ρ</italic>)). It is represented by a matrix <inline-formula id="pone.0209358.e056"><alternatives><graphic xlink:href="pone.0209358.e056.jpg" id="pone.0209358.e056g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M56"><mml:mrow><mml:mi>K</mml:mi><mml:mo>(</mml:mo><mml:mo>Φ</mml:mo><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> for which the following holds
<disp-formula id="pone.0209358.e057"><alternatives><graphic xlink:href="pone.0209358.e057.jpg" id="pone.0209358.e057g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M57"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>K</mml:mi><mml:mo>(</mml:mo><mml:mo>Φ</mml:mo><mml:mo>)</mml:mo><mml:mtext>res</mml:mtext><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mtext>res</mml:mtext><mml:mo>(</mml:mo><mml:mo>Φ</mml:mo><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(1)</label></disp-formula>
for all <inline-formula id="pone.0209358.e058"><alternatives><graphic xlink:href="pone.0209358.e058.jpg" id="pone.0209358.e058g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M58"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>Let <inline-formula id="pone.0209358.e059"><alternatives><graphic xlink:href="pone.0209358.e059.jpg" id="pone.0209358.e059g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M59"><mml:mrow><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209358.e060"><alternatives><graphic xlink:href="pone.0209358.e060.jpg" id="pone.0209358.e060g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M60"><mml:mi>𝒵</mml:mi></mml:math></alternatives></inline-formula> be a complex Euclidean spaces. The action of the Stinespring representation of a quantum channel <inline-formula id="pone.0209358.e061"><alternatives><graphic xlink:href="pone.0209358.e061.jpg" id="pone.0209358.e061g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M61"><mml:mrow><mml:mo>Φ</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> on a state <inline-formula id="pone.0209358.e062"><alternatives><graphic xlink:href="pone.0209358.e062.jpg" id="pone.0209358.e062g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M62"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is given by
<disp-formula id="pone.0209358.e063"><alternatives><graphic xlink:href="pone.0209358.e063.jpg" id="pone.0209358.e063g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M63"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>Φ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mtext>Tr</mml:mtext><mml:mi>𝒵</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>A</mml:mi><mml:mi>ρ</mml:mi><mml:msup><mml:mi>A</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(2)</label></disp-formula>
where <inline-formula id="pone.0209358.e064"><alternatives><graphic xlink:href="pone.0209358.e064.jpg" id="pone.0209358.e064g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M64"><mml:mrow><mml:mi>A</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>⊗</mml:mo><mml:mi>𝒵</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>We now briefly describe the relationships among channel representations [<xref rid="pone.0209358.ref028" ref-type="bibr">28</xref>]. Let <inline-formula id="pone.0209358.e065"><alternatives><graphic xlink:href="pone.0209358.e065.jpg" id="pone.0209358.e065g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M65"><mml:mrow><mml:mo>Φ</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> be a quantum channel which can be written in the Kraus representation as
<disp-formula id="pone.0209358.e066"><alternatives><graphic xlink:href="pone.0209358.e066.jpg" id="pone.0209358.e066g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M66"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>Φ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:munderover><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mi>ρ</mml:mi><mml:msubsup><mml:mi>K</mml:mi><mml:mi>i</mml:mi><mml:mo>†</mml:mo></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(3)</label></disp-formula>
where <inline-formula id="pone.0209358.e067"><alternatives><graphic xlink:href="pone.0209358.e067.jpg" id="pone.0209358.e067g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M67"><mml:msubsup><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> are Kraus operators satisfying <inline-formula id="pone.0209358.e068"><alternatives><graphic xlink:href="pone.0209358.e068.jpg" id="pone.0209358.e068g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M68"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:msubsup><mml:mi>K</mml:mi><mml:mi>i</mml:mi><mml:mo>†</mml:mo></mml:msubsup><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mi mathvariant="script">X</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>. According to this assumption, Φ can be represented in</p>
      <list list-type="bullet">
        <list-item>
          <p>Choi representation as
<disp-formula id="pone.0209358.e069"><alternatives><graphic xlink:href="pone.0209358.e069.jpg" id="pone.0209358.e069g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M69"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>J</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>Φ</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:munderover><mml:mtext>res</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mtext>res</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:msubsup><mml:mi>K</mml:mi><mml:mi>i</mml:mi><mml:mo>†</mml:mo></mml:msubsup><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(4)</label></disp-formula></p>
        </list-item>
        <list-item>
          <p>natural representation as
<disp-formula id="pone.0209358.e070"><alternatives><graphic xlink:href="pone.0209358.e070.jpg" id="pone.0209358.e070g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M70"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mo>Φ</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:munderover><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msubsup><mml:mi>K</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(5)</label></disp-formula></p>
        </list-item>
        <list-item>
          <p>Stinespring representation as
<disp-formula id="pone.0209358.e071"><alternatives><graphic xlink:href="pone.0209358.e071.jpg" id="pone.0209358.e071g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M71"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>Φ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mtext>tr</mml:mtext><mml:mi>𝒵</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>A</mml:mi><mml:mi>ρ</mml:mi><mml:msup><mml:mi>A</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(6)</label></disp-formula>
where <inline-formula id="pone.0209358.e072"><alternatives><graphic xlink:href="pone.0209358.e072.jpg" id="pone.0209358.e072g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M72"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:msub><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209358.e073"><alternatives><graphic xlink:href="pone.0209358.e073.jpg" id="pone.0209358.e073g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M73"><mml:mrow><mml:mi>𝒵</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mo>ℂ</mml:mo><mml:mi>r</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        </list-item>
      </list>
      <p>In <monospace>QuantumInformation.jl</monospace> states and channels are always represented in the computational basis therefore channels are stored in the memory as either vectors of matrices in case of Kraus operators or matrices in other cases. In <monospace>QuantumInformation.jl</monospace> quantum channels are represented by a set of types deriving from an abstract type <monospace>AbstractQuantumOperation{T}</monospace> where type parameter <monospace>T</monospace> should inherit from <monospace>AbstractMatrix{&lt;:Number}</monospace>. Every type inheriting from <monospace>AbstractQuantumOperation{T}</monospace> should contain fields <monospace>idim</monospace> and <monospace>odim</monospace> representing the dimension of input and output space of the quantum channel.</p>
      <p>Two special types of channels are implemented: <monospace>UnitaryChannel</monospace> and <monospace>IdentityChannel</monospace> that can transform ket vectors into ket vectors.</p>
      <sec id="sec011">
        <title>Constructors</title>
        <p>Channel objects can be constructed from matrices that represent them, as shown in the following listing</p>
        <boxed-text id="pone.0209358.box015" position="anchor" orientation="portrait">
          <p>
            <monospace>julia&gt; <italic>γ</italic> = 0.4</monospace>
          </p>
          <p>
            <monospace> 0.4</monospace>
          </p>
          <p>
            <monospace>julia&gt; K0 = Matrix([1 0; 0 sqrt(1-<italic>γ</italic>)])</monospace>
          </p>
          <p>
            <monospace>2×2 Array{Float64,2}:</monospace>
          </p>
          <p>
            <monospace> 1.0 0.0</monospace>
          </p>
          <p>
            <monospace> 0.0 0.774597</monospace>
          </p>
          <p>
            <monospace>julia&gt; K1 = Matrix([0 sqrt(<italic>γ</italic>); 0 0])</monospace>
          </p>
          <p>
            <monospace>2×2 Array{Float64,2}:</monospace>
          </p>
          <p>
            <monospace> 0.0 0.632456</monospace>
          </p>
          <p>
            <monospace> 0.0 0.0</monospace>
          </p>
          <p>
            <monospace>julia&gt; Φ = KrausOperators([K0,K1])</monospace>
          </p>
          <p>
            <monospace>KrausOperators{Array{Float64,2}}</monospace>
          </p>
          <p>
            <monospace>dimensions: (2, 2)</monospace>
          </p>
          <p>
            <monospace> [1.0 0.0; 0.0 0.774597]</monospace>
          </p>
          <p>
            <monospace> [0.0 0.632456; 0.0 0.0]</monospace>
          </p>
          <p>
            <monospace>julia&gt; iscptp(Φ)</monospace>
          </p>
          <p>
            <monospace> true</monospace>
          </p>
        </boxed-text>
        <p specific-use="continuation">There are no checks whether a matrix represents a valid CP-TP or CP-TNI map, because this kind of verification is costly and requires potentially expensive numerical computation. Function such as <monospace>iscptp()</monospace>, and <monospace>iscptni()</monospace> are provided to test properties of supposed quantum channel or quantum operation.</p>
      </sec>
      <sec id="sec012">
        <title>Conversion</title>
        <p>Conversions between all quantum channel types, <italic>i.e.</italic> these that derive from <monospace>AbstractQuantumOperation{T}</monospace> are implemented. The users are not limited by any single channel representation and can transform between representations they find the most efficient or suitable for their purpose.</p>
        <boxed-text id="pone.0209358.box016" position="anchor" orientation="portrait">
          <p>
            <monospace>julia&gt; Ψ1 = convert(SuperOperator{Matrix{ComplexF64}}, Φ)</monospace>
          </p>
          <p>
            <monospace>SuperOperator{Array{Complex{Float64},2}}</monospace>
          </p>
          <p>
            <monospace>dimensions: (2, 2)</monospace>
          </p>
          <p>
            <monospace>Complex{Float64}</monospace>
          </p>
          <p>
            <monospace> [1.0+0.0im 0.0+0.0im 0.0+0.0im 0.4+0.0im;</monospace>
          </p>
          <p>
            <monospace> 0.0+0.0im 0.774597+0.0im 0.0+0.0im 0.0+0.0im;</monospace>
          </p>
          <p>
            <monospace> 0.0+0.0im 0.0+0.0im 0.774597+0.0im 0.0+0.0im;</monospace>
          </p>
          <p>
            <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im 0.6+0.0im]</monospace>
          </p>
          <p>
            <monospace>julia&gt; Ψ2 = convert(DynamicalMatrix{Matrix{Float64}}, Φ)</monospace>
          </p>
          <p>
            <monospace>DynamicalMatrix{Array{Float64,2}}</monospace>
          </p>
          <p>
            <monospace>dimensions: (2, 2)</monospace>
          </p>
          <p>
            <monospace> [1.0 0.0 0.0 0.774597;</monospace>
          </p>
          <p>
            <monospace> 0.0 0.4 0.0 0.0;</monospace>
          </p>
          <p>
            <monospace> 0.0 0.0 0.0 0.0;</monospace>
          </p>
          <p>
            <monospace> 0.774597 0.00.0 0.6]</monospace>
          </p>
          <p>
            <monospace>julia&gt; Ψ3 = convert(Stinespring{Matrix{Float64}}, Φ)</monospace>
          </p>
          <p>
            <monospace>Stinespring{Array{Float64,2}}</monospace>
          </p>
          <p>
            <monospace>dimensions: (2, 2)</monospace>
          </p>
          <p>
            <monospace> [0.0 0.0;</monospace>
          </p>
          <p>
            <monospace> -1.82501e-8 0.0;</monospace>
          </p>
          <p>
            <monospace> …;</monospace>
          </p>
          <p>
            <monospace> 0.0 0.0;</monospace>
          </p>
          <p>
            <monospace> 0.0 -0.774597]</monospace>
          </p>
        </boxed-text>
      </sec>
      <sec id="sec013">
        <title>Application</title>
        <p>Channels can act on pure and mixed states represented by vectors and matrices respectively. Channels are callable and therefore mimic application of a function on a quantum state.</p>
        <boxed-text id="pone.0209358.box017" position="anchor" orientation="portrait">
          <p>
            <monospace>julia&gt; <italic>ρ</italic>1 = <italic>ψ</italic> * <italic>ψ</italic>’</monospace>
          </p>
          <p>
            <monospace>2×2 Array{Complex{Float64},2}:</monospace>
          </p>
          <p>
            <monospace> 0.5+0.0im 0.5+0.0im</monospace>
          </p>
          <p>
            <monospace> 0.5+0.0im 0.5+0.0im</monospace>
          </p>
          <p>
            <monospace>julia&gt; Φ(<italic>ρ</italic>1)</monospace>
          </p>
          <p>
            <monospace>2×2 Array{Complex{Float64},2}:</monospace>
          </p>
          <p>
            <monospace> 0.7+0.0im 0.387298+0.0im</monospace>
          </p>
          <p>
            <monospace> 0.387298+0.0im 0.3+0.0im</monospace>
          </p>
          <p>
            <monospace>julia&gt; Ψ1(<italic>ρ</italic>1)</monospace>
          </p>
          <p>
            <monospace>2×2 Array{Complex{Float64},2}:</monospace>
          </p>
          <p>
            <monospace> 0.7+0.0im 0.387298+0.0im</monospace>
          </p>
          <p>
            <monospace> 0.387298+0.0im 0.3+0.0im</monospace>
          </p>
          <p>
            <monospace>julia&gt; Φ(<italic>ψ</italic>)</monospace>
          </p>
          <p>
            <monospace>2×2 Array{Complex{Float64},2}:</monospace>
          </p>
          <p>
            <monospace> 0.7+0.0im 0.387298+0.0im</monospace>
          </p>
          <p>
            <monospace> 0.387298+0.0im 0.3+0.0im</monospace>
          </p>
        </boxed-text>
      </sec>
      <sec id="sec014">
        <title>Composition</title>
        <p>Channels can be composed in parallel or in sequence. Composition in parallel is done using <monospace>kron()</monospace> function or the overloaded ⊗ operator. Composition in sequence can be done in two ways either by using <monospace>Julia</monospace> built-in function composition operator (<italic>f</italic> ∘ <italic>g</italic>)(⋅) = <italic>f</italic>(<italic>g</italic>)(⋅) or by using multiplication of objects inheriting from <monospace>AbstractQuantumOperation{T}</monospace> abstract type.</p>
        <boxed-text id="pone.0209358.box018" position="anchor" orientation="portrait">
          <p>
            <monospace>julia&gt; <italic>ρ</italic>2 = <italic>ϕ</italic> * <italic>ϕ</italic>’</monospace>
          </p>
          <p>
            <monospace>2×2 Array{Complex{Float64},2}:</monospace>
          </p>
          <p>
            <monospace> 0.25+0.0im   0.433013+0.0im</monospace>
          </p>
          <p>
            <monospace> 0.433013+0.0im 0.75+0.0im</monospace>
          </p>
          <p>
            <monospace>julia&gt; (Φ ⊗ Φ)(<italic>ρ</italic>1 ⊗ <italic>ρ</italic>2)</monospace>
          </p>
          <p>
            <monospace>4×4 Array{Complex{Float64},2}:</monospace>
          </p>
          <p>
            <monospace> 0.385+0.0im   0.234787+0.0im 0.213014+0.0im 0.129904+0.0im</monospace>
          </p>
          <p>
            <monospace> 0.234787+0.0im 0.315+0.0im   0.129904+0.0im 0.174284+0.0im</monospace>
          </p>
          <p>
            <monospace> 0.213014+0.0im 0.129904+0.0im 0.165+0.0im   0.100623+0.0im</monospace>
          </p>
          <p>
            <monospace> 0.129904+0.0im 0.174284+0.0im 0.100623+0.0im 0.135+0.0im</monospace>
          </p>
          <p>
            <monospace>julia&gt; (Ψ1 ∘ Ψ2)(<italic>ρ</italic>1)</monospace>
          </p>
          <p>
            <monospace>2×2 Transpose{Complex{Float64},Array{Complex{Float64},2}:</monospace>
          </p>
          <p>
            <monospace>0.82+0.0im 0.3+0.0im</monospace>
          </p>
          <p>
            <monospace>0.3+0.0im 0.18+0.0im</monospace>
          </p>
        </boxed-text>
      </sec>
    </sec>
  </sec>
  <sec id="sec015">
    <title>Functionals</title>
    <sec id="sec016">
      <title>Trace norm and distance</title>
      <p>Let <inline-formula id="pone.0209358.e074"><alternatives><graphic xlink:href="pone.0209358.e074.jpg" id="pone.0209358.e074g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M74"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. The <italic>trace norm</italic> is defined as <inline-formula id="pone.0209358.e075"><alternatives><graphic xlink:href="pone.0209358.e075.jpg" id="pone.0209358.e075g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M75"><mml:mrow><mml:msub><mml:mrow><mml:mo>∥</mml:mo><mml:mi>ρ</mml:mi><mml:mo>∥</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mtext>Tr</mml:mtext><mml:msqrt><mml:mrow><mml:mi>ρ</mml:mi><mml:msup><mml:mi>ρ</mml:mi><mml:mo>†</mml:mo></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula> and the trace distance is defined as <inline-formula id="pone.0209358.e076"><alternatives><graphic xlink:href="pone.0209358.e076.jpg" id="pone.0209358.e076g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M76"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msub><mml:mrow><mml:mo>∥</mml:mo><mml:mi>ρ</mml:mi><mml:mo>-</mml:mo><mml:mi>σ</mml:mi><mml:mo>∥</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <boxed-text id="pone.0209358.box019" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; <italic>ψ</italic> = (1/sqrt(2)) * (ket(1,2) + ket(2,2))</monospace>
        </p>
        <p>
          <monospace>2-element Array{Complex{Float64},1}:</monospace>
        </p>
        <p>
          <monospace> 0.7071067811865475 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.7071067811865475 + 0.0im</monospace>
        </p>
        <p>
          <monospace><italic>ϕ</italic> = (1/2) * ket(1,2) + (sqrt(3)/2) * ket(2,2)</monospace>
        </p>
        <p>
          <monospace>2-element Array{Complex{Float64},1}:</monospace>
        </p>
        <p>
          <monospace> 0.5 + 0.0im</monospace>
        </p>
        <p>
          <monospace> 0.8660254037844386 + 0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; <italic>ρ</italic> = proj(<italic>ψ</italic>)</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.5+0.0im 0.5+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.5+0.0im 0.5+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; <italic>σ</italic> = proj(<italic>ϕ</italic>)</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.25+0.0im 0.433013+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.433013+0.0im 0.75+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; norm_trace(<italic>ρ</italic>)</monospace>
        </p>
        <p>
          <monospace> 1.0</monospace>
        </p>
        <p>
          <monospace>julia&gt; trace_distance(<italic>ρ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.2588190451025207 + 0.0im</monospace>
        </p>
      </boxed-text>
    </sec>
    <sec id="sec017">
      <title>Hilbert–Schmidt norm and distance</title>
      <p>The <italic>Hilbert–Schmidt</italic> norm and distance defined by <inline-formula id="pone.0209358.e077"><alternatives><graphic xlink:href="pone.0209358.e077.jpg" id="pone.0209358.e077g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M77"><mml:mrow><mml:msub><mml:mrow><mml:mo>∥</mml:mo><mml:mi>ρ</mml:mi><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:mi>H</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mtext>Tr</mml:mtext><mml:msup><mml:mi>ρ</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mi>ρ</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209358.e078"><alternatives><graphic xlink:href="pone.0209358.e078.jpg" id="pone.0209358.e078g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M78"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>H</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msub><mml:mrow><mml:mo>∥</mml:mo><mml:mi>ρ</mml:mi><mml:mo>-</mml:mo><mml:mi>σ</mml:mi><mml:mo>∥</mml:mo></mml:mrow><mml:mrow><mml:mi>H</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, respectively, can be used as follows</p>
      <boxed-text id="pone.0209358.box020" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; norm_hs(<italic>ρ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.9999999999999998</monospace>
        </p>
        <p>
          <monospace>julia&gt; hs_distance(<italic>ρ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.36602540378443854</monospace>
        </p>
      </boxed-text>
    </sec>
    <sec id="sec018">
      <title>Fidelity and superfidelity</title>
      <p><italic>Fidelity</italic> is a measure of distance of quantum states. It is an example of a distance measure which is not a metric on the space of quantum states. The fidelity of two quantum states <inline-formula id="pone.0209358.e079"><alternatives><graphic xlink:href="pone.0209358.e079.jpg" id="pone.0209358.e079g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M79"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is given by <inline-formula id="pone.0209358.e080"><alternatives><graphic xlink:href="pone.0209358.e080.jpg" id="pone.0209358.e080g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M80"><mml:mrow><mml:mrow><mml:mi>F</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>∥</mml:mo></mml:mrow><mml:msqrt><mml:mi>ρ</mml:mi></mml:msqrt><mml:msqrt><mml:mi>σ</mml:mi></mml:msqrt><mml:msub><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula></p>
      <boxed-text id="pone.0209358.box021" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; fidelity_sqrt(<italic>ρ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.9659258262890682</monospace>
        </p>
        <p>
          <monospace>julia&gt; fidelity(<italic>ρ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.9330127018922192</monospace>
        </p>
        <p>
          <monospace>julia&gt; fidelity(<italic>ψ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.9330127018922191</monospace>
        </p>
        <p>
          <monospace>julia&gt; fidelity(<italic>ρ</italic>, <italic>ϕ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.9330127018922191</monospace>
        </p>
        <p>
          <monospace>julia&gt; fidelity(<italic>ψ</italic>, <italic>ϕ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.9330127018922192</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation"><italic>Superfidelity</italic> is an upper bound on the fidelity of two quantum states It is defined by <inline-formula id="pone.0209358.e081"><alternatives><graphic xlink:href="pone.0209358.e081.jpg" id="pone.0209358.e081g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M81"><mml:mrow><mml:mi>G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mtext>Tr</mml:mtext><mml:mi>ρ</mml:mi><mml:mi>σ</mml:mi><mml:mo>+</mml:mo><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mtext>Tr</mml:mtext><mml:msup><mml:mi>ρ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mtext>Tr</mml:mtext><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <boxed-text id="pone.0209358.box022" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; superfidelity(<italic>ρ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.9330127018922193</monospace>
        </p>
      </boxed-text>
    </sec>
    <sec id="sec019">
      <title>Diamond norm</title>
      <p>In order to introduce the <italic>diamond norm</italic>, we first introduce the notion of the induced trace norm. Given <inline-formula id="pone.0209358.e082"><alternatives><graphic xlink:href="pone.0209358.e082.jpg" id="pone.0209358.e082g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M82"><mml:mrow><mml:mo>Φ</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> we define its induced trace norm as <inline-formula id="pone.0209358.e083"><alternatives><graphic xlink:href="pone.0209358.e083.jpg" id="pone.0209358.e083g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M83"><mml:mrow><mml:msub><mml:mrow><mml:mo>∥</mml:mo><mml:mo>Φ</mml:mo><mml:mo>∥</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mtext>max</mml:mtext><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mo>∥</mml:mo><mml:mo>Φ</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:mi>X</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>∥</mml:mo><mml:mi>X</mml:mi><mml:mo>∥</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>≤</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. The diamond norm of Φ is defined as <inline-formula id="pone.0209358.e084"><alternatives><graphic xlink:href="pone.0209358.e084.jpg" id="pone.0209358.e084g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M84"><mml:mrow><mml:msub><mml:mrow><mml:mo>∥</mml:mo><mml:mo>Φ</mml:mo><mml:mo>∥</mml:mo></mml:mrow><mml:mo>◇</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>∥</mml:mo><mml:mo>Φ</mml:mo><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mrow><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>∥</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>. One important property of the diamond norm is that for Hermiticity-preserving <inline-formula id="pone.0209358.e085"><alternatives><graphic xlink:href="pone.0209358.e085.jpg" id="pone.0209358.e085g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M85"><mml:mrow><mml:mo>Φ</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> we obtain <inline-formula id="pone.0209358.e086"><alternatives><graphic xlink:href="pone.0209358.e086.jpg" id="pone.0209358.e086g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M86"><mml:mrow><mml:mo>∥</mml:mo><mml:mo>Φ</mml:mo><mml:msub><mml:mo>∥</mml:mo><mml:mo>◇</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mtext>max</mml:mtext><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo>∥</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>Φ</mml:mo><mml:mo>⊗</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mrow><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>〈</mml:mo><mml:mi>ψ</mml:mi></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mo>∥</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>,</mml:mo><mml:mo>〈</mml:mo><mml:mi>ψ</mml:mi><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <boxed-text id="pone.0209358.box023" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; K0 = Matrix([1 0; 0 sqrt(1-<italic>γ</italic>)])</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Float64,2}:</monospace>
        </p>
        <p>
          <monospace> 1.0 0.0</monospace>
        </p>
        <p>
          <monospace> 0.0 0.774597</monospace>
        </p>
        <p>
          <monospace>julia&gt; K1 = Matrix([0 sqrt(<italic>γ</italic>); 0 0])</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Float64,2}:</monospace>
        </p>
        <p>
          <monospace> 0.0 0.632456</monospace>
        </p>
        <p>
          <monospace> 0.0 0.0</monospace>
        </p>
        <p>
          <monospace>julia&gt; Φ = KrausOperators([K0,K1])</monospace>
        </p>
        <p>
          <monospace>KrausOperators{Array{Float64,2}}</monospace>
        </p>
        <p>
          <monospace>dimensions: (2, 2)</monospace>
        </p>
        <p>
          <monospace> [1.0 0.0; 0.0 0.774597]</monospace>
        </p>
        <p>
          <monospace> [0.0 0.632456; 0.0 0.0]</monospace>
        </p>
        <p>
          <monospace>julia&gt; L0 = Matrix([1 0; 0 sqrt(1-<italic>γ</italic>)])</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Float64,2}:</monospace>
        </p>
        <p>
          <monospace> 1.0 0.0</monospace>
        </p>
        <p>
          <monospace> 0.0 0.774597</monospace>
        </p>
        <p>
          <monospace>julia&gt; L1 = Matrix([0 0; 0 sqrt(<italic>γ</italic>)])</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Float64,2}:</monospace>
        </p>
        <p>
          <monospace> 0.0 0.0</monospace>
        </p>
        <p>
          <monospace> 0.0 0.632456</monospace>
        </p>
        <p>
          <monospace>julia&gt; Ψ = KrausOperators([K0,K1])</monospace>
        </p>
        <p>
          <monospace>KrausOperators{Array{Float64,2}}</monospace>
        </p>
        <p>
          <monospace>dimensions: (2, 2)</monospace>
        </p>
        <p>
          <monospace> [1.0 0.0; 0.0 0.774597]</monospace>
        </p>
        <p>
          <monospace> [0.0 0.632456; 0.0 0.0]</monospace>
        </p>
        <p>
          <monospace>julia&gt; norm_diamond(Φ)</monospace>
        </p>
        <p>
          <monospace> 1.0000000077706912</monospace>
        </p>
        <p>
          <monospace>julia&gt; diamond_distance(Φ, Ψ)</monospace>
        </p>
        <p>
          <monospace> -5.258429449675825e-7</monospace>
        </p>
      </boxed-text>
      <p>Diamond norm and diamond distance are implemented using the <monospace>Convex.jl</monospace>
<monospace>Julia</monospace> package [<xref rid="pone.0209358.ref025" ref-type="bibr">25</xref>].</p>
    </sec>
    <sec id="sec020">
      <title>Shannon entropy and von Neumann entropy</title>
      <p><italic>Shannon entropy</italic> is defined for a probability vector <italic>p</italic> as <inline-formula id="pone.0209358.e087"><alternatives><graphic xlink:href="pone.0209358.e087.jpg" id="pone.0209358.e087g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M87"><mml:mrow><mml:mi>H</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="normal">p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>-</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mo form="prefix">log</mml:mo><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>. We also provide an implementation for the point Shannon entropy. It is defined as <italic>h</italic>(<italic>a</italic>) = −<italic>a</italic> log <italic>a</italic> − (1 − <italic>a</italic>) log(1 − <italic>a</italic>).</p>
      <boxed-text id="pone.0209358.box024" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; p = [0.3, 0.2, 0.5]</monospace>
        </p>
        <p>
          <monospace>3-element Array{Float64,1}:</monospace>
        </p>
        <p>
          <monospace> 0.3</monospace>
        </p>
        <p>
          <monospace> 0.2</monospace>
        </p>
        <p>
          <monospace> 0.5</monospace>
        </p>
        <p>
          <monospace>julia&gt; shannon_entropy(p)</monospace>
        </p>
        <p>
          <monospace> 1.0296530140645737</monospace>
        </p>
        <p>
          <monospace>julia&gt; shannon_entropy(0.5)</monospace>
        </p>
        <p>
          <monospace> 0.6931471805599453</monospace>
        </p>
      </boxed-text>
      <p>For a quantum system described by a state <italic>ρ</italic>, the <italic>von Neumann entropy</italic> is <italic>S</italic>(<italic>ρ</italic>) = −tr<italic>ρ</italic> log <italic>ρ</italic>. Let λ<sub><italic>i</italic></sub>, 0 ≤ <italic>i</italic> &lt; <italic>n</italic> be the eigenvalues of <italic>ρ</italic>, then <italic>S</italic>(<italic>ρ</italic>) can be written as <inline-formula id="pone.0209358.e088"><alternatives><graphic xlink:href="pone.0209358.e088.jpg" id="pone.0209358.e088g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M88"><mml:mrow><mml:mi>S</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>-</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msub><mml:mo>λ</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo form="prefix">log</mml:mo><mml:msub><mml:mo>λ</mml:mo><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <boxed-text id="pone.0209358.box025" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; <italic>ρ</italic> = [0.25 0.25im; -0.25im 0.75]</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.25+0.0im 0.0+0.25im</monospace>
        </p>
        <p>
          <monospace> 1-0.0-0.25im 0.75+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; <italic>σ</italic> = [0.4 0.1im; -0.1im 0.6]</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.4+0.0im 0.0+0.1im</monospace>
        </p>
        <p>
          <monospace> -0.0-0.1im 0.6+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; vonneumann_entropy(0.4 * <italic>ρ</italic> + 0.6 * <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.5869295208554555</monospace>
        </p>
      </boxed-text>
    </sec>
    <sec id="sec021">
      <title>Distinguishability between two quantum states</title>
      <p>One of the measure of distinguishability between two quantum states is the <italic>quantum relative entropy</italic>, called also Kullback–Leibler divergence, defined as <italic>S</italic>(<italic>ρ</italic>‖<italic>σ</italic>) = −Tr<italic>ρ</italic> log <italic>σ</italic> + Tr<italic>ρ</italic> log <italic>ρ</italic></p>
      <boxed-text id="pone.0209358.box026" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; relative_entropy(<italic>ρ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.11273751829075163</monospace>
        </p>
        <p>
          <monospace>julia&gt; kl_divergence(<italic>ρ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.11273751829075163</monospace>
        </p>
      </boxed-text>
      <p>Another type of measure of distinguishability between two quantum state is <italic>quantum Jensen–Shannon divergence</italic> given by <inline-formula id="pone.0209358.e089"><alternatives><graphic xlink:href="pone.0209358.e089.jpg" id="pone.0209358.e089g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M89"><mml:mrow><mml:mi>Q</mml:mi><mml:mi>J</mml:mi><mml:mi>S</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mi>ρ</mml:mi><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mi>σ</mml:mi><mml:mo>)</mml:mo><mml:mo>-</mml:mo><mml:mo>(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mi>S</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mi>S</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <boxed-text id="pone.0209358.box027" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; js_divergence(<italic>ρ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.1252860912303596</monospace>
        </p>
      </boxed-text>
      <p><italic>The Bures distance</italic> defines an infinitesimal distance between quantum states, and it is defined as <inline-formula id="pone.0209358.e090"><alternatives><graphic xlink:href="pone.0209358.e090.jpg" id="pone.0209358.e090g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M90"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:msqrt><mml:mrow><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msqrt><mml:mo>)</mml:mo></mml:mrow></mml:msqrt></mml:mrow></mml:math></alternatives></inline-formula>. The value related with Bures distance is the Bures angle <inline-formula id="pone.0209358.e091"><alternatives><graphic xlink:href="pone.0209358.e091.jpg" id="pone.0209358.e091g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M91"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo form="prefix">arccos</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msqrt><mml:mrow><mml:mi>F</mml:mi><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>,</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msqrt><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></p>
      <boxed-text id="pone.0209358.box028" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; bures_distance(<italic>ρ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.24867555729886728</monospace>
        </p>
        <p>
          <monospace>julia&gt; bures_angle(<italic>ρ</italic>, <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.2493208055929498</monospace>
        </p>
      </boxed-text>
    </sec>
    <sec id="sec022">
      <title>Quantum entanglement</title>
      <p>One of the entanglement measures is <italic>negativity</italic> defined as <inline-formula id="pone.0209358.e092"><alternatives><graphic xlink:href="pone.0209358.e092.jpg" id="pone.0209358.e092g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M92"><mml:mrow><mml:mi mathvariant="normal">N</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>ρ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:msup><mml:mi>ρ</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mi>A</mml:mi></mml:msub></mml:msup><mml:msub><mml:mrow><mml:mo>∥</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <boxed-text id="pone.0209358.box029" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; negativity(<italic>ρ</italic> ⊗ <italic>σ</italic>, [2, 2], 2)</monospace>
        </p>
        <p>
          <monospace>-0.0</monospace>
        </p>
        <p>
          <monospace>julia&gt; negativity(proj((1/sqrt(2)*(ket(1,2) ⊗ ket(1,2)-ket(2,2) ⊗ ket(2,2)))), [2, 2], 2)</monospace>
        </p>
        <p>
          <monospace> 0.4999999999999999</monospace>
        </p>
        <p>
          <monospace>julia&gt; log negativity(<italic>ρ</italic> ⊗ <italic>σ</italic>, [2, 2], 2)</monospace>
        </p>
        <p>
          <monospace>-1.1102230246251565e-16</monospace>
        </p>
      </boxed-text>
      <p><italic>Positive partial transpose</italic> (the Peres–Horodecki criterion) is a necessary condition of separability of the joint state <italic>ρ</italic><sub><italic>AB</italic></sub>. According PPT criterion, if <inline-formula id="pone.0209358.e093"><alternatives><graphic xlink:href="pone.0209358.e093.jpg" id="pone.0209358.e093g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M93"><mml:msup><mml:mi>ρ</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mi>B</mml:mi></mml:msub></mml:msup></mml:math></alternatives></inline-formula> has non negative eigenvalues, then <italic>ρ</italic><sub><italic>AB</italic></sub> is separable.</p>
      <boxed-text id="pone.0209358.box030" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; ppt(<italic>ρ</italic> ⊗ <italic>σ</italic>, [2, 2], 2)</monospace>
        </p>
        <p>
          <monospace> 0.052512626584708365</monospace>
        </p>
        <p>
          <monospace>julia&gt; ppt(proj((1/sqrt(2)*(ket(1,2) ⊗ ket(1,2)-ket(2,2) ⊗ ket(2,2)))), [2, 2], 2)</monospace>
        </p>
        <p>
          <monospace>-0.4999999999999999</monospace>
        </p>
      </boxed-text>
      <p>Another way to quantification of quantum entanglement is <italic>Concurrence</italic> [<xref rid="pone.0209358.ref029" ref-type="bibr">29</xref>]. Concurrence of quantum state <italic>ρ</italic> is a strong separability criterion. For two-qubit systems it is defined as <italic>C</italic>(<italic>ρ</italic>) = max(0, λ<sub>1</sub> − λ<sub>2</sub> − λ<sub>3</sub> − λ<sub>4</sub>), where λ<sub><italic>i</italic></sub> are decreasing eigenvalues of <inline-formula id="pone.0209358.e094"><alternatives><graphic xlink:href="pone.0209358.e094.jpg" id="pone.0209358.e094g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M94"><mml:msqrt><mml:mrow><mml:msqrt><mml:mi>ρ</mml:mi></mml:msqrt><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:msqrt><mml:mi>ρ</mml:mi></mml:msqrt></mml:mrow></mml:msqrt></mml:math></alternatives></inline-formula> with <inline-formula id="pone.0209358.e095"><alternatives><graphic xlink:href="pone.0209358.e095.jpg" id="pone.0209358.e095g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M95"><mml:mrow><mml:mover accent="true"><mml:mi>ρ</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mi>ρ</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. If <italic>C</italic>(<italic>ρ</italic>) = 0, then <italic>ρ</italic> is separable.</p>
      <boxed-text id="pone.0209358.box031" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; <italic>ρ</italic> = [0.25 0.1im; -0.1im 0.75]</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.25+0.0im 0.0+0.1im</monospace>
        </p>
        <p>
          <monospace>-0.0-0.1im 0.75+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; <italic>σ</italic> = [0.4 0.1im; -0.1im 0.6]</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.4+0.0im 0.0+0.1im</monospace>
        </p>
        <p>
          <monospace>-0.0-0.1im 0.6+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; concurrence(<italic>ρ</italic> ⊗ <italic>σ</italic>)</monospace>
        </p>
        <p>
          <monospace> 0.0</monospace>
        </p>
        <p>
          <monospace>julia&gt; concurrence(proj(max_entangled(4)))</monospace>
        </p>
        <p>
          <monospace> 0.9999999999999998</monospace>
        </p>
      </boxed-text>
    </sec>
  </sec>
  <sec id="sec023">
    <title>Measurements</title>
    <p>Measurements are modeled in two ways:</p>
    <list list-type="bullet">
      <list-item>
        <p>as Positive Operator Valued Measures (POVMs),</p>
      </list-item>
      <list-item>
        <p>measurements with post-selection.</p>
      </list-item>
    </list>
    <p>In both cases a measurement is treated as a special case of a quantum channel (operation).</p>
    <sec id="sec024">
      <title>Positive Operator Valued Measure measurement</title>
      <p>A POVM measurement is defined as follows. Let <inline-formula id="pone.0209358.e096"><alternatives><graphic xlink:href="pone.0209358.e096.jpg" id="pone.0209358.e096g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M96"><mml:mrow><mml:mi>μ</mml:mi><mml:mo>:</mml:mo><mml:mo>Γ</mml:mo><mml:mo>→</mml:mo><mml:mi mathvariant="normal">P</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> be a mapping from a finite alphabet of measurement outcomes to the set of linear positive operators. If <inline-formula id="pone.0209358.e097"><alternatives><graphic xlink:href="pone.0209358.e097.jpg" id="pone.0209358.e097g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M97"><mml:mrow><mml:msub><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ξ</mml:mi><mml:mo>∈</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mi>μ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>ξ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mi mathvariant="script">X</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> then <italic>μ</italic> is a POVM measurement. The set of positive semi-definite linear operators is defined as <inline-formula id="pone.0209358.e098"><alternatives><graphic xlink:href="pone.0209358.e098.jpg" id="pone.0209358.e098g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M98"><mml:mrow><mml:mi mathvariant="normal">P</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>X</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>:</mml:mo><mml:mo>〈</mml:mo><mml:mi>ψ</mml:mi><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mspace width="4.pt"/><mml:mtext>for</mml:mtext><mml:mspace width="4.pt"/><mml:mtext>all</mml:mtext><mml:mspace width="4.pt"/><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. POVM measurement models the situation where a quantum object is destroyed during the measurement process and quantum state after the measurement does not exists.</p>
      <p>We model POVM measurement as a channel <inline-formula id="pone.0209358.e099"><alternatives><graphic xlink:href="pone.0209358.e099.jpg" id="pone.0209358.e099g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M99"><mml:mrow><mml:mi>θ</mml:mi><mml:mo>:</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>→</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula id="pone.0209358.e100"><alternatives><graphic xlink:href="pone.0209358.e100.jpg" id="pone.0209358.e100g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M100"><mml:msub><mml:mrow><mml:mi mathvariant="script">Y</mml:mi><mml:mo>=</mml:mo><mml:mtext>span</mml:mtext><mml:mrow><mml:mo>{</mml:mo><mml:mi>ξ</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>ξ</mml:mi><mml:mo>∈</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> such that <italic>θ</italic>(<italic>ρ</italic>) = ∑<sub><italic>ξ</italic>∈Γ</sub> tr(<italic>ρ μ</italic>(<italic>ξ</italic>))|<italic>ξ</italic>〉〈<italic>ξ</italic>|. This channel transforms the measured quantum state into a classical state (diagonal matrix) containing probabilities of measuring given outcomes. Note that in <monospace>QuantumInformation.jl</monospace> Γ = {1, 2, …, |Γ|} and POVM measurements are represented by the type</p>
      <boxed-text id="pone.0209358.box032" position="anchor" orientation="portrait">
        <p>
          <monospace>POVMMeasurement{T} &lt;: AbstractQuantumOperation{T} where</monospace>
        </p>
        <p>
          <monospace>T&lt;:AbstractMatrix{&lt;:Number}</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">Predicate function <monospace>ispovm()</monospace> verifies whether a list of matrices is a proper POVM.</p>
      <boxed-text id="pone.0209358.box033" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; <italic>ρ</italic> = proj(1.0/sqrt(2)*(ket(1,3)+ket(3,3)))</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.5+0.0im 0.0+0.0im 0.5+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.5+0.0im 0.0+0.0im 0.5+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; E0 = proj(ket(1,3))</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 1.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; E1 = proj(ket(2,3))+proj(ket(3,3))</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 1.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 1.0+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; M = POVMMeasurement([E0,E1])</monospace>
        </p>
        <p>
          <monospace>POVMMeasurement{Array{Complex{Float64},2}}</monospace>
        </p>
        <p>
          <monospace>dimensions: (3, 2)</monospace>
        </p>
        <p>
          <monospace>Complex{Float64}</monospace>
        </p>
        <p>
          <monospace> [1.0+0.0im 0.0+0.0im 0.0+0.0im;</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im;</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im]</monospace>
        </p>
        <p>
          <monospace>Complex{Float64}</monospace>
        </p>
        <p>
          <monospace> [0.0+0.0im 0.0+0.0im 0.0+0.0im;</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 1.0+0.0im 0.0+0.0im;</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 1.0+0.0im]</monospace>
        </p>
        <p>
          <monospace>julia&gt; ispovm(M)</monospace>
        </p>
        <p>
          <monospace> true</monospace>
        </p>
        <p>
          <monospace>julia&gt; M(<italic>ρ</italic>)</monospace>
        </p>
        <p>
          <monospace>2×2 LinearAlgebra.Diagonal{Float64,Array{Float64,1}}:</monospace>
        </p>
        <p>
          <monospace> 0.5 .</monospace>
        </p>
        <p>
          <monospace> . 0.5</monospace>
        </p>
      </boxed-text>
    </sec>
    <sec id="sec025">
      <title>Measurement with post-selection</title>
      <p>When a quantum system after being measured is not destroyed one can be interested in its state after the measurement. This state depends on the measurement outcome. In this case the measurement process is defined in the following way.</p>
      <p>Let <inline-formula id="pone.0209358.e101"><alternatives><graphic xlink:href="pone.0209358.e101.jpg" id="pone.0209358.e101g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M101"><mml:mrow><mml:mi>μ</mml:mi><mml:mo>:</mml:mo><mml:mo>Γ</mml:mo><mml:mo>→</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> be a mapping from a finite set of measurement outcomes to set of linear operators called effects. If <inline-formula id="pone.0209358.e102"><alternatives><graphic xlink:href="pone.0209358.e102.jpg" id="pone.0209358.e102g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M102"><mml:mrow><mml:msub><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ξ</mml:mi><mml:mo>∈</mml:mo><mml:mo>Γ</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mi>μ</mml:mi><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>ξ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>†</mml:mo></mml:msup><mml:mi>μ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>ξ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mi mathvariant="script">X</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> then <italic>μ</italic> is a quantum measurement. Given outcome <italic>ξ</italic> was obtained, the state before the measurement, <italic>ρ</italic>, is transformed into sub-normalized quantum state <italic>ρ</italic><sub><italic>ξ</italic></sub> = <italic>μ</italic>(<italic>ξ</italic>)<italic>ρμ</italic>(<italic>ξ</italic>)<sup>†</sup>. The outcome <italic>ξ</italic> will be obtained with probability <italic>tr</italic>(<italic>ρ</italic><sub><italic>ξ</italic></sub>).</p>
      <boxed-text id="pone.0209358.box034" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; PM = PostSelectionMeasurement(E1)</monospace>
        </p>
        <p>
          <monospace>PostSelectionMeasurement{Array{Complex{Float64},2}}</monospace>
        </p>
        <p>
          <monospace>dimensions: (3, 3)</monospace>
        </p>
        <p>
          <monospace>Complex{Float64}</monospace>
        </p>
        <p>
          <monospace> [0.0+0.0im 0.0+0.0im 0.0+0.0im;</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 1.0+0.0im 0.0+0.0im;</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 1.0+0.0im]</monospace>
        </p>
        <p>
          <monospace>julia&gt; iseffect(PM)</monospace>
        </p>
        <p>
          <monospace> true</monospace>
        </p>
        <p>
          <monospace>julia&gt; PM(<italic>ρ</italic>)</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.5+0.0im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">In <monospace>QuantumInformation.jl</monospace> this kind of measurement is modeled as CP-TNI map with a single Kraus operator <italic>μ</italic>(<italic>ξ</italic>) and represented as</p>
      <boxed-text id="pone.0209358.box035" position="anchor" orientation="portrait">
        <p>
          <monospace>PostSelectionMeasurement{T} &lt;: AbstractQuantumOperation{T} where</monospace>
        </p>
        <p>
          <monospace>T&lt;:AbstractMatrix{&lt;:Number}</monospace>
        </p>
      </boxed-text>
      <p>Measurement types can be composed and converted to Kraus operators, superoperators, Stinespring representation operators, and dynamical matrices.</p>
      <boxed-text id="pone.0209358.box036" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; <italic>α</italic> = 0.3</monospace>
        </p>
        <p>
          <monospace> 0.3</monospace>
        </p>
        <p>
          <monospace>julia&gt; K0 = ComplexF64[0 0 sqrt(<italic>α</italic>); 0 1 0; 0 0 0]</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.547723+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 1.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; K1 = ComplexF64[1 0 0; 0 0 0; 0 0 sqrt(1 − α)]</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 1.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.83666+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; Φ = KrausOperators([K0,K1])</monospace>
        </p>
        <p>
          <monospace>KrausOperators{Array{Complex{Float64},2}}</monospace>
        </p>
        <p>
          <monospace>dimensions: (3, 3)</monospace>
        </p>
        <p>
          <monospace>Complex{Float64}</monospace>
        </p>
        <p>
          <monospace> [0.0+0.0im 0.0+0.0im 0.547723+0.0im;</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 1.0+0.0im 0.0+0.0im;</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im]</monospace>
        </p>
        <p>
          <monospace>Complex{Float64}</monospace>
        </p>
        <p>
          <monospace> [1.0+0.0im 0.0+0.0im 0.0+0.0im;</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im;</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.83666+0.0im]</monospace>
        </p>
        <p>
          <monospace>julia&gt; <italic>ρ</italic> = proj(1.0/sqrt(2)*(ket(1,3)+ket(3,3)))</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.5+0.0im 0.0+0.0im 0.5+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.5+0.0im 0.0+0.0im 0.5+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; (PM ∘ Φ)(<italic>ρ</italic>)</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.0+0.0im</monospace>
        </p>
        <p>
          <monospace> 0.0+0.0im 0.0+0.0im 0.35+0.0im</monospace>
        </p>
      </boxed-text>
    </sec>
  </sec>
  <sec id="sec026">
    <title>Random quantum objects</title>
    <p>In this section we present the implementation of the sub-package <monospace>RandomMatrices</monospace>. The justification for including these functionalities in our package is twofold. First, the application of random matrix theory (RMT) in quantum information is a blooming field of research with a plethora of interesting results [<xref rid="pone.0209358.ref030" ref-type="bibr">30</xref>–<xref rid="pone.0209358.ref039" ref-type="bibr">39</xref>]. Hence, it is useful to have readily available implementations of known algorithms of generating random matrices. Secondly, when performing numerical investigations, we often need “generic” inputs. Generating random matrices with a known distribution is one of the ways to obtain such generic inputs.</p>
    <sec id="sec027">
      <title>Ginibre matrices</title>
      <p>In this section we introduce the Ginibre random matrices ensemble [<xref rid="pone.0209358.ref040" ref-type="bibr">40</xref>]. This ensemble is at the core of a vast majority of algorithms for generating random matrices presented in later subsections. Let (<italic>G</italic><sub><italic>ij</italic></sub>)<sub>1≤<italic>i</italic>≤<italic>m</italic>,1≤<italic>j</italic>≤<italic>n</italic></sub> be a <italic>m</italic> × <italic>n</italic> table of independent identically distributed (i.i.d.) random variable on <inline-formula id="pone.0209358.e103"><alternatives><graphic xlink:href="pone.0209358.e103.jpg" id="pone.0209358.e103g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M103"><mml:mi mathvariant="double-struck">K</mml:mi></mml:math></alternatives></inline-formula>. The field <inline-formula id="pone.0209358.e104"><alternatives><graphic xlink:href="pone.0209358.e104.jpg" id="pone.0209358.e104g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M104"><mml:mi mathvariant="double-struck">K</mml:mi></mml:math></alternatives></inline-formula> can be either of ℝ, ℂ or ℚ. With each of the fields we associate a Dyson index <italic>β</italic> equal to 1, 2, or 4 respectively. Let <italic>G</italic><sub><italic>ij</italic></sub> be i.i.d random variables with the real and imaginary parts sampled independently from the distribution <inline-formula id="pone.0209358.e105"><alternatives><graphic xlink:href="pone.0209358.e105.jpg" id="pone.0209358.e105g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M105"><mml:mrow><mml:mi mathvariant="script">N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>β</mml:mi></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. Hence, <inline-formula id="pone.0209358.e106"><alternatives><graphic xlink:href="pone.0209358.e106.jpg" id="pone.0209358.e106g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M106"><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>,where matrix <italic>G</italic> is
<disp-formula id="pone.0209358.e107"><alternatives><graphic xlink:href="pone.0209358.e107.jpg" id="pone.0209358.e107g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M107"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∝</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mtext>Tr</mml:mtext><mml:mi>G</mml:mi><mml:msup><mml:mi>G</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives><label>(7)</label></disp-formula>
This law is unitarily invariant, meaning that for any unitary matrices <italic>U</italic> and <italic>V</italic>, <italic>G</italic> and <italic>UGV</italic> are equally distributed. It can be shown that for <italic>β</italic> = 2 the eigenvalues of <italic>G</italic> are uniformly distributed over the unit disk on the complex plane [<xref rid="pone.0209358.ref041" ref-type="bibr">41</xref>].</p>
      <p>In our library the ensemble Ginibre matrices is implemented in the <monospace>GinibreEnsemble{<italic>β</italic>}</monospace> parametric type. The parameter determines the Dyson index. The following constructors are provided</p>
      <boxed-text id="pone.0209358.box037" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; GinibreEnsemble{<italic>β</italic>}(m::Int, n::Int)</monospace>
        </p>
        <p>
          <monospace>julia&gt; GinibreEnsemble{<italic>β</italic>}(m::Int)</monospace>
        </p>
        <p>
          <monospace>julia&gt; GinibreEnsemble(m::Int, n::Int)</monospace>
        </p>
        <p>
          <monospace>julia&gt; GinibreEnsemble(m::Int)</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The parameters <italic>n</italic> and <italic>m</italic> determine the dimensions of output and input spaces. The versions with one argument assume <italic>m</italic> = <italic>n</italic>. When the Dyson index is omitted it assumed that <italic>β</italic> = 2. Sampling from these distributions can be performed as follows</p>
      <boxed-text id="pone.0209358.box038" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; g = GinibreEnsemble{2}(2,3)</monospace>
        </p>
        <p>
          <monospace> GinibreEnsemble{2}(m = 2, n = 3)</monospace>
        </p>
        <p>
          <monospace>julia&gt; rand(g)</monospace>
        </p>
        <p>
          <monospace>2×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.835803+1.10758im -0.622744-0.130165im -0.677944+0.636562im</monospace>
        </p>
        <p>
          <monospace> 1.32826+0.106582im -0.460737-0.531975im -0.656758+0.0244259im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The function <monospace>rand</monospace> has specialized methods for each possible value of the Dyson index <italic>β</italic>.</p>
    </sec>
    <sec id="sec028">
      <title>Wishart matrices</title>
      <p>Wishart matrices form an ensemble of random positive semidefinite matrices. They are parametrized by two factors. First is the Dyson index <italic>β</italic> which is equal to one for real matrices, two for complex matrices and four for symplectic matrices. The second parameter, <italic>K</italic>, is responsible for the rank of the matrices. They are sampled as follows</p>
      <list list-type="order">
        <list-item>
          <p>Choose <italic>β</italic> and <italic>K</italic>.</p>
        </list-item>
        <list-item>
          <p>Sample a Ginibre matrix <inline-formula id="pone.0209358.e108"><alternatives><graphic xlink:href="pone.0209358.e108.jpg" id="pone.0209358.e108g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M108"><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> with the Dyson index <italic>β</italic> and <inline-formula id="pone.0209358.e109"><alternatives><graphic xlink:href="pone.0209358.e109.jpg" id="pone.0209358.e109g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M109"><mml:mrow><mml:mtext>dim</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0209358.e110"><alternatives><graphic xlink:href="pone.0209358.e110.jpg" id="pone.0209358.e110g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M110"><mml:mrow><mml:mtext>dim</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>K</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
        </list-item>
        <list-item>
          <p>Return <italic>GG</italic><sup>†</sup>.</p>
        </list-item>
      </list>
      <p>In <monospace>QuantumInformation.jl</monospace> this is implemented using the type <monospace>WishartEnsemble{<italic>β</italic>, K}</monospace>. We also provide additional constructors for convenience</p>
      <boxed-text id="pone.0209358.box039" position="anchor" orientation="portrait">
        <p>
          <monospace>WishartEnsemble{<italic>β</italic>}(d::Int) where <italic>β</italic> = WishartEnsemble{<italic>β</italic>, 1}(d)</monospace>
        </p>
        <p>
          <monospace>WishartEnsemble(d::Int) = WishartEnsemble{2}(d)</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">These can be used in the following way</p>
      <boxed-text id="pone.0209358.box040" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; w = WishartEnsemble{1,0.2}(5)</monospace>
        </p>
        <p>
          <monospace> WishartEnsemble{1,0.2}(d = 5)</monospace>
        </p>
        <p>
          <monospace>julia&gt; z = rand(w)</monospace>
        </p>
        <p>
          <monospace>5×5 Array{Float64,2}:</monospace>
        </p>
        <p>
          <monospace> 0.0897637 0.0257443 0.0314593 0.0223569 0.093517</monospace>
        </p>
        <p>
          <monospace> 0.0257443 0.00738347 0.00902253 0.00641196 0.0268207</monospace>
        </p>
        <p>
          <monospace> 0.0314593 0.00902253 0.0110254 0.00783535 0.0327746</monospace>
        </p>
        <p>
          <monospace> 0.0223569 0.00641196 0.00783535 0.00556828 0.0232917</monospace>
        </p>
        <p>
          <monospace> 0.093517 0.0268207 0.0327746 0.0232917 0.0974271</monospace>
        </p>
        <p>
          <monospace>julia&gt; eigvals(z)</monospace>
        </p>
        <p>
          <monospace>5-element Array{Float64,1}:</monospace>
        </p>
        <p>
          <monospace> -1.549149323294561e-17</monospace>
        </p>
        <p>
          <monospace> -1.11670454111383e-18</monospace>
        </p>
        <p>
          <monospace> 1.5797866551971292e-18</monospace>
        </p>
        <p>
          <monospace> 6.408793727745745e-18</monospace>
        </p>
        <p>
          <monospace> 0.21116803949130986</monospace>
        </p>
        <p>
          <monospace>julia&gt; w = WishartEnsemble(3)</monospace>
        </p>
        <p>
          <monospace> WishartEnsemble{2,1}(d = 3)</monospace>
        </p>
        <p>
          <monospace>julia&gt; z = rand(w)</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.474628+0.0im 0.177244-0.0227445im 0.137337-0.0929298im</monospace>
        </p>
        <p>
          <monospace> 0.177244+0.0227445im 0.128676+0.0im 0.0938587-0.165916im</monospace>
        </p>
        <p>
          <monospace> 0.137337+ 0.0929298im 0.0938587+0.165916im 0.555453+0.0im</monospace>
        </p>
        <p>
          <monospace>julia&gt; eigvals(z)</monospace>
        </p>
        <p>
          <monospace>3-element Array{Float64,1}:</monospace>
        </p>
        <p>
          <monospace> 0.01707438064450695</monospace>
        </p>
        <p>
          <monospace> 0.35884924300093163</monospace>
        </p>
        <p>
          <monospace> 0.7828337014291611</monospace>
        </p>
      </boxed-text>
    </sec>
    <sec id="sec029">
      <title>Circular ensembles</title>
      <p>Circular ensembles are measures on the space of unitary matrices. There are three main circular ensembles. Each of this ensembles has an associated Dyson index <italic>β</italic> [<xref rid="pone.0209358.ref042" ref-type="bibr">42</xref>]</p>
      <list list-type="bullet">
        <list-item>
          <p>Circular orthogonal ensemble (COE), <italic>β</italic> = 1.</p>
        </list-item>
        <list-item>
          <p>Circular unitary ensemble (CUE), <italic>β</italic> = 2.</p>
        </list-item>
        <list-item>
          <p>Circular symplectic ensemble (CSE), <italic>β</italic> = 4.</p>
        </list-item>
      </list>
      <p>They can be characterized as follows. The CUE is simply the Haar measure on the unitary group. Now, if <italic>U</italic> is an element of CUE then <italic>U</italic><sup><italic>T</italic></sup>
<italic>U</italic> is an element of <italic>COE</italic> and <italic>U</italic><sub><italic>R</italic></sub>
<italic>U</italic> is an element CSE. Here
<disp-formula id="pone.0209358.e111"><alternatives><graphic xlink:href="pone.0209358.e111.jpg" id="pone.0209358.e111g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M111"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>U</mml:mi><mml:mi>R</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd/><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd/><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo><mml:msup><mml:mi>U</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd/><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd/><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd><mml:mo>⋱</mml:mo></mml:mtd><mml:mtd/><mml:mtd/></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd/><mml:mtd><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(8)</label></disp-formula>
As can be seen the sampling of Haar unitaries is at the core of sampling these ensembles. Hence, we will focus on them in the remainder of this section.</p>
      <p>There are several possible approaches to generating random unitary matrices according to the Haar measure. One way is to consider known parametrizations of unitary matrices, such as the Euler [<xref rid="pone.0209358.ref043" ref-type="bibr">43</xref>] or Jarlskog [<xref rid="pone.0209358.ref044" ref-type="bibr">44</xref>] ones. Sampling these parameters from appropriate distributions yields a Haar random unitary. The downside is the long computation time, especially for large matrices, as this involves a lot of matrix multiplications. We will not go into this further, we refer the interested reader to the papers on these parametrizations.</p>
      <p>Another approach is to consider a Ginibre matrix <inline-formula id="pone.0209358.e112"><alternatives><graphic xlink:href="pone.0209358.e112.jpg" id="pone.0209358.e112g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M112"><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and its polar decomposition <italic>G</italic> = <italic>UP</italic>, where <inline-formula id="pone.0209358.e113"><alternatives><graphic xlink:href="pone.0209358.e113.jpg" id="pone.0209358.e113g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M113"><mml:mrow><mml:mi>U</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is unitary and <italic>P</italic> is a positive matrix. The matrix <italic>P</italic> is unique and given by <inline-formula id="pone.0209358.e114"><alternatives><graphic xlink:href="pone.0209358.e114.jpg" id="pone.0209358.e114g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M114"><mml:msqrt><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mi>G</mml:mi></mml:mrow></mml:msqrt></mml:math></alternatives></inline-formula>. Hence, assuming <italic>P</italic> is invertible, we could recover <italic>U</italic> as
<disp-formula id="pone.0209358.e115"><alternatives><graphic xlink:href="pone.0209358.e115.jpg" id="pone.0209358.e115g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M115"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>U</mml:mi><mml:mo>=</mml:mo><mml:mi>G</mml:mi><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi>G</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mi>G</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(9)</label></disp-formula>
As this involves the inverse square root of a matrix, this approach can be potentially numerically unstable.</p>
      <p>The optimal approach is to utilize the QR decomposition of <italic>G</italic>, <italic>G</italic> = <italic>QR</italic>, where <inline-formula id="pone.0209358.e116"><alternatives><graphic xlink:href="pone.0209358.e116.jpg" id="pone.0209358.e116g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M116"><mml:mrow><mml:mi>Q</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is unitary and <inline-formula id="pone.0209358.e117"><alternatives><graphic xlink:href="pone.0209358.e117.jpg" id="pone.0209358.e117g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M117"><mml:mrow><mml:mi>R</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is upper triangular. This procedure is unique if <italic>G</italic> is invertible and we require the diagonal elements of <italic>R</italic> to be positive. As typical implementations of the QR algorithm do not consider this restriction, we must enforce it ourselves. The algorithm is as follows</p>
      <list list-type="order">
        <list-item>
          <p>Generate a Ginibre matrix <inline-formula id="pone.0209358.e118"><alternatives><graphic xlink:href="pone.0209358.e118.jpg" id="pone.0209358.e118g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M118"><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pone.0209358.e119"><alternatives><graphic xlink:href="pone.0209358.e119.jpg" id="pone.0209358.e119g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M119"><mml:mrow><mml:mtext>dim</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> with Dyson index <italic>β</italic> = 2.</p>
        </list-item>
        <list-item>
          <p>Perform the QR decomposition obtaining <italic>Q</italic> and <italic>R</italic>.</p>
        </list-item>
        <list-item>
          <p>Multiply the <italic>i</italic><sup>th</sup> column of <italic>Q</italic> by <italic>r</italic><sub><italic>ii</italic></sub>/|<italic>r</italic><sub><italic>ii</italic></sub>|.</p>
        </list-item>
      </list>
      <p>This gives us a Haar distributed random unitary. For detailed analysis of this algorithm see [<xref rid="pone.0209358.ref027" ref-type="bibr">27</xref>]. This procedure can be generalized in order to obtain a random isometry. The only required changed is the dimension of <italic>G</italic>. We simply start with <inline-formula id="pone.0209358.e120"><alternatives><graphic xlink:href="pone.0209358.e120.jpg" id="pone.0209358.e120g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M120"><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula id="pone.0209358.e121"><alternatives><graphic xlink:href="pone.0209358.e121.jpg" id="pone.0209358.e121g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M121"><mml:mrow><mml:mo form="prefix">dim</mml:mo><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>≥</mml:mo><mml:mo form="prefix">dim</mml:mo><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>Furthermore, we may introduce two additional circular ensembles corresponding to the Haar measure on the orthogonal and symplectic groups. These are the circular real ensemble (CRE) and circular quaternion ensemble (CQE). Their sampling is similar to sampling from CUE. The only difference is the initial Dyson index of the Ginibre matrix. This is set to <italic>β</italic> = 1 for CRE and <italic>β</italic> = 4 for CQE.</p>
      <p>In <monospace>QuantumInformation.jl</monospace> these distributions can be sampled as</p>
      <boxed-text id="pone.0209358.box041" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; c = CircularEnsemble{2}(3)</monospace>
        </p>
        <p>
          <monospace>CircularEnsemble{2}(</monospace>
        </p>
        <p>
          <monospace>d: 3</monospace>
        </p>
        <p>
          <monospace>g: GinibreEnsemble{2}(m = 3, n = 3)</monospace>
        </p>
        <p>
          <monospace>)</monospace>
        </p>
        <p>
          <monospace>julia&gt; u = rand(c)</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 0.339685+0.550434im -0.392266-0.3216im -0.53172+0.203988im</monospace>
        </p>
        <p>
          <monospace> 0.515118-0.422262im 0.392165-0.626859im -0.0504431-0.084009im</monospace>
        </p>
        <p>
          <monospace> 0.297203+0.222832im -0.418737-0.143578im 0.607012-0.545525im</monospace>
        </p>
        <p>
          <monospace>julia&gt; u*u’</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 1.0+0.0im -5.55112e-17-5.55112e-17im -2.77556e-17-4.16334e-17im</monospace>
        </p>
        <p>
          <monospace> -5.55112e-17+5.55112e-17im 1.0+0.0im -2.498e-16+0.0im</monospace>
        </p>
        <p>
          <monospace> -2.77556e-17+4.16334e-17im -2.498e-16+0.0im 1.0+0.0im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">Sampling from the Haar measure on the orthogonal group can be achieved as</p>
      <boxed-text id="pone.0209358.box042" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; c = CircularRealEnsemble(3)</monospace>
        </p>
        <p>
          <monospace>CircularRealEnsemble(</monospace>
        </p>
        <p>
          <monospace>d: 3</monospace>
        </p>
        <p>
          <monospace>g: GinibreEnsemble{1}(m = 3, n = 3)</monospace>
        </p>
        <p>
          <monospace>)</monospace>
        </p>
        <p>
          <monospace>julia&gt; o = rand(c)</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Float64,2}:</monospace>
        </p>
        <p>
          <monospace> 0.772464 0.611349 -0.171907</monospace>
        </p>
        <p>
          <monospace> 0.0524376 0.208368 0.976644</monospace>
        </p>
        <p>
          <monospace> 0.63289 -0.763436 0.128899</monospace>
        </p>
        <p>
          <monospace>julia&gt; o*o’</monospace>
        </p>
        <p>
          <monospace>3×3 Array{Float64,2}:</monospace>
        </p>
        <p>
          <monospace> 1.0 -1.38778e-16 -8.67362e-17</monospace>
        </p>
        <p>
          <monospace> -1.38778e-16 1.0 8.32667e-17</monospace>
        </p>
        <p>
          <monospace> -8.67362e-17 8.32667e-17 1.0</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">For convenience we provide the following type aliases</p>
      <boxed-text id="pone.0209358.box043" position="anchor" orientation="portrait">
        <p>
          <monospace>const COE = CircularEnsemble{1}</monospace>
        </p>
        <p>
          <monospace>const CUE = CircularEnsemble{2}</monospace>
        </p>
        <p>
          <monospace>const CSE = CircularEnsemble{4}</monospace>
        </p>
      </boxed-text>
    </sec>
    <sec id="sec030">
      <title>Random quantum states</title>
      <p>In this section we discuss the properties and methods of generating random quantum states. We will treat quantum channels as a special case of quantum states.</p>
      <sec id="sec031">
        <title>Pure states</title>
        <p>Pure states are elements of the unit sphere in <inline-formula id="pone.0209358.e122"><alternatives><graphic xlink:href="pone.0209358.e122.jpg" id="pone.0209358.e122g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M122"><mml:mi mathvariant="script">X</mml:mi></mml:math></alternatives></inline-formula>. Thus it is straightforward to generate them randomly. We start with a vector of <inline-formula id="pone.0209358.e123"><alternatives><graphic xlink:href="pone.0209358.e123.jpg" id="pone.0209358.e123g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M123"><mml:mrow><mml:mo form="prefix">dim</mml:mo><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> independent complex numbers sampled from the standard normal distribution. What remains is to normalize the length of this vector to unity.</p>
        <p>This is implemented using the <monospace>HaarKet{<italic>β</italic>}</monospace> type. The value <italic>β</italic> = 1 corresponds to the Haar measure on the unit sphere in ℝ<sup><italic>d</italic></sup>, while <italic>β</italic> = 2 corresponds to the Haar measure on the unit sphere in ℂ<sup><italic>d</italic></sup>. The usage is as follows</p>
        <boxed-text id="pone.0209358.box044" position="anchor" orientation="portrait">
          <p>
            <monospace>julia&gt; h = HaarKet{2}(3)</monospace>
          </p>
          <p>
            <monospace>HaarKet{2}(d = 3)</monospace>
          </p>
          <p>
            <monospace>julia&gt; <italic>ψ</italic> = rand(h)</monospace>
          </p>
          <p>
            <monospace>3-element Array{Complex{Float64},1}:</monospace>
          </p>
          <p>
            <monospace> 0.1687649644765863 − 0.3201009507269653im</monospace>
          </p>
          <p>
            <monospace> 0.7187423269572294 − 0.39405022770434767im</monospace>
          </p>
          <p>
            <monospace> 0.1342475675218075 + 0.42327915636096036im</monospace>
          </p>
          <p>
            <monospace>julia&gt; norm(<italic>ψ</italic>)</monospace>
          </p>
          <p>
            <monospace> 1.0</monospace>
          </p>
        </boxed-text>
        <p specific-use="continuation">For convenience we provide the following constructor</p>
        <boxed-text id="pone.0209358.box045" position="anchor" orientation="portrait">
          <p>
            <monospace>HaarKet(d::Int) = HaarKet{2}(d)</monospace>
          </p>
        </boxed-text>
        <p specific-use="continuation">as the majority of uses cases require sampling complex states.</p>
      </sec>
      <sec id="sec032">
        <title>Mixed states</title>
        <p>Random mixed states can be generated in one of two equivalent ways. The first one comes from the partial trace of random pure states. Suppose we have a pure state <inline-formula id="pone.0209358.e124"><alternatives><graphic xlink:href="pone.0209358.e124.jpg" id="pone.0209358.e124g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M124"><mml:mrow><mml:mi>ψ</mml:mi><mml:mo>〉</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="script">Y</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>. Then we can obtain a random mixed as
<disp-formula id="pone.0209358.e125"><alternatives><graphic xlink:href="pone.0209358.e125.jpg" id="pone.0209358.e125g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M125"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mtext>tr</mml:mtext><mml:mi mathvariant="script">Y</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mrow><mml:mi>ψ</mml:mi><mml:mo>⟩</mml:mo><mml:mo>⟨</mml:mo></mml:mrow><mml:mi>ψ</mml:mi><mml:mo>|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(10)</label></disp-formula>
Note that in the case <inline-formula id="pone.0209358.e126"><alternatives><graphic xlink:href="pone.0209358.e126.jpg" id="pone.0209358.e126g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M126"><mml:mrow><mml:mo form="prefix">dim</mml:mo><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo form="prefix">dim</mml:mo><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> we recover the (flat) Hilbert-Schmidt distribution on the set of quantum states.</p>
        <p>An alternative approach is to start with a Ginibre matrix <inline-formula id="pone.0209358.e127"><alternatives><graphic xlink:href="pone.0209358.e127.jpg" id="pone.0209358.e127g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M127"><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. We obtain a random quantum state <italic>ρ</italic> as
<disp-formula id="pone.0209358.e128"><alternatives><graphic xlink:href="pone.0209358.e128.jpg" id="pone.0209358.e128g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M128"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>ρ</mml:mi><mml:mo>=</mml:mo><mml:mi>G</mml:mi><mml:msup><mml:mi>G</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mo>/</mml:mo><mml:mtext>Tr</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>G</mml:mi><mml:msup><mml:mi>G</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(11)</label></disp-formula>
It can be easily verified that this approach is equivalent to the one utilizing random pure states. First, note that in both cases we start with <inline-formula id="pone.0209358.e129"><alternatives><graphic xlink:href="pone.0209358.e129.jpg" id="pone.0209358.e129g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M129"><mml:mrow><mml:mo form="prefix">dim</mml:mo><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo form="prefix">dim</mml:mo><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> complex random numbers sampled from the standard normal distribution. Next, we only need to note that taking the partial trace of a pure state |<italic>ψ</italic>〉 is equivalent to calculating <italic>AA</italic><sup>†</sup> where <italic>A</italic> is a matrix obtained from reshaping |<italic>ψ</italic>〉.</p>
        <p>The properties of these states have been extensively studied. We will omit stating all the properties here and refer the reader to [<xref rid="pone.0209358.ref031" ref-type="bibr">31</xref>–<xref rid="pone.0209358.ref036" ref-type="bibr">36</xref>].</p>
        <p>Sampling random mixed states is implemented using the <monospace>HilbertSchmidtStates{<italic>β</italic>, K}</monospace> type. The meaning of the type parameters is the same as in the Wishart matrices case. We provide additional constructors which set the default values of the parameters</p>
        <boxed-text id="pone.0209358.box046" position="anchor" orientation="portrait">
          <p>
            <monospace>HilbertSchmidtStates{<italic>β</italic>}(d::Int) where <italic>β</italic> = HilbertSchmidtStates{<italic>β</italic>, 1}(d)</monospace>
          </p>
          <p>
            <monospace>HilbertSchmidtStates(d::Int) = HilbertSchmidtStates{2, 1}(d)</monospace>
          </p>
        </boxed-text>
        <p specific-use="continuation">The latter one is the most frequent use case. Here is an example</p>
        <boxed-text id="pone.0209358.box047" position="anchor" orientation="portrait">
          <p>
            <monospace>julia&gt; h = HilbertSchmidtStates(3)</monospace>
          </p>
          <p>
            <monospace>HilbertSchmidtStates{2,1}(WishartEnsemble{2,1}(d = 3), 3)</monospace>
          </p>
          <p>
            <monospace>julia&gt; <italic>ρ</italic> = rand(h)</monospace>
          </p>
          <p>
            <monospace>3×3 Array{Complex{Float64},2}:</monospace>
          </p>
          <p>
            <monospace> 0.335603+0.0im 0.0696096+0.0606972im 0.0373103+0.0853966im</monospace>
          </p>
          <p>
            <monospace> 0.0696096-0.0606972im 0.209561+0.0im -0.000865656+0.0129982im</monospace>
          </p>
          <p>
            <monospace> 0.0373103-0.0853966im -0.000865656-0.0129982im 0.454836+0.0im</monospace>
          </p>
          <p>
            <monospace>julia&gt; tr(<italic>ρ</italic>)</monospace>
          </p>
          <p>
            <monospace> 1.0 + 0.0im</monospace>
          </p>
          <p>
            <monospace>julia&gt; eigvals(<italic>ρ</italic>)</monospace>
          </p>
          <p>
            <monospace>3-element Array{Float64,1}:</monospace>
          </p>
          <p>
            <monospace> 0.15460054248543945</monospace>
          </p>
          <p>
            <monospace> 0.3306739537037592</monospace>
          </p>
          <p>
            <monospace> 0.5147255038108014</monospace>
          </p>
        </boxed-text>
      </sec>
    </sec>
    <sec id="sec033">
      <title>Random quantum channels</title>
      <p>Quantum channels are a special subclass of quantum states with constraints imposed on their <italic>partial</italic> trace as well as trace. Formally, we start with a Ginibre matrix <inline-formula id="pone.0209358.e130"><alternatives><graphic xlink:href="pone.0209358.e130.jpg" id="pone.0209358.e130g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M130"><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:mtext>L</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>⊗</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>,</mml:mo><mml:mi>𝒵</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. We obtain a random Choi-Jamiołkowski matrix <italic>J</italic><sub>Φ</sub> corresponding to a channel Φ as
<disp-formula id="pone.0209358.e131"><alternatives><graphic xlink:href="pone.0209358.e131.jpg" id="pone.0209358.e131g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M131"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>J</mml:mi><mml:mo>Φ</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mi mathvariant="script">X</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mtext>Tr</mml:mtext><mml:mi mathvariant="script">X</mml:mi></mml:msub><mml:mi>G</mml:mi><mml:msup><mml:mi>G</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mi>G</mml:mi><mml:msup><mml:mi>G</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mo>(</mml:mo><mml:msub><mml:mi mathvariant="double-struck">I</mml:mi><mml:mi mathvariant="script">X</mml:mi></mml:msub><mml:mo>⊗</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mtext>Tr</mml:mtext><mml:mi mathvariant="script">X</mml:mi></mml:msub><mml:mi>G</mml:mi><mml:msup><mml:mi>G</mml:mi><mml:mo>†</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(12)</label></disp-formula>
When <inline-formula id="pone.0209358.e132"><alternatives><graphic xlink:href="pone.0209358.e132.jpg" id="pone.0209358.e132g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M132"><mml:mrow><mml:mo form="prefix">dim</mml:mo><mml:mo>(</mml:mo><mml:mi>𝒵</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo form="prefix">dim</mml:mo><mml:mo>(</mml:mo><mml:mi mathvariant="script">X</mml:mi><mml:mo>)</mml:mo><mml:mo form="prefix">dim</mml:mo><mml:mo>(</mml:mo><mml:mi mathvariant="script">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> this is known to generate a uniform distribution over the set of quantum channels [<xref rid="pone.0209358.ref037" ref-type="bibr">37</xref>, <xref rid="pone.0209358.ref038" ref-type="bibr">38</xref>].</p>
      <p>The implementation uses the type <monospace>ChoiJamiolkowskiMatrices{<italic>β</italic>, K}</monospace>. The parameters <italic>β</italic> and <italic>K</italic> have the same meaning as in the Wishart matrix case. Additionally here, the constructor</p>
      <boxed-text id="pone.0209358.box048" position="anchor" orientation="portrait">
        <p>
          <monospace>ChoiJamiolkowskiMatrices{<italic>β</italic>, K}(idim::Int, odim::Int) where {<italic>β</italic>, K}</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">takes two parameters—the input and output dimension of the channel. As in the previous cases we provide some additional constructors for convenience</p>
      <boxed-text id="pone.0209358.box049" position="anchor" orientation="portrait">
        <p>
          <monospace>function ChoiJamiolkowskiMatrices{<italic>β</italic>}(idim::Int, odim::Int) where <italic>β</italic></monospace>
        </p>
        <p>
          <monospace> ChoiJamiolkowskiMatrices{<italic>β</italic>, 1}(idim, odim)</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
        <p>
          <monospace>function ChoiJamiolkowskiMatrices{<italic>β</italic>}(d::Int) where <italic>β</italic></monospace>
        </p>
        <p>
          <monospace> ChoiJamiolkowskiMatrices{<italic>β</italic>}(d, d)</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
        <p>
          <monospace>function ChoiJamiolkowskiMatrices(idim::Int, odim::Int)</monospace>
        </p>
        <p>
          <monospace> ChoiJamiolkowskiMatrices{2}(idim, odim)</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
        <p>
          <monospace>function ChoiJamiolkowskiMatrices(d::Int)</monospace>
        </p>
        <p>
          <monospace> ChoiJamiolkowskiMatrices(d, d)</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">Here is an example of usage</p>
      <boxed-text id="pone.0209358.box050" position="anchor" orientation="portrait">
        <p>
          <monospace>julia&gt; c = ChoiJamiolkowskiMatrices(2, 3)</monospace>
        </p>
        <p>
          <monospace>ChoiJamiolkowskiMatrices{2,1}(WishartEnsemble{2,1}(d = 6), 2, 3)</monospace>
        </p>
        <p>
          <monospace>julia&gt; Φ = rand(c)</monospace>
        </p>
        <p>
          <monospace>DynamicalMatrix{Array{Complex{Float64},2}}</monospace>
        </p>
        <p>
          <monospace>dimensions: (2, 3)</monospace>
        </p>
        <p>
          <monospace>Complex{Float64}</monospace>
        </p>
        <p>
          <monospace> [0.307971-4.98733e-18im -0.00411588+0.0368471im…</monospace>
        </p>
        <p>
          <monospace> -0.0676732+0.024328im 0.0860858+0.00302876im;</monospace>
        </p>
        <p>
          <monospace> -0.00411588-0.0368471im 0.167651+2.1684e-19im…</monospace>
        </p>
        <p>
          <monospace> -0.0428561+0.0266119im 0.0191888+0.0101013im;</monospace>
        </p>
        <p>
          <monospace> … ;</monospace>
        </p>
        <p>
          <monospace> -0.0676732-0.024328im -0.0428561 − 0.0266119im…</monospace>
        </p>
        <p>
          <monospace> 0.210419+0.0im -0.103401 − 0.142753im;</monospace>
        </p>
        <p>
          <monospace> 0.0860858-0.00302876im 0.0191888 − 0.0101013im…</monospace>
        </p>
        <p>
          <monospace> -0.103401+0.142753im 0.411068+0.0im]</monospace>
        </p>
        <p>
          <monospace>julia&gt; ptrace(Φ.matrix, [3, 2],[1])</monospace>
        </p>
        <p>
          <monospace>2×2 Array{Complex{Float64},2}:</monospace>
        </p>
        <p>
          <monospace> 1.0 − 1.53957e-17im  − 1.38778e-17 − 3.05311e-16im</monospace>
        </p>
        <p>
          <monospace> 1.38778e-17 + 3.05311e-16im 1.0 + 2.1684e-19im</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">Note that the resulting sample is of type <monospace>DynamicalMatrix</monospace>.</p>
    </sec>
  </sec>
  <sec id="sec034">
    <title>Example</title>
    <p>As an example we provide the teleportation protocol in the presence of noise. Imagine we have an entangled pair of particles in the state
<disp-formula id="pone.0209358.e133"><alternatives><graphic xlink:href="pone.0209358.e133.jpg" id="pone.0209358.e133g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M133"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mo>⟩</mml:mo><mml:mo>=</mml:mo></mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mfrac><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mn>00</mml:mn><mml:mo>⟩</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mn>11</mml:mn><mml:mo>⟩</mml:mo><mml:mo>)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(13)</label></disp-formula>
One of the particles stays with Alice and another is sent through a noisy channel to Bob. As a noise model we chose the amplitude damping channel given by the Kraus operators
<disp-formula id="pone.0209358.e134"><alternatives><graphic xlink:href="pone.0209358.e134.jpg" id="pone.0209358.e134g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M134"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>K</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:msqrt><mml:mrow><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi>γ</mml:mi></mml:mrow></mml:msqrt></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo><mml:mspace width="1.em"/><mml:msub><mml:mi>K</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:msqrt><mml:mi>γ</mml:mi></mml:msqrt></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives><label>(14)</label></disp-formula>
The channel has one parameter <italic>γ</italic> ∈ [0, 1] modeling the strength of the noise. Assume that Alice possesses a random pure state |<italic>ϕ</italic>〉 that she teleports to Bob. The protocol is shown in <xref ref-type="fig" rid="pone.0209358.g001">Fig 1</xref>.</p>
    <fig id="pone.0209358.g001" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0209358.g001</object-id>
      <label>Fig 1</label>
      <caption>
        <title>Schematic depiction of the teleportation protocol.</title>
        <p>Squiggly line represents the maximally entangled state, and box Φ represents the noise operator.</p>
      </caption>
      <graphic xlink:href="pone.0209358.g001"/>
    </fig>
    <p>Our examples show the fidelity of the final state at Bob’s site averaged over 100 random pure initial states. We also check how the parameter <italic>γ</italic> influences this fidelity.</p>
    <boxed-text id="pone.0209358.box051" position="anchor" orientation="portrait">
      <p>
        <monospace>using QuantumInformation</monospace>
      </p>
      <p>
        <monospace>steps = 100</monospace>
      </p>
      <p>
        <monospace>haar = HaarKet(2)</monospace>
      </p>
      <p>
        <monospace><italic>ψ</italic> = (ket(0, 4) + ket(3, 4))/sqrt(2)</monospace>
      </p>
      <p>
        <monospace><italic>γ</italic>s = 0.0:0.01:1.0</monospace>
      </p>
      <p>
        <monospace>Φ = KrausOperators([[1 0; 0 sqrt(1-γ)], [0 sqrt(<italic>γ</italic>); 0 0]])</monospace>
      </p>
      <p>
        <monospace>post = [PostSelectionMeasurement(proj(ket(i, 4)) ⊗ eye(2)) for i = 0:3]</monospace>
      </p>
      <p>
        <monospace>rots = [UnitaryChannel(eye(2)), UnitaryChannel(sx), UnitaryChannel(sz),</monospace>
      </p>
      <p>
        <monospace>UnitaryChannel(sx*sz)]</monospace>
      </p>
      <p>
        <monospace>had = UnitaryChannel{Matrix{ComplexF64}}(hadamard(2))</monospace>
      </p>
      <p>
        <monospace>cnot = UnitaryChannel{Matrix{ComplexF64}}([1 0 0 0; 0 1 0 0; 0 0 0 1; 0 0 1 0])</monospace>
      </p>
      <p>
        <monospace>r = zeros(steps, length(<italic>γ</italic>s), 4);</monospace>
      </p>
      <p>
        <monospace>for (k, <italic>γ</italic>) in enumerate(<italic>γ</italic>s)</monospace>
      </p>
      <p>
        <monospace> for i = 1:steps</monospace>
      </p>
      <p>
        <monospace>  <italic>ϕ</italic> = rand(haar)</monospace>
      </p>
      <p>
        <monospace>  <italic>ξ</italic> = <italic>ϕ</italic> ⊗ <italic>ψ</italic></monospace>
      </p>
      <p>
        <monospace>  <italic>ρ</italic> = ((had ⊗ IdentityChannel(4))∘(cnot ⊗</monospace>
      </p>
      <p>
        <monospace>IdentityChannel(2))∘(IdentityChannel(4) ⊗ Φ))(<italic>ξ</italic>)</monospace>
      </p>
      <p>
        <monospace>  for j = 1:4</monospace>
      </p>
      <p>
        <monospace>   <italic>σ</italic> = rots[j](ptrace(post[j](<italic>ρ</italic>), [2, 2, 2], [1, 2]))</monospace>
      </p>
      <p>
        <monospace>   r[i, k, j] = fidelity(<italic>ϕ</italic>, <italic>σ</italic>/tr(<italic>σ</italic>))</monospace>
      </p>
      <p>
        <monospace>  end</monospace>
      </p>
      <p>
        <monospace> end</monospace>
      </p>
      <p>
        <monospace>end</monospace>
      </p>
      <p>
        <monospace>mean(r, 1)</monospace>
      </p>
    </boxed-text>
  </sec>
  <sec id="sec035">
    <title>Benchmarks</title>
    <p>In the benchmarks we compare our library to the state-of-the-art <monospace>Python</monospace> library, <monospace>QuTiP</monospace> [<xref rid="pone.0209358.ref012" ref-type="bibr">12</xref>, <xref rid="pone.0209358.ref013" ref-type="bibr">13</xref>]. We perform the following tests:</p>
    <list list-type="order">
      <list-item>
        <p>sampling a random unitary matrix,</p>
      </list-item>
      <list-item>
        <p>sampling a random pure state,</p>
      </list-item>
      <list-item>
        <p>sampling a random mixed state,</p>
      </list-item>
      <list-item>
        <p>sampling a random channel,</p>
      </list-item>
      <list-item>
        <p>calculating the trace distance of a random mixed state from the maximally mixed state,</p>
      </list-item>
      <list-item>
        <p>calculating the trace distance between two random mixed states,</p>
      </list-item>
      <list-item>
        <p>calculating the entropy of the stationary state of a random channel.</p>
      </list-item>
    </list>
    <p>The latter is done as follows. First we sample a random quantum channel. Next, we apply the <monospace>reshuffle</monospace> operation and calculate its eigenvectors and eigenvalues. We take the state corresponding to the eigenvalue equal to one and calculate its von Neumann entropy. All tests are performed 1000 times and an average time of computation from these samples is calculated. In the case of <monospace>Julia</monospace> code we ensure all functions are compiled prior to testing. The tests are performed for dimensions 4, 16, 64, 256, 1024. In the next subsections we present and discuss results for all the aforementioned cases.</p>
    <p>The tests were performed on a machine equipped with Intel Core i7-6800K and 64 GB of RAM. The libraries installed on the system were</p>
    <boxed-text id="pone.0209358.box052" position="anchor" orientation="portrait">
      <p>
        <monospace>julia&gt; versioninfo()</monospace>
      </p>
      <p>
        <monospace>julia Version 1.0.0</monospace>
      </p>
      <p>
        <monospace>Platform Info:</monospace>
      </p>
      <p>
        <monospace> OS: Linux (x86_64-redhat-linux)</monospace>
      </p>
      <p>
        <monospace> CPU: Intel(R) Core(TM) i7-6800K CPU @ 3.40GHz</monospace>
      </p>
      <p>
        <monospace> WORD_SIZE: 64</monospace>
      </p>
      <p>
        <monospace> LIBM: libopenlibm</monospace>
      </p>
      <p>
        <monospace> LLVM: libLLVM − 6.0.0 (ORCJIT, broadwell)</monospace>
      </p>
      <p>
        <monospace>julia&gt; LAPACK.version()</monospace>
      </p>
      <p>
        <monospace>v“3.7.0”</monospace>
      </p>
      <p>
        <monospace>julia&gt; BLAS.vendor()</monospace>
      </p>
      <p>
        <monospace>:openblas</monospace>
      </p>
      <p>
        <monospace>julia&gt; BLAS.openblas_get_config()</monospace>
      </p>
      <p>
        <monospace>“DYNAMIC_ARCH_NO_AFFINITY Haswell”</monospace>
      </p>
    </boxed-text>
    <p specific-use="continuation">The <monospace>Python</monospace> libraries were</p>
    <boxed-text id="pone.0209358.box053" position="anchor" orientation="portrait">
      <p>
        <monospace>In [1]: import numpy as np</monospace>
      </p>
      <p>
        <monospace>In [2]: np.__version__</monospace>
      </p>
      <p>
        <monospace>Out[2]: ‘1.7.1’</monospace>
      </p>
      <p>
        <monospace>In [3]: np.__config__.show()</monospace>
      </p>
      <p>
        <monospace>Out[3]:</monospace>
      </p>
      <p>
        <monospace>blas_mkl_info:</monospace>
      </p>
      <p>
        <monospace> NOT AVAILABLE</monospace>
      </p>
      <p>
        <monospace>blis_info:</monospace>
      </p>
      <p>
        <monospace> NOT AVAILABLE</monospace>
      </p>
      <p>
        <monospace>openblas_info:</monospace>
      </p>
      <p>
        <monospace> libraries = [‘openblas’, ‘openblas’]</monospace>
      </p>
      <p>
        <monospace> library_dirs = [‘/home/user/anaconda3/lib’]</monospace>
      </p>
      <p>
        <monospace> language = c</monospace>
      </p>
      <p>
        <monospace> define_macros = [(‘HAVE CBLAS’, None)]</monospace>
      </p>
      <p>
        <monospace>blas_opt_info:</monospace>
      </p>
      <p>
        <monospace> libraries = [‘openblas’, ‘openblas’]</monospace>
      </p>
      <p>
        <monospace> library_dirs = [‘/home/user/anaconda3/lib’]</monospace>
      </p>
      <p>
        <monospace> language = c</monospace>
      </p>
      <p>
        <monospace> define_macros = [(‘HAVE CBLAS’, None)]</monospace>
      </p>
      <p>
        <monospace>lapack_mkl_info:</monospace>
      </p>
      <p>
        <monospace> NOT AVAILABLE</monospace>
      </p>
      <p>
        <monospace>openblas_lapack_info:</monospace>
      </p>
      <p>
        <monospace> libraries = [‘openblas’, ‘openblas’]</monospace>
      </p>
      <p>
        <monospace> library_dirs = [‘/home/user/anaconda3/lib’]</monospace>
      </p>
      <p>
        <monospace> language = c</monospace>
      </p>
      <p>
        <monospace> define_macros = [(‘HAVE CBLAS’, None)]</monospace>
      </p>
      <p>
        <monospace>lapack_opt_info:</monospace>
      </p>
      <p>
        <monospace> libraries = [‘openblas’, ‘openblas’]</monospace>
      </p>
      <p>
        <monospace> library_dirs = [‘/home/user/anaconda3/lib’]</monospace>
      </p>
      <p>
        <monospace> language = c</monospace>
      </p>
      <p>
        <monospace> define_macros = [(‘HAVE CBLAS’, None)]</monospace>
      </p>
    </boxed-text>
    <sec id="sec036">
      <title>Sampling a random unitary matrix</title>
      <p>The <monospace>Julia</monospace> code for this test is</p>
      <boxed-text id="pone.0209358.box054" position="anchor" orientation="portrait">
        <p>
          <monospace>using QuantumInformation</monospace>
        </p>
        <p>
          <monospace>function random_unitary(steps::Int, d::Int)</monospace>
        </p>
        <p>
          <monospace> dist = CUE(d)</monospace>
        </p>
        <p>
          <monospace> for i = 1:steps U = rand(dist) end</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The <monospace>Python</monospace> implementation reads</p>
      <boxed-text id="pone.0209358.box055" position="anchor" orientation="portrait">
        <p>
          <monospace>import qutip as q</monospace>
        </p>
        <p>
          <monospace>def random_unitary(steps, d):</monospace>
        </p>
        <p>
          <monospace> for _ in range(steps):</monospace>
        </p>
        <p>
          <monospace>  q.rand_unitary_haar(d)</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The benchmark results are presented in <xref ref-type="fig" rid="pone.0209358.g002">Fig 2</xref>. Note that, as advertised, our implementation is faster and the gap gets bigger as the dimension of the input system increases.</p>
      <fig id="pone.0209358.g002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0209358.g002</object-id>
        <label>Fig 2</label>
        <caption>
          <title>Benchmark results for sampling random unitary matrices in <monospace>QuantumInformation.jl</monospace> and <monospace>Python</monospace>.</title>
        </caption>
        <graphic xlink:href="pone.0209358.g002"/>
      </fig>
    </sec>
    <sec id="sec037">
      <title>Sampling a random pure state</title>
      <p>The <monospace>Julia</monospace> code for this test is</p>
      <boxed-text id="pone.0209358.box056" position="anchor" orientation="portrait">
        <p>
          <monospace>using QuantumInformation</monospace>
        </p>
        <p>
          <monospace>function random_pure_state(steps::Int, d::Int)</monospace>
        </p>
        <p>
          <monospace> dist = HaarKet(d)</monospace>
        </p>
        <p>
          <monospace> for i = 1:steps <italic>ψ</italic> = rand(dist) end</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The <monospace>Python</monospace> implementation reads</p>
      <boxed-text id="pone.0209358.box057" position="anchor" orientation="portrait">
        <p>
          <monospace>import qutip as q</monospace>
        </p>
        <p>
          <monospace>def random_pure_state(steps, d):</monospace>
        </p>
        <p>
          <monospace> for _ in range(steps):</monospace>
        </p>
        <p>
          <monospace>  q.rand_ket_haar(d)</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The benchmark results are presented in <xref ref-type="fig" rid="pone.0209358.g003">Fig 3</xref>. In this case we get a huge difference in the computation times. This is due to the fact that <monospace>QuTiP</monospace> first samples an entire random unitary matrix and returns its first column as the sampled state. On the other hand our implementation samples only one vector.</p>
      <fig id="pone.0209358.g003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0209358.g003</object-id>
        <label>Fig 3</label>
        <caption>
          <title>Benchmark results for sampling random pure states in <monospace>QuantumInformation.jl</monospace> and <monospace>Python</monospace>.</title>
        </caption>
        <graphic xlink:href="pone.0209358.g003"/>
      </fig>
    </sec>
    <sec id="sec038">
      <title>Sampling a random mixed state</title>
      <p>The <monospace>Julia</monospace> code for this test is</p>
      <boxed-text id="pone.0209358.box058" position="anchor" orientation="portrait">
        <p>
          <monospace>using QuantumInformation</monospace>
        </p>
        <p>
          <monospace>function random_mixed_state(steps::Int, d::Int)</monospace>
        </p>
        <p>
          <monospace> dist = HilbertSchmidtStates(d)</monospace>
        </p>
        <p>
          <monospace> for i = 1:steps <italic>ρ</italic> = rand(dist) end</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The <monospace>Python</monospace> implementation reads</p>
      <boxed-text id="pone.0209358.box059" position="anchor" orientation="portrait">
        <p>
          <monospace>import qutip as q</monospace>
        </p>
        <p>
          <monospace>def random_mixed_state(steps, d):</monospace>
        </p>
        <p>
          <monospace> for _ in range(steps):</monospace>
        </p>
        <p>
          <monospace>  q.rand_dm_hs(d)</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The benchmark results are presented in <xref ref-type="fig" rid="pone.0209358.g004">Fig 4</xref>. Again, our package is faster compared to <monospace>QuTiP</monospace>.</p>
      <fig id="pone.0209358.g004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0209358.g004</object-id>
        <label>Fig 4</label>
        <caption>
          <title>Benchmark results for sampling random mixed state in <monospace>QuantumInformation.jl</monospace> and <monospace>Python</monospace>.</title>
        </caption>
        <graphic xlink:href="pone.0209358.g004"/>
      </fig>
    </sec>
    <sec id="sec039">
      <title>Sampling a random channel</title>
      <p>The <monospace>Julia</monospace> code for this test is</p>
      <boxed-text id="pone.0209358.box060" position="anchor" orientation="portrait">
        <p>
          <monospace>using QuantumInformation</monospace>
        </p>
        <p>
          <monospace>function random_channel(steps::Int, d::Int)</monospace>
        </p>
        <p>
          <monospace> dist = ChoiJamiolkowskiMatrices(round(Int, sqrt(d)))</monospace>
        </p>
        <p>
          <monospace> for i = 1:steps Φ = convert(SuperOperator{Matrix{ComplexF64}}, rand(dist)) end</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The <monospace>Python</monospace> implementation reads</p>
      <boxed-text id="pone.0209358.box061" position="anchor" orientation="portrait">
        <p>
          <monospace>import qutip as q</monospace>
        </p>
        <p>
          <monospace>def random_channel(steps, d):</monospace>
        </p>
        <p>
          <monospace> for _ in range(steps):</monospace>
        </p>
        <p>
          <monospace>  q.rand_super_bcsz(int(np.sqrt(d)))</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">Note the conversion to <monospace>SuperOperator</monospace> in the benchmark. This is to mimic <monospace>QuTiP</monospace>’s behavior which returns a superoperator. The benchmark results are presented in <xref ref-type="fig" rid="pone.0209358.g005">Fig 5</xref>.</p>
      <fig id="pone.0209358.g005" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0209358.g005</object-id>
        <label>Fig 5</label>
        <caption>
          <title>Benchmark results for sampling random quantum channels in <monospace>QuantumInformation.jl</monospace> and <monospace>Python</monospace>.</title>
        </caption>
        <graphic xlink:href="pone.0209358.g005"/>
      </fig>
    </sec>
    <sec id="sec040">
      <title>Calculating the trace distance form the maximally mixed state</title>
      <p>The <monospace>Julia</monospace> code for this test is</p>
      <boxed-text id="pone.0209358.box062" position="anchor" orientation="portrait">
        <p>
          <monospace>using QuantumInformation</monospace>
        </p>
        <p>
          <monospace>function trace_distance_max_mixed(steps::Int, d::Int)</monospace>
        </p>
        <p>
          <monospace> dist = HilbertSchmidtStates(d)</monospace>
        </p>
        <p>
          <monospace> <inline-formula id="pone.0209358.e135"><alternatives><graphic xlink:href="pone.0209358.e135.jpg" id="pone.0209358.e135g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M135"><mml:mi>ρ</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="double-struck">I</mml:mi><mml:mo>(</mml:mo><mml:mtext>d</mml:mtext><mml:mo>)</mml:mo><mml:mo>/</mml:mo><mml:mtext>d</mml:mtext></mml:math></alternatives></inline-formula></monospace>
        </p>
        <p>
          <monospace> for i = 1:steps trace distance(rand(dist), <italic>ρ</italic>) end</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The <monospace>Python</monospace> implementation reads</p>
      <boxed-text id="pone.0209358.box063" position="anchor" orientation="portrait">
        <p>
          <monospace>import qutip as q</monospace>
        </p>
        <p>
          <monospace>def trace_distance_max_mixed(steps, d):</monospace>
        </p>
        <p>
          <monospace> rho = q.Qobj(np.eye(d) / d)</monospace>
        </p>
        <p>
          <monospace> for _ in range(steps):</monospace>
        </p>
        <p>
          <monospace>  q.metrics.tracedist(q.rand_dm_hs(d), rho)</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The benchmark results are presented in <xref ref-type="fig" rid="pone.0209358.g006">Fig 6</xref>. Again, for all studied dimensions, our implementation is faster compared to <monospace>Python</monospace>.</p>
      <fig id="pone.0209358.g006" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0209358.g006</object-id>
        <label>Fig 6</label>
        <caption>
          <title>Benchmark results for calculating the trace distance between a random
mixed state and the maximally mixed in <monospace>QuantumInformation.jl</monospace> and <monospace>Python</monospace>.</title>
        </caption>
        <graphic xlink:href="pone.0209358.g006"/>
      </fig>
    </sec>
    <sec id="sec041">
      <title>Calculating the trace distance between two random mixed states</title>
      <p>The <monospace>Julia</monospace> code for this test is</p>
      <boxed-text id="pone.0209358.box064" position="anchor" orientation="portrait">
        <p>
          <monospace>using QuantumInformation</monospace>
        </p>
        <p>
          <monospace>function trace_distance_random(steps::Int, d::Int)</monospace>
        </p>
        <p>
          <monospace> dist = HilbertSchmidtStates(d)</monospace>
        </p>
        <p>
          <monospace> for i = 1:steps trace_distance(rand(dist), rand(dist)) end</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The <monospace>Python</monospace> implementation reads</p>
      <boxed-text id="pone.0209358.box065" position="anchor" orientation="portrait">
        <p>
          <monospace>import qutip as q</monospace>
        </p>
        <p>
          <monospace>def trace_distance_random(steps, d):</monospace>
        </p>
        <p>
          <monospace> for _ in range(steps):</monospace>
        </p>
        <p>
          <monospace>  q.metrics.tracedist(q.rand_dm_hs(d), q.rand_dm_hs(d))</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The benchmark results are presented in <xref ref-type="fig" rid="pone.0209358.g007">Fig 7</xref>.</p>
      <fig id="pone.0209358.g007" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0209358.g007</object-id>
        <label>Fig 7</label>
        <caption>
          <title>Benchmark results for calculating the trace distance between two random mixed states in <monospace>QuantumInformation.jl</monospace> and <monospace>Python</monospace>.</title>
        </caption>
        <graphic xlink:href="pone.0209358.g007"/>
      </fig>
    </sec>
    <sec id="sec042">
      <title>Calculating the entropy of the stationary state of a random channel</title>
      <p>The <monospace>Julia</monospace> code for this test is</p>
      <boxed-text id="pone.0209358.box066" position="anchor" orientation="portrait">
        <p>
          <monospace>using QuantumInformation</monospace>
        </p>
        <p>
          <monospace>function random_unitary(steps::Int, d::Int)</monospace>
        </p>
        <p>
          <monospace> dist = CUE(d)</monospace>
        </p>
        <p>
          <monospace> for i = 1:steps U = rand(dist) end</monospace>
        </p>
        <p>
          <monospace>end</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The <monospace>Python</monospace> implementation reads</p>
      <boxed-text id="pone.0209358.box067" position="anchor" orientation="portrait">
        <p>
          <monospace>import qutip as q</monospace>
        </p>
        <p>
          <monospace>def random_unitary(steps, d):</monospace>
        </p>
        <p>
          <monospace> for _ in range(steps):</monospace>
        </p>
        <p>
          <monospace>  q.rand_unitary_haar(d)</monospace>
        </p>
      </boxed-text>
      <p specific-use="continuation">The benchmark results are presented in <xref ref-type="fig" rid="pone.0209358.g008">Fig 8</xref>.</p>
      <fig id="pone.0209358.g008" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0209358.g008</object-id>
        <label>Fig 8</label>
        <caption>
          <title>Benchmark results for calculating the entropy of a stationary state of a random quantum channel in <monospace>QuantumInformation.jl</monospace> and <monospace>Python</monospace>.</title>
        </caption>
        <graphic xlink:href="pone.0209358.g008"/>
      </fig>
    </sec>
  </sec>
  <sec id="sec043">
    <title>Conclusions and future work</title>
    <p>Numerical investigations are important part of research in many fields of science, especially in quantum information. The <monospace>Julia</monospace> language is a modern programming language, which provides strong support for linear algebra and posses an extensive type system. One of the important feature of <monospace>Julia</monospace> is high performance approaching statically-compiled languages like <monospace>C</monospace> or <monospace>Fortran</monospace>. Those were the reasons why we created the <monospace>QuantumInformation.jl</monospace> library in <monospace>Julia</monospace>.</p>
    <p>We performed benchmark comparisons of <monospace>QuantumInformation.jl</monospace> with <monospace>QuTiP</monospace>. They clearly state that our library is faster compared to the current state of the art. As the core numerical libraries were the same for both tested packages, we conclude that this speedup is due to the advantages offered by <monospace>Julia</monospace>.</p>
    <p>Future work will consists of optimization of numerical code, extending the type system, developing further functionals, better integration with <monospace>Convex.jl</monospace> package. Additional work will also include parallelization of the code and support for writing quantum circuits in more intuitive manner.</p>
  </sec>
</body>
<back>
  <ref-list>
    <title>References</title>
    <ref id="pone.0209358.ref001">
      <label>1</label>
      <mixed-citation publication-type="other">QuantumInformation.jl;. Available from: <pub-id pub-id-type="doi">10.5281/zenodo.1745488</pub-id>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref002">
      <label>2</label>
      <mixed-citation publication-type="other">Quantiki: List of QC simulators;. Available from: <ext-link ext-link-type="uri" xlink:href="https://quantiki.org/wiki/list-qc-simulators">https://quantiki.org/wiki/list-qc-simulators</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref003">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Miszczak</surname><given-names>JA</given-names></name>. <article-title>Singular value decomposition and matrix reorderings in quantum information theory</article-title>. <source>International Journal of Modern Physics C</source>. <year>2011</year>;<volume>22</volume>(<issue>09</issue>):<fpage>897</fpage>–<lpage>918</lpage>. <pub-id pub-id-type="doi">10.1142/S0129183111016683</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref004">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Miszczak</surname><given-names>JA</given-names></name>. <article-title>Generating and using truly random quantum states in Mathematica</article-title>. <source>Computer Physics Communications</source>. <year>2012</year>;<volume>183</volume>(<issue>1</issue>):<fpage>118</fpage>–<lpage>124</lpage>. <pub-id pub-id-type="doi">10.1016/j.cpc.2011.08.002</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref005">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Munoz</surname><given-names>JG</given-names></name>, <name><surname>Delgado</surname><given-names>F</given-names></name>. <article-title>QUANTUM: A Wolfram Mathematica add-on for Dirac Bra-Ket Notation, Non-Commutative Algebra, and Simulation of Quantum Computing Circuits</article-title>. In: <source>Journal of Physics: Conference Series</source>. <volume>vol. 698</volume>. IOP Publishing; 2016. p. 012019.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref006">
      <label>6</label>
      <mixed-citation publication-type="journal"><name><surname>Radtke</surname><given-names>T</given-names></name>, <name><surname>Fritzsche</surname><given-names>S</given-names></name>. <article-title>Simulation of n-qubit quantum systems. I. Quantum registers and quantum gates</article-title>. <source>Computer Physics Communications</source>. <year>2005</year>;<volume>173</volume>(<issue>1-2</issue>):<fpage>91</fpage>–<lpage>113</lpage>. <pub-id pub-id-type="doi">10.1016/j.cpc.2005.07.006</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref007">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Radtke</surname><given-names>T</given-names></name>, <name><surname>Fritzsche</surname><given-names>S</given-names></name>. <article-title>Simulation of n-qubit quantum systems. II. Separability and entanglement</article-title>. <source>Computer Physics Communications</source>. <year>2006</year>;<volume>175</volume>(<issue>2</issue>):<fpage>145</fpage>–<lpage>166</lpage>. <pub-id pub-id-type="doi">10.1016/j.cpc.2006.03.006</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref008">
      <label>8</label>
      <mixed-citation publication-type="journal"><name><surname>Radtke</surname><given-names>T</given-names></name>, <name><surname>Fritzsche</surname><given-names>S</given-names></name>. <article-title>Simulation of n-qubit quantum systems. III. Quantum operations</article-title>. <source>Computer Physics Communications</source>. <year>2007</year>;<volume>176</volume>(<issue>9-10</issue>):<fpage>617</fpage>–<lpage>633</lpage>. <pub-id pub-id-type="doi">10.1016/j.cpc.2007.02.106</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref009">
      <label>9</label>
      <mixed-citation publication-type="journal"><name><surname>Radtke</surname><given-names>T</given-names></name>, <name><surname>Fritzsche</surname><given-names>S</given-names></name>. <article-title>Simulation of n-qubit quantum systems. IV. Parametrizations of quantum states, matrices and probability distributions</article-title>. <source>Computer Physics Communications</source>. <year>2008</year>;<volume>179</volume>(<issue>9</issue>):<fpage>647</fpage>–<lpage>664</lpage>. <pub-id pub-id-type="doi">10.1016/j.cpc.2008.06.007</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref010">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Radtke</surname><given-names>T</given-names></name>, <name><surname>Fritzsche</surname><given-names>S</given-names></name>. <article-title>Simulation of n-qubit quantum systems. V. Quantum measurements</article-title>. <source>Computer Physics Communications</source>. <year>2010</year>;<volume>181</volume>(<issue>2</issue>):<fpage>440</fpage>–<lpage>453</lpage>. <pub-id pub-id-type="doi">10.1016/j.cpc.2009.10.015</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref011">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Ince</surname><given-names>DC</given-names></name>, <name><surname>Hatton</surname><given-names>L</given-names></name>, <name><surname>Graham-Cumming</surname><given-names>J</given-names></name>. <article-title>The case for open computer programs</article-title>. <source>Nature</source>. <year>2012</year>;<volume>482</volume>(<issue>7386</issue>):<fpage>485</fpage><pub-id pub-id-type="doi">10.1038/nature10836</pub-id><?supplied-pmid 22358837?><pub-id pub-id-type="pmid">22358837</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref012">
      <label>12</label>
      <mixed-citation publication-type="journal"><name><surname>Johansson</surname><given-names>J</given-names></name>, <name><surname>Nation</surname><given-names>P</given-names></name>, <name><surname>Nori</surname><given-names>F</given-names></name>. <article-title>QuTiP: An open-source Python framework for the dynamics of open quantum systems</article-title>. <source>Computer Physics Communications</source>. <year>2012</year>;<volume>183</volume>(<issue>8</issue>):<fpage>1760</fpage>–<lpage>1772</lpage>. <pub-id pub-id-type="doi">10.1016/j.cpc.2012.02.021</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref013">
      <label>13</label>
      <mixed-citation publication-type="journal"><name><surname>Johansson</surname><given-names>J</given-names></name>, <name><surname>Nation</surname><given-names>P</given-names></name>, <name><surname>Nori</surname><given-names>F</given-names></name>. <article-title>QuTiP 2: A Python framework for the dynamics of open quantum systems</article-title>. <source>Computer Physics Communications</source>. <year>2013</year>;<volume>184</volume>:<fpage>1234</fpage>–<lpage>1240</lpage>. <pub-id pub-id-type="doi">10.1016/j.cpc.2012.11.019</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref014">
      <label>14</label>
      <mixed-citation publication-type="other">Travis E O. A guide to NumPy. Trelgol Publishing;.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref015">
      <label>15</label>
      <mixed-citation publication-type="other">Jones E, Oliphant T, Peterson P, et al. SciPy: Open source scientific tools for Python; 2001–. Available from: <ext-link ext-link-type="uri" xlink:href="http://www.scipy.org/">http://www.scipy.org/</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref016">
      <label>16</label>
      <mixed-citation publication-type="other">The Julia language;. Available from: <ext-link ext-link-type="uri" xlink:href="https://docs.julialang.org/">https://docs.julialang.org/</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref017">
      <label>17</label>
      <mixed-citation publication-type="other">QuantumInfo.jl;. Available from: <ext-link ext-link-type="uri" xlink:href="https://github.com/BBN-Q/QuantumInfo.jl">https://github.com/BBN-Q/QuantumInfo.jl</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref018">
      <label>18</label>
      <mixed-citation publication-type="other">Quantum.jl;. Available from: <ext-link ext-link-type="uri" xlink:href="https://github.com/acroy/Quantum.jl">https://github.com/acroy/Quantum.jl</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref019">
      <label>19</label>
      <mixed-citation publication-type="other">Julia|Quantum〉. Available from: <ext-link ext-link-type="uri" xlink:href="http://juliaquantum.github.io/projects/">http://juliaquantum.github.io/projects/</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref020">
      <label>20</label>
      <mixed-citation publication-type="journal"><name><surname>Krämer</surname><given-names>S</given-names></name>, <name><surname>Plankensteiner</surname><given-names>D</given-names></name>, <name><surname>Ostermann</surname><given-names>L</given-names></name>, <name><surname>Ritsch</surname><given-names>H</given-names></name>. <article-title>QuantumOptics.jl: A Julia framework for simulating open quantum systems</article-title>. <source>Computer Physics Communications</source>. <year>2018</year>;<volume>227</volume>:<fpage>109</fpage>–<lpage>116</lpage>. <pub-id pub-id-type="doi">10.1016/j.cpc.2018.02.004</pub-id>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref021">
      <label>21</label>
      <mixed-citation publication-type="book"><name><surname>Bengtsson</surname><given-names>I</given-names></name>, <name><surname>Życzkowski</surname><given-names>K</given-names></name>. <source>Geometry of Quantum States: An Introduction to Quantum Entanglement</source>. <edition>1st ed</edition><publisher-name>Cambridge University Press</publisher-name>; <year>2008</year>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref022">
      <label>22</label>
      <mixed-citation publication-type="journal"><name><surname>Bezanson</surname><given-names>J</given-names></name>, <name><surname>Edelman</surname><given-names>A</given-names></name>, <name><surname>Karpinski</surname><given-names>S</given-names></name>, <name><surname>Shah</surname><given-names>VB</given-names></name>. <article-title>Julia: A fresh approach to numerical computing</article-title>. <source>SIAM Review</source>. <year>2017</year>;<volume>59</volume>(<issue>1</issue>):<fpage>65</fpage>–<lpage>98</lpage>. <pub-id pub-id-type="doi">10.1137/141000671</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref023">
      <label>23</label>
      <mixed-citation publication-type="other">Lattner C, Adve V. LLVM: A compilation framework for lifelong program analysis &amp; transformation. In: Proceedings of the international symposium on Code generation and optimization: feedback-directed and runtime optimization. IEEE Computer Society; 2004. p. 75.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref024">
      <label>24</label>
      <mixed-citation publication-type="other">Bezanson J, Chen J, Karpinski S, Shah V, Edelman A. Array operators using multiple dispatch: A design methodology for array implementations in dynamic languages. In: Proceedings of ACM SIGPLAN International Workshop on Libraries, Languages, and Compilers for Array Programming. ACM; 2014. p. 56.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref025">
      <label>25</label>
      <mixed-citation publication-type="other">Udell M, Mohan K, Zeng D, Hong J, Diamond S, Boyd S. Convex Optimization in Julia. SC14 Workshop on High Performance Technical Computing in Dynamic Languages. 2014;.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref026">
      <label>26</label>
      <mixed-citation publication-type="other">Jutho. TensorOperations.jl;. Available from: <ext-link ext-link-type="uri" xlink:href="https://github.com/Jutho/TensorOperations.jl">https://github.com/Jutho/TensorOperations.jl</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref027">
      <label>27</label>
      <mixed-citation publication-type="journal"><name><surname>Mezzadri</surname><given-names>F</given-names></name>. <article-title>How to generate random matrices from the classical compact groups</article-title>. <source>Notices of the American Mathematical Society</source>. <year>2007</year>;<volume>54</volume>(<issue>5</issue>):<fpage>592</fpage>–<lpage>604</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref028">
      <label>28</label>
      <mixed-citation publication-type="book"><name><surname>Watrous</surname><given-names>J</given-names></name>. <source>The Theory of Quantum Information</source>. <publisher-name>Cambridge University Press</publisher-name>; <year>2018</year>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref029">
      <label>29</label>
      <mixed-citation publication-type="journal"><name><surname>Hill</surname><given-names>S</given-names></name>, <name><surname>Wootters</surname><given-names>WK</given-names></name>. <article-title>Entanglement of a pair of quantum bits</article-title>. <source>Physical Review Letters</source>. <year>1997</year>;<volume>78</volume>(<issue>26</issue>):<fpage>5022</fpage><pub-id pub-id-type="doi">10.1103/PhysRevLett.78.5022</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref030">
      <label>30</label>
      <mixed-citation publication-type="journal"><name><surname>Collins</surname><given-names>B</given-names></name>, <name><surname>Nechita</surname><given-names>I</given-names></name>. <article-title>Random matrix techniques in quantum information theory</article-title>. <source>Journal of Mathematical Physics</source>. <year>2016</year>;<volume>57</volume>(<issue>1</issue>):<fpage>015215</fpage><pub-id pub-id-type="doi">10.1063/1.4936880</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref031">
      <label>31</label>
      <mixed-citation publication-type="journal"><name><surname>Wootters</surname><given-names>WK</given-names></name>. <article-title>Random quantum states</article-title>. <source>Foundations of Physics</source>. <year>1990</year>;<volume>20</volume>(<issue>11</issue>):<fpage>1365</fpage>–<lpage>1378</lpage>. <pub-id pub-id-type="doi">10.1007/BF01883491</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref032">
      <label>32</label>
      <mixed-citation publication-type="journal"><name><surname>Życzkowski</surname><given-names>K</given-names></name>, <name><surname>Sommers</surname><given-names>HJ</given-names></name>. <article-title>Induced measures in the space of mixed quantum states</article-title>. <source>Journal of Physics A: Mathematical and General</source>. <year>2001</year>;<volume>34</volume>(<issue>35</issue>):<fpage>7111</fpage><pub-id pub-id-type="doi">10.1088/0305-4470/34/35/335</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref033">
      <label>33</label>
      <mixed-citation publication-type="journal"><name><surname>Sommers</surname><given-names>HJ</given-names></name>, <name><surname>Życzkowski</surname><given-names>K</given-names></name>. <article-title>Statistical properties of random density matrices</article-title>. <source>Journal of Physics A: Mathematical and General</source>. <year>2004</year>;<volume>37</volume>(<issue>35</issue>):<fpage>8457</fpage><pub-id pub-id-type="doi">10.1088/0305-4470/37/35/004</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref034">
      <label>34</label>
      <mixed-citation publication-type="journal"><name><surname>Puchała</surname><given-names>Z</given-names></name>, <name><surname>Pawela</surname><given-names>Ł</given-names></name>, <name><surname>Życzkowski</surname><given-names>K</given-names></name>. <article-title>Distinguishability of generic quantum states</article-title>. <source>Physical Review A</source>. <year>2016</year>;<volume>93</volume>(<issue>6</issue>):<fpage>062112</fpage><pub-id pub-id-type="doi">10.1103/PhysRevA.93.062112</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref035">
      <label>35</label>
      <mixed-citation publication-type="journal"><name><surname>Zhang</surname><given-names>L</given-names></name>, <name><surname>Singh</surname><given-names>U</given-names></name>, <name><surname>Pati</surname><given-names>AK</given-names></name>. <article-title>Average subentropy, coherence and entanglement of random mixed quantum states</article-title>. <source>Annals of Physics</source>. <year>2017</year>;<volume>377</volume>:<fpage>125</fpage>–<lpage>146</lpage>. <pub-id pub-id-type="doi">10.1016/j.aop.2016.12.024</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref036">
      <label>36</label>
      <mixed-citation publication-type="journal"><name><surname>Zhang</surname><given-names>L</given-names></name>. <article-title>Average coherence and its typicality for random mixed quantum states</article-title>. <source>Journal of Physics A: Mathematical and Theoretical</source>. <year>2017</year>;<volume>50</volume>(<issue>15</issue>):<fpage>155303</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref037">
      <label>37</label>
      <mixed-citation publication-type="journal"><name><surname>Bruzda</surname><given-names>W</given-names></name>, <name><surname>Cappellini</surname><given-names>V</given-names></name>, <name><surname>Sommers</surname><given-names>HJ</given-names></name>, <name><surname>Życzkowski</surname><given-names>K</given-names></name>. <article-title>Random quantum operations</article-title>. <source>Physics Letters A</source>. <year>2009</year>;<volume>373</volume>(<issue>3</issue>):<fpage>320</fpage>–<lpage>324</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref038">
      <label>38</label>
      <mixed-citation publication-type="journal"><name><surname>Nechita</surname><given-names>I</given-names></name>, <name><surname>Puchała</surname><given-names>Z</given-names></name>, <name><surname>Pawela</surname><given-names>Ł</given-names></name>, <name><surname>Życzkowski</surname><given-names>K</given-names></name>. <article-title>Almost all quantum channels are equidistant</article-title>. <source>Journal of Mathematical Physics</source>. <year>2018</year>;<volume>59</volume>(<issue>5</issue>):<fpage>052201</fpage><pub-id pub-id-type="doi">10.1063/1.5019322</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref039">
      <label>39</label>
      <mixed-citation publication-type="journal"><name><surname>Zhang</surname><given-names>L</given-names></name>, <name><surname>Wang</surname><given-names>J</given-names></name>, <name><surname>Chen</surname><given-names>Z</given-names></name>. <article-title>Spectral density of mixtures of random density matrices for qubits</article-title>. <source>Physics Letters A</source>. <year>2018</year>;<volume>382</volume>(<issue>23</issue>):<fpage>1516</fpage>–<lpage>1523</lpage>. <pub-id pub-id-type="doi">10.1016/j.physleta.2018.04.018</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref040">
      <label>40</label>
      <mixed-citation publication-type="journal"><name><surname>Ginibre</surname><given-names>J</given-names></name>. <article-title>Statistical ensembles of complex, quaternion, and real matrices</article-title>. <source>Journal of Mathematical Physics</source>. <year>1965</year>;<volume>6</volume>(<issue>3</issue>):<fpage>440</fpage>–<lpage>449</lpage>. <pub-id pub-id-type="doi">10.1063/1.1704292</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref041">
      <label>41</label>
      <mixed-citation publication-type="journal"><name><surname>Tao</surname><given-names>T</given-names></name>, <name><surname>Vu</surname><given-names>V</given-names></name>. <article-title>Random matrices: the circular law</article-title>. <source>Communications in Contemporary Mathematics</source>. <year>2008</year>;<volume>10</volume>(<issue>02</issue>):<fpage>261</fpage>–<lpage>307</lpage>. <pub-id pub-id-type="doi">10.1142/S0219199708002788</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref042">
      <label>42</label>
      <mixed-citation publication-type="book"><name><surname>Mehta</surname><given-names>ML</given-names></name>. <source>Random matrices</source>. <volume>vol. 142</volume><publisher-name>Elsevier</publisher-name>; <year>2004</year>.</mixed-citation>
    </ref>
    <ref id="pone.0209358.ref043">
      <label>43</label>
      <mixed-citation publication-type="journal"><name><surname>Życzkowski</surname><given-names>K</given-names></name>, <name><surname>Kuś</surname><given-names>M</given-names></name>. <article-title>Random unitary matrices</article-title>. <source>Journal of Physics A: Mathematical and General</source>. <year>1994</year>;<volume>27</volume>(<issue>12</issue>):<fpage>4235</fpage><pub-id pub-id-type="doi">10.1088/0305-4470/27/12/028</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0209358.ref044">
      <label>44</label>
      <mixed-citation publication-type="journal"><name><surname>Jarlskog</surname><given-names>C</given-names></name>. <article-title>A recursive parametrization of unitary matrices</article-title>. <source>Journal of Mathematical Physics</source>. <year>2005</year>;<volume>46</volume>(<issue>10</issue>):<fpage>103508</fpage><pub-id pub-id-type="doi">10.1063/1.2038607</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
