<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5408799</article-id>
    <article-id pub-id-type="pmid">28453674</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btw832</article-id>
    <article-id pub-id-type="publisher-id">btw832</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>ntCard: a streaming algorithm for cardinality estimation in genomics data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Mohamadi</surname>
          <given-names>Hamid</given-names>
        </name>
        <xref ref-type="aff" rid="btw832-aff1">1</xref>
        <xref ref-type="aff" rid="btw832-aff2">2</xref>
        <xref ref-type="corresp" rid="btw832-cor1"/>
        <!--<email>hmohamadi@bcgsc.ca</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Khan</surname>
          <given-names>Hamza</given-names>
        </name>
        <xref ref-type="aff" rid="btw832-aff1">1</xref>
        <xref ref-type="aff" rid="btw832-aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Birol</surname>
          <given-names>Inanc</given-names>
        </name>
        <xref ref-type="aff" rid="btw832-aff1">1</xref>
        <xref ref-type="aff" rid="btw832-aff2">2</xref>
        <xref ref-type="corresp" rid="btw832-cor1"/>
        <!--<email>ibirol@bcgsc.ca</email>-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Berger</surname>
          <given-names>Bonnie</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <aff id="btw832-aff1"><label>1</label>Canada’s Michael Smith Genome Sciences Centre, British Columbia Cancer Agency, Vancouver, BC, Canada</aff>
    <aff id="btw832-aff2"><label>2</label>Faculty of Science, University of British Columbia, Vancouver, BC, Canada</aff>
    <author-notes>
      <corresp id="btw832-cor1">To whom correspondence should be addressed. Email: <email>hmohamadi@bcgsc.ca</email> or <email>ibirol@bcgsc.ca</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>01</day>
      <month>5</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2017-01-05">
      <day>05</day>
      <month>1</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>1</month>
      <year>2017</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>33</volume>
    <issue>9</issue>
    <fpage>1324</fpage>
    <lpage>1330</lpage>
    <history>
      <date date-type="received">
        <day>31</day>
        <month>10</month>
        <year>2016</year>
      </date>
      <date date-type="rev-recd">
        <day>21</day>
        <month>12</month>
        <year>2016</year>
      </date>
      <date date-type="accepted">
        <day>27</day>
        <month>12</month>
        <year>2016</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2017. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2017</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by-nc/4.0/" license-type="cc-by-nc">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btw832.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="SA1">
        <title>Motivation</title>
        <p>Many bioinformatics algorithms are designed for the analysis of sequences of some uniform length, conventionally referred to as <italic>k</italic>-mers. These include de Bruijn graph assembly methods and sequence alignment tools. An efficient algorithm to enumerate the number of unique <italic>k</italic>-mers, or even better, to build a histogram of <italic>k</italic>-mer frequencies would be desirable for these tools and their downstream analysis pipelines. Among other applications, estimated frequencies can be used to predict genome sizes, measure sequencing error rates, and tune runtime parameters for analysis tools. However, calculating a <italic>k</italic>-mer histogram from large volumes of sequencing data is a challenging task.</p>
      </sec>
      <sec id="SA2">
        <title>Results</title>
        <p>Here, we present ntCard, a streaming algorithm for estimating the frequencies of <italic>k</italic>-mers in genomics datasets. At its core, ntCard uses the ntHash algorithm to efficiently compute hash values for streamed sequences. It then samples the calculated hash values to build a reduced representation multiplicity table describing the sample distribution. Finally, it uses a statistical model to reconstruct the population distribution from the sample distribution. We have compared the performance of ntCard and other cardinality estimation algorithms. We used three datasets of 480 GB, 500 GB and 2.4 TB in size, where the first two representing whole genome shotgun sequencing experiments on the human genome and the last one on the white spruce genome. Results show ntCard estimates <italic>k</italic>-mer coverage frequencies &gt;15× faster than the state-of-the-art algorithms, using similar amount of memory, and with higher accuracy rates. Thus, our benchmarks demonstrate ntCard as a potentially enabling technology for large-scale genomics applications.</p>
      </sec>
      <sec id="SA3">
        <title>Availability and Implementation</title>
        <p>ntCard is written in C ++ and is released under the GPL license. It is freely available at <ext-link ext-link-type="uri" xlink:href="https://github.com/bcgsc/ntCard">https://github.com/bcgsc/ntCard</ext-link>.</p>
      </sec>
      <sec id="SA4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">National Institutes of Health</named-content>
          <named-content content-type="funder-identifier">10.13039/100000002</named-content>
        </funding-source>
        <award-id>R01HG007182</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Many bioinformatics applications rely on counting or cataloguing fixed-length substrings of DNA/RNA sequences, called <italic>k</italic>-mers, generated from reads coming out of high-throughput sequencing platforms. This is a very important step in <italic>de novo</italic> assembly (<xref rid="btw832-B3" ref-type="bibr">Butler <italic>et al.</italic>, 2008</xref>; <xref rid="btw832-B16" ref-type="bibr">Li <italic>et al.</italic>, 2010</xref>; <xref rid="btw832-B25" ref-type="bibr">Salzberg <italic>et al.</italic>, 2012</xref>; <xref rid="btw832-B28" ref-type="bibr">Simpson <italic>et al.</italic>, 2009</xref>; <xref rid="btw832-B30" ref-type="bibr">Zerbino and Birney, 2008</xref>), multiple sequence alignment (<xref rid="btw832-B10" ref-type="bibr">Edgar, 2004</xref>), error correction (<xref rid="btw832-B18" ref-type="bibr">Medvedev <italic>et al.</italic>, 2011</xref>; <xref rid="btw832-B12" ref-type="bibr">Heo <italic>et al.</italic>, 2014</xref>), repeat detection (<xref rid="btw832-B27" ref-type="bibr">Simpson, 2014</xref>), SNP detection (<xref rid="btw832-B22" ref-type="bibr">Nattestad and Schatz, 2016</xref>; <xref rid="btw832-B26" ref-type="bibr">Shajii <italic>et al.</italic>, 2016</xref>) and RNA-seq quantification analysis (<xref rid="btw832-B23" ref-type="bibr">Patro <italic>et al.</italic>, 2014</xref>). The problem of counting <italic>k</italic>-mers has been well studied in the literature, including the Jellyfish (<xref rid="btw832-B17" ref-type="bibr">Marçais and Kingsford, 2011</xref>), BFCounter (<xref rid="btw832-B20" ref-type="bibr">Melsted and Pritchard, 2011</xref>), DSK (<xref rid="btw832-B24" ref-type="bibr">Rizk <italic>et al.</italic>, 2013</xref>) and KMC (<xref rid="btw832-B9" ref-type="bibr">Deorowicz <italic>et al.</italic>, 2015</xref>) algorithms. These tools need considerable computational resources and can be improved in terms of memory, disk space and runtime requirements for processing and obtaining the histogram of <italic>k</italic>-mer frequencies in large sets of DNA/RNA sequences. During the past few years, there have been many studies to improve the memory and time requirements for the <italic>k</italic>-mer counting problem. While a naïve approach would keep track of all possible <italic>k</italic>-mers in the input datasets, employing a succinct and compact data structure (<xref rid="btw832-B6" ref-type="bibr">Conway and Bromage, 2011</xref>), or a disk-based workflow (<xref rid="btw832-B9" ref-type="bibr">Deorowicz <italic>et al.</italic>, 2015</xref>; <xref rid="btw832-B24" ref-type="bibr">Rizk <italic>et al.</italic>, 2013</xref>) would reduce memory usage. Although the improved methods with efficient implementations have considerable impact on memory and time usage, they require processing all possible <italic>k</italic>-mers base-by-base and storing them in memory or disk. Therefore, the time and memory requirements for theses efficient solutions grow linearly with the input data size, and can take hours or days using terabytes of memory for large datasets. In the recent works by Chikhi-Medvedev (<xref rid="btw832-B4" ref-type="bibr">Chikhi and Medvedev, 2014</xref>) and Melsted-Halldórsson (<xref rid="btw832-B19" ref-type="bibr">Melsted and Halldórsson, 2014</xref>), the authors proposed methods to approximate the <italic>k</italic>-mer coverage histogram in large sets of DNA/RNA sequences, which are about an order of magnitude faster, and use only a fraction of the memory compared with previous <italic>k</italic>-mer counting algorithms. However, these methods still can take considerable amount of time for processing terabytes of high-throughput sequencing data, or may not provide the full histogram for <italic>k</italic>-mer abundance.</p>
    <p>In this article, we present an efficient streaming algorithm, <italic>ntCard</italic>, for estimating the <italic>k</italic>-mer coverage histogram for large high-throughput sequencing genomics data. The proposed method requires fixed amount of memory, and runs in linear time with respect to the size of the input dataset. At its core, ntCard uses the <italic>ntHash</italic> algorithm (<xref rid="btw832-B21" ref-type="bibr">Mohamadi <italic>et al.</italic>, 2016</xref>) to efficiently compute hash values for streamed sequences. It samples the calculated hash values to build a reduced representation multiplicity table describing the sample distribution, which it uses to statistically infer the population distribution. We compare the histograms estimated by ntCard with the exact <italic>k</italic>-mer counts of DSK (<xref rid="btw832-B24" ref-type="bibr">Rizk <italic>et al.</italic>, 2013</xref>), and illustrate that the ntCard estimations are approximations within guaranteed intervals. We also compare the accuracy, runtime and memory usage of ntCard with the best available exact and approximate algorithms for <italic>k</italic>-mer count frequencies such as DSK (<xref rid="btw832-B24" ref-type="bibr">Rizk <italic>et al.</italic>, 2013</xref>), KmerGenie (<xref rid="btw832-B4" ref-type="bibr">Chikhi and Medvedev, 2014</xref>), KmerStream (<xref rid="btw832-B19" ref-type="bibr">Melsted and Halldórsson, 2014</xref>) and Khmer (<xref rid="btw832-B14" ref-type="bibr">Irber and Brown, 2016</xref>).</p>
  </sec>
  <sec>
    <title>2 Methods</title>
    <p>Let’s first introduce the problem background and notations on streaming algorithms for identifying the distinct elements. Then we will derive a statistical model to estimate <italic>k</italic>-mer frequencies, and outline the generated model.</p>
    <sec>
      <title>2.1 Background, notations and definitions</title>
      <p>Streaming algorithms are algorithms for processing data that are too large to be stored in available memory, but can be examined online, typically in a single pass. There has been a growing interest in streaming algorithms in a wide range of applications, in different domains dealing with massive amounts of data. Examples include, analysis of network traffic, database transactions, sensor networks and satellite data feeds (<xref rid="btw832-B7" ref-type="bibr">Cormode and Garofalakis, 2005</xref>; <xref rid="btw832-B8" ref-type="bibr">Cormode and Muthukrishnan, 2005</xref>; <xref rid="btw832-B13" ref-type="bibr">Indyk and Woodruff, 2005</xref>).</p>
      <p>Here, we propose a streaming algorithm for estimating the frequencies of <italic>k</italic>-mers in massive data produced from high-throughput sequencing technologies. Let <italic>f<sub>i</sub></italic> denote the number of distinct <italic>k</italic>-mers that appear <italic>i</italic> times in a given sequencing dataset. The <italic>k</italic>-mer frequency histogram is then the list of <italic>f<sub>i</sub></italic>, <inline-formula id="IE1"><mml:math id="IEQ1"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. The <italic>k</italic>th frequency moment <italic>F<sub>k</sub></italic> is defined as
<disp-formula id="E1"><label>(1)</label><mml:math id="EQ1"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>∞</mml:mo></mml:munderover><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msup></mml:mrow><mml:mo>.</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula>
The numbers <italic>F<sub>k</sub></italic> provide useful statistics on the input sequences. For example, <italic>F</italic><sub>0</sub> denotes the number of distinct <italic>k</italic>-mers appearing in the stream sequences, <italic>F</italic><sub>1</sub> is the total number of <italic>k</italic>-mers in the input datasets, <italic>F</italic><sub>2</sub> is the Gini index of variation that can be used to show the diversity of <italic>k</italic>-mers and <inline-formula id="IE2"><mml:math id="IEQ2"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mo>∞</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> results in the most frequent <italic>k</italic>-mer in the input reads.</p>
      <p>There are streaming algorithms in the literature for estimating different <italic>k</italic>th frequency moments. The problem of estimating <italic>F</italic><sub>0</sub>, also known as distinct elements counting, has been addressed by the FM-Sketch (<xref rid="btw832-B11" ref-type="bibr">Flajolet and Martin, 1985</xref>) and K-Minimum Value (<xref rid="btw832-B2" ref-type="bibr">Bar-Yossef <italic>et al.</italic>, 2002</xref>) algorithms. An <italic>F</italic><sub>2</sub> estimation algorithm was first proposed in Alon <italic>et al.</italic> (<xref rid="btw832-B1" ref-type="bibr">Alon <italic>et al.</italic>, 1999</xref>), and <inline-formula id="IE3"><mml:math id="IEQ3"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mo>∞</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> was investigated by Cormode and Muthukrishnan (<xref rid="btw832-B8" ref-type="bibr">Cormode and Muthukrishnan, 2005</xref>). These proposed algorithms can perform their estimations within a factor of (<inline-formula id="IE4"><mml:math id="IEQ4"><mml:mrow><mml:mn>1</mml:mn><mml:mo>±</mml:mo><mml:mi mathvariant="normal">ϵ</mml:mi></mml:mrow></mml:math></inline-formula>) with a set probability using <inline-formula id="IE5"><mml:math id="IEQ5"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi mathvariant="normal">ϵ</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> operations, where <italic>N</italic> is the number of distinct <italic>k</italic>-mers in the dataset (<xref rid="btw832-B19" ref-type="bibr">Melsted and Halldórsson, 2014</xref>).</p>
    </sec>
    <sec>
      <title>2.2 Estimating <italic>k</italic>-mer frequencies, <italic>f<sub>i</sub></italic></title>
      <p>To estimate the <italic>k</italic>-mer frequencies, we use a hash-based approach similar to the KmerStream algorithm (<xref rid="btw832-B19" ref-type="bibr">Melsted and Halldórsson, 2014</xref>). KmerStream is based on the K-Minimum Value algorithm (<xref rid="btw832-B2" ref-type="bibr">Bar-Yossef <italic>et al.</italic>, 2002</xref>), and it samples the data streams at different rates to select the optimal sampling rate giving the best result.</p>
      <p>ntCard works by first hashing the <italic>k</italic>-mers in read streams, which it samples to build a reduced multiplicity table. After calculating the multiplicity table for sampled <italic>k</italic>-mers, it uses this table to infer the population histogram through a statistical model.</p>
      <sec>
        <title>2.2.1 Hashing</title>
        <p>ntCard utilizes the ntHash algorithm (<xref rid="btw832-B21" ref-type="bibr">Mohamadi <italic>et al.</italic>, 2016</xref>) to efficiently compute the canonical hash values for all <italic>k</italic>-mers in DNA sequences. ntHash is a recursive, or rolling, hash function in which the hash value for the next <italic>k</italic>-mer in an input sequence of length <italic>l</italic> (<inline-formula id="IE6"><mml:math id="IEQ6"><mml:mrow><mml:mi>l</mml:mi><mml:mo>≥</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>) is derived from the hash value of the previous <italic>k</italic>-mer.
<disp-formula id="E2"><label>(2)</label><mml:math id="EQ2"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>l</mml:mi><mml:mn>1</mml:mn></mml:msup><mml:msub><mml:mi>H</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo>⊕</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>l</mml:mi><mml:mi>k</mml:mi></mml:msup><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mo>⊕</mml:mo><mml:mo> </mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>
This calculation is initiated for the first <italic>k</italic>-mer in the sequence using the base function
<disp-formula id="E3"><label>(3)</label><mml:math id="EQ3"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>l</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mo>⊕</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>l</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mo>⊕</mml:mo><mml:mo> </mml:mo><mml:mo>…</mml:mo><mml:mo> </mml:mo><mml:mo>⊕</mml:mo><mml:mo> </mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>In the above equations ⊕ is bitwise exclusive or operation, <italic>rol</italic> is cyclic binary left rotation, and <italic>h</italic> is a seed table mapping the nucleotide letters to a pre-designed 64-bit random integers. The 64-bit random integers are designed in a way that in every bit position in the 64-bit random seeds, there is equal number of 0’s and 1’s spread randomly. The time complexity of ntHash for a sequence of length <italic>l</italic> is <inline-formula id="IE7"><mml:math id="IEQ7"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, compared to <italic>O</italic>(<italic>kl</italic>) for regular hash functions.</p>
        <p>To compute the reverse-complement and consequently the canonical hash values (i.e. hash values invariant of reverse-complementation), ntHash modifies the seed table <italic>h</italic> by placing the complement nucleotide seeds within a fixed distance <italic>d</italic> of the corresponding nucleotide seeds, and then computes the hash values using
<disp-formula id="E4"><label>(4)</label><mml:math id="EQ4"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo>=</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mo>⊕</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>l</mml:mi><mml:mn>1</mml:mn></mml:msup><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mo>⊕</mml:mo><mml:mo> </mml:mo><mml:mo>⋯</mml:mo><mml:mo> </mml:mo><mml:mo>⊕</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>l</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo>=</mml:mo><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msup><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo>⊕</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msup><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mo>⊕</mml:mo><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:msup><mml:mi>l</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
Where <italic>ror</italic> is a cyclic binary right rotation. We have shown earlier that ntHash has substantial speed improvement over conventional approaches, while retaining a near-ideal hash value distribution (<xref rid="btw832-B21" ref-type="bibr">Mohamadi <italic>et al.</italic>, 2016</xref>).</p>
      </sec>
      <sec>
        <title>2.2.2 Sampling and building the multiplicity table</title>
        <p>After computing the hash values for <italic>k</italic>-mers in DNA streams using ntHash, ntCard segments the 64-bit hash values into three parts as shown in <xref ref-type="fig" rid="btw832-F1">Figure 1</xref>. It uses the left <italic>s</italic> bits in the 64-bit hash value for its <italic>sampling</italic> criterion, picking <italic>k</italic>-mers for which these bits are zero, which results in an average sampling rate of <inline-formula id="IE8"><mml:math id="IEQ8"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>s</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Earlier, we have demonstrated that ntHash bits are independently and uniformly distributed (<xref rid="btw832-B21" ref-type="bibr">Mohamadi <italic>et al.</italic>, 2016</xref>). Consequently, 1/2 of the hash values start with 0, 1/4 of them will start with two zeros, and <inline-formula id="IE9"><mml:math id="IEQ9"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>s</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> start with <italic>s</italic> zeros. Therefore, by selecting the hash values starting with <italic>s</italic> zeros, we build our sample with the cardinality of <inline-formula id="IE10"><mml:math id="IEQ10"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>s</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
        <fig id="btw832-F1" orientation="portrait" position="float">
          <label>Fig. 1.</label>
          <caption>
            <p>64-bit hash value generated by ntHash. The <italic>s</italic> left bits are used for sampling the <italic>k</italic>-mers in input datasets and the <italic>r</italic> right bits are used as resolution bit for building the reduced multiplicity table, with <inline-formula id="IE11"><mml:math id="IEQ11"><mml:mrow><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula></p>
          </caption>
          <graphic xlink:href="btw832f1"/>
        </fig>
        <p>Also building on the statistical properties of computed hash values, we use the right <italic>r</italic> bits, called the <italic>resolution</italic> bits, to build a <italic>k</italic>-mer multiplicity table for sampled <italic>k</italic>-mers. To do so, we use an array of size <inline-formula id="IE12"><mml:math id="IEQ12"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>r</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> to keep observed <italic>k</italic>-mer counts. The resolution bits of each hash value serve as the index for the count array. We note that, each entry in the array is an approximate count of the sampled <italic>k</italic>-mers, since there may be multiple <italic>k</italic>-mers with the same <italic>r</italic> bit pattern, resulting in count collisions.</p>
        <p>Ideally, one would want a hash function that generates a unique hash value for every <italic>k</italic>-mer, say using infinite number of bits. Also, if one has access to infinite memory to hold all these values, the ideal values for <italic>s</italic> and <italic>r</italic> would be zero and infinity, respectively. Since we do not in practice have access to such resources, we use 64-bit hash values, subsample our dataset by <inline-formula id="IE13"><mml:math id="IEQ13"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>s</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, and tabulate <inline-formula id="IE14"><mml:math id="IEQ14"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>r</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> patterns (some of which with zero counts). To infer the population histogram from these measurements, we derived the following statistical model.</p>
        <p>Let’s denote the count array with <inline-formula id="IE15"><mml:math id="IEQ15"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>r</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> entries by <inline-formula id="IE16"><mml:math id="IEQ16"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. If we were to extend our resolution to <italic>r</italic> + 1, we would obtain a new count array, <inline-formula id="IE17"><mml:math id="IEQ17"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, with <inline-formula id="IE18"><mml:math id="IEQ18"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> entries, twice the size of the current array <inline-formula id="IE19"><mml:math id="IEQ19"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. There is a relation between the entries of the current array <inline-formula id="IE20"><mml:math id="IEQ20"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> and the new count array <inline-formula id="IE21"><mml:math id="IEQ21"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. By folding the first half of <inline-formula id="IE22"><mml:math id="IEQ22"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> with its second half, we can construct <inline-formula id="IE23"><mml:math id="IEQ23"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> using
<disp-formula id="E5"><label>(5)</label><mml:math id="EQ5"><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>t</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>r</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:mi>n</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>r</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula id="IE24"><mml:math id="IEQ24"><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>n</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> denotes the count for entry <italic>n</italic> in the table <inline-formula id="IE25"><mml:math id="IEQ25"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
        <p>Next, if we let <inline-formula id="IE26"><mml:math id="IEQ26"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> be the relative frequency of counts <inline-formula id="IE27"><mml:math id="IEQ27"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> in table <inline-formula id="IE28"><mml:math id="IEQ28"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, with <inline-formula id="IE29"><mml:math id="IEQ29"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mo>∞</mml:mo></mml:msubsup><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, we can make the following observations. An entry of <inline-formula id="IE30"><mml:math id="IEQ30"><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> is only possible if <inline-formula id="IE31"><mml:math id="IEQ31"><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE32"><mml:math id="IEQ32"><mml:mrow><mml:msubsup><mml:mi>t</mml:mi><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>r</mml:mi></mml:msup><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Since there is no <italic>a priori</italic> reason why the first and second half of <inline-formula id="IE33"><mml:math id="IEQ33"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> should have different count distributions, we can relate the frequencies of zero counts in the two tables through
<disp-formula id="E6"><label>(6)</label><mml:math id="EQ6"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></disp-formula>
Similarly, a count of one in <inline-formula id="IE34"><mml:math id="IEQ34"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is only possible if the first half of <inline-formula id="IE35"><mml:math id="IEQ35"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is a one and the second half a zero corresponding to that entry, or vice versa, which we can write mathematically as
<disp-formula id="E7"><label>(7)</label><mml:math id="EQ7"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mi>p</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></disp-formula>
This can be generalized as
<disp-formula id="E8"><label>(8)</label><mml:math id="EQ8"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>i</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></disp-formula><boxed-text id="btw832-BOX1" position="float" orientation="portrait"><label>Algorithm 1</label><caption><p>The ntCard algorithm</p></caption><p>1: <bold>function</bold> Update(<italic>k</italic>-mer)</p><p>2:  <bold>for</bold> each read <italic>seq</italic> do</p><p>3:   <bold>for</bold> each <italic>k</italic>-mer in <italic>seq</italic> do</p><p>4:    <inline-formula id="IE36"><mml:math id="IEQ36"><mml:mrow><mml:mi>h</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula><bold>ntHash</bold> (<italic>k</italic>-mer) ▹ Compute 64-bit <italic>h</italic> using ntHash</p><p>5:    <bold>if</bold><inline-formula id="IE37"><mml:math id="IEQ37"><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mn>64</mml:mn><mml:mo>:</mml:mo><mml:mn>64</mml:mn><mml:mo>−</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mn>0</mml:mn><mml:mi>s</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula><bold>then</bold> ▹ Checking the <italic>s</italic> left bit in <italic>h</italic></p><p>6:     <inline-formula id="IE38"><mml:math id="IEQ38"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mo>:</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> ▹ <italic>r</italic> is resolution parameter</p><p>7:     <inline-formula id="IE39"><mml:math id="IEQ39"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></p><p>8: <bold>function</bold> Estimate</p><p>9:  <bold>for</bold><inline-formula id="IE40"><mml:math id="IEQ40"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> 1 to <inline-formula id="IE41"><mml:math id="IEQ41"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>r</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> do</p><p>10:   <inline-formula id="IE42"><mml:math id="IEQ42"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></p><p>11:  <bold>for</bold><inline-formula id="IE43"><mml:math id="IEQ43"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> 1 to <italic>t<sub>max</sub></italic> do</p><p>12:   <inline-formula id="IE44"><mml:math id="IEQ44"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>r</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula></p><p>13:  <inline-formula id="IE45"><mml:math id="IEQ45"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>×</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> ▹ <italic>F</italic><sub>0</sub> estimate</p><p>14:  <bold>for</bold><inline-formula id="IE46"><mml:math id="IEQ46"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> 1 to <italic>t<sub>max</sub></italic> do</p><p>15:   <inline-formula id="IE47"><mml:math id="IEQ47"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:mfrac><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:mfrac><mml:mrow><mml:mi>j</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></inline-formula> ▹ Relative estimates</p><p>16:  <bold>for</bold><inline-formula id="IE48"><mml:math id="IEQ48"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> 1 to <italic>t<sub>max</sub></italic> do</p><p>17:   <inline-formula id="IE49"><mml:math id="IEQ49"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> ▹ <italic>f<sub>i</sub></italic> estimates</p><p>18:  <bold>return</bold><inline-formula id="IE50"><mml:math id="IEQ50"><mml:mrow><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></p></boxed-text>Note that, <xref ref-type="disp-formula" rid="E6 E7 E8">Equations (6)–(8)</xref> can be solved for <inline-formula id="IE51"><mml:math id="IEQ51"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> through the recursive formula
<disp-formula id="E9"><label>(9)</label><mml:math id="EQ9"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>for</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>for</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>for</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
Now, just like extensions from a resolution of <italic>r</italic> to <italic>r</italic> + 1, resolution to <italic>r </italic>+<italic> x</italic> is also mathematically tractable. Ultimately, we would be interested in relating the observed count frequencies <inline-formula id="IE52"><mml:math id="IEQ52"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> to the count frequencies <inline-formula id="IE53"><mml:math id="IEQ53"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>∞</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, and in calculating <italic>k</italic>-mer multiplicity frequencies
<disp-formula id="E10"><label>(10)</label><mml:math id="EQ10"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>∞</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>∞</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>
For example, for <italic>i</italic> = 1, this can be calculated as
<disp-formula id="E11"><label>(11)</label><mml:math id="EQ11"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mi>lim</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>→</mml:mo><mml:mo>∞</mml:mo></mml:mrow></mml:munder><mml:mfrac><mml:mrow><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>x</mml:mi></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>x</mml:mi></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>x</mml:mi></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>x</mml:mi></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>
and for <italic>i</italic> = 2 as
<disp-formula id="E12"><label>(12)</label><mml:math id="EQ12"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msubsup><mml:mi>p</mml:mi><mml:mn>2</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>
In general, for <inline-formula id="IE54"><mml:math id="IEQ54"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, we can write the following equation
<disp-formula id="E13"><label>(13)</label><mml:math id="EQ13"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msup><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mo stretchy="false">(</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"/><mml:mtd columnalign="left"><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mi mathvariant="double-struck">Z</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo> </mml:mo><mml:mi mathvariant="normal">s</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo>.</mml:mo><mml:mo> </mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>k</mml:mi></mml:munder><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>k</mml:mi></mml:munder><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:munder></mml:mstyle><mml:mrow><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:munderover><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
where <inline-formula id="IE55"><mml:math id="IEQ55"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE56"><mml:math id="IEQ56"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≠</mml:mo><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE57"><mml:math id="IEQ57"><mml:mrow><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mi>arg</mml:mi><mml:mo>⁡</mml:mo><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:munder><mml:mo>{</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>This complex-looking formula can also be written in the following recursive form
<disp-formula id="E14"><label>(14)</label><mml:math id="EQ14"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>i</mml:mi></mml:mfrac><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mfrac><mml:mrow><mml:mi>j</mml:mi><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula>
The two terms of this equation can be interpreted as follows. The first term corresponds to count frequencies <italic>i</italic> in table <inline-formula id="IE58"><mml:math id="IEQ58"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> assuming none of the entries collided with any non-zero entries through folding rounds from <inline-formula id="IE59"><mml:math id="IEQ59"><mml:mrow><mml:munder><mml:mrow><mml:mi>lim</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>→</mml:mo><mml:mo>∞</mml:mo></mml:mrow></mml:munder><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <italic>r</italic>. The second term is a correction to the first term, accounting for all collisions of <inline-formula id="IE60"><mml:math id="IEQ60"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> and <italic>j</italic>, result of which is a count frequency of <italic>i</italic>.</p>
        <p>Now, we can derive an estimate for <italic>F</italic><sub>0</sub> by a similar approach we used for relative frequencies.
<disp-formula id="E15"><label>(15)</label><mml:math id="EQ15"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mi>lim</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>→</mml:mo><mml:mo>∞</mml:mo></mml:mrow></mml:munder><mml:msup><mml:mn>2</mml:mn><mml:mi>s</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></disp-formula>
This formula has three terms inside the limit, the first one, <inline-formula id="IE61"><mml:math id="IEQ61"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi>s</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, correcting for the subsampling we have performed. The second term is the frequency of non-zero entries in table <inline-formula id="IE62"><mml:math id="IEQ62"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, and the third entry is the normalizing factor that was used to convert occurrences of counts in this table to their frequencies, <inline-formula id="IE63"><mml:math id="IEQ63"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. Taking this limit then gives
<disp-formula id="E16"><label>(16)</label><mml:math id="EQ16"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msup><mml:mi>ln</mml:mi><mml:mo>⁡</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>0</mml:mn><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></disp-formula>
Using the <xref ref-type="disp-formula" rid="E14">Equations (14)</xref> and <xref ref-type="disp-formula" rid="E16">(16)</xref> we can obtain the <italic>k</italic>-mer coverage frequencies as outlined in Algorithm 1 with a binomial proportion confidence interval. The workflow of ntCard algorithm is also presented in <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S1</xref>.</p>
      </sec>
    </sec>
    <sec>
      <title>2.3 Implementation details</title>
      <p>Selection of the resolution parameter, <italic>r</italic>, represents a tradeoff between accuracy and computational resources. While it should not be too low to avoid poor estimates of frequency counts, it should not be too high for feasible peak memory usage. In our experience, values <italic>r</italic> &gt; 20 work well for accurate estimates, and memory usage peaks above 1 GB for <inline-formula id="IE64"><mml:math id="IEQ64"><mml:mrow><mml:mi>r</mml:mi><mml:mo>≥</mml:mo><mml:mn>28</mml:mn></mml:mrow></mml:math></inline-formula>. We have set the default value to <italic>r</italic> = 27. We have also observed that estimations based on only <italic>t<sub>r</sub></italic>, without applying the statistical model, has higher error rates due to count collisions, as expected.</p>
      <p>If input reads or sequences contain ambiguous bases, or characters other than <inline-formula id="IE65"><mml:math id="IEQ65"><mml:mrow><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, ntCard ignores them in the hashing stage. This is performed as a functionality of ntHash algorithm. When ntHash encounters a non-<italic>ACGT</italic> character it can jump over the ambiguous base, and restarts the hashing procedure from the first valid <italic>k</italic>-mer containing only <italic>ACGT</italic> characters.ntCard is written in C ++ and parallelized using OpenMP for multi-threaded computing on a single computing node. As input, it gets the set of sequences in FASTA, FASTQ, SAM and BAM formats. The input sequences can also be in compressed formats such as.gz and.bz formats. ntCard is distributed under GNU General Public License (GPL). Documentation and source code are freely available at <ext-link ext-link-type="uri" xlink:href="https://github.com/bcgsc/ntCard">https://github.com/bcgsc/ntCard</ext-link>.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Experimental setup</title>
      <p>To evaluate the performance and accuracy of ntCard, we downloaded the following publicly available sequencing data.
<list list-type="bullet"><list-item><p>The Genome in a Bottle (GIAB) project (<xref rid="btw832-B31" ref-type="bibr">Zook <italic>et al.</italic>, 2016</xref>) sequenced seven individuals using a large variety of sequencing technologies. We downloaded 2x250 bp paired-end Illumina whole genome shotgun sequencing data for the Ashkenazi mother (HG004).</p></list-item><list-item><p>We downloaded a second <italic>H. Sapiens</italic> dataset from the 1000 Genomes Project, for the individual NA19238 (SRA:ERR309932).</p></list-item><list-item><p>To represent a larger problem, we used the white spruce (<italic>Picea glauca</italic>) genome sequencing data that represents the genotype PG29 (<xref rid="btw832-B29" ref-type="bibr">Warren <italic>et al.</italic>, 2015</xref>) (accession number: ALWZ0100000000 and PID: PRJNA83435).</p></list-item></list></p>
      <p>The information of each dataset including the number of sequences, size of sequences, total number of bases and total input size of datasets is presented in <xref rid="btw832-T1" ref-type="table">Table 1</xref>. To evaluate the performance of ntCard, we compare it to KmerGenie, KmerStream and Khmer in terms of accuracy of estimates, runtime and memory usage. We also compare the accuracy of our results with DSK, which is an exact <italic>k</italic>-mer counting tool. Results were obtained on computing nodes with 48 GB of RAM and dual Intel Xeon X5650 2.66GHz CPUs with 12 cores. The operating system on each node was Linux CentOS 5.4.
<table-wrap id="btw832-T1" orientation="portrait" position="float"><label>Table 1.</label><caption><p>Dataset specification</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="left" span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="center" span="1"/></colgroup><thead><tr><th rowspan="1" colspan="1">Dataset</th><th rowspan="1" colspan="1">Read number</th><th rowspan="1" colspan="1">Read length</th><th rowspan="1" colspan="1">Total bases</th><th rowspan="1" colspan="1">Size</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">HG004</td><td rowspan="1" colspan="1">868,593,056</td><td rowspan="1" colspan="1">250 bp</td><td rowspan="1" colspan="1">217,148,264,000</td><td rowspan="1" colspan="1">480 GB</td></tr><tr><td rowspan="1" colspan="1">NA19238</td><td rowspan="1" colspan="1">913,959,800</td><td rowspan="1" colspan="1">250 bp</td><td rowspan="1" colspan="1">228,489,950,000</td><td rowspan="1" colspan="1">500 GB</td></tr><tr><td rowspan="1" colspan="1">PG29</td><td rowspan="1" colspan="1">6,858,517,737</td><td rowspan="1" colspan="1">250 bp</td><td rowspan="1" colspan="1">1,714,629,434,250</td><td rowspan="1" colspan="1">2.4 TB</td></tr></tbody></table></table-wrap></p>
      <p>All five tools are run with their default parameters, and the parameters related to the resource usage are set in a way to utilize the maximum capacity on each computing node as described in <xref ref-type="supplementary-material" rid="sup1">Supplementary Data</xref>. For example, all tools are run in multi-threaded mode with the maximum number of threads available on the computer.</p>
    </sec>
    <sec>
      <title>3.2 Accuracy</title>
      <p>In <xref rid="btw832-T2 btw832-T3 btw832-T4" ref-type="table">Tables 2–4</xref>, we see the results of DSK, ntCard, KmerGenie, KmerStream, and Khmer for distinct number of <italic>k</italic>-mers, <italic>F</italic><sub>0</sub>, as well as the number on singletons, <italic>f</italic><sub>1</sub>, on three datasets. We compared the accuracy of estimated counts from ntCard, KmerGenie, KmerStream and Khmer with exact counts from DSK. We see that, for all <italic>k</italic>-mer lengths, ntCard computes <italic>F</italic><sub>0</sub> and <italic>f</italic><sub>1</sub> for all three datasets with error rates less than 0.7%. In comparison, the error rates of KmerGenie, KmerStream and Khmer can be up to 17%, 9% and 11%, respectively. Note that, the Khmer algorithm only estimates the total number of distinct <italic>k</italic>-mers, <italic>F</italic><sub>0</sub>. The full results from all algorithms other than DSK are presented in <xref ref-type="supplementary-material" rid="sup1">Supplementary Tables S1–S3</xref>.
<table-wrap id="btw832-T2" orientation="portrait" position="float"><label>Table 2.</label><caption><p>Accuracy of algorithms in estimating <italic>F</italic><sub>0</sub> and <italic>f</italic><sub>1</sub> for HG004 reads</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/></colgroup><thead><tr><th rowspan="1" colspan="1"><italic>k</italic></th><th colspan="2" rowspan="1">DSK</th><th rowspan="1" colspan="1">ntCard</th><th rowspan="1" colspan="1">KmerGenie</th><th rowspan="1" colspan="1">KmerStream</th><th rowspan="1" colspan="1">Khmer</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">32</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">13,319,957,567</td><td rowspan="1" colspan="1"><bold>0.01%</bold></td><td rowspan="1" colspan="1">0.97%</td><td rowspan="1" colspan="1">7.04%</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">16,539,753,749</td><td rowspan="1" colspan="1"><bold>0.02%</bold></td><td rowspan="1" colspan="1">0.64%</td><td rowspan="1" colspan="1">5.12%</td><td rowspan="1" colspan="1">0.67%</td></tr><tr><td rowspan="1" colspan="1">64</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">17,898,672,342</td><td rowspan="1" colspan="1"><bold>0.02%</bold></td><td rowspan="1" colspan="1">0.35%</td><td rowspan="1" colspan="1">0.73%</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">21,343,659,785</td><td rowspan="1" colspan="1"><bold>0.00%</bold></td><td rowspan="1" colspan="1">0.22%</td><td rowspan="1" colspan="1">0.66%</td><td rowspan="1" colspan="1">0.15%</td></tr><tr><td rowspan="1" colspan="1">96</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">18,827,062,018</td><td rowspan="1" colspan="1">0.36%</td><td rowspan="1" colspan="1">0.87%</td><td rowspan="1" colspan="1"><bold>0.00%</bold></td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">22,313,944,415</td><td rowspan="1" colspan="1">0.24%</td><td rowspan="1" colspan="1">0.69%</td><td rowspan="1" colspan="1"><bold>0.05%</bold></td><td rowspan="1" colspan="1">0.31%</td></tr><tr><td rowspan="1" colspan="1">128</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">18,091,241,186</td><td rowspan="1" colspan="1"><bold>0.36%</bold></td><td rowspan="1" colspan="1">0.76%</td><td rowspan="1" colspan="1">0.40%</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">21,555,678,676</td><td rowspan="1" colspan="1">0.25%</td><td rowspan="1" colspan="1">0.62%</td><td rowspan="1" colspan="1"><bold>0.20%</bold></td><td rowspan="1" colspan="1">0.30%</td></tr></tbody></table><table-wrap-foot><fn id="tblfn1"><p>The DSK column reports the exact <italic>k</italic>-mer counts, and columns for the other tools report percent errors.</p></fn></table-wrap-foot></table-wrap><table-wrap id="btw832-T3" orientation="portrait" position="float"><label>Table 3.</label><caption><p>Accuracy of algorithms in estimating <italic>F</italic><sub>0</sub> and <italic>f</italic><sub>1</sub> for NA19238 reads</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="center" span="1"/></colgroup><thead><tr><th rowspan="1" colspan="1"><italic>k</italic></th><th colspan="2" rowspan="1">DSK</th><th rowspan="1" colspan="1">ntCard</th><th rowspan="1" colspan="1">KmerGenie</th><th rowspan="1" colspan="1">KmerStream</th><th rowspan="1" colspan="1">Khmer</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">32</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">14,881,561,565</td><td rowspan="1" colspan="1"><bold>0.00%</bold></td><td rowspan="1" colspan="1">0.53%</td><td rowspan="1" colspan="1">6.36%</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">18,091,801,391</td><td rowspan="1" colspan="1"><bold>0.00%</bold></td><td rowspan="1" colspan="1">0.40%</td><td rowspan="1" colspan="1">4.64%</td><td rowspan="1" colspan="1">1.82%</td></tr><tr><td rowspan="1" colspan="1">64</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">19,074,667,480</td><td rowspan="1" colspan="1"><bold>0.02%</bold></td><td rowspan="1" colspan="1">0.75%</td><td rowspan="1" colspan="1">0.68%</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">22,527,419,136</td><td rowspan="1" colspan="1"><bold>0.01%</bold></td><td rowspan="1" colspan="1">0.77%</td><td rowspan="1" colspan="1">0.65%</td><td rowspan="1" colspan="1">1.22%</td></tr><tr><td rowspan="1" colspan="1">96</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">19,420,503,673</td><td rowspan="1" colspan="1">0.22%</td><td rowspan="1" colspan="1">0.66%</td><td rowspan="1" colspan="1"><bold>0.09%</bold></td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">22,932,238,161</td><td rowspan="1" colspan="1">0.16%</td><td rowspan="1" colspan="1">0.66%</td><td rowspan="1" colspan="1"><bold>0.07%</bold></td><td rowspan="1" colspan="1">0.46%</td></tr><tr><td rowspan="1" colspan="1">128</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">17,902,027,438</td><td rowspan="1" colspan="1">0.21%</td><td rowspan="1" colspan="1">0.85%</td><td rowspan="1" colspan="1"><bold>0.19%</bold></td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">21,421,517,759</td><td rowspan="1" colspan="1">0.13%</td><td rowspan="1" colspan="1">0.76%</td><td rowspan="1" colspan="1"><bold>0.03%</bold></td><td rowspan="1" colspan="1">1.05%</td></tr></tbody></table><table-wrap-foot><fn id="tblfn2"><p>The DSK column reports the exact <italic>k</italic>-mer counts, and columns for the other tools report percent errors.</p></fn></table-wrap-foot></table-wrap><table-wrap id="btw832-T4" orientation="portrait" position="float"><label>Table 4.</label><caption><p>Accuracy of algorithms in estimating <italic>F</italic><sub>0</sub> and <italic>f</italic><sub>1</sub> for PG29 reads</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col valign="top" align="left" span="1"/><col valign="top" align="center" span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="char" char="." span="1"/><col valign="top" align="center" span="1"/></colgroup><thead><tr><th rowspan="1" colspan="1"><italic>k</italic></th><th colspan="2" rowspan="1">DSK</th><th rowspan="1" colspan="1">ntCard</th><th rowspan="1" colspan="1">KmerGenie</th><th rowspan="1" colspan="1">KmerStream</th><th rowspan="1" colspan="1">Khmer</th></tr></thead><tbody><tr><td rowspan="1" colspan="1">32</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">27,430,910,938</td><td rowspan="1" colspan="1"><bold>0.02%</bold></td><td rowspan="1" colspan="1">15.33%</td><td rowspan="1" colspan="1">9.41%</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">42,642,198,777</td><td rowspan="1" colspan="1"><bold>0.01%</bold></td><td rowspan="1" colspan="1">11.02%</td><td rowspan="1" colspan="1">7.37%</td><td rowspan="1" colspan="1">8.86%</td></tr><tr><td rowspan="1" colspan="1">64</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">44,344,130,469</td><td rowspan="1" colspan="1"><bold>0.04%</bold></td><td rowspan="1" colspan="1">16.36%</td><td rowspan="1" colspan="1">2.61%</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">67,800,291,613</td><td rowspan="1" colspan="1"><bold>0.02%</bold></td><td rowspan="1" colspan="1">11.14%</td><td rowspan="1" colspan="1">1.73%</td><td rowspan="1" colspan="1">11.18%</td></tr><tr><td rowspan="1" colspan="1">96</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">43,300,244,443</td><td rowspan="1" colspan="1"><bold>0.66%</bold></td><td rowspan="1" colspan="1">17.51%</td><td rowspan="1" colspan="1">0.73%</td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">69,855,690,006</td><td rowspan="1" colspan="1"><bold>0.46%</bold></td><td rowspan="1" colspan="1">11.13%</td><td rowspan="1" colspan="1">0.57%</td><td rowspan="1" colspan="1">9.36%</td></tr><tr><td rowspan="1" colspan="1">128</td><td rowspan="1" colspan="1"><italic>f</italic><sub>1</sub></td><td rowspan="1" colspan="1">32,089,613,024</td><td rowspan="1" colspan="1">0.40%</td><td rowspan="1" colspan="1">14.82%</td><td rowspan="1" colspan="1"><bold>0.06%</bold></td><td rowspan="1" colspan="1">–</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"><italic>F</italic><sub>0</sub></td><td rowspan="1" colspan="1">58,195,246,941</td><td rowspan="1" colspan="1">0.30%</td><td rowspan="1" colspan="1">8.35%</td><td rowspan="1" colspan="1"><bold>0.27%</bold></td><td rowspan="1" colspan="1">7.39%</td></tr></tbody></table><table-wrap-foot><fn id="tblfn3"><p>The DSK column reports the exact <italic>k</italic>-mer counts, and columns for the other tools report percent errors. </p></fn></table-wrap-foot></table-wrap></p>
      <p>Compared to ntCard and KmerStream, Khmer and KmerGenie estimates for distinct number of <italic>k</italic>-mers, <italic>F</italic><sub>0</sub>, have the highest error rates (&gt;7%) on PG29 data; though, for HG004 and NA19238, Khmer estimates <italic>F</italic><sub>0</sub> with lower error rates, and KmerGenie has very accurate estimates with error rates &lt;1% for all <italic>k</italic> values. On all three datasets, KmerStream has more accurate estimates for longer <italic>k</italic>-mers, where error rates increasing rapidly for shorter <italic>k</italic>-mers. Although ntCard generally has the opposite trend, it also has the most stable performance for all three datasets. Except for <italic>k </italic>=<italic> </italic>128 bp on NA19238 and PG29, and <italic>k </italic>=<italic> </italic>96 bp on NA19238 and HG004, ntCard consistently displays the best accuracy both for <italic>F</italic><sub>0</sub> and <italic>f</italic><sub>1</sub>, as indicated by the bold entries in <xref rid="btw832-T2 btw832-T3 btw832-T4" ref-type="table">Tables 2–4</xref>.</p>
      <p>We have also evaluated the accuracy of full <italic>k</italic>-mer frequency histograms of ntCard on all three datasets with different <italic>k</italic> values. Since the KmerStream algorithm only computes estimates for <italic>F</italic><sub>0</sub> and <italic>f</italic><sub>1</sub> and Khmer only estimates <italic>F</italic><sub>0</sub>, we could only compare the accuracy of the ntCard histogram with the estimated results of KmerGenie and the exact histogram from DSK method. <xref ref-type="fig" rid="btw832-F2">Figure 2</xref> shows the <italic>k</italic>-mer frequency histograms of DSK, ntCard, and KmerGenie for all three datasets with four <italic>k</italic> values, <inline-formula id="IE66"><mml:math id="IEQ66"><mml:mrow><mml:mo>{</mml:mo><mml:mn>32</mml:mn><mml:mo>,</mml:mo><mml:mn>64</mml:mn><mml:mo>,</mml:mo><mml:mn>96</mml:mn><mml:mo>,</mml:mo><mml:mn>128</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Since the results of <italic>f</italic><sub>1</sub> have already been presented in <xref rid="btw832-T2" ref-type="table">Tables 2–4</xref>, and since <inline-formula id="IE67"><mml:math id="IEQ67"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mn>…</mml:mn><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mn>62</mml:mn></mml:mrow></mml:msub><mml:mo>≪</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, the histograms in <xref ref-type="fig" rid="btw832-F2">Figure 2</xref> show the <italic>k</italic>-mer frequencies starting from <italic>f</italic><sub>2</sub>. The exact numbers of <inline-formula id="IE68"><mml:math id="IEQ68"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mn>…</mml:mn><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mn>62</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for DSK, ntCard, and KmerGenie on all three datasets are presented in <xref ref-type="supplementary-material" rid="sup1">Supplementary Tables S4–S15</xref>. From <xref ref-type="fig" rid="btw832-F2">Figure 2</xref> and <xref ref-type="supplementary-material" rid="sup1">Supplementary Tables S4–S15</xref>, we can see ntCard estimates the <italic>k</italic>-mer frequency histograms for all three datasets more accurate than KmerGenie.</p>
      <fig id="btw832-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p><italic>k</italic>-mer frequency histograms for human genomes HG004 and NA19238 (rows 1 and 2, respectively), and the white spruce genome PG29 (row 3). We have used DSK <italic>k</italic>-mer counting results as our ground truth in evaluation (orange circle data points). The <italic>k</italic>-mer coverage frequency results, <inline-formula id="IE69"><mml:math id="IEQ69"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mn>..</mml:mn><mml:msub><mml:mi>f</mml:mi><mml:mrow><mml:mn>62</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of ntCard and KmerGenie for different values of <inline-formula id="IE70"><mml:math id="IEQ70"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>32</mml:mn><mml:mo>,</mml:mo><mml:mn>64</mml:mn><mml:mo>,</mml:mo><mml:mn>96</mml:mn><mml:mo>,</mml:mo><mml:mn>128</mml:mn></mml:mrow></mml:math></inline-formula> (the four columns from left to right) are shown with the symbols (+) and (<inline-formula id="IE71"><mml:math id="IEQ71"><mml:mo>⋄</mml:mo></mml:math></inline-formula>), respectively</p>
        </caption>
        <graphic xlink:href="btw832f2"/>
      </fig>
    </sec>
    <sec>
      <title>3.3 Runtime and memory usage</title>
      <p>We have calculated the memory usage of all benchmarked tools. DSK uses both main memory and disk space for counting <italic>k</italic>-mers, and therefore we obtained both values for it. We should also mention that DSK was executed on compute nodes equipped with solid-state drives (SSD). This helps the runtime of DSK be greatly reduced with the SSD and multi-threaded parallelism. The memory usage for DSK on all three datasets was the same at about 20 GB of RAM, while the disk space usage was 500 GB for human genomes HG004 and NA19238, and 1 TB for the white spruce genome PG29.</p>
      <p>The memory usage of KmerGenie to estimate the full <italic>k</italic>-mer frequency histograms for all datasets was about 200 MB of RAM. KmerStream uses 2-bit counters to estimate <italic>F</italic><sub>0</sub> and <italic>f</italic><sub>1</sub>, resulting in lower memory requirement. The memory usage for KmerStream on all three datasets was about 65 MB of RAM. The Khmer algorithm requires the lowest amount of memory among all algorithms but only estimates <italic>F</italic><sub>0</sub>. It requires about 15 MB of RAM to estimate the total number of distinct <italic>k</italic>-mers in all three datasets. The memory requirement of ntCard for all three datasets was about 500 MB of RAM, although we note that it computes the full <italic>k</italic>-mer multiplicity histogram. We have also implemented a special runtime parameter to only compute the total number of distinct elements, <italic>F</italic><sub>0</sub>, in which case it requires about 2 MB of RAM.</p>
      <p><xref ref-type="fig" rid="btw832-F3">Figure 3</xref> shows the runtime of all methods on the experimented datasets with different <italic>k</italic> values from 32 to 128. The runtime of ntCard to obtain the full <italic>k</italic>-mer frequency histograms for human genome datasets (HG004, NA19238) is about 6 mins. For KmerStream, it takes about 100 mins to obtain <italic>F</italic><sub>0</sub> and <italic>f</italic><sub>1</sub> on human genome datasets, while this is about 200 mins for Khmer to estimate just the total number of distinct <italic>k</italic>-mers, <italic>F</italic><sub>0</sub>. DSK and KmerGenie take up to 600 and 800 minutes, respectively, to compute the <italic>k</italic>-mer coverage histograms for human genome datasets. For the white spruce PG29 dataset, ntCard requires about 30 mins to estimate <italic>k</italic>-mer frequency histograms, while for KmerStream it takes about 450 mins to obtain <italic>F</italic><sub>0</sub> and <italic>f</italic><sub>1</sub>. The Khmer takes longer time about 1200 mins to estimate <italic>F</italic><sub>0</sub>. DSK can take up to 2700 mins to compute the <italic>k</italic>-mer frequency histograms and this number is 3400 mins for KmerGenie to estimate <italic>k</italic>-mer coverage histograms. We should note that ntCard, KmerGenie and KmerStream algorithms have an option to pass multiple <italic>k</italic> values and compute multiple <italic>k</italic>-mer coverage histograms in a single run. This option will reduce the amortized runtime per <italic>k</italic> value, but it will increase the memory usage. From the runtime results, we see ntCard estimates the full <italic>k</italic>-mer coverage frequency histograms &gt;15× faster than the closest competitor, KmerStream, which only computes <italic>F</italic><sub>0</sub> and <italic>f</italic><sub>1</sub>. <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S2</xref> shows the runtime performance versus the number of threads for the ntCard algorithm. In our experiments and computing environment, approximately one third of the ntCard runtime is spent on reading input datasets, and the rest on computing <italic>k</italic>-mer coverage histograms. Therefore I/O efficiency, which is system and architecture dependent, has a considerable impact on the runtime performance of ntCard.</p>
      <fig id="btw832-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Runtime of DSK, ntCard, KmerGenie, KmerStream and Khmer for all three datasets, HG004, NA19238 and PG29. We have calculated the runtime of all algorithms for different values of <italic>k</italic> in <inline-formula id="IE72"><mml:math id="IEQ72"><mml:mrow><mml:mo>{</mml:mo><mml:mn>32</mml:mn><mml:mo>,</mml:mo><mml:mn>64</mml:mn><mml:mo>,</mml:mo><mml:mn>96</mml:mn><mml:mo>,</mml:mo><mml:mn>128</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. As we see in the plots, ntCard estimates the full <italic>k</italic>-mer coverage frequency histograms &gt;15× faster than KmerStream</p>
        </caption>
        <graphic xlink:href="btw832f3"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>With growing throughput and dropping cost of the next generation sequencing technologies, there is a continued need to develop faster and more effective bioinformatics tools to process and analyze data associated with them. Developing algorithms and tools that analyze these huge amounts of data <italic>on the fly</italic>, preferably without storing intermediate files, would have many benefits in a broad spectrum of genomics projects such as <italic>de novo</italic> genome and transcriptome assembly, sequence alignment, repeat detection, error correction and downstream analysis.</p>
    <p>In this work, we introduced the ntCard streaming algorithm for estimating the <italic>k</italic>-mer coverage frequency histogram for high-throughput sequencing genomics data. It employs the <italic>ntHash</italic> algorithm for hashing all <italic>k</italic>-mers in DNA/RNA sequences efficiently, samples the <italic>k</italic>-mers in datasets based on the <italic>k</italic>-mer hashes, and reconstructs the <italic>k</italic>-mer frequencies using a statistical model. Using an amount of memory comparable to similar tools, ntCard estimates <italic>k</italic>-mer frequency histogram for massive genomics datasets, several folds faster than the state-of-the-art approaches.</p>
    <p>Sample use cases of ntCard include tuning runtime parameters in de Bruijn graph assembly tasks such as optimal <italic>k</italic> value for the assembly, and setting parameters in applications utilizing the Bloom filter data structure. ntCard has been used in the new version of our genome assembly software package, ABySS 2.0 (<xref rid="btw832-B15" ref-type="bibr">Jackman <italic>et al.</italic>, 2016</xref>), to determine the values for total memory size and number of hash functions. It has been also utilized to set the Bloom filter sizes in BioBloom tools (<xref rid="btw832-B5" ref-type="bibr">Chu <italic>et al.</italic>, 2014</xref>), which is a general use fast sequence categorization tool utilizing Bloom filters. Using ntCard these tools are able to get the total number of distinct <italic>k</italic>-mers <italic>F</italic><sub>0</sub>, as well as the number of <italic>k</italic>-mers above a certain multiplicity threshold. The <italic>k</italic>-mer coverage histograms computed by ntCard can be also used as input to utilities like <italic>GenomeScope</italic> (<ext-link ext-link-type="uri" xlink:href="http://qb.cshl.edu/genomescope/">http://qb.cshl.edu/genomescope/</ext-link>) for estimating genome sizes, sequencing error rates, repeat contents, and heterozygosity of genomes (<xref rid="btw832-B4" ref-type="bibr">Chikhi and Medvedev, 2014</xref>; <xref rid="btw832-B17" ref-type="bibr">Marçais and Kingsford, 2011</xref>; <xref rid="btw832-B19" ref-type="bibr">Melsted and Halldórsson, 2014</xref>; <xref rid="btw832-B27" ref-type="bibr">Simpson, 2014</xref>).</p>
    <p>We expect ntCard to provide utility in efficiently characterizing certain properties of large read sets, helping quality control pipelines and <italic>de novo</italic> sequencing projects.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>Supplementary Data</label>
      <media xlink:href="btw832_supp.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>We thank the Sequencing Lab and the Bioinformatics Technology Lab (BTL) at Genome Sciences Centre, British Columbia Cancer Agency for their assistance with this project.</p>
    <sec>
      <title>Funding</title>
      <p>We thank Genome Canada, Genome British Columbia, and British Columbia Cancer Foundation for their financial support. The work is also partially funded by the National Institutes of Health under Award Number R01HG007182. The content of this work is solely the responsibility of the authors, and does not necessarily represent the official views of the National Institutes of Health or other funding organizations.</p>
      <p><italic>Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="btw832-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Alon</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>1999</year>) 
<article-title>The space complexity of approximating the frequency moments</article-title>. <source>J. Comput. Syst. Sci</source>., <volume>58</volume>, <fpage>137</fpage>–<lpage>147</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B2">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Bar-Yossef</surname><given-names>Z.</given-names></name></person-group><etal>et al</etal> (<year>2002</year>) Counting distinct elements in a data stream. In: <italic>Proceedings of the 6th International Workshop on Randomization and Approximation Techniques.</italic> RANDOM ’02, p.<fpage>1</fpage>–<lpage>10</lpage>. Springer-Verlag, London, UK.</mixed-citation>
    </ref>
    <ref id="btw832-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Butler</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) 
<article-title>ALLPATHS: de novo assembly of whole-genome shotgun microreads</article-title>. <source>Gen. Res</source>., <volume>18</volume>, <fpage>810</fpage>–<lpage>820</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chikhi</surname><given-names>R.</given-names></name>, <name name-style="western"><surname>Medvedev</surname><given-names>P.</given-names></name></person-group> (<year>2014</year>) 
<article-title>Informed and automated k-mer size selection for genome assembly</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>31</fpage>–<lpage>37</lpage>.<pub-id pub-id-type="pmid">23732276</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chu</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>BioBloom tools: fast, accurate and memory-efficient host species sequence screening using bloom filters</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3402</fpage>–<lpage>3404</lpage>.<pub-id pub-id-type="pmid">25143290</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Conway</surname><given-names>T.C.</given-names></name>, <name name-style="western"><surname>Bromage</surname><given-names>A.J.</given-names></name></person-group> (<year>2011</year>) 
<article-title>Succinct data structures for assembling large genomes</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>479</fpage>–<lpage>486</lpage>.<pub-id pub-id-type="pmid">21245053</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B7">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Cormode</surname><given-names>G.</given-names></name>, <name name-style="western"><surname>Garofalakis</surname><given-names>M.</given-names></name></person-group> (<year>2005</year>). Sketching streams through the net: distributed approximate query tracking. In: <italic>Proceedings of the 31st International Conference on Very Large Data Bases.</italic> VLDB ’05, p.13–24. VLDB Endowment, Trondheim, Norway.</mixed-citation>
    </ref>
    <ref id="btw832-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Cormode</surname><given-names>G.</given-names></name>, <name name-style="western"><surname>Muthukrishnan</surname><given-names>S.</given-names></name></person-group> (<year>2005</year>) 
<article-title>An improved data stream summary: the count-min sketch and its applications</article-title>. <source>J. Algorithms</source>, <volume>55</volume>, <fpage>58</fpage>–<lpage>75</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Deorowicz</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>KMC 2: fast and resource-frugal k-mer counting</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>1569</fpage>–<lpage>1576</lpage>.<pub-id pub-id-type="pmid">25609798</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Edgar</surname><given-names>R.C.</given-names></name></person-group> (<year>2004</year>) 
<article-title>MUSCLE: multiple sequence alignment with high accuracy and high throughput</article-title>. <source>Nucl. Acids Res</source>., <volume>32</volume>, <fpage>1792</fpage>–<lpage>1797</lpage>.<pub-id pub-id-type="pmid">15034147</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Flajolet</surname><given-names>P.</given-names></name>, <name name-style="western"><surname>Martin</surname><given-names>G.N.</given-names></name></person-group> (<year>1985</year>) 
<article-title>Probabilistic counting algorithms for data base applications</article-title>. <source>J. Comput. Syst. Sci</source>., <volume>31</volume>, <fpage>182</fpage>–<lpage>209</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Heo</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>BLESS: bloom filter-based error correction solution for high-throughput sequencing reads</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>1354</fpage>–<lpage>1362</lpage>.<pub-id pub-id-type="pmid">24451628</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Indyk</surname><given-names>P.</given-names></name>, <name name-style="western"><surname>Woodruff</surname><given-names>D.</given-names></name></person-group> (<year>2005</year>) Optimal approximations of the frequency moments of data streams. In <italic>Proceedings of the Thirty-seventh Annual ACM Symposium on Theory of Computing.</italic> STOC ’05, p.202–208. ACM, New York, NY, USA.</mixed-citation>
    </ref>
    <ref id="btw832-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Irber Junior</surname><given-names>L.C.</given-names></name>, <name name-style="western"><surname>Brown</surname><given-names>C.T.</given-names></name></person-group> (<year>2016</year>) 
<article-title>Efficient cardinality estimation for k-mers in large DNA sequencing data sets</article-title>. <source>bioRxiv</source>, <fpage>1</fpage>–<lpage>5</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jackman</surname><given-names>S.D.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>ABySS 2.0: resource-efficient assembly of large genomes using a bloom filter</article-title>. <source>bioRxiv</source>, <fpage>1</fpage>–<lpage>24</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title>. <source>Gen. Res</source>, <volume>20</volume>, <fpage>265</fpage>–<lpage>272</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Marçais</surname><given-names>G.</given-names></name>, <name name-style="western"><surname>Kingsford</surname><given-names>C.</given-names></name></person-group> (<year>2011</year>) 
<article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>764</fpage>–<lpage>770</lpage>.<pub-id pub-id-type="pmid">21217122</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Medvedev</surname><given-names>P.</given-names></name></person-group><etal>et al</etal> (<year>2011</year>) 
<article-title>Error correction of high-throughput sequencing datasets with non-uniform coverage</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>i137</fpage>–<lpage>i141</lpage>.<pub-id pub-id-type="pmid">21685062</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Melsted</surname><given-names>P.</given-names></name>, <name name-style="western"><surname>Halldórsson</surname><given-names>B.V.</given-names></name></person-group> (<year>2014</year>) 
<article-title>KmerStream: streaming algorithms for k-mer abundance estimation</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3541</fpage>–<lpage>3547</lpage>.<pub-id pub-id-type="pmid">25355787</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Melsted</surname><given-names>P.</given-names></name>, <name name-style="western"><surname>Pritchard</surname><given-names>J.K.</given-names></name></person-group> (<year>2011</year>) 
<article-title>Efficient counting of k-mers in DNA sequences using a bloom filter</article-title>. <source>BMC Bioinformatics</source>., <volume>12</volume>, <fpage>333.</fpage><pub-id pub-id-type="pmid">21831268</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mohamadi</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>ntHash: recursive nucleotide hashing</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>3492</fpage>–<lpage>3494</lpage>.<pub-id pub-id-type="pmid">27423894</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Nattestad</surname><given-names>M.</given-names></name>, <name name-style="western"><surname>Schatz</surname><given-names>M.C.</given-names></name></person-group> (<year>2016</year>) 
<article-title>Assemblytics: a web analytics tool for the detection of variants from an assembly</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>3021</fpage>–<lpage>3023</lpage>.<pub-id pub-id-type="pmid">27318204</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Patro</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Sailfish enables alignment-free isoform quantification from RNA-seq reads using lightweight algorithms</article-title>. <source>Nat. Biotech</source>., <volume>32</volume>, <fpage>462</fpage>–<lpage>464</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rizk</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>DSK: k-mer counting with very low memory usage</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>652</fpage>–<lpage>653</lpage>.<pub-id pub-id-type="pmid">23325618</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Salzberg</surname><given-names>S.L.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>GAGE: a critical evaluation of genome assemblies and assembly algorithms</article-title>. <source>Gen. Res</source>, <volume>22</volume>, <fpage>557</fpage>–<lpage>567</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Shajii</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Fast genotyping of known SNPs through approximate k-mer matching</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>i538</fpage>–<lpage>i544</lpage>.<pub-id pub-id-type="pmid">27587672</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Simpson</surname><given-names>J.T.</given-names></name></person-group> (<year>2014</year>) 
<article-title>Exploring genome characteristics and sequence quality without a reference</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>1228</fpage>–<lpage>1235</lpage>.<pub-id pub-id-type="pmid">24443382</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Simpson</surname><given-names>J.T.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>ABySS: a parallel assembler for short read sequence data</article-title>. <source>Gen. Res</source>., <volume>19</volume>, <fpage>1117</fpage>–<lpage>1123</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Warren</surname><given-names>R.L.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Improved white spruce (Picea glauca) genome assemblies and annotation of large gene families of conifer terpenoid and phenolic defense metabolism</article-title>. <source>Plant J</source>., <volume>83</volume>, <fpage>189</fpage>–<lpage>212</lpage>.<pub-id pub-id-type="pmid">26017574</pub-id></mixed-citation>
    </ref>
    <ref id="btw832-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zerbino</surname><given-names>D.R.</given-names></name>, <name name-style="western"><surname>Birney</surname><given-names>E.</given-names></name></person-group> (<year>2008</year>) 
<article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>. <source>Gen. Res</source>., <volume>18</volume>, <fpage>821</fpage>–<lpage>829</lpage>.</mixed-citation>
    </ref>
    <ref id="btw832-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zook</surname><given-names>J.M.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Extensive sequencing of seven human genomes to characterize benchmark reference materials</article-title>. <source>Sci. Data</source>, <volume>3</volume>, <fpage>160025</fpage>.<pub-id pub-id-type="pmid">27271295</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
