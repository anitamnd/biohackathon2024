<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6612831</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz349</article-id>
    <article-id pub-id-type="publisher-id">btz349</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2019 Conference Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Comparative and Functional Genomics</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>cloudSPAdes: assembly of synthetic long reads using de Bruijn graphs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Tolstoganov</surname>
          <given-names>Ivan</given-names>
        </name>
        <xref ref-type="aff" rid="btz349-aff1">1</xref>
        <xref ref-type="corresp" rid="btz349-cor1"/>
        <!--<email>i.tolstoganov@spbu.ru</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bankevich</surname>
          <given-names>Anton</given-names>
        </name>
        <xref ref-type="aff" rid="btz349-aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chen</surname>
          <given-names>Zhoutao</given-names>
        </name>
        <xref ref-type="aff" rid="btz349-aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Pevzner</surname>
          <given-names>Pavel A</given-names>
        </name>
        <xref ref-type="aff" rid="btz349-aff1">1</xref>
        <xref ref-type="aff" rid="btz349-aff2">2</xref>
      </contrib>
    </contrib-group>
    <aff id="btz349-aff1"><label>1</label>Center for Algorithmic Biotechnology, Institute of Translational Biomedicine, St. Petersburg State University, St. Petersburg, Russia</aff>
    <aff id="btz349-aff2"><label>2</label>Department of Computer Science and Engineering, University of California at San Diego, La Jolla, CA, USA</aff>
    <aff id="btz349-aff3"><label>3</label>Universal Sequencing Technology Corporation, Carlsbad, CA, USA</aff>
    <author-notes>
      <corresp id="btz349-cor1">To whom correspondence should be addressed. <email>i.tolstoganov@spbu.ru</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-05">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>35</volume>
    <issue>14</issue>
    <fpage>i61</fpage>
    <lpage>i70</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz349.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>The recently developed barcoding-based synthetic long read (SLR) technologies have already found many applications in genome assembly and analysis. However, although some new barcoding protocols are emerging and the range of SLR applications is being expanded, the existing SLR assemblers are optimized for a narrow range of parameters and are not easily extendable to new barcoding technologies and new applications such as metagenomics or hybrid assembly.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We describe the algorithmic challenge of the SLR assembly and present a cloudSPAdes algorithm for SLR assembly that is based on analyzing the de Bruijn graph of SLRs. We benchmarked cloudSPAdes across various barcoding technologies/applications and demonstrated that it improves on the state-of-the-art SLR assemblers in accuracy and speed.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>Source code and installation manual for cloudSPAdes are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/ablab/spades/releases/tag/cloudspades-paper">https://github.com/ablab/spades/releases/tag/cloudspades-paper</ext-link>.</p>
      </sec>
      <sec id="s4">
        <title>Supplementary Information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Russian Science Foundation</named-content>
          <named-content content-type="funder-identifier">10.13039/501100006769</named-content>
        </funding-source>
        <award-id>19–14–00172</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p><bold>The SLR technology.</bold> Long-read sequencing technologies (developed by Pacific Biosciences and Oxford Nanopores) have resulted in improved assemblies as compared to short-read sequencing technologies. However, their applications, particularly in the field of metagenomics, remain rather expensive in terms of the per-base cost (<xref rid="btz349-B12" ref-type="bibr">Gong <italic>et al.</italic>, 2018</xref>; <xref rid="btz349-B13" ref-type="bibr">Goordial <italic>et al.</italic>, 2017</xref>). In contrast, the <italic>synthetic long reads (SLRs)</italic> technologies [recently developed by Illumina, 10X Genomics, Loop Genomics, and Universal Sequencing Technology (UST)] combine the accuracy and low cost of short reads with the long range information, making them an attractive alternative to error-prone long reads (<xref rid="btz349-B20" ref-type="bibr">Marks <italic>et al.</italic>, 2018</xref>; <xref rid="btz349-B33" ref-type="bibr">Voskoboynik <italic>et al.</italic>, 2013</xref>; <xref rid="btz349-B36" ref-type="bibr">Zheng <italic>et al.</italic>, 2016</xref>).</p>
    <p>Various SLR technologies follow similar protocols (<xref ref-type="fig" rid="btz349-F1">Fig. 1</xref>):
<list list-type="bullet"><list-item><p>DNA is sheared into long genomic <italic>fragments</italic>.</p></list-item><list-item><p>Fragments are distributed across multiple <italic>containers</italic>, each container characterized by a unique <italic>barcode</italic>. A container may contain multiple fragments with the same barcode.</p></list-item><list-item><p>Fragments in each container are amplified and broken further into shorter <italic>subfragments</italic> marked with the barcode of the container it came from.</p></list-item><list-item><p>All subfragments are pooled together and sequenced as short paired-end reads which can be assigned to their original containers using barcodes.</p></list-item></list><fig id="btz349-F1" orientation="portrait" position="float"><label>Fig. 1.</label><caption><p>An overview of SLR technologies. A genome (metagenome) is sheared into long fragments that are placed into multiple containers. Fragments in each container are amplified, broken into short subfragments, barcoded and sequenced. Resulting reads are assigned to their original containers using barcodes</p></caption><graphic xlink:href="btz349f1"/></fig></p>
    <p>As the result, each long fragment is represented as a <italic>read cloud</italic>: a set of barcoded paired-end reads that originated from a given fragment (<xref rid="btz349-B19" ref-type="bibr">Kuleshov <italic>et al.</italic>, 2016</xref>).</p>
    <p><bold>TSLR and SSLR.</bold> The <italic>TruSeq SLR (TSLR)</italic> technology generates 384 containers with 150–300 fragments with length <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula>kb and sequences them with high coverage (<xref rid="btz349-B4" ref-type="bibr">Bankevich and Pevzner, 2016</xref>; <xref rid="btz349-B33" ref-type="bibr">Voskoboynik <italic>et al.</italic>, 2013</xref>). These parameters enable <italic>barcode assembly</italic> of all reads with the same barcode that aims to reconstruct all fragments marked by this barcode.</p>
    <p>Although TSLRs revealed rare species in metagenomes (<xref rid="btz349-B4" ref-type="bibr">Bankevich and Pevzner, 2016</xref>, <xref rid="btz349-B5" ref-type="bibr">2018</xref>; <xref rid="btz349-B32" ref-type="bibr">Sharon <italic>et al.</italic>, 2015</xref>), their applications are limited by a rather high cost.</p>
    <p>The <italic>Sparse SLR (SSLR)</italic> technologies (such as developed by 10x Genomics and UST) represent a lower cost alternative to the TSLR technology (<xref rid="btz349-B20" ref-type="bibr">Marks <italic>et al.</italic>, 2018</xref>; <xref rid="btz349-B36" ref-type="bibr">Zheng <italic>et al.</italic>, 2016</xref>) that results in a low coverage of fragments by short reads and does not enable barcode assembly. Instead, it generates longer fragments (typically 10–70 kb) distributed over many containers (up to 4 million).</p>
    <p>In difference from truSPAdes (<xref rid="btz349-B4" ref-type="bibr">Bankevich and Pevzner, 2016</xref>) aimed at high-cost TSLRs, cloudSPAdes was developed for the lower-cost SSLRs.</p>
    <p>The mean fragment length defines a typical repeat length an SSLR technology can resolve. However, the low coverage of fragments by short reads may result in difficulties in repeat resolution, even in the case of long fragments. Thus, each SSLR assembly algorithm should be adapted to the parameters of a specific SSLR technology and even to the parameters of a specific dataset (even generated by the same technology!) since various datasets often have different characteristics.</p>
    <p>Although the 10X Genomics Chromium Controller is now the most popular instrument for generating SSLRs, various groups are now developing new barcoding protocols with the goal to reduce the cost of SSLRs and even substitute a rather expensive Chromium Controller by a simpler kit-based barcoding protocol, thus reducing the cost by an order of magnitude. For example, UST recently introduced <italic>Transposase Enzyme Linked Long-read Sequencing</italic> (<italic>TELL-seq<sup>TM</sup></italic>) that enables faster and more cost-effective way to generate SSLRs in a single-tube reaction without a need for an expensive protocol-specific instrument. TELL-Seq promises to advance short-read sequencing by replacing mate-pairs in generating low-cost high-quality short-read assemblies.</p>
    <p>TELL-seq takes advantage of a unique property of Mu transposition reaction, which creates a very stable intermediate product (i.e. strand transfer complex) when Mu transposomes attack a DNA target (<xref rid="btz349-B31" ref-type="bibr">Savilahti <italic>et al.</italic>, 1995</xref>), and barcodes the DNA target before it breaks. TELL-Seq produces SSLR sequencing libraries for a variety of genome sizes ranging from bacterium to human with 1 to 10 ng genomic DNA input in approximately 3 h. In difference from the Chromium Controller, it does not require emulsion compartments and results in a scalable and automation-friendly workflow.</p>
    <p>Since various barcoding protocols often have different parameters, there is a need to test how these parameters affect the quality of genome assembly. However, our benchmarking revealed that existing SSLR assemblers are optimized for a narrow range of parameters and their performance may greatly deteriorate when these parameters change. With respect to various applications, we demonstrate that the state-of-the-art metagenomics SSLR assemblers, that work well on some dataset, may perform poorly on other datasets with different coverage of fragments by short reads, different distributions of species abundances, etc. For example, even for the same SSLR technology, there exist a need to adjust parameters due to varying sample characteristics, e.g. DNA can be more fragmented in one sample versus another, resulting in shorter fragments. This raises a problem of developing a <italic>universal</italic> SSLR assembler that learns parameters from the data and works well across a wide range of parameters.</p>
    <p><bold>SLR assemblers.</bold> The existing SLR assemblers can be classified into three categories:
<list list-type="bullet"><list-item><p>The <italic>barcode assembly</italic> approach reconstructs SLRs by assembling short reads from a single barcode as in the TSLR technology (<xref rid="btz349-B4" ref-type="bibr">Bankevich and Pevzner, 2016</xref>) or several barcodes as in the SSLR technology (<xref rid="btz349-B9" ref-type="bibr">Bishara <italic>et al.</italic>, 2018</xref>), and further reconstructs the genome from the resulting SLRs.</p></list-item><list-item><p>The <italic>scaffolding</italic> approach aligns the barcoded reads to contigs and uses them for scaffolding (<xref rid="btz349-B1" ref-type="bibr">Adey <italic>et al.</italic>, 2014</xref>; <xref rid="btz349-B19" ref-type="bibr">Kuleshov <italic>et al.</italic>, 2016</xref>; <xref rid="btz349-B35" ref-type="bibr">Yeo <italic>et al.</italic>, 2018</xref>).</p></list-item><list-item><p>The <italic>de Bruijn graph</italic> approach constructs the assembly graph of all barcoded reads and uses it for the follow-up SLR assembly (<xref rid="btz349-B34" ref-type="bibr">Weisenfeld <italic>et al.</italic>, 2017</xref>).</p></list-item></list></p>
    <p>With exception of Supernova (<xref rid="btz349-B34" ref-type="bibr">Weisenfeld <italic>et al.</italic>, 2017</xref>), the existing SSLR assemblers [Architect (<xref rid="btz349-B19" ref-type="bibr">Kuleshov <italic>et al.</italic>, 2016</xref>), ARCS (<xref rid="btz349-B35" ref-type="bibr">Yeo <italic>et al.</italic>, 2018</xref>) and Athena (<xref rid="btz349-B9" ref-type="bibr">Bishara <italic>et al.</italic>, 2018</xref>)] use SPAdes assembler (<xref rid="btz349-B6" ref-type="bibr">Bankevich <italic>et al.</italic>, 2012</xref>) for an initial assembly (without using barcoding information) and further improve it by utilizing the barcoding information. However, they only use SPAdes <italic>contigs</italic> and do not take advantage of the SPAdes <italic>assembly graph</italic> that provides important information for analyzing barcodes. cloudSPAdes addresses this limitation by analyzing the assembly graph and represents the first application of assembly graphs for metagenomic SSLR assembly [assembly graphs were previously used only for genomic SSLR assembly (<xref rid="btz349-B34" ref-type="bibr">Weisenfeld <italic>et al.</italic>, 2017</xref>)].</p>
    <p><bold>The Shortest Cloud Superstring Problem.</bold> A string is called a <italic>superstring</italic> of a collection of strings if it contains each string from this collection as a substring. The genome assembly problem is related to the <italic>Shortest Superstring Problem</italic>, finding a shortest superstring for a collection of strings. In difference from the classical genome assembly problem, the algorithmic problems motivated by the SSLR assembly have not been explored yet. Below we describe an analog of the Shortest Superstring Problem (for a set of clouds rather than strings) motivated by the SLR assembly.</p>
    <p>The <italic>composition</italic> of a string <italic>S</italic> [denoted as <italic>composition</italic>(<italic>S</italic>)] is defined as the set of all characters in <italic>S</italic>. A set of characters <italic>c</italic> is a <italic>cloud</italic> of a string <italic>S</italic> if there exists a substring <italic>s</italic> of <italic>S</italic> with composition equal to <italic>c</italic>. We say that a string <italic>S conforms</italic> with a collection of sets <italic>C</italic> (referred to as a <italic>cloud-set</italic>) if each set in <italic>C</italic> is a cloud of <italic>S</italic>. Given a cloud-set <italic>C</italic>, the <italic>Shortest Cloud Superstring (SCS) Problem</italic> is to find a shortest string that conforms with <italic>C</italic>. Note the difference between the Shortest Superstring (the set of strings is known) and the SCS Problems (the set of strings is unknown but their compositions are known), reflecting the difference between the classical genome assembly and the SLR assembly.</p>
    <p>Below we explain how the SCS Problem relates to the SLR assembly, describe an algorithm for solving this problem, generalize this problem for assembly graphs and use it to develop the cloudSPAdes tool for both genomics and metagenomic SSLR assembly.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p><bold>De Bruijn graph.</bold> In the genomic mode, cloudSPAdes uses a genomic assembler SPAdes (<xref rid="btz349-B6" ref-type="bibr">Bankevich <italic>et al.</italic>, 2012</xref>) to construct the assembly graph from reads. Given a set of reads <italic>Reads</italic> and a <italic>k</italic>-mer size (or a range of <italic>k</italic>-mer sizes in the iterative mode), SPAdes constructs the <italic>de Bruijn graph</italic> of reads and transforms it into the <italic>assembly graph</italic><inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:mi mathvariant="italic">DB</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="italic">DB</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Reads</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> after performing various <italic>graph simplification</italic> procedures (<xref ref-type="fig" rid="btz349-F2">Fig. 2</xref>). In the metagenomic mode, cloudSPAdes uses a metagenomic assembler metaSPAdes (<xref rid="btz349-B25" ref-type="bibr">Nurk <italic>et al.</italic>, 2017</xref>) to construct the assembly graph from reads with non-uniform coverage.
</p>
    <fig id="btz349-F2" orientation="portrait" position="float">
      <label>Fig. 2.</label>
      <caption>
        <p>Outline of the cloudSPAdes algorithm. (First layer) Linear representation of a circular genome <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:mi>a</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>b</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> with five long edges <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> and <italic>e</italic>. Numbers under the edges denote the lengths of the segments. (Second layer left) Assembly graph <italic>DB</italic> of the genome. (Second layer right) Contracted assembly graph <italic>CDB</italic>. The contraction of an edge (<italic>v</italic>, <italic>w</italic>) is the gluing of the endpoints of this edge into a single vertex <italic>u</italic>, followed by the removal of the loop-edge resulting from this gluing (all edges incident to <italic>v</italic> or <italic>w</italic> in the assembly graph are incident to <italic>u</italic> in the contracted assembly graph). (Third layer left) The containment metric for the contracted de Bruijn graph <italic>CDB</italic>. (Third layer middle) The transition-set <italic>T</italic> in the contracted assembly graph with the containment index exceeding 0.7 and the <italic>T</italic>-compatible cloud-set <italic>C</italic>. The transition-set <italic>T</italic> includes all correct genomic transitions (<italic>ab</italic>, <italic>bc</italic>, <italic>cd</italic>, <italic>de</italic>, <italic>ea</italic>) and three false transitions (<italic>ba</italic>, <italic>cb</italic>, <italic>ae</italic>). (Third layer right) The <italic>T</italic>-compatible clouded Eulerian cycle for the contracted assembly graph <italic>CDB</italic>, the transition-set <italic>T</italic> and the cloud-set <italic>C</italic>. (Fourth layer) The short-edge subgraph of the assembly graph <italic>DB</italic> between two consecutive long edges <italic>a</italic> and <italic>b</italic> in the genomic cycle. There are two possible ways to fill the gap between <italic>a</italic> and <italic>b</italic>, the correct one (shown on top and reconstructed by cloudSPAdes) and the incorrect one (shown at the bottom)</p>
      </caption>
      <graphic xlink:href="btz349f2"/>
    </fig>
    <p>Each edge in the assembly graph is labeled by a nucleotide string and the <italic>length</italic> of an edge is defined as the number of nucleotides in this string.</p>
    <p>For simplicity, below we assume that all chromosomes are circular. Each chromosome traverses a cycle in the assembly graph that we refer to as a <italic>genomic cycle</italic> (a genomic cycle may be broken into multiple paths if there exist drops in coverage that fragment the assembly graph). The <italic>multiplicity</italic> of an edge in the assembly graph is defined as the total number of times it is traversed by all genomic cycles in the assembly graph. An edge is classified as <italic>unique</italic> if its multiplicity is 1 and as <italic>repeat</italic>, otherwise. Although this classification is not known in the <italic>de novo</italic> setting, SPAdes infers the tentative sets of unique and repeat edges.</p>
    <p><bold>Clouds in the assembly graph.</bold> We refer to a subpath of the genomic cycle traversed by a fragment <italic>F</italic> in the assembly graph <italic>DB</italic> as <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>) and to the set of edges in this subpath as the <italic>cloud in the assembly graph</italic> of the fragment <italic>F</italic>, referred to as <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>). We say that a barcode <italic>marks</italic> an edge of the assembly graph if one of the reads aligned to this edge has this barcode. We refer to a barcode marking the fragment <italic>F</italic> as <italic>barcode</italic>(<italic>F</italic>).</p>
    <p>In the ideal case, when <italic>barcode</italic>(<italic>F</italic>) marks all edges in <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>) (and does not mark other edges), the SSLR technology provides information about <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>) [all edges marked by <italic>barcode</italic>(<italic>F</italic>)] but does not reveal <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>). In practice, if edges of <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>) form a connected subgraph in the assembly graph, one might attempt to reconstruct <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>) from <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>) as a path traversing all edges in this subgraph. If we succeed in reconstructing <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>), we can transform it into a string over the <italic>edge alphabet</italic> (the set of all edges in the assembly graph). If all fragments were transformed into such strings, the SSLR assembly problem would be reduced to genome assembly from a set of such strings.</p>
    <p>In reality, <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>) may be self-overlapping (in the case when it contains repeat edges), making it difficult to figure out how it traverses edges in <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>). Below we show how to use clouds for reconstructing the genomic cycle even in the case when paths traversed by some fragments are unknown.</p>
    <p>Since each cloud in the assembly graph is a composition of a subpath of a genomic cycle, the SSLR assembly corresponds to solving the SCS Problem for the set of all clouds in the assembly graph. However, although the SCS Problem is a useful abstraction, it does not adequately model the cloud assembly (similarly to the Shortest Superstring Problem that does not adequately model the read assembly).</p>
    <p>Below we introduce a more adequate model for the SSLR assembly [Clouded Eulerian Path (CEP) problem] and describe a practical SSLR assembly algorithm.</p>
    <p><bold>The challenge of reconstructing clouds in the assembly graph.</bold> Given the set of all edges marked by <italic>barcode</italic> [referred to as <italic>edges</italic>(<italic>DB</italic>, <italic>barcode</italic>)], we consider the problem of reconstructing <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>) for all fragments <italic>F</italic> marked by <italic>barcode</italic>.</p>
    <p>One way to address this problem is to select each connected subgraph formed by <italic>edges</italic>(<italic>DB</italic>, <italic>barcode</italic>) as an approximation of <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>) for some fragment <italic>F</italic>. However, short edges in <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>) are often not marked by <italic>barcode</italic>(<italic>F</italic>) (since the coverage of fragments by reads is low), making it difficult to reconstruct <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>). In this case, <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>) does not form a connected subgraph in the assembly graph and is broken into multiple connected subgraphs (<xref ref-type="fig" rid="btz349-F3">Fig. 3a</xref>).
</p>
    <fig id="btz349-F3" orientation="portrait" position="float">
      <label>Fig. 3.</label>
      <caption>
        <p>Reconstructing clouds in the assembly graph. A fragment of assembly graph with edges marked by blue, red and green barcodes. Long edges are shown as solid and short edges are shown dashed. (<bold>a</bold>) A cloud formed by the blue barcode is broken into two subgraphs. (<bold>b</bold>) Two fragments that share the red barcode also share a short edge, resulting in a multicloud subgraph. (<bold>c</bold>) A short edge in the fragment-path that is not marked by the green barcode results in a connected component (marked by the green barcode) that cannot be traversed by a single path</p>
      </caption>
      <graphic xlink:href="btz349f3"/>
    </fig>
    <p>Additionally, each <italic>barcode</italic> usually marks multiple fragments that may correspond to paths sharing some edges. Thus, a connected subgraph formed by <italic>edges</italic>(<italic>DB</italic>, <italic>barcode</italic>) may correspond to several fragments rather than to a single fragment (<xref ref-type="fig" rid="btz349-F3">Fig. 3b</xref>). We refer to such subgraphs of the assembly graph as <italic>multicloud</italic> subgraphs as opposed to <italic>unicloud</italic> subgraphs that represent a single cloud in the assembly graph.</p>
    <p>Since multicloud subgraphs are difficult to analyze, one can consider only subgraphs that form a path [such a path likely corresponds to <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>)] that traverses each edge in a subgraph at least once. However, limiting analysis to paths may filter out some unicloud subgraphs, since some edges unmarked by <italic>barcode</italic>(<italic>F</italic>) will be missing from <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>) (<xref ref-type="fig" rid="btz349-F3">Fig. 3c</xref>).</p>
    <p><bold>Focusing on long edges of the assembly graph.</bold> To address the complications illustrated in <xref ref-type="fig" rid="btz349-F2">Figure 2</xref>, instead of considering all edges of the assembly graph, we focus on <italic>long</italic> edges (longer than a <italic>length threshold LT</italic>) and ignore <italic>short</italic> edges. We refer to a cloud with at least two long edges as a <italic>multi-edge</italic> cloud and define the <italic>complexity</italic> of a cloud-set as the mean number of long edges in a multi-edge cloud. On the one hand, setting up a small length threshold results in difficult-to-analyze cloud-sets with high complexity. On the other hand, setting up a large length threshold results in easy-to-analyze cloud-sets with small complexity but makes it difficult to fill the gaps between consecutive long edges (formed by short edges) in the genomic path.</p>
    <p>Our benchmarking revealed that selecting the length threshold in such a way that the resulting clouds are relatively small (the complexity of the resulting cloud-set is <inline-formula id="IE5"><mml:math id="IM5"><mml:mo>≈</mml:mo></mml:math></inline-formula>3) represents a good trade-off. <xref ref-type="fig" rid="btz349-F4">Figure 4</xref> illustrates how the number of long edges and the complexity of a cloud-set [denoted <italic>complexity</italic>(<italic>LT</italic>)] reduce with the increase in the length threshold <italic>LT</italic>. We define the parameter <italic>LT</italic> as the maximum value <italic>L</italic> of the length threshold with <italic>complexity</italic>(<italic>L</italic>) above 3. 
</p>
    <fig id="btz349-F4" orientation="portrait" position="float">
      <label>Fig. 4.</label>
      <caption>
        <p>Number of long edges in the assembly graph (left), complexity (middle) and the mean weight of a vertex in the contracted assembly graph (right) depending on the edge length threshold (for the YEAST dataset described in Section 3). Long edges are defined as edges longer than 11 kb (the mean number of long edges in a multi-edge cloud is 3 for the edge length threshold 11 kb)</p>
      </caption>
      <graphic xlink:href="btz349f4"/>
    </fig>
    <p>cloudSPAdes first attempts to infer the order of long edges and afterwards attempts to fill the gaps between long edges by progressively shorter and shorter edges.</p>
    <p>For simplicity, below we define this iterative process by defining only two tiers of edges lengths: long (longer than <italic>LT</italic>) and short (all remaining edges). In the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>, we will illustrate this iterative process in more details by defining three tiers of edge lengths: ultralong (longer than <italic>LT</italic><sup>+</sup>), long (longer than a threshold <italic>LT</italic> but shorter or equal than <italic>LT</italic><sup>+</sup>) and short (all remaining edges).</p>
    <p><bold>Contracted assembly graph.</bold> Short edges in <italic>Path</italic>(<italic>F</italic>) are less likely to be marked by <italic>barcode</italic>(<italic>F</italic>) than long edges. Thus, instead of reconstructing the order of all edges in <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>), we focus on a simpler problem of reconstructing the order of long edges in <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>) for every fragment <italic>F</italic>.</p>
    <p>To focus on long edges in the assembly graph <italic>DB</italic>, we <italic>contract</italic> all short edges in this graph (<xref ref-type="fig" rid="btz349-F2">Figure 2</xref>). Note that the resulting assembly graph may contain <italic>non-branching vertices</italic> (vertices with a single incoming and a single outgoing edge). The <italic>contracted assembly graph DB<sub>LT</sub></italic> is obtained from this graph by transforming each non-branching path into a single edge. For the YEAST dataset (<inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:mi mathvariant="italic">LT</mml:mi><mml:mo>≈</mml:mo><mml:mn>11</mml:mn></mml:mrow></mml:math></inline-formula> kb), the contracted assembly graph <italic>DB<sub>LT</sub></italic> has 154 vertices and 525 edges (13 of them are loops). We define the <italic>weight of a vertex</italic> in the contracted assembly graph as the total length of all edges that were contracted into this vertex (<xref ref-type="fig" rid="btz349-F4">Fig. 4</xref>).</p>
    <p>Below we describe variations of the SCS Problem aimed at analyzing the contracted assembly graph [Cloud Permutation (CP) Problem and CEP Problem]. The latter employs the concept of <italic>transitions</italic> between the edges of the contracted assembly graph that we use for reconstructing the set of long edges for every cloud in the assembly graph. A <italic>transition-set</italic> in a graph <italic>G</italic> is an arbitrary set of pairs of incident edges (<italic>v</italic>, <italic>w</italic>) and (<italic>w</italic>, <italic>u</italic>) in this graph [a loop (<italic>v</italic>, <italic>v</italic>) may form a transition with any edge that has <italic>v</italic> as one of its endpoints]. We distinguish between <italic>correct</italic> transitions (pairs of consecutive edges in a genomic path) and <italic>false</italic> transitions (all other pairs of edges).</p>
    <p><bold>The CP Problem and the CEP Problem.</bold> Our goal is to solve the SCS Problem for clouds encoded in the alphabet of long edges in the contracted assembly graph. Since long edges are mostly unique, this task corresponds to a simpler <italic>CP Problem</italic>: find a permutation (a string without repeated symbols) that conforms with a cloud-set <italic>C</italic>. We omitted the word ‘shortest’ in this formulation, since all permutations have the same length [each of them contains all characters from <italic>C</italic> that we denote as <italic>char</italic>(<italic>C</italic>)].</p>
    <p>Twenty years ago, various <italic>DNA physical mapping</italic> studies (<xref rid="btz349-B28" ref-type="bibr">Pevzner, 2000</xref>; <xref rid="btz349-B30" ref-type="bibr">Rajaraman <italic>et al.</italic>, 2017</xref>) analyzed algorithmic problems similar to the CP Problem (<xref rid="btz349-B2" ref-type="bibr">Alizadeh <italic>et al.</italic>, 1995</xref>; <xref rid="btz349-B7" ref-type="bibr">Batzoglou and Istrail, 1999</xref>; <xref rid="btz349-B21" ref-type="bibr">Mayraz and Shamir, 1999</xref>). However, we are not aware of a software tool that resulted from these studies and would be applicable to SSLRs. Below we describe the CEP Problem that is relevant to analyzing clouds on edges of an assembly graph.</p>
    <p>We refer to a cloud-set where each cloud is a subset of edges in a graph <italic>G</italic> as a cloud-set in <italic>G</italic>. Given a transition-set <italic>T</italic> in a graph <italic>G</italic>, we say that a path <italic>P</italic> in <italic>G</italic> is <italic>T-compatible</italic>, if every pair of consecutive edges in this path forms a transition in <italic>T</italic>. Given a transition-set <italic>T</italic> in a graph <italic>G</italic>, and a cloud-set <italic>C</italic> in <italic>G</italic>, a Clouded Eulerian Path is a <italic>T</italic>-compatible Eulerian path in <italic>G</italic> that forms a permutation of its edges conforming with the cloud-set <italic>C</italic>. The <italic>CEP Problem</italic> is to find a CEP for <italic>G</italic>, <italic>T</italic> and <italic>C</italic>. Note that solving the Clouded Permutation Problem on <italic>C</italic> is equivalent to solving the CEP problem in the case when a graph <italic>G</italic> contains a single vertex, all its edges represent loops, and every pair of edges in <italic>G</italic> forms a transition. In the case of an empty cloud-set <italic>C</italic>, solving the CEP problem corresponds to finding a <italic>T</italic>-compatible Eulerian path in <italic>G</italic> (<xref rid="btz349-B11" ref-type="bibr">Fleischner, 1990</xref>).</p>
    <p><bold>Clouds in the contracted assembly graph.</bold> Each cloud <italic>cloud</italic>(<italic>DB</italic>, <italic>F</italic>) in the assembly graph corresponds to a cloud <italic>cloud</italic>(<italic>CDB</italic>, <italic>F</italic>) in the contracted assembly graph. Let <italic>clouds</italic>(<italic>CDB</italic>, <italic>barcode</italic>) be the set of clouds in the contracted assembly graph of all fragments marked by <italic>barcode</italic>. Since the contracted assembly graph does not have short edges [that are often not marked by <italic>barcode</italic>(<italic>F</italic>)], clouds in this graph are more likely to represent connected subgraphs than clouds in the assembly graph. Thus, reconstructing <italic>clouds</italic>(<italic>CDB</italic>, <italic>barcode</italic>) from only long edges marked by <italic>barcode</italic> is easier than reconstructing <italic>clouds</italic>(<italic>DB</italic>, <italic>barcode</italic>) from all edges in the assembly graph marked by <italic>barcode</italic>.</p>
    <p>Each barcode marks a set of edges <italic>edges</italic>(<italic>CDB</italic>, <italic>barcode</italic>) in the contracted assembly graph. We consider the <italic>induced subgraph</italic> formed by these edges and analyze its connected components. Given a transition-set <italic>T</italic>, we classify a connected component as <italic>simple</italic> if it contains a <italic>T</italic>-compatible Eulerian path (non-simple components likely result from barcode collisions) and report simple components as <italic>putative clouds</italic>. We refer to the set of putative clouds constructed using the contracted assembly graph <italic>CDB</italic>, a transition-set <italic>T</italic> and barcoded reads <italic>Reads</italic> as <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:mi mathvariant="italic">Clouds</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">CDB</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Reads</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (each cloud in this set represents a set of edges in the contracted assembly graph).</p>
    <p>Let <italic>Genome</italic> be a genome string and <italic>Cycle</italic>(<italic>Genome</italic>, <italic>DB</italic>) be a genomic cycle traversed by <italic>Genome</italic> in the assembly graph <italic>DB</italic>. This cycle got contracted into a genomic cycle <italic>Cycle</italic>(<italic>Genome</italic>, <italic>CDB</italic>) in the contracted assembly graph <italic>CDB</italic> that we aim to reconstruct. Given a contracted assembly graph <italic>CDB</italic>, we attempt to solve the cloud superstring problem for the cloud-set <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:mi mathvariant="italic">Clouds</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">CDB</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Reads</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to reconstruct <italic>Cycle</italic>(<italic>Genome</italic>, <italic>CDB</italic>).</p>
    <p><bold>Brief outline of the cloudSPAdes algorithm.</bold> Below we use a simple simulated dataset to illustrate the main steps of the algorithm and delegate the details to the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>. <xref ref-type="fig" rid="btz349-F2">Figure 2</xref> describes a simulated genome and a simulated SSLR dataset with 50 000 fragments (with mean fragment length 20 kb and mean coverage 0.1×) distributed among 2000 containers.</p>
    <p>cloudSPAdes first derives the parameter <italic>LT</italic> by analyzing the dataset and uses it to transform the assembly graph <italic>DB</italic> into the contracted assembly graph <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:mi mathvariant="italic">CDB</mml:mi><mml:mo>=</mml:mo><mml:mi>D</mml:mi><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">LT</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. It further defines the initial transition-set that includes five correct (<italic>ab</italic>, <italic>bc</italic>, <italic>cd</italic>, <italic>de</italic>, <italic>ea</italic>) and seven false (<italic>ad</italic>, <italic>ae</italic>, <italic>ba</italic>, <italic>cb</italic>, <italic>ce</italic>, <italic>db</italic>, <italic>ec</italic>) transitions. cloudSPAdes attempts to remove false transitions by evaluating various metrics described in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>. <xref ref-type="fig" rid="btz349-F2">Figure 2</xref> illustrates only one of these metrics that we describe below.</p>
    <p>We refer to the set of barcodes marking an edge <italic>e</italic> in a graph as <italic>barcode-set</italic> of an edge and denote this set as <italic>b</italic>(<italic>e</italic>). Given edges <italic>e</italic><sub>1</sub> and <italic>e</italic><sub>2</sub>, we refer to the set of barcodes marking both <italic>e</italic><sub>1</sub> and <italic>e</italic><sub>2</sub> as <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:mi>b</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We score the similarity between barcode-sets of two edges using the <italic>containment index CI</italic> (<xref rid="btz349-B16" ref-type="bibr">Koslicki and Zabeti, 2017</xref>)
<disp-formula id="E1"><mml:math id="M1"><mml:mrow><mml:mtext>CI</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
    <p>We say that long edges <italic>e</italic><sub>1</sub> and <italic>e</italic><sub>2</sub> have <italic>similar barcode-sets</italic> if <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:mtext>CI</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> exceeds a threshold CI<sub>long</sub> (the approach for setting this threshold is described in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>).</p>
    <p><xref ref-type="fig" rid="btz349-F2">Figure 2</xref> shows the containment metric for the simulated dataset (entries exceeding the threshold CI<sub>long</sub> are shown in dark blue). After applying this threshold, we are left with a transition-set <italic>T</italic> consisting of all correct transitions (<italic>ab</italic>, <italic>bc</italic>, <italic>cd</italic>, <italic>de</italic>, <italic>ea</italic>) and three false transitions (<italic>ba</italic>, <italic>cb</italic>, <italic>ae</italic>). After deriving the transition-set <italic>T</italic>, cloudSPAdes constructs a cloud-set <inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Clouds</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">CDB</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">Reads</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in the contracted assembly graph consisting of only five clouds {<italic>ab</italic>}, {<italic>bc</italic>}, {<italic>abe</italic>}, {<italic>bcd</italic>}, {<italic>cde</italic>}. Afterwards, cloudSPAdes attempts to find out how the genomic cycle traverses the contracted assembly graph by solving the CEP problem (there exists only one <italic>T</italic>-compatible Eulerian cycle for this cloud-set).</p>
    <p>After finding a genomic cycle in the contracted assembly graph <italic>CDB</italic>, cloudSPAdes turns the attention to the assembly graph <italic>DB</italic>, fills the gap between each pair of consecutive long edges in this cycle and constructs a genomic cycle in the assembly graph. In the simulated example, it is not clear whether this cycle is traversed as <inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:mi>a</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>b</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> or as <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:mi>a</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>b</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mi>c</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. cloudSPAdes selects one of these possibilities by iteratively reducing the parameter <italic>LT</italic> to fill the gaps between long edges in the assembly graph using additional metrics described in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>.</p>
    <p><bold>Combinatorics of crossing clouds.</bold> cloudSPAdes is motivated by a combinatorial analysis of cloud-sets that we describe in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>. For simplicity, the theoretical results below and in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref> refer to the case of reconstructing a single linear genome. However, in the case of a metagenome, cloudSPAdes uses these results to assemble multiple circular genomes in a metagenome. For a self-contained description of all results, below we define a condition on a cloud-set that guarantees that the CP Problem has a unique solution.</p>
    <p>We say that sets <italic>c</italic><sub>1</sub> and <italic>c</italic><sub>2</sub><italic>cross</italic> (<inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>⌢</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>) iff <inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:menclose notation="updiagonalstrike"><mml:mo>⊆</mml:mo></mml:menclose><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:menclose notation="updiagonalstrike"><mml:mo>⊆</mml:mo></mml:menclose><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>≠</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>. A cloud-set <italic>C crosses</italic> a subset of <italic>char</italic>(<italic>C</italic>) if it contains a cloud crossing this subset. A set of clouds <italic>C</italic> is <italic>complete</italic> if it crosses each non-trivial subset of <italic>char</italic>(<italic>C</italic>).</p>
    <p>Theorem. Let <italic>G</italic> be a permutation that conforms with a cloud-set <italic>C</italic>. Then <italic>G</italic> is unique iff <italic>C</italic> is complete.</p>
    <p><bold>Organization of <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>.</bold> Section 1 introduces various procedures aimed at eliminating <italic>false transitions</italic>. Sections 2–7 describe the transition elimination procedures in more details. Section 8 describes how to partition the contracted assembly graph into smaller subgraphs and to solve a separate CP Problem in each of them. Section 9 describes how cloudSPAdes utilizes read-pairs in the SSLR libraries.</p>
    <p>Long edges in <italic>path</italic>(<italic>DB</italic>, <italic>F</italic>) form a path <italic>path</italic>(<italic>CDB</italic>, <italic>F</italic>) in the contracted assembly graph that we aim to reconstruct and to further use the reconstructed paths for figuring out how the genomic cycle traverses the contracted assembly graph. Since <italic>path</italic>(<italic>CDB</italic>, <italic>F</italic>) does not provide information about short edges within genomic cycle, Supplementary Section 10 describes how to fill in the gaps between long edges in this path (formed by paths consisting of short edges), thus reconstructing the entire genomic cycles.</p>
    <p>The proof of the Theorem is given in Supplementary Section 11. Supplementary Sections 12 and 13 describe how cloudSPAdes combines information provided by a cloud-set and a transition-set in the contracted assembly graph. Supplementary Section 14 outlines the steps of the cloudSPAdes algorithms in more details.</p>
  </sec>
  <sec>
    <title>3 Results</title>
    <p><bold>SLR assemblers.</bold> We benchmarked cloudSPAdes and the state-of-the-art SSLR assemblers Architect (<xref rid="btz349-B19" ref-type="bibr">Kuleshov <italic>et al.</italic>, 2016</xref>), ARCS (<xref rid="btz349-B35" ref-type="bibr">Yeo <italic>et al.</italic>, 2018</xref>), Athena (<xref rid="btz349-B9" ref-type="bibr">Bishara <italic>et al.</italic>, 2018</xref>) and Supernova (<xref rid="btz349-B34" ref-type="bibr">Weisenfeld <italic>et al.</italic>, 2017</xref>) using QUAST (<xref rid="btz349-B14" ref-type="bibr">Gurevich <italic>et al.</italic>, 2013</xref>) and metaQUAST (<xref rid="btz349-B23" ref-type="bibr">Mikheenko <italic>et al.</italic>, 2016</xref>). Architect, ARCS, Athena and Supernova are aimed at various settings and/or various variants of the SLR technologies: Architect is best suited for TSLR assemblies, ARCS and Supernova were developed for human SSLR assemblies and Athena was developed for metagenomics SSLR assemblies.</p>
    <p><bold>Datasets.</bold> We benchmarked all SLR assemblers on three genomic SSLR dataset generated by TELL-seq technology and three metagenomic SSLR datasets generated by 10X Genomics technology (see Supplementary Section 15 for detailed information about these datasets and the reference genomes). Although the metagenomics datasets were generated using the same, they have widely different characteristics with respect to fragment coverage by short reads and abundances of various species, thus allowing us to analyze how stable each assembly tool is with respect to these variations. The genomic datasets were analyzed with the goal to evaluate whether the state-of-the-art SSLR tools can be applied to emerging technologies with parameters that differ from the parameters of the 10X Genomics technology.</p>
    <p><italic>YEAST</italic>, <italic>STAPH</italic> and <italic>ECOLI</italic> datasets contain reads from the genomic DNA of <italic>Saccharomyces cerevisiae</italic>, <italic>Staphylococcus aureus</italic> and <italic>Escherichia coli</italic> DH10B strain, respectively.</p>
    <p><italic>MOCK5 dataset</italic> is a synthetic community dataset containing reads from the genomic DNA mixture of five bacterial species, four of them have genomes that are similar to known genomes (<xref rid="btz349-B10" ref-type="bibr">Danko <italic>et al.</italic>, 2019</xref>).</p>
    <p><italic>MOCK20 dataset</italic> is a synthetic community dataset containing reads from the genomic DNA mixture of 20 bacterial strains, 19 of them have genomes that are similar to known genomes (<xref rid="btz349-B9" ref-type="bibr">Bishara <italic>et al.</italic>, 2018</xref>).</p>
    <p><italic>GUT dataset</italic> is a large metagenomic dataset from the gut of a male adult (<xref rid="btz349-B9" ref-type="bibr">Bishara <italic>et al.</italic>, 2018</xref>).</p>
    <p>The lengths of fragments generated by the SSLR technology are defined by the lengths of DNA fragments extracted from the sample.</p>
    <p>Since extracting high molecular weight DNA from a metagenomic sample is challenging (<xref rid="btz349-B3" ref-type="bibr">Bag <italic>et al.</italic>, 2016</xref>; <xref rid="btz349-B17" ref-type="bibr">Kuhn <italic>et al.</italic>, 2017</xref>), the average SSLR fragment length often drops from 30–70 kb in an isolate to 5–10 kb in a metagenome. Supplementary Section 16 presents statistics for various SSLR metagenomic datasets.</p>
    <p><bold>Benchmarking SLR assemblers.</bold><xref rid="btz349-T1" ref-type="table">Table 1</xref> summarizes the assembly statistics for metagenomic datasets. <xref rid="btz349-T2" ref-type="table">Table 2</xref> summarizes the assembly statistics for prokaryotic datasets. <xref ref-type="fig" rid="btz349-F5">Figure 5</xref> presents the NAx plots for the YEAST, STAPH, ECOLI, MOCK5 and MOCK20 datasets and the NGx plot for the GUT dataset. <xref ref-type="fig" rid="btz349-F6">Figure 6</xref> provides information about the NGA50 statistics and the number of misassemblies for each reference genome for the MOCK5, MOCK20 and GUT datasets.</p>
    <table-wrap id="btz349-T1" orientation="portrait" position="float">
      <label>Table 1.</label>
      <caption>
        <p>Assembly statistics for the MOCK5, MOCK20 and GUT datasets</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">Assembler</th>
            <th rowspan="1" colspan="1">metaSPAdes</th>
            <th rowspan="1" colspan="1">Athena</th>
            <th rowspan="1" colspan="1">cloudSPAdes</th>
            <th rowspan="1" colspan="1">Architect</th>
            <th rowspan="1" colspan="1">ARCS</th>
            <th rowspan="1" colspan="1">Supernova</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">MOCK5</td>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># contigs</td>
            <td rowspan="1" colspan="1">353</td>
            <td rowspan="1" colspan="1">117</td>
            <td rowspan="1" colspan="1">
              <bold>97</bold>
            </td>
            <td rowspan="1" colspan="1">295</td>
            <td rowspan="1" colspan="1">319</td>
            <td rowspan="1" colspan="1">1895</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total length (kb)</td>
            <td rowspan="1" colspan="1">21 253</td>
            <td rowspan="1" colspan="1">
              <bold>21 820</bold>
            </td>
            <td rowspan="1" colspan="1">21 260</td>
            <td rowspan="1" colspan="1">21 259</td>
            <td rowspan="1" colspan="1">21 256</td>
            <td rowspan="1" colspan="1">21 614</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NA50 (kb)</td>
            <td rowspan="1" colspan="1">51</td>
            <td rowspan="1" colspan="1">154</td>
            <td rowspan="1" colspan="1">
              <bold>225</bold>
            </td>
            <td rowspan="1" colspan="1">61</td>
            <td rowspan="1" colspan="1">52</td>
            <td rowspan="1" colspan="1">2</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">N50 (kb)</td>
            <td rowspan="1" colspan="1">116</td>
            <td rowspan="1" colspan="1">351</td>
            <td rowspan="1" colspan="1">
              <bold>1294</bold>
            </td>
            <td rowspan="1" colspan="1">185</td>
            <td rowspan="1" colspan="1">168</td>
            <td rowspan="1" colspan="1">120</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NA10 (kb)</td>
            <td rowspan="1" colspan="1">194</td>
            <td rowspan="1" colspan="1">688</td>
            <td rowspan="1" colspan="1">
              <bold>1265</bold>
            </td>
            <td rowspan="1" colspan="1">284</td>
            <td rowspan="1" colspan="1">268</td>
            <td rowspan="1" colspan="1">101</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">N10 (kb)</td>
            <td rowspan="1" colspan="1">562</td>
            <td rowspan="1" colspan="1">1020</td>
            <td rowspan="1" colspan="1">
              <bold>2836</bold>
            </td>
            <td rowspan="1" colspan="1">1129</td>
            <td rowspan="1" colspan="1">1372</td>
            <td rowspan="1" colspan="1">2369</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Longest alignment (kb)</td>
            <td rowspan="1" colspan="1">268</td>
            <td rowspan="1" colspan="1">1150</td>
            <td rowspan="1" colspan="1">
              <bold>1416</bold>
            </td>
            <td rowspan="1" colspan="1">563</td>
            <td rowspan="1" colspan="1">563</td>
            <td rowspan="1" colspan="1">491</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># N’s per 100 kb</td>
            <td rowspan="1" colspan="1">22</td>
            <td rowspan="1" colspan="1">
              <bold>0</bold>
            </td>
            <td rowspan="1" colspan="1">761</td>
            <td rowspan="1" colspan="1">25</td>
            <td rowspan="1" colspan="1">23</td>
            <td rowspan="1" colspan="1">15 762</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Mean NGA50 per reference (kb)</td>
            <td rowspan="1" colspan="1">93</td>
            <td rowspan="1" colspan="1">
              <bold>544</bold>
            </td>
            <td rowspan="1" colspan="1">528</td>
            <td rowspan="1" colspan="1">125</td>
            <td rowspan="1" colspan="1">105</td>
            <td rowspan="1" colspan="1">19</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Mean # misassemblies per reference</td>
            <td rowspan="1" colspan="1">
              <bold>3.75</bold>
            </td>
            <td rowspan="1" colspan="1">21.5</td>
            <td rowspan="1" colspan="1">10</td>
            <td rowspan="1" colspan="1">5.25</td>
            <td rowspan="1" colspan="1">6.25</td>
            <td rowspan="1" colspan="1">59.5</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Running time</td>
            <td align="center" rowspan="1" colspan="1">37 h</td>
            <td align="center" rowspan="1" colspan="1">37 h + 36 h</td>
            <td align="center" rowspan="1" colspan="1">37 h + 51 min</td>
            <td align="center" rowspan="1" colspan="1">37 h + 4 h</td>
            <td align="center" rowspan="1" colspan="1">37 h + 3.5 h</td>
            <td align="center" rowspan="1" colspan="1">
              <bold>25 min</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">MOCK20</td>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># contigs</td>
            <td rowspan="1" colspan="1">1089</td>
            <td rowspan="1" colspan="1">
              <bold>243</bold>
            </td>
            <td rowspan="1" colspan="1">793</td>
            <td rowspan="1" colspan="1">1032</td>
            <td rowspan="1" colspan="1">1015</td>
            <td rowspan="1" colspan="1">13 193</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total length (kb)</td>
            <td rowspan="1" colspan="1">51 053</td>
            <td rowspan="1" colspan="1">50 917</td>
            <td rowspan="1" colspan="1">54 838</td>
            <td rowspan="1" colspan="1">51 067</td>
            <td rowspan="1" colspan="1">51 060</td>
            <td rowspan="1" colspan="1">67 321</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NA50 (kb)</td>
            <td rowspan="1" colspan="1">50</td>
            <td rowspan="1" colspan="1">
              <bold>203</bold>
            </td>
            <td rowspan="1" colspan="1">124</td>
            <td rowspan="1" colspan="1">50</td>
            <td rowspan="1" colspan="1">54</td>
            <td rowspan="1" colspan="1">18</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">N50 (kb)</td>
            <td rowspan="1" colspan="1">155</td>
            <td rowspan="1" colspan="1">
              <bold>885</bold>
            </td>
            <td rowspan="1" colspan="1">845</td>
            <td rowspan="1" colspan="1">157</td>
            <td rowspan="1" colspan="1">189</td>
            <td rowspan="1" colspan="1">36</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NA10 (kb)</td>
            <td rowspan="1" colspan="1">364</td>
            <td rowspan="1" colspan="1">1141</td>
            <td rowspan="1" colspan="1">
              <bold>1368</bold>
            </td>
            <td rowspan="1" colspan="1">366</td>
            <td rowspan="1" colspan="1">1021</td>
            <td rowspan="1" colspan="1">95</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">N10 (kb)</td>
            <td rowspan="1" colspan="1">581</td>
            <td rowspan="1" colspan="1">3011</td>
            <td rowspan="1" colspan="1">1968</td>
            <td rowspan="1" colspan="1">587</td>
            <td rowspan="1" colspan="1">
              <bold>6300</bold>
            </td>
            <td rowspan="1" colspan="1">166</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Longest alignment (kb)</td>
            <td rowspan="1" colspan="1">907</td>
            <td rowspan="1" colspan="1">
              <bold>2389</bold>
            </td>
            <td rowspan="1" colspan="1">1844</td>
            <td rowspan="1" colspan="1">907</td>
            <td rowspan="1" colspan="1">1435</td>
            <td rowspan="1" colspan="1">1532</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># N’s per 100 kb</td>
            <td rowspan="1" colspan="1">14</td>
            <td rowspan="1" colspan="1">
              <bold>0.4</bold>
            </td>
            <td rowspan="1" colspan="1">403</td>
            <td rowspan="1" colspan="1">16</td>
            <td rowspan="1" colspan="1">14</td>
            <td rowspan="1" colspan="1">245</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Mean NGA50 per reference (kb)</td>
            <td rowspan="1" colspan="1">153</td>
            <td rowspan="1" colspan="1">781</td>
            <td rowspan="1" colspan="1">
              <bold>787</bold>
            </td>
            <td rowspan="1" colspan="1">153</td>
            <td rowspan="1" colspan="1">467</td>
            <td rowspan="1" colspan="1">343</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Mean # misassemblies per reference</td>
            <td rowspan="1" colspan="1">
              <bold>1.4</bold>
            </td>
            <td rowspan="1" colspan="1">3.4</td>
            <td rowspan="1" colspan="1">3.0</td>
            <td rowspan="1" colspan="1">1.6</td>
            <td rowspan="1" colspan="1">1.6</td>
            <td rowspan="1" colspan="1">12.2</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Running time</td>
            <td align="center" rowspan="1" colspan="1">68 h</td>
            <td align="center" rowspan="1" colspan="1">68 h + 9 days</td>
            <td align="center" rowspan="1" colspan="1">68 h + 3 h</td>
            <td align="center" rowspan="1" colspan="1">68 h + 6.5 h</td>
            <td align="center" rowspan="1" colspan="1">68 h + 5 h</td>
            <td align="center" rowspan="1" colspan="1">26 days</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">GUT</td>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># contigs</td>
            <td rowspan="1" colspan="1">39 317</td>
            <td rowspan="1" colspan="1">
              <bold>14 015</bold>
            </td>
            <td rowspan="1" colspan="1">33 130</td>
            <td rowspan="1" colspan="1">39 283</td>
            <td rowspan="1" colspan="1">39 270</td>
            <td rowspan="1" colspan="1">25 333</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total length (kb)</td>
            <td rowspan="1" colspan="1">342 982</td>
            <td rowspan="1" colspan="1">318 979</td>
            <td rowspan="1" colspan="1">
              <bold>376 934</bold>
            </td>
            <td rowspan="1" colspan="1">346 276</td>
            <td rowspan="1" colspan="1">342 987</td>
            <td rowspan="1" colspan="1">374 906</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NG50</td>
            <td rowspan="1" colspan="1">5708</td>
            <td rowspan="1" colspan="1">15 544</td>
            <td rowspan="1" colspan="1">12 729</td>
            <td rowspan="1" colspan="1">5903</td>
            <td rowspan="1" colspan="1">6441</td>
            <td rowspan="1" colspan="1">
              <bold>21 195</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NG10</td>
            <td rowspan="1" colspan="1">95 914</td>
            <td rowspan="1" colspan="1">
              <bold>375 559</bold>
            </td>
            <td rowspan="1" colspan="1">322 007</td>
            <td rowspan="1" colspan="1">96 072</td>
            <td rowspan="1" colspan="1">95 939</td>
            <td rowspan="1" colspan="1">263 602</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Longest contig (kb)</td>
            <td rowspan="1" colspan="1">725</td>
            <td rowspan="1" colspan="1">
              <bold>1968</bold>
            </td>
            <td rowspan="1" colspan="1">1934</td>
            <td rowspan="1" colspan="1">725</td>
            <td rowspan="1" colspan="1">725</td>
            <td rowspan="1" colspan="1">1787</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># N’s per 100 kb</td>
            <td rowspan="1" colspan="1">22</td>
            <td rowspan="1" colspan="1">
              <bold>0</bold>
            </td>
            <td rowspan="1" colspan="1">714</td>
            <td rowspan="1" colspan="1">22</td>
            <td rowspan="1" colspan="1">23</td>
            <td rowspan="1" colspan="1">22 613</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Mean NGA50 per reference</td>
            <td rowspan="1" colspan="1">40 301</td>
            <td rowspan="1" colspan="1">
              <bold>93 563</bold>
            </td>
            <td rowspan="1" colspan="1">85 859</td>
            <td rowspan="1" colspan="1">40 301</td>
            <td rowspan="1" colspan="1">40 301</td>
            <td rowspan="1" colspan="1">17 586</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Mean # misassemblies per reference</td>
            <td rowspan="1" colspan="1">
              <bold>11.08</bold>
            </td>
            <td rowspan="1" colspan="1">52.46</td>
            <td rowspan="1" colspan="1">35.31</td>
            <td rowspan="1" colspan="1">13.69</td>
            <td rowspan="1" colspan="1">11.15</td>
            <td rowspan="1" colspan="1">24.53</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Running time</td>
            <td align="center" rowspan="1" colspan="1">6 days</td>
            <td align="center" rowspan="1" colspan="1">6 days + 24 days</td>
            <td align="center" rowspan="1" colspan="1">6 days + 12.5 h</td>
            <td align="center" rowspan="1" colspan="1">6 days + 13 h</td>
            <td align="center" rowspan="1" colspan="1">6 days + 9 h</td>
            <td align="center" rowspan="1" colspan="1">
              <bold>28 h</bold>
            </td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn1">
          <p><italic>Note:</italic> The running time for all tools but Supernova includes the SPAdes or metaSPAdes running time (<inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula> days for the GUT dataset). The best value for each row is indicated in bold. metaSPAdes was run with the default <italic>k</italic>-mer size equal to 55. All benchmarking was done on Intel Xeon E7-4880 processor using 15 CPUs. metaQUAST defines the NA50 statistics as similar to NGA50, but calculates it with respect to the total assembly length instead of the reference genome size. To compare various assemblers, we used both contigs and scaffolds exceeding 2 kb in length. metaQUAST was launched with the <italic>-m 2000</italic> and <italic>-x 2500</italic> options for all datasets, and with <italic>–fragmented</italic> option for the GUT dataset. The reference length for the GUT dataset was set to length of the metaSPAdes assembly (520 Mb). Since the reference assemblies may have significant differences compared to the genomes in the GUT metagenome, estimates of the number of assembly errors for the GUT dataset should be taken with caution since many of the errors may represent differences with the references rather than errors. All tools except Architect were run with default parameters. Architect was run with parameters <italic>t </italic>=<italic> </italic>2, <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mi mathvariant="italic">rc</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">abs</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">thr</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="italic">rc</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">rel</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">edge</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">thr</mml:mi><mml:mo>=</mml:mo><mml:mn>0.02</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="italic">rc</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">rel</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">prun</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">thr</mml:mi><mml:mo>=</mml:mo><mml:mn>0.01</mml:mn></mml:mrow></mml:math></inline-formula> to optimize its performance on SSLR datasets.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <table-wrap id="btz349-T2" orientation="portrait" position="float">
      <label>Table 2.</label>
      <caption>
        <p>Assembly statistics for the YEAST, STAPH and ECOLI datasets</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">Assembler</th>
            <th rowspan="1" colspan="1">SPAdes</th>
            <th rowspan="1" colspan="1">Athena</th>
            <th rowspan="1" colspan="1">cloudSPAdes</th>
            <th rowspan="1" colspan="1">Architect</th>
            <th rowspan="1" colspan="1">ARCS</th>
            <th rowspan="1" colspan="1">Supernova</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">YEAST</td>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># contigs</td>
            <td rowspan="1" colspan="1">305</td>
            <td rowspan="1" colspan="1">116</td>
            <td rowspan="1" colspan="1">
              <bold>101</bold>
            </td>
            <td rowspan="1" colspan="1">320</td>
            <td rowspan="1" colspan="1">259</td>
            <td rowspan="1" colspan="1">898</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total length (kb)</td>
            <td rowspan="1" colspan="1">11 583</td>
            <td rowspan="1" colspan="1">
              <bold>11 752</bold>
            </td>
            <td rowspan="1" colspan="1">11 734</td>
            <td rowspan="1" colspan="1">11 603</td>
            <td rowspan="1" colspan="1">11 589</td>
            <td rowspan="1" colspan="1">10 983</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NGA50 (kb)</td>
            <td rowspan="1" colspan="1">103</td>
            <td rowspan="1" colspan="1">179</td>
            <td rowspan="1" colspan="1">
              <bold>539</bold>
            </td>
            <td rowspan="1" colspan="1">228</td>
            <td rowspan="1" colspan="1">185</td>
            <td rowspan="1" colspan="1">22</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NG50 (kb)</td>
            <td rowspan="1" colspan="1">103</td>
            <td rowspan="1" colspan="1">187</td>
            <td rowspan="1" colspan="1">
              <bold>691</bold>
            </td>
            <td rowspan="1" colspan="1">410</td>
            <td rowspan="1" colspan="1">198</td>
            <td rowspan="1" colspan="1">23</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NGA10 (kb)</td>
            <td rowspan="1" colspan="1">227</td>
            <td rowspan="1" colspan="1">470</td>
            <td rowspan="1" colspan="1">
              <bold>888</bold>
            </td>
            <td rowspan="1" colspan="1">622</td>
            <td rowspan="1" colspan="1">532</td>
            <td rowspan="1" colspan="1">63</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NG10 (kb)</td>
            <td rowspan="1" colspan="1">243</td>
            <td rowspan="1" colspan="1">470</td>
            <td rowspan="1" colspan="1">
              <bold>1, 715</bold>
            </td>
            <td rowspan="1" colspan="1">772</td>
            <td rowspan="1" colspan="1">533</td>
            <td rowspan="1" colspan="1">70</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Longest alignment (kb)</td>
            <td rowspan="1" colspan="1">314</td>
            <td rowspan="1" colspan="1">545</td>
            <td rowspan="1" colspan="1">
              <bold>848</bold>
            </td>
            <td rowspan="1" colspan="1">314</td>
            <td rowspan="1" colspan="1">584</td>
            <td rowspan="1" colspan="1">92</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># N’s per 100 kb</td>
            <td rowspan="1" colspan="1">18</td>
            <td rowspan="1" colspan="1">
              <bold>1</bold>
            </td>
            <td rowspan="1" colspan="1">761</td>
            <td rowspan="1" colspan="1">24</td>
            <td rowspan="1" colspan="1">57</td>
            <td rowspan="1" colspan="1">548</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># misassemblies</td>
            <td rowspan="1" colspan="1">
              <bold>1</bold>
            </td>
            <td rowspan="1" colspan="1">15</td>
            <td rowspan="1" colspan="1">7</td>
            <td rowspan="1" colspan="1">21</td>
            <td rowspan="1" colspan="1">
              <bold>1</bold>
            </td>
            <td rowspan="1" colspan="1">16</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Running time</td>
            <td rowspan="1" colspan="1">74 min</td>
            <td rowspan="1" colspan="1">74 min + 11 h</td>
            <td rowspan="1" colspan="1">74 min + 13 min</td>
            <td rowspan="1" colspan="1">74 min + 30 min</td>
            <td rowspan="1" colspan="1">74 min + 42 min</td>
            <td rowspan="1" colspan="1">
              <bold>25 min</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">STAPH</td>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># contigs</td>
            <td rowspan="1" colspan="1">89</td>
            <td rowspan="1" colspan="1">21</td>
            <td rowspan="1" colspan="1">56</td>
            <td rowspan="1" colspan="1">75</td>
            <td rowspan="1" colspan="1">79</td>
            <td rowspan="1" colspan="1">12</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total length (kb)</td>
            <td rowspan="1" colspan="1">2870</td>
            <td rowspan="1" colspan="1">2886</td>
            <td rowspan="1" colspan="1">2905</td>
            <td rowspan="1" colspan="1">2874</td>
            <td rowspan="1" colspan="1">2872</td>
            <td rowspan="1" colspan="1">
              <bold>2957</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NGA50 (kb)</td>
            <td rowspan="1" colspan="1">174</td>
            <td rowspan="1" colspan="1">728</td>
            <td rowspan="1" colspan="1">1645</td>
            <td rowspan="1" colspan="1">821</td>
            <td rowspan="1" colspan="1">252</td>
            <td rowspan="1" colspan="1">
              <bold>2794</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NG50 (kb)</td>
            <td rowspan="1" colspan="1">174</td>
            <td rowspan="1" colspan="1">728</td>
            <td rowspan="1" colspan="1">1655</td>
            <td rowspan="1" colspan="1">821</td>
            <td rowspan="1" colspan="1">252</td>
            <td rowspan="1" colspan="1">
              <bold>2797</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NGA10 (kb)</td>
            <td rowspan="1" colspan="1">303</td>
            <td rowspan="1" colspan="1">1170</td>
            <td rowspan="1" colspan="1">1645</td>
            <td rowspan="1" colspan="1">859</td>
            <td rowspan="1" colspan="1">356</td>
            <td rowspan="1" colspan="1">
              <bold>2794</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NG10 (kb)</td>
            <td rowspan="1" colspan="1">313</td>
            <td rowspan="1" colspan="1">1231</td>
            <td rowspan="1" colspan="1">1654</td>
            <td rowspan="1" colspan="1">1022</td>
            <td rowspan="1" colspan="1">356</td>
            <td rowspan="1" colspan="1">
              <bold>2797</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Longest alignment (kb)</td>
            <td rowspan="1" colspan="1">313</td>
            <td rowspan="1" colspan="1">1170</td>
            <td rowspan="1" colspan="1">1645</td>
            <td rowspan="1" colspan="1">859</td>
            <td rowspan="1" colspan="1">356</td>
            <td rowspan="1" colspan="1">
              <bold>2793</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># N’s per 100 kb</td>
            <td rowspan="1" colspan="1">25</td>
            <td rowspan="1" colspan="1">
              <bold>0</bold>
            </td>
            <td rowspan="1" colspan="1">603</td>
            <td rowspan="1" colspan="1">33</td>
            <td rowspan="1" colspan="1">60</td>
            <td rowspan="1" colspan="1">27</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># misassemblies</td>
            <td rowspan="1" colspan="1">2</td>
            <td rowspan="1" colspan="1">2</td>
            <td rowspan="1" colspan="1">3</td>
            <td rowspan="1" colspan="1">5</td>
            <td rowspan="1" colspan="1">2</td>
            <td rowspan="1" colspan="1">
              <bold>0</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Running time</td>
            <td rowspan="1" colspan="1">119 min</td>
            <td rowspan="1" colspan="1">119 min + 115 min</td>
            <td rowspan="1" colspan="1">119 min + 1 min</td>
            <td rowspan="1" colspan="1">119 min + 11 min</td>
            <td rowspan="1" colspan="1">119 min + 9 min</td>
            <td rowspan="1" colspan="1">190 min</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">ECOLI</td>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
            <td rowspan="1" colspan="1"/>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># contigs</td>
            <td rowspan="1" colspan="1">110</td>
            <td rowspan="1" colspan="1">16</td>
            <td rowspan="1" colspan="1">9</td>
            <td rowspan="1" colspan="1">75</td>
            <td rowspan="1" colspan="1">75</td>
            <td rowspan="1" colspan="1">63</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Total length (kb)</td>
            <td rowspan="1" colspan="1">4515</td>
            <td rowspan="1" colspan="1">
              <bold>4634</bold>
            </td>
            <td rowspan="1" colspan="1">4596</td>
            <td rowspan="1" colspan="1">4516</td>
            <td rowspan="1" colspan="1">4518</td>
            <td rowspan="1" colspan="1">4471</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NGA50 (kb)</td>
            <td rowspan="1" colspan="1">82</td>
            <td rowspan="1" colspan="1">396</td>
            <td rowspan="1" colspan="1">
              <bold>2543</bold>
            </td>
            <td rowspan="1" colspan="1">201</td>
            <td rowspan="1" colspan="1">287</td>
            <td rowspan="1" colspan="1">123</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NG50 (kb)</td>
            <td rowspan="1" colspan="1">83</td>
            <td rowspan="1" colspan="1">439</td>
            <td rowspan="1" colspan="1">
              <bold>2813</bold>
            </td>
            <td rowspan="1" colspan="1">209</td>
            <td rowspan="1" colspan="1">287</td>
            <td rowspan="1" colspan="1">127</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NGA10 (kb)</td>
            <td rowspan="1" colspan="1">260</td>
            <td rowspan="1" colspan="1">1, 075</td>
            <td rowspan="1" colspan="1">
              <bold>2543</bold>
            </td>
            <td rowspan="1" colspan="1">542</td>
            <td rowspan="1" colspan="1">505</td>
            <td rowspan="1" colspan="1">260</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">NG10 (kb)</td>
            <td rowspan="1" colspan="1">260</td>
            <td rowspan="1" colspan="1">1, 075</td>
            <td rowspan="1" colspan="1">
              <bold>2813</bold>
            </td>
            <td rowspan="1" colspan="1">542</td>
            <td rowspan="1" colspan="1">506</td>
            <td rowspan="1" colspan="1">260</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Longest alignment (kb)</td>
            <td rowspan="1" colspan="1">326</td>
            <td rowspan="1" colspan="1">1074</td>
            <td rowspan="1" colspan="1">
              <bold>2543</bold>
            </td>
            <td rowspan="1" colspan="1">542</td>
            <td rowspan="1" colspan="1">505</td>
            <td rowspan="1" colspan="1">414</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># N’s per 100 kb</td>
            <td rowspan="1" colspan="1">20</td>
            <td rowspan="1" colspan="1">
              <bold>0</bold>
            </td>
            <td rowspan="1" colspan="1">647</td>
            <td rowspan="1" colspan="1">28</td>
            <td rowspan="1" colspan="1">97</td>
            <td rowspan="1" colspan="1">73</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1"># misassemblies</td>
            <td rowspan="1" colspan="1">
              <bold>1</bold>
            </td>
            <td rowspan="1" colspan="1">5</td>
            <td rowspan="1" colspan="1">3</td>
            <td rowspan="1" colspan="1">5</td>
            <td rowspan="1" colspan="1">3</td>
            <td rowspan="1" colspan="1">5</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Running time</td>
            <td rowspan="1" colspan="1">18 min</td>
            <td rowspan="1" colspan="1">18 min + 43 min</td>
            <td rowspan="1" colspan="1">18 min + 11 s</td>
            <td rowspan="1" colspan="1">18 min + 1 min</td>
            <td rowspan="1" colspan="1">18 min + 53 s</td>
            <td rowspan="1" colspan="1">
              <bold>11 min</bold>
            </td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn2">
          <p><italic>Note:</italic> The running time for all tools but Supernova includes the SPAdes running time. The best value for each row is indicated in bold. All benchmarking was done on Intel Xeon E7-4880 processor using 15 CPUs. Number of misassemblies includes only global misassemblies as identified by QUAST (with breakpoint distance exceeding 2 kb). QUAST was launched with the <italic>–scaffold-gap-max-size 20000</italic> and <italic>-x 2000</italic> options for all datasets.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <fig id="btz349-F5" orientation="portrait" position="float">
      <label>Fig. 5.</label>
      <caption>
        <p>The NGAx plots for the YEAST (top left), STAPH (top middle) and ECOLI(top right) datasets. NAx plots for the MOCK5 (top right), NAx plots for the MOCK20 (bottom left) and NGx plot for the GUT (bottom right) datasets. The metaSPAdes curve is not shown since it is nearly identical to the ARCS curve for the GUT dataset. The metaSPAdes curve is replaced with the SPAdes curve for the YEAST, STAPH and ECOLI plots</p>
      </caption>
      <graphic xlink:href="btz349f5"/>
    </fig>
    <fig id="btz349-F6" orientation="portrait" position="float">
      <label>Fig. 6.</label>
      <caption>
        <p>metaQUAST statistics for MOCK5, MOCK20 and GUT datasets. NGA50 statistics per reference for the MOCK5(top left), MOCK20 (top middle) and GUT(top right) datasets. Number of misassemblies per reference for the MOCK5 (bottom left), MOCK20 (bottom middle) and GUT (bottom right) datasets. Genomes are represented by their RefSeq IDs</p>
      </caption>
      <graphic xlink:href="btz349f6"/>
    </fig>
    <p>The benchmarking results for the YEAST datasets reveal that the existing SSLR assemblers are unstable with respect to parameters: their performance deteriorates when they are faced with datasets whose parameters differ from the parameters these assemblers optimized for. The unstable behavior of various SSLR tools makes it difficult to develop new barcoding technologies since the ongoing experimental developments of new protocols have to be constantly complemented by computational tests (otherwise it is unclear how a new technology affects the downstream assembly).</p>
    <p>cloudSPAdes turned out to be a fast assembler that performs well across the range of technologies and applications. As discussed in (<xref rid="btz349-B25" ref-type="bibr">Nurk <italic>et al.</italic>, 2017</xref>), the NA50 metric alone is limited with respect to estimating the contiguity of metagenomics assemblers since biologists are typically interested in the contiguity of the 10–100 most abundant genomes that often form less than 50% of the total metagenome length. We thus reflected the both NA50 and NA10 statistics in <xref rid="btz349-T1" ref-type="table">Table 1</xref> (see <xref ref-type="fig" rid="btz349-F5">Fig. 5</xref> for detailed information about the contiguity of various assemblers).</p>
    <p>On the MOCK5 dataset, cloudSPAdes generated the longest contigs with respect to the NA50 (225 kb for cloudSPAdes versus 154 kb for Athena) and NA10 (1265 kb versus 688 kb). The superior performance of cloudSPAdes on the MOCK5 dataset may be explained by its adaptability to the specific properties of the SSLR datasets, e.g. the MOCK5 dataset has an unusually low fragment coverage.</p>
    <p>On the MOCK20 datasets, cloudSPAdes and Athena showed similar results: Athena resulted in higher NA50 (124 kb for cloudSPAdes versus 203 kb for Athena) but lower NA10 (1368 kb for cloudSPAdes versus 1141 kb for Athena).</p>
    <p>On the GUT dataset, cloudSPAdes, Athena and Supernova generated the most contiguous assemblies. However, Supernova’s assembly has limited applicability since it generated contigs with an extremely large fraction of unknown nucleotides (22.6% of all nucleotides are marked as Ns). cloudSPAdes and Athena resulted in assemblies with similar contiguity (NG50 and NG10 are approximately 20% higher for Athena than for cloudSPAdes). However, NG50 and NG10 parameters do not account for assembly errors that typically inflate the contig lengths. Since only a few reference genomes for the GUT dataset are known, we are unable to derive the NA50 and NA10 statistics for this dataset. However, judging from the fact that Athena made <inline-formula id="IE20"><mml:math id="IM20"><mml:mo>≈</mml:mo></mml:math></inline-formula>50% more assembly errors on the reference GUT genomes, we project that cloudSPAdes assemblies may have very similar or even higher NA50 and NA10 statistics than Athena assembly. Interestingly, Athena resulted in a 20% smaller total assembly length than cloudSPAdes. Athena took 24 days to assemble the GUT dataset, while cloudSPAdes took only 12.5 h (not counting the metaSPAdes running time).</p>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>Although long error-prone reads have revolutionized sequencing of large genomes, the relatively high cost limits their applications to sequencing of small genomes. This is unfortunate since the number of bacterial sequencing projects based on short reads [most of them assembled with SPAdes (<xref rid="btz349-B6" ref-type="bibr">Bankevich <italic>et al.</italic>, 2012</xref>)] greatly exceeds the number of eukaryotic sequencing projects based on long reads [most of them assembled with Canu (<xref rid="btz349-B15" ref-type="bibr">Koren <italic>et al.</italic>, 2017</xref>)]. However, since long-read assemblies are much more contiguous than short-read assemblies, there is an effort to make assemblies of small genomes both contiguous and cost efficient at the same time. Although SSLRs represent a potential solution for a low-cost genome sequencing, the 10X Genomics Chromium Controller remains rather expensive for sequencing small genomes. That is why UST and other companies are trying to reduce the cost of SSLRs, to eliminate the need for an expensive Chromium Controller, to simplify sample preparation, and to enable new SSLR applications. These efforts promise to revolutionize sequencing of small genomes by making it as cost-effective as short-read sequencing and as contiguous as long read sequencing. However, to support such developments, there is a need to develop a ‘universal’ SSLR assembler that works well across various barcoding technologies and various applications.</p>
    <p>We have demonstrated that the existing SSLR assemblers are rather stringent with respect to changing parameters of the emerging barcoding technologies and even the parameters of specific metagenomics datasets generated using the same 10X Genomics technology. cloudSPAdes is an attempt to develop a universal open-source SSLR assembler that works well across various technologies and datasets. Although it significantly improves on the contiguity of SPAdes and metaSPAdes assemblies, further efforts are needed to close the gap between the contiguity (and the number of assembly errors) of the low-cost SSLR assemblies and high-cost assemblies based on long error-prone reads.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>btz349_Supplementary_Data</label>
      <media xlink:href="btz349_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We are indebted to Serafim Batzoglou, Alex Bishara, Sergey Nurk, Andrey Prjibelski, Andrey Slabodkin, Dmitry Antipov and Yana Safonova for many helpful discussions and help with preparation of this paper.</p>
    <sec>
      <title>Funding</title>
      <p>The project was supported by the Russian Science Foundation (grant 19–14–00172).</p>
      <p><italic>Conflict of Interest:</italic> none declared.</p>
    </sec>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz349-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Adey</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>In vitro, long-range sequence information for De Novo genome assembly via transposase contiguity</article-title>. <source>Genome Res</source>., <volume>24</volume>, <fpage>2041</fpage>–<lpage>2049</lpage>.<pub-id pub-id-type="pmid">25327137</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Alizadeh</surname><given-names>F.</given-names></name></person-group><etal>et al</etal> (<year>1995</year>) 
<article-title>Physical mapping of chromosomes: a combinatorial problem in molecular biology</article-title>. <source>Algorithmica</source>, <volume>13</volume>, <fpage>52</fpage>–<lpage>76</lpage>.</mixed-citation>
    </ref>
    <ref id="btz349-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bag</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>An improved method for high quality metagenomics DNA extraction from human and environmental samples</article-title>. <source>Sci. Rep</source>., <volume>6</volume>, <fpage>26775.</fpage><pub-id pub-id-type="pmid">27240745</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bankevich</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Pevzner</surname><given-names>P.A.</given-names></name></person-group> (<year>2016</year>) 
<article-title>TruSPAdes: barcode assembly of TruSeq synthetic long reads</article-title>. <source>Nat. Methods</source>, <volume>13</volume>, <fpage>248</fpage>–<lpage>250</lpage>.<pub-id pub-id-type="pmid">26828418</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bankevich</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Pevzner</surname><given-names>P.A.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Joint analysis of long and short reads enables accurate estimates of microbiome complexity</article-title>. <source>Cell Syst</source>., <volume>7</volume>, <fpage>192</fpage>–<lpage>200</lpage>.<pub-id pub-id-type="pmid">30056005</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bankevich</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>SPAdes: a new genome assembly algorithm and its applications to single-cell sequencing</article-title>. <source>J. Comput. Biol</source>., <volume>19</volume>, <fpage>455</fpage>–<lpage>477</lpage>.<pub-id pub-id-type="pmid">22506599</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B7">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Batzoglou</surname><given-names>S.</given-names></name>, <name name-style="western"><surname>Istrail</surname><given-names>S.</given-names></name></person-group> (<year>1999</year>) <chapter-title>Physical mapping with repeated probes: the hypergraph superstring problem</chapter-title> In: Crochemore, M. and Paterson, M. (eds) <source>Combinatorial Pattern Matching</source>. CPM 1999. Lecture Notes in Computer Science, Vol. 1645. 
<publisher-name>Springer</publisher-name>, 
<publisher-loc>Berlin, Heidelberg</publisher-loc>, pp. <fpage>66</fpage>–<lpage>77</lpage>.</mixed-citation>
    </ref>
    <ref id="btz349-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bishara</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>High-quality genome sequences of uncultured microbes by assembly of read clouds</article-title>. <source>Nat. Biotechnol</source>., <volume>36</volume>, <fpage>1067</fpage>–<lpage>1075</lpage>.</mixed-citation>
    </ref>
    <ref id="btz349-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Danko</surname><given-names>D.C.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Minerva: an alignment- and reference-free approach to deconvolve linked-reads for metagenomics</article-title>. <source>Genome Res</source>., <volume>29</volume>, <fpage>116</fpage>–<lpage>124</lpage>.<pub-id pub-id-type="pmid">30523036</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B11">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Fleischner</surname><given-names>H.</given-names></name></person-group> (<year>1990</year>) <source>Eulerian Graphs and Related Topics</source>, Vol. 1. 
<publisher-name>Elsevier</publisher-name>, 
<publisher-loc>Amsterdam</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btz349-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Gong</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Culture-independent analysis of liver abscess using nanopore sequencing</article-title>. <source>PLoS One</source>, <volume>13</volume>, <fpage>e0190853.</fpage><pub-id pub-id-type="pmid">29315344</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Goordial</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>In situ field sequencing and life detection in remote (79–26’N) Canadian high arctic permafrost ice wedge microbial communities</article-title>. <source>Front. Microbiol</source>., <volume>8</volume>, <fpage>2594.</fpage><pub-id pub-id-type="pmid">29326684</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Gurevich</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>QUAST: quality assessment tool for genome assemblies</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>1072</fpage>–<lpage>1075</lpage>.<pub-id pub-id-type="pmid">23422339</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Koren</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Canu: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>722</fpage>–<lpage>736</lpage>.<pub-id pub-id-type="pmid">28298431</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B16">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Koslicki</surname><given-names>D.</given-names></name>, <name name-style="western"><surname>Zabeti</surname><given-names>H.</given-names></name></person-group> (<year>2017</year>) Improving min hash via the containment index with applications to metagenomic analysis. Preprint.</mixed-citation>
    </ref>
    <ref id="btz349-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kuhn</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Comparison of ten different DNA extraction procedures with respect to their suitability for environmental samples</article-title>. <source>J. Microbiol. Methods</source>, <volume>143</volume>, <fpage>78</fpage>–<lpage>86</lpage>.<pub-id pub-id-type="pmid">29056447</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kuleshov</surname><given-names>V.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Genome assembly from synthetic long read clouds</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>i216</fpage>–<lpage>i224</lpage>.<pub-id pub-id-type="pmid">27307620</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Marks</surname><given-names>P.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Resolving the full spectrum of human genome variation using linked-reads</article-title>. <source>Genome Res</source>., <volume>29</volume>, <fpage>635</fpage>–<lpage>645</lpage>.</mixed-citation>
    </ref>
    <ref id="btz349-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mayraz</surname><given-names>G.</given-names></name>, <name name-style="western"><surname>Shamir</surname><given-names>R.</given-names></name></person-group> (<year>1999</year>) 
<article-title>Construction of physical maps from oligonucleotide fingerprints data</article-title>. <source>J. Comput. Biol</source>., <volume>6</volume>, <fpage>237</fpage>–<lpage>252</lpage>.<pub-id pub-id-type="pmid">10421525</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mikheenko</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>MetaQUAST: evaluation of metagenome assemblies</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>1088</fpage>–<lpage>1090</lpage>.<pub-id pub-id-type="pmid">26614127</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Nurk</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>metaSPAdes: a new versatile metagenomic assembler</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>824</fpage>–<lpage>834</lpage>.<pub-id pub-id-type="pmid">28298430</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>O’Leary</surname><given-names>N.A.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Reference sequence (RefSeq) database at NCBI: current status, taxonomic expansion, and functional annotation</article-title>. <source>Nucleic Acids Res</source>., <volume>44</volume>, <fpage>D733</fpage>–<lpage>D745</lpage>.<pub-id pub-id-type="pmid">26553804</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ondov</surname><given-names>B.D.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Mash: fast genome and metagenome distance estimation using MinHash</article-title>. <source>Genome Biol</source>., <volume>17</volume>, <fpage>132.</fpage><pub-id pub-id-type="pmid">27323842</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B28">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Pevzner</surname><given-names>P.</given-names></name></person-group> (<year>2000</year>) <source>Computational Molecular Biology: An Algorithmic Approach</source>. 
<publisher-name>The MIT Press</publisher-name>, 
<publisher-loc>Cambridge, MA</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btz349-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rajaraman</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Algorithms and complexity results for genome mapping problems</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinformatics</source>, <volume>14</volume>, <fpage>418</fpage>–<lpage>430</lpage>.</mixed-citation>
    </ref>
    <ref id="btz349-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Savilahti</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>1995</year>) 
<article-title>The phage Mu transpososome core: DNA requirements for assembly and function</article-title>. <source>EMBO J</source>., <volume>14</volume>, <fpage>4893</fpage>–<lpage>4903</lpage>.<pub-id pub-id-type="pmid">7588618</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sharon</surname><given-names>I.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Accurate, multi-kb reads resolve complex populations and detect rare microorganisms</article-title>. <source>Genome Res</source>., <volume>25</volume>, <fpage>534</fpage>–<lpage>543</lpage>.<pub-id pub-id-type="pmid">25665577</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Voskoboynik</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>The genome sequence of the colonial chordate, <italic>Botryllus schlosseri</italic></article-title>. <source>Elife</source>, <volume>2</volume>, <fpage>e00569.</fpage><pub-id pub-id-type="pmid">23840927</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Weisenfeld</surname><given-names>N.I.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Direct determination of diploid genome sequences</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>757</fpage>–<lpage>767</lpage>.<pub-id pub-id-type="pmid">28381613</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Yeo</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>ARCS: scaffolding genome drafts with linked reads</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>725</fpage>–<lpage>731</lpage>.<pub-id pub-id-type="pmid">29069293</pub-id></mixed-citation>
    </ref>
    <ref id="btz349-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zheng</surname><given-names>G.X.Y.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Haplotyping germline and cancer genomes with high-throughput linked-read sequencing</article-title>. <source>Nat. Biotechnol</source>., <volume>34</volume>, <fpage>303</fpage>–<lpage>311</lpage>.<pub-id pub-id-type="pmid">26829319</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
