<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8896632</article-id>
    <article-id pub-id-type="pmid">32871006</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btaa764</article-id>
    <article-id pub-id-type="publisher-id">btaa764</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Databases and Ontologies</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Mainzelliste SecureEpiLinker (MainSEL): privacy-preserving record linkage using secure multi-party computation</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-6458-5840</contrib-id>
        <name>
          <surname>Stammler</surname>
          <given-names>Sebastian</given-names>
        </name>
        <xref rid="btaa764-cor1" ref-type="corresp"/>
        <aff><institution>Department of Computer Science, Technische Universität Darmstadt</institution>, 64289 Darmstadt, <country country="DE">Germany</country></aff>
        <!--sebastian.stammler@cysec.de-->
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-9731-7666</contrib-id>
        <name>
          <surname>Kussel</surname>
          <given-names>Tobias</given-names>
        </name>
        <aff><institution>Department of Computer Science, Technische Universität Darmstadt</institution>, 64289 Darmstadt, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Schoppmann</surname>
          <given-names>Phillipp</given-names>
        </name>
        <aff><institution>Department of Computer Science, Humboldt-Universität zu Berlin</institution>, 10099 Berlin, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Stampe</surname>
          <given-names>Florian</given-names>
        </name>
        <aff><institution>Federated Information Systems, German Cancer Research Center</institution>, 69120 Heidelberg, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tremper</surname>
          <given-names>Galina</given-names>
        </name>
        <aff><institution>Federated Information Systems, German Cancer Research Center</institution>, 69120 Heidelberg, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Katzenbeisser</surname>
          <given-names>Stefan</given-names>
        </name>
        <aff><institution>Faculty of Computer Science and Mathematics, Universität Passau</institution>, 94030 Passau, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hamacher</surname>
          <given-names>Kay</given-names>
        </name>
        <aff><institution>Department of Computer Science, Technische Universität Darmstadt</institution>, 64289 Darmstadt, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-1880-5555</contrib-id>
        <name>
          <surname>Lablans</surname>
          <given-names>Martin</given-names>
        </name>
        <aff><institution>Federated Information Systems, German Cancer Research Center</institution>, 69120 Heidelberg, <country country="DE">Germany</country></aff>
        <aff><institution>Zentrum für Präventivmedizin und Digitale Gesundheit Baden-Württemberg, University Medical Centre Mannheim</institution>, 68135 Mannheim, <country country="DE">Germany</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Lu</surname>
          <given-names>Zhiyong</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btaa764-cor1">To whom correspondence should be addressed. <email>sebastian.stammler@cysec.de</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <day>15</day>
      <month>3</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2020-09-01">
      <day>01</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>01</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <volume>38</volume>
    <issue>6</issue>
    <fpage>1657</fpage>
    <lpage>1668</lpage>
    <history>
      <date date-type="received">
        <day>25</day>
        <month>11</month>
        <year>2019</year>
      </date>
      <date date-type="rev-recd">
        <day>24</day>
        <month>7</month>
        <year>2020</year>
      </date>
      <date date-type="editorial-decision">
        <day>22</day>
        <month>8</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>25</day>
        <month>8</month>
        <year>2020</year>
      </date>
      <date date-type="corrected-typeset">
        <day>01</day>
        <month>9</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2021</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btaa764.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Record Linkage has versatile applications in real-world data analysis contexts, where several datasets need to be linked on the record level in the absence of any exact identifier connecting related records. An example are medical databases of patients, spread across institutions, that have to be linked on personally identifiable entries like name, date of birth or ZIP code. At the same time, privacy laws may prohibit the exchange of this personally identifiable information (PII) across institutional boundaries, ruling out the outsourcing of the record linkage task to a trusted third party. We propose to employ privacy-preserving record linkage (PPRL) techniques that prevent, to various degrees, the leakage of PII while still allowing for the linkage of related records.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We develop a framework for fault-tolerant PPRL using secure multi-party computation with the medical record keeping software <italic toggle="yes">Mainzelliste</italic> as the data source. Our solution does not rely on any trusted third party and all PII is guaranteed to not leak under common cryptographic security assumptions. Benchmarks show the feasibility of our approach in realistic networking settings: linkage of a patient record against a database of 10 000 records can be done in 48 s over a heavily delayed (100 ms) network connection, or 3.9 s with a low-latency connection.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The source code of the sMPC node is freely available on Github at <ext-link xlink:href="https://github.com/medicalinformatics/SecureEpilinker" ext-link-type="uri">https://github.com/medicalinformatics/SecureEpilinker</ext-link> subject to the AGPLv3 license. The source code of the modified Mainzelliste is available at <ext-link xlink:href="https://github.com/medicalinformatics/MainzellisteSEL" ext-link-type="uri">https://github.com/medicalinformatics/MainzellisteSEL</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>German Federal Ministry of Education and Research (BMBF) through the HiGHmed Consortium</institution>
          </institution-wrap>
        </funding-source>
        <award-id>01ZZ1802G</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>German Research Foundation (DFG) through the MAGIC project</institution>
          </institution-wrap>
        </funding-source>
        <award-id>LA 3859/1-1</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Research Training Group GRK</institution>
          </institution-wrap>
        </funding-source>
        <award-id>1651</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="12"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="btaa764-1">
    <label>1</label>
    <title>Introduction</title>
    <p>In medical research, many questions can only be addressed by combining data from different research institutions and clinics. New correlations between diseases and medical indications require combining data usually originating from different sources, such as genomic data, laboratory values or clinical data. In particular for rare diseases, individual treatment facilities will generally not have enough cases to be able to draw statistically significant conclusions. For this purpose, it is essential that data stored at different locations for a given patient are correctly linked (referred to as ‘record linkage’). At the same time, it is necessary to safeguard the patient’s privacy and manage the data according to applicable data protection laws (<xref rid="btaa764-B18" ref-type="bibr">Eurpean Parliament and Council, 2016</xref>). In particular, personal patient data may not be stored or exchanged between different data sources across organizations without a sound legal basis, usually a patient’s informed consent (<xref rid="btaa764-B50" ref-type="bibr">Vatsalan <italic toggle="yes">et al.</italic>, 2013</xref>).</p>
    <p>Patient data stored in databases can be considered to consist of two components, namely (i<bold>)</bold> the identity data (IDAT, e.g. given name, surname, date of birth) and (ii<bold>)</bold> the medical data (MDAT). In this article, we will only be considering record linkage using information from the IDAT. One cannot always assume that patient data will be always complete and free of errors. Nonetheless, we would like to be able to match patient data across datasets wherever possible. In 1969, Fellegi and Sunter published the first mathematical description of record linkage, the process of pairwise comparison of records from two sets of records to find the pairs that likely represent identical entities (<xref rid="btaa764-B20" ref-type="bibr">Fellegi and Sunter, 1969</xref>). The use of such record linkage methods, employing plaintext identifying data, is well established in the domain of patient data (<xref rid="btaa764-B53" ref-type="bibr">Winkler, 2014</xref>). However, given that the two sets of patient data may be at geographically separated and legally independent institutions, it is clear that plaintext patient data will need to leave at least one of the sites for the comparison to be made, an obvious confidentiality issue.</p>
    <p>To mitigate this problem, a number of techniques were developed, known as Privacy-Preserving Record Linkage (PPRL) (<xref rid="btaa764-B7" ref-type="bibr">Brown <italic toggle="yes">et al.</italic>, 2017</xref>). These techniques transform the IDAT in such a way as to make the identification of the patient difficult, but still allow record linkage. One type of PPRL is based on ‘Bloom filters’ (<xref rid="btaa764-B47" ref-type="bibr">Schnell <italic toggle="yes">et al.</italic>, 2009</xref>; <xref rid="btaa764-B50" ref-type="bibr">Vatsalan <italic toggle="yes">et al.</italic>, 2013</xref>), which allow error-tolerant linkage of hashed identifying data. This approach has been implemented in the Mainzelliste, an open-source software (<xref rid="btaa764-B32" ref-type="bibr">Lablans et al., 2015</xref>) used for pseudonymization and depseudonymization of patient IDAT and the administration of multiple pseudonyms. For reidentification of patients it uses a record linkage mechanism, based on the EpiLink algorithm (<xref rid="btaa764-B13" ref-type="bibr">Contiero <italic toggle="yes">et al.</italic>, 2005</xref>), which allows for fault-tolerant patient matching. Mainzelliste is widely used in various medical research networks (<xref rid="btaa764-B33" ref-type="bibr">Lablans et al., 2018</xref>; <xref rid="btaa764-B39" ref-type="bibr">Miracum, 2019</xref>), patient registries (<xref rid="btaa764-B9" ref-type="bibr">Burkhart and Wiese, 2015</xref>; <xref rid="btaa764-B41" ref-type="bibr">Muscholl et al., 2014</xref>), a radiotherapy infrastructure for multicentric studies (<xref rid="btaa764-B48" ref-type="bibr">Skripcak et al., 2016</xref>), centralized biobanks (<xref rid="btaa764-B4" ref-type="bibr">Bernemann <italic toggle="yes">et al.</italic>, 2016</xref>) and commercial software (<xref rid="btaa764-B11" ref-type="bibr">Climedo, 2019</xref>; <xref rid="btaa764-B27" ref-type="bibr">iAS interActive Systems GmbH, 2019</xref>; <xref rid="btaa764-B37" ref-type="bibr">Link, 2019</xref>).</p>
    <p>However, even when using Bloom filters, identity data—albeit in encrypted form—is still being stored in a central location and can, in principle, be misused for unauthorized reidentification. In fact, many Bloom filter-based solutions are vulnerable to frequency and cryptanalysis attacks (<xref rid="btaa764-B10" ref-type="bibr">Christen <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btaa764-B51" ref-type="bibr">Vatsalan et al., 2017</xref>). Although a recent version is claimed to be secure against all currently known exploits (<xref rid="btaa764-B46" ref-type="bibr">Schnell and Borgs, 2018</xref>), it can be expected, as with any computer system (<xref rid="btaa764-B55" ref-type="bibr">Zabicki and Ellis, 2017</xref>), that new attacks could be devised to circumvent these improvements.</p>
    <p>An optimal record linkage process would completely avoid storing IDAT—in any form—outside of the original treatment facilities and, thus, render such attacks impossible. Ideally, none of the record linkage parties would obtain any new information from the linkage process. This is the promise of Secure Multi-Party Computation (sMPC). This technique is based on the principle that in a computation performed across multiple parties, each participating party only knows their own input and the result of the given computation (<xref rid="btaa764-B50" ref-type="bibr">Vatsalan <italic toggle="yes">et al.</italic>, 2013</xref>).</p>
    <p>In this article, we describe the design and implementation of Mainzelliste Secure EpiLinker (MainSEL), a variant of sMPC integrated as an extension into Mainzelliste. A record linkage setup using MainSEL is comprised of a <italic toggle="yes">local data source</italic>, the <italic toggle="yes">local MainSEL</italic>, a <italic toggle="yes">remote data source</italic>, the <italic toggle="yes">remote MainSEL</italic> and (optionally) a <italic toggle="yes">linkage service</italic>. We developed a close integration into Mainzelliste, to deploy a holistic ID management and linkage solution based on an open-source software that is already in wide use.</p>
    <sec id="btaa764-1.1">
      <label>1.1</label>
      <title>Related work</title>
      <p>While being studied for over fifty years, record linkage algorithms and techniques gained increased traction and interest in the last decade. In comparison to the classic publications of record linkage (<xref rid="btaa764-B20" ref-type="bibr">Fellegi and Sunter, 1969</xref>) the focus shifted toward PPRL techniques to meet raising privacy requirements.</p>
      <p>A number of techniques use Bloom filters and hash-based message authentication codes (HMACs) to provide privacy in the linkage process (<xref rid="btaa764-B47" ref-type="bibr">Schnell <italic toggle="yes">et al.</italic>, 2009</xref>), which has been proven insecure, if additional security measures (e.g. usage of salts) are not taken (<xref rid="btaa764-B31" ref-type="bibr">Kuzu <italic toggle="yes">et al.</italic>, 2011</xref>). Another active field of research is the scalability of PPRL methods (<xref rid="btaa764-B51" ref-type="bibr">Vatsalan et al., 2017</xref>) or the incorporation of additional data types, like clinical and genomic data (<xref rid="btaa764-B3" ref-type="bibr">Baker <italic toggle="yes">et al.</italic>, 2019</xref>). In the PPRL space, <xref rid="btaa764-B34" ref-type="bibr">Laud and Pankova (2018)</xref> have recently leveraged sMPC to perform record linkage without a trusted third party for the iDASH 2017 competition. They used the Sharemind framework (<xref rid="btaa764-B6" ref-type="bibr">Bogdanov <italic toggle="yes">et al.</italic>, 2008</xref>) to perform <italic toggle="yes">exact-only</italic> matching of databases.</p>
      <sec id="btaa764-1.1.1">
        <label>1.1.1</label>
        <title>Comparison to current state-of-the-art</title>
        <p>More recently, <xref rid="btaa764-B35" ref-type="bibr">Lazrig <italic toggle="yes">et al.</italic> (2018)</xref> used sMPC and Bloom filter string comparisons with Dice-coefficients based on (<xref rid="btaa764-B47" ref-type="bibr">Schnell <italic toggle="yes">et al.</italic>, 2009</xref>) to implement probabilistic PPRL. This is similar to our approach in that they use the same methodology for fault-tolerant string matching, since the Mainzelliste software’s record linkage algorithm also uses the method by <xref rid="btaa764-B47" ref-type="bibr">Schnell <italic toggle="yes">et al.</italic> (2009)</xref>. But our work differs to theirs in several ways.</p>
        <p>They use a total of four Bloom filters, in which (fragments of) different fields are combined. Expert knowledge of probable errors is encoded in the choice of fragments and fields. In contrast, our solution takes a much more general approach by implementing the full field-tested EpiLink algorithm (<xref rid="btaa764-B13" ref-type="bibr">Contiero <italic toggle="yes">et al.</italic>, 2005</xref>) as implemented in the Mainzelliste (<xref rid="btaa764-B32" ref-type="bibr">Lablans <italic toggle="yes">et al.</italic>, 2015</xref>): fields are compared directly (and are not mixed up in the same Bloom filter), missing fields are handled properly and erroneously interchanged fields are handled by the introduction of <italic toggle="yes">exchange groups</italic> in the record linkage configuration.</p>
        <p>Furthermore, our solution performs the whole post-processing of linkage information still in sMPC, whereas Lazrig et al.’s solution reveals per Bloom filter whether it matched, which leaks information (Revealing per-field matching information can leak, e.g. that someone has a different, say, surname in the other database, because the surname Bloom filter did <italic toggle="yes">not</italic> match. Another possible attack is to query the database multiple times, each time revealing a match for another field, like family name and DOB, thus iteratively re-identifying a record over multiple queries by intersecting on different fields. The real query stays invisible to the queried database. In general, if not the whole computation is performed in sMPC, unforeseen information leak can occur from intermediate values.). Our method also resolves ties between several probabilistically matching records by determining the highest match score before evaluating the score threshold. For this, we implemented a novel quotient-ordering circuit that is able to calculate the maximum of many quotients, with its index, in sMPC. Their solution cannot resolve ties between multiple matches. Additionally, our solution compares fields like the date of birth or zip code with exact equality and combines the individual field comparisons in a weighted sum to give the final score, before evaluating the score threshold, whereas, as mentioned above, their solution only performs a threshold comparison on individual field comparisons.</p>
        <p>Hence our solution is more generally applicable and delivers a higher quality of matches (see Section 3.1 for the results and <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix SB</xref> for more details and a direct comparison to Lazrig <italic toggle="yes">et al.</italic>) and in particular contains Lazrig <italic toggle="yes">et al.</italic>’s method as a special simplistic case: Circuit <xref rid="btaa764-F9" ref-type="fig">5</xref> (Dice-coefficient) alone reflects their whole sMPC implementation (without the final threshold evaluation) while additionally being CBMC-GC-2 (<xref rid="btaa764-B8" ref-type="bibr">Buescher <italic toggle="yes">et al.</italic>, 2016</xref>) optimized. They also built a custom implementation using Yao’s Garbled Circuit whereas we use the more general sMPC-framework ABY (<xref rid="btaa764-B15" ref-type="bibr">Demmler <italic toggle="yes">et al.</italic>, 2015a</xref>) and offer four different protocol variants (cf. Section 2.3.3), so our solution can be more easily extended for future challenges regarding in-sMPC processing of match results. Also note that they did not publish their software whereas the source code of MainSEL is freely available under the AGPLv3 license. Furthermore, our solution can be deployed in hospital environments today as it is an extension of the already widely deployed Mainzelliste (<xref rid="btaa764-B32" ref-type="bibr">Lablans <italic toggle="yes">et al.</italic>, 2015</xref>) patient record management solution and comes with a complete linkage service ID management solution.</p>
        <p>Unlike Lazrig <italic toggle="yes">et al.</italic>, we choose to forego blocking mechanisms and instead compare all records, which leads to an extremely strong privacy guarantee, as many blocking techniques, especially techniques based on <italic toggle="yes">Differential Privacy</italic> (DP), are not composable with sMPC security guarantees. In fact, the security notion of DP is contrary to the sMPC security goals in the case of PPRL, as sMPC aims to reveal the correct, exact result of the ideal function and DP aims to reveal only noisy, i.e. (boundedly) approximate results. Even hybrid systems using differentially private blocking mechanisms as a pre-processing for the sMPC record linkage (<xref rid="btaa764-B28" ref-type="bibr">Inan <italic toggle="yes">et al.</italic>, 2010</xref>), like <xref rid="btaa764-B35" ref-type="bibr">Lazrig <italic toggle="yes">et al.</italic></xref>, fail to achieve strong end-to-end privacy and may reveal properties of the inputs. The proof of those statements, as well as further complications at composing DP and sMPC techniques with a focus on PPRL are discussed in <xref rid="btaa764-B26" ref-type="bibr">He <italic toggle="yes">et al.</italic> (2017)</xref>.</p>
        <p>That makes our work, to the best of our knowledge, the first practical sMPC-based probabilistic PPRL solution able to handle noisy and heterogeneous datasets which is also effectively handling incomplete data.</p>
      </sec>
    </sec>
  </sec>
  <sec id="btaa764-2">
    <label>2</label>
    <title>Materials and methods</title>
    <p>We will describe the method and our implementation in great detail, giving hospitals, data protection commissioners as well as governmental regulators the details to evaluate this novel method.</p>
    <p>In this article, the function <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo></mml:mrow></mml:math></inline-formula> denotes the logarithm to base 2. When we describe a protocol between two parties, we sometimes refer to them as Aarhus and Berlin (This is obviously inspired by the well known <italic toggle="yes">Alice</italic> and <italic toggle="yes">Bob</italic>, but changed to city names to stress the potential geographical distance of the protocol’s participants.) for increased clarity of the description.</p>
    <sec id="btaa764-2.1">
      <label>2.1</label>
      <title>Record linkage</title>
      <p>Record linkage describes the task of linking records from different data sources that belong to the same entity. In general, this may include two or more data sources. We deal with the task of peer-to-peer, that is, two-party record linkage. In this setting, classic solutions off-load the record linkage to a <italic toggle="yes">Trusted Third Party (TTP)</italic>, often called a linkage unit. Since we use secure multi-party computation, we do not require any trusted third party.</p>
      <p>Privacy-Preserving Record Linkage (PPRL) generally advances in several steps: data pre-processing, blocking/filtering, field comparisons/similarity and match classification. This is then followed by some application of the record linkage classification, e.g. the counting of matches (<italic toggle="yes">match-cardinality</italic>) or linkage of the datasets for scientific evaluations. The MainSEL software implements the field comparison, match classification and the match-cardinality application. In Section 2.4 we introduce a <italic toggle="yes">linkage service</italic> that enables the secure use of the linked datasets in arbitrary follow-up applications. Note that this service is not a TTP.</p>
      <p>Given a record <italic toggle="yes">x</italic> and a set of <italic toggle="yes">N</italic> database records <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (abbreviated <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>), we want to determine the best matching database record and quantify the match quality. To that end, we will introduce a similarity score function <italic toggle="yes">S</italic>(<italic toggle="yes">x</italic>, <italic toggle="yes">y</italic>) between two records that attains values between 0 and 1. The database record with the highest similarity score is then compared to a threshold parameter (Mainzelliste actually checks against two thresholds, leading to a more fine-grained classification. We implemented this but omit its description for brevity.) <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>T</mml:mi><mml:mo>≤</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Only if it is above this threshold, those records are identified as a match. We call this functionality <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mtext>bestMatch</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Let <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (abbreviated <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>) be a set of <italic toggle="yes">M</italic> records. For each <italic toggle="yes">x<sup>k</sup></italic>, we determine the best matching record and check whether the score reaches the threshold. The count of those matches now determines the above introduced <italic toggle="yes">match-cardinality</italic>, which we denote with <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mtext>matchCardinality</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>In summary, we care about the following two functionalities: 
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:mtext>bestMatch</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>×</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mtext>argmax</mml:mtext></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi mathvariant="normal">j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi mathvariant="normal">N</mml:mi></mml:mrow></mml:munder><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">y</mml:mi></mml:mrow><mml:mi mathvariant="normal">j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
 <disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:mtext>matchCardinality</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>k</mml:mi><mml:mo>:</mml:mo><mml:mo>∃</mml:mo><mml:mi>j</mml:mi><mml:mo>:</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>min</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
      <sec id="btaa764-2.1.1">
        <label>2.1.1</label>
        <title>Match classification score</title>
        <p>To determine the similarity score of two records, we implemented the same algorithm as used by the Mainzelliste software, which is inspired by the EpiLink software (<xref rid="btaa764-B13" ref-type="bibr">Contiero <italic toggle="yes">et al.</italic>, 2005</xref>) and resembles a threshold-based similarity join (<xref rid="btaa764-B12" ref-type="bibr">Cohen, 2000</xref>). This leads to the best possible compatibility within the German medical research ecosystem, where the Mainzelliste is the most commonly used tool for data pseudonymization in medical research networks.</p>
        <p>The similarity score <italic toggle="yes">S</italic>(<italic toggle="yes">x</italic>, <italic toggle="yes">y</italic>) of two records <italic toggle="yes">x</italic> and <italic toggle="yes">y</italic> is a normalized weighted sum of field similarities, yielding a score between 0 and 1: 
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mover><mml:mover><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">︷</mml:mo></mml:mover><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:mover><mml:mo>/</mml:mo><mml:mover><mml:mover><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">︷</mml:mo></mml:mover><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:mover><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>The two records <italic toggle="yes">x</italic> and <italic toggle="yes">y</italic> have <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>I</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> field values <italic toggle="yes">x<sub>i</sub></italic> and <italic toggle="yes">y<sub>i</sub></italic>, each, for <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">I</italic> is the field index set. <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>δ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is 1 if both fields <italic toggle="yes">x<sub>i</sub></italic> and <italic toggle="yes">y<sub>j</sub></italic> are non-empty and 0 otherwise. Similarity of fields of index <italic toggle="yes">i</italic> are determined using the functions <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, which will be described in Section 2.1.2. Following (<xref rid="btaa764-B13" ref-type="bibr">Contiero <italic toggle="yes">et al.</italic>, 2005</xref>), the weights are chosen according to the formula <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where <italic toggle="yes">e<sub>i</sub></italic> and <italic toggle="yes">f<sub>i</sub></italic> are the error rate and average frequency of values, respectively. Those values are statistically derived once for a set of fields and then fixed, see <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix SD</xref> for the values we used.</p>
        <p>Two fields are determined to match if their score is above a certain threshold. Weighting each field’s impact on the final score differently improves the score’s ability to veraciously categorize matches.</p>
        <p>We introduced the definitions <italic toggle="yes">s</italic>(<italic toggle="yes">x</italic>, <italic toggle="yes">y</italic>) and <italic toggle="yes">w</italic>(<italic toggle="yes">x</italic>, <italic toggle="yes">y</italic>) for the numerator and denominator, which we also call the field-weight and weight component of a (partial) score, because we often need to work with them individually, especially when describing the sMPC solution. The actual division <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:math></inline-formula> is never evaluated.</p>
        <p><italic toggle="yes">Tie-solving order</italic>. We often need to determine the maximum of a set of quotients, for which we introduce a special order. On quotients <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, written as numerator-denominator pairs (<italic toggle="yes">s</italic><sub>1</sub>, <italic toggle="yes">w</italic><sub>1</sub>) and (<italic toggle="yes">s</italic><sub>2</sub>, <italic toggle="yes">w</italic><sub>2</sub>), we define the <italic toggle="yes">tie-solving order</italic> a<italic toggle="yes"><sc>s</sc></italic> 
 <disp-formula id="E4"><label>(4)</label><mml:math id="M4" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>:</mml:mo><mml:mo>⇔</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>&gt;</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∨</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>∧</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>&gt;</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>which returns <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">true</mml:mi></mml:mrow></mml:math></inline-formula> even if the quotients are the same, but numerator and denominator of the left quotient are nominally larger. This makes sense for our application because if the left field-weight/weight quotient is nominally larger, then more entries contributed to its score (i.e. more entries of the right quotient were empty). It also solves the problem of zero denominators, favoring the quotient with non-zero denominator in such a case. If both are zero, it does not matter which one is chosen by this order, as the contribution to a sum would then be zero anyway.</p>
        <p><italic toggle="yes">Exchange groups</italic>. In real record linkage scenarios, linkage quality can be improved by grouping some fields into so-called <italic toggle="yes">exchange groups</italic>, like <italic toggle="yes">first, sur-</italic> and <italic toggle="yes">birth name</italic>. Such fields may be accidentally swapped when entered. The score <xref rid="E3" ref-type="disp-formula">(3)</xref> is now modified to pairwise compare all fields of an exchange group.</p>
        <p>Let <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mtext>Sym</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denote the set of all permutations of a set <italic toggle="yes">G</italic>, its <italic toggle="yes">symmetric group</italic>. It has size <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo><mml:mo>!</mml:mo></mml:mrow></mml:math></inline-formula>. We introduce the following useful definitions of the sum of weighted similarity scores and sum of weights for an exchange group <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>⊂</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:math></inline-formula> and permutation <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>∈</mml:mo><mml:mtext>Sym</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>: 
<disp-formula id="E5"><label>(5)</label><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>G</mml:mi><mml:mo>σ</mml:mo></mml:msubsup></mml:mrow><mml:mrow><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mo>δ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>G</mml:mi><mml:mo>σ</mml:mo></mml:msubsup></mml:mrow><mml:mrow><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mo>δ</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
        <p>A group <italic toggle="yes">G</italic>’s sub-score for permutation <italic toggle="yes">σ</italic> is now defined as <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>G</mml:mi><mml:mo>σ</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>G</mml:mi><mml:mo>σ</mml:mo></mml:msubsup><mml:mo>/</mml:mo><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>G</mml:mi><mml:mo>σ</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. Note that all fields in <italic toggle="yes">G</italic> must be of the same comparison type and that <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>I</mml:mi><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>. The score <italic toggle="yes">S<sub>G</sub></italic> for a group <italic toggle="yes">G</italic> is now determined as the maximum of all sub-scores for all permutations, using the tie-solving order <xref rid="E4" ref-type="disp-formula">(4)</xref>: 
<disp-formula id="E6"><label>(6)</label><mml:math id="M6" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>G</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>G</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>G</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mo>σ</mml:mo><mml:mo>∈</mml:mo><mml:mtext>Sym</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>G</mml:mi><mml:mo>σ</mml:mo></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>G</mml:mi><mml:mo>σ</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>Let <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo> </mml:mo></mml:mrow></mml:math></inline-formula> be the set of all exchange groups and <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo> </mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>I</mml:mi><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mo>∪</mml:mo></mml:mrow><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo> </mml:mo></mml:mrow></mml:msub><mml:mi>G</mml:mi></mml:mrow></mml:math></inline-formula> those fields not in any exchange group. Our final similarity score of two records <italic toggle="yes">x</italic> and <italic toggle="yes">y</italic> now become<italic toggle="yes"><sc>s</sc></italic> 
 <disp-formula id="E7"><label>(7)</label><mml:math id="M7" display="block" overflow="scroll"><mml:mtable><mml:mtr><mml:mtd><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo> </mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>G</mml:mi></mml:msub></mml:mrow><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo> </mml:mo></mml:mrow><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>G</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi><mml:mo> </mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>G</mml:mi></mml:msub></mml:mrow><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>I</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo> </mml:mo></mml:mrow><mml:mrow><mml:mtext>id</mml:mtext></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>where <italic toggle="yes">s<sub>G</sub></italic> and <italic toggle="yes">w<sub>G</sub></italic> are the numerator and denominator of the group scores <italic toggle="yes">S<sub>G</sub></italic>, as defined in <xref rid="E6" ref-type="disp-formula">Eq. (6)</xref>.</p>
      </sec>
      <sec id="btaa764-2.1.2">
        <label>2.1.2</label>
        <title>Field comparison</title>
        <p>Depending on the field type of field <italic toggle="yes">i</italic>, we use either simple equality or Dice-coefficients of Bloom filters (<xref rid="btaa764-B5" ref-type="bibr">Bloom, 1970</xref>) (introduced below) as the measure of similarity <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Equality comparison is applied to numeric and other data fields where no matching fault tolerance is wanted. It simply assigns 1 to fields that are exactly the same and 0 otherwise.</p>
        <p><italic toggle="yes">Bloom filter dice similarity</italic>. The Bloom filter Dice similarity from Schnell <italic toggle="yes">et al.</italic> (2009) is applied to string fields like <italic toggle="yes">first</italic> and <italic toggle="yes">surname</italic> where fault tolerance is desired. Strings <italic toggle="yes">x</italic> are converted into a Bloom filter <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mtext>Bl</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by tokenizing them into bigrams and then applying a family of hash functions to the bigrams, thereby setting the bits in the Bloom filter bitmask. Further details can be found in <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix SA</xref>.</p>
        <p>Let Hw denote the <italic toggle="yes">Hamming-weight</italic>, that is, the number of set bits of a bit vector and <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo>∧</mml:mo><mml:mi>Y</mml:mi></mml:mrow></mml:math></inline-formula> denote bitwise AND of the bit vectors <italic toggle="yes">X</italic> and <italic toggle="yes">Y</italic>. Write <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mtext>Hw</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>Bl</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for the Hamming-weight of the Bloom filter of string <italic toggle="yes">x</italic> and <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>∧</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mtext>Hw</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>Bl</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∧</mml:mo><mml:mtext>Bl</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Using the <italic toggle="yes">Sørensen-Dice</italic>-coefficient (<xref rid="btaa764-B17" ref-type="bibr">Dice, 1945</xref>), the similarity of two strings is now calculated a<italic toggle="yes"><sc>s</sc></italic> 
 <disp-formula id="E8"><label>(8)</label><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>string</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>·</mml:mo><mml:mtext>Hw</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>Bl</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∧</mml:mo><mml:mtext>Bl</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mtext>Hw</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>Bl</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mtext>Hw</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>Bl</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>∧</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>y</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>The Dice-coefficient has the advantage of being insensitive to the number of zero bits, of which there will be many for a large Bloom filter. It captures the <italic toggle="yes">relative</italic> similarity of strings. An example is shown in <xref rid="btaa764-F1" ref-type="fig">Figure 1</xref>. Note that the Dice-coefficient could also have been applied directly to the bigrams of two strings in a similar way. Unlike many other PPRL algorithms, we do not rely on Bloom filters for increased privacy of the input data (In fact, it has been shown insecure by <xref rid="btaa764-B10" ref-type="bibr">Christen <italic toggle="yes">et al.</italic> (2017)</xref>). For privacy, we rely on sMPC instead, and Bloom filters are only used because they can be evaluated more easily in sMPC than bigrams.</p>
        <fig position="float" id="btaa764-F1">
          <label>Fig. 1.</label>
          <caption>
            <p>Visual example of a Bloom filter-based Dice similarity measurement between the strings ‘SMITH’ and ‘SMYTHS’. Differences in the set bits are colored. This example assumes <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>2 independent hash functions and a 12 bit Bloom filter. Note that a change of one letter leads to at most 2<italic toggle="yes">k</italic> changes in the Bloom filter. This means that small changes in the strings lead to small changes in the bit vector</p>
          </caption>
          <graphic xlink:href="btaa764f1" position="float"/>
        </fig>
      </sec>
    </sec>
    <sec id="btaa764-2.2">
      <label>2.2</label>
      <title>Secure multi-party computation</title>
      <p>The central component of our system is based on a technique called <italic toggle="yes">secure multi-party computation (sMPC)</italic>. While the foundations of this subfield of cryptography were laid in the 1980s (<xref rid="btaa764-B24" ref-type="bibr">Goldreich <italic toggle="yes">et al.</italic>, 1987</xref>; <xref rid="btaa764-B54" ref-type="bibr">Yao, 1986</xref>), it has long been considered impractical due to the large computational overhead. This changed in the early 2000s, with cryptographic breakthroughs such as Oblivious Transfer Extensions (<xref rid="btaa764-B29" ref-type="bibr">Ishai <italic toggle="yes">et al.</italic>, 2003</xref>) and the first implementation of generic two-party computation (<xref rid="btaa764-B38" ref-type="bibr">Malkhi <italic toggle="yes">et al.</italic>, 2004</xref>). Since then, a variety of sMPC frameworks have been developed (<xref rid="btaa764-B6" ref-type="bibr">Bogdanov <italic toggle="yes">et al.</italic>, 2008</xref>; <xref rid="btaa764-B14" ref-type="bibr">Damgrd <italic toggle="yes">et al.</italic>, 2012</xref>; <xref rid="btaa764-B15" ref-type="bibr">Demmler <italic toggle="yes">et al.</italic>, 2015a</xref>; <xref rid="btaa764-B56" ref-type="bibr">Zahur and Evans, 2015</xref>). In this work, we rely on the ABY framework (<xref rid="btaa764-B15" ref-type="bibr">Demmler <italic toggle="yes">et al.</italic>, 2015a</xref>) for secure two-party computation.</p>
      <p>ABY implements three approaches to two-party computations: Yao’s Garbled Circuit (<xref rid="btaa764-B54" ref-type="bibr">Yao, 1986</xref>), the GMW protocol (<xref rid="btaa764-B24" ref-type="bibr">Goldreich <italic toggle="yes">et al.</italic>, 1987</xref>) and Arithmetic Sharing, as well as transformations of intermediate values between them. These protocols and their security assumptions are outlined in <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix SC</xref>.</p>
      <p>This allows us to freely combine those techniques, as some operations are more efficient in a specific sMPC protocol. In Section 2.3, we will present the details of our circuit designs and in Section 3.4 we explore how different combinations of sMPC protocols affect the running time of our implementation.</p>
      <sec id="btaa764-2.2.1">
        <label>2.2.1</label>
        <title>Threat model and privacy goals</title>
        <p>Ideally, we would like to guarantee that in our system, no information about the input data can be learned by anyone at all. However, this definition of privacy is not very useful, since the output of any meaningful computation necessarily contains information about the inputs. Therefore, the cryptographic definition of privacy for sMPC protocols draws an analogy to a Trusted Third Party (TTP): Informally, a distributed protocol is said to <italic toggle="yes">privately implement</italic> an <italic toggle="yes">ideal functionality f</italic>, if the information revealed by the protocol is the same as what would be revealed if a TTP had computed <italic toggle="yes">f</italic>. We omit a formal definition here and instead refer to <xref rid="btaa764-B23" ref-type="bibr">Goldreich (2004)</xref>. The ideal functionalities considered in this work are <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mtext>bestMatch</mml:mtext></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mtext>matchCardinality</mml:mtext></mml:mrow></mml:math></inline-formula> from <xref rid="E1" ref-type="disp-formula">Eqs. (1)</xref> and <xref rid="E2" ref-type="disp-formula">(2)</xref>.</p>
        <p>Throughout this article, we will focus on the <italic toggle="yes">semi-honest</italic> or <italic toggle="yes">honest-but-curious</italic> attacker model. In this setting, protocols aim to be secure against an attacker who correctly follows the protocol, but additionally tries to learn as much as possible about the other parties’ inputs and outputs. While stronger security models (such as <italic toggle="yes">covert</italic> or <italic toggle="yes">malicious</italic> adversaries) exist, the semi-honest model is a good fit in a setting as ours, where the parties are regulated by law and known in advance.</p>
        <p>While the inputs of the parties participating in an sMPC protocol remain secure, the input <italic toggle="yes">sizes</italic> (i.e. the number of records to be linked) need to be known in advance. However, in cases where this information is still considered sensitive, the parties can pad their databases with dummy elements to any reasonable upper bound on the size, thus hiding the actual size, at the expense of increased computational complexity.</p>
        <p>Summing up ABY’s security assumptions (cf. <xref rid="sup1" ref-type="supplementary-material">SC.3</xref>), the weakest link in the security of our ABY implementation is, apart from supporting only the semi-honest attacker model, the reliance on the quantum-insecure CDH assumption. Accepting this assumption, our implementation guarantees that each party of the sMPC does not learn anything about the other party’s input or any intermediate calculation. They only learn what is specified as the ideal functionality’s output: in the single-record-linkage mode of operation (<inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mtext>bestMatch</mml:mtext></mml:mrow></mml:math></inline-formula>), they each learn one part of an XOR sharing of the matching record’s index together with the match bit. This is then forwarded to the linkage service as described in Section 2.4 for further processing. Each XOR share looks just like random data to each party. In the match-cardinality mode of operation (<inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mtext>matchCardinality</mml:mtext></mml:mrow></mml:math></inline-formula>), both parties only learn the number of matches.</p>
      </sec>
    </sec>
    <sec id="btaa764-2.3">
      <label>2.3</label>
      <title>Circuit design</title>
      <p>In order to calculate the main functionalities <xref rid="E1" ref-type="disp-formula">(1)</xref> and <xref rid="E2" ref-type="disp-formula">(2)</xref> in a sMPC with ABY, they have to be expressed as circuits. The following sections give an in-depth description of the circuit designs of the score calculation <xref rid="E7" ref-type="disp-formula">(7)</xref> and how to determine the maximum of those scores, which leads to <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mtext>bestMatch</mml:mtext></mml:mrow></mml:math></inline-formula>  <xref rid="E1" ref-type="disp-formula">(1)</xref>. We choose to work in fixed-point arithmetic because it is more efficient for our purpose, although floating-point calculations are partially possible in ABY (<xref rid="btaa764-B16" ref-type="bibr">Demmler <italic toggle="yes">et al.</italic>, 2015b</xref>).</p>
      <p>When expressing algorithms in a circuit, it cannot have dynamic control flow, because otherwise information of intermediary results would leak. Thus, all branches have to be evaluated and all loops have to be unrolled. For efficiency reasons, all unrolled loops are executed in parallel and all sums are calculated as balanced binary-trees to minimize the circuit depth.</p>
      <p>Because we lack dynamic control flow, we decided to not apply blocking mechanisms, as is usually done in record linkage pipelines. Blocking describes the pre-filtering of records such that less records need to be fully compared. We also have to evaluate all field similarities, even if either field is empty (in which case this pair of fields does not contribute to the score).</p>
      <p>Given a record <italic toggle="yes">x</italic> by Aarhus and the records <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> by Berlin, the circuit<statement id="btaa764-mthst1"><label>C 1. </label><p>calculates all scores’ numerators <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and denominators <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>  <italic toggle="yes">(</italic>cf. <xref rid="E7" ref-type="disp-formula">eq. (7)</xref>),</p></statement><statement id="btaa764-mthst2"><label>C 2. </label><p>determines the highest score and its index <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mtext>arg</mml:mtext><mml:msub><mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow><mml:mi mathvariant="normal">j</mml:mi></mml:msub><mml:mi mathvariant="normal">S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="normal">y</mml:mi></mml:mrow><mml:mi mathvariant="normal">j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>,</p></statement><statement id="btaa764-mthst3"><label>C 3. </label><p>tests for a match by calculating the <italic toggle="yes">match bit</italic></p></statement>
 <disp-formula id="E9"><mml:math id="M9" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>⇔</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>T</mml:mi><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>otherwise</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>It is more efficient to calculate the field-weight- and weight-sums <italic toggle="yes">s</italic> and <italic toggle="yes">w</italic> in parallel, use them for (C2) and (C3) and never actually calculate the divisions <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:math></inline-formula>. The steps (C1)–(C3) combined completely implement the functionality <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mtext>bestMatch</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. If Aarhus now has <italic toggle="yes">M</italic> records <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and they want to compute the <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mtext>matchCardinality</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, they compute <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mtext>bestMatch</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all <italic toggle="yes">k</italic> and then simply sum the match bits.</p>
      <sec id="btaa764-2.3.1">
        <label>2.3.1</label>
        <title>Notation</title>
        <p>To describe the individual circuit components, we introduce the notation <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">x</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to say that <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">x</mml:mi></mml:math></inline-formula> is the encoding of value <italic toggle="yes">x</italic> as a circuit input or the circuit implementation of function <italic toggle="yes">x</italic>. Sans-serif font is used for circuit variables, typewriter for circuit functions/algorithms. We define <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">bitlen</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="sans-serif">bitlen</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="sans-serif">bitlen</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:math></inline-formula>, for <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">x</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">x</mml:mi><mml:mo>:</mml:mo><mml:mo>*</mml:mo><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mi>l</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. We sometimes abbreviate the three sMPC protocols Arithmetic Sharing, GMW and Yao with <italic toggle="yes">A</italic>, <italic toggle="yes">B</italic> and <italic toggle="yes">Y</italic> (This adheres to the notation of ABY.), respectively, and denote the spaces of values of bit-length <italic toggle="yes">l</italic> in those protocols as <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">S</mml:mi></mml:mrow><mml:mi>A</mml:mi><mml:mi>l</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">S</mml:mi></mml:mrow><mml:mi>B</mml:mi><mml:mi>l</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">S</mml:mi></mml:mrow><mml:mi>Y</mml:mi><mml:mi>l</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>. We also introduce the annotation <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>x</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:mrow><mml:mi>p</mml:mi><mml:mi>l</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> of a variable’s or function’s output bit-length <italic toggle="yes">l</italic> and protocol <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> or <italic toggle="yes">Y</italic>. It is mainly relevant to the discussion in Section 2.3.5. The superscript bit-length <italic toggle="yes">l</italic> or subscript protocol <italic toggle="yes">p</italic> are sometimes omitted for brevity.</p>
      </sec>
      <sec id="btaa764-2.3.2">
        <label>2.3.2</label>
        <title>Fixed-point representation</title>
        <p>We start by introducing the fixed-point presentations of weights and field similarities, which are the only two real number variables in the similarity score. Let <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="sans-serif">bitlen</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the <italic toggle="yes">weight precision</italic> and <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="sans-serif">bitlen</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the <italic toggle="yes">similarity</italic> or <italic toggle="yes">Dice precision</italic>, which is the same for all fields <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        <p>The field similarity measures <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> output real numbers between 0 and 1. So their fixed-point representations are calculated as <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>⌊</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>·</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:msup><mml:mo>⌉</mml:mo></mml:mrow></mml:math></inline-formula>. In case of equality, which outputs either 0 or 1, this is just a left-shift by <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:math></inline-formula>. The circuit implementation of the Bloom filter Dice-coefficient <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>string</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> uses a custom integer-division where the numerator is left-shifted by <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:math></inline-formula> before the integer-division to give a result between 0 and <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
        <p>Similarly, the real-valued threshold <italic toggle="yes">T</italic> is multiplied with <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> and rounded to the nearest integer to attain its fixed-point representation, <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">T</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>⌊</mml:mo><mml:mi>T</mml:mi><mml:mo>·</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:msup><mml:mo>⌉</mml:mo></mml:mrow></mml:math></inline-formula>. It is necessary to scale the threshold together with the field similarities to make inequality (C3) work.</p>
        <p>The real weights <inline-formula id="IE66"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> are transformed into numbers <inline-formula id="IE67"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> by rescaling them so that the highest weight has value <inline-formula id="IE68"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and then rounding to the nearest integer: 
<disp-formula id="E10"><label>(9)</label><mml:math id="M10" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>⌊</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo stretchy="true">(</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true">)</mml:mo><mml:mo>⌉</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>This leads to the highest possible precision because the weights occupy the full range of <inline-formula id="IE69"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec id="btaa764-2.3.3">
        <label>2.3.3</label>
        <title>Implementation variations</title>
        <p>As has been shown (<xref rid="btaa764-B15" ref-type="bibr">Demmler <italic toggle="yes">et al.</italic>, 2015a</xref>), using different protocols for different kinds of calculations with intermediate conversions may be more efficient than staying in the same protocol, even if this incurs additional conversion costs. We therefore implemented four variations of the circuit, choosing different sMPC protocols for Boolean/logic (protocol <inline-formula id="IE70"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula>) and arithmetic (protocol <inline-formula id="IE71"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula>) components of the circuit, with possible conversions in between where necessary. Points of possible conversions are denoted with <inline-formula id="IE72"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mn>2</mml:mn><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE73"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mn>2</mml:mn><mml:mo>α</mml:mo></mml:mrow></mml:math></inline-formula>. Note that they are <italic toggle="yes">no operation</italic> if the same protocol is chosen for <inline-formula id="IE74"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> and <inline-formula id="IE75"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula>.</p>
        <p>For the Boolean/logic components, either the GMW or Yao’s Garbled Circuit protocol were selected, i.e. <inline-formula id="IE76"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>=</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> or <italic toggle="yes">Y</italic>. Additionally, for the arithmetic circuit components, we either stayed in the same protocol <inline-formula id="IE77"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula>, or converted to Arithmetic Sharing, i.e. <inline-formula id="IE78"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula> or <italic toggle="yes">A</italic>. This results in the following four circuit variants.</p>
        <p><inline-formula id="IE79"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW</mml:mi></mml:mrow></mml:math></inline-formula>: <inline-formula id="IE80"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>=</mml:mo><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>, i.e. the whole circuit implemented in the GMW protocol.</p>
        <p><inline-formula id="IE81"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW/A</mml:mi></mml:mrow></mml:math></inline-formula>: <inline-formula id="IE82"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>=</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE83"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:math></inline-formula>, i.e. Boolean/logic components implemented in the GMW protocol and arithmetic components in Arithmetic Sharing.</p>
        <p><inline-formula id="IE84"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">Yao</mml:mi></mml:mrow></mml:math></inline-formula>: <inline-formula id="IE85"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>=</mml:mo><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mi>Y</mml:mi></mml:mrow></mml:math></inline-formula>, i.e. the whole circuit implemented in Yao’s Garbled Circuit.</p>
        <p><inline-formula id="IE86"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">Yao/A</mml:mi></mml:mrow></mml:math></inline-formula>: <inline-formula id="IE87"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>=</mml:mo><mml:mi>Y</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE88"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:math></inline-formula>, i.e. Boolean/logic components implemented in Yao’s Garbled Circuit and arithmetic components in Arithmetic Sharing.</p>
        <p>Specifically, Circuits <xref rid="btaa764-F6" ref-type="fig">2</xref> and <xref rid="btaa764-F7" ref-type="fig">3</xref> are of arithmetic nature while Circuits <xref rid="btaa764-F8" ref-type="fig">4</xref> and <xref rid="btaa764-F9" ref-type="fig">5</xref> are of Boolean nature. Circuit <xref rid="btaa764-F10" ref-type="fig">6</xref> is of mixed nature: after two multiplications, several Boolean operations are performed.</p>
      </sec>
      <sec id="btaa764-2.3.4">
        <label>2.3.4</label>
        <title>Circuit components</title>
        <p>We now describe the circuit implementations to attain results (C1)–(C3). Inputs are only mentioned in the circuit sub-component where they are used, thus omitted in superordinate components. Private inputs by Aarhus and Berlin are stated as semicolon-delimited pairs. A high-level overview of the circuit layout is shown with Circuit <xref rid="btaa764-F5" ref-type="fig">1</xref>.</p>
        <p>Now follows the description of the circuit implementation of <inline-formula id="IE89"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">Score</mml:mi></mml:mrow></mml:math></inline-formula> with its sub-components for a single pair of records <inline-formula id="IE90"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">x</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE91"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">y</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">y</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as private inputs by Aarhus and Berlin, respectively. For brevity, we omit the record index <italic toggle="yes">j</italic> for Berlin ’s input <inline-formula id="IE92"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="sans-serif">y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> as only a single pair of records is relevant in the remaining section. Remember that <inline-formula id="IE93"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">z</mml:mi></mml:mrow><mml:mi mathvariant="sans-serif">i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denotes an <italic toggle="yes">individual field</italic> of a single record <inline-formula id="IE94"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">z</mml:mi></mml:math></inline-formula>.</p>
        <p>Circuit <xref rid="btaa764-F6" ref-type="fig">2</xref> (<inline-formula id="IE95"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">Score</mml:mi></mml:mrow></mml:math></inline-formula>) calculates the score numerators <inline-formula id="IE96"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">s</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and denominators <inline-formula id="IE97"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">w</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in parallel, in protocol <inline-formula id="IE98"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> [cf. <xref rid="E7" ref-type="disp-formula">Eq. (7)</xref>]. It uses the sub-components <inline-formula id="IE99"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">GroupFieldWeight</mml:mi></mml:mrow></mml:math></inline-formula> (Circuit <xref rid="btaa764-F7" ref-type="fig">3</xref>) for the calculation of a group’s sub-score and <inline-formula id="IE100"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">MaxQuotient</mml:mi></mml:mrow></mml:math></inline-formula> to determine the score for each group, i.e. the maximum over all group sub-scores [cf. <xref rid="E6" ref-type="disp-formula">Eq. (6)</xref>].</p>
        <fig position="float" id="btaa764-F6">
          <label>Circuit 2:</label>
          <caption>
            <p><inline-formula id="IE101"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">Score</mml:mi></mml:mrow></mml:math></inline-formula>: similarity score (C1) of <inline-formula id="IE102"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">x</mml:mi></mml:math></inline-formula> and <inline-formula id="IE103"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">y</mml:mi></mml:math></inline-formula> [<xref rid="E7" ref-type="disp-formula">Eq. (7)</xref> in protocol <inline-formula id="IE104"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula>].</p>
          </caption>
          <graphic xlink:href="btaa764f6" position="float"/>
        </fig>
        <fig position="float" id="btaa764-F7">
          <label>Circuit 3:</label>
          <caption>
            <p><inline-formula id="IE105"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">GroupFieldWeight</mml:mi></mml:mrow></mml:math></inline-formula> [<xref rid="E5" ref-type="disp-formula">Eq. (5)</xref> in protocol <inline-formula id="IE106"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula>]. The empty-bits <inline-formula id="IE107"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>δ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mi>z</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> are 0 if entry <italic toggle="yes">i</italic> of record <italic toggle="yes">z</italic> is empty and 1 otherwise. If any entry is empty, then <inline-formula id="IE108"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">w</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Note that if <inline-formula id="IE109"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> or <italic toggle="yes">Y</italic>, the multiplication between the <italic toggle="yes">δ</italic>’s in line 2 is a logical AND.</p>
          </caption>
          <graphic xlink:href="btaa764f7" position="float"/>
        </fig>
        <p><italic toggle="yes">Similarity circuits</italic>. The field similarity <inline-formula id="IE110"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">sim</mml:mi></mml:mrow></mml:math></inline-formula> applies either the simple equality Circuit <xref rid="btaa764-F8" ref-type="fig">4</xref> or the Bloom filter Dice-coefficient Circuit <xref rid="btaa764-F9" ref-type="fig">5</xref> on field entries <inline-formula id="IE111"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">y</mml:mi></mml:mrow><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, depending on their type. If field <italic toggle="yes">i</italic> has Dice similarity type, we use the field entry’s Bloom filter as the input to the circuit, <inline-formula id="IE112"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>Bl</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which can be computed locally. The bit-length of field <italic toggle="yes">i</italic> is denoted by <inline-formula id="IE113"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">l</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">b</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        <fig position="float" id="btaa764-F8">
          <label>Circuit 4:</label>
          <caption>
            <p><inline-formula id="IE114"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">equal</mml:mi></mml:mrow></mml:math></inline-formula> (in protocol <inline-formula id="IE115"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula>). </p>
          </caption>
          <graphic xlink:href="btaa764f8" position="float"/>
        </fig>
        <p>Note that both circuits output the similarity as values in protocol <inline-formula id="IE116"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula> of fixed-point precision <inline-formula id="IE117"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:math></inline-formula>. Free bit-shifts were used for multiplication or division by 2. The marked component of the <inline-formula id="IE118"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">dice</mml:mi></mml:mrow></mml:math></inline-formula> circuit was created using the CBMC-GC-2 compiler (<xref rid="btaa764-B8" ref-type="bibr">Buescher <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btaa764-B21" ref-type="bibr">Franz <italic toggle="yes">et al.</italic>, 2014</xref>) on the function <inline-formula id="IE119"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>↦</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>≪</mml:mo><mml:mi mathvariant="sans-serif">ls</mml:mi><mml:mo>+</mml:mo><mml:mi>y</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which is rounding integer division (‘/’ and <inline-formula id="IE120"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">IntDiv</mml:mi></mml:mrow></mml:math></inline-formula> denotes C integer division). A separate circuit was compiled for all feasible input and output bit-lengths <inline-formula id="IE121"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>≤</mml:mo><mml:mi mathvariant="sans-serif">lh</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mn>12</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE122"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>≤</mml:mo><mml:mi mathvariant="sans-serif">ls</mml:mi><mml:mo>≤</mml:mo><mml:mn>22</mml:mn><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mn>64</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, covering Bloom filters of length up to 2047. The Hamming-weight of a Bloom filter <inline-formula id="IE123"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">z</mml:mi></mml:math></inline-formula> needs <inline-formula id="IE124"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lh</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">lb</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> bits, being the sum of <inline-formula id="IE125"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lb</mml:mi></mml:mrow></mml:math></inline-formula> many 1-bit numbers.</p>
        <p><italic toggle="yes">Maximum quotient circuit</italic>. Remember that a group’s sub-score is the quotient <inline-formula id="IE126"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="sans-serif">s</mml:mi></mml:mrow><mml:mi>G</mml:mi><mml:mo>σ</mml:mo></mml:msubsup><mml:mo>/</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="sans-serif">w</mml:mi></mml:mrow><mml:mi>G</mml:mi><mml:mo>σ</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. As described in Section 2.1.1, a group’s score is the maximum of those sub-scores [cf. <xref rid="E6" ref-type="disp-formula">Eq. (6)</xref>] and is determined by evaluating a fold with the tie-solving order as defined in <xref rid="E4" ref-type="disp-formula">eq. (4)</xref>. This order is implemented in Circuit <xref rid="btaa764-F10" ref-type="fig">6</xref>, which outputs the larger of two quotients, together with its index.</p>
        <fig position="float" id="btaa764-F10">
          <label>Circuit 6:</label>
          <caption>
            <p><inline-formula id="IE127"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">MaxQuotient</mml:mi><mml:mo>′</mml:mo><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>→</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula> (maximum of two quotients with index in mixed protocols). It is <inline-formula id="IE128"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mi>Q</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">S</mml:mi></mml:mrow><mml:mo>α</mml:mo></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">S</mml:mi></mml:mrow><mml:mo>α</mml:mo></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">S</mml:mi></mml:mrow><mml:mo>β</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> for the space of quotients together with their indices and <inline-formula id="IE129"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">Mux</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">c</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">a</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> returns <inline-formula id="IE130"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">a</mml:mi></mml:math></inline-formula> if <inline-formula id="IE131"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">c</mml:mi></mml:math></inline-formula> is 1 and <inline-formula id="IE132"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">b</mml:mi></mml:math></inline-formula> otherwise (<inline-formula id="IE133"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">c</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>).</p>
          </caption>
          <graphic xlink:href="btaa764f10" position="float"/>
        </fig>
        <p>Note that the index is not needed for the calculation of a group weight, but will later be used when calculating the maximum over all scores to determine the best match in Circuit <xref rid="btaa764-F5" ref-type="fig">1</xref>.</p>
        <p>Now the actual <inline-formula id="IE134"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">MaxQuotient</mml:mi></mml:mrow></mml:math></inline-formula> circuit is the binary-tree fold of a list of quotients using <inline-formula id="IE135"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">MaxQuotient</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> as the fold operation.</p>
      </sec>
      <sec id="btaa764-2.3.5">
        <label>2.3.5</label>
        <title>Precision choices and overflow prevention</title>
        <p>It follows a discussion about the chosen bit-length <italic toggle="yes">L</italic> for arithmetic circuit components and the resulting fixed-point precisions <inline-formula id="IE136"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE137"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:math></inline-formula> to prevent overflows. The weight sum <inline-formula id="IE138"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of Circuit <xref rid="btaa764-F6" ref-type="fig">2</xref> is a sum of <italic toggle="yes">n</italic> weights of bit-length <inline-formula id="IE139"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi></mml:mrow></mml:math></inline-formula> and as such has length <inline-formula id="IE140"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi mathvariant="sans-serif">lw</mml:mi></mml:mrow></mml:math></inline-formula>. Similarly <inline-formula id="IE141"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has length <inline-formula id="IE142"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mi mathvariant="sans-serif">lw</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:math></inline-formula>. However, the largest values that are created in any arithmetic circuit component are the <inline-formula id="IE143"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">z</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>’s of Circuit <xref rid="btaa764-F10" ref-type="fig">6</xref>, line <xref rid="btaa764-F10" ref-type="fig">1</xref>. Multiplying <inline-formula id="IE144"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">s</mml:mi></mml:math></inline-formula> with <inline-formula id="IE145"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">w</mml:mi></mml:math></inline-formula> means multiplying a sum of <italic toggle="yes">n</italic> weights of length <inline-formula id="IE146"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi></mml:mrow></mml:math></inline-formula> with a sum of <italic toggle="yes">n</italic> field-weights of length <inline-formula id="IE147"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:math></inline-formula>, resulting in a variable of bit-length <inline-formula id="IE148"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi mathvariant="sans-serif">lw</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:math></inline-formula>. Hence <inline-formula id="IE149"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE150"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:math></inline-formula> are chosen such that the bit-length <italic toggle="yes">L</italic> of space <inline-formula id="IE151"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">S</mml:mi></mml:mrow><mml:mo>α</mml:mo><mml:mi>L</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is fully used but no overflows occur (ABY supports <inline-formula id="IE152"><mml:math id="IM151" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>8</mml:mn><mml:mo>,</mml:mo><mml:mn>16</mml:mn><mml:mo>,</mml:mo><mml:mn>32</mml:mn><mml:mo>,</mml:mo><mml:mn>64</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE153"><mml:math id="IM152" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula> Arithmetic Sharing): we have <inline-formula id="IE154"><mml:math id="IM153" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> bits left to distribute to <inline-formula id="IE155"><mml:math id="IM154" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE156"><mml:math id="IM155" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi></mml:mrow></mml:math></inline-formula>. To distribute them evenly and, at the same time, not waste a bit, we set <inline-formula id="IE157"><mml:math id="IM156" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">ls</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE158"><mml:math id="IM157" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo> </mml:mo><mml:mi>mod</mml:mi><mml:mo> </mml:mo><mml:mn>3</mml:mn><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE159"><mml:math id="IM158" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">ls</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> otherwise.</p>
        <p>We compared the fixed-point score calculation as implemented in our circuits to the same calculation done in double floating point precision on a large number of random inputs. The observed deviations are &lt; 1% for <inline-formula id="IE160"><mml:math id="IM159" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>16</mml:mn><mml:mo> </mml:mo><mml:mtext>bit</mml:mtext></mml:mrow></mml:math></inline-formula>, &lt; 0.1% for <inline-formula id="IE161"><mml:math id="IM160" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>32</mml:mn><mml:mo> </mml:mo><mml:mtext>bit</mml:mtext></mml:mrow></mml:math></inline-formula> and negligible for <inline-formula id="IE162"><mml:math id="IM161" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>64</mml:mn><mml:mo> </mml:mo><mml:mtext>bit</mml:mtext></mml:mrow></mml:math></inline-formula>. Most reported benchmarks in Section 3 were performed with <italic toggle="yes">L </italic>=<italic toggle="yes"> </italic>32 and <italic toggle="yes">n </italic>=<italic toggle="yes"> </italic>8 fields, such that <inline-formula id="IE163"><mml:math id="IM162" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">lw</mml:mi><mml:mo>=</mml:mo><mml:mn>9</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE164"><mml:math id="IM163" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">ls</mml:mi><mml:mo>=</mml:mo><mml:mn>8</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
        <fig position="float" id="btaa764-F5">
          <label>Circuit 1:</label>
          <caption>
            <p>High-level circuit calculating (C1)–(C3), thus implementing functionality <inline-formula id="IE165"><mml:math id="IM164" display="inline" overflow="scroll"><mml:mrow><mml:mtext>bestMatch</mml:mtext></mml:mrow></mml:math></inline-formula>. The scores <inline-formula id="IE166"><mml:math id="IM165" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="sans-serif">y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>  <italic toggle="yes">(</italic>result (C1)) are calculated by running Circuit <xref rid="btaa764-F6" ref-type="fig">2</xref> (<inline-formula id="IE167"><mml:math id="IM166" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">Score</mml:mi></mml:mrow></mml:math></inline-formula>) for all record input pairs <inline-formula id="IE168"><mml:math id="IM167" display="inline" overflow="scroll"><mml:mi mathvariant="sans-serif">x</mml:mi></mml:math></inline-formula> and <inline-formula id="IE169"><mml:math id="IM168" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="sans-serif">y</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> from Aarhus and Berlin, respectively, in parallel. The best match (C2) is then determined by running circuit <inline-formula id="IE170"><mml:math id="IM169" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">MaxQuotient</mml:mi></mml:mrow></mml:math></inline-formula> on all scores, which is a balanced binary-tree fold of Circuit <xref rid="btaa764-F10" ref-type="fig">6</xref>. Finally, the match bit (C3) is determined by evaluating inequality <inline-formula id="IE171"><mml:math id="IM170" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="sans-serif">y</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="sans-serif">j</mml:mi></mml:mrow><mml:mi mathvariant="sans-serif">*</mml:mi></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mi mathvariant="sans-serif">Tw</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="sans-serif">x</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="sans-serif">y</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="sans-serif">j</mml:mi></mml:mrow><mml:mi mathvariant="sans-serif">*</mml:mi></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> on the best match.</p>
          </caption>
          <graphic xlink:href="btaa764f5" position="float"/>
        </fig>
        <fig position="float" id="btaa764-F9">
          <label>Circuit 5:</label>
          <caption>
            <p><inline-formula id="IE172"><mml:math id="IM171" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="monospace">dice</mml:mi></mml:mrow></mml:math></inline-formula> [<xref rid="E8" ref-type="disp-formula">Eq. (8)</xref> in protocol <inline-formula id="IE173"><mml:math id="IM172" display="inline" overflow="scroll"><mml:mo>β</mml:mo></mml:math></inline-formula>] with annotated bit-lengths.</p>
          </caption>
          <graphic xlink:href="btaa764f9" position="float"/>
        </fig>
      </sec>
    </sec>
    <sec id="btaa764-2.4">
      <label>2.4</label>
      <title>Systems architecture</title>
      <p>In this section we describe the MainSEL record linkage system’s design. It is comprised of the Mainzelliste as the data source and SEL as the sMPC compute unit. Both components communicate with each other via JSON REST interfaces. We illustrate the systems’ communication interface, the record linkage and ID management workflow and possible additional modes of operation.</p>
      <sec id="btaa764-2.4.1">
        <label>2.4.1</label>
        <title>Communication</title>
        <p>The sequence of communication is divided into two phases: the initialization phase and the linkage phase. During local initialization the connection to the local data source and the structure of the records, as well as their weights, are configured. Then an arbitrary number of remote targets can be configured. Every call between each of the parties is authenticated via a pre-shared key and executed over a secure channel, e.g. TLS-secured (<xref rid="btaa764-B44" ref-type="bibr">Rescorla, 2008</xref>).</p>
        <p>The initialization phase is completed when the configurations between the local SEL and the (multiple) remote SEL s, as well as between the local SEL and the linkage service, are tested. The test assures connectivity and compatible algorithm configurations.</p>
        <p>The linkage phase (see <xref rid="btaa764-F2" ref-type="fig">Fig. 2</xref>) starts with the local Mainzelliste sending one or a number of records to the local SEL and a callback address for the linkage result [step (1)]. The number of records to link, as well as the number of records in the remote Mainzelliste, need to be known for circuit creation. Therefore, the local SEL transmits its number of records to the remote SEL, which in turn queries all records from its remote Mainzelliste and returns that number [step (2)]. To allow a separation of circuit generation and linkage procedure, both numbers can be based on estimates and padded to allow growth in the time between circuit generation and linkage. In this case, it must be verified that the sizes used during the circuit generation are compatible with the actual numbers.</p>
        <fig position="float" id="btaa764-F2">
          <label>Fig. 2.</label>
          <caption>
            <p>Communication sequence diagram of the linkage phase. <italic toggle="yes">ML</italic> stands for Mainzelliste, the patient database and pseudonymization framework, <italic toggle="yes">SEL</italic> stands for the sMPC compute unit and <italic toggle="yes">LS</italic> stands for Linkage Service. The communication proceeds over a secure, authenticated channel. The numbers in parentheses enumerate the protocol’s steps described in Section 2.4.1.</p>
          </caption>
          <graphic xlink:href="btaa764f2" position="float"/>
        </fig>
        <p>With these requirements satisfied, the actual sMPC is executed between the local and the remote SEL [step (3)]. At the end of the computation, each side holds one share of the index of the best match, as well as shares of the match bits. These shares are then sent to the linkage service. Additionally, the remote SEL sends their encrypted IDs to the linkage service [step (4)]. It combines the shares and the best matching IDs are de- and re-encrypted. The information whether a match occurred is stored together with the linkage ID (LID) in encrypted form. This LID is transmitted to the local SEL, which sends it to the given callback address for storage or evaluation in the Mainzelliste [step (5)].</p>
      </sec>
      <sec id="btaa764-2.4.2">
        <label>2.4.2</label>
        <title>ID generation and management</title>
        <p>The usage of the record linkage process results is a privacy concern in itself. To avoid re-identification by two colluding actors on both sides, the returned LID must not reveal any information about the matching result. However, this very information is the basis for the detection of duplicates and the assignment of pseudonyms.</p>
        <p>Confidential pseudonymization is achieved by introducing the <italic toggle="yes">Linkage Service</italic>, a component only concerned with generating and encrypting LIDs. This component does not constitute a trusted third party, as it has no functionality in the linkage process and does never receive any private information. It only holds a secret key for every party for re-keying the generated LIDs and generates random IDs. This setup is used to prevent collusion of adversaries in both locations.</p>
        <p>To prepare for confidential LID management, one data source contacts the Linkage service to generate random IDs for all its records. Those random IDs are encrypted with the corresponding party’s secret key. After receiving the linkage result as well as the list of IDs from the server, the linkage service decrypts the LIDs. If the linkage results in a match, a matching bit is concatenated to the decrypted ID and this string is re-encrypted with the client’s secret key. If the records do not match, a new random ID is generated and encrypted with the client key. This procedure ensures that every LID looks like a random string and even two actors on both sides are not able to examine or compare IDs to learn matching records.</p>
        <p>To identify the matching records, a process that requires the patients’ consent for the data exchange from both parties is executed which grants the linkage service permission to decrypt the LIDs and distribute them in plain text. This information allows the identification of matches as well as the quality of matches.</p>
        <p>In this scenario, only the linkage service is allowed to generate LIDs. Otherwise the security of this procedure would be compromised. To check the validity of signatures, MainSEL uses a randomly chosen but sufficiently long zero padding of the plain text LIDs. This enables the linkage service to verify the validity of LIDs and that they belong to the correct party.</p>
        <p><italic toggle="yes">LID Generation without a LS</italic>. The described outsourcing of ID management is desirable for regulatory reasons, but not required from a cryptographic protocol perspective. The same functionality could be realized within the sMPC circuit, for example in the following way: both parties input an additional randomness per record. If <inline-formula id="IE174"><mml:math id="IM173" display="inline" overflow="scroll"><mml:mrow><mml:mtext>bestMatch</mml:mtext></mml:mrow></mml:math></inline-formula> determines a match, both parties’ randomness is XORed to obtain the LID for both. Otherwise, each party just receives the other party’s randomness as LID. Both cases are without collusion indistinguishable, as in the matching case the LID is effectively One-Time-Pad-encrypted with the other party’s randomness and as such indistinguishable from a random string as in the second case. Only after direct comparison of the LIDs can actual matches be identified. The linkage service prohibits exactly this collusion and allows a structured process, like distributing the LIDs after a review procedure.</p>
      </sec>
      <sec id="btaa764-2.4.3">
        <label>2.4.3</label>
        <title>Match-cardinality mode</title>
        <p>As described in the introduction of Section 2.1, we can easily extent the <inline-formula id="IE175"><mml:math id="IM174" display="inline" overflow="scroll"><mml:mrow><mml:mtext>bestMatch</mml:mtext></mml:mrow></mml:math></inline-formula> functionality to count the number of matches, resulting in functionality <inline-formula id="IE176"><mml:math id="IM175" display="inline" overflow="scroll"><mml:mrow><mml:mtext>matchCardinality</mml:mtext></mml:mrow></mml:math></inline-formula>, by simply summing the match bits. This can also be interpreted as the (fault-tolerant) patient lists’ intersection cardinality.</p>
        <p>This mode of operation is relevant for a number of real world applications, especially in the research and treatment planning of rare diseases. Patients with rare diseases are regularly recorded in multiple hospitals and research facilities, often with differing or uncertain diagnoses. This leads to a high amount of duplicate records in joint cohort studies. The current legal process for finding those duplicates includes all legal requirements required for transferring and processing the complete identifying dataset. This process is unreasonably complex for the feasibility analysis stage of a study, where e.g. cohort sizes are determined.</p>
      </sec>
    </sec>
  </sec>
  <sec id="btaa764-3">
    <label>3</label>
    <title>Results</title>
    <p>This section provides benchmarking results for our implementation of the sMPC circuit as set forth in Section 2.3 and describes the experimental setup. The interpretation of the reported benchmarks is discussed in Section 4.</p>
    <sec id="btaa764-3.1">
      <label>3.1</label>
      <title>Record linkage quality</title>
      <p>As we implement the established, well understood record linkage algorithm of the Mainzelliste software (<xref rid="btaa764-B32" ref-type="bibr">Lablans <italic toggle="yes">et al.</italic>, 2015</xref>) that is in broad practical use in the German medical research environment, the analysis of the achieved record linkage quality is not the focus of this work. However, we can report a precision of 0.994 and perfect recall performing a linkage between two datasets with 10 000 (synthetic) records, each, 60% overlap and a 10% error rate per field. For more details on the data generation and perturbation procedure, as well as more analysis results and a comparison to <xref rid="btaa764-B35" ref-type="bibr">Lazrig <italic toggle="yes">et al.</italic> (2018)</xref>, we refer to <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix SB</xref>.</p>
    </sec>
    <sec id="btaa764-3.2">
      <label>3.2</label>
      <title>Benchmarking setup</title>
      <p>For the implementation, we used C++ and the ABY framework (<xref rid="btaa764-B15" ref-type="bibr">Demmler <italic toggle="yes">et al.</italic>, 2015a</xref>). The timing benchmarks ran on two identical servers with Intel Xeon E5-2690 CPUs (2.90 GHz), 256 GiB RAM each and a local 1 Gbit/s connection. Both ran a recent Arch Linux OS with vanilla Kernel version 4.20.7 and gcc version 8.2.1 for source code compilation. In ABY, we set the security parameters to achieve a symmetric security level of 128 bit. We furthermore chose <inline-formula id="IE177"><mml:math id="IM176" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>32</mml:mn><mml:mo> </mml:mo><mml:mtext>bit</mml:mtext></mml:mrow></mml:math></inline-formula> as the bit-length of the arithmetic circuit components to achieve a score accuracy within 0.1%, cf. Section 2.3.5. All reported timings are averaged over at least five iterations. All benchmarks—except where specifically noted—are using the default EpiLink configuration that is shipped with the Mainzelliste software (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix SD</xref>), consisting of four Dice-compared and four equality-compared fields. The parameters of this default configuration are chosen following <xref rid="btaa764-B45" ref-type="bibr">Sariyar <italic toggle="yes">et al.</italic> (2011)</xref>.</p>
    </sec>
    <sec id="btaa764-3.3">
      <label>3.3</label>
      <title>Setup and online phases</title>
      <p>Since a sMPC computation can be split into two phases, we report those timings separately. In the first <italic toggle="yes">setup</italic> phase (often called <italic toggle="yes">offline</italic> phase in the sMPC literature), only the size and structure of the circuit need to be known, but the input data can be set later. More specifically, in this phase the parties perform base OTs and OT-extension and exchange multiplication triples (Arithmetic Sharing) or Yao keys. Details can be found in the description of the ABY framework (<xref rid="btaa764-B15" ref-type="bibr">Demmler <italic toggle="yes">et al.</italic>, 2015a</xref>). This allows for the—usually much more communication intensive—setup phase to be run before the input to the circuit is even known. The second <italic toggle="yes">online</italic> phase runs once the input to the circuit is known and usually requires an order of magnitude less communication and thus runs much faster than the setup phase.</p>
      <p>Our record linkage circuit only depends on the database size and the EpiLink fields configuration, which is assumed not to change once two institutions agreed on a common configuration. Thus, two institutions running the Secure EpiLinker can greatly benefit from this separation into setup and online phase. They can run the setup phase on their combined databases, and once one side inserts a new patient in their database, they can immediately execute the online phase. We therefore often speak of the online runtime as the actual runtime of a secure record linkage procedure. To be fair, however, in an initial full database cross-linkage procedure, both phases’ timings would sum up to give the total runtime. On the other hand, the full cross-linkage would only need to run once after two institutions agree to enter the mutual secure record linkage scheme.</p>
    </sec>
    <sec id="btaa764-3.4">
      <label>3.4</label>
      <title>Timings</title>
      <p><xref rid="btaa764-F3" ref-type="fig">Figure 3</xref> reports the two phases’ runtimes for varying database sizes and sMPC circuit implementations, in three different network environments. We varied the database sizes from 1 to 10 000 and tested all four variants of the circuit implementation described in Section 2.3.3.</p>
      <fig position="float" id="btaa764-F3">
        <label>Fig. 3.</label>
        <caption>
          <p>Setup and online runtime in seconds for <italic toggle="yes">varying database sizes</italic> and four circuit variants (cf. Section 2.3.3), in three network environments: (<bold>A</bold>) &lt;0.1 ms latency  + 1 Gbit/s bandwidth, (<bold>B</bold>) &lt;0.1 ms + 100 Mbit/s, (<bold>C</bold>) 100 ms + 1 Gbit/s. The Epilink configuration of DKFZ’s Mainzelliste (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix SD</xref>) was used in all benchmarks</p>
        </caption>
        <graphic xlink:href="btaa764f3" position="float"/>
      </fig>
      <p>The pure <inline-formula id="IE178"><mml:math id="IM177" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">Yao</mml:mi></mml:mrow></mml:math></inline-formula> protocol has a constant number of rounds. The communication rounds of the other protocols are proportional to the circuit depth. <xref rid="btaa764-T1" ref-type="table">Table 1</xref> reveals that the number of communication rounds grows logarithmically with the database size, starting with an offset. For example <inline-formula id="IE179"><mml:math id="IM178" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW/A</mml:mi></mml:mrow></mml:math></inline-formula> requires 266 rounds for database size one, reaching 506 for size 25 000. This can be explained by the fact that the first part of any circuit runs the record linkage for all database entries in parallel, resulting in a circuit of fixed depth not dependent on the database size. The second part of the circuit determines the maximum score in a balanced binary-tree, which explains the logarithmic growth.</p>
      <table-wrap position="float" id="btaa764-T1">
        <label>Table 1.</label>
        <caption>
          <p>Comparison of the setup and online runtimes of the sMPC linkage procedure of a single record with a remote database in circuit variant <inline-formula id="IE180"><mml:math id="IM179" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW/A</mml:mi></mml:mrow></mml:math></inline-formula></p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Database<hr/></th>
              <th colspan="3" align="center" rowspan="1">Comm. [MiB]<hr/></th>
              <th colspan="3" rowspan="1">Setup phase [s]<hr/></th>
              <th colspan="3" rowspan="1">Online phase [s]<hr/></th>
            </tr>
            <tr>
              <th align="center" rowspan="1" colspan="1">Size</th>
              <th align="center" rowspan="1" colspan="1">No. of rounds</th>
              <th align="center" rowspan="1" colspan="1">Setup</th>
              <th align="center" rowspan="1" colspan="1">Online</th>
              <th rowspan="1" colspan="1">A</th>
              <th rowspan="1" colspan="1">B</th>
              <th rowspan="1" colspan="1">C</th>
              <th rowspan="1" colspan="1">A</th>
              <th rowspan="1" colspan="1">B</th>
              <th rowspan="1" colspan="1">C</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="right" rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">266</td>
              <td rowspan="1" colspan="1">0.6</td>
              <td rowspan="1" colspan="1">0.1</td>
              <td rowspan="1" colspan="1">0.018</td>
              <td rowspan="1" colspan="1">0.036</td>
              <td rowspan="1" colspan="1">0.72</td>
              <td align="char" rowspan="1" colspan="1">0.052</td>
              <td align="char" rowspan="1" colspan="1">0.054</td>
              <td rowspan="1" colspan="1">13</td>
            </tr>
            <tr>
              <td align="right" rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">330</td>
              <td rowspan="1" colspan="1">5.5</td>
              <td rowspan="1" colspan="1">0.7</td>
              <td rowspan="1" colspan="1">0.097</td>
              <td rowspan="1" colspan="1">0.15</td>
              <td rowspan="1" colspan="1">1.4</td>
              <td align="char" rowspan="1" colspan="1">0.072</td>
              <td align="char" rowspan="1" colspan="1">0.072</td>
              <td rowspan="1" colspan="1">16</td>
            </tr>
            <tr>
              <td align="right" rowspan="1" colspan="1">25</td>
              <td rowspan="1" colspan="1">346</td>
              <td rowspan="1" colspan="1">13.5</td>
              <td rowspan="1" colspan="1">1.7</td>
              <td rowspan="1" colspan="1">0.18</td>
              <td rowspan="1" colspan="1">0.29</td>
              <td rowspan="1" colspan="1">1.6</td>
              <td align="char" rowspan="1" colspan="1">0.093</td>
              <td align="char" rowspan="1" colspan="1">0.094</td>
              <td rowspan="1" colspan="1">17</td>
            </tr>
            <tr>
              <td align="right" rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">378</td>
              <td rowspan="1" colspan="1">53.7</td>
              <td rowspan="1" colspan="1">6.7</td>
              <td rowspan="1" colspan="1">0.43</td>
              <td rowspan="1" colspan="1">1.7</td>
              <td rowspan="1" colspan="1">2.5</td>
              <td align="char" rowspan="1" colspan="1">0.17</td>
              <td align="char" rowspan="1" colspan="1">0.17</td>
              <td rowspan="1" colspan="1">18</td>
            </tr>
            <tr>
              <td align="right" rowspan="1" colspan="1">250</td>
              <td rowspan="1" colspan="1">394</td>
              <td rowspan="1" colspan="1">133.9</td>
              <td rowspan="1" colspan="1">16.8</td>
              <td rowspan="1" colspan="1">0.87</td>
              <td rowspan="1" colspan="1">5.3</td>
              <td rowspan="1" colspan="1">4</td>
              <td align="char" rowspan="1" colspan="1">0.29</td>
              <td align="char" rowspan="1" colspan="1">0.3</td>
              <td rowspan="1" colspan="1">19</td>
            </tr>
            <tr>
              <td align="right" rowspan="1" colspan="1">1000</td>
              <td rowspan="1" colspan="1">426</td>
              <td rowspan="1" colspan="1">555.2</td>
              <td rowspan="1" colspan="1">47.1</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">23</td>
              <td rowspan="1" colspan="1">11</td>
              <td align="char" rowspan="1" colspan="1">0.77</td>
              <td align="char" rowspan="1" colspan="1">0.87</td>
              <td rowspan="1" colspan="1">22</td>
            </tr>
            <tr>
              <td align="right" rowspan="1" colspan="1">2500</td>
              <td rowspan="1" colspan="1">458</td>
              <td rowspan="1" colspan="1">1394.1</td>
              <td rowspan="1" colspan="1">119.5</td>
              <td rowspan="1" colspan="1">7.3</td>
              <td rowspan="1" colspan="1">60</td>
              <td rowspan="1" colspan="1">25</td>
              <td align="char" rowspan="1" colspan="1">1.6</td>
              <td align="char" rowspan="1" colspan="1">1.9</td>
              <td rowspan="1" colspan="1">27</td>
            </tr>
            <tr>
              <td align="right" rowspan="1" colspan="1">10 000</td>
              <td rowspan="1" colspan="1">490</td>
              <td rowspan="1" colspan="1">5577.4</td>
              <td rowspan="1" colspan="1">459.4</td>
              <td rowspan="1" colspan="1">28</td>
              <td rowspan="1" colspan="1">240</td>
              <td rowspan="1" colspan="1">96</td>
              <td align="char" rowspan="1" colspan="1">6.1</td>
              <td align="char" rowspan="1" colspan="1">8.2</td>
              <td rowspan="1" colspan="1">48</td>
            </tr>
            <tr>
              <td align="right" rowspan="1" colspan="1">25 000</td>
              <td rowspan="1" colspan="1">506</td>
              <td rowspan="1" colspan="1">13 917.9</td>
              <td rowspan="1" colspan="1">1150.3</td>
              <td rowspan="1" colspan="1">69</td>
              <td rowspan="1" colspan="1">610</td>
              <td rowspan="1" colspan="1">240</td>
              <td align="char" rowspan="1" colspan="1">15</td>
              <td align="char" rowspan="1" colspan="1">23</td>
              <td rowspan="1" colspan="1">88</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: Compared are the three networking configurations from <xref rid="btaa764-F3" ref-type="fig">Figure 3</xref>, for <italic toggle="yes">varying database sizes</italic>. The reported network communication cost is the sum of sent and received data. See <xref rid="sup1" ref-type="supplementary-material">Appendix SE</xref> for the complete set of tables.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>Overall, the <inline-formula id="IE181"><mml:math id="IM180" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW/A</mml:mi></mml:mrow></mml:math></inline-formula> variant performs best in both, the setup and online phase and almost all network settings. For all circuit variants, asymptotically, the sMPC runtime grows linearly, after a ramp-up for small database sizes. The ramp-up is more pronounced for non-Yao based variants, which can be explained by the previously discussed effect on the communication rounds. This is particularly visible for the online phase in network environment <bold>C</bold>. For larger database sizes, the larger amounts of data per round amortize the negative effects of multiple rounds and the bandwidth becomes the dominant effect on runtime.</p>
      <p>In <xref rid="btaa764-F4" ref-type="fig">Figure 4</xref>, a similar pattern can be seen for a growing number of fields (where the database size was kept constant at 1000). Asymptotically, the runtime grows linearly with the number of fields. This can be explained by the same arguments as before, because multiple fields are also compared in parallel. Also note that the runtimes of equality-compared integer fields are almost negligible in comparison to Dice-compared Bloom filter fields, because the latter are much more complex to evaluate (cf. Circuits <xref rid="btaa764-F8" ref-type="fig">4</xref> versus <xref rid="btaa764-F9" ref-type="fig">5</xref>).</p>
      <fig position="float" id="btaa764-F4">
        <label>Fig. 4.</label>
        <caption>
          <p>Setup and online runtime in seconds for <italic toggle="yes">varying number of fields</italic> and <italic toggle="yes">varying field types</italic>: (1) only 12 bit integer fields with equality comparison, (2) only 500 bit Bloom filters with Dice comparison or (3) both, counted as pairs. Network environment A: &lt;0.1 ms latency + 1 Gbit/s bandwidth was used with a database size of 1000 and the <inline-formula id="IE182"><mml:math id="IM181" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW/A</mml:mi></mml:mrow></mml:math></inline-formula> circuit variant</p>
        </caption>
        <graphic xlink:href="btaa764f4" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec id="btaa764-4">
    <label>4</label>
    <title>Discussion</title>
    <p>In circuit variant <inline-formula id="IE183"><mml:math id="IM182" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW/A</mml:mi></mml:mrow></mml:math></inline-formula> and network environment <bold>A</bold> (no latency, 1 Gbit/s), a full cross-linkage of two medium-sized databases with 10 000 patients each would take 78 h for the setup and 17 h for the online phase, or approximately 4 days in total. In the high latency (100 ms) networking setup <bold>C</bold>, it would take almost 17 days. We expect to drastically reduce this time in future work by adding record linkage blocking techniques to our procedure, which, for classical and Bloom filter-based record linkage, have already been implemented in recent versions of Mainzelliste. However, this setup would only need to run once initially, when two parties enter the secure record linkage system. Once the system is online and linked, securely linking a newly admitted patient to an existing database of size 10 000 would take 6.1 s online time for circuit variant <inline-formula id="IE184"><mml:math id="IM183" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW/A</mml:mi></mml:mrow></mml:math></inline-formula> or 4 s in the pure <inline-formula id="IE185"><mml:math id="IM184" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW</mml:mi></mml:mrow></mml:math></inline-formula> protocol, assuming network setting <bold>A</bold>. In network environment <bold>C</bold>, it would take 48 s for variant <inline-formula id="IE186"><mml:math id="IM185" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW/A</mml:mi></mml:mrow></mml:math></inline-formula>. Also note the different scaling behaviors: due to the exhaustive pair comparisons, the computation- and communication complexity is <inline-formula id="IE187"><mml:math id="IM186" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>×</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> during the <italic toggle="yes">initial</italic> linking phase, while during normal operation the complexity becomes <inline-formula id="IE188"><mml:math id="IM187" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. linear in the size of the data source. This demonstrates the feasibility of our technique in a broad range of practical applications.</p>
    <p>The optimal configuration of our system depends on the requirements of the scenario. For most environments, the optimization of the online times is sensible, as the setup phase can run between timing critical processes. For all cases other than having small databases and very high latencies, using variant <inline-formula id="IE189"><mml:math id="IM188" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">GMW/A</mml:mi></mml:mrow></mml:math></inline-formula> constitutes a sensible default. This allows non-technical personnel to deploy our system with a sensible configuration.</p>
    <p>This work is easily generalizable to augmented patient data. If, for example, the IDAT fields used in this work were augmented by equality-check MDAT values, runtimes would not be impacted heavily. As displayed in <xref rid="btaa764-F4" ref-type="fig">Figure 4</xref>, simple equality comparisons are nearly negligible in comparison to fault-tolerant Bloom-Dice comparisons.</p>
    <p>Our results are in alignment with <xref rid="btaa764-B15" ref-type="bibr">Demmler et al.’s (2015a</xref>) observation that in most applications the utilization of mixed sMPC protocols is more efficient. The performance gains of the combined usage of GMW and Arithmetic Sharing outweigh the additional computations required for the conversions between the protocols.</p>
    <p>The studied network environments reveal widely known bottlenecks of sMPC. Firstly, we can identify the network communication as the computation’s main impediment (cf. <xref rid="btaa764-F3" ref-type="fig">Fig. 3</xref>). By either throttling the network bandwidth or increasing the latency between both parties, runtimes significantly increase. A detailed analysis of the connection between the database sizes, network settings and circuit depths was given in Section 3.4. At least in Germany, this should not pose a strong impediment since research clinics are connected by the high-performance DFN network, which most closely resembles our best network environment <bold>A</bold>. We can also conclude that machines with more computational power would unfortunately not lead to significant improvements in runtime.</p>
    <p>The legal question whether the transmitted data is ‘personal data’ is not answered yet in the European Union. Past decisions of the European Court of Justice and the German Federal Court of Justice lead to our understanding that record linkage without the patients consent might be legally permitted, as encrypted data is only personal data for parties having access to the encryption key as well as third parties having the legal right to demand disclosure of the key (<xref rid="btaa764-B19" ref-type="bibr">Federal Court of Justice of Germany, 2017</xref>; <xref rid="btaa764-B49" ref-type="bibr">The Court of Justice of the European Union, 2016</xref>). In the case that the encrypted data is seen as a pseudonym connected to additional information, the legal status is determined by the network (and availability) of the connected additional data. The referenced rulings have been made before the introduction of the European ‘General Data Protection Regulation (GDPR)’ (<xref rid="btaa764-B18" ref-type="bibr">Eurpean Parliament and Council, 2016</xref>). We find it highly plausible that our record linkage solution indeed does not transmit personal data, but at the moment no legal verification of that claim is published.</p>
  </sec>
  <sec id="btaa764-5">
    <label>5</label>
    <title>Conclusion</title>
    <p>In this work, we presented a novel method to perform privacy preserving record linkage with no information leakage, guaranteed by the utilization of provably secure multi-party computation. Most importantly, in the environment relevant for medical research in the foreseeable future (semi-honest setting and the absence of quantum computers), record linkage via MainSEL ensures that no record linkage party learns anything apart from the intended record linkage result—not even in an indirect (e.g. Bloom-filtered) form. Our implementation includes integration interfaces, optimizations and operation-ready deployment methods.</p>
    <p>Due to carefully designed cryptographic protocols, as well as a novel high-level approach to generate optimized integer division circuits, our solution provides reasonable runtimes for linking mid-sized to large data sources as well as in an online mode for large and very large data sources. Albeit the promising results, this work opens up possibilities for further optimization and research in the following two categories: (i<bold>)</bold> the secure record linkage algorithms and (ii<bold>)</bold> the interfaces and application.</p>
    <p>In practical applications, record linkage between more than two parties would be desirable but implies significant opportunities for research: probabilistic record linkage measures like ours are not transitive so in a multi-database setting, match conflicts may arise. In practice, such conflicts are usually resolved by accepting a non-direct-but-transitive match as a match, thereby interpreting such direct non-matches as false negatives. How to optimize network topologies to minimize linkage conflicts (e.g. with a star topology if feasible) is future research.</p>
    <p>Note that we implemented a pair-wise record linkage algorithm using a secure <italic toggle="yes">two</italic>-party computation framework (ABY), so using MainSEL to fully link <italic toggle="yes">k</italic> databases of size <italic toggle="yes">N</italic>, each, requires the naive pairwise matching of <inline-formula id="IE190"><mml:math id="IM189" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> records. However, we’d like to stress that we built a drop-in replacement for the local record linkage that usually happens inside a single Mainzelliste instance in clear-text, so our solution can be readily deployed to the existing German medical research environment, where the Mainzelliste is in broad use, to enable novel research directions that would not be possible without a fully privacy-preserving linkage methodology. The usage of optimized algorithms for multi-database record linkage while using the <italic toggle="yes">multi</italic>-party successor to ABY will be explored in the future.</p>
    <p>To further enhance the flexibility of the record linkage solution in this work, additional methods to include non-IDAT fields can be included. Those fields might lead to the need to include or develop different matching classifier. To reduce the computationally intensive areas of the procedure, it might be possible to include pruning and blocking methods. To be utilized, these must be provable secure and free of information leakage, which, in combination with sMPC protocols, presents an open research problem, as typical blocking techniques, such as <italic toggle="yes">Locality Sensitive Hashing</italic> based techniques, are shown to be incompatible to those strong privacy guarantees (<xref rid="btaa764-B26" ref-type="bibr">He <italic toggle="yes">et al.</italic>, 2017</xref>). We plan to analyze the applicability of <italic toggle="yes">Oblivious RAM</italic>-based constructions in a potential blocking mechanism to avoid the degradation of our privacy guarantees.</p>
    <p>Reliably deploying an application in the hospital IT environments is also a big challenge. The implementation of ICE techniques using STUN, TURN and other suitable methods for firewall and proxy traversal is the next step to be ready for hospital deployment. Our current implementation handles user authentication analogous to Mainzelliste. In the future, we want to provide OAuth2 and TLS client certificate authentication. Even though MainSEL is not designed as a secure record linkage software library, but as a generic interfaced standalone application, it could be adapted as a C++ Software Development Kit (SDK), or even software library, with moderate effort.</p>
    <p>Independent of those areas of improvement, further regulatory and legal work is a necessary condition to allow practical usage of secure record linkage. With this work we hope to contribute to this process by providing practical benchmarks and technology details. In our opinion secure record linkage can contribute to a more privacy-preserving, better auditable and less bureaucratic digitized medicine.</p>
    <p>We would like to stress, that even if secure record linkage is computationally intensive, many application scenarios become legally or intent-wise possible only through the privacy guarantees of our solution.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the German Federal Ministry of Education and Research (BMBF) through the HiGHmed Consortium [01ZZ1802G]; and the German Research Foundation (DFG) through the MAGIC project [LA 3859/1-1] and the Research Training Group GRK 1651 (SOAMED).</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btaa764_Supplementary_Data</label>
      <media xlink:href="btaa764_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors give special thanks to Daniel Demmler for many fruitful discussions regarding the use of ABY and many fun debugging sessions. They also thank David Croft and Esther Schmidt for their thorough and helpful proofreading suggestions. They thank our anonymous reviewers for helping us to write a clearer and more concise publication.</p>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btaa764-B1">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Asharov</surname><given-names>G.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) More efficient oblivious transfer and extensions for faster secure computation. In <italic toggle="yes">Proceedings of the 2013 ACM SIGSAC Conference on Computer &amp; Communications Security – CCS ’13</italic>, ACM Press, New York, NY, USA. pp. <fpage>535</fpage>–<lpage>548</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Asharov</surname><given-names>G.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>More efficient oblivious transfer extensions</article-title>. <source>J. Cryptol</source>., <volume>30</volume>, <fpage>805</fpage>–<lpage>858</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Baker</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Privacy-preserving linkage of genomic and clinical data sets</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinf</source>., <volume>16</volume>, <fpage>1342</fpage>–<lpage>1348</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bernemann</surname><given-names>I.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Zentralisierte biobanken als grundlage für die medizinische forschung</article-title>. <source>Bundesgesundheitsblatt, Gesundheitsforschung, Gesundheitsschutz</source>, <volume>59</volume>, <fpage>336</fpage>–<lpage>343</lpage>.<pub-id pub-id-type="pmid">26830106</pub-id></mixed-citation>
    </ref>
    <ref id="btaa764-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bloom</surname><given-names>B.H.</given-names></string-name></person-group> (<year>1970</year>) <article-title>Space/time trade-offs in hash coding with allowable errors</article-title>. <source>Commun. ACM</source>, <volume>13</volume>, <fpage>422</fpage>–<lpage>426</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B6">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bogdanov</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2008</year>) Sharemind: a framework for fast privacy-preserving computations. In: Jajodia,S. and Lopez,J.(eds) <italic toggle="yes">ESORICS</italic>, volume 5283 of <italic toggle="yes">Lecture Notes in Computer Science</italic>. Springer, Berlin, Heidelberg, pp. <fpage>192</fpage>–<lpage>206</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Brown</surname><given-names>A.P.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Evaluating privacy-preserving record linkage using cryptographic long-term keys and multibit trees on large medical datasets</article-title>. <source>BMC Med. Inf. Decis. Mak</source>., <volume>17</volume>, <fpage>83:1</fpage>–<lpage>83:7</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B8">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Buescher</surname><given-names>N.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <part-title>Compiling low depth circuits for practical secure computation</part-title>. In: <source>Computer Security – ESORICS 2016, Lecture Notes in Computer Science</source>. <publisher-name>Springer</publisher-name>, <publisher-loc>Cham</publisher-loc>., pages <fpage>80</fpage>–<lpage>98</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B9">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Burkhart</surname><given-names>M.</given-names></string-name>, <string-name><surname>Wiese</surname><given-names>B.</given-names></string-name></person-group> (<year>2019</year>) Deutsches Mukoviszidoseregister–Berichtsband 2015. <italic toggle="yes">Mukoviszidose Institut, Bonn</italic>.</mixed-citation>
    </ref>
    <ref id="btaa764-B10">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Christen</surname><given-names>P.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <part-title>Efficient cryptanalysis of bloom filters for privacy-preserving record linkage</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Kim</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (eds.) <source>Advances in Knowledge Discovery and Data Mining, Lecture Notes in Computer Science</source>. <publisher-name>Springer International Publishing</publisher-name>, Cham., Berlin, Heidelberg, Germany, pp. <fpage>628</fpage>–<lpage>640</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B11">
      <mixed-citation publication-type="other">Climedo (<year>2019</year>) Digitale Probandenakte.</mixed-citation>
    </ref>
    <ref id="btaa764-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cohen</surname><given-names>W.W.</given-names></string-name></person-group> (<year>2000</year>) <article-title>Data integration using similarity joins and a word-based information representation language</article-title>. <source>ACM Trans. Inf. Syst</source>., <volume>18</volume>, <fpage>288</fpage>–<lpage>321</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Contiero</surname><given-names>P.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2005</year>) <article-title>The EpiLink record linkage software</article-title>. <source>Methods Inf. Med</source>., <volume>44</volume>, <fpage>66</fpage>–<lpage>71</lpage>.<pub-id pub-id-type="pmid">15778796</pub-id></mixed-citation>
    </ref>
    <ref id="btaa764-B14">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Damgård</surname><given-names>I.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) Multiparty computation from somewhat homomorphic encryption. In: Safavi-Naini,R. and Canetti,R.(eds) <italic toggle="yes">CRYPTO</italic>, volume 7417 of <italic toggle="yes">Lecture Notes in Computer Science</italic>. Springer, Springer, Berlin, Heidelberg, pp. <fpage>643</fpage>–<lpage>662</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Demmler</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015a</year>) <part-title>ABY – a framework for efficient mixed-protocol secure two-party computation</part-title>. In <source>NDSS</source>. <publisher-name>The Internet Society</publisher-name>. Reston, Virginia, USA.</mixed-citation>
    </ref>
    <ref id="btaa764-B16">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Demmler</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015b</year>) Automated synthesis of optimized circuits for secure computation. In <italic toggle="yes">Proceedings of the 22Nd ACM SIGSAC Conference on Computer and Communications Security</italic>, CCS ’15. ACM, New York, NY, USA, pp. <fpage>1504</fpage>–<lpage>1517</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dice</surname><given-names>L.R.</given-names></string-name></person-group> (<year>1945</year>) <article-title>Measures of the amount of ecologic association between species</article-title>. <source>Ecology</source>, <volume>26</volume>, <fpage>297</fpage>–<lpage>302</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B18">
      <mixed-citation publication-type="other">Eurpean Parliament and Council. (<year>2016</year>) Regulation (EU) 2016/679 of the European Parliament and of the Council of 27 April 2016 on the protection of natural persons with regard to the processing of personal data and on the free movement of such data, and repealing Directive 95/46/EC (General Data Protection Regulation).</mixed-citation>
    </ref>
    <ref id="btaa764-B19">
      <mixed-citation publication-type="other">Federal Court of Justice of Germany (<year>2017</year>) Urteil <italic toggle="yes">VI ZR 135/13.</italic> Federal Court of Justice of Germany.</mixed-citation>
    </ref>
    <ref id="btaa764-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fellegi</surname><given-names>I.P.</given-names></string-name>, <string-name><surname>Sunter</surname><given-names>A.B.</given-names></string-name></person-group> (<year>1969</year>) <article-title>A theory for record linkage</article-title>. <source>J. Am. Stat. Assoc</source>., <volume>64</volume>, <fpage>1183</fpage>–<lpage>1210</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B21">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Franz</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>). <part-title>CBMC-GC: an ANSI C compiler for secure two-party computations</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Cohen</surname><given-names>A.</given-names></string-name></person-group> (ed.) <source>Compiler Construction, Lecture Notes in Computer Science</source>. <publisher-name>Springer</publisher-name>, <publisher-loc>Berlin, Heidelberg</publisher-loc>, pp. <fpage>244</fpage>–<lpage>249</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B22">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Gilboa</surname><given-names>N.</given-names></string-name></person-group> (<year>1999</year>) <part-title>Two party RSA key generation</part-title>. In: Wiener,M. (ed.) <source>CRYPTO, volume 1666 of Lecture Notes in Computer Science</source>. <publisher-name>Springer</publisher-name>, Berlin, Heidelberg, pp. <fpage>116</fpage>–<lpage>129</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B23">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Goldreich</surname><given-names>O.</given-names></string-name></person-group> (<year>2004</year>) <source>The Foundations of Cryptography - Volume 2, Basic Applications</source>. <publisher-name>Cambridge University Press, Cambridge, UK</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btaa764-B24">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Goldreich</surname><given-names>O.</given-names></string-name></person-group>  <etal>et al</etal> (<year>1987</year>) How to play any mental game or a completeness theorem for protocols with honest majority. In: <italic toggle="yes">STOC</italic>. ACM, New York, NY, USA, pp. <fpage>218</fpage>–<lpage>229</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B25">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Guo</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) Efficient and secure multiparty computation from fixed-key block ciphers. <italic toggle="yes">Technical report 074</italic>, Cryptology ePrint Archive.</mixed-citation>
    </ref>
    <ref id="btaa764-B26">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>He</surname><given-names>X.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) Composing differential privacy and secure computation: a case study on scaling private record linkage. In <italic toggle="yes">Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security, CCS ’17</italic>. ACM, Dallas, Texas, USA, pages <fpage>1389</fpage>–<lpage>1406</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B27">
      <mixed-citation publication-type="other">iAS interActive Systems GmbH (<year>2019</year>) secuTrial.</mixed-citation>
    </ref>
    <ref id="btaa764-B28">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Inan</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2010</year>) Private record matching using differential privacy. In <italic toggle="yes">Proceedings of the 13th International Conference on Extending Database Technology, EDBT ’10</italic>. Association for Computing Machinery, ACM, New York, NY, USA , pp. <fpage>123</fpage>–<lpage>134</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B29">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Ishai</surname><given-names>Y.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2003</year>) <part-title>Extending oblivious transfers efficiently</part-title>. In Boneh,D. (ed.) <source>CRYPTO, volume 2729 of Lecture Notes in Computer Science</source>. <publisher-name>Springer</publisher-name>, Berlin, Heidelberg, pp. <fpage>145</fpage>–<lpage>161</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B30">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Kirsch</surname><given-names>A.</given-names></string-name>, <string-name><surname>Mitzenmacher</surname><given-names>M.</given-names></string-name></person-group> (<year>2006</year>). <part-title>Less hashing, same performance: building a better bloom filter</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Azar</surname><given-names>Y.</given-names></string-name> and <string-name><surname>Erlebach</surname><given-names>T.</given-names></string-name></person-group> (eds.) <source>Algorithms – ESA 2006, Lecture Notes in Computer Science</source>. <publisher-name>Springer</publisher-name>, <publisher-loc>Berlin, Heidelberg</publisher-loc>, pp. <fpage>456</fpage>–<lpage>467</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B31">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Kuzu</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2011</year>) <part-title>A constraint satisfaction cryptanalysis of bloom filters in private record linkage</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Fischer-Hübner</surname><given-names>S.</given-names></string-name> and <string-name><surname>Hopper</surname><given-names>N.</given-names></string-name></person-group> (eds.) <source>Privacy Enhancing Technologies, Lecture Notes in Computer Science</source>. <publisher-name>Springer</publisher-name>, <publisher-loc>Berlin, Heidelberg</publisher-loc>, pp. <fpage>226</fpage>–<lpage>245</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lablans</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) <article-title>A RESTful interface to pseudonymization services in modern web applications</article-title>. <source>BMC Med. Inf. Decis. Mak</source>., <volume>15</volume>, <fpage>2</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lablans</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>An architecture for translational cancer research as exemplified by the German cancer consortium</article-title>. <source>JCO Clin. Cancer Inf</source>., <volume>2</volume>, <fpage>1</fpage>–<lpage>8</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Laud</surname><given-names>P.</given-names></string-name>, <string-name><surname>Pankova</surname><given-names>A.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Privacy-preserving record linkage in large databases using secure multiparty computation</article-title>. <source>BMC Med. Genomics</source>, <volume>11</volume>, <fpage>84</fpage>.<pub-id pub-id-type="pmid">30309353</pub-id></mixed-citation>
    </ref>
    <ref id="btaa764-B35">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Lazrig</surname><given-names>I.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) Privacy preserving probabilistic record linkage without trusted third party. In: <italic toggle="yes">2018 16th Annual Conference on Privacy, Security and Trust (PST)</italic>, IEEE, conference, Belfast, Ireland, pp. <fpage>1</fpage>–<lpage>10</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lindell</surname><given-names>Y.</given-names></string-name>, <string-name><surname>Pinkas</surname><given-names>B.</given-names></string-name></person-group> (<year>2009</year>) <article-title>A proof of security of Yao’s protocol for two-party computation</article-title>. <source>J. Cryptol</source>., <volume>22</volume>, <fpage>161</fpage>–<lpage>188</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B37">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Link</surname><given-names>D.</given-names></string-name></person-group> (<year>2019</year>) CentraXX Basic — Kairos GmbH.</mixed-citation>
    </ref>
    <ref id="btaa764-B38">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Malkhi</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2004</year>) Fairplay – secure two-party computation system. In: <italic toggle="yes">USENIX Security Symposium</italic>. USENIX, Berkeley, CA, USA, pp. <fpage>287</fpage>–<lpage>302</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B39">
      <mixed-citation publication-type="other">Miracum (<year>2019</year>) Miracum. miracolix tools.</mixed-citation>
    </ref>
    <ref id="btaa764-B40">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Mitzenmacher</surname><given-names>M.</given-names></string-name>, <string-name><surname>Upfal</surname><given-names>E.</given-names></string-name></person-group> (<year>2005</year>) <source>Probability and Computing: Randomized Algorithms and Probabilistic Analysis</source>. <publisher-name>Cambridge University Press, Cambridge, UK</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btaa764-B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Muscholl</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) <article-title>Osse – open source registry software solution</article-title>. <source>Orphanet J. Rare Dis</source>., <volume>9</volume>, <fpage>O9</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B42">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Naor</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2001</year>) Efficient oblivious transfer protocols. In <italic toggle="yes">Proceedings of the Twelfth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA ’01</italic>. Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, pp. <fpage>448</fpage>–<lpage>457</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B43">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rabin</surname><given-names>M.O.</given-names></string-name></person-group> (<year>2005</year>) <article-title>How to exchange secrets with oblivious transfer</article-title>. <source>IACR Cryptol. ePrint Arch</source>., <volume>2005</volume>, <fpage>187</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B44">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Rescorla</surname><given-names>E.</given-names></string-name></person-group> (<year>2008</year>) <italic toggle="yes">The Transport Layer Security (TLS) Protocol Version 1.2 (RFC5246)</italic>.</mixed-citation>
    </ref>
    <ref id="btaa764-B45">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sariyar</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2011</year>) <article-title>Controlling false match rates in record linkage using extreme value theory</article-title>. <source>J. Biomed. Inf</source>., <volume>44</volume>, <fpage>648</fpage>–<lpage>654</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B46">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schnell</surname><given-names>R.</given-names></string-name>, <string-name><surname>Borgs</surname><given-names>C.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Protecting record linkage identifiers using a language model for patient names</article-title>. <source>Studies Health Technol. Inf</source>., <volume>253</volume>, <fpage>91</fpage>–<lpage>95</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B47">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schnell</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2009</year>) <article-title>Privacy-preserving record linkage using Bloom filters</article-title>. <source>BMC Med. Inf. Decis. Mak</source>., <volume>9</volume>, <fpage>41</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B48">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Skripcak</surname><given-names>T.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Toward distributed conduction of large-scale studies in radiation therapy and oncology: open-source system integration approach</article-title>. <source>IEEE J. Biomed. Health Inf</source>., <volume>20</volume>, <fpage>1397</fpage>–<lpage>1403</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B49">
      <mixed-citation publication-type="other">The Court of Justice of the European Union (<year>2016</year>) <italic toggle="yes">C-582/14.</italic> ECJ.</mixed-citation>
    </ref>
    <ref id="btaa764-B50">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vatsalan</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2013</year>) <article-title>A taxonomy of privacy-preserving record linkage techniques</article-title>. <source>Inf. Syst</source>., <volume>38</volume>, <fpage>946</fpage>–<lpage>969</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B51">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Vatsalan</surname><given-names>D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>). <part-title>Privacy-preserving record linkage for big data: current approaches and research challenges</part-title>. In <person-group person-group-type="editor"><string-name><surname>Zomaya</surname><given-names>A.Y.</given-names></string-name> and <string-name><surname>Sakr</surname><given-names>S.</given-names></string-name></person-group> (eds.) <source>Handbook of Big Data Technologies</source>. <publisher-name>Springer International Publishing</publisher-name>, <publisher-loc>Cham</publisher-loc>., pp. <fpage>851</fpage>–<lpage>895</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B52">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wiesner</surname><given-names>S.</given-names></string-name></person-group> (<year>1983</year>) <article-title>Conjugate coding</article-title>. <source>ACM SIGACT News</source>, <volume>15</volume>, <fpage>78</fpage>–<lpage>88</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B53">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Winkler</surname><given-names>W.E.</given-names></string-name></person-group> (<year>2014</year>) <article-title>Matching and record linkage</article-title>. <source>Wiley Interdiscipl. Rev. Comput. Stat</source>., <volume>6</volume>, <fpage>313</fpage>–<lpage>325</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B54">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Yao</surname><given-names>A.C.-C.</given-names></string-name></person-group> (<year>1986</year>) <part-title>How to Generate and Exchange Secrets (Extended Abstract</part-title>). In John,H. (ed.) <source>FOCS</source>. <publisher-name>IEEE Computer Society</publisher-name>, Washington D.C., USA, pp. <fpage>162</fpage>–<lpage>167</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B55">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Zabicki</surname><given-names>R.</given-names></string-name>, <string-name><surname>Ellis</surname><given-names>S.R.</given-names></string-name></person-group> (<year>2017</year>) <part-title>Penetration testing</part-title>. In <person-group person-group-type="editor"><string-name><surname>Vacca</surname><given-names>J.R.</given-names></string-name></person-group> (ed.) <source>Computer and Information Security Handbook, Chapter 75</source>. Morgan Kaufmann, Boston, USA, <publisher-name> pp. </publisher-name><fpage>1031</fpage>–<lpage>1038</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa764-B56">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zahur</surname><given-names>S.</given-names></string-name>, <string-name><surname>Evans</surname><given-names>D.</given-names></string-name></person-group> (<year>2015</year>) <article-title>Obliv-C: a language for extensible data-oblivious computation</article-title>. <source>IACR Cryptol. ePrint Arch</source>., <volume>2015</volume>, <fpage>1153</fpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
