<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6612857</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz347</article-id>
    <article-id pub-id-type="publisher-id">btz347</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2019 Conference Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genomic Variation Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Efficient haplotype matching between a query and a panel for genealogical search</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Naseri</surname>
          <given-names>Ardalan</given-names>
        </name>
        <xref ref-type="aff" rid="btz347-aff1">1</xref>
        <xref ref-type="author-notes" rid="btz347-FM2"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Holzhauser</surname>
          <given-names>Erwin</given-names>
        </name>
        <xref ref-type="aff" rid="btz347-aff1">1</xref>
        <xref ref-type="author-notes" rid="btz347-FM2"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zhi</surname>
          <given-names>Degui</given-names>
        </name>
        <xref ref-type="aff" rid="btz347-aff2">2</xref>
        <xref ref-type="corresp" rid="btz347-cor1"/>
        <!--<email>degui.zhi@uth.tmc.edu</email>-->
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-4051-5549</contrib-id>
        <name>
          <surname>Zhang</surname>
          <given-names>Shaojie</given-names>
        </name>
        <xref ref-type="aff" rid="btz347-aff1">1</xref>
        <xref ref-type="corresp" rid="btz347-cor1"/>
        <!--<email>shzhang@cs.ucf.edu</email>-->
      </contrib>
    </contrib-group>
    <aff id="btz347-aff1"><label>1</label>Department of Computer Science, University of Central Florida, Orlando, FL, USA</aff>
    <aff id="btz347-aff2"><label>2</label>School of Biomedical Informatics and School of Public Health, University of Texas Health Science Center at Houston, Houston, TX, USA</aff>
    <author-notes>
      <corresp id="btz347-cor1">To whom correspondence should be addressed. <email>degui.zhi@uth.tmc.edu</email> or <email>shzhang@cs.ucf.edu</email></corresp>
      <fn id="btz347-FM2">
        <p>The authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint First Authors.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-05">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>35</volume>
    <issue>14</issue>
    <fpage>i233</fpage>
    <lpage>i241</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz347.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>With the wide availability of whole-genome genotype data, there is an increasing need for conducting genetic genealogical searches efficiently. Computationally, this task amounts to identifying shared DNA segments between a query individual and a very large panel containing millions of haplotypes. The celebrated Positional Burrows-Wheeler Transform (PBWT) data structure is a pre-computed index of the panel that enables constant time matching at each position between one haplotype and an arbitrarily large panel. However, the existing algorithm (Durbin’s Algorithm 5) can only identify set-maximal matches, the longest matches ending at any location in a panel, while in real genealogical search scenarios, multiple ‘good enough’ matches are desired.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this work, we developed two algorithmic extensions of Durbin’s Algorithm 5, that can find all <italic>L</italic>-long matches, matches longer than or equal to a given length <italic>L</italic>, between a query and a panel. In the first algorithm, PBWT-Query, we introduce ‘virtual insertion’ of the query into the PBWT matrix of the panel, and then scanning up and down for the PBWT match blocks with length greater than <italic>L</italic>. In our second algorithm, L-PBWT-Query, we further speed up PBWT-Query by introducing additional data structures that allow us to avoid iterating through blocks of incomplete matches. The efficiency of PBWT-Query and L-PBWT-Query is demonstrated using the simulated data and the UK Biobank data. Our results show that our proposed algorithms can detect related individuals for a given query efficiently in very large cohorts which enables a fast on-line query search.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>genome.ucf.edu/pbwt-query</p>
      </sec>
      <sec id="s4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">US National Institutes of Health</named-content>
        </funding-source>
        <award-id>R01HG010086</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>The increasing volumes of whole-genome genotype data, partly due to the steady drop in the cost of genotyping (<xref rid="btz347-B5" ref-type="bibr">Campbell <italic>et al.</italic>, 2015</xref>; <xref rid="btz347-B10" ref-type="bibr">Jiang <italic>et al.</italic>, 2016</xref>), offer a new opportunity to study genetic relationships and relatedness between individuals. In the public domain, biobank-scale SNP array projects have collected large amounts of genotype data. For example, UK Biobank has released genotype and health-related data of ∼500 k individuals in the UK (<xref rid="btz347-B4" ref-type="bibr">Bycroft <italic>et al.</italic>, 2018</xref>; <xref rid="btz347-B19" ref-type="bibr">Sudlow <italic>et al.</italic>, 2015</xref>). However, this sample size is dwarfed by the collections in consumer genetics companies. As of July 2018, 23andMe claims to have over 5 million customers and have collected the genotype data of all customers. AncestryDNA has collected DNAs of more than 10 million individuals. It has been projected that genotype data of more than 100 million individuals will be available through direct-to-consumer companies by 2021 (<xref rid="btz347-B11" ref-type="bibr">Khan and Mittelman, 2018</xref>).</p>
    <p>Genetic relationships among individuals are reflected in Identity by Descent (IBD) segments, shared DNA segments between a pair of individuals that have been inherited from a common ancestor. The length of IBD segments correlates with how recently two individuals share a common ancestor. A pair of individuals that share a common ancestor in a more recent generation may share more IBD segments, of larger length, compared with a pair of individuals that share a common ancestor less recently (<xref rid="btz347-B20" ref-type="bibr">Thompson, 2013</xref>). Therefore, in genotype or haplotype sequences, IBD segments that define a recent common ancestor correspond to long matches of DNA sequences. It has been projected that about 60% of individuals of European descent have a third-degree cousin or closer relative in a current database of over 1 million (<xref rid="btz347-B8" ref-type="bibr">Erlich <italic>et al.</italic>, 2018</xref>) that can be found using IBD segments.</p>
    <p>Previous research efforts were mostly focused on ‘M-vs-M’ matches of IBD segments. For a collection (panel) with <italic>M</italic> individuals or haplotypes, the goal was to identify all IBD segments between any pairs of individuals in the panel. Several methods have been proposed to detect all pairwise IBD segments in a panel (<xref rid="btz347-B1" ref-type="bibr">Browning and Browning, 2011</xref>, <xref rid="btz347-B2" ref-type="bibr">2013a</xref>, <xref rid="btz347-B3" ref-type="bibr">b</xref>; <xref rid="btz347-B9" ref-type="bibr">Gusev <italic>et al.</italic>, 2009</xref>; <xref rid="btz347-B16" ref-type="bibr">Purcell <italic>et al.</italic>, 2007</xref>; <xref rid="btz347-B17" ref-type="bibr">Rodriguez <italic>et al.</italic>, 2013</xref>, <xref rid="btz347-B18" ref-type="bibr">2015</xref>). Most of these works rely on pairwise comparisons and thus with computational complexity <italic>O</italic>(<italic>NM</italic><sup>2</sup>), where <italic>N</italic> is the length of the genome. GERMLINE (<xref rid="btz347-B9" ref-type="bibr">Gusev <italic>et al.</italic>, 2009</xref>) is a fast ‘M-vs-M’ method claimed to be linear to the size of the panel [<italic>O</italic>(<italic>NM</italic>)] for random sequences. However, real genetic sequences typically contain repetitive local haplotypes and thus GERMLINE does not demonstrate linear behavior in real sequences. <xref rid="btz347-B7" ref-type="bibr">Durbin (2014)</xref> proposed an efficient genotype indexing method for storing and searching haplotype sequences. The proposed method, called Positional Burrows-Wheeler Transform (PBWT), is based on sorting the haplotype sequences based on their reversed prefix order. PBWT enables an efficient haplotype search among the haplotypes within a panel and has been applied for genotype phasing and imputation (<xref rid="btz347-B12" ref-type="bibr">Loh <italic>et al.</italic>, 2016a</xref>, <xref rid="btz347-B13" ref-type="bibr">b</xref>).</p>
    <p>For genealogical search, finding all matches greater than or equal to a certain length between a haplotype query and panel is desired. This can be thought of as finding all individuals in a panel related to the query that have a common ancestor in recent generations, which reveals more information about the query than set-maximal matches. A trivial example illustrates our point: in a large population containing a single pair of identical twins, the only set-maximal match that exists between any pair of individuals is the match between the twins spanning the length of the twins. All other relationships between any pair of individuals are missed. In the general case, to a lesser degree, examining only the longest set-maximal matches misses the majority of measurable genetic relationships between pairs of individuals in a population. The length of matches correlates with the number of generations that two individuals share a common ancestor. As a result, it can be applied to find multiple relatives of a given query individual up to a given degree of relatedness.</p>
    <p>The problem under consideration of this project is to develop an algorithm independent from the number of haplotypes for identifying all long IBD segments between a query and a panel, i.e. ‘1-vs-M’ search, given <italic>M</italic> haplotypes in the panel. Why is the time complexity independent from the number of haplotypes or individuals important? This is because when the panel contains millions of individuals, naive methods of all pairwise comparison [with computational complexity <italic>O</italic>(<italic>NM</italic>)] will be too slow for real-time applications. However, no efficient on-line method yet exists to identify all long IBD segments between a query and a panel. GERMLINE (<xref rid="btz347-B9" ref-type="bibr">Gusev <italic>et al.</italic>, 2009</xref>) does yet not offer a direct algorithm for ‘1-vs-M’ search. Durbin’s Algorithm 5 (<xref rid="btz347-B7" ref-type="bibr">Durbin, 2014</xref>) can find the single longest set-maximal matches between a query haplotype and all haplotypes in the panel with runtime <italic>O</italic>(<italic>N</italic>), i.e. independent from the number of haplotypes in the panel. However, in practice, multiple ‘good enough’ matches are desired for a genealogical search. Of note, one might be tempted to repeatedly apply Durbin’s set-maximal matches algorithm and exclude the detected match at each run. This solution would not be practical, since the indices for the panel need to be re-computed or updated after each detected match. To our knowledge, there are no algorithms to find all <italic>L</italic>-long matches, matches longer than or equal to a given length <italic>L</italic> between a query and a panel of haplotypes, independent from <italic>M</italic>.</p>
    <p>In this work, we present a set of efficient algorithms that can identify all <italic>L</italic>-long matches of a given query in an arbitrarily large panel. We address the main limitation of Durbin’s original PBWT algorithm that cannot find all <italic>L</italic>-long matches for a new query efficiently. First, we introduce an efficient approach for finding long matches to a query using PBWT, named PBWT-Query. The key idea of PBWT-Query is to ‘virtually’ insert the query haplotype into the PBWT matrix of the panel, and then scan up and down in the PBWT index for any long match. However, this algorithm may not be efficient when matches are numerous and the cost of scanning is non-negligible. To address this issue, we developed a second algorithm, L-PBWT-Query, that introduces additional pre-computed array data structures, named Linked Equal/Alternating Positions (LEAP) arrays, to help skip unnecessary repetitive up-and-down scanning of PBWT-Query at each site. Moreover, we developed a memory-mapped implementation of the L-PBWT-Query that can alleviate the main memory burden added by the LEAP arrays and the PBWT panel. The time complexity of both PBWT-Query and L-PBWT-Query is independent from the number of haplotypes in the panel.</p>
    <p>In the next section, we describe the algorithm in detail, followed by simulation results that show the efficiency of PBWT-Query and L-PBWT-Query. Finally, the application on real data is demonstrated by using the one million haplotypes from the UK Biobank data to search for related individuals extracted from the panel.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Overview and notation</title>
      <p>PBWT (<xref rid="btz347-B7" ref-type="bibr">Durbin, 2014</xref>) facilitates an efficient approach to find all <italic>L</italic>-long matches, matches longer than or equal to a given length <italic>L</italic>, among the haplotypes in a panel. It also provides a fast approach to find the longest matches for a haplotype query in a panel. However, finding <italic>L</italic>-long matches to a query is of greater interest. Suppose we have a haplotype <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>…</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Then, <italic>s</italic>[<italic>i</italic>, <italic>j</italic>) denotes the subsequence <inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>…</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> denotes the length of <italic>s</italic>, i.e. <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>. When we compare any haplotype sequences, we always assume that they share the same sites, number of sites, and ordering of sites. To follow the notations of <xref rid="btz347-B7" ref-type="bibr">Durbin (2014)</xref>, we define the haplotype matrix of <italic>X</italic> as the matrix whose <italic>i</italic>th row is <italic>x<sub>i</sub></italic>.</p>
      <p>We can formulate our problem as follows: Given a query haplotype <italic>z</italic> and a database of haplotypes <inline-formula id="IE5"><mml:math id="IM5"><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:mo>|</mml:mo><mml:mi>z</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> for any <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula>, we would like to find all <italic>L</italic>-long matches that are greater than or equal to length <italic>L</italic> between <italic>z</italic> and all <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula>. We say that there is an <italic>L</italic>-long match between <italic>z</italic> and <italic>x<sub>i</sub></italic> from sites <italic>e</italic> to <italic>k</italic> if <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula>, <italic>e</italic> = 0 or <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>e</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>e</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic>k</italic> = <italic>N</italic> or <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. that match from <italic>e</italic> to <italic>k</italic> between <italic>z</italic> and <italic>x<sub>i</sub></italic> cannot be extended in either direction. To find <italic>L</italic>-long matches to a query, we first find the position of the query in the PBWT panel at each site. All of the possible <italic>L</italic>-long matches ending at a given site <italic>k</italic> will occur in contiguous blocks of haplotypes adjacent to the ‘would be’ position of the query in the panel sorted by the reverse of the prefix ending at site <italic>k</italic>. Hence, we can scan the neighboring sequences in the PBWT panel to find <italic>L</italic>-long matches. The time complexity of PBWT-Query is <inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo>−</mml:mo><mml:mi>L</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>R</italic> is the average length of the matches, and <italic>c</italic> is the total number of matches.</p>
      <p>To speed up the search, we use LEAP arrays to reduce the search space of possible matches that terminate at each site <italic>k</italic> by skipping over haplotypes whose matches can still be extended to further sites. The LEAP arrays consist of arrays <inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>nd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>nd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> for each site <italic>k</italic>, which we formally define in the Notation section. These arrays are generated from the PBWT matrix and independent from the query haplotype. We called this new approach L-PBWT-Query, whose worst-case time complexity is <italic>O</italic>(<italic>N</italic> + <italic>c</italic>), where <italic>c</italic> is the number of <italic>L</italic>-long matches. The LEAP arrays can be pre-computed in <italic>O</italic>(<italic>NM</italic>) time, and require <italic>O</italic>(<italic>NM</italic>) space in main memory or hard disk. Therefore, the greatest utility of our approach is the use-case where the user has a large amount of hard disk or main memory space and a constant (or infrequently changing) database haplotype panel and wants to perform many queries on the same panel. In this case, the database population needs only be pre-computed once to achieve subsequently fast. Following, we introduce PBWT data structures and LEAP arrays.</p>
      <sec>
        <label>2.1.1</label>
        <title>PBWT matrix and positional prefix array</title>
        <p>We define the haplotypes in <italic>X</italic> sorted by the <italic>k</italic>th reversed prefix (i.e. by the reverse of sites 0 to <italic>k</italic> − 1) as <italic>y<sup>k</sup></italic>, and the positional prefix array <italic>a<sub>k</sub></italic> containing a permutation of the indices 0 to <italic>M</italic> − 1 such that <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. For every <italic>y<sup>k</sup></italic>, we refer to the contiguous block of haplotypes <inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> as <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>; similarly, <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> refers to <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, etc. For example, if <italic>X</italic> = {1001, 1111, 0100}, then, <italic>y</italic><sup>3</sup> = {1001, 0100, 1111} and <italic>a</italic><sub>3</sub> = {0, 2, 1}. Then, we refer to the PBWT matrix as the matrix whose <italic>i</italic>th column corresponds to the <italic>i</italic>th column of <italic>y<sup>i</sup></italic>.</p>
      </sec>
      <sec>
        <label>2.1.2</label>
        <title>Divergence array</title>
        <p>We define the divergence array <italic>d<sub>k</sub></italic> such that <italic>d<sub>k</sub></italic>[<italic>i</italic>] is the starting position of the longest match between <inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> ending at <italic>k</italic> (<xref rid="btz347-B7" ref-type="bibr">Durbin, 2014</xref>), i.e. <italic>d<sub>k</sub></italic> gives the starts of all the longest matches ending at a given <italic>k</italic> for any two adjacent haplotypes in <italic>y<sup>k</sup></italic>. The longest match between some <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> (<italic>i</italic> &lt; <italic>j</italic>) ending at <italic>k</italic> begins at <inline-formula id="IE26"><mml:math id="IM26"><mml:mrow><mml:munder><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>m</mml:mi><mml:mo>≤</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <label>2.1.3</label>
        <title>LEAP arrays</title>
        <p>Here, we formally define the LEAP arrays: <italic>I</italic><sub>ps</sub>, <italic>I</italic><sub>pd</sub>, <italic>I</italic><sub>ns</sub>, <italic>I</italic><sub>nd</sub>, <italic>D</italic><sub>ps</sub>, <italic>D</italic><sub>pd</sub>, <italic>D</italic><sub>ns</sub> and <italic>D</italic><sub>nd</sub>. For each <inline-formula id="IE27"><mml:math id="IM27"><mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. each column of the PBWT matrix, we maintain four indices: <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>nd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>. <italic>I</italic><sub>ps</sub> and <italic>I</italic><sub>ns</sub> allow us to jump around between equal values within each column of the PBWT matrix. Similarly, <italic>I</italic><sub>pd</sub> and <italic>I</italic><sub>nd</sub> allow us to jump around between differing values within each column of the PBWT matrix. The subscripts <italic>ps</italic>, <italic>pd</italic>, <italic>ns</italic> and <italic>nd</italic> are shorthand for previous-same, previous-different, next-same and next-different, respectively, which will make sense below. If <italic>j</italic> is the largest index such that <inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic>j</italic> &lt; <italic>i</italic>, <inline-formula id="IE31"><mml:math id="IM31"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>; that is, we can use <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to jump in <italic>y<sup>k</sup></italic> from a given haplotype to the closest preceding haplotype that has the same value at <italic>k</italic>. If <italic>j</italic> is the largest index such that <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic>j</italic> &lt; <italic>i</italic>, <inline-formula id="IE34"><mml:math id="IM34"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>; that is, we can use <inline-formula id="IE35"><mml:math id="IM35"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to jump in <italic>y<sup>k</sup></italic> from a given haplotype to the closest preceding haplotype that has a different value at <italic>k</italic>. If <italic>j</italic> is the smallest index such that <inline-formula id="IE36"><mml:math id="IM36"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic>j</italic> &gt; <italic>i</italic>, <inline-formula id="IE37"><mml:math id="IM37"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>; that is, we can use <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to jump in <italic>y<sup>k</sup></italic> from a given haplotype to the closest proceeding haplotype that has the same value at <italic>k</italic>. Finally, if <italic>j</italic> is the smallest index such that <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic>j</italic> &gt; <italic>i</italic>, <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>nd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>; i.e. we can use <inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>nd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to jump in <italic>y<sup>k</sup></italic> from a given haplotype to the closest proceeding haplotype that has the different value at <italic>k</italic>. Although these indices facilitate our ability to skip unnecessary haplotypes during our search, when we jump between haplotypes, we need to know if the block of potential <italic>L</italic>-long matches terminated in the skipped haplotypes. If any divergence value for the skipped haplotypes is larger than <italic>L</italic> − <italic>k</italic>, we know that our query cannot have an <italic>L</italic>-long match ending at <italic>k</italic> to the haplotype that we jumped to. Therefore, we maintain four additional arrays: <italic>D</italic><sub>ps</sub>, <italic>D</italic><sub>pd</sub>, <italic>D</italic><sub>ns</sub> and <italic>D</italic><sub>nd</sub>, which are natural counterparts to <italic>I</italic><sub>ps</sub>, <italic>I</italic><sub>pd</sub>, <italic>I</italic><sub>ns</sub> and <italic>I</italic><sub>nd</sub>. Each of these stores the largest divergence value between the haplotypes that we skipped, depending on the index that we used to jump. For example, if we use <inline-formula id="IE42"><mml:math id="IM42"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> to jump from <inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> will give us <inline-formula id="IE45"><mml:math id="IM45"><mml:mrow><mml:munder><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>r</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>; similarly, if we use <inline-formula id="IE46"><mml:math id="IM46"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> to jump from <inline-formula id="IE47"><mml:math id="IM47"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE48"><mml:math id="IM48"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> will give us <inline-formula id="IE49"><mml:math id="IM49"><mml:mrow><mml:munder><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>r</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. <italic>D</italic><sub>ps</sub>, <italic>D</italic><sub>pd</sub>, <italic>D</italic><sub>ns</sub> and <italic>D</italic><sub>nd</sub> are undefined when fewer than two haplotypes are skipped using <italic>I</italic><sub>ps</sub>, <italic>I</italic><sub>pd</sub>, <italic>I</italic><sub>ns</sub> and <italic>I</italic><sub>nd</sub>, respectively; in those cases, we can use the divergence arrays directly.</p>
      </sec>
    </sec>
    <sec>
      <title>2.2 PBWT-Query: finding all <italic>L</italic>-long matches from a new sequence <italic>z</italic> to <italic>X</italic> in <inline-formula id="IE50"><mml:math id="IM50"><mml:mrow><mml:mi mathvariant="italic">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">N</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">R</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="italic">L</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time</title>
      <sec>
        <label>2.2.1</label>
        <title>‘Virtual insertion’ of the query haplotype</title>
        <p><xref ref-type="fig" rid="btz347-F1">Figure 1</xref> shows a simple example of virtually inserting a query haplotype to the PBWT panel. The position of the new haplotype at each site will be adjacent to the longest match at the site <italic>k</italic>. <xref rid="btz347-B7" ref-type="bibr">Durbin (2014)</xref> proposed an efficient algorithm to find all set-maximal matches between a query <italic>z</italic> and a panel <italic>X</italic>, UpdateZMatches [Durbin’s Algorithm 5 (<xref rid="btz347-B7" ref-type="bibr">Durbin, 2014</xref>)]. A set-maximal match (<xref rid="btz347-B7" ref-type="bibr">Durbin, 2014</xref>), between <italic>z</italic> and some <inline-formula id="IE51"><mml:math id="IM51"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula> is defined as an <italic>L</italic>-long match (<inline-formula id="IE52"><mml:math id="IM52"><mml:mrow><mml:mi>L</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) between <italic>z</italic> and <italic>x<sub>i</sub></italic> from <italic>e</italic> to <italic>k</italic> such that there does not exist a match between <italic>z</italic> and any other <inline-formula id="IE53"><mml:math id="IM53"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>X</mml:mi><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from <inline-formula id="IE54"><mml:math id="IM54"><mml:mrow><mml:mi>e</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE55"><mml:math id="IM55"><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE56"><mml:math id="IM56"><mml:mrow><mml:mi>e</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE57"><mml:math id="IM57"><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. Simply, the match between <italic>z</italic> and <italic>x<sub>i</sub></italic> is set-maximal if it cannot be extended in either direction, and <italic>z</italic> does not have a larger match to any other haplotype in <italic>X</italic> whose indices enclose the indices of its match to <italic>x<sub>i</sub></italic>. To find all set-maximal matches at <italic>k</italic>, UpdateZMatches computes three values: <italic>f<sub>k</sub></italic>, <italic>g<sub>k</sub></italic> and <italic>e<sub>k</sub></italic> such that <italic>z</italic> has a set-maximal match to <inline-formula id="IE58"><mml:math id="IM58"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE59"><mml:math id="IM59"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> from <italic>e<sub>k</sub></italic> to <italic>k</italic> if <inline-formula id="IE60"><mml:math id="IM60"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE61"><mml:math id="IM61"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. It computes <italic>f<sub>k</sub></italic>, <italic>g<sub>k</sub></italic> and <italic>e<sub>k</sub></italic> based on <inline-formula id="IE62"><mml:math id="IM62"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE63"><mml:math id="IM63"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. A detailed routine for computing <italic>f<sub>k</sub></italic>, <italic>g<sub>k</sub></italic> and <italic>e<sub>k</sub></italic> can be found in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Algorithm S1</xref>. To follow the notations of <xref rid="btz347-B7" ref-type="bibr">Durbin (2014)</xref>, we define <italic>w</italic> such that <inline-formula id="IE64"><mml:math id="IM64"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE65"><mml:math id="IM65"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>u<sub>k</sub></italic>[<italic>i</italic>] is the number of zero values at site <italic>k</italic> in <inline-formula id="IE66"><mml:math id="IM66"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mn>0</mml:mn><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE67"><mml:math id="IM67"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the number of one values at site <italic>k</italic> in <inline-formula id="IE68"><mml:math id="IM68"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mn>0</mml:mn><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE69"><mml:math id="IM69"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, and <italic>c<sub>k</sub></italic> is the total number of zeros at site <italic>k</italic>.
</p>
        <fig id="btz347-F1" orientation="portrait" position="float">
          <label>Fig. 1.</label>
          <caption>
            <p>An example of virtually inserting a new query haplotype to a PBWT panel at site <italic>k</italic>. The haplotype sequences of the panel are sorted based on the reversed prefix order in the PBWT panel at site <italic>k</italic></p>
          </caption>
          <graphic xlink:href="btz347f1"/>
        </fig>
        <p>It is the case that if <italic>z</italic> were in <italic>y<sup>k</sup></italic>, it would occur in sorted order immediately preceding either <inline-formula id="IE70"><mml:math id="IM70"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE71"><mml:math id="IM71"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>. This is because <inline-formula id="IE72"><mml:math id="IM72"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> matches <inline-formula id="IE73"><mml:math id="IM73"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE74"><mml:math id="IM74"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, but <inline-formula id="IE75"><mml:math id="IM75"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (or <italic>e<sub>k</sub></italic> = 0). In both cases, if <inline-formula id="IE76"><mml:math id="IM76"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, <italic>z</italic> can go in sorted order immediately preceding <inline-formula id="IE77"><mml:math id="IM77"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>. Otherwise, it can immediately proceed to <inline-formula id="IE78"><mml:math id="IM78"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>. We refer to this index of <italic>y<sup>k</sup></italic> which would immediately proceed to <italic>z</italic> as <italic>h<sub>k</sub></italic>, and we can use this to find all <italic>L</italic>-long matches between <italic>z</italic> and <italic>X</italic> ending at <italic>k</italic>.</p>
        <p><inline-formula id="IE79"><mml:math id="IM79"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE80"><mml:math id="IM80"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> all have a match to <inline-formula id="IE81"><mml:math id="IM81"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> of at least length <inline-formula id="IE82"><mml:math id="IM82"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE83"><mml:math id="IM83"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE84"><mml:math id="IM84"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> all have a match to <inline-formula id="IE85"><mml:math id="IM85"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> of at least length <inline-formula id="IE86"><mml:math id="IM86"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. This implies that if we pick some haplotype <inline-formula id="IE87"><mml:math id="IM87"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> in <italic>X</italic>, we know that all matches to <inline-formula id="IE88"><mml:math id="IM88"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> ending at <italic>k</italic> of length greater than or equal to <italic>L</italic> occur in some block <inline-formula id="IE89"><mml:math id="IM89"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE90"><mml:math id="IM90"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>b</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> in <italic>y<sup>k</sup></italic> such that <italic>t</italic> &lt; <italic>b</italic>, <inline-formula id="IE91"><mml:math id="IM91"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>b</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE92"><mml:math id="IM92"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:munder><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>m</mml:mi><mml:mo>≤</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula>. It follows that all matches to <italic>X</italic> ending at <italic>k</italic>, whether from an external query haplotype or internal haplotype, occur in a contiguous block at <italic>y<sup>k</sup></italic>.</p>
      </sec>
      <sec>
        <label>2.2.2</label>
        <title>Reporting all <italic>L</italic>-long matches</title>
        <p>We know that all matches to <italic>z</italic> ending at <italic>k</italic> of length greater than or equal to <italic>L</italic> occur in a contiguous block <inline-formula id="IE93"><mml:math id="IM93"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE94"><mml:math id="IM94"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> in <italic>y<sup>k</sup></italic> such that <italic>t<sub>k</sub></italic> &lt; <italic>b<sub>k</sub></italic>, <inline-formula id="IE95"><mml:math id="IM95"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE96"><mml:math id="IM96"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:mi>m</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula>. What is left, then, is to find the smallest index <italic>t<sub>k</sub></italic> and largest index <italic>b<sub>k</sub></italic> that enclose the block of haplotypes with potential <italic>L</italic>-long matches. We say <italic>potential</italic> because each <inline-formula id="IE97"><mml:math id="IM97"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is only a <italic>match</italic> if <inline-formula id="IE98"><mml:math id="IM98"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, but not an <italic>L-long match</italic>, as the end of the match can be extended, i.e. <inline-formula id="IE99"><mml:math id="IM99"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> matches <inline-formula id="IE100"><mml:math id="IM100"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We define <inline-formula id="IE101"><mml:math id="IM101"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>z</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to be the smallest value such that <inline-formula id="IE102"><mml:math id="IM102"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>z</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> matches <inline-formula id="IE103"><mml:math id="IM103"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>z</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE104"><mml:math id="IM104"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to be the smallest value such that <inline-formula id="IE105"><mml:math id="IM105"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> matches <inline-formula id="IE106"><mml:math id="IM106"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We can use <inline-formula id="IE107"><mml:math id="IM107"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>z</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <italic>d<sub>k</sub></italic> to scan up <italic>y<sup>k</sup></italic> beginning at <inline-formula id="IE108"><mml:math id="IM108"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> until we find <inline-formula id="IE109"><mml:math id="IM109"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> (except in the case where <inline-formula id="IE110"><mml:math id="IM110"><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, printing <italic>L</italic>-long matches along the way. Similarly, we can use <inline-formula id="IE111"><mml:math id="IM111"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <italic>d<sub>k</sub></italic> to scan down <italic>y<sup>k</sup></italic> beginning at <inline-formula id="IE112"><mml:math id="IM112"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> until we find <inline-formula id="IE113"><mml:math id="IM113"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> (except in the case where <inline-formula id="IE114"><mml:math id="IM114"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, printing <italic>L</italic>-long matches along the way. Specifically, we can keep scanning in either direction so long as <inline-formula id="IE115"><mml:math id="IM115"><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula> for the particular <inline-formula id="IE116"><mml:math id="IM116"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> we are iterating through [similar to Durbin’s Algorithm 3 (<xref rid="btz347-B7" ref-type="bibr">Durbin, 2014</xref>)], and we can print an <italic>L</italic>-long match between <italic>z</italic> and <inline-formula id="IE117"><mml:math id="IM117"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> so long as <inline-formula id="IE118"><mml:math id="IM118"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Although scanning up, if <inline-formula id="IE119"><mml:math id="IM119"><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, the match between <italic>z</italic> and a particular <inline-formula id="IE120"><mml:math id="IM120"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> would begin at <inline-formula id="IE121"><mml:math id="IM121"><mml:mrow><mml:mi>max</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:munder><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>m</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Similarly, while scanning down, if <italic>b<sub>k</sub></italic> &gt; <italic>h<sub>k</sub></italic>, the match between <italic>z</italic> and a particular <inline-formula id="IE122"><mml:math id="IM122"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> would begin at <inline-formula id="IE123"><mml:math id="IM123"><mml:mrow><mml:mi>max</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>h</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:munder><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>m</mml:mi><mml:mo>≤</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. A detailed procedure of this approach is presented in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Algorithm S2</xref>.</p>
        <p><xref ref-type="fig" rid="btz347-F2">Figure 2</xref> illustrates searching for <italic>L</italic>-long matches for <italic>L</italic> = 3. For clarity, we have included example <italic>y<sup>k</sup>’</italic>s for <italic>k</italic> = 1, 2, 3, where we have highlighted in gray the reverse prefixes that are used to sort the rows of the haplotype matrix, and have included the sorted order of <italic>z</italic> in these panels. The key idea of our approach is, scanning through each site <italic>k</italic> from 0 to <italic>N</italic>, to find the would-be position of the query <italic>z</italic> in <italic>y<sup>k</sup></italic>. Then, we can scan up and down site <italic>k</italic> in <italic>y<sup>k</sup></italic> to search for <italic>L</italic>-long matches that end at that site. First, at each site <italic>k</italic>, we find the block of potential set-maximal matches ending at <italic>k</italic>, labeled in purple. If <italic>z</italic> were in <italic>y<sup>k</sup></italic>, it would occur at the beginning or end of this block. In this example, <italic>z</italic> always happens to be at the beginning of the purple blocks, but it can also occur at the end. As we scan through this block, we output an <italic>L</italic>-long match ending at each green position if, at that position, there is a mismatch between that individual and the query.
</p>
        <fig id="btz347-F2" orientation="portrait" position="float">
          <label>Fig. 2.</label>
          <caption>
            <p>An example of searching for <italic>L</italic>-long matches of length ≥3 in a panel with five haplotypes comprising eight sites. <bold>(A)</bold> The haplotype matrix (<italic>y</italic><sup>0</sup>) and the query <italic>z</italic>. <bold>(B)</bold> The PBWT matrix. <italic>i</italic>th column in the PBWT matrix corresponds to the <italic>i</italic>th column of <italic>y<sup>i</sup></italic>. <bold>(C)</bold> The positional prefix arrays. Each row depicts the positional prefix array <italic>a<sub>k</sub></italic>. Each positional prefix array <italic>a<sub>k</sub></italic> contains the permutation of indices 0 to <italic>N</italic> − 1 such that <inline-formula id="IE124"><mml:math id="IM124"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. <bold>(D)</bold><italic>y<sup>k’</sup></italic>s for <italic>k</italic> = 1, 2, 3. The haplotypes in <italic>X</italic> sorted by the <italic>k</italic>th reversed prefix (i.e. by the reverse of sites 0 to <italic>k</italic> − 1) are referred as <italic>y<sup>k</sup></italic>. The prefixes used to sort are shaded in gray in <italic>y</italic><sup>1</sup>, <italic>y</italic><sup>2</sup> and <italic>y</italic><sup>3</sup>. The blocks of potential set-maximal matches ending at <italic>k</italic> are labeled in purple, the index of the haplotype that immediately proceeds to <italic>z</italic> is highlighted as red, and the intervals of potential <italic>L</italic>-long matches ending at each site are highlighted in lime green. <italic>f</italic> and <italic>g</italic> which enclose the block of potential set-maximal matches are underlined</p>
          </caption>
          <graphic xlink:href="btz347f2"/>
        </fig>
        <p>The time complexity of computing <italic>f<sub>k</sub></italic>, <italic>g</italic> and <italic>e<sub>k</sub></italic> is <italic>O</italic>(<italic>N</italic>) across all <italic>k</italic> (<xref rid="btz347-B7" ref-type="bibr">Durbin, 2014</xref>). For a given site, we may scan through all <italic>M</italic> haplotypes in search of <italic>t<sub>k</sub></italic> and <italic>b<sub>k</sub></italic>. If there is a block of matches that does not terminate at each site, we will still need to scan the entire block. As we do this for <italic>N</italic> sites, the time complexity of PBWT-Query is <inline-formula id="IE125"><mml:math id="IM125"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo>−</mml:mo><mml:mi>L</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>R</italic> is the average length of the matches and <italic>c</italic> the total number of matches. In the next section, we introduce L-PBWT-Query which employs additional data structures to achieve a time complexity independent from the number of haplotypes and the lengths of the matches.</p>
      </sec>
    </sec>
    <sec>
      <title>2.3 L-PBWT-Query: finding all <italic>L</italic>-long matches from a new sequence <italic>z</italic> to <italic>X</italic> in <inline-formula id="IE126"><mml:math id="IM126"><mml:mrow><mml:mi mathvariant="italic">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">N</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time</title>
      <p>Although searching for <italic>t<sub>k</sub></italic> and <italic>b<sub>k</sub></italic>, the smallest and largest indices that contain potential <italic>L</italic>-long matches, every <inline-formula id="IE127"><mml:math id="IM127"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> scanned through where <inline-formula id="IE128"><mml:math id="IM128"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (i.e. the match can be extended further) is unnecessary work. Therefore, if we can restrict our search at each site only to those <inline-formula id="IE129"><mml:math id="IM129"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE130"><mml:math id="IM130"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, we can improve the time complexity of searching for <italic>t<sub>k</sub></italic> and <italic>b<sub>k</sub></italic> across all sites to <inline-formula id="IE131"><mml:math id="IM131"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>c</italic> is the number of <italic>L</italic>-long matches. We can achieve this by maintaining a data structure that allows us to efficiently jump between <inline-formula id="IE132"><mml:math id="IM132"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of the same <italic>k</italic>, for <italic>i</italic> = 0 to <italic>M</italic> − 1 and <italic>k</italic> = 1 to <italic>N</italic> − 1. Again, the key idea is that we want to jump around between only those <inline-formula id="IE133"><mml:math id="IM133"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE134"><mml:math id="IM134"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. For bi-allelic data, if <italic>z</italic>[<italic>k</italic>] = 1, we primarily want to move around <inline-formula id="IE135"><mml:math id="IM135"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> that equal to 0, and similarly, if <italic>z</italic>[<italic>k</italic>] = 0, we primarily want to move around between <inline-formula id="IE136"><mml:math id="IM136"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> that equal to 1, to find matches that end at <italic>k</italic> + 1.</p>
      <sec>
        <label>2.3.1</label>
        <title>Speeding up PBWT-Query using LEAP arrays</title>
        <p>Using our data structure, we can modify the procedures to scan up and down in search of <italic>t<sub>k</sub></italic> and <italic>b<sub>k</sub></italic> once we have found <italic>h<sub>k</sub></italic>. Namely, when we scan up, we can use <inline-formula id="IE137"><mml:math id="IM137"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE138"><mml:math id="IM138"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to find the first <inline-formula id="IE139"><mml:math id="IM139"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> (<inline-formula id="IE140"><mml:math id="IM140"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>) such that <inline-formula id="IE141"><mml:math id="IM141"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, if such exists. Then, if necessary, we can use <inline-formula id="IE142"><mml:math id="IM142"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to keep searching only through haplotypes that differ from <italic>z</italic> at site <italic>k</italic>. Algorithm 1 demonstrates the updated routines which efficiently scan up a given <italic>y<sup>k</sup></italic> to find <italic>t<sub>k</sub></italic> and <italic>b<sub>k</sub></italic> using our data structure. Similarly, when we scan down, we can use <inline-formula id="IE143"><mml:math id="IM143"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE144"><mml:math id="IM144"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>nd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to find the first <inline-formula id="IE145"><mml:math id="IM145"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> (<inline-formula id="IE146"><mml:math id="IM146"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≥</mml:mo><mml:mi>h</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) such that <inline-formula id="IE147"><mml:math id="IM147"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, if such exists. Then, if necessary, we can use <inline-formula id="IE148"><mml:math id="IM148"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to keep searching only through haplotypes that differ from <italic>z</italic> at <italic>k</italic>. A detailed routine of the algorithm for scanning down is included in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Algorithm S3</xref>. Then, Algorithm 2 demonstrates our updated L-PBWT-Query that makes use of our improved scanning routines in Algorithm 1 and <xref ref-type="supplementary-material" rid="sup1">Supplementary Algorithm S3</xref>.</p>
        <p><xref ref-type="fig" rid="btz347-F3">Figure 3</xref> demonstrates <italic>y</italic><sup>30</sup> for an example genotype panel, along with the indices used to facilitate efficient query search. In the panel, <italic>t</italic> and <italic>b</italic> refer to the indices that define the block of haplotypes <inline-formula id="IE149"><mml:math id="IM149"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE150"><mml:math id="IM150"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> where all <italic>L</italic>-long matches for <italic>L</italic> = 4 ending at site 30 may occur. Within that block of haplotypes, we are interested in those <inline-formula id="IE151"><mml:math id="IM151"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE152"><mml:math id="IM152"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mn>30</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>30</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Since we would have to scan up from <inline-formula id="IE153"><mml:math id="IM153"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> to find <italic>t</italic> and scan down from <inline-formula id="IE154"><mml:math id="IM154"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> to find <italic>b</italic>, without the indices, we could end up scanning through the entire column, a worst-case <italic>O</italic>(<italic>M</italic>) operation; across all sites, we could end up performing <italic>O</italic>(<italic>NM</italic>) operations. However, with the indices, we only ever traverse through those sequences where the match ends at 30; so, at site 30, our scanning up and down is improved to worst-case <italic>O</italic>(number of matches ending at 30), and therefore, across all sites, our runtime is improved to worst-case <inline-formula id="IE155"><mml:math id="IM155"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>c</italic> is the number of <italic>L</italic>-long matches.
</p>
        <fig id="btz347-F3" orientation="portrait" position="float">
          <label>Fig. 3.</label>
          <caption>
            <p>An example of a haplotype panel with its corresponding indices to facilitate the search for <italic>L</italic>-long matches for <italic>L</italic> = 4 ending at site 30, exclusive. The indices <inline-formula id="IE156"><mml:math id="IM156"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>nd</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> allow jumping from any <inline-formula id="IE157"><mml:math id="IM157"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mn>30</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to the nearest <inline-formula id="IE158"><mml:math id="IM158"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mn>30</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> preceding or proceeding <inline-formula id="IE159"><mml:math id="IM159"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mn>30</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE160"><mml:math id="IM160"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mn>30</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mn>30</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE161"><mml:math id="IM161"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mn>30</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mn>30</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE162"><mml:math id="IM162"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE163"><mml:math id="IM163"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">nd</mml:mi></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> give us the largest divergence values from haplotypes skipped using <inline-formula id="IE164"><mml:math id="IM164"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ns</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE165"><mml:math id="IM165"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>nd</mml:mtext></mml:mrow><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, respectively. The indices for the seventh sequence in <italic>y</italic><sup>30</sup> are highlighted in the table. <italic>t</italic> and <italic>b</italic> refer to the top and bottom of the block of potential <italic>L</italic>-long matches in <italic>y</italic><sup>30</sup>, and <italic>h</italic> refers to the sequence that would immediately proceed to the query if it were in <italic>y</italic><sup>30</sup></p>
          </caption>
          <graphic xlink:href="btz347f3"/>
        </fig>
        <p>As before, the time complexity of computing <italic>f<sub>k</sub></italic>, <italic>g<sub>k</sub></italic> and <italic>e<sub>k</sub></italic> is <italic>O</italic>(<italic>N</italic>) across all <italic>k</italic> (<xref rid="btz347-B7" ref-type="bibr">Durbin, 2014</xref>). Now, our worst-case time complexity for scanning for <italic>t<sub>k</sub></italic> and <italic>b<sub>k</sub></italic> across all sites is <italic>O</italic>(<italic>N</italic> + <italic>c</italic>), where <italic>c</italic> is the number of <italic>L</italic>-long matches. So, our total worst-case time complexity for L-PBWT-Query is <italic>O</italic>(<italic>N</italic> + <italic>c</italic>), which is independent from the number of haplotypes <italic>M</italic>. Although our querying approach has a runtime linear in <italic>N</italic> and the number of <italic>L</italic>-long matches, our approach assumes that the PBWT, <italic>I</italic> matrices and <italic>D</italic> matrices for <italic>X</italic> are pre-computed, and stored in the hard disk. These can be computed in <italic>O</italic>(<italic>NM</italic>) time, and they occupy <italic>O</italic>(<italic>NM</italic>) space in the hard disk. Specifically, if <italic>X</italic> occupies <italic>NM</italic> memory, the additional <italic>I</italic> and <italic>D</italic> matrices occupy roughly 8<italic>NM</italic> memory.
</p>
        <p>
          <boxed-text id="btz347-BOX1" position="float" orientation="portrait">
            <label>Algorithm 1</label>
            <caption>
              <p> Scan Up For <italic>L</italic>-Long Matches</p>
            </caption>
            <p><bold>function</bold> ScanUp(<italic>k</italic>, <italic>h</italic>, <italic>d<sub>z</sub></italic>)</p>
            <p> <bold>if</bold><inline-formula id="IE166"><mml:math id="IM166"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula> and match ends at <italic>k</italic> + 1 <bold>then</bold></p>
            <p>  report match to <inline-formula id="IE167"><mml:math id="IM167"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> from <italic>d<sub>z</sub></italic> to <italic>k</italic> + 1</p>
            <p> <inline-formula id="IE168"><mml:math id="IM168"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>←</mml:mo><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula></p>
            <p> <bold>if</bold><inline-formula id="IE169"><mml:math id="IM169"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>  <bold>if</bold><inline-formula id="IE170"><mml:math id="IM170"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE171"><mml:math id="IM171"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>   //<italic>Use</italic><inline-formula id="IE172"><mml:math id="IM172"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>or</italic><inline-formula id="IE173"><mml:math id="IM173"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>to find the first</italic><inline-formula id="IE174"><mml:math id="IM174"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>(</italic><inline-formula id="IE175"><mml:math id="IM175"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula><italic>) such</italic></p>
            <p>   // that <inline-formula id="IE176"><mml:math id="IM176"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic>, if such exists</italic></p>
            <p>   <inline-formula id="IE177"><mml:math id="IM177"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>max</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>   <bold>if</bold><inline-formula id="IE178"><mml:math id="IM178"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE179"><mml:math id="IM179"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>    <inline-formula id="IE180"><mml:math id="IM180"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>max</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>    <inline-formula id="IE181"><mml:math id="IM181"><mml:mrow><mml:mi>t</mml:mi><mml:mo>←</mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>pd</mml:mtext></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>   <bold>else if</bold><inline-formula id="IE182"><mml:math id="IM182"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>    <inline-formula id="IE183"><mml:math id="IM183"><mml:mrow><mml:mi>t</mml:mi><mml:mo>←</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></p>
            <p>   //<italic>If necessary, we can use</italic><inline-formula id="IE184"><mml:math id="IM184"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>to keep searching only</italic></p>
            <p>   //<italic>through haplotypes that differ from z at site k</italic></p>
            <p>   <bold>while</bold><inline-formula id="IE185"><mml:math id="IM185"><mml:mrow><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE186"><mml:math id="IM186"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula><bold>do</bold></p>
            <p>    report match to <inline-formula id="IE187"><mml:math id="IM187"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> from <italic>d</italic><sub>max</sub> to <italic>k</italic> + 1</p>
            <p>    <bold>if</bold><inline-formula id="IE188"><mml:math id="IM188"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>     <inline-formula id="IE189"><mml:math id="IM189"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>max</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>    <inline-formula id="IE190"><mml:math id="IM190"><mml:mrow><mml:mi>t</mml:mi><mml:mo>←</mml:mo><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mtext>ps</mml:mtext></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  <bold>else</bold></p>
            <p>   <bold>while</bold><inline-formula id="IE191"><mml:math id="IM191"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula><bold>do</bold></p>
            <p>    <bold>if</bold><inline-formula id="IE192"><mml:math id="IM192"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>&gt;</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><bold>then</bold><inline-formula id="IE193"><mml:math id="IM193"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>    report match to <inline-formula id="IE194"><mml:math id="IM194"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> from <italic>d</italic><sub>max</sub> to <italic>k</italic> + 1</p>
            <p>    <inline-formula id="IE195"><mml:math id="IM195"><mml:mrow><mml:mi>t</mml:mi><mml:mo>←</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></p>
          </boxed-text>
        </p>
        <p>
          <boxed-text id="btz347-BOX2" position="float" orientation="portrait">
            <label>Algorithm 2</label>
            <caption>
              <p> L-PBWT-Query</p>
            </caption>
            <p><bold>for</bold><inline-formula id="IE196"><mml:math id="IM196"><mml:mrow><mml:mi>k</mml:mi><mml:mo>←</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> to <italic>N</italic> − 1 <bold>do</bold></p>
            <p> //<italic>z matches</italic><inline-formula id="IE197"><mml:math id="IM197"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>through</italic><inline-formula id="IE198"><mml:math id="IM198"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>from</italic><inline-formula id="IE199"><mml:math id="IM199"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic>until</italic></p>
            <p> //<italic>at least k + 1</italic></p>
            <p> <inline-formula id="IE200"><mml:math id="IM200"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> UpdateFandG(<italic>k</italic>)</p>
            <p> //<italic>z can be inserted into</italic><inline-formula id="IE201"><mml:math id="IM201"><mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula><italic>in sorted order either</italic></p>
            <p> //<italic>before</italic><inline-formula id="IE202"><mml:math id="IM202"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>or before</italic><inline-formula id="IE203"><mml:math id="IM203"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula></p>
            <p> <bold>if</bold><inline-formula id="IE204"><mml:math id="IM204"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>  <inline-formula id="IE205"><mml:math id="IM205"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p>
            <p>  <inline-formula id="IE206"><mml:math id="IM206"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>←</mml:mo><mml:mtext>max</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  <inline-formula id="IE207"><mml:math id="IM207"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>z</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p>
            <p> <bold>else</bold></p>
            <p>  <inline-formula id="IE208"><mml:math id="IM208"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p>
            <p>  <inline-formula id="IE209"><mml:math id="IM209"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>z</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>←</mml:mo><mml:mtext>max</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>  <inline-formula id="IE210"><mml:math id="IM210"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p>
            <p> <bold>if</bold><inline-formula id="IE211"><mml:math id="IM211"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>  ScanUp(<italic>k</italic>, <inline-formula id="IE212"><mml:math id="IM212"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>z</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>)</p>
            <p> <bold>if</bold><italic>h</italic> &lt; <italic>M</italic><bold>then</bold></p>
            <p>  ScanDown(<italic>k</italic>, <inline-formula id="IE213"><mml:math id="IM213"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mi>h</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>)</p>
          </boxed-text>
        </p>
      </sec>
      <sec>
        <label>2.3.2</label>
        <title>Memory-efficient implementation of L-PBWT-Query</title>
        <p>We implemented two versions of L-PBWT-Query: L-PBWT-Query (Memory-Mapped), where all of the pre-computed data structures are accessed using memory-mapped files using Boost libraries, and L-PBWT-Query (Memory-Extensive), where all of the pre-computed data structures are loaded into main memory. To clarify, L-PBWT-Query (Memory-Mapped) does not load all of the panel and data structures in main memory at once. Instead, parts of the panel and data structures are loaded from the appropriate files into memory in a ‘lazy loading’ fashion, i.e. as they are needed. Therefore, using memory-mapped files reduces I/O operations. This mechanism provides a relatively fast alternative to access the panel and data structures, especially if a panel has been recently queried by queries relatively similar to subsequent queries, which we refer to as ‘warming up’ a panel. When a panel is warmed up, relevant portions of the panel and data structures (a relatively small subset of the overall panel and data structures) have already been loaded into main memory and mapped to virtual memory, for faster subsequent access.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Benchmarking using simulated data</title>
      <p>We simulated a large haplotype panel using the Markovian Coalescent Simulator (MaCS) <xref rid="btz347-B6" ref-type="bibr">Chen <italic>et al.</italic> (2009)</xref> with the command macs 500001 2000000 -t .001 -r .001 -h 1e2 and extracted subsets of the panel for our benchmarking. For the purpose of benchmarking, we implemented PBWT-Query (Memory-Extensive) and Exhaustive Search. Exhaustive Search scans across the entire length of sites for each pair of the query and a haplotype in the panel, which has <italic>O</italic>(<italic>NM</italic>) time complexity. For all of our benchmarks, we used the following protocol: When running L-PBWT-Query (Memory-Mapped), for a given panel, we always warmed up a panel with three runs on the particular query, then averaged the runtime of three additional runs. When running PBWT-Query (Memory-Extensive), L-PBWT-Query (Memory-Extensive) and Exhaustive Search, we averaged the runtimes of three runs.</p>
      <p>First, we want to verify that the runtime of PBWT-Query and L-PBWT-Query, in practice, is truly independent from the number of haplotypes. To that end, we developed a benchmark which we refer to as the increasing haplotypes benchmark. <xref ref-type="fig" rid="btz347-F4">Figure 4</xref> and <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S1</xref> show the results of our increasing haplotypes benchmark, respectively, which support our assertion that the runtime of our approach is independent from the number of haplotypes. For this benchmark, we tested panels where we successively increased the number of haplotypes in the panel by a constant amount (from 20 000 to 200 000 haplotypes in steps of 20 000). In the first experiment, we kept the number of sites (10 000) and the number of matches (25 359) constant for the added haplotypes (<xref ref-type="fig" rid="btz347-F4">Fig. 4A</xref> and <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S1</xref>). The minimum length of match <italic>L</italic> was set to 1000. We can see that, indeed, for the Exhaustive Search, run time increases roughly linearly with the number of haplotypes (<italic>M</italic>). The runtime of our memory-mapped implementation stays roughly constant, even as we increase the number of haplotypes ten times. When compared with L-PBWT-Query (Memory-Extensive), there appears to be some constant overhead associated with fetching data from memory-mapped files, instead of cache or main memory. PBWT-Query runtime is similar to L-PBWT-Query as the number of matches remains constant. In the second experiment, we increased the number of haplotypes and the number of matches increases linearly (<xref ref-type="fig" rid="btz347-F4">Fig. 4B</xref> and <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S1</xref>). Both L-PBWT-Query implementations show a better runtime compared with PBWT-Query with increasing number of haplotypes and increasing number of matches.
</p>
      <fig id="btz347-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>Running time (in seconds) of searching for a query in panels containing 10 000 sites with increasing number of haplotypes <bold>(A)</bold> while keeping the number of matches constant and <bold>(B)</bold> with increasing number of matches</p>
        </caption>
        <graphic xlink:href="btz347f4"/>
      </fig>
      <p>Additionally, we want to concretely investigate the additive effect of increasing sites and increasing matches on the runtime of PBWT-Query and L-PBWT-Query. To that end, we developed a benchmark which we refer to as the increasing sites benchmark. <xref ref-type="fig" rid="btz347-F5">Figure 5</xref> is a plot of our increasing sites benchmarks, and <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S2</xref> gives the runtimes of those benchmarks. We performed two benchmarks: one where we successively increase the number of sites (from 20 000 to 200 000) while keeping the number of matches constant (<xref ref-type="fig" rid="btz347-F5">Fig. 5A</xref>), and another where we successively increase the number of sites (from 20 000 to 200 000) while the number of matches increases linearly with the number of sites (<xref ref-type="fig" rid="btz347-F5">Fig. 5B</xref>). From both of these figures, we can see that the runtime of our approach increases as expected, linearly with the number of sites and matches. As before, there is some constant overhead associated with fetching from memory-mapped files instead of main memory. All benchmarks were run on a 2.1 GHz server with 500 GB of RAM. The maximum resident sizes for the benchmarks are included in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Table S3</xref>.
</p>
      <fig id="btz347-F5" orientation="portrait" position="float">
        <label>Fig. 5.</label>
        <caption>
          <p>Running time (in seconds) of searching for a query in panels containing 20 000 haplotypes with increasing number of sites: <bold>(A)</bold> while keeping the number of matches relatively constant (∼70 000 matches) and <bold>(B)</bold> with increasing number of matches linearly with the number of sites</p>
        </caption>
        <graphic xlink:href="btz347f5"/>
      </fig>
    </sec>
    <sec>
      <title>3.2 Applying PBWT-Query and L-PBWT-Query on the UK Biobank data</title>
      <p>PBWT-Query and L-PBWT-Query were tested on the UK Biobank data (487 409 participants and 974 818 haplotypes for autosomal chromosomes) (<xref rid="btz347-B4" ref-type="bibr">Bycroft <italic>et al.</italic>, 2018</xref>) to demonstrate their utility on real data. The UK Biobank dataset includes pairwise kinship coefficients between individuals computed using the KING toolset <xref rid="btz347-B14" ref-type="bibr">Manichaikul <italic>et al.</italic> (2010)</xref>. According to the KING tutorial, the kinship coefficient ranges [0.177, 0.354], [0.0884, 0.177] and [0.0442, 0.0884] denote first-, second- and third-degree relationships, respectively. Here, a first-degree relationship refers to a parent–offspring or full-sibling relationship, a second-degree relationship includes half-siblings, avuncular pairs and grandparent–grandchild pairs, and a third-degree relationship includes the first-cousins <xref rid="btz347-B14" ref-type="bibr">Manichaikul <italic>et al.</italic> (2010)</xref>.</p>
      <p>The aim is to investigate whether potential genetic relationships from the UK Biobank data can be inferred by searching for exact matches using PBWT-Query or L-PBWT-Query. Because true IBDs can be disrupted by mismatches, the sum of the lengths of <italic>L</italic>-long matches between a pair of individuals was tested as a potential signal to differentiate first-, second- and third-degree relationships from each other, and from a background population. Two hundred individuals (400 haplotypes) which had genetic relationships within the UK Biobank data were chosen as queries. As a representative sample of the background population, one thousand individuals were randomly chosen from the UK Biobank excluding the 200 query individuals. The two hundred individuals were queried against the entire UK Biobank data for exact matches of length ≥ 700 SNPs in Chromosomes 1 through 22. This match length cutoff was chosen by following the precedent of 23andMe, whose simulations show that first, second and third cousin relationships can be reliably detected by haplotype matches of length ≥ 700 SNPs and 7 cM across all chromosomes. If we consider the detection power as the percentage of related pairs with any matches of length ≥ 700 SNPs, there is a 100% detection power in detecting potential first- and second-degree relationships by searching only in Chromosome 1. The detection power for first, second and third-degree relationships using all autosomal chromosomes is 100%. The queries were run using PBWT-Query and L-PBWT-Query (Memory-Extensive) on a 2.5 GHz server with 15 TB of SSD and 6 TB of RAM. The average time for running L-PBWT-Query a single query (one haplotype) on Chromosomes 1 through 22 is 6 s and for PBTW-Query 20 s, discounting the time to load the L-PBWT-Query data structures into memory. The maximum resident set size for L-PBWT-Query was 4.7 TB, and 2.4 TB for PBWT-Query.</p>
      <p>There is a promising separation between the three degrees of relatedness and the background population. <xref ref-type="fig" rid="btz347-F6">Figure 6A</xref> shows that the sum of the lengths of <italic>L</italic>-long matches between a pair of individuals is a capable signal to differentiate first-, second- and third-degree relationships from random pairs picked from the background population, and to filter potential first- second- and third-degree relationships for further processing. <xref ref-type="fig" rid="btz347-F6">Figure 6B</xref> shows an example of detected identical segments in Chromosome 1 between an individual (A) and two of their relatives (B and C) in the UK Biobank data. The two haplotypes for each individual are distinguished by 1 and 2 (e.g. A has haplotypes A1 and A2). The total length of the segments shared with the first-degree relative is significantly larger than those shared with the third-degree relative. We computed the AUC values to differentiate three degrees of relationships using the sum of the lengths of the shared segments. The AUC value between first- and third-degree relationships is 0.98, and AUC value between first- and second-degree relationships is 0.96. There are a few outliers in the second-degree relationships; however, the AUC value between the second- and third-degree relationships is 90%. Thus, identical segments interrupted due to genotyping or phasing errors can be used to infer the related individuals, and to estimate the degree of relatedness between closely related individuals, without careful post-processing of the interrupted matches.
</p>
      <fig id="btz347-F6" orientation="portrait" position="float">
        <label>Fig. 6.</label>
        <caption>
          <p>(<bold>A</bold>) Probability distributions of the sum of <italic>L</italic>-long matches (in cM) between the query and related individuals (first-, second- or third-degree), and random individuals in the UK Biobank data. Relatedness is computed using KING. <bold>(B)</bold> An example of detected identical segments in Chromosome 1 (in bps) for an individual with at least two relatives (first- and third-degree relatives) in the UK Biobank data</p>
        </caption>
        <graphic xlink:href="btz347f6"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this work, we proposed two efficient algorithms, PBWT-Query and L-PBWT-Query, for finding all <italic>L</italic>-long matches between a query haplotype and a panel. The time complexity of L-PBWT-Query does not rely on the number of haplotypes in the panel, which enables on-line genealogical search in large cohorts. Furthermore, the memory-mapped version of the algorithm, L-PBWT-Query (Memory-Mapped), will facilitate fast search when extensive main memory is not available, in exchange for a slightly increased running time. PBWT-Query shows similar runtime to L-PBWT-Query as the number of matches remains constant with the increasing number of haplotypes. However, the difference in efficiency becomes more obvious with the increasing number of matches.</p>
    <p>L-PBWT-Query (Memory-Mapped) does not require loading the entire panel into the main memory in order to facilitate a fast search. The tradeoff, however, is an increased running time due to increased I/O operations. We demonstrated that the running time of the L-PBWT-Query (Memory-Mapped) version is slightly worse than L-PBWT-Query (Memory-Extensive), but L-PBWT-Query (Memory-Mapped) will be more practical if extensive memory resources are not available.</p>
    <p>We applied L-PBWT-Query on ∼500 k individuals from the UK Biobank data and were able to detect close relatives of query individuals. The running time for all autosomal chromosomes in the UK Biobank data would be only a few seconds using a single CPU. Our results show that very close relatives can be easily found by L-PBWT-Query. We also ran PBWT-Query on the UK Biobank data. Although the memory usage for PBWT-Query was lower than L-PBWT-Query, the run time was moderately worse. To further improve detection, consideration of haplotype phasing quality will be needed. Another limitation of our work is that we have been focusing on developing efficient algorithms for exact matches of a query in the panel. In order to enhance the application on real datasets and detect more distant relatives, the algorithms need to be made tolerant to genotyping errors or mutations that could have occurred in real data, e.g. by random projection (<xref rid="btz347-B15" ref-type="bibr">Naseri <italic>et al.</italic>, 2017</xref>).</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>btz347_Supplementary_Data</label>
      <media xlink:href="btz347_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank Dr Xiaoqian Jiang for sharing computational resources. This research has been conducted using the UK Biobank Resource under Application Number 24247.</p>
    <sec>
      <title>Funding</title>
      <p>This work was supported by the US National Institutes of Health [R01HG010086].</p>
      <p><italic>Conflict of Interest</italic>: The authors, through their respective universities, have submitted a provisional patent application based on this technology. This does not restrict the non-commercial use of the methods described in this article.</p>
    </sec>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz347-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Browning</surname><given-names>B.L.</given-names></name>, <name name-style="western"><surname>Browning</surname><given-names>S.R.</given-names></name></person-group> (<year>2011</year>) 
<article-title>A fast, powerful method for detecting identity by descent</article-title>. <source>Am. J. Hum. Genet</source>., <volume>88</volume>, <fpage>173</fpage>–<lpage>182</lpage>.<pub-id pub-id-type="pmid">21310274</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Browning</surname><given-names>B.L.</given-names></name>, <name name-style="western"><surname>Browning</surname><given-names>S.R.</given-names></name></person-group> (<year>2013a</year>) 
<article-title>Detecting identity by descent and estimating genotype error rates in sequence data</article-title>. <source>Am. J. Hum. Genet</source>., <volume>93</volume>, <fpage>840</fpage>–<lpage>851</lpage>.<pub-id pub-id-type="pmid">24207118</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Browning</surname><given-names>B.L.</given-names></name>, <name name-style="western"><surname>Browning</surname><given-names>S.R.</given-names></name></person-group> (<year>2013b</year>) 
<article-title>Improving the accuracy and efficiency of identity-by-descent detection in population data</article-title>. <source>Genetics</source>, <volume>194</volume>, <fpage>459</fpage>–<lpage>471</lpage>.<pub-id pub-id-type="pmid">23535385</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bycroft</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>The UK Biobank resource with deep phenotyping and genomic data</article-title>. <source>Nature</source>, <volume>562</volume>, <fpage>203</fpage>–<lpage>209</lpage>.<pub-id pub-id-type="pmid">30305743</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Campbell</surname><given-names>N.R.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Genotyping-in-Thousands by sequencing (GT-seq): a cost effective SNP genotyping method based on custom amplicon sequencing</article-title>. <source>Mol. Ecol. Resour</source>., <volume>15</volume>, <fpage>855</fpage>–<lpage>867</lpage>.<pub-id pub-id-type="pmid">25476721</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chen</surname><given-names>G.K.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>Fast and flexible simulation of DNA sequence data</article-title>. <source>Genome Res</source>., <volume>19</volume>, <fpage>136</fpage>–<lpage>142</lpage>.<pub-id pub-id-type="pmid">19029539</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Durbin</surname><given-names>R.</given-names></name></person-group> (<year>2014</year>) 
<article-title>Efficient haplotype matching and storage using the positional Burrows-Wheeler transform (PBWT)</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>1266</fpage>–<lpage>1272</lpage>.<pub-id pub-id-type="pmid">24413527</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Erlich</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Identity inference of genomic data using long-range familial searches</article-title>. <source>Science</source>, <volume>362</volume>, <fpage>690</fpage>–<lpage>694</lpage>.<pub-id pub-id-type="pmid">30309907</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Gusev</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>Whole population, genome-wide mapping of hidden relatedness</article-title>. <source>Genome Res</source>., <volume>19</volume>, <fpage>318</fpage>–<lpage>326</lpage>.<pub-id pub-id-type="pmid">18971310</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jiang</surname><given-names>Z.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Genome wide sampling sequencing for SNP genotyping: methods, challenges and future development</article-title>. <source>Int. J. Biol. Sci</source>., <volume>12</volume>, <fpage>100</fpage>–<lpage>108</lpage>.<pub-id pub-id-type="pmid">26722221</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Khan</surname><given-names>R.</given-names></name>, <name name-style="western"><surname>Mittelman</surname><given-names>D.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Consumer genomics will change your life, whether you get tested or not</article-title>. <source>Genome Biol</source>., <volume>19</volume>, <fpage>120.</fpage><pub-id pub-id-type="pmid">30124172</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Loh</surname><given-names>P.R.</given-names></name></person-group><etal>et al</etal> (<year>2016a</year>) 
<article-title>Fast and accurate long-range phasing in a UK Biobank cohort</article-title>. <source>Nat. Genet</source>., <volume>48</volume>, <fpage>811</fpage>–<lpage>816</lpage>.<pub-id pub-id-type="pmid">27270109</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Loh</surname><given-names>P.R.</given-names></name></person-group><etal>et al</etal> (<year>2016b</year>) 
<article-title>Reference-based phasing using the Haplotype Reference Consortium panel</article-title>. <source>Nat. Genet</source>., <volume>48</volume>, <fpage>1443</fpage>–<lpage>1448</lpage>.<pub-id pub-id-type="pmid">27694958</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Manichaikul</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>Robust relationship inference in genome-wide association studies</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>2867</fpage>–<lpage>2873</lpage>.<pub-id pub-id-type="pmid">20926424</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Naseri</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>). 
<article-title>Ultra-fast identity by descent detection in biobank-scale cohorts using positional Burrows-Wheeler transform</article-title>. <source>bioRxiv</source>, <fpage>103325</fpage>.</mixed-citation>
    </ref>
    <ref id="btz347-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Purcell</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2007</year>) 
<article-title>PLINK: a tool set for whole-genome association and population-based linkage analyses</article-title>. <source>Am. J. Hum. Genet</source>., <volume>81</volume>, <fpage>559</fpage>–<lpage>575</lpage>.<pub-id pub-id-type="pmid">17701901</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B17">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Rodriguez</surname><given-names>J.M.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>). An accurate method for inferring relatedness in large datasets of unphased genotypes via an embedded likelihood-ratio test. In: <italic>Proceedings of the 17th International Conference on Research in Computational Molecular Biology</italic>, pp. <fpage>212</fpage>–<lpage>229</lpage>. 
<publisher-name>Springer, Berlin, Heidelberg</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btz347-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rodriguez</surname><given-names>J.M.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Parente2: a fast and accurate method for detecting identity by descent</article-title>. <source>Genome Res</source>., <volume>25</volume>, <fpage>280</fpage>–<lpage>289</lpage>.<pub-id pub-id-type="pmid">25273070</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sudlow</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>UK Biobank: an open access resource for identifying the causes of a wide range of complex diseases of middle and old age</article-title>. <source>PLoS Med</source>., <volume>12</volume>, <fpage>e1001779.</fpage><pub-id pub-id-type="pmid">25826379</pub-id></mixed-citation>
    </ref>
    <ref id="btz347-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Thompson</surname><given-names>E.A.</given-names></name></person-group> (<year>2013</year>) 
<article-title>Identity by descent: variation in meiosis, across genomes, and in populations</article-title>. <source>Genetics</source>, <volume>194</volume>, <fpage>301</fpage>–<lpage>326</lpage>.<pub-id pub-id-type="pmid">23733848</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
