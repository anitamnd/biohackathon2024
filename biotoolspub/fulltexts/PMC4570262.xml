<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4570262</article-id>
    <article-id pub-id-type="pmid">26370285</article-id>
    <article-id pub-id-type="publisher-id">709</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-015-0709-7</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Reference-free compression of high throughput sequencing data with a probabilistic de Bruijn graph</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Benoit</surname>
          <given-names>Gaëtan</given-names>
        </name>
        <address>
          <email>gaetan.benoit@inria.fr</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lemaitre</surname>
          <given-names>Claire</given-names>
        </name>
        <address>
          <email>claire.lemaitre@inria.fr</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lavenier</surname>
          <given-names>Dominique</given-names>
        </name>
        <address>
          <email>dominique.lavenier@irisa.fr</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Drezen</surname>
          <given-names>Erwan</given-names>
        </name>
        <address>
          <email>erwan.drezen@inria.fr</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Dayris</surname>
          <given-names>Thibault</given-names>
        </name>
        <address>
          <email>thibault.dayris@outlook.fr</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Uricaru</surname>
          <given-names>Raluca</given-names>
        </name>
        <address>
          <email>ruricaru@labri.fr</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Rizk</surname>
          <given-names>Guillaume</given-names>
        </name>
        <address>
          <email>guillaume.rizk@gmail.com</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2191 9284</institution-id><institution-id institution-id-type="GRID">grid.410368.8</institution-id><institution>INRIA/IRISA/GenScale, </institution><institution>Campus de Beaulieu, </institution></institution-wrap>Rennes, 35042 France </aff>
      <aff id="Aff2"><label>2</label>University of Bordeaux, CNRS/LaBRI, Talence, F-33405 France </aff>
      <aff id="Aff3"><label>3</label>University of Bordeaux, CBiB, Bordeaux, F-33000 France </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>14</day>
      <month>9</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2015</year>
    </pub-date>
    <volume>16</volume>
    <elocation-id>288</elocation-id>
    <history>
      <date date-type="received">
        <day>16</day>
        <month>4</month>
        <year>2015</year>
      </date>
      <date date-type="accepted">
        <day>17</day>
        <month>8</month>
        <year>2015</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© Benoit et al. 2015</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p>Data volumes generated by next-generation sequencing (NGS) technologies is now a major concern for both data storage and transmission. This triggered the need for more efficient methods than general purpose compression tools, such as the widely used gzip method.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We present a novel reference-free method meant to compress data issued from high throughput sequencing technologies. Our approach, implemented in the software <sc>Leon</sc>, employs techniques derived from existing assembly principles. The method is based on a reference probabilistic <italic>de Bruijn Graph</italic>, built <italic>de novo</italic> from the set of reads and stored in a Bloom filter. Each read is encoded as a path in this graph, by memorizing an anchoring kmer and a list of bifurcations. The same probabilistic <italic>de Bruijn Graph</italic> is used to perform a lossy transformation of the quality scores, which allows to obtain higher compression rates without losing pertinent information for downstream analyses.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p><sc>Leon</sc> was run on various real sequencing datasets (whole genome, exome, RNA-seq or metagenomics). In all cases, LEON showed higher overall compression ratios than state-of-the-art compression software. On a <italic>C. elegans</italic> whole genome sequencing dataset, LEON divided the original file size by more than 20.</p>
        <p><sc>Leon</sc> is an open source software, distributed under GNU affero GPL License, available for download at <ext-link ext-link-type="uri" xlink:href="http://gatb.inria.fr/software/leon/">http://gatb.inria.fr/software/leon/</ext-link>.</p>
      </sec>
      <sec>
        <title>Electronic supplementary material</title>
        <p>The online version of this article (doi:10.1186/s12859-015-0709-7) contains supplementary material, which is available to authorized users.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Compression</kwd>
      <kwd>
        <italic>de Bruijn Graph</italic>
      </kwd>
      <kwd>NGS</kwd>
      <kwd>Bloom filter</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2015</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>It is well known that data volumes produced by next-generation sequencing are a major issue. The size of the Sequence Read Archive, hosting a major part of the sequence data generated world wide, is growing very fast and now contains 3.5 petabases (<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/Traces/sra/">http://www.ncbi.nlm.nih.gov/Traces/sra/</ext-link>) of DNA and RNA [<xref ref-type="bibr" rid="CR1">1</xref>]. This is an issue for both data storage and transmission, hampering collaboration between teams and long-term storage of data needed for the reproducibility of published results. Raw reads are stored in ASCII-based text files, in FASTA or FASTQ formats, containing for each read entry a read ID, a string for the sequence itself and, for the FASTQ files, a string of quality scores encoding a per base estimation of accuracy. Such files are usually compressed with the general purpose compression tool GZIP (<ext-link ext-link-type="uri" xlink:href="http://www.gzip.org">www.gzip.org</ext-link>, Jean-Loup Gailly and Mark Adler), which is fast and largely accepted but does not exploit specificities of sequencing data</p>
    <p>Compression of sequencing data can be divided into three distinct problems: compression of read IDs, of base sequence and of quality scores. For the compression of read IDs, standard methods are perfectly suited, since read IDs are usually highly similar from one read to another. Compression of DNA sequences and quality scores on the other hand, are two very different problems. The former displays high redundancy across reads when depth of sequencing is high, but spread over the whole file, and must be lossless, whereas the latter displays a highly noisy signal on a larger alphabet size, and lossy compression may be appropriate. Here we present a software for the compression of FASTA and FASTQ files, including read IDs, DNA sequences and quality scores.</p>
    <p><italic>Sequence compression</italic> techniques fall into two categories: reference-based methods, such as QUIP, CRAM, PATHENC and FASTQZ, exploit similarities between reads and a reference genome [<xref ref-type="bibr" rid="CR2">2</xref>–<xref ref-type="bibr" rid="CR5">5</xref>], whereas <italic>de novo</italic> compression schemes in FQZCOMP, SCALCE, FASTQZ, DSRC, ORCOM, BEETL, MINCE exploit similarities between reads themselves [<xref ref-type="bibr" rid="CR5">5</xref>–<xref ref-type="bibr" rid="CR10">10</xref>]. Reference based methods usually map reads to the genome and then only store information needed to rebuild reads: genome position and differences. While efficient, such methods require a time-consuming mapping phase to the genome, and are not applicable when no close reference is known. Moreover, the reference genome is also needed for de-compressing the data, which could lead to data loss if the reference has been lost or modified.Most <italic>de novo</italic> methods either (i) use a context-model to predict bases according to their context, followed by an arithmetic encoder (FASTQZ, FQZCOMP, DSRC), or (ii) re-order reads to maximize similarities between consecutive reads and therefore boost compression of generic compression methods (SCALCE, ORCOM, MINCE).</p>
    <p>FASTQZ and FQZCOMP are improvements of generic text-compression methods. For simple genomes, the context model is able to learn the underlying genome and produces good results. DSRC uses similar techniques, but is additionally tailored for high-speed compression and decompression. PATHENC also uses a context model followed by arithmetic coding, with two refinements [<xref ref-type="bibr" rid="CR4">4</xref>]. First, the context-model is initialized with a reference genome. Secondly, the starts of the reads are encoded separately, as a set of kmers compactly encoded with a bit tree, which also requires to reorder reads. While they conceptually make a connection with paths in a graph, their method does not use a de Bruijn graph.</p>
    <p>As far as we know, tools that achieve the best sequence compression ratios are currently read re-ordering methods.BEETL and BEETL-FASTQ use the Burrows-Wheeler transform of the read set to achieve compression [<xref ref-type="bibr" rid="CR9">9</xref>, <xref ref-type="bibr" rid="CR11">11</xref>]. However, the method seems to be more suitable as a searchable compressed archive than a full compression/decompression tool of fastq files (see BEETL-FASTQ Readme). ORCOM uses minimizers, an increasingly used method in various NGS algorithms, to quickly re-order the read set into bins of reads of high similarity [<xref ref-type="bibr" rid="CR8">8</xref>]. This is a very efficient method regarding sequence compression ratio and execution speed. Their method is currently limited to sequence compression, header and quality streams are discarded. MINCE exploits the same paradigm, it also re-order reads into buckets of similar reads based on minimizers. Reads are then transformed to avoid redundant coding of the minimizer among a bucket, and compressed by a general-purpose compressor. Header and quality streams are discarded. However, when reordering reads, one should pay special attention to keeping read pairing information. Indeed losing such information would make it impossible to use down-stream NGS analysis requiring paired-reads. In this sense, methods that reorder reads without dealing with the pairing information cannot be considered as lossless, and cannot be directly compared to other methods. MINCE addresses this issue by concatenating paired reads together before compression, and splitting them after decompression. SCALCE also has an option to handle paired-reads correctly, but activating this option significantly degrades the compression ratio.</p>
    <p>Lastly, QUIP (in its reference-free mode) uses a different approach, based on methods tailored for NGS analysis. Sequence assembly algorithms building a reference genome as a set of contigs are used, followed by a reference-based approach [<xref ref-type="bibr" rid="CR2">2</xref>]. This method is highly dependent on the quality of the generated contigs, and is out-performed in a recent compression competition [<xref ref-type="bibr" rid="CR5">5</xref>].</p>
    <p><italic>Quality score compression</italic> techniques are divided between <italic>lossless</italic> methods, where decompressed data is guaranteed to match the original values, and <italic>lossy</italic> approaches, trading loss in fidelity of reproduction for higher compression rates.</p>
    <p>It has been observed that quality values are generally correlated to their position in the read and to the nearby quality values. Many <italic>lossless</italic> methods exploit this through the use of context-models followed by arithmetic coding (DSRC, FASTQZ, FQZCOMP). Other <italic>lossless</italic> approaches transform quality scores to values that can be coded using fewer bits, <italic>i.e.</italic> gap translating, min shifting and frequency ordering [<xref ref-type="bibr" rid="CR12">12</xref>].</p>
    <p>Classic <italic>lossy</italic> approaches consist in reducing the range of possible values, making further compression easier. The general idea is to divide the initial spectrum of scores into a lower number of bins. FASTQZ and Wan et al. present variations on this scheme [<xref ref-type="bibr" rid="CR5">5</xref>, <xref ref-type="bibr" rid="CR12">12</xref>]. FQZCOMP and LIBCSAM methods smooth qualities within a block, ensuring that the difference from the original value is no more than a given threshold [<xref ref-type="bibr" rid="CR5">5</xref>, <xref ref-type="bibr" rid="CR13">13</xref>].</p>
    <p>Other <italic>lossy</italic> quality scores compression approaches use the information contained in the DNA sequence to make smart modifications of the quality scores by smoothing unimportant quality values, in order to reduce the entropy of the quality set. Janin et al. assume that if a given nucleotide can be completely predicted by its context, then its corresponding quality value becomes unimportant and can even be discarded [<xref ref-type="bibr" rid="CR14">14</xref>]. This is achieved through a time and memory-consuming Burrows-Wheeler transform (BWT) of the read set and a longest common prefix (LCP) array. The method RQS [<xref ref-type="bibr" rid="CR15">15</xref>] exploits a similar idea but, instead of computing the BWT, compute a dictionary of frequently occurring kmers and then identify kmers within small Hamming distance of frequent ones. Positions corresponding to differences from such frequent kmers are assumed to be SNPs or sequencing errors and their quality values are preserved, while the other quality scores are smoothed. Surprisingly, RQS improves SNP-calling accuracy on a gold-standard dataset. However, their method scales to large read sets only if the dictionary is constructed over a sample of the original data set, and the effect of such sampling is not clearly measured.</p>
    <p>In this paper, we introduce LEON, a novel <italic>de novo</italic> method for lossless sequence compression and lossy quality compression using methods derived from assembly principles. However, instead of building a reference as a set of sequences, the reference is represented as a probabilistic <italic>de Bruijn Graph</italic>. Read order is preserved and each read is represented by a kmer anchor and a list of bifurcation choices, enough to re-build it from the graph. The same data structure is used for quality compression. Nucleotides covered by a sufficient number of highly frequent kmers are assumed to be error-free and have their quality smoothed to an arbitrarily chosen value. The quality stream is then compressed with the zlib library.</p>
    <p>LEON was run on various real sequencing datasets to evaluate the impact on compression ratio of numerous dataset features, such as the size and complexity of the target genome, the sequencing depth, the sequencing technology. In all cases, LEON showed higher overall compression ratios than state-of-the-art compression software and was at least 2 times faster than the generic tool GZIP, with at least 5 times better compression ratios. For instance, on a <italic>C. elegans</italic> whole genome sequencing dataset,the original file size is divided by more than 20, and in a large human dataset case, the file size was reduced from 733 GB to 47 GB. Several types of sequenced samples (whole genome, exome, RNA-seq or metagenomics) were also tested, demonstrating the robustness of LEON. Finally, the effects of the lossy transformation of quality scores was evaluated on a SNP calling analysis and showed an improvement in the prediction accuracy.</p>
  </sec>
  <sec id="Sec2">
    <title>Methods</title>
    <sec id="Sec3">
      <title>Overview</title>
      <p>Although our compression approach does not rely on a reference genome, it bears some similarities with reference-based approaches. As we do not dispose of any external data, the first step of our approach is to build <italic>de novo</italic> a reference from the reads and then, similarly to reference-based approaches, to record each read as a position and a list of differences with respect to this reference. However, the major difference lies in the data structure hosting the reference: instead of a sequence or a set of sequences, a <italic>de Bruijn Graph</italic> is built, whose basic pieces of information are <italic>kmers</italic>, i.e. words of size <italic>k</italic>. This data structure, commonly used for <italic>de novo</italic> assembly of short reads, has the advantage of representing most of the DNA information contained in the reads while dumping the redundancy due to sequencing coverage.</p>
      <p>Since the <italic>de Bruijn Graph</italic> must be stored in the compressed file to reconstruct the reads, one important issue is its size. To tackle this issue, our method relies first on a good parameterization of the <italic>de Bruijn Graph</italic> and secondly on its implementation as a <italic>probabilistic</italic> data structure. The parameters are set so that the structure stores most of the important information, that is the most redundant one, while discarding the small differences, such as sequencing errors. Our implementation of the <italic>de Bruijn Graph</italic> is based on bloom filters [<xref ref-type="bibr" rid="CR16">16</xref>]. Although not exact, this is very efficient to store such large data structures in the main memory and then in the compressed files.</p>
      <p>Figure <xref rid="Fig1" ref-type="fig">1</xref> shows an overview of the method implemented in the LEON software. First, kmers are counted and only those abundant enough are inserted into a bloom filter representing the <italic>de Bruijn Graph</italic>. Each read is encoded by first finding its best anchoring kmer, then a walk through the graph starting from this anchor node is performed to construct the list of bifurcations followed when mapping the read to the graph. Finally, the compressed file contains the <italic>de Bruijn Graph</italic> and, for each read, its anchoring kmer and a list of bifurcations encoded with an order 0 arithmetic encoder.
<fig id="Fig1"><label>Fig. 1</label><caption><p>LEON method overview. First, a <italic>de Bruijn Graph</italic> is constructed from the reads: kmers are counted, then abundant enough kmers are inserted into a bloom filter representing a probabilistic <italic>de Bruijn Graph</italic>. Reads are then mapped to this graph, and the necessary information required to rebuild the reads from the graph is stored in the compressed file: an anchoring kmer and a list of bifurcations</p></caption><graphic xlink:href="12859_2015_709_Fig1_HTML" id="MO1"/></fig>
</p>
    </sec>
    <sec id="Sec4">
      <title>Building the reference as a <italic>de Bruijn Graph</italic></title>
      <p>A <italic>de Bruijn Graph</italic> is a directed graph where each node is a word of length <italic>k</italic>, called a kmer. An edge is present from node <italic>a</italic> to node <italic>b</italic> if the <italic>k</italic>−1 suffix of node <italic>a</italic> is exactly the <italic>k</italic>−1 prefix of node <italic>b</italic>. A <italic>de Bruijn Graph</italic> can be built from a set of reads by cutting each read in overlapping kmers. Each read of size <italic>l</italic> is then a path of <italic>l</italic>−<italic>k</italic>+1 nodes in the graph. In this case, the <italic>de Bruijn Graph</italic> contains as many nodes as there are distinct kmers in the read dataset.</p>
      <p>Sequencing errors can generate numerous novel distinct kmers that are present in only one or very few reads. This increases drastically the number of nodes in the graph. To avoid this, only kmers that are sufficiently covered in the dataset are represented in the graph, that is kmers having more than <italic>T</italic>
<sub><italic>sol</italic></sub> (solidity threshold) occurrences in the read dataset, hereafter called <italic>solid</italic> kmers.</p>
      <p>The number of nodes, the number of edge per node, and the graph topology, have a strong impact on the size of the data structure. A given node is said to be branching if it has more than one in-going edges or more than one out-going edges. A simple path is then a path of nodes without any branching node. In order to efficiently store most of the reads, the graph should contain long simple paths such that the majority of reads will follow a simple path (without needing to store any bifurcation or difference). This is governed by two parameters, <italic>k</italic> and <italic>T</italic>
<sub><italic>sol</italic></sub>.</p>
      <p>Although both parameters are tunable by the user, the default mode of LEON does not require any user choice. The default <italic>k</italic> value is 31 and the optimal <italic>T</italic>
<sub><italic>sol</italic></sub> value is inferred automatically from the analysis of the kmer counts profile, with a method similar to the one used in KMERGENIE [<xref ref-type="bibr" rid="CR17">17</xref>], and also briefly discussed in the Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Section 2.</p>
    </sec>
    <sec id="Sec5">
      <title>Probabilistic <italic>de Bruijn Graph</italic></title>
      <p>A traditional implementation of a <italic>de Bruijn Graph</italic> requires a lot of memory. For example, hash table implementation similar to the one by Iqbal et al. [<xref ref-type="bibr" rid="CR18">18</xref>],that stores for each node, a kmer and a byte containing the edges, requires at least <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}
$ 8 \lceil \frac {k}{32}\rceil + 1 $
\end{document}</tex-math><mml:math id="M2"><mml:mn>8</mml:mn><mml:mo>⌈</mml:mo><mml:mfrac><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:mfrac><mml:mo>⌉</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:math><inline-graphic xlink:href="12859_2015_709_IEq1.gif"/></alternatives></inline-formula> bytes per node. This means approximately 27 GB for a human sized genome, which is largely prohibitive for compression purposes. Therefore a more lightweight implementation is required.</p>
      <p>The notion of probabilistic <italic>de Bruijn Graph</italic> was first introduced by T.Brown et al. [<xref ref-type="bibr" rid="CR19">19</xref>], and refers to a <italic>de Bruijn Graph</italic> represented as a Bloom filter. It was shown that the graph nodes can be encoded with as little as 4 bits per node, with the drawback of introducing false nodes and false branchings. Chikhi and Rizk [<xref ref-type="bibr" rid="CR20">20</xref>] then also used a bloom filter to store the <italic>de Bruijn Graph</italic>. An additional structure storing critical false positives, rendered the <italic>de Bruijn Graph</italic> representation exact at a total cost of approximately 13 bits per node, then improved to 8 bits per node with cascading bloom filters [<xref ref-type="bibr" rid="CR21">21</xref>].</p>
      <p>The <bold>Bloom filter</bold> [<xref ref-type="bibr" rid="CR16">16</xref>] is a space efficient hash-based data structure, designed to test whether an element is in a set. It is made up of a bit array initialized with zeros, and a set of hash functions. When inserting or querying for an element, its hash values are computed yielding a set of array positions. The insert operation corresponds to setting to 1 all these positions, whereas membership operation returns <italic>yes</italic> if and only if all the bits at these positions are set to 1. A <italic>no</italic> answer means the element is definitely not in the set. A <italic>yes</italic> answer indicates that the element may or may not be in the set. Hence, the Bloom filter has one-sided errors. The probability of false positives increases with the number of elements inserted in the Bloom filter.</p>
      <p>Inserting the graph nodes in the bloom filter is sufficient to represent the <italic>de Bruijn Graph</italic>. Graph edges can be inferred by querying for the existence of all 4 possible successors of a given node.</p>
      <p>For LEON’s compression purposes the main issue is the total graph size, while the exact representation of the graph is not a major issue: it only implies that additional bifurcation events may need to be stored for some reads. Therefore, a probabilistic <italic>de Bruijn Graph</italic> is chosen, since it provides both memory-efficient representation and reasonably fast construction of the graph: the list of solid kmers are simply inserted into a bloom filter.</p>
      <p>There is a trade-off between the size of the bloom filter and its impact on the storage size of each read: a small bloom filter will take less space in the compressed file but will induce more storage space for each read. Since the bloom filter size is amortized across all reads, the optimal bloom filter size depends on the depth of sequencing (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Section 5).</p>
    </sec>
    <sec id="Sec6">
      <title>Encoding the read sequences</title>
      <p>The reference stored in the <italic>de Bruijn Graph</italic> does not contain all the necessary information to retrieve a given read. The idea is to store the minimum information required to reconstruct a read from the graph when decompressing. The data needed is an <italic>anchor</italic> kmer to indicate where to begin the reconstruction in the graph, a list of <italic>bifurcations</italic> to tell which path to follow, and the read size to know when to stop read reconstruction.</p>
      <sec id="Sec7">
        <title>Dictionary of anchors</title>
        <p>An <italic>anchor</italic> kmer is required to reconstruct a read from the graph. It is equivalent of read position in a reference genome for reference-based compression methods.</p>
        <p>This is an important issue. A naive solution storing the raw kmer for each read would require to store, for example, <italic>k</italic> out of the total <italic>l</italic> nucleotides of a read, representing <italic>k</italic>/<italic>l</italic>=30/100 in a typical situation. This would severely limit the overall compression ratio.</p>
        <p>LEON tackles this problem by reusing several times the same anchor kmer for different reads. Common anchor kmers are stored in a dictionary of kmers saved in the compressed file. Thus, an index in this dictionary is sufficient to encode a kmer anchor, requiring much less space than a kmer.</p>
        <p>The selection procedure for the anchor kmer is as follows: each kmer of a read is considered as a putative anchor and queried in the dictionary of anchors. When one is found, the procedure stops and the anchor kmer is encoded as its index in the dictionary. If none is found, one <italic>suitable</italic> anchor kmer is selected in the read, then inserted in the dictionary. A <italic>suitable</italic> kmer is a solid kmer, i.e. a kmer that is also guaranteed by design to be a graph node. When no <italic>suitable</italic> kmers are found, the read cannot be mapped to the graph, it is encoded as a read without anchor.</p>
      </sec>
      <sec id="Sec8">
        <title>Bifurcation list</title>
        <p>The bifurcation list tells how the read is mapped to the graph, i.e. which path it follows whenever a bifurcation occurs. Since the anchoring kmer can be in the middle of the read, two bifurcation lists are needed, along with the sizes of the two paths. In practice, only read length and anchor position are encoded, from which the two paths sizes can be inferred. In the following, only the path at the right of the anchor is described, the other being symmetrical.</p>
        <p>Starting from the anchor, the four possible kmer successors are queried in the <italic>de Bruijn Graph</italic>, and compared to the following kmer in the read. If only one successor exists and is the same as the kmer in the read, this is a simple path, nothing needs to be encoded. On the contrary, whenever an ambiguity occurs, such as several neighbors in the graph, the real nucleotide is added to the bifurcation list. It should be noted that, in general, the bifurcation position in the read is not required, since it is contained in the graph. However, in the special case of a simple path that is different from the read, both nucleotide and read position needs to be added. This is the case for instance for a sequencing error in the read. In this case, when decompressing, the error position cannot be inferred from the graph. The detailed construction mechanism is explained in Algorithm 1, and an encoding example is shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>.<fig id="Fig2"><label>Fig. 2</label><caption><p>Schematic description of LEON’s path encoding. In the upper part, the mapping of two reads to the <italic>de Bruijn Graph</italic> is represented. Kmer anchors are shown in blue, bifurcations to (read on the left side) or difference from the graph (read on the right side) are respectively highlighted in green and red. In the bottom part, the corresponding path encodings for these two reads are shown: the index of the kmer anchor, and for each side the path length and bifurcation list</p></caption><graphic xlink:href="12859_2015_709_Fig2_HTML" id="MO3"/></fig>
</p>
        <p>
          <graphic xlink:href="12859_2015_709_Figa_HTML.gif" id="MO2"/>
        </p>
      </sec>
      <sec id="Sec9">
        <title>Reads without anchor</title>
        <p>Reads that cannot be mapped to the graph are simply encoded in the file with their raw sequence of nucleotides. This only happens if no kmer of the read is solid, i.e. if there is at least one sequencing error every <italic>k</italic> nucleotides or if the read is from a low covered region. Therefore, this is a rare event, it does not impact significantly the compression ratio (verified experimentally, see Fig. <xref rid="Fig3" ref-type="fig">3</xref>).
<fig id="Fig3"><label>Fig. 3</label><caption><p>Components contribution in sequence compression. Sequence compression ratio (top) and relative contribution of each component in the compressed sequence stream (bottom) for diverse datasets. WGS high means high coverage (116, 70 and 102 x respectively), WGS low means down-sampling to 10x</p></caption><graphic xlink:href="12859_2015_709_Fig3_HTML" id="MO4"/></fig>
</p>
      </sec>
      <sec id="Sec10">
        <title>Arithmetic coding</title>
        <p>All elements inserted in the compressed file (except for the bloom filter) are encoded with order 0 arithmetic coding [<xref ref-type="bibr" rid="CR22">22</xref>]. LEON uses an individual model for each component (read size, anchor position, bifurcation list, raw nucleotides for un-anchored reads, dictionary of anchors), registering symbol frequencies and assigning fewer bits to frequent symbols.</p>
      </sec>
      <sec id="Sec11">
        <title>Decompression</title>
        <p>The main difference between the decompression and the compression processes is the reference building step that is not required during decompression. The decompression process starts by loading in memory the <italic>de Bruijn Graph</italic> and the anchor dictionary. For each read, the anchor kmer is obtained by a simple access to the dictionary of anchors. The anchor position and the read size are then decoded to know how many nodes of the <italic>de Bruijn Graph</italic> need to be explored in each direction (left and right paths). The process to recover the read sequence in each direction starting from its anchor is similar to the one described in algorithm 1. We first check in the bifurcation list if we are at a position where the nucleotide is different from any path in the <italic>de Bruijn Graph</italic> (typically the case of a sequencing error). In this case, we add to the read the next nucleotide of the bifurcation list. In other cases, the successive nucleotides are obtained from the walk in the <italic>de Bruijn Graph</italic> and whenever a bifurcation is encountered, the path to choose is given by decoding the next nucleotide of the bifurcation list.</p>
      </sec>
    </sec>
    <sec id="Sec12">
      <title>Quality compression</title>
      <p>It has been observed that <italic>lossless</italic> quality compression methods are reaching a <italic>wall</italic>, <italic>i.e.</italic> a maximum compression rate that cannot be exceeded [<xref ref-type="bibr" rid="CR5">5</xref>]. This comes from the nature of the quality stream, meaning that it is too noisy to be efficiently compressed on a lossless basis. Moreover, the usefullness of such a large panel of quality scores is not self-evident. Most downstream NGS analysis will ignore the fact that a nucleotide has a probability of error of 5.0∗10<sup>−4</sup> rather than 3.9∗10<sup>−4</sup>.</p>
      <p>For these reasons, a <italic>lossy</italic> compression scheme was chosen for LEON. Similar to work by Janin et al. and Yu et al. [<xref ref-type="bibr" rid="CR14">14</xref>, <xref ref-type="bibr" rid="CR15">15</xref>], we use the evidence contained in the reads to smooth the quality scores. For this, we capitalize on the information already computed during the DNA sequences compression step, <italic>i.e.</italic> the set of <italic>solid</italic> kmers stored in the Bloom filter. Based on the assumption that nucleotides being covered by a sufficient number (<italic>σ</italic>) of solid kmers can safely be considered as error-free, they are being assigned an arbitrarily high quality value (‘@’). However, upgrading low quality scores to higher values is more risky for downstream NGS analysis than replacing already high scores, as this may incur, for instance, false positives SNP-calls. To alleviate this risk, we require a higher number <italic>σ</italic> of solid kmers in order to trigger quality replacement for these low quality values.</p>
      <p>In details, the procedure is as follows. (1) We first truncate all quality scores above a given threshold (qualities higher than ‘@’ are replaced by ‘@’). (2) All positions that are covered by at least <italic>σ</italic> solid kmers have their quality score replaced by ‘@’. (3) The quality stream is compressed with the zlib library. The <italic>σ</italic> parameter is computed as follows: with <italic>δ</italic>=<italic>`</italic>
<italic>@</italic>
<sup>′</sup>−original quality, we set <italic>σ</italic>=2 if <italic>δ</italic>≤10, and <italic>σ</italic>=<italic>δ</italic>−5 otherwise.</p>
      <p>This approach is obviously <italic>lossy</italic> since it changes the original qualities. However, modifying the quality values based on the information extracted from the reads, means that some quality scores are actually <italic>corrected</italic>. This can be viewed as an amelioration instead of a loss, and should explain the improvements of downstrean NGS analysis already discussed in RQS results [<xref ref-type="bibr" rid="CR15">15</xref>]. In this context, we explore the effect of our quality smoothing procedure on SNP-calling in Table <xref rid="Tab2" ref-type="table">2</xref>.
</p>
    </sec>
    <sec id="Sec13">
      <title>Implementation</title>
      <sec id="Sec14">
        <title>GATB library</title>
        <p>The GATB library (<ext-link ext-link-type="uri" xlink:href="http://gatb.inria.fr/">http://gatb.inria.fr/</ext-link>) was used to implement LEON [<xref ref-type="bibr" rid="CR23">23</xref>]. This library provides an API for building and navigating a <italic>de Bruijn Graph</italic> and its implementation, based on the Bloom filter and the constant-memory kmer counting algorithm introduced by Rizk and Chikhi [<xref ref-type="bibr" rid="CR24">24</xref>], and later improved by new methods introduced by Deorowicz et al. [<xref ref-type="bibr" rid="CR25">25</xref>], i.e. minimizer-based kmer partitioning and (<italic>k</italic>,<italic>x</italic>)-mers counting.LEON is able to compress Fasta or Fastq files, and has the option to compress quality scores in lossless or lossy mode.</p>
      </sec>
      <sec id="Sec15">
        <title>Header compression</title>
        <p>To compress the sequence headers, a classic compression approach was used. A typical header string can be viewed as several fields of information separated by special characters (any character which is neither a digitn nor alphabetic). Most of these fields are identical for all reads (for instance, the dataset name or the size of the reads). The idea is to store fixed fields only once and efficiently encode variable fields. A short representation of a header can be obtained using its previous header as reference. Each field of the header and its reference are compared one by one. Nothing needs to be kept when fields match. When differences occur, either the numerical difference or the size of the longest common prefix are used to shorten the representation. The resulting short representation is encoded using an order 0 arithmetic coding.</p>
      </sec>
      <sec id="Sec16">
        <title>Complexity</title>
        <p>If we omit the kmer counting step, LEON performs compression and decompression in one single pass over the reads. For a given read, selecting the anchor and building the bifurcation list requires a number of operations that is proportional to the number of kmers in the read. Both compression and decompression processes have running times proportional to the read count multiplied by the average number of kmers per read, that is a time complexity linear with the size of the dataset.</p>
        <p>It is important to note that decompression is faster than compression. The time consuming kmer counting step is not performed during decompression since the <italic>de Bruijn Graph</italic> is stored in the compressed file.</p>
        <p>Two main structures are maintained in main memory during compression and decompression. The bloom filter can use up to <italic>G</italic>∗<italic>b</italic> bits for storing solid kmers where <italic>G</italic> is the size of the target genome and <italic>b</italic> is the number of bits per solid kmers (typically <italic>b</italic> is set to 12). During anchor selection, the minimum requirement is to choose a solid kmer as anchor. It means that like the bloom filter, the maximum number of anchors that can be inserted in the dictionary is <italic>G</italic>, the size of the genome. The important thing to notice is that the amount of memory needed by LEON is not related to the size of the input file but proportional to the size of the target genome.</p>
      </sec>
      <sec id="Sec17">
        <title>Parallelization</title>
        <p>To allow our method to fully benefit from multi-threading, reads of the input file are split in blocks of <italic>n</italic> reads. Each block is then processed independently of the others by a given thread.</p>
        <p>Parallelization speed-up is shown in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S3.</p>
      </sec>
    </sec>
    <sec id="Sec18">
      <title>Datasets and tools</title>
      <sec id="Sec19">
        <title>NGS datasets</title>
        <p>LEON’s performance was evaluated on several publicly available read datasets. Main tests and comparisons were performed on whole genome sequencing (WGS) Illumina datasets with high coverage (more than 70x), from three organisms showing a large range of genome sizes and complexities: a bacteria <italic>E. coli</italic> (G=5 Mbp), a nematode <italic>C. elegans</italic> (G=100 Mbp) and a human individual (G=3 Gbp). The largest file tested is the WGS human one with 102x coverage resulting in an uncompressed fastq file size of 733 GB. To evaluate the impact of sequencing depth, these datasets were then randomly down-sampled. Additionally, other types of sequencing protocols and technologies were tested, such as RNA-seq, metagenomics, exome sequencing or Ion Torrent technology. Detailed features and accession numbers of each dataset are given in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table ST1.</p>
      </sec>
      <sec id="Sec20">
        <title>Other tools and evaluation criteria</title>
        <p>Several compression software were run on these datasets to compare with LEON, from best state-of-the-art tools to the general purpose compressor GZIP (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table ST2). Tools that are able to compress the whole fastq files and that allow to properly handle paired reads were preferentially chosen. SCALCE and MINCE that re-order reads were run with their option to keep paired reads together. Additionally, being the best read-reordering tool, Orcom was kept for reference. However, it cannot be directly compared to other tools as it loses the read pairing information. Manually concatenating paired reads before compression is possible for ORCOM, however this leads to poor compression ratio. Hence we decided to show ORCOM results only in the mode that lose paired read information.</p>
        <p>LEON and concurrent tools were compared on the following main criteria: (i) compression ratio, expressed as the original file size divided by the compressed file size, (ii) compression time, (iii) de-compression time and (iv) main memory used during compression.Since the main compared feature is compression ratio, concurrent tools were tuned for maximum compression when possible. LEON was always used with default parameters. Moreover, since LEON’s default mode for quality score compression is lossy, other tools were also run in a lossy configuration for quality scores (see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Section 4.1 for additional details and used command lines).</p>
        <p>All tools were run on a machine equipped with a 2.50 GHz Intel E5-2640 CPU with 12 cores, 192 GB of memory.All tools were set to use 8 threads.</p>
      </sec>
      <sec id="Sec21">
        <title>Lossy quality compression evaluation</title>
        <p>Lossy quality compression ratios cannot be compared without also taking into account the impact of the lossy transformation of the quality stream on downstream analysis, for instance SNP-calling accuracy. An experiment on a read dataset from the “1000 genomes project” (phase 1 release) was performed. More specifically, SNPs were called before and after several lossy quality transformations on a low coverage Illumina read sequences dataset, corresponding to the human chromosome 20 (HG00096 individual, SRR062634).</p>
        <p>Five reference-free, lossy quality compression tools were tested together with LEON, each of them being representative for a particular category of methods: FASTQZ that lowers the number of bins of the quality spectrum, LIBCSAM and FQZCOMP that smooth qualities within a block, and RQS as a tool that, similarly to LEON, uses information extracted from the DNA sequences. The SNP-calling results obtained for the original qualities were compared with those for the transformed qualities, and with those obtained for a naive quality transformation where all qualities are replaced by an arbitrarily chosen high score value, ’H’ (this corresponds to the extreme case where all qualities are discarded). Reads were mapped with BWA, then samtools mpileup followed by bcftools procedure was used to call SNPs and to generate the VCF files [<xref ref-type="bibr" rid="CR26">26</xref>, <xref ref-type="bibr" rid="CR27">27</xref>]. To assess the number of SNPs that were lost in each quality transformation process, as well as the ones that were potentially found in addition to those detected with the original qualities, each VCF file was compared to what we consider to be the reference SNP set, <italic>i.e.</italic> the VCF file that was produced by the “1000 genomes project” on the same sequencing data. The precision and recall measures were computed with respect to the VCF reference file, with the same procedure detailed by the authors of LIBCSAM [<xref ref-type="bibr" rid="CR13">13</xref>]. For RQS that only transforms qualities, and for LEON (that compresses the header and the sequence but only transforms the quality part), the quality streams were compressed with the general purpose compression tool GZIP.</p>
      </sec>
    </sec>
  </sec>
  <sec id="Sec22" sec-type="results">
    <title>Results</title>
    <sec id="Sec23">
      <title>Impact of the parameters and <italic>de Bruijn Graph</italic> false positives</title>
      <p>The compression ratio of LEON crucially depends on the quality of the reference that is built <italic>de novo</italic> from the reads, the probabilistic <italic>de Bruijn Graph</italic>.</p>
      <p>In order to evaluate the impact of using an approximate <italic>de Bruijn Graph</italic> compared to an exact representation, the compression ratio of LEON was computed for several sizes of bloom filters expressed as a number of bits per node. The larger the bloom filter, the fewer the false positives but the more space is needed to store it. Figure S4 in Additional file 1 shows that the optimal trade-off lies around 10 bits per solid kmer, for the 70x <italic>C. elegans</italic> dataset. It also demonstrates that correctness of <italic>de Bruijn Graph</italic> is not essential for compression purposes.</p>
      <p>The kmer size and the minimal abundance threshold (parameters <italic>k</italic> and <italic>T</italic>
<sub><italic>sol</italic></sub> respectively) also impact the compression ratio, as they control the number of nodes and the topology of the exact <italic>de Bruijn Graph</italic>. In fact LEON compression ratio proves to be robust to variations of these parameters around the optimal values (see the results on varying these parameters in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figures S1 and S2). Therefore, LEON can safely be used with its default parameters.</p>
    </sec>
    <sec id="Sec24">
      <title>DNA compression ratio with respect to dataset features</title>
      <p>Figure <xref rid="Fig4" ref-type="fig">4</xref> shows that the compression ratio increases with the sequencing depth. Obviously, the more redundant information is contained in the file, the more LEON can compress it. This is due to the fact that the space occupied by the Bloom filter does not depend on the sequencing depth and is rapidly negligible compared to the initial space occupied by the reads when coverage increases (see also Fig. <xref rid="Fig3" ref-type="fig">3</xref>). Notably, the compression factor depends also on the sequenced genome size and complexity, with better compression for the small and less complex bacterial genome. In this case the <italic>de Bruijn Graph</italic> contains more simple paths and bifurcation lists are smaller.
<fig id="Fig4"><label>Fig. 4</label><caption><p>Sequence compression ratios by coverage. Compression ratios obtained by LEON on the sequence stream, with respect to the sequencing coverage of the datasets. The three WGS datasets were down-sampled to obtain lower coverage</p></caption><graphic xlink:href="12859_2015_709_Fig4_HTML" id="MO5"/></fig>
</p>
      <p>Figure <xref rid="Fig3" ref-type="fig">3</xref> shows the relative contributions of each component of the DNA compressed stream for diverse datasets. For WGS datasets, this confirms that the relative contribution of the Bloom filter is low for high coverage datasets, but prohibitive for low coverage datasets (10x).</p>
      <p>For other types of datasets, the relative contributions vary greatly. For instance, the exome dataset is well compressed since the coverage is very high (more than 1000x) on a very small reference (exons representing around 1 % of the human genome). However, as the capture is noisy and some reads fall outside exons, an important part of the compressed file is taken by un-anchored reads.</p>
      <p>For the RNA-seq and metagenomic datasets, the bifurcation and un-anchored reads components represent the major part of the compressed DNA stream sizes. This is due to the heterogeneous sequence abundances in these kinds of datasets. In such cases, sequencing errors cannot be identified solely based on the kmer abundances and the solidity threshold is less effective in simplifying the graph. For instance in the case of RNA-seq, highly transcribed genes are likely to generate parts of the <italic>de Bruijn Graph</italic> with a high density of branchings, the majority of them corresponding to sequencing errors. Conversely, in the metagenomic dataset, numerous species have a low abundance in the sample and their genome is not represented in the <italic>de Bruijn Graph</italic>, resulting in a high number of un-anchored reads.</p>
      <p>Among the tested datasets, three correspond to the same target species (<italic>E. coli</italic>), sequenced with similar sequencing depths (∼115x) but with different sequencing technologies or protocols : Illumina HiSEq 2000, Illumina MiSeq and Ion-Torrent. In Fig. <xref rid="Fig3" ref-type="fig">3</xref>, one can observe that this factor impacts the DNA compression ratio and the relative contributions of each component. The Ion-Torrent dataset has the lowest compression ratio and this is mainly due to the bifurcation and sequencing errors components. This is explained by the sequencing errors that are mostly insertions and deletions, which are not well handled by the current bifurcation algorithm (an insertion or deletion implies the rest of the read will be encoded as errors), contrary to substitution errors. In the Illumina MiSeq protocol, reads are longer than in the classical HiSeq (250 vs 100 pb). Consequently, for the same amount of DNA, there are fewer reads and therefore fewer anchors to be encoded. This explains the great difference in the relative contribution of the anchor address component. Note that overall DNA compression ratio are roughly similar between both protocols, but this is due to a higher number of sequencing errors in this particular MiSeq dataset. Since the technologies are evolving to produce longer reads with fewer sequencing errors, this suggests that LEON compression ratio will easily fit the technology evolutions.</p>
      <p>Lastly, because of the anchor selection procedure, initial read order may theoretically impact compression ratio. However, test showed that LEON compression ratio only varies slightly when changing read order, generally below 1 % variation.</p>
    </sec>
    <sec id="Sec25">
      <title>Comparison with other tools</title>
      <p>For high coverage WGS datasets, LEON obtains the best compression ratio for the whole FASTQ file, i.e. sequence, header and quality streams combined, in comparison to other compression software (see Table <xref rid="Tab1" ref-type="table">1</xref>). In particular, with respect to the most used tool, GZIP, LEON compressed file can be up to 7 times smaller than the GZIP one for high coverage datasets. In the large human dataset case, we can save up to 686 GB (the file size drops from 733 GB to 47 GB).
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Compression features obtained for the three high coverage WGS datasets with several compression tools. Total compression ratio is the compression ratio (original size / compressed size) of the whole FASTQ file, header, sequence and quality combined</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Method</th><th align="left" colspan="4">Compression ratio</th><th align="left" colspan="2">Compression</th><th align="left" colspan="2">Decompression</th></tr><tr><th align="left"/><th align="left">Total</th><th align="left">Header</th><th align="left">Base</th><th align="left">Quality</th><th align="left">Time (s)</th><th align="left">Mem. (MB)</th><th align="left">Time (s)</th><th align="left">Mem. (MB)</th></tr></thead><tbody><tr><td align="left" colspan="9">SRR959239 - WGS <italic>E. coli</italic> - 1.4 GB - 116x</td></tr><tr><td align="left">gzip</td><td align="left">3.9</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">179</td><td align="left">1</td><td align="left">13</td><td align="left">1</td></tr><tr><td align="left">dsrc<italic>-lossy</italic>
</td><td align="left">7.6</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">9</td><td align="left">1942</td><td align="left">13</td><td align="left">1998</td></tr><tr><td align="left">fqzcomp<italic>-lossy</italic>
</td><td align="left">17.9</td><td align="left">35.2</td><td align="left">12.0</td><td align="left">19.6</td><td align="left">73</td><td align="left">4171</td><td align="left">74</td><td align="left">4160</td></tr><tr><td align="left">fastqz<italic>-lossy</italic>
</td><td align="left">13.4</td><td align="left">40.8</td><td align="left">14.1</td><td align="left">8.7</td><td align="left">255</td><td align="left">1375</td><td align="left">298</td><td align="left">1375</td></tr><tr><td align="left">leon<italic>-lossy</italic>
</td><td align="left"><bold>30.9</bold></td><td align="left">45.1</td><td align="left">17.5</td><td align="left">59.3</td><td align="left">39</td><td align="left">353</td><td align="left">33</td><td align="left">205</td></tr><tr><td align="left">scalce<italic>-lossy</italic>
</td><td align="left">9.8</td><td align="left">21.4</td><td align="left">8.3</td><td align="left">9.2</td><td align="left">62</td><td align="left">2012</td><td align="left">35</td><td align="left">2012</td></tr><tr><td align="left">quip</td><td align="left">8.4</td><td align="left">29.8</td><td align="left">8.5</td><td align="left">5.3</td><td align="left">244</td><td align="left">1008</td><td align="left">232</td><td align="left">823</td></tr><tr><td align="left">mince</td><td align="left">—</td><td align="left">—</td><td align="left">16.7</td><td align="left">—</td><td align="left">77<sup><italic>#</italic></sup>
</td><td align="left">1812</td><td align="left">19<sup><italic>#</italic></sup>
</td><td align="left">242</td></tr><tr><td align="left">orcom*</td><td align="left">—</td><td align="left">—</td><td align="left">34.3*</td><td align="left">—</td><td align="left">10<sup><italic>#</italic></sup>
</td><td align="left">2243</td><td align="left">15<sup><italic>#</italic></sup>
</td><td align="left">197</td></tr><tr><td align="left" colspan="9">SRR065390 - WGS <italic>C. elegans - 17 GB - 70x</italic>
</td></tr><tr><td align="left">gzip</td><td align="left">3.8</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">2145</td><td align="left">1</td><td align="left">165</td><td align="left"/></tr><tr><td align="left">dsrc<italic>-lossy</italic>
</td><td align="left">7.9</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">67</td><td align="left">5039</td><td align="left">85</td><td align="left">5749</td></tr><tr><td align="left">fqzcomp<italic>-lossy</italic>
</td><td align="left">12.8</td><td align="left">54.2</td><td align="left">7.6</td><td align="left">15.0</td><td align="left">952</td><td align="left">4169</td><td align="left">1048</td><td align="left">4159</td></tr><tr><td align="left">fastqz<italic>-lossy</italic>
</td><td align="left">10.3</td><td align="left">61.9</td><td align="left">7.3</td><td align="left">8.7</td><td align="left">2749</td><td align="left">1527</td><td align="left">3326</td><td align="left">1527</td></tr><tr><td align="left">leon<italic>-lossy</italic>
</td><td align="left"><bold>21.3</bold></td><td align="left">48.6</td><td align="left">12.0</td><td align="left">32.9</td><td align="left">627</td><td align="left">1832</td><td align="left">471</td><td align="left">419</td></tr><tr><td align="left">scalce<italic>-lossy</italic>
</td><td align="left">8.2</td><td align="left">34.1</td><td align="left">6.5</td><td align="left">7.2</td><td align="left">751.4</td><td align="left">5309</td><td align="left">182.3</td><td align="left">1104</td></tr><tr><td align="left">quip</td><td align="left">6.5</td><td align="left">54.3</td><td align="left">4.8</td><td align="left">5.2</td><td align="left">928</td><td align="left">775</td><td align="left">968</td><td align="left">771</td></tr><tr><td align="left">mince</td><td align="left">—</td><td align="left">—</td><td align="left">10.3</td><td align="left">—</td><td align="left">1907<sup><italic>#</italic></sup>
</td><td align="left">21825</td><td align="left">387<sup><italic>#</italic></sup>
</td><td align="left">242</td></tr><tr><td align="left">orcom*</td><td align="left">—</td><td align="left">—</td><td align="left">24.2*</td><td align="left">—</td><td align="left">113<sup><italic>#</italic></sup>
</td><td align="left">9408</td><td align="left">184<sup><italic>#</italic></sup>
</td><td align="left">1818</td></tr><tr><td align="left" colspan="9">SRR345593/SRR345594 - WGS human - 733 GB - 102x</td></tr><tr><td align="left">gzip</td><td align="left">3.3</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">104,457</td><td align="left">1</td><td align="left">9124</td><td align="left">1</td></tr><tr><td align="left">dsrc<italic>-lossy</italic>
</td><td align="left">7.4</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">2797</td><td align="left">5207</td><td align="left">3598</td><td align="left">5914</td></tr><tr><td align="left">fqzcomp<italic>-lossy</italic>
</td><td align="left">9.3</td><td align="left">23.2</td><td align="left">5.3</td><td align="left">15.0</td><td align="left">39,613</td><td align="left">4169</td><td align="left">48,889</td><td align="left">4158</td></tr><tr><td align="left">fastqz(a)</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td></tr><tr><td align="left">leon<italic>-lossy</italic>
</td><td align="left"><bold>15.6</bold></td><td align="left">27.5</td><td align="left">9.2</td><td align="left">26.8</td><td align="left">40,766</td><td align="left">9556</td><td align="left">21262</td><td align="left">5869</td></tr><tr><td align="left">scalce(b)</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td></tr><tr><td align="left">quip</td><td align="left">6.5</td><td align="left">54.3</td><td align="left">4.8</td><td align="left">5.2</td><td align="left">52,854</td><td align="left">776</td><td align="left">46594</td><td align="left">775</td></tr><tr><td align="left">mince(a)</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td><td align="left">—</td></tr><tr><td align="left">orcom*</td><td align="left">—</td><td align="left">—</td><td align="left">19.2*</td><td align="left">—</td><td align="left">29,364<sup><italic>#</italic></sup>
</td><td align="left">27505</td><td align="left">10,889<sup><italic>#</italic></sup>
</td><td align="left">60,555</td></tr></tbody></table><table-wrap-foot><p>The following columns indicate the ratio for each individual component, when available. Running time (in s) and peak memory (in MB) are given for compression and decompression. All tools were used without a reference genome. Best overall results are in bold</p><p><sup>a</sup>Program does not support variable length sequences</p><p><sup>b</sup>SCALCE was not able to finish on the large WGS human dataset</p><p><italic>-lossy</italic> suffix means the method was run in <italic>lossy</italic> mode for quality scores compression</p><p><sup>*</sup>Stars indicate that the given program changes read order and loses read-pairing information, and thus cannot be directly compared to other tools</p><p>Running time with <sup>#</sup> is on DNA sequence only</p><p>Best overall results are in bold</p></table-wrap-foot></table-wrap>
</p>
      <p>Interestingly, although QUIP is similar in approach to LEON, results in terms of sequence compression ratio are much lower than LEON. This can probably be explained by the large amount of reads that could not be mapped to the assembled contigs, either because they were incomplete or too fragmented. As expected, ORCOM, which allows read-reordering, achieves the highest sequence compression ratios. However, it looses important read pairing information and thus cannot be directly compared to <italic>lossless</italic> methods. Moreover, it only compresses the DNA sequence part and completely discards header and quality scores. MINCE and SCALCE that both re-order reads but keep read pairing information have a lower compression ratio than LEON on the DNA sequence. It seems than keeping read pairing information without degrading compression ratio is not a simple task for read-reordering methods.</p>
      <p>To be on par with LEON lossy quality scores compression, other tools were also run in a lossy compression mode when available (see command lines in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Table ST2). LEON achieves much higher compression of quality scores than other tools, 26.8 on the human dataset, compared to 15x for FASTQZCOMP.</p>
      <p>Additional comparisons on other types of datasets are shown in Fig. <xref rid="Fig5" ref-type="fig">5</xref>. LEON is better than other tools on all datasets, except on the metagenomic one where all tools perform roughly equally bad. In general, the sequence stream takes the most space in the whole compressed file for all tools. Interestingly, this is not the case for the Miseq and ion-torrent datasets. They suffer from higher sequencing error rates, which impact more the quality smoothing than the sequence compression.
<fig id="Fig5"><label>Fig. 5</label><caption><p>Compression ratios comparison. Comparison of compression ratios between <italic>de novo</italic> compression software for diverse datasets. On top, overall compression factor (orignal file size / compressed file size). The bottom part represents space distribution between header, sequence and quality scores (respectively in red, green and blue)</p></caption><graphic xlink:href="12859_2015_709_Fig5_HTML" id="MO6"/></fig>
</p>
      <p>Concerning running times, DSRC is by far the fastest method. It achieves compression ratios generally lower than other methods, but still up to two times better than GZIP. It is a good choice when running time is the major concern. Apart from DSRC, LEON compression time is about the same order of magnitude as other methods compressing the whole FASTQ file, and a bit faster for decompression.</p>
      <p>Regarding memory, contrary to other tools that use fixed memory resources, the memory used by LEON depends on the genome size, with less than 2 GB for a medium genome such as <italic>C. elegans</italic>. Importantly, it remains reasonable for a human genome with 9.5 GB, making LEON still usable on desktop computers.</p>
    </sec>
    <sec id="Sec26">
      <title>Impact of lossy compression of qualities</title>
      <p>The impacts of several lossy quality compression schemes were evaluated by measuring the SNP-calling accuracy. Results are summarized in Table <xref rid="Tab2" ref-type="table">2</xref> and Fig. <xref rid="Fig6" ref-type="fig">6</xref>.
<table-wrap id="Tab2"><label>Table 2</label><caption><p>SNP calling precision/recall test on data from human chromosome 20, compared to a gold standard coming from the “1000 genomes project”</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" colspan="4">HG00096 chrom 20</th></tr></thead><tbody><tr><td align="left">Prog</td><td align="left">Precision</td><td align="left">Recall</td><td align="left">Compression ratio</td></tr><tr><td align="left"><italic>lossless</italic></td><td align="left">85.02</td><td align="left">67.02</td><td align="left">2.95</td></tr><tr><td align="left">SCALCE</td><td align="left">85.15</td><td align="left">66.13</td><td align="left">4.1</td></tr><tr><td align="left">FASTQZ</td><td align="left">85.46</td><td align="left">66.63</td><td align="left">5.4</td></tr><tr><td align="left">LIBCSAM</td><td align="left">84.85</td><td align="left">67.09</td><td align="left">8.4</td></tr><tr><td align="left">FQZCOMP</td><td align="left">85.09</td><td align="left">66.61</td><td align="left">8.9</td></tr><tr><td align="left">LEON</td><td align="left"><bold>85.63</bold></td><td align="left"><bold>67.17</bold></td><td align="left">11.4</td></tr><tr><td align="left">RQS</td><td align="left">85.59</td><td align="left">67.15</td><td align="left">12.4</td></tr><tr><td align="left"><italic>no quality</italic></td><td align="left">57.73</td><td align="left">68.66</td><td align="left">-</td></tr></tbody></table><table-wrap-foot><p><italic>No quality</italic> means all qualities were discarded and replaced by ’H’. The ratio is given by the original quality size divided by the compressed size. For the <italic>lossless</italic> line, the best compression ratio obtained by lossless compression tools is given (obtained here with FQZCOMP). Results are ordered by increasing compression ratio</p><p>Best overall results are in bold</p></table-wrap-foot></table-wrap>
<fig id="Fig6"><label>Fig. 6</label><caption><p>Compression / accuracy trade-off for quality compression. Impact of <italic>lossy</italic> compression methods of quality scores on SNP calling, for a human chromosome 20 (HG00096 individual, SRR062634) compared to a gold standard. Each line represents the F-score/compressed size trade-off for a method, the higher the line, the better. The dashed line represents the F-score obtained by the original fastq file and by lossless compression methods</p></caption><graphic xlink:href="12859_2015_709_Fig6_HTML" id="MO7"/></fig>
</p>
      <p>In Table <xref rid="Tab2" ref-type="table">2</xref> we compared the compression ratios obtained by the five lossy quality compression tools with parameters producing precision and recall values close to those obtained for the reference lossless case. The <italic>lossless</italic> and the <italic>no quality</italic> results give precision/recall scores of extreme cases where, respectively, the original quality scores are kept or completely discarded. Moreover, the original qualities file compressed with FQZCOMP tool (the lossless compression tool that gives the best compression ratio on this data) gives a lower bound in terms of compression ratio. The parameters used for these tests, given in Table ST2 of Additional file <xref rid="MOESM1" ref-type="media">1</xref>, were chosen to yield a good compromise between precision/recall and compressed size.</p>
      <p>The results in Table <xref rid="Tab2" ref-type="table">2</xref> show that, unsurprisingly, naive smoothing (<italic>no quality</italic>) leads to high recall but very poor precision. Moreover, FASTQZ, FQZCOMP and LIBCSAM have both lower precision/recall scores and compression ratios than LEON and RQS.</p>
      <p>This confirms our initial hypothesis that smoothing qualities based on the information extracted from the reads is more effective than reducing the quality spectrum with generic transformations. Moreover, the precision/recall results of RQS and LEON corroborate the observation made in [<xref ref-type="bibr" rid="CR15">15</xref>, <xref ref-type="bibr" rid="CR28">28</xref>] regarding the ability of such tools to locally correct the data and thus to enhance the SNP-calling process.</p>
      <p>Whereas in Table <xref rid="Tab2" ref-type="table">2</xref> we choose, for each tool, one set of parameters giving a good compromise between precision/recall and compressed size, in Fig. <xref rid="Fig6" ref-type="fig">6</xref> we analyze a wide range of parameters affecting the trade-off between compression ratios and SNP-calling results (measured with the F-score). Figure <xref rid="Fig6" ref-type="fig">6</xref> shows the F-score as a function of the compressed size.</p>
      <p>For LEON and RQS the kmer solidity threshold (<italic>T</italic>
<sub><italic>sol</italic></sub>) was varied. For FQZCOMP, FASTQZ and LIBCSAM the parameter governing the amount of quality score modified was varied. As expected, for LEON and RQS the F-score increases when the compressed size increases, and is above that of the other tools and also above that of the original file (indicated with a dashed line). Even though coherent, LIBCSAM F-score results are clearly below those of LEON and RQS. On the other hand, FQZCOMP and especially FASTQZ exhibit strange behavior, as parameters that should yield smaller compressed files and lower F-scores sometimes achieve bigger compressed sizes and lower F-scores.</p>
    </sec>
  </sec>
  <sec id="Sec27" sec-type="discussion">
    <title>Discussion</title>
    <p>In this article, we introduced a new method for reference-free NGS data compression. Whereas the QUIP approach is building a <italic>de novo</italic> reference with traditional assembly methods, we use a <italic>de Bruijn Graph</italic> as a <italic>de novo</italic> reference. This allows skipping the computationally intensive and tricky assembly step, and also allows to map more reads on the graph than would be possible on a set of <italic>de novo</italic> built contigs. Our approach also yields better compression ratios than context model based methods such as FASTQZ or FQZCOMP, which, in a way, also learn the underlying genome from the context. This can be explained by the larger word size used by LEON. Thanks to the probabilistic <italic>de Bruijn Graph</italic>, our method is able to work with large kmers, whereas context models are limited to order-14 models due to memory constraints.</p>
    <p>The development of an API in the GATB library to read the LEON format on-the-fly without full decompression on disk is under development and will facilitate usage by other tools based on GATB (that could use it as a native input format). Moreover, the LEON compressed file contains more information than just the raw list of reads: the included <italic>de Bruijn Graph</italic> can be directly re-used by other software. For example, the TAKEABREAK and DISCOSNP software [<xref ref-type="bibr" rid="CR29">29</xref>, <xref ref-type="bibr" rid="CR30">30</xref>] detecting polymorphisms from the <italic>de Bruijn Graph</italic> will be able to take as input a LEON file and save significant time from the graph construction step. In this way, LEON can be seen as more than just a compression tool, as it also pre-processes data for further NGS analysis.</p>
    <p>Further developments to enhance LEON performance and functionalities are also considered. First, if reordering reads is acceptable for the user, grouping reads with the same anchor would allow to store the anchor once for many reads and save significant space. However, read-reordering strategy is acceptable in our opinion only if read pairing information is preserved, which is not the case of current read-reordering methods. With LEON method, since paired reads are close in the graph, it may be possible to encode paired reads together, by also encoding the path in-between reads. This would allow read reordering without losing read pairing information. Secondly, the detection of insertion and deletion errors could boost substantially the compression ratio of datasets issued from novel sequencing technologies (Ion Torrent or Pacific Bioscience). Moreover, our approach makes it possible to deal with multiple datasets efficiently. It would be straightforward to store the <italic>de Bruijn Graph</italic> only once for several datasets sequenced from the same organism for instance, and thus improving compression ratio.</p>
    <p>Lastly, our approach bears some similarities with error correction methods. When reads are anchored to the graph, some sequencing errors are clearly identified and saved in the file for the decompression. It could be combined with more powerful error detection algorithms to provide state-of-the art error correction, for example with the BLOOCOO<sup>1</sup> tool already implemented with the GATB library [<xref ref-type="bibr" rid="CR23">23</xref>]. It would then be straightforward to propose an option when decompressing the file, to choose between lossless sequence decompression mode, or with the sequencing errors corrected.</p>
  </sec>
  <sec id="Sec28" sec-type="conclusion">
    <title>Conclusions</title>
    <p>We introduced LEON, an all-in-one software for FASTQ file compression that handles DNA, header and quality scores. LEON uses the same data structure for both DNA and quality scores compression, a <italic>de Bruijn Graph</italic> compactly stored in a Bloom filter. The quality compression scheme is lossy, allowing for good overall compression ratios, without losing the essential quality information and thus not hampering downstream NGS analysis. LEON achieves higher compression ratios than other state-of the art tools and seems robust regarding diverse types of data.</p>
  </sec>
  <sec id="Sec29">
    <title>Endnote</title>
    <p>
      <sup>1</sup>
      <ext-link ext-link-type="uri" xlink:href="http://gatb.inria.fr/software/bloocoo/">http://gatb.inria.fr/software/bloocoo/</ext-link>
    </p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Additional file</title>
    <sec id="Sec30">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="12859_2015_709_MOESM1_ESM.pdf">
            <label>Additional file 1</label>
            <caption>
              <p><bold>Supplementary material.</bold> This supplementary file contains full details of datasets used and command line parameters of tools benchmarked, as well as additional test results concerning the impact of parameters <italic>k</italic> and <italic>T</italic>
<sub><italic>sol</italic></sub> on LEON. (PDF 116 kb)</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>NGS</term>
        <def>
          <p>next-generation sequencing</p>
        </def>
      </def-item>
      <def-item>
        <term>SNP</term>
        <def>
          <p>single-nucleotide polymorphism</p>
        </def>
      </def-item>
      <def-item>
        <term>BWT</term>
        <def>
          <p>Burrows-Wheeler transform</p>
        </def>
      </def-item>
      <def-item>
        <term>LCP</term>
        <def>
          <p>Longest common prefix</p>
        </def>
      </def-item>
      <def-item>
        <term>WGS</term>
        <def>
          <p>Whole-genome sequencing</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Availability of supporting data</bold>
      </p>
      <p>All datasets used for tools benchmarking are publicly available in the Sequence Read Archive (SRA) and were downloaded either from the NCBI or EBI web servers. Full list of SRA accession numbers is detailed in table ST1 in the Additional file <xref rid="MOESM1" ref-type="media">1</xref>.</p>
    </fn>
    <fn>
      <p>
        <bold>Competing interests</bold>
      </p>
      <p>The authors declare that they have no competing interests.</p>
    </fn>
    <fn>
      <p>
        <bold>Authors’ contributions</bold>
      </p>
      <p>GB, CL, DL, RU and GR participated in the design of the algorithm. GB and GR implemented the method. RU, TD and GR designed and implemented the quality score compression algorithm. ED, GR, GB and CL carried out the comparative benchmarks. All authors read and approved the final manuscript.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors are grateful to Thomas Derrien, Rayan Chikhi and Delphine Naquin for beta-testing. This work was supported by the ANR-12-EMMA-0019-01 GATB project and ANR-12-BS02-0008 Colib’read project. The GenOuest BioInformatics Platform provided the computing resources necessary for benchmarking.</p>
  </ack>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Leinonen</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Sugawara</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Shumway</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The sequence read archive</article-title>
        <source>Nucleic Acids Res</source>
        <year>2010</year>
        <volume>39</volume>
        <fpage>1019</fpage>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jones</surname>
            <given-names>DC</given-names>
          </name>
          <name>
            <surname>Ruzzo</surname>
            <given-names>WL</given-names>
          </name>
          <name>
            <surname>Peng</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Katze</surname>
            <given-names>MG</given-names>
          </name>
        </person-group>
        <article-title>Compression of next-generation sequencing reads aided by highly efficient de novo assembly</article-title>
        <source>Nucleic Acids Res</source>
        <year>2012</year>
        <volume>40</volume>
        <issue>22</issue>
        <fpage>171</fpage>
        <pub-id pub-id-type="doi">10.1093/nar/gks754</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Fritz</surname>
            <given-names>MHY</given-names>
          </name>
          <name>
            <surname>Leinonen</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Cochrane</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Efficient storage of high throughput sequencing data using reference-based compression</article-title>
        <source>Genome Res</source>
        <year>2011</year>
        <volume>21</volume>
        <fpage>734</fpage>
        <lpage>40</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.114819.110</pub-id>
        <pub-id pub-id-type="pmid">21245279</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kingsford</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Patro</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Reference-based compression of short-read sequences using path encoding</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <fpage>071</fpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv071</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bonfield</surname>
            <given-names>JK</given-names>
          </name>
          <name>
            <surname>Mahoney</surname>
            <given-names>MV</given-names>
          </name>
        </person-group>
        <article-title>Compression of fastq and sam format sequencing data</article-title>
        <source>PLoS One</source>
        <year>2013</year>
        <volume>8</volume>
        <issue>3</issue>
        <fpage>59190</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0059190</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hach</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Numanagic</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Alkan</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Sahinalp</surname>
            <given-names>SC</given-names>
          </name>
        </person-group>
        <article-title>Scalce: boosting sequence compression algorithms using locally consistent encoding</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>23</issue>
        <fpage>3051</fpage>
        <lpage>057</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts593</pub-id>
        <pub-id pub-id-type="pmid">23047557</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Grabowski</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Compression of dna sequence reads in fastq format</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>6</issue>
        <fpage>860</fpage>
        <lpage>2</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr014</pub-id>
        <pub-id pub-id-type="pmid">21252073</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Grabowski</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Roguski</surname>
            <given-names>Ł</given-names>
          </name>
        </person-group>
        <article-title>Disk-based compression of data from genome sequencing</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>31</volume>
        <fpage>844</fpage>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Janin</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Schulz-Trieglaff</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Cox</surname>
            <given-names>AJ</given-names>
          </name>
        </person-group>
        <article-title>Beetl-fastq: a searchable compressed archive for dna reads</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>387</fpage>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Patro</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Kingsford</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Data-dependent bucketing improves reference-free compression of sequencing reads</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <fpage>248</fpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv248</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cox</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Bauer</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Jakobi</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Large-scale compression of genomic sequence databases with the burrows–wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>11</issue>
        <fpage>1415</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts173</pub-id>
        <pub-id pub-id-type="pmid">22556365</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wan</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Anh</surname>
            <given-names>VN</given-names>
          </name>
          <name>
            <surname>Asai</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Transformations for the compression of fastq quality scores of next-generation sequencing data</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>5</issue>
        <fpage>628</fpage>
        <lpage>35</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr689</pub-id>
        <pub-id pub-id-type="pmid">22171329</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cánovas</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Moffat</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Turpin</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Lossy compression of quality scores in genomic data</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <issue>15</issue>
        <fpage>2130</fpage>
        <lpage>136</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu183</pub-id>
        <pub-id pub-id-type="pmid">24728856</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Janin</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Cox</surname>
            <given-names>AJ</given-names>
          </name>
        </person-group>
        <article-title>Adaptive reference-free compression of sequence quality scores</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>30</volume>
        <fpage>257</fpage>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <mixed-citation publication-type="other">Yu YW, Yorukoglu D, Berger B. Traversing the k-mer landscape of ngs read datasets for quality score sparsification. In: Research in computational molecular biology. Springer: 2014. p. 385–99.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <mixed-citation publication-type="other">Kirsch A, Mitzenmacher M. Less hashing, same performance: Building a better bloom filter. Algorithms-ESA 2006. 2006:456–67.</mixed-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Medvedev</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Informed and automated k-mer size selection for genome assembly</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>30</volume>
        <fpage>310</fpage>
        <pub-id pub-id-type="pmid">24085568</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Iqbal</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Caccamo</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Turner</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Flicek</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>McVean</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>De novo assembly and genotyping of variants using colored de bruijn graphs</article-title>
        <source>Nat Genet</source>
        <year>2012</year>
        <volume>44</volume>
        <issue>2</issue>
        <fpage>226</fpage>
        <lpage>32</lpage>
        <pub-id pub-id-type="doi">10.1038/ng.1028</pub-id>
        <pub-id pub-id-type="pmid">22231483</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pell</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Hintze</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Canino-Koning</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Howe</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Tiedje</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Brown</surname>
            <given-names>CT</given-names>
          </name>
        </person-group>
        <article-title>Scaling metagenome sequence assembly with probabilistic de bruijn graphs</article-title>
        <source>Proc Natl Acad Sci</source>
        <year>2012</year>
        <volume>109</volume>
        <issue>33</issue>
        <fpage>13272</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.1121464109</pub-id>
        <pub-id pub-id-type="pmid">22847406</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Rizk</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Space-efficient and exact de bruijn graph representation based on a bloom filter</article-title>
        <source>Algorithms Mol Biol</source>
        <year>2013</year>
        <volume>8</volume>
        <issue>1</issue>
        <fpage>22</fpage>
        <pub-id pub-id-type="doi">10.1186/1748-7188-8-22</pub-id>
        <pub-id pub-id-type="pmid">24040893</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salikhov</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Sacomoto</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Kucherov</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Using cascading bloom filters to improve the memory usage for de brujin graphs</article-title>
        <source>Algoritm Bioinforma</source>
        <year>2013</year>
        <volume>9</volume>
        <fpage>364</fpage>
        <lpage>76</lpage>
        <pub-id pub-id-type="doi">10.1007/978-3-642-40453-5_28</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Witten</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Neal</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Cleary</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Arithmetic coding for data compression</article-title>
        <source>Commun ACM</source>
        <year>1987</year>
        <volume>30</volume>
        <fpage>520</fpage>
        <lpage>540</lpage>
        <pub-id pub-id-type="doi">10.1145/214762.214771</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <mixed-citation publication-type="other">Drezen E, Rizk G, Chikhi R, Deltel C, Lemaitre C, Peterlongo P, et al. Gatb: Genome assembly and analysis tool box. Bioinformatics. 2014. doi:<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/btu406">10.1093/bioinformatics/btu406</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rizk</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Lavenier</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Dsk: k-mer counting with very low memory usage</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <issue>5</issue>
        <fpage>652</fpage>
        <lpage>3</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btt020</pub-id>
        <pub-id pub-id-type="pmid">23325618</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kokot</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Grabowski</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Debudaj-Grabysz</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Kmc 2: Fast and resource-frugal k-mer counting</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <fpage>022</fpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv022</pub-id>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Handsaker</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Wysoker</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Fennell</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Ruan</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Homer</surname>
            <given-names>N</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The sequence alignment/map format and samtools</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>16</issue>
        <fpage>2078</fpage>
        <lpage>079</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp352</pub-id>
        <pub-id pub-id-type="pmid">19505943</pub-id>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate short read alignment with burrows–wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>14</issue>
        <fpage>1754</fpage>
        <lpage>60</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yu</surname>
            <given-names>YW</given-names>
          </name>
          <name>
            <surname>Yorukoglu</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Peng</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Berger</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Quality score compression improves genotyping accuracy</article-title>
        <source>Nat Biotechnol</source>
        <year>2015</year>
        <volume>33</volume>
        <issue>3</issue>
        <fpage>240</fpage>
        <lpage>3</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.3170</pub-id>
        <pub-id pub-id-type="pmid">25748910</pub-id>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lemaitre</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Ciortuz</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Peterlongo</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Mapping-free and assembly-free discovery of inversion breakpoints from raw ngs reads</article-title>
        <source>Algoritm Comput Biol</source>
        <year>2014</year>
        <volume>8542</volume>
        <fpage>119</fpage>
        <lpage>30</lpage>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Uricaru</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Rizk</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Lacroix</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Quillery</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Plantard</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Reference-free detection of isolated snps</article-title>
        <source>Nucleic Acids Res</source>
        <year>2015</year>
        <volume>43</volume>
        <issue>2</issue>
        <fpage>11</fpage>
        <pub-id pub-id-type="doi">10.1093/nar/gku1187</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
