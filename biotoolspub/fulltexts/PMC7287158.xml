<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName archivearticle.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Front Neurosci</journal-id>
    <journal-id journal-id-type="iso-abbrev">Front Neurosci</journal-id>
    <journal-id journal-id-type="publisher-id">Front. Neurosci.</journal-id>
    <journal-title-group>
      <journal-title>Frontiers in Neuroscience</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1662-4548</issn>
    <issn pub-type="epub">1662-453X</issn>
    <publisher>
      <publisher-name>Frontiers Media S.A.</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7287158</article-id>
    <article-id pub-id-type="doi">10.3389/fnins.2020.00289</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Neuroscience</subject>
        <subj-group>
          <subject>Methods</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>MVPA-Light: A Classification and Regression Toolbox for Multi-Dimensional Data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Treder</surname>
          <given-names>Matthias S.</given-names>
        </name>
        <xref ref-type="corresp" rid="c001">
          <sup>*</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/133031/overview"/>
      </contrib>
    </contrib-group>
    <aff><institution>School of Computer Science &amp; Informatics, Cardiff University</institution>, <addr-line>Cardiff</addr-line>, <country>United Kingdom</country></aff>
    <author-notes>
      <fn fn-type="edited-by">
        <p>Edited by: Hamid R. Rabiee, Sharif University of Technology, Iran</p>
      </fn>
      <fn fn-type="edited-by">
        <p>Reviewed by: Veena A. Nair, University of Wisconsin-Madison, United States; Stefan Haufe, Charité–Universittsmedizin Berlin, Germany</p>
      </fn>
      <corresp id="c001">*Correspondence: Matthias S. Treder <email>trederm@cardiff.ac.uk</email></corresp>
      <fn fn-type="other" id="fn001">
        <p>This article was submitted to Brain Imaging Methods, a section of the journal Frontiers in Neuroscience</p>
      </fn>
    </author-notes>
    <pub-date pub-type="epub">
      <day>04</day>
      <month>6</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>14</volume>
    <elocation-id>289</elocation-id>
    <history>
      <date date-type="received">
        <day>15</day>
        <month>8</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>12</day>
        <month>3</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2020 Treder.</copyright-statement>
      <copyright-year>2020</copyright-year>
      <copyright-holder>Treder</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY). The use, distribution or reproduction in other forums is permitted, provided the original author(s) and the copyright owner(s) are credited and that the original publication in this journal is cited, in accordance with accepted academic practice. No use, distribution or reproduction is permitted which does not comply with these terms.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>MVPA-Light is a MATLAB toolbox for multivariate pattern analysis (MVPA). It provides native implementations of a range of classifiers and regression models, using modern optimization algorithms. High-level functions allow for the multivariate analysis of multi-dimensional data, including generalization (e.g., time x time) and searchlight analysis. The toolbox performs cross-validation, hyperparameter tuning, and nested preprocessing. It computes various classification and regression metrics and establishes their statistical significance, is modular and easily extendable. Furthermore, it offers interfaces for LIBSVM and LIBLINEAR as well as an integration into the FieldTrip neuroimaging toolbox. After introducing MVPA-Light, example analyses of MEG and fMRI datasets, and benchmarking results on the classifiers and regression models are presented.</p>
    </abstract>
    <kwd-group>
      <kwd>machine learning</kwd>
      <kwd>classification</kwd>
      <kwd>decoding</kwd>
      <kwd>regression</kwd>
      <kwd>MVPA</kwd>
      <kwd>regularization</kwd>
      <kwd>cross-validation</kwd>
      <kwd>toolbox</kwd>
    </kwd-group>
    <counts>
      <fig-count count="5"/>
      <table-count count="3"/>
      <equation-count count="17"/>
      <ref-count count="52"/>
      <page-count count="19"/>
      <word-count count="14493"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="s1">
    <title>1. Introduction</title>
    <p>Multivariate pattern analysis (MVPA) refers to a set of multivariate tools for the analysis of brain activity or structure. It draws on supervised learning, a branch of machine learning mainly dealing with classification and regression problems. Multivariate classification has been used in EEG-based brain-computer interfaces since at least the 1980s (Farwell and Donchin, <xref rid="B15" ref-type="bibr">1988</xref>), but it did not become a mainstream tool in cognitive neuroscience until the late 2000s (Mur et al., <xref rid="B36" ref-type="bibr">2009</xref>; Pereira et al., <xref rid="B41" ref-type="bibr">2009</xref>; Blankertz et al., <xref rid="B5" ref-type="bibr">2011</xref>; Lemm et al., <xref rid="B31" ref-type="bibr">2011</xref>). MVPA was first popularized by the seminal work of Haxby et al. (Haxby et al., <xref rid="B21" ref-type="bibr">2001</xref>; Norman et al., <xref rid="B37" ref-type="bibr">2006</xref>; Haxby, <xref rid="B20" ref-type="bibr">2012</xref>). In an fMRI study, the authors provided evidence that visual categories (such as faces and houses) are associated with distributed representations across multiple brain regions. MVPA is designed to exploit such multivariate patterns by taking into account multiple voxels or channels simultaneously. This constitutes a major difference between MVPA and traditional statistical methods such as <italic>t</italic>-test and analysis of variance (ANOVA). Traditional statistical tests are often univariate i.e., a test is performed for each dependent variable, for instance voxel or EEG channel, separately. In contrast to MVPA, such tests are blind to the distributed information encoded in the correlations between different spatial locations.</p>
    <p>To highlight this difference with an example, consider a hypothetical visual experiment: In each trial, subjects are presented an image of either a face or a house and their brain activity is recorded using fMRI. To make sure that they maintain attention, subjects are instructed to indicate via a button press whether the image represents a face or a house. This experiment will be referred to as “faces vs. houses” throughout this paper. To investigate the difference between the brain responses to faces vs. houses, a <italic>t</italic>-test can be applied to answer the question “Is the activity <italic>at a specific voxel</italic> different for faces vs. houses?.” In contrast, MVPA addresses the more general question “Is the <italic>pattern of brain activity</italic> different for faces vs. houses?.” This example illustrates that univariate statistics and MVPA inhabit opposite ends of a spectrum between <italic>sensitivity</italic> (“Is there an effect?”) and <italic>localizability</italic> (“Where is the effect?”). A classical univariate test might be unable to detect a specific effect because it is blind to multivariate dependencies (low sensitivity) but any effect it does detect is perfectly localized to a single voxel. In contrast, MVPA gains statistical power by capitalizing on correlations between different locations (high sensitivity) but it is difficult to attribute an effect to a specific brain location (low localizability). A MVPA technique called <italic>searchlight analysis</italic> (see glossary) attempts to cover the middle ground between these two extremes. As this comparison illustrates, MVPA should be considered as a complement, rather than a competitor, to traditional statistical methods. Finally, there are other ways in which MVPA and traditional statistics differ. For instance, MVPA includes kernel methods that are sensitive to non-linear relationships and it makes extensive use of techniques such as <italic>cross-validation</italic> that control for <italic>overfitting</italic>.</p>
    <p>To use MVPA as part of a neuroimaging analysis pipeline, numerous excellent MATLAB toolboxes have been developed over the years, including the Amsterdam Decoding and Modeling Toolbox (ADAM) (Fahrenfort et al., <xref rid="B13" ref-type="bibr">2018</xref>), BCILAB (Kothe and Makeig, <xref rid="B27" ref-type="bibr">2013</xref>), Berlin BCI toolbox (Blankertz et al., <xref rid="B4" ref-type="bibr">2016</xref>), CoSMoMVPA (Oosterhof et al., <xref rid="B39" ref-type="bibr">2016</xref>), Decision Decoding ToolBOX (DDTBOX) (Bode et al., <xref rid="B7" ref-type="bibr">2019</xref>), Donders Machine Learning Toolbox (DMLT) (<monospace>github.com/distrep/DMLT</monospace>), Pattern Recognition for Neuroimaging Toolbox (PRoNTo) (Schrouff et al., <xref rid="B44" ref-type="bibr">2013</xref>), and The Decoding Toolbox (TDT) (Hebart et al., <xref rid="B23" ref-type="bibr">2015</xref>). Beyond MATLAB, the currently most popular computer languages for machine learning are Python and R, with outstanding toolboxes such as Scikit Learn (Pedregosa et al., <xref rid="B40" ref-type="bibr">2011</xref>) for Python and Caret (Kuhn, <xref rid="B29" ref-type="bibr">2008</xref>) and MLR (Bischl et al., <xref rid="B2" ref-type="bibr">2000</xref>) for R. A comprehensive comparison of MVPA-Light with all of these toolboxes is beyond the scope of this paper, but what sets it apart is the adherence to all of the following design principles:</p>
    <list list-type="bullet">
      <list-item>
        <p><italic>Self-contained</italic>: unlike many toolboxes that provide wrappers for existing classifiers, the backbone of MVPA-Light is native implementations of various classifiers, regression models, and their corresponding optimization algorithms (Trust-Region Newton, Dual Coordinate Descent). As a result, MVPA-Light works out-of-the-box, without the need for additional toolboxes or code compilation.</p>
      </list-item>
      <list-item>
        <p><italic>Transparent</italic>: the toolbox has a shallow code base with well-documented functions. In many cases, the function call stack has a depth of two within the toolbox. For instance, a call to <monospace>mv_classify</monospace> using an LDA classifier triggers calls to functions such as <monospace>mv_check_inputs</monospace>, <monospace>train_lda</monospace>, and <monospace>test_lda</monospace>. Although the train/test functions might call additional optimization functions, most of the work is done at these two shallowest levels. To preserve the shallowness, high-level functions replicate some code that might be shared otherwise. Object orientation and encapsulation is avoided in favor of the more transparent MATLAB structs.</p>
      </list-item>
      <list-item>
        <p><italic>Fast</italic>: all models and high-level functions are written with speed as a prime concern. In some cases, the need for speed conflicts with the out-of-the-box requirement. For instance, Logistic Regression and SVM use iterative optimization algorithms written in MATLAB. However, these algorithms potentially run faster using compiled code. To this end, an interface is provided for LIBSVM (Chang et al., <xref rid="B8" ref-type="bibr">2011</xref>) and LIBLINEAR (Fan et al., <xref rid="B14" ref-type="bibr">2008</xref>), two C implementations of Logistic Regression and SVM for users who do not shy away from compiling the code on their platform.</p>
      </list-item>
      <list-item>
        <p><italic>Modular and pluggable</italic>: it is possible, and intended, to harvest parts of the code such as the classifiers for other purposes. It is also easy to plug the toolbox into a larger neuroimaging analysis framework. An interface for FieldTrip (Oostenveld et al., <xref rid="B38" ref-type="bibr">2011</xref>) is described in the Methods section.</p>
      </list-item>
      <list-item>
        <p><italic>High-level interface</italic>: common MVPA tasks such as searchlight analysis and time generalization including cross-validation can be performed with a few lines of MATLAB code. Many of the hyperparameters required by classifiers and regression models are automatically selected by MVPA-Light, taking the burden of hyperparameter selection off the user.</p>
      </list-item>
    </list>
    <p>It is worth noting that MVPA-Light is a purely statistical toolbox. That is, it assumes that data has been preprocessed with a neuroimaging toolbox and comes in the shape of MATLAB arrays. Many neuroimaging toolboxes (e.g., FieldTrip, SPM, EEGLAB) store the imaging data in such arrays, so that MVPA-Light can easily be used as a plugin tool. This comes with the perk that adaptation to different imaging modalities is straightforward.</p>
    <sec>
      <title>1.1. MVPA Glossary</title>
      <p>MVPA comes with its own set of commonly used terms, many of which are borrowed from machine learning. Since they are used extensively throughout the paper, a glossary is provided here. Fully understanding these concepts can be challenging so unfamiliar readers are referred to review papers on MVPA (Mur et al., <xref rid="B36" ref-type="bibr">2009</xref>; Pereira et al., <xref rid="B41" ref-type="bibr">2009</xref>; Misaki et al., <xref rid="B34" ref-type="bibr">2010</xref>; Grootswagers et al., <xref rid="B17" ref-type="bibr">2017</xref>; Varoquaux et al., <xref rid="B50" ref-type="bibr">2017</xref>). For an in-depth introduction to machine learning refer to standard textbooks (Bishop, <xref rid="B3" ref-type="bibr">2007</xref>; Hastie et al., <xref rid="B19" ref-type="bibr">2009</xref>; James et al., <xref rid="B24" ref-type="bibr">2013</xref>).</p>
      <list list-type="bullet">
        <list-item>
          <p><italic>Binary classifier</italic>. A classifier trained on data that contains two classes, such as in the “faces vs. houses” experiment. If there is more than two classes, the classifier is called a multi-class classifier.</p>
        </list-item>
        <list-item>
          <p><italic>Classification</italic>. One of the primary applications of MVPA. In classification, a classifier takes a multivariate pattern of brain activity (referred to as <italic>feature vector</italic>) as input and maps it onto a categorical brain state or experimental condition (referred to as <italic>class label</italic>). In the “faces vs. houses” experiment, the classifier is used to investigate whether patterns of brain activity can discriminate between faces and houses.</p>
        </list-item>
        <list-item>
          <p><italic>Classifier</italic>. An algorithm that performs classification, for instance Linear Discriminant Analysis (LDA) and Support Vector Machine (SVM).</p>
        </list-item>
        <list-item>
          <p><italic>Classifier output</italic>. If a classifier receives a pattern of brain activity (feature vector) as input, its output is a predicted class label e.g., “face.” Many classifiers are also able to produce class probabilities (representing the probability that a brain pattern belongs to a specific class) or decision values.</p>
        </list-item>
        <list-item>
          <p><italic>Class label</italic>. Categorical variable that represents a label for each sample/trial. In the “faces vs. houses” experiment, the class labels are “face” and “house.” Class labels are often encoded by numbers, e.g., “face” = 1 and “house” = 2, and arranged as a vector. For instance, the class label vector [1, 2, 1] indicates that a subject viewed a face in trial 1, a house in trial 2, and another face in trial 3.</p>
        </list-item>
        <list-item>
          <p><italic>Cross-validation</italic>. To obtain a realistic estimate of classification or regression performance and control for overfitting, a model should be tested on an independent dataset that has not been used for training. In most neuroimaging experiments, there is only one dataset with a restricted number of trials. K-fold cross-validation makes efficient use of such data by splitting it into k different folds. In every iteration, one of the k folds is held out and used as test set, whereas all other folds are used for training. This is repeated until every fold served as test set once. Since cross-validation itself is stochastic due to the random assignment of samples to folds, it can be useful to repeat the cross-validation several times and average the results. See Lemm et al. (<xref rid="B31" ref-type="bibr">2011</xref>) and Varoquaux et al. (<xref rid="B50" ref-type="bibr">2017</xref>) for a discussion of cross-validation and potential pitfalls.</p>
        </list-item>
        <list-item>
          <p><italic>Data</italic>. From the perspective of a classifier or regression model, a dataset is a collection of samples (e.g., trials in an experiment). Each sample consists of a brain pattern and a corresponding class label or response. In formal notation, each sample consists of a pair (<bold>x</bold>, <italic>y</italic>) where <bold>x</bold> is a feature vector and <italic>y</italic> is the corresponding class label or response.</p>
        </list-item>
        <list-item>
          <p><italic>Decision boundary</italic>. Classifiers partition feature space into separate regions. Each region is assigned to a specific class. Classifiers make predictions for a test sample by looking up into which region it falls. The boundary between regions is known as decision boundary. For linear classifiers, the decision boundary is also known as a hyperplane.</p>
        </list-item>
        <list-item>
          <p><italic>Decision value</italic>. Classifiers such as LDA and SVM produce decision values which can be thresholded to produce class labels. For linear classifiers and kernel classifiers, a decision value represents the distance to the decision boundary. The further away a test sample is from the decision boundary, the more confident the classifier is about it belonging to a particular class. Decision values are unitless.</p>
        </list-item>
        <list-item>
          <p><italic>Decoder</italic>. An alternative term for a <italic>classifier</italic> or <italic>regression model</italic> that is popular in the neuroimaging literature. The term nicely captures the fact that it tries to invert the encoding process. In encoding e.g., a sensory experience such as viewing a face is translated into a pattern of brain activity. In decoding, one starts from a pattern of brain activity and tries to infer whether it was caused by a face or a house stimulus.</p>
        </list-item>
        <list-item>
          <p><italic>Feature</italic>. A feature is a variable that is part of the input to a model. If the dataset is tabular with rows representing samples, it typically corresponds to one of the columns. In the “faces vs. houses” experiment, each voxel represents a feature.</p>
        </list-item>
        <list-item>
          <p><italic>Feature space</italic>. Usually a real vector space that contains the feature vectors. The dimensionality of the feature space is equal to the number of features.</p>
        </list-item>
        <list-item>
          <p><italic>Feature vector</italic>. For each sample, features are stored in a vector. For example, consider a EEG measurement with three electrodes Fz, Cz, and Oz and corresponding voltages 40, 65, and 97 μV. The voltage at each EEG sensor represents a feature, so the corresponding feature vector is the vector [40, 65, 97] ∈ ℝ<sup>3</sup>.</p>
        </list-item>
        <list-item>
          <p><italic>Fitting (a model)</italic>. Same as <italic>training</italic>.</p>
        </list-item>
        <list-item>
          <p><italic>Hyperparameter</italic>. A parameter of a model that needs to be specified by the user, such as the type and amount of regularization applied, the type of kernel, and the kernel width γ for Gaussian kernels. From the user's perspective, hyperparameters can be nuisance parameters: it is sometimes not clear a priori how to set them, but their exact value can have a substantial effect on the performance of the model.</p>
        </list-item>
        <list-item>
          <p><italic>Hyperparameter tuning</italic>. If it is unclear how a hyperparameter should be set, multiple candidate values can be tested. Typically, this is done via nested cross-validation: the training set is again split into separate folds. A model is trained for each of the candidate values and its performance is evaluated on the held-out fold, called validation set. Only the model with the best performance is then taken forward to the test set.</p>
        </list-item>
        <list-item>
          <p><italic>Hyperplane</italic>. For linear classifiers, the decision boundary is a hyperplane. In the special case of a two-dimensional feature space, a hyperplane corresponds to a straight line. In three dimensions, it corresponds to a plane.</p>
        </list-item>
        <list-item>
          <p><italic>Loss function</italic>. A function that is used for training. The model parameters are optimized such that the loss function attains a minimum value. For instance, in Linear Regression the sum of squares of the residuals serves as a loss function.</p>
        </list-item>
        <list-item>
          <p><italic>Metric</italic>. A quantitative measure of the performance of a model on a test set. For example, precision/recall for classification or mean squared error for regression.</p>
        </list-item>
        <list-item>
          <p><italic>Model</italic>. In the context of this paper, a model is a classifier or regression model.</p>
        </list-item>
        <list-item>
          <p><italic>Multi-class classifier</italic>. A classifier trained on data that contains three or more classes. For instance, assume that in the “faces vs. houses” experiment additional images have been presented depicting “animals” and “tools.” This would define four classes in total, hence classification would require a multi-class classifier.</p>
        </list-item>
        <list-item>
          <p><italic>Overfitting</italic>. Occurs when a model over-adapts to the training data. As a consequence, it will perform well on the training set but badly on the test set. Generally speaking, overfitting is more likely to occur if the number of features is larger than the number of samples, and more likely for complex non-linear models than for linear models. Regularization can serve as an antidote to overfitting.</p>
        </list-item>
        <list-item>
          <p><italic>Parameters</italic>. Models are governed by parameters e.g., beta coefficients in Linear Regression or the weight vector <bold>w</bold> and bias <italic>b</italic> in a linear classifier.</p>
        </list-item>
        <list-item>
          <p><italic>Regression</italic>. One of the primary applications of MVPA (together with classification). Regression is very similar to classification, but it aims to predict a continuous variable rather than a class label. For instance, in the ‘faces vs. houses' experiment, assume that the reaction time of the button press has been recorded, too. To investigate the question “Does the pattern of brain activity in each trial predict reaction time?,” regression can be performed using reaction time as responses.</p>
        </list-item>
        <list-item>
          <p><italic>Regression model</italic>. An algorithm that performs regression, for instance Ridge Regression and Support Vector Regression (SVR).</p>
        </list-item>
        <list-item>
          <p><italic>Regularization</italic>. A set of techniques that aim to reduce overfitting. Regularization is often directly incorporated into training by adding a penalty term to the loss function. For instance, L1 and L2 penalty terms are popular regularization techniques. They reduce overfitting by preventing coefficients from taking on too large values.</p>
        </list-item>
        <list-item>
          <p><italic>Response</italic>. In regression, responses act as the target values that a model tries to predict. They play the same role that class labels play in classification. Unlike class labels, responses are continuous e.g., reaction time.</p>
        </list-item>
        <list-item>
          <p><italic>Searchlight analysis</italic>. In neuroimaging analysis, a question such as “Does brain activity differentiate between faces and houses?” is usually less interesting than the question “Which brain regions differentiate between faces and houses?.” In other words, the goal of MVPA is to establish the presence of an effect <italic>and</italic> localize it in space or time. Searchlight analysis intends to marry statistical sensitivity with localizability. It is a well-established technique in the fMRI literature, where a searchlight is defined e.g., as a sphere of 1 cm radius, centered on a voxel in the brain (Kriegeskorte et al., <xref rid="B28" ref-type="bibr">2006</xref>). All voxels within the radius serve as features for a classification or regression analysis. The result of the analysis is assigned to the central voxel. If the analysis is repeated for all voxel positions, the resultant 3D map of classification accuracies can be overlayed on a brain image. Brain regions that have discriminative information then light up as peaks in the map. Searchlight analysis is not limited to spatial coordinates. The same idea can be applied to other dimensions such as time points and frequencies.</p>
        </list-item>
        <list-item>
          <p><italic>Testing</italic>. The process of applying a trained model to the test set. The performance of the model can then be quantified using a metric.</p>
        </list-item>
        <list-item>
          <p><italic>Test set</italic>. Part of the data designated for testing. Like with training sets, test sets are automatically defined in cross-validation, or they can arise naturally in multi-site studies or in experiments with different phases.</p>
        </list-item>
        <list-item>
          <p><italic>Training</italic>. The process of optimizing the parameters of a model using a training set.</p>
        </list-item>
        <list-item>
          <p><italic>Training set</italic>. Part of the data designated for training. In cross-validation, a dataset is automatically split into training and test sets. In other cases, a training set may arise naturally. For instance, in experiments with different phases (e.g., memory encoding and memory retrieval) one phase may serve as training set and the other phase as test set. Another example is multi-site studies, where a model can be trained on data from one site and tested on data from another site.</p>
        </list-item>
        <list-item>
          <p><italic>Underfitting</italic>. Occurs when a classifier or regression model is too simple to explain the data. For example, imagine a dataset wherein the optimal decision boundary is a circle, with samples of class 1 being inside the circle and samples of class 2 outside. A linear classifier is not able to represent a circular decision boundary, hence it will be unable to adequately solve the task. Underfitting can be checked by fitting a complex model (e.g., kernel SVM) to data. If the complex model performs much better than a more simple linear model (e.g., LDA) then it is likely that the simple model underfits the data. In most neuroimaging datasets, overfitting is more of a concern than underfitting.</p>
        </list-item>
      </list>
      <p>The rest of the paper is structured as follows. The high-level functions of the toolbox are described, followed by an introduction of the classifiers and regression models. Then, example analyses are presented using a publicly available Wakeman and Henson (<xref rid="B51" ref-type="bibr">2014</xref>, <xref rid="B52" ref-type="bibr">2015</xref>) MEEG dataset and the Haxby et al. (<xref rid="B21" ref-type="bibr">2001</xref>) fMRI dataset. Finally, a benchmarking analysis is conducted wherein the computational efficiency of the classifiers and regression models in MVPA-Light is compared to models in other toolboxes in MATLAB, Python, and R.</p>
    </sec>
  </sec>
  <sec sec-type="materials and methods" id="s2">
    <title>2. Materials and Methods</title>
    <sec>
      <title>2.1. Requirements</title>
      <p>A standard desktop computer is sufficient to run MVPA-Light. The RAM requirement is dictated by the memory footprint of the dataset. Since some functions operate on a copy of the data, it is recommended that the available RAM exceeds the size of the dataset by at least a factor of two (e.g., 4+ GB RAM for a 2 GB dataset). MVPA-Light is supported by MATLAB 2012a and more recent versions. The Statistics toolbox is required at some points in the toolbox (e.g., for calculating <italic>t</italic>-values). The cluster permutation test in <monospace>mv_statistics</monospace> uses the Image Processing toolbox to extract the clusters.</p>
    </sec>
    <sec>
      <title>2.2. Getting Started</title>
      <p>MVPA-Light is shipped with a set of example scripts (in the <monospace>/examples</monospace> subfolder) and an example EEG dataset. These scripts cover both the high-level functions in MVPA-Light and calling the train/test functions manually. The best starting point is to work through the example scripts and then adapt them to one's purpose. An up-to-date introduction to the toolbox with relevant hyperlinks is provided on the GitHub page (<monospace>github.com/treder/mvpa-light</monospace>).</p>
      <p>The EEG data has been taken from the BNCI-Horizon-2020 repository (<ext-link ext-link-type="uri" xlink:href="http://bnci-horizon-2020.eu/database">http://bnci-horizon-2020.eu/database</ext-link>). It consists of three <monospace>mat</monospace> files corresponding to three subjects (subject codes <monospace>VPaak</monospace>, <monospace>VPaan</monospace>, and <monospace>VPgcc</monospace>) from the auditory oddball paradigm introduced in Treder et al. (<xref rid="B49" ref-type="bibr">2014</xref>). Out of the experimental conditions, the “SynthPop” condition has been selected. Attended and unattended deviants are coded as class 1 and 2. The 64 EEG channels in the original dataset have been reduced to 32 channels.</p>
      <p>To give a concrete code example, consider the “faces vs. houses” experiment. For each trial, the BOLD response has been recorded for all voxels. This yields a [samples x voxels] data matrix for one subject, where the samples correspond to trials and the voxels serve as features. The matrix is denoted as <monospace>X</monospace>. Each trial corresponds to either a “face” or a “house” stimulus. This is encoded in a vector of class labels, denoted as <monospace>clabel</monospace>, that contains 1's and 2's (“face” = 1, “house” = 2). Then the following piece of code performs 10-fold cross-validation with 2 repetitions. LDA is used as classifier and area under the ROC curve (AUC) is calculated as a classification metric.</p>
      <preformat>
cfg = [];
cfg.model       = 'lda';
cfg.metric      = 'auc';
cfg.cv          = 'kfold';
cfg.k           = 10;
cfg.repeat      = 2;
</preformat>
      <preformat>
auc = mv_classify(cfg, X, clabel);
</preformat>
      <p>The output value <monospace>auc</monospace> contains the classifier performance measure, in this case a single AUC value averaged across test folds and repetitions. <monospace>mv_classify</monospace> is part of the high-level interface that will be discussed next.</p>
    </sec>
    <sec>
      <title>2.3. High-level Interface</title>
      <p>The structure of MVPA-Light is depicted in <xref ref-type="fig" rid="F1">Figure 1</xref>. The toolbox can be interacted with through high-level functions that cover common classification tasks. <monospace>mv_classify</monospace> is a general-purpose function that works on data of arbitrary dimension (e.g., time-frequency data). It performs any combination of cross-validation, searchlight analysis, generalization, and other tasks. Two more specialized functions are provided for convenience: <monospace>mv_classify_across_time</monospace> and <monospace>mv_classify_timextime</monospace>, assume that the data has a time dimension i.e., it is a 3-D [samples × features × time points] array. <monospace>mv_classify_across_time</monospace> performs classification for every time point, resulting in a vector of cross-validated metrics, the length of the vector being the number of time points. <monospace>mv_classify_timextime</monospace> expects the same 3-D input. It implements time generalization (King and Dehaene, <xref rid="B26" ref-type="bibr">2014</xref>) i.e., classification for every combination of training and test time points, resulting in a 2-D matrix of cross-validated metrics. For regression tasks, the equivalent to <monospace>mv_classify</monospace> is the function <monospace>mv_regress</monospace>. It also works with data of arbitrary dimension and supports both searchlight and generalization.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p>Structure of MVPA-Light.</p>
        </caption>
        <graphic xlink:href="fnins-14-00289-g0001"/>
      </fig>
      <p>All high-level functions take three input arguments. First, <monospace>cfg</monospace>, a configuration structure wherein parameters for the analysis can be set. Second, <monospace>X</monospace>, the data acting as input to the model. Third, <monospace>clabel</monospace> or <monospace>y</monospace>, a vector of class labels or responses. Some of the parameters in the <monospace>cfg</monospace> struct are common to all high-level functions:</p>
      <list list-type="bullet">
        <list-item>
          <p><monospace>cfg.model</monospace>: name of the classifier or regression model, e.g., <monospace>'lda.'</monospace></p>
        </list-item>
        <list-item>
          <p><monospace>cfg.hyperparameter</monospace>: a struct that specifies the hyperparameters for the model. For instance, <monospace>cfg.hyperparameter.lambda</monospace> = <monospace>0.1</monospace> sets the magnitude of shrinkage regularization in LDA. LDA's hyperparameters are introduced in section 2.4.3.</p>
        </list-item>
        <list-item>
          <p><monospace>cfg.metric</monospace>: specifies the metric to be calculated from the model predictions e.g., classification accuracy or mean-squared error for regression. Metrics are introduced in section 2.6.</p>
        </list-item>
        <list-item>
          <p><monospace>cfg.preprocess</monospace>: a struct that specifies a nested preprocessing pipeline. The pipeline consists of preprocessing operations that are applied on train and test data separately. Preprocessing is discussed in section 2.3.3.</p>
        </list-item>
      </list>
      <sec>
        <title>2.3.1. Cross-Validation</title>
        <p>Cross-validation is implemented in all high-level functions. It is controlled by the following parameters that are part of the <monospace>cfg</monospace> struct defined in the previous section:</p>
        <list list-type="bullet">
          <list-item>
            <p><monospace>cfg.cv</monospace>: cross-validation type, either <monospace>'kfold,' 'leaveout,'</monospace><monospace>'predefined,''holdout,'</monospace> or <monospace>'none'</monospace>.</p>
          </list-item>
          <list-item>
            <p><monospace>cfg.k</monospace>: number of folds in k-fold cross-validation.</p>
          </list-item>
          <list-item>
            <p><monospace>cfg.repeat</monospace>: number of times the cross-validation is repeated with new randomly assigned folds.</p>
          </list-item>
          <list-item>
            <p><monospace>cfg.p</monospace>: if <monospace>cfg.cv</monospace> = <monospace>'holdout,'p</monospace> is the fraction of test samples.</p>
          </list-item>
          <list-item>
            <p><monospace>cfg.fold</monospace>: if <monospace>cfg.cv</monospace> = <monospace>'predefined,'</monospace> fold is a vector of integers that specifies which fold a sample belongs to.</p>
          </list-item>
          <list-item>
            <p><monospace>cfg.stratify</monospace>: if 1, for classification, the class proportions are approximately preserved in each test fold.</p>
          </list-item>
        </list>
        <p>See the function <monospace>mv_get_crossvalidation_folds</monospace> for more details.</p>
      </sec>
      <sec>
        <title>2.3.2. Hyperparameter Tuning</title>
        <p>MVPA-Light tries to automate hyperparameter selection as much as possible. This is done using either reasonable default values, hyperparameter estimators [Ledoit and Wolf (<xref rid="B30" ref-type="bibr">2004</xref>) for LDA] or hyperparameter-free regularizers (log-F(1,1) for Logistic Regression). If this is not possible, automated grid search using nested cross-validation can be used for testing out different hyperparameter combinations essentially by brute force. For better performance, bespoke hyperparameter tuning functions are implemented for some classifiers. Otherwise, the generic tuning function <monospace>mv_tune_hyperparameter</monospace> is used.</p>
      </sec>
      <sec>
        <title>2.3.3. Preprocessing</title>
        <p>Preprocessing refers to operations applied to the data prior to training the classifier. To not bias the result, some preprocessing operations (such as Common Spatial Patterns) should be performed in a “nested” fashion. That is, they are performed on the training data first and subsequently applied to the test data using parameters estimated from the training data (Lemm et al., <xref rid="B31" ref-type="bibr">2011</xref>; Varoquaux et al., <xref rid="B50" ref-type="bibr">2017</xref>). Currently implemented functions include PCA, sample averaging (Cichy and Pantazis, <xref rid="B9" ref-type="bibr">2017</xref>), kernel averaging (Treder, <xref rid="B47" ref-type="bibr">2018</xref>), and under-/oversampling for unbalanced data. Preprocessing pipelines are defined by adding the <monospace>cfg.preprocess</monospace> parameter. For instance,</p>
        <preformat>
cfg.preprocess = {'undersample,' 'zscore,'
 'average_kernel'}
</preformat>
        <p>adds a preprocessing pipeline that performs undersampling of the data followed by z-scoring and kernel averaging.</p>
      </sec>
      <sec>
        <title>2.3.4. Searchlight Analysis</title>
        <p>In MVPA-Light, <monospace>mv_classify_across_time</monospace> performs searchlight analysis across the time axis. More bespoke searchlight analyses can be conducted using <monospace>mv_classify</monospace> and <monospace>mv_regress</monospace> by setting the parameter <monospace>cfg.neighbours</monospace>.</p>
      </sec>
    </sec>
    <sec>
      <title>2.4. Classifiers</title>
      <p>The main workhorses of MVPA are classifiers and regression models. <xref ref-type="fig" rid="F2">Figure 2</xref> provides a pictorial description of the classifiers. They are implemented using pairs of train/test functions. In the high-level interface, a classifier and its hyperparameters can be specified using <monospace>cfg.model</monospace> and <monospace>cfg.hyperparameter</monospace>. For instance,</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p>Overview of the available classifiers. Dots represent samples, color indicates the class. <italic>LDA</italic>: different classes are assumed to have the same covariance matrix, indicated by the ellipsoids. <italic>Gaussian Naive Bayes</italic>: features are conditionally independent, yielding diagonal covariance matrices. <italic>Logistic regression</italic>: a sigmoid function (curved plane) is fit to directly model class probabilities. <italic>SVM</italic>: a hyperplane (solid line) is fit such that the margin (distance from hyperplane to closest sample; indicated by dotted lines) is maximized. <italic>Ensemble</italic>: multiple classifiers are trained on subsets of the data. In this example, their hyperplanes partition the data into spaces belonging to classes 1 and 2. After applying all classifiers to a new data point and collecting their “votes,” the class receiving most votes is selected. <italic>Kernel methods</italic>: in this example the optimal decision boundary is circular (circle), hence the data is not linearly separable. After projection into a high-dimensional feature space using a map ϕ, the data becomes linearly separable (solid line) and a linear classifier such as SVM or LDA can be successfully applied in this space.</p>
        </caption>
        <graphic xlink:href="fnins-14-00289-g0002"/>
      </fig>
      <preformat>
cfg.model = 'lda';
cfg.hyperparameter.lambda = 0.1;
</preformat>
      <p>specifies an LDA classifier and sets the hyperparameter <monospace>lambda</monospace> = <monospace>0.1</monospace>. The <monospace>cfg</monospace> struct can then be used in a high-level function call, e.g., <monospace>acc</monospace> = <monospace>mv_classify_across_time(cfg, X, clabel)</monospace>. Alternatively, as a low-level interface, the train/test functions can be called directly. For instance, an LDA classifier can be trained directly using</p>
      <preformat>
model = train_lda(param, X, clabel)
</preformat>
      <p>where <monospace>X</monospace> is the training data and <monospace>clabel</monospace> are the corresponding class labels. <monospace>param</monospace> is a MATLAB struct that contains hyperparameters (same as <monospace>cfg.hyperparameter</monospace>). It can be initialized by calling <monospace>param</monospace> = <monospace>mv_get_hyperparameter('lda')</monospace>. An explanation of the hyperparameters for LDA is given when typing <monospace>help('train_lda')</monospace> in MATLAB. The output <monospace>model</monospace> is a struct that contains the classifier's parameters after training. The classifier can be applied to test data, denoted as <monospace>Xtest</monospace>, by calling</p>
      <preformat>
  [clabel, dval, prob] = test_lda(model,
Xtest)
</preformat>
      <p>The first output argument <monospace>clabel</monospace> is the predicted class labels. They can be compared against the true class labels to calculate a classification performance metric. <monospace>test_lda</monospace> provides two additional outputs, but not all classifiers have this capability. <monospace>dval</monospace> is the decision value, a dimensionless quantity that measures the distance to the hyperplane. <monospace>prob</monospace> contains the probability for a given sample to belong to class 1.</p>
      <p>To introduce some mathematical notation needed in the following, data is denoted as a matrix <bold>X</bold> ∈ ℝ<sup><italic>n</italic> × <italic>p</italic></sup> of <italic>n</italic> samples and <italic>p</italic> predictors/features. The i-th row of <bold>X</bold> is denoted as the column vector <inline-formula><mml:math id="M1"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>ℝ</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. Class labels are stored in a vector <bold>y</bold> ∈ ℝ<sup><italic>n</italic></sup> with <italic>y</italic><sub><italic>i</italic></sub> referring to the i-th class label. When the index is not relevant, the feature vector and class label are simply referred to as <bold>x</bold> and <italic>y</italic>. Before describing the classifiers, two conceptual perspectives are introduced that highlight some of their similarities.</p>
      <sec>
        <title>2.4.1. Perspective 1: Linear Classifiers</title>
        <p>For two classes, linear classifiers such as LDA, Logistic Regression, and linear SVM act on the data in a unified way. The decision value for a test sample <bold>x</bold> is given by</p>
        <disp-formula id="E1">
          <label>(1)</label>
          <mml:math id="M2">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mtext class="textrm" mathvariant="normal">dval</mml:mtext>
                  <mml:mo>=</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>w</mml:mtext>
                      </mml:mstyle>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mo>⊤</mml:mo>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mstyle mathvariant="bold">
                    <mml:mtext>x</mml:mtext>
                  </mml:mstyle>
                  <mml:mo>+</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>where <bold>w</bold> is the weight vector or normal to the hyperplane specifying the linear combination of features, and <italic>b</italic> is the threshold/bias term. A sample is assigned to the first class if <monospace>dval</monospace>&gt; 0 and to the second class if <monospace>dval</monospace> &lt; 0. If we encode class 1 as +1 and class 2 as –1, this can be expressed concisely as</p>
        <disp-formula id="E2">
          <mml:math id="M3">
            <mml:mtable columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mtext class="textrm" mathvariant="normal">predicted class</mml:mtext>
                  <mml:mo>=</mml:mo>
                  <mml:mtext class="textrm" mathvariant="normal">sign</mml:mtext>
                  <mml:mrow>
                    <mml:mo stretchy="true">(</mml:mo>
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mstyle mathvariant="bold">
                            <mml:mtext>w</mml:mtext>
                          </mml:mstyle>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mo>⊤</mml:mo>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>x</mml:mtext>
                      </mml:mstyle>
                      <mml:mo>+</mml:mo>
                      <mml:mi>b</mml:mi>
                    </mml:mrow>
                    <mml:mo stretchy="true">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>where sign:ℝ → {−1, +1} is the sign function. Linear classifiers differ only in the way that <bold>w</bold> and <italic>b</italic> are derived.</p>
      </sec>
      <sec>
        <title>2.4.2. Perspective 2: Probabilistic Classifiers</title>
        <p>Another useful perspective is given by the Bayesian framework (Bishop, <xref rid="B3" ref-type="bibr">2007</xref>). Probabilistic classifiers such as LDA, Naive Bayes, and Logistic Regression are able to directly model class probabilities for individual samples. Let us denote the (posterior) probability for class <italic>i</italic> given test sample <bold>x</bold> as <italic>P</italic>(<italic>y</italic> = <italic>i</italic>|<bold>x</bold>). A possible approach for calculating this quantity is Bayes' theorem:</p>
        <disp-formula id="E3">
          <label>(2)</label>
          <mml:math id="M4">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mi>P</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mi>y</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mi>i</mml:mi>
                      <mml:mo stretchy="false">|</mml:mo>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>x</mml:mtext>
                      </mml:mstyle>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>=</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mrow>
                          <mml:mstyle mathvariant="bold">
                            <mml:mtext>x</mml:mtext>
                          </mml:mstyle>
                          <mml:mo stretchy="false">|</mml:mo>
                          <mml:mi>y</mml:mi>
                          <mml:mo>=</mml:mo>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mtext> </mml:mtext>
                      <mml:mi>P</mml:mi>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mrow>
                          <mml:mi>y</mml:mi>
                          <mml:mo>=</mml:mo>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mrow>
                          <mml:mstyle mathvariant="bold">
                            <mml:mtext>x</mml:mtext>
                          </mml:mstyle>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>Here, <italic>P</italic>(<bold>x</bold>|<italic>y</italic> = <italic>i</italic>) is the likelihood function which quantifies the relative probability of observing <bold>x</bold> given the class label, and <italic>P</italic>(<italic>y</italic> = <italic>i</italic>) is the prior probability for a sample to belong to class <italic>i</italic>. The denominator, called evidence, can be calculated by marginalizing across the classes: <inline-formula><mml:math id="M5"><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder class="msub"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle><mml:mo>|</mml:mo><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mtext> </mml:mtext><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <title>2.4.3. Linear Discriminant Analysis (LDA)</title>
        <p>If the classes follow a multivariate Gaussian distribution with a common covariance matrix for all classes, LDA yields the theoretically optimal classifier (Duda et al., <xref rid="B12" ref-type="bibr">2001</xref>). In the context of EEG/MEG analysis, LDA is discussed in detail in Blankertz et al. (<xref rid="B5" ref-type="bibr">2011</xref>). The likelihood function takes the form</p>
        <disp-formula id="E4">
          <label>(3)</label>
          <mml:math id="M6">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mi>P</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>x</mml:mtext>
                      </mml:mstyle>
                      <mml:mo stretchy="false">|</mml:mo>
                      <mml:mi>y</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>~</mml:mo>
                  <mml:mrow>
                    <mml:mi mathvariant="script">N</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mstyle mathvariant="bold">
                            <mml:mtext>m</mml:mtext>
                          </mml:mstyle>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>,</mml:mo>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>Σ</mml:mtext>
                      </mml:mstyle>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>i.e., it is multivariate Gaussian distributed with a class-specific mean <bold>m</bold><sub><italic>i</italic></sub> and common covariance matrix <bold>Σ</bold>. Both need to be estimated from the training data. Equation (2) can then be evaluated to calculate class probabilities. A prediction can be done by selecting the most likely class out of all candidate classes,</p>
        <disp-formula id="E5">
          <mml:math id="M7">
            <mml:mtable columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mtext class="textrm" mathvariant="normal">predicted class</mml:mtext>
                  <mml:mo>=</mml:mo>
                  <mml:mstyle displaystyle="true">
                    <mml:munder>
                      <mml:mrow>
                        <mml:mtext class="textrm" mathvariant="normal">arg max</mml:mtext>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                    </mml:munder>
                  </mml:mstyle>
                  <mml:mtext> </mml:mtext>
                  <mml:mi>P</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mi>y</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mi>i</mml:mi>
                      <mml:mo stretchy="false">|</mml:mo>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>x</mml:mtext>
                      </mml:mstyle>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>which is known as the maximum a posteriori (MAP) rule. LDA is closely related to other statistical models. For two classes, LDA is equivalent to Linear Regression using the class labels as targets. It is also equivalent to Linearly Constrained Minimum Variance (LCMV) beamforming when applied to ERP data (Treder et al., <xref rid="B48" ref-type="bibr">2016</xref>). The latter equivalence relationship also applies to other methods based on generalized eigenvalue decomposition of covariance matrices (De Cheveigné and Parra, <xref rid="B11" ref-type="bibr">2014</xref>).</p>
        <p>In MVPA-Light, multi-class LDA is implemented as the classifier <monospace>'multiclass_lda.'</monospace> For two classes, a more efficient implementation denoted as <monospace>'lda'</monospace> is available. In practice, the covariance matrix is often ill-conditioned and needs to be regularized (Blankertz et al., <xref rid="B5" ref-type="bibr">2011</xref>). The hyperparameter <monospace>lambda</monospace> controls the amount of regularization. In shrinkage regularization, <monospace>lambda</monospace> ∈ [0, 1] blends between the empirical covariance matrix (<monospace>lambda</monospace> = 0) and a scaled identity matrix (<monospace>lambda</monospace>= 1). By default, <monospace>lambda</monospace> is estimated automatically using the Ledoit-Wolf formula (Ledoit and Wolf, <xref rid="B30" ref-type="bibr">2004</xref>). Section 4.1 (<xref ref-type="supplementary-material" rid="SM1">Appendix</xref> in Supplementary Material) discusses the implementation of LDA in detail.</p>
      </sec>
      <sec>
        <title>2.4.4. Naive Bayes</title>
        <p>In Naive Bayes, the features are assumed to be conditionally independent of each other given the class label (Bishop, <xref rid="B3" ref-type="bibr">2007</xref>). While this is indeed naive and often wrong, Naive Bayes has nevertheless been remarkably successful in classification problems. The independence assumption leads to a straightforward formula for the likelihood function since only univariate densities need to be estimated. Let <italic>x</italic>(<italic>j</italic>) be the <italic>j</italic>-th feature and <bold>x</bold> = [<italic>x</italic>(1), <italic>x</italic>(2), …, <italic>x</italic>(<italic>p</italic>)]<sup>⊤</sup> be a feature vector then the likelihood function is given by</p>
        <disp-formula id="E6">
          <mml:math id="M8">
            <mml:mtable columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mi>P</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>x</mml:mtext>
                      </mml:mstyle>
                      <mml:mo stretchy="false">|</mml:mo>
                      <mml:mi>y</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mi>i</mml:mi>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>=</mml:mo>
                  <mml:mstyle displaystyle="true">
                    <mml:munderover accentunder="false" accent="false">
                      <mml:mrow>
                        <mml:mo>∏</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                        <mml:mo>=</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>p</mml:mi>
                      </mml:mrow>
                    </mml:munderover>
                  </mml:mstyle>
                  <mml:mi>P</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msup>
                      <mml:mi>x</mml:mi>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>j</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo stretchy="false">|</mml:mo>
                    <mml:mi>y</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>Like in LDA, the predicted class can be obtained using the MAP rule. In MVPA-Light, Naive Bayes is implemented as <monospace>'naive_bayes.'</monospace> Additionally, MVPA-Light assumes that these densities are univariate Gaussian i.e., <inline-formula><mml:math id="M9"><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>|</mml:mo><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>~</mml:mo><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. For Gaussian densities, the independence assumption is equivalent to assuming that the covariance matrix is diagonal. As indicated in <xref ref-type="fig" rid="F2">Figure 2</xref>, there is a close relationship between LDA and Gaussian Naive Bayes: LDA allows for a dense covariance matrix, but it requires that it is the same for all classes. In contrast, Naive Bayes allows each class to have a different covariance matrix, but it requires each matrix to be diagonal. Additional details on the implementation are given in section 4.2 (<xref ref-type="supplementary-material" rid="SM1">Appendix</xref> in Supplementary Material).</p>
      </sec>
      <sec>
        <title>2.4.5. Logistic Regression</title>
        <p>In Logistic Regression for two classes, the posterior probability is modeled directly by fitting a logistic function to the data (Hastie et al., <xref rid="B19" ref-type="bibr">2009</xref>). If the two classes are coded as +1 and –1, it is given by</p>
        <disp-formula id="E7">
          <label>(4)</label>
          <mml:math id="M10">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mi>P</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mi>y</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mo>±</mml:mo>
                      <mml:mn>1</mml:mn>
                      <mml:mo stretchy="false">|</mml:mo>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>x</mml:mtext>
                      </mml:mstyle>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>=</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>1</mml:mn>
                      <mml:mo>+</mml:mo>
                      <mml:mtext class="textrm" mathvariant="normal">exp</mml:mtext>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mrow>
                          <mml:mo>-</mml:mo>
                          <mml:mi>y</mml:mi>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mrow>
                              <mml:msup>
                                <mml:mrow>
                                  <mml:mstyle mathvariant="bold">
                                    <mml:mtext>w</mml:mtext>
                                  </mml:mstyle>
                                </mml:mrow>
                                <mml:mrow>
                                  <mml:mo>⊤</mml:mo>
                                </mml:mrow>
                              </mml:msup>
                              <mml:mstyle mathvariant="bold">
                                <mml:mtext>x</mml:mtext>
                              </mml:mstyle>
                              <mml:mo>+</mml:mo>
                              <mml:mi>b</mml:mi>
                            </mml:mrow>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>The weights <bold>w</bold> are found by minimizing the logistic loss function</p>
        <disp-formula id="E8">
          <label>(5)</label>
          <mml:math id="M11">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi mathvariant="script">L</mml:mi>
                      <mml:mrow>
                        <mml:mtext>LR</mml:mtext>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mstyle mathvariant="bold">
                      <mml:mtext>w</mml:mtext>
                    </mml:mstyle>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mstyle displaystyle="true">
                      <mml:munderover>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mo>=</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                        <mml:mi>n</mml:mi>
                      </mml:munderover>
                      <mml:mrow>
                        <mml:mi>log</mml:mi>
                      </mml:mrow>
                    </mml:mstyle>
                    <mml:mo stretchy="false">[</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>+</mml:mo>
                    <mml:mtext>exp</mml:mtext>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mo>−</mml:mo>
                    <mml:msub>
                      <mml:mi>y</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msup>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>w</mml:mtext>
                      </mml:mstyle>
                      <mml:mo>⊤</mml:mo>
                    </mml:msup>
                    <mml:msub>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>x</mml:mtext>
                      </mml:mstyle>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo>+</mml:mo>
                    <mml:mi>b</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo stretchy="false">]</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>In MVPA-Light, Logistic Regression is implemented as <monospace>'logreg.'</monospace> By default, log-F(1,1) regularization (<monospace>reg</monospace> = <monospace>'logf'</monospace>) is used by imposing Jeffrey's prior on the weights (Firth, <xref rid="B16" ref-type="bibr">1993</xref>; King and Zeng, <xref rid="B25" ref-type="bibr">2001</xref>; Rahman and Sultana, <xref rid="B42" ref-type="bibr">2017</xref>). Alternatively, L2-regularization can be used to impose a Gaussian prior on the weights (<monospace>reg</monospace> = <monospace>'l2'</monospace>). In this case, an additional hyperparameter <monospace>lambda</monospace> ∈ [0, ∞) that controls the amount of regularization needs to be specified by the user. It can be set to a fixed value. Alternatively, a range of candidates can be specified (e.g., <monospace>lambda</monospace> = <monospace>[0.001, 0.01, 0.1, 1]</monospace>). A nested cross-validation is then performed to select the optimal value. Additional details on the implementation are given in section 4.3 (<xref ref-type="supplementary-material" rid="SM1">Appendix</xref> in Supplementary Material). An alternative implementation using LIBLINEAR is also available, see Section 2.9.</p>
      </sec>
      <sec>
        <title>2.4.6. Linear Support Vector Machine (SVM)</title>
        <p>A SVM has no underlying probabilistic model. Instead, it is based on the idea of maximizing the margin (Hearst et al., <xref rid="B22" ref-type="bibr">1998</xref>; Schölkopf and Smola, <xref rid="B43" ref-type="bibr">2001</xref>). For linearly separable data, the margin is the distance from the hyperplane to the closest data point (dotted line in <xref ref-type="fig" rid="F2">Figure 2</xref>). This distance is given by 1/||<bold>w</bold>||. Minimizing ||<bold>w</bold>|| is then equal to maximizing the margin. At the same time, one needs to make sure that the training samples are correctly classified at a distance from the hyperplane. This is achieved by requiring <inline-formula><mml:math id="M12"><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>w</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mo>⊤</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> for class 1 and <inline-formula><mml:math id="M13"><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>w</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mo>⊤</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo>≤</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula> for class 2. Encoding the classes as +1 and –1, both terms can be combined into <inline-formula><mml:math id="M14"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>w</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mo>⊤</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:math></inline-formula>. This constraint cannot be satisfied for every training sample <italic>i</italic> ∈ {1, …, <italic>n</italic>} if the data cannot be perfectly separated. Therefore, positive slack variables ξ<sub><italic>i</italic></sub> are introduced that allow for misclassifications. Now the goal becomes to maximize the margin while simultaneously minimizing the amount of constraint violations given by <inline-formula><mml:math id="M15"><mml:munder class="msub"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>ξ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>. Put together, this leads to the following optimization problem:</p>
        <disp-formula id="E9">
          <label>(6)</label>
          <mml:math id="M16">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mtable style="text-align:axis;" equalrows="false" columnlines="none" equalcolumns="false" class="array">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mstyle displaystyle="true">
                          <mml:munder>
                            <mml:mrow>
                              <mml:mtext class="textrm" mathvariant="normal">arg min</mml:mtext>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mstyle mathvariant="bold">
                                <mml:mtext>w</mml:mtext>
                              </mml:mstyle>
                            </mml:mrow>
                          </mml:munder>
                        </mml:mstyle>
                        <mml:mtext> </mml:mtext>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:mfrac>
                        <mml:mo stretchy="false">‖</mml:mo>
                        <mml:mstyle mathvariant="bold">
                          <mml:mtext>w</mml:mtext>
                        </mml:mstyle>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mo stretchy="false">‖</mml:mo>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>+</mml:mo>
                        <mml:mi>c</mml:mi>
                        <mml:mstyle displaystyle="true">
                          <mml:munder class="msub">
                            <mml:mrow>
                              <mml:mo>∑</mml:mo>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>i</mml:mi>
                            </mml:mrow>
                          </mml:munder>
                        </mml:mstyle>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>ξ</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mtext class="textrm" mathvariant="normal">subject to </mml:mtext>
                        <mml:mo>∀</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>:</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>y</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mstyle mathvariant="bold">
                                  <mml:mtext>w</mml:mtext>
                                </mml:mstyle>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mo>⊤</mml:mo>
                              </mml:mrow>
                            </mml:msup>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mstyle mathvariant="bold">
                                  <mml:mtext>x</mml:mtext>
                                </mml:mstyle>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>i</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo>+</mml:mo>
                            <mml:mi>b</mml:mi>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mo>≥</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>-</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>ξ</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd columnalign="left">
                        <mml:mtext>                  </mml:mtext>
                        <mml:mo>∀</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>:</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>ξ</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>≥</mml:mo>
                        <mml:mn>0</mml:mn>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr/>
                  </mml:mtable>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>The resultant classifier, called two-class L1-Support Vector Machine (SVM) is implemented as <monospace>‘svm.'</monospace> The hyperparameter <monospace>c</monospace> controls the amount of regularization and needs to be set by the user. Despite the lack of a probabilistic model, a Platt approximation using an external function (<ext-link ext-link-type="uri" xlink:href="http://www.work.caltech.edu/htlin/program/libsvm/"><monospace>http://www.work.caltech.edu/htlin/program/libsvm/</monospace></ext-link>) is used to estimate class probabilities if required. Additional details on the implementation are given in section 4.4 (<xref ref-type="supplementary-material" rid="SM1">Appendix</xref> in Supplementary Material). Alternative implementations using LIBSVM and LIBLINEAR are also available, see section 2.9.</p>
      </sec>
      <sec>
        <title>2.4.7. Kernel Classifiers</title>
        <p>In kernel methods such as SVM and kernel FDA, a sample is implicitly mapped from the input space <inline-formula><mml:math id="M17"><mml:mrow><mml:mi mathvariant="script">X</mml:mi></mml:mrow></mml:math></inline-formula> into a high-dimensional feature space <inline-formula><mml:math id="M18"><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:math></inline-formula> using a map <inline-formula><mml:math id="M19"><mml:mi>ϕ</mml:mi><mml:mo>:</mml:mo><mml:mrow><mml:mi mathvariant="script">X</mml:mi></mml:mrow><mml:mo>→</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:math></inline-formula>. As illustrated in <xref ref-type="fig" rid="F2">Figure 2</xref>, such a map can translate a non-linear classification problem into a linear problem in feature space (Schölkopf and Smola, <xref rid="B43" ref-type="bibr">2001</xref>). For two classes, decision values are given by</p>
        <disp-formula id="E10">
          <label>(7)</label>
          <mml:math id="M20">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mtext class="textrm" mathvariant="normal">dval</mml:mtext>
                  <mml:mo>=</mml:mo>
                  <mml:msubsup>
                    <mml:mrow>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>w</mml:mtext>
                      </mml:mstyle>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>ϕ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mo>⊤</mml:mo>
                    </mml:mrow>
                  </mml:msubsup>
                  <mml:mi>ϕ</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>x</mml:mtext>
                      </mml:mstyle>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>+</mml:mo>
                  <mml:mi>b</mml:mi>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>where <bold>w</bold><sub>ϕ</sub> is the weight vector in feature space. If we compare this formula to Equation (1), it becomes evident that kernel classifiers are linear classifiers acting on non-linear transformations of the features. Often, it is infeasible to explicitly apply the map due to the high dimensionality of <inline-formula><mml:math id="M21"><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:math></inline-formula>. However, for methods such as SVM and LDA, an efficient workaround is available. The optimization problem can be rewritten into a form wherein only the inner products between pairs of samples are needed, i.e., 〈ϕ(<bold>x</bold>), ϕ(<bold>x</bold>′)〉 for samples <bold>x</bold> and <bold>x</bold>′. Now, if ϕ maps to a Reproducing Kernel Hilbert Space (RKHS), these inner products can be efficiently calculated via a kernel function <italic>k</italic> that operates in input space, resulting in the identity <italic>k</italic>(<bold>x</bold>, <bold>x</bold>′) = 〈ϕ(<bold>x</bold>), ϕ(<bold>x</bold>′)〉. This is known as the <italic>kernel trick</italic>.</p>
        <p>To give a simple example, consider two samples with two-dimensional features, <bold>x</bold> = [<italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>] and <inline-formula><mml:math id="M22"><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula>. The homogeneous polynomial kernel of degree 2 has the kernel function <inline-formula><mml:math id="M23"><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:munderover accentunder="false" accent="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> and the corresponding feature map ϕ:ℝ<sup>2</sup> → ℝ<sup>3</sup> with <inline-formula><mml:math id="M24"><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msqrt><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msqrt><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula>. It is now easily verified that <italic>k</italic>(<bold>x</bold>, <bold>x</bold>′) = 〈ϕ(<bold>x</bold>), ϕ(<bold>x</bold>′)〉. For LDA, a kernelized version called Kernel Fisher Discriminant Analysis (KFDA) has been developed by Mika et al. (<xref rid="B33" ref-type="bibr">1999</xref>). It is available as <monospace>'kernel_fda.'</monospace> By default, the model is regularized using shrinkage regularization controlled by the hyperparameter <monospace>lambda</monospace>. Often, a small value (e.g., <monospace>lambda</monospace> = <monospace>0.01</monospace>) is adequate. Additional details on the implementation are given in section 4.5 (<xref ref-type="supplementary-material" rid="SM1">Appendix</xref> in Supplementary Material). For kernel SVM, either <monospace>'svm'</monospace> or the LIBSVM interface can be used. For both SVM and KFDA, the kernel can be chosen by setting the <monospace>kernel</monospace> parameter. Further information on the kernels is provided in the train functions.</p>
      </sec>
      <sec>
        <title>2.4.8. Ensemble Methods</title>
        <p>An <monospace>'ensemble'</monospace> is a meta-classifier that trains dozens or even hundreds of classifiers. In ensembles, these individual classifiers are referred to as learners. The type of learner can be set using the <monospace>learner</monospace> hyperparameter. For instance, setting <monospace>learner</monospace> = <monospace>'svm'</monospace> creates an ensemble of SVM classifiers. To encourage the learners to focus on different aspects of the data, every learner is presented just a subset of the training data. <monospace>nsamples</monospace> controls the number of training samples that is randomly selected for a given learner, whereas <monospace>nfeatures</monospace> controls the number of features. The final classifier output is determined via a voting strategy. If <monospace>strategy</monospace> = <monospace>'vote,'</monospace> then the class label produced by each individual learner serves as a vote. The class that receives the maximum number of votes is then selected. If <monospace>strategy</monospace> = <monospace>'dval'</monospace> then the raw decision values are averaged and the final decision is taken based on whether the average is positive or negative. The latter only works with classifiers that produce decision values.</p>
      </sec>
      <sec>
        <title>2.4.9. Classifier Output Type</title>
        <p>For every test sample, a classifier produces raw output. This output takes either a discrete form as a <italic>class label</italic> or a continuous one. If it is continuous, it comes either as a <italic>decision value</italic> or as a <italic>probability</italic>. A decision value is an unbounded number that can be positive or negative. Its absolute value corresponds to the distance to the hyperplane. For two classes, the probability is a number between 0 and 1 representing the probability that a sample belongs to class 1. In the high-level interface, the classifier output can be specified explicitly by setting <monospace>cfg.output_type</monospace> to <monospace>'clabel,''dval,'</monospace> or <monospace>'prob.'</monospace> In most cases, however, it suffices to let MVPA-Light infer the output type.</p>
      </sec>
    </sec>
    <sec>
      <title>2.5. Regression Models</title>
      <p>Like classifiers, regression models are implemented using pairs of train/test functions. In the high-level function <monospace>mv_regress</monospace>, a regression model is specified using the <monospace>cfg.model</monospace> parameter. Low-level access is possible by directly calling the train/test functions. For instance, <monospace>model</monospace> = <monospace>train_ridge(param, X, y)</monospace> trains a ridge regression model. <monospace>X</monospace> is the training data and <monospace>y</monospace> are the corresponding responses. <monospace>param</monospace> is a MATLAB struct that contains hyperparameters. The output <monospace>model</monospace> is a struct that contains the model parameters after training. The model can be applied to test data by calling <monospace>yhat</monospace> = <monospace>test_ridge(model, Xtest)</monospace> where <monospace>Xtest</monospace> is test data. The output of the test function is the model predictions. In the following section, the individual regression models are introduced. It is assumed that the training data is contained in matrix <bold>X</bold> ∈ ℝ<sup><italic>n</italic> × <italic>p</italic></sup> of <italic>n</italic> samples and <italic>p</italic> predictors. The i-th row of this matrix is denoted as the column vector <inline-formula><mml:math id="M25"><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>ℝ</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. Responses are stored in a vector <bold>y</bold> ∈ ℝ<sup><italic>n</italic></sup> with <bold>y</bold><sub><italic>i</italic></sub> referring to the i-th response.</p>
      <sec>
        <title>2.5.1. Perspective: Linear Regression</title>
        <p>Linear models such as Linear Regression, Ridge Regression, and linear Support Vector Regression, act on the data in a unified way by means of a vector of coefficients <bold>w</bold> (often represented by β's in the literature). Linear regression models differ only in the way that <bold>w</bold> is derived. To simplify the notation, it is assumed that the data matrix <bold>X</bold> contains a column of ones and hence the intercept term is contained in <bold>w</bold>. For a test sample <bold>x</bold>, the predicted response is given by <inline-formula><mml:math id="M26"><mml:mover accent="false"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>w</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mo>⊤</mml:mo></mml:mrow></mml:msup><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:math></inline-formula>. The vector of predicted responses on the training data <inline-formula><mml:math id="M27"><mml:mover accent="false"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>y</mml:mtext></mml:mstyle></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>ℝ</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> can be written in matrix notation as</p>
        <disp-formula id="E11">
          <label>(8)</label>
          <mml:math id="M28">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mover accent="false">
                    <mml:mrow>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>y</mml:mtext>
                      </mml:mstyle>
                    </mml:mrow>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                  <mml:mo>=</mml:mo>
                  <mml:mstyle mathvariant="bold">
                    <mml:mtext>X</mml:mtext>
                  </mml:mstyle>
                  <mml:mstyle mathvariant="bold">
                    <mml:mtext>w</mml:mtext>
                  </mml:mstyle>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>During training, the goal is to find a <bold>w</bold> such that <inline-formula><mml:math id="M29"><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≈</mml:mo><mml:msub><mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula> for each training sample. A natural measure of closeness between the true response and the prediction is the squared distance <inline-formula><mml:math id="M30"><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula>, which directly leads to the sum of squares measure <inline-formula><mml:math id="M31"><mml:munderover accentunder="false" accent="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula>. In matrix notation, the sum of squares is denoted as</p>
        <disp-formula id="E12">
          <label>(9)</label>
          <mml:math id="M32">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="script">L</mml:mi>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mtext class="textrm" mathvariant="normal">OLS</mml:mtext>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>w</mml:mtext>
                      </mml:mstyle>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>=</mml:mo>
                  <mml:mo stretchy="false">‖</mml:mo>
                  <mml:mstyle mathvariant="bold">
                    <mml:mtext>y</mml:mtext>
                  </mml:mstyle>
                  <mml:mo>-</mml:mo>
                  <mml:mstyle mathvariant="bold">
                    <mml:mtext>X</mml:mtext>
                  </mml:mstyle>
                  <mml:mstyle mathvariant="bold">
                    <mml:mtext>w</mml:mtext>
                  </mml:mstyle>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mo stretchy="false">‖</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                    </mml:mrow>
                  </mml:msup>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>The solution that minimizes this quantity, known as ordinary least squares (OLS) solution to linear regression, is given by <bold>w</bold> = (<bold>X</bold><sup>⊤</sup><bold>X</bold>)<sup>−1</sup>
<bold>X</bold><sup>⊤</sup><bold>y</bold>. It is worth noting that if one divides the sum of squares by the number of samples <italic>n</italic>, one obtains the regression metric <italic>mean squared error</italic> (MSE).</p>
      </sec>
      <sec>
        <title>2.5.2. Ridge Regression</title>
        <p>Ridge regression is a regularized version of OLS regression. It is useful for data that suffers from multicollinearity. The model is regularized by adding a L2 penalty that shrinks the weights toward zero. For a given regularization parameter <monospace>lambda</monospace> ∈ [0, ∞), denoted by the Greek symbol λ, the loss function is given by</p>
        <disp-formula id="E13">
          <label>(10)</label>
          <mml:math id="M33">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:mi mathvariant="script">L</mml:mi>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mtext class="textrm" mathvariant="normal">ridge</mml:mtext>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mstyle mathvariant="bold">
                        <mml:mtext>w</mml:mtext>
                      </mml:mstyle>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mo>=</mml:mo>
                  <mml:mo stretchy="false">‖</mml:mo>
                  <mml:mstyle mathvariant="bold">
                    <mml:mtext>y</mml:mtext>
                  </mml:mstyle>
                  <mml:mo>-</mml:mo>
                  <mml:mstyle mathvariant="bold">
                    <mml:mtext>X</mml:mtext>
                  </mml:mstyle>
                  <mml:mstyle mathvariant="bold">
                    <mml:mtext>w</mml:mtext>
                  </mml:mstyle>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mo stretchy="false">‖</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>+</mml:mo>
                  <mml:mo>λ</mml:mo>
                  <mml:mo stretchy="false">‖</mml:mo>
                  <mml:mstyle mathvariant="bold">
                    <mml:mtext>w</mml:mtext>
                  </mml:mstyle>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mo stretchy="false">‖</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                    </mml:mrow>
                  </mml:msup>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>This convex optimization problem can be solved directly by calculating the gradient and setting it to zero. Alternatively, it can be rewritten into its dual Lagrangian form first (Bishop, <xref rid="B3" ref-type="bibr">2007</xref>). The resultant primal and dual ridge solutions that minimize the loss function are given by</p>
        <disp-formula id="E14">
          <label>(11)</label>
          <mml:math id="M34">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mtable style="text-align:axis;" equalrows="false" columnlines="none" equalcolumns="false" class="array">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mstyle mathvariant="bold">
                          <mml:mtext>w</mml:mtext>
                        </mml:mstyle>
                        <mml:mo>=</mml:mo>
                        <mml:mtext> </mml:mtext>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mrow>
                                <mml:msup>
                                  <mml:mrow>
                                    <mml:mstyle mathvariant="bold">
                                      <mml:mtext>X</mml:mtext>
                                    </mml:mstyle>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mo>⊤</mml:mo>
                                  </mml:mrow>
                                </mml:msup>
                                <mml:mstyle mathvariant="bold">
                                  <mml:mtext>X</mml:mtext>
                                </mml:mstyle>
                                <mml:mo>+</mml:mo>
                                <mml:mo>λ</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>I</mml:mi>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mi>p</mml:mi>
                                  </mml:mrow>
                                </mml:msub>
                              </mml:mrow>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>-</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mstyle mathvariant="bold">
                              <mml:mtext>X</mml:mtext>
                            </mml:mstyle>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>⊤</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mstyle mathvariant="bold">
                          <mml:mtext>y</mml:mtext>
                        </mml:mstyle>
                        <mml:mtext>    </mml:mtext>
                        <mml:mo>(</mml:mo>
                        <mml:mtext class="textrm" mathvariant="normal">primal solution</mml:mtext>
                        <mml:mo>)</mml:mo>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mo>=</mml:mo>
                        <mml:mtext> </mml:mtext>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mstyle mathvariant="bold">
                              <mml:mtext>X</mml:mtext>
                            </mml:mstyle>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>⊤</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mrow>
                                <mml:mstyle mathvariant="bold">
                                  <mml:mtext>X</mml:mtext>
                                </mml:mstyle>
                                <mml:msup>
                                  <mml:mrow>
                                    <mml:mstyle mathvariant="bold">
                                      <mml:mtext>X</mml:mtext>
                                    </mml:mstyle>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mo>⊤</mml:mo>
                                  </mml:mrow>
                                </mml:msup>
                                <mml:mo>+</mml:mo>
                                <mml:mo>λ</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>I</mml:mi>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mi>n</mml:mi>
                                  </mml:mrow>
                                </mml:msub>
                              </mml:mrow>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>-</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mstyle mathvariant="bold">
                          <mml:mtext>y</mml:mtext>
                        </mml:mstyle>
                        <mml:mtext>    </mml:mtext>
                        <mml:mtext class="textrm" mathvariant="normal">(dual solution)</mml:mtext>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>where <inline-formula><mml:math id="M35"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>ℝ</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>×</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> and <inline-formula><mml:math id="M36"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi>ℝ</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> are identity matrices. The equivalence between the primal and dual solution can be verified by left-multiplying both solutions with <inline-formula><mml:math id="M37"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>X</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mo>⊤</mml:mo></mml:mrow></mml:msup><mml:mstyle mathvariant="bold"><mml:mtext>X</mml:mtext></mml:mstyle><mml:mo>+</mml:mo><mml:mi>λ</mml:mi><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>For <monospace>lambda</monospace>= 0 ridge regression reduces to OLS regression. By default (<monospace>form</monospace> = <monospace>'auto'</monospace>), MVPA-Light dynamically switches between the primal and the dual form depending on whether <italic>n</italic> is larger or smaller than <italic>p</italic>.</p>
      </sec>
      <sec>
        <title>2.5.3. Kernel Ridge Regression</title>
        <p>Analogous to kernel classifiers (section 2.4.7), a non-linear version of ridge regression can be developed by applying a non-linear transformation to the features. Let this transformation be represented by <inline-formula><mml:math id="M38"><mml:mi>ϕ</mml:mi><mml:mo>:</mml:mo><mml:mrow><mml:mi mathvariant="script">X</mml:mi></mml:mrow><mml:mo>→</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:math></inline-formula>, a map from input space to a Reproducing Kernel Hilbert Space, and <inline-formula><mml:math id="M39"><mml:mi>Φ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>X</mml:mtext></mml:mstyle></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>ϕ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mstyle mathvariant="bold"><mml:mtext>x</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>⊤</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula>. The solution is given by replacing <bold>X</bold> by Φ(<bold>X</bold>) in Equation (11),</p>
        <disp-formula id="E15">
          <label>(12)</label>
          <mml:math id="M40">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mtable style="text-align:axis;" equalrows="false" columnlines="none" equalcolumns="false" class="array">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mstyle mathvariant="bold">
                              <mml:mtext>w</mml:mtext>
                            </mml:mstyle>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>ϕ</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mrow>
                                <mml:mo>Φ</mml:mo>
                                <mml:msup>
                                  <mml:mrow>
                                    <mml:mrow>
                                      <mml:mo stretchy="false">(</mml:mo>
                                      <mml:mrow>
                                        <mml:mstyle mathvariant="bold">
                                          <mml:mtext>X</mml:mtext>
                                        </mml:mstyle>
                                      </mml:mrow>
                                      <mml:mo stretchy="false">)</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mo>⊤</mml:mo>
                                  </mml:mrow>
                                </mml:msup>
                                <mml:mo>Φ</mml:mo>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mrow>
                                    <mml:mstyle mathvariant="bold">
                                      <mml:mtext>X</mml:mtext>
                                    </mml:mstyle>
                                  </mml:mrow>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                                <mml:mo>+</mml:mo>
                                <mml:mo>λ</mml:mo>
                                <mml:mstyle mathvariant="bold">
                                  <mml:mtext>I</mml:mtext>
                                </mml:mstyle>
                              </mml:mrow>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>-</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mo>Φ</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mrow>
                                <mml:mstyle mathvariant="bold">
                                  <mml:mtext>X</mml:mtext>
                                </mml:mstyle>
                              </mml:mrow>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>⊤</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mstyle mathvariant="bold">
                          <mml:mtext>y</mml:mtext>
                        </mml:mstyle>
                        <mml:mtext> </mml:mtext>
                        <mml:mtext class="textrm" mathvariant="normal">(primal solution)</mml:mtext>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mtext>   </mml:mtext>
                        <mml:mo>=</mml:mo>
                        <mml:mo>Φ</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mrow>
                                <mml:mstyle mathvariant="bold">
                                  <mml:mtext>X</mml:mtext>
                                </mml:mstyle>
                              </mml:mrow>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>⊤</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mrow>
                                <mml:mo>Φ</mml:mo>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mrow>
                                    <mml:mstyle mathvariant="bold">
                                      <mml:mtext>X</mml:mtext>
                                    </mml:mstyle>
                                  </mml:mrow>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                                <mml:mo>Φ</mml:mo>
                                <mml:msup>
                                  <mml:mrow>
                                    <mml:mrow>
                                      <mml:mo stretchy="false">(</mml:mo>
                                      <mml:mrow>
                                        <mml:mstyle mathvariant="bold">
                                          <mml:mtext>X</mml:mtext>
                                        </mml:mstyle>
                                      </mml:mrow>
                                      <mml:mo stretchy="false">)</mml:mo>
                                    </mml:mrow>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mo>⊤</mml:mo>
                                  </mml:mrow>
                                </mml:msup>
                                <mml:mo>+</mml:mo>
                                <mml:mo>λ</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mstyle mathvariant="bold">
                                      <mml:mtext>I</mml:mtext>
                                    </mml:mstyle>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mi>n</mml:mi>
                                  </mml:mrow>
                                </mml:msub>
                              </mml:mrow>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>-</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mstyle mathvariant="bold">
                          <mml:mtext>y</mml:mtext>
                        </mml:mstyle>
                        <mml:mtext> </mml:mtext>
                        <mml:mtext class="textrm" mathvariant="normal">(dual solution)</mml:mtext>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>Unfortunately, this solution is of limited practical use, since generally speaking the feature space is too high-dimensional to represent <bold>w</bold><sub>ϕ</sub> and Φ(<bold>X</bold>). However, the dual solution can be rewritten as follows. Let <bold>K</bold> = Φ(<bold>X</bold>)Φ(<bold>X</bold>)<sup>⊤</sup> be the kernel matrix with <bold>K</bold><sub><italic>ij</italic></sub> = <italic>k</italic>(<bold>x</bold><sub><italic>i</italic></sub>, <bold>x</bold><sub><italic>j</italic></sub>) for a kernel function <italic>k</italic>. Define the vector of dual weights <bold><italic>α</italic></bold> as</p>
        <disp-formula id="E16">
          <label>(13)</label>
          <mml:math id="M41">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mtable style="text-align:axis;" equalrows="false" columnlines="none" equalcolumns="false" class="array">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mstyle mathvariant="bold-italic">
                          <mml:mi>α</mml:mi>
                        </mml:mstyle>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mrow>
                                <mml:mstyle mathvariant="bold">
                                  <mml:mtext>K</mml:mtext>
                                </mml:mstyle>
                                <mml:mo>+</mml:mo>
                                <mml:mo>λ</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>I</mml:mi>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mi>n</mml:mi>
                                  </mml:mrow>
                                </mml:msub>
                              </mml:mrow>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>-</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mtext> </mml:mtext>
                        <mml:mstyle mathvariant="bold">
                          <mml:mtext>y</mml:mtext>
                        </mml:mstyle>
                        <mml:mo>.</mml:mo>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>Then the predicted response to a test sample <bold>x</bold> can be rewritten in terms of kernel evaluations:</p>
        <disp-formula id="E17">
          <label>(14)</label>
          <mml:math id="M42">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mtable style="text-align:axis;" equalrows="false" columnlines="none" equalcolumns="false" class="array">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mi>f</mml:mi>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mrow>
                            <mml:mstyle mathvariant="bold">
                              <mml:mtext>x</mml:mtext>
                            </mml:mstyle>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mo>=</mml:mo>
                        <mml:msubsup>
                          <mml:mrow>
                            <mml:mstyle mathvariant="bold">
                              <mml:mtext>w</mml:mtext>
                            </mml:mstyle>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>ϕ</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>⊤</mml:mo>
                          </mml:mrow>
                        </mml:msubsup>
                        <mml:mi>ϕ</mml:mi>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mrow>
                            <mml:mstyle mathvariant="bold">
                              <mml:mtext>x</mml:mtext>
                            </mml:mstyle>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mo>=</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mstyle mathvariant="bold-italic">
                              <mml:mi>α</mml:mi>
                            </mml:mstyle>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>⊤</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>Φ</mml:mo>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mrow>
                            <mml:mstyle mathvariant="bold">
                              <mml:mtext>X</mml:mtext>
                            </mml:mstyle>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mi>ϕ</mml:mi>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mrow>
                            <mml:mstyle mathvariant="bold">
                              <mml:mtext>x</mml:mtext>
                            </mml:mstyle>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mo>=</mml:mo>
                        <mml:mstyle displaystyle="true">
                          <mml:munderover accentunder="false" accent="false">
                            <mml:mrow>
                              <mml:mo>∑</mml:mo>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>i</mml:mi>
                              <mml:mo>=</mml:mo>
                              <mml:mn>1</mml:mn>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>n</mml:mi>
                            </mml:mrow>
                          </mml:munderover>
                        </mml:mstyle>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>α</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mi>k</mml:mi>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mstyle mathvariant="bold">
                                  <mml:mtext>x</mml:mtext>
                                </mml:mstyle>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>i</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo>,</mml:mo>
                            <mml:mstyle mathvariant="bold">
                              <mml:mtext>x</mml:mtext>
                            </mml:mstyle>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mo>.</mml:mo>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
      </sec>
    </sec>
    <sec>
      <title>2.6. Performance Metrics</title>
      <p>In most cases, the quantity of interest is not the raw model output but rather a metric that summarizes the performance of the classifier or regression model on test data. The desired metric can be specified by e.g., setting <monospace>cfg.metric = 'accuracy'</monospace> in any high-level function. Multiple metrics can be requested by providing a cell array, e.g., <monospace>cfg.metric</monospace> = <monospace>{'accuracy,' 'auc'}</monospace>. <xref rid="T1" ref-type="table">Table 1</xref> lists the metrics implemented in MVPA-Light. For a thorough discussion of classification metrics, refer to Sokolova and Lapalme (<xref rid="B45" ref-type="bibr">2009</xref>).</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p>Metrics in MVPA-Light.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Task</bold>
              </th>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Metric</bold>
              </th>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Range</bold>
              </th>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Description</bold>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">Classification</td>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'accuracy'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">[0,1]</td>
              <td valign="top" align="left" rowspan="1" colspan="1">Fraction correctly predicted class labels.</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'auc'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">[0,1]</td>
              <td valign="top" align="left" rowspan="1" colspan="1">For two classes only. An alternative to classification accuracy that is more robust to imbalanced classes. Requires continuous classifier output (decision values or probabilities). 0.5 means chance-level performance and 1 means perfect separation of the classes.</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'confusion'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">[0,1]</td>
              <td valign="top" align="left" rowspan="1" colspan="1">Confusion matrix. Rows corresponds to true class, columns to predicted class. The (<italic>i, j</italic>)-th element gives the proportion of samples of class i that have been classified as class j.</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'dval'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">(−∞, +∞)</td>
              <td valign="top" align="left" rowspan="1" colspan="1">For two classes only. Average decision value, for each class separately.</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'f1'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">[0,1]</td>
              <td valign="top" align="left" rowspan="1" colspan="1">Combines precision (PR) and recall (R) into a single score using the harmonic average 2*PR*R / (PR+R).</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'kappa'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">[-1, 1]</td>
              <td valign="top" align="left" rowspan="1" colspan="1">Cohen's kappa, a measure of inter-rater reliability.</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'precision'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">[0,1]</td>
              <td valign="top" align="left" rowspan="1" colspan="1">TP / (TP + FP). Fraction of samples labeled as positive that actually belong to the positive class. For multi-class, it is calculated per class from the confusion matrix.</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'recall'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">[0,1]</td>
              <td valign="top" align="left" rowspan="1" colspan="1">TP / (TP + FN). Fraction of positive samples that have been detected. For multi-class, it is calculated per class from the confusion matrix.</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'tval'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">(−∞, +∞)</td>
              <td valign="top" align="left" rowspan="1" colspan="1">For two classes only. T-test statistic for the unequal sample size, equal variance case, based on decision values.</td>
            </tr>
            <tr style="border-bottom: thin solid #000000;">
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'none'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">(−∞, +∞)</td>
              <td valign="top" align="left" rowspan="1" colspan="1">Returns a cell array with the raw classifier outputs for all test sets.</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">Regression</td>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'mae'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">[0, ∞)</td>
              <td valign="top" align="left" rowspan="1" colspan="1">Mean absolute error: <inline-formula><mml:math id="M43"><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:munderover accentunder="false" accent="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>ŷ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:math></inline-formula>.</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'mse'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">[0, ∞)</td>
              <td valign="top" align="left" rowspan="1" colspan="1">Mean squared error: <inline-formula><mml:math id="M44"><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:munderover accentunder="false" accent="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>-</mml:mo><mml:msub><mml:mrow><mml:mi>ŷ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula>.</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <monospace>'r_squared'</monospace>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">(−∞, 1]</td>
              <td valign="top" align="left" rowspan="1" colspan="1"><italic>R</italic><sup>2</sup> coefficient representing the fraction of variance explained by the model.</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p><italic>TP, true positives; FP, false positives; FN, false negatives. Regression: y = responses, ŷ = model predictions</italic>.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>If cross-validation is used then the metric is initially calculated for each test set in each repetition separately. It is then averaged across test sets and repetitions. Since the number of samples in a test set can vary across different folds, a proportionally weighted average is used whereby larger test sets get a larger weight.</p>
    </sec>
    <sec>
      <title>2.7. Statistical Analysis</title>
      <p>In neuroimaging experiments, establishing the statistical significance of a metric is often more important than maximizing the metric <italic>per se</italic>. Neuroimaging data is typically hierarchical: a study comprises many subjects, and each subject comprises many trials. To perform group analysis, a common approach is then to start with a level 1 (single-subject) analysis and calculate a classification or regression metric. At this stage, the samples consist of single trials for a particular subject. The metrics are then taken on to level 2 (group level). At this stage, each subject constitutes one sample (Mumford and Poldrack, <xref rid="B35" ref-type="bibr">2007</xref>). The function <monospace>mv_statistics</monospace> implements both level 1 (single-subject) and level 2 (group level) statistical analysis. For level 1 analysis, the following tests are available:</p>
      <list list-type="bullet">
        <list-item>
          <p>Binomial test: uses a binomial distribution to calculate the p-value under the null hypothesis that classification accuracy is at chance. Requires classification accuracy as metric.</p>
        </list-item>
        <list-item>
          <p>Permutation test: non-parametric significance test. Creates a null distribution by shuffling the class labels or responses and repeating the multivariate analysis e.g., 1,000 times.</p>
        </list-item>
        <list-item>
          <p>Cluster permutation test: an elegant solution to the multiple comparisons problems arising when MVPA is performed along multiple dimensions (e.g., for each time-frequency point). Uses the cluster statistic introduced in Maris and Oostenveld (<xref rid="B32" ref-type="bibr">2007</xref>).</p>
        </list-item>
      </list>
      <p>For level 2 analysis, a permutation test (with and without cluster correction) is available for within-subject and between-subjects designs. Note that no classification/regression is performed. The metrics that have been obtained in the level 1 analysis for each subject are simply subjected to a standard statistical test. In the <italic>within-subject</italic> design, two different cases are considered. If pairs of values have been observed (e.g., mean decision values for class 1 and 2) they are tested for a significant difference across subjects. If only one value has been observed (e.g., AUC) it is tested against a given null value (e.g., 0.5). As test statistics, mean, <italic>t</italic>-test, or Wilcoxon signed-rank test can be used. To create a null distribution, data is permuted by randomly swapping the pairs of values or swapping the value and its null value. In <italic>between-subjects</italic> design, subjects are partitioned into two different groups. The test statistic quantifies whether the metric differs between two groups. A null distribution is created by randomly assigning subjects to groups.</p>
      <p>To illustrate this with an example, consider the “faces vs. houses” experiment. For the within-subject design, assume the mean decision values for houses and faces have been determined for each subject using cross-validation. A paired-samples <italic>t</italic>-test across subjects comparing the decision value for faces vs houses is used to calculate a <italic>t</italic>-statistic. A null distribution is created by randomly swapping face and house values for each subject and recomputing the statistic. For a between-subjects design, assume the experiment has also been carried out with a clinical group of Parkinson's patients and AUC values have been recorded for both groups. A Wilcoxon rank sum test is used to compare the AUC for the two groups at each voxel. A null distribution is created by randomly assigning subjects to either the clinical or the control group.</p>
    </sec>
    <sec>
      <title>2.8. Custom Classifiers and Regression Models</title>
      <p>MVPA-Light can be extended with custom models. To this end, the appropriate train and test functions need to be implemented. Additionally, default hyperparameters need to be added to the function <monospace>mv_get_hyperparameter</monospace>. In the appendix, it is shown how to implement a prototype classifier that assigns a sample to the closest class centroid.</p>
    </sec>
    <sec>
      <title>2.9. LIBSVM and LIBLINEAR</title>
      <p>LIBSVM (Chang et al., <xref rid="B8" ref-type="bibr">2011</xref>) and LIBLINEAR (Fan et al., <xref rid="B14" ref-type="bibr">2008</xref>) are two high-performance libraries for SVM, Support Vector Regression (SVR), and Logistic Regression. In order to use the libraries with MVPA-Light, the user needs to follow the installation instructions on the respective websites. In particular, the C-code needs to be compiled and added to the MATLAB path. In MVPA-Light, the models are denoted as <monospace>'libsvm'</monospace> and <monospace>'liblinear.'</monospace></p>
    </sec>
    <sec>
      <title>2.10. FieldTrip Integration</title>
      <p>The FieldTrip (Oostenveld et al., <xref rid="B38" ref-type="bibr">2011</xref>) function <monospace>ft_statistics_mvpa</monospace> provides a direct interface between FieldTrip and MVPA-Light. In brief, the function calls MVPA-Light functions to carry out multivariate analysis, and then stores the results back into FieldTrip structs. To use MVPA-Light from high-level FieldTrip functions such as <monospace>ft_timelockstatistics</monospace>, one has to set the parameter <monospace>cfg.method</monospace> = <monospace>'mvpa.'</monospace> The interface is introduced in detail in a tutorial on the FieldTrip website <xref ref-type="fn" rid="fn0001"><sup>1</sup></xref>.</p>
    </sec>
    <sec>
      <title>2.11. Development</title>
      <p>To maintain the integrity of the toolbox, the <monospace>unittests/</monospace> subfolder features a unit testing framework for all models, optimization algorithms, high-level functions and some of the important utility functions. The unit tests make use of both the example EEG data, random noise, and simulated data. Unit testing can be triggered by executing the <monospace>run_all_unittests</monospace> function.</p>
    </sec>
    <sec>
      <title>2.12. Analysis of a MEEG Dataset</title>
      <p>To illustrate MVPA-Light on a real dataset, a multivariate analysis was conducted on a multi-subject, multi-modal face processing dataset wherein subjects viewed images of famous faces, familiar faces, or scrambled faces. See Wakeman and Henson (<xref rid="B51" ref-type="bibr">2014</xref>, <xref rid="B52" ref-type="bibr">2015</xref>) for a detailed description of the data. The dataset contains 16 subjects with EEG and MEG simultaneously recorded. The MEEG data was preprocessed using FieldTrip. It was low-pass filtered with a cut-off of 100 Hz and high-pass filtered using a FIR one-pass zero-phase filter with a cut-off of 0.1 Hz. A bandstop filter was applied at 50 Hz to suppress line noise. Subsequently, data was downsampled to 220 Hz and for each subject, the 6 separate runs were combined into a single dataset, yielding 880–889 trials per subject with roughly equal proportions for the three classes. All trials displaying famous faces were coded as class 1, familiar faces as class 2, and scrambled faces as class 3. MVPA was performed to investigate the following questions:</p>
      <list list-type="order">
        <list-item>
          <p>ERP classification: Wakeman and Henson (<xref rid="B52" ref-type="bibr">2015</xref>) found two prominent event-related components, a N170 and a sustained component roughly starting at 400 ms post-stimulus. Cross-validation with a multi-class classifier was used to investigate whether these components discriminate between the three classes.</p>
        </list-item>
        <list-item>
          <p>Time classification: Is there more discriminative information in MEG than in EEG? To answer this, classification across time was performed for three different channel sets, namely EEG only, MEG only, and EEG+MEG combined.</p>
        </list-item>
        <list-item>
          <p>Time-frequency classification: Is the discriminative information for famous vs scrambled faces confined to specific oscillatory frequencies and times? To answer this, time-frequency spectra were calculated for single trials and classification was performed at each time-frequency bin separately.</p>
        </list-item>
        <list-item>
          <p>Generalization: Are representations shared across time (King and Dehaene, <xref rid="B26" ref-type="bibr">2014</xref>) or frequency? To answer this, time generalization (time x time classification) was applied to the ERF data, and frequency generalization (frequency x frequency classification) was applied to the time-frequency data.</p>
        </list-item>
      </list>
      <p>MVPA was performed at the sensor level using a LDA classifier. All analyses were cross-validated using 5- or 10-fold cross-validation. Only the MEG channels were used as features except for analysis 2, where different sets of channels were compared. To assess statistical significance, the following tests were carried out:</p>
      <list list-type="bullet">
        <list-item>
          <p>Level 1 statistics. For each subject, the statistical significance of the time generalization (famous vs. scrambled faces) was investigated. For illustrative purposes, the three statistical tests contained in MVPA-Light were compared: binomial, permutation, and cluster permutation tests. Permutation tests were based on 500 random permutations of the class labels. The cluster permutation test was corrected for multiple comparisons by using a cluster statistic, the other tests were uncorrected. For the cluster statistic, a critical value of 0.6 was chosen for classification accuracy. This analysis is reported only for the first subject.</p>
        </list-item>
        <list-item>
          <p>Level 2 statistics (across subjects). The AUC values obtained in the time-frequency classification analyses were statistically compared to a null value of 0.5 using cluster permutation tests based on a within-subject design.</p>
        </list-item>
      </list>
    </sec>
    <sec>
      <title>2.13. Analysis of a fMRI Dataset</title>
      <p>To illustrate the application of MVPA-Light to fMRI data, another analysis was conducted using a block-design fMRI study. See Haxby et al. (<xref rid="B21" ref-type="bibr">2001</xref>) for a detailed description. The dataset was downloaded from <ext-link ext-link-type="uri" xlink:href="http://www.pymvpa.org/datadb/haxby2001.html"><monospace>http://www.pymvpa.org/datadb/haxby2001.html</monospace></ext-link>. The study investigates face and object representations in human ventral temporal cortex. It comprises 6 subjects with 12 runs per subject. In each run, subjects viewed grayscale images of 8 living and non-living object categories, grouped in 24 s blocks separated by rest periods. Images were shown for 500 ms followed by a 1,500 ms inter-stimulus interval. Full-brain fMRI data were recorded with a volume repetition time of 2.5 s. Hence, a stimulus block was covered by roughly 9 volumes. A zero-phase Butterworth high-pass filter with a cut-off frequency of 0.01 Hz was applied in order to remove slow drifts. No other preprocessing was performed. The following questions were addressed:</p>
      <list list-type="order">
        <list-item>
          <p>Confusion matrix: Which image categories lead to similar brain activation patterns?</p>
        </list-item>
        <list-item>
          <p>Time classification: How does classification performance evolve across time following stimulus onset?</p>
        </list-item>
        <list-item>
          <p>Searchlight analysis: Which of the brain regions contain discriminative information that discerns between faces and houses?</p>
        </list-item>
      </list>
      <p>Leave-one-run-out cross-validation was used to calculate classification performance. Multi-class LDA with 8 classes served as a classifier. For the searchlight analysis, binary LDA contrasting faces vs. houses was used with AUC serving as metric. The searchlight consisted of a 3x3x3 cube of voxels that was centered on each target voxel. A level 2 cluster permutation test was computed on the AUC values against the null hypothesis that AUC equals 0.5.</p>
    </sec>
    <sec>
      <title>2.14. Benchmarking</title>
      <p>Multivariate analyses can involve hundreds or even thousands of train/test iterations. Therefore, training time (the amount of time required to train a single model on data) is a relevant quantity when evaluating different model implementations. To benchmark MVPA-Light's models, their training time was compared to models in the MATLAB Statistics Toolbox as well as models in Python (Scikit Learn package) and R (different packages). The comparison to other MVPA toolboxes is of less relevance since they often rely on external packages such as LIBSVM and LIBLINEAR which are also available in MVPA-Light (this applies to e.g., DDTBOX, PRoNTo, TDT). The following three datasets were considered:</p>
      <list list-type="bullet">
        <list-item>
          <p>MEG single-subjects. The Wakeman and Henson (<xref rid="B52" ref-type="bibr">2015</xref>) dataset was used with the famous vs. scrambled faces conditions, epoched in the range [–0.2, 1] s. Data dimensions were 585–592 trials per subject, 306 channels, and 265 time points. MVPA was performed for every subject and every time point separately, using channels as features.</p>
        </list-item>
        <list-item>
          <p>MEG super-subject. Trials of all subjects in the MEG single-subjects data were concatenated to form a single “super-subject” comprising 9,421 trials, 306 channels, and 265 time points. MVPA was performed for every time point separately, using channels as features.</p>
        </list-item>
        <list-item>
          <p>fMRI. For each subject in the Haxby et al. (<xref rid="B21" ref-type="bibr">2001</xref>) data, all voxels with a non-zero signal were concatenated to a single feature vector. The time dimension was dropped, different time points within a trial were simply considered as different samples. The two classes “face” and “house” were considered, yielding a data matrix of 216 samples (198 samples for subject 5) and between 163,665 and 163,839 voxels per subject. MVPA was performed for every subject separately, using voxels as features.</p>
        </list-item>
      </list>
      <p>The MEG single-subjects dataset is of standard size for neuroimaging data and thus serves as a benchmark for ordinary operation. The other two datasets are intended to test the computational limits of the models by using either a large number of trials (MEG super-subject) or a large number of features (fMRI). For the single-subjects dataset, classification performance was measured in addition to training time. To be as unbiased as possible, hyperparameters were mostly unchanged except when a change made the models more comparable across toolboxes (e.g., setting the same regularization value). No hyperparameter tuning was performed in order to quantify pure training time.</p>
      <p>The MVPA-Light models were compared to LIBSVM, LIBLINEAR, and MATLAB 2019a's fitcdiscr (LDA), lassoglm (LogReg), fitcnb (Naive Bayes), fitcsvm (SVM), ridge, and fitrsvm (SVR). Python and R-based toolboxes were installed in virtual environments using Anaconda 4.7.12. Scikit Learn 0.21.2 was used together with Python 3.7.3. R version 3.6.1 was used with packages MASS (LDA), glmnet (LogReg and Ridge), e1071 (Naive Bayes, SVM, SVR), and listdtr (Kernel Ridge).</p>
      <p>For the single-subject data, the timing results were averaged across subjects. Then for both the single-subject and the super-subject, mean and standard deviation was calculated across time points. For the fMRI data, mean and standard deviation was calculated across subjects. All analyses were conducted after a fresh restart of a desktop computer with networking disabled. The computer had an Intel Core i7-6700 @ 3.40 GHz x 8 CPU with 64 GB RAM running on Ubuntu 18.04. All scripts are available in the accompanying GitHub repository<xref ref-type="fn" rid="fn0002"><sup>2</sup></xref>.</p>
    </sec>
    <sec>
      <title>2.15. Results</title>
      <sec>
        <title>2.15.1. MEEG Data</title>
        <p><xref ref-type="fig" rid="F3">Figure 3</xref> depicts the results of the MVPA, averaged across subjects. Errorbars depict standard error across subjects.</p>
        <fig id="F3" position="float">
          <label>Figure 3</label>
          <caption>
            <p>Results for the classification analysis of the Wakeman and Henson (<xref rid="B52" ref-type="bibr">2015</xref>) MEEG data. <bold>(A)</bold> Multi-class classification (famous vs. unfamiliar vs. scrambled faces) of N170 and sustained ERP component. <bold>(B)</bold> AUC is plotted as a function of time for famous vs. scrambled images. The classification was performed using three different channel sets: EEG only, MEG only, and EEG+MEG combined. <bold>(C)</bold> Binary classification (famous vs. scrambled and famous vs unfamiliar) for time-frequency data. AUC is plotted as a function of both time and frequency. The AUC values are color-coded. <bold>(D)</bold> Time x time generalization and frequency x frequency generalization using a binary classifier (famous vs. scrambled). <bold>(E)</bold> Level 2 statistical analysis of the time-frequency classification. <bold>(F)</bold> Level 1 statistical analysis of the time x time generalization, shown exemplarily for subject 1.</p>
          </caption>
          <graphic xlink:href="fnins-14-00289-g0003"/>
        </fig>
        <p><italic>ERP classification</italic> (<xref ref-type="fig" rid="F3">Figure 3A</xref>). The bar graph shows that for both the N170 and the sustained ERP component classification accuracy is significantly above the chance level of 33%. Accuracy can be broken down into confusion matrices that show which combinations of classes get misclassified (“confused”). For both N170 and the sustained ERP component, the highest accuracy is obtained for the scrambled images (0.63 and 0.78). Moreover, misclassification (off-diagonal elements) is most prominent for the famous and unfamiliar faces. This is not surprising since both types of images are identical in terms of low-level features and both show actual faces, in contrast to the scrambled images.</p>
        <p><italic>Time classification</italic> (<xref ref-type="fig" rid="F3">Figure 3B</xref>). The classes are not discriminable prior to the occurrence of the N170. A classification peak at the time of the N170 can be seen for all channel sets. At this stage, the AUC values diverge, with EEG yielding a significantly lower AUC. Combining EEG+MEG seems to yield a slightly higher performance than MEG alone.</p>
        <p><italic>Time-frequency classification</italic> (<xref ref-type="fig" rid="F3">Figure 3C</xref>). For famous vs scrambled faces, peak performance is reached in the delta frequency band at a latency between 0.2 and 0.4 s. For famous vs unfamiliar faces, peak performance is attained in the latter half of the trial (0.5–1 s) in the theta and alpha frequency bands.</p>
        <p><italic>Generalization</italic> (<xref ref-type="fig" rid="F3">Figure 3D</xref>). The first plot depicts AUC (color-coded) as a function of training time (y-axis) and testing time (x-axis). There is evidence for widespread time generalization for famous vs scrambled faces starting about at the time of the N170 peak and covering most of the remaining trial. In particular, there is generalization between the N170 and the later sustained component (horizontal and vertical lines emanating at 0.17 s), suggesting some correlation between the spatial pattern of the N170 and the sustained component. The second plot depicts AUC as a function of frequency. There is some generalization in the theta band (lower-left corner), the alpha band, and the lower beta band (16–22 Hz). Also, when the classifier is trained in the beta band, classification performance partially generalizes to the alpha band. However, the overall performance is low when compared to the time-locked data.</p>
        <p><italic>Level 2 statistics</italic> (<xref ref-type="fig" rid="F3">Figure 3E</xref>). Group statistical analysis based on the time-frequency classification data in the panel above. Images depict AUC values masked by significance (deep blue = not significant). For the famous vs. scrambled faces classification, a large cluster spanning the whole trial and especially the low frequency bands is evident. For the famous vs. unfamiliar faces condition, there is a significant cluster corresponding to large AUC values evident after 0.5 s and confined to the lower frequency range.</p>
        <p><italic>Level 1 statistics</italic> (<xref ref-type="fig" rid="F3">Figure 3F</xref>). Level 1 statistical analysis based on the time generalization data in the panel above, shown exemplarily for subject 1. Images depict the AUC values masked by significance. Both uncorrected tests (binomial and permutation test) exhibit spurious effects even at pre-stimulus time. Most of these spurious effects disappear under the cluster permutation test.</p>
      </sec>
      <sec>
        <title>2.15.2. fMRI Data</title>
        <p><xref ref-type="fig" rid="F4">Figure 4</xref> depicts the results of the MVPA on the fMRI data, averaged across subjects.</p>
        <fig id="F4" position="float">
          <label>Figure 4</label>
          <caption>
            <p>Results for the classification analysis of the Haxby et al. (<xref rid="B21" ref-type="bibr">2001</xref>) fMRI data. <bold>(A)</bold> Confusion matrix for multi-class (8 classes) classification based on voxels in the ventral temporal area, averaged across subjects. <bold>(B)</bold> Multi-class (8 classes) classification accuracy was calculated for each time point following stimulus onset. Lines depict means across subjects, shaded areas correspond to standard error. Masks were used to select voxels in the ventral temporal area (yellow line), voxels responsive to faces (blue), or voxels responsive to houses (red). <bold>(C)</bold> Cluster permutation test results based on a searchlight analysis using a binary classifier (faces vs houses). Red spots represent AUC values superimposed on axial slices of the averaged structural MRI. All depicted AUC values correspond to the significant cluster; other AUC values have been masked out.</p>
          </caption>
          <graphic xlink:href="fnins-14-00289-g0004"/>
        </fig>
        <p><italic>Confusion matrix</italic> (<xref ref-type="fig" rid="F4">Figure 4A</xref>). A mask provided with the data was applied to select voxels from ventral temporal areas. A high overall performance is observed for LDA with 8 classes. Misclassifications tend to be confined to general semantic categories. For instance, misclassified faces tend to be labeled as cats (both living objects), whereas misclassified non-living objects tend to be labeled as other non-living objects. This indicates that there are shared representations for images from the same general category.</p>
        <p><italic>Time classification</italic> (<xref ref-type="fig" rid="F4">Figure 4B</xref>). Although all ROIs and time points yield performances above the chance level of 12.5%, the ventral temporal area (which comprises both face and house responsive voxels) yields the best performance. For the latter, classification performance peaks at about 5 s after stimulus onset.</p>
        <p><italic>Searchlight analysis</italic> (<xref ref-type="fig" rid="F4">Figure 4C</xref>). AUC values averaged across subjects are depicted. The AUCs are masked by the significant cluster (<italic>p</italic> &lt; 0.01) and overlayed on an averaged anatomical MRI. Although the cluster is large, high values &gt;0.8 are predominantly found in dorsal and ventral visual areas including the paraphippocampal place area and the fusiform area, nicely dovetailing with the original findings of Haxby et al. (<xref rid="B21" ref-type="bibr">2001</xref>).</p>
      </sec>
      <sec>
        <title>2.15.3. Benchmarking</title>
        <p><xref ref-type="fig" rid="F5">Figure 5</xref> depicts ERP classification accuracy across time on the MEG single-subjects data for different classifiers and different toolboxes, averaged across subjects. Except for the MATLAB classifiers, results are nearly identical for all implementations of LDA, LogReg, and linear SVM, with a peak performance of about 75%. Lower performance is evident for Naive Bayes, but consistently so across different implementations. For SVM with a RBF kernel, the best performance is obtained in R, followed MATLAB, with both MVPA-Light and Scikit Learn performing worse. Since no hyperparameter tuning was performed, the latter result is most likely due to differences in the default hyperparameters.</p>
        <fig id="F5" position="float">
          <label>Figure 5</label>
          <caption>
            <p>Mean ERP classification accuracy for the benchmarking analysis using the MEG single-subjects data (averaged across subjects). MVPA-Light is depicted as a solid black line.</p>
          </caption>
          <graphic xlink:href="fnins-14-00289-g0005"/>
        </fig>
        <p><xref rid="T2" ref-type="table">Tables 2</xref>, <xref rid="T3" ref-type="table">3</xref> show the timing results for different classifiers and regression models. These results are discussed model by model:</p>
        <table-wrap id="T2" position="float">
          <label>Table 2</label>
          <caption>
            <p>Benchmarking results: mean training time and standard deviation in seconds for different classifiers.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th valign="top" align="left" rowspan="1" colspan="1">
                  <bold>Dataset</bold>
                </th>
                <th valign="top" align="left" rowspan="1" colspan="1">
                  <bold>Toolbox</bold>
                </th>
                <th valign="top" align="center" colspan="5" style="border-bottom: thin solid #000000;" rowspan="1">
                  <bold>Classifier</bold>
                </th>
              </tr>
              <tr>
                <th valign="top" align="left" colspan="2" rowspan="1"/>
                <th valign="top" align="left" rowspan="1" colspan="1">
                  <bold>LDA</bold>
                </th>
                <th valign="top" align="center" rowspan="1" colspan="1">
                  <bold>LogReg</bold>
                </th>
                <th valign="top" align="center" rowspan="1" colspan="1">
                  <bold>Naive Bayes</bold>
                </th>
                <th valign="top" align="center" rowspan="1" colspan="1">
                  <bold>SVM (linear)</bold>
                </th>
                <th valign="top" align="center" rowspan="1" colspan="1">
                  <bold>SVM (RBF)</bold>
                </th>
              </tr>
            </thead>
            <tbody>
              <tr style="border-bottom: thin solid #000000;">
                <td valign="top" align="left" rowspan="1" colspan="1">MEG single-subjects</td>
                <td valign="top" align="left" rowspan="1" colspan="1">MVPA-Light</td>
                <td valign="top" align="center" rowspan="1" colspan="1"><bold>0.003</bold> ± 0.0001</td>
                <td valign="top" align="center" rowspan="1" colspan="1"><bold>0.0097</bold> ± 0.0005</td>
                <td valign="top" align="center" rowspan="1" colspan="1"><bold>0.001</bold> ± 0.00004</td>
                <td valign="top" align="center" rowspan="1" colspan="1">0.07 ± 0.002</td>
                <td valign="top" align="center" rowspan="1" colspan="1"><bold>0.02</bold> ± 0.0001</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">LIBLINEAR</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.014 ± 0.0009(<italic>p</italic>)<break/> 0.035 ± 0.001(<italic>d</italic>)</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.023</bold> ± 0.002(<italic>p</italic>)<break/> 0.231 ± 0.02(<italic>d</italic>)</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">LIBSVM</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.098 ± 0.01</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.125 ± 0.001</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MATLAB</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.026 ± 0.0008</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.03 ± 0.006</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.05 ± 0.0001</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.041 ± 0.004</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.023 ± 0.0004</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">Scikit Learn</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.097 ± 0.0006</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.1 ± 0.005</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.007 ± 0.0001</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.37 ± 0.052</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.45 ± 0.032</td>
              </tr>
              <tr style="border-bottom: thin solid #000000;">
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" rowspan="1" colspan="1">R</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.084 ± 0.0003</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.013 ± 0.002</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.04 ± 0.0001</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.71 ± 0.113</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.41 ± 0.026</td>
              </tr>
              <tr>
                <td valign="top" align="left" rowspan="1" colspan="1">MEG super-subject</td>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MVPA-Light</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.026</bold> ± 0.0028</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.437 ± 0.0062</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.015</bold> ± 0.0001</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">10.122 ± 1.05</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>5.369</bold> ± 0.033</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">LIBLINEAR</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.732 ± 0.068(<italic>p</italic>)<break/> 0.998 ± 0.063(<italic>d</italic>)</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>1.338</bold> ± 0.168(<italic>p</italic>)<break/> 6.29 ± 0.519(<italic>d</italic>)</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">LIBSVM</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">42.089 ± 4.188</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">37.941 ± 0.404</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MATLAB</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.149 ± 0.002</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.279 ± 0.137</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.231 ± 0.027</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">20.98 ± 1.78</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">11.65 ± 0.217</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">Scikit Learn</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.596 ± 0.017</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">2.065 ± 0.109</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.09 ± 0.001</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">32.19 ± 2.07</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">34.56 ± 0.38</td>
              </tr>
              <tr style="border-bottom: thin solid #000000;">
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" rowspan="1" colspan="1">R</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.84 ± .004</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.159</bold> ± 0.018</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.144 ± .0006</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">1123.16 ± 27.39</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">123.31 ± 9.38</td>
              </tr>
              <tr>
                <td valign="top" align="left" rowspan="1" colspan="1">fMRI</td>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MVPA-Light</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.293</bold> ± 0.0078</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">OOM</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.309</bold> ± 0.011</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.182</bold> ± 0.0086</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>2.064</bold> ± 0.235</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">LIBLINEAR</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>4.008</bold> ± 0.627(<italic>p</italic>)<break/> 6.689 ± 1.018(<italic>d</italic>)</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">-</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">2.235 ± 0.218(<italic>p</italic>)<break/> 6.125 ± 0.995(<italic>d</italic>)</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">-</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">LIBSVM</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">11.79 ± 0.787</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">11.88 ± 0.822</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MATLAB</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">OOM</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">23.79 ± 4.008</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">357.49 ± 2.205</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">5.053 ± 0.325</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">4.845 ± 0.308</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">Scikit Learn</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">24.45 ± 1.1</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">20.68 ± 4.24</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">2.86 ± 0.06</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">10.46 ± 0.59</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">9.15 ± 0.59</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">R</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">OOM</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">7.1 ± 1.13</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">18.48 ± 0.35</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">39.67 ± 1.98</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">43.3 ± 2.18</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p><italic>For each combination of dataset and classifier, the fastest model is marked in bold. OOM, out of memory error; (p), primal form; (d), dual form</italic>.</p>
          </table-wrap-foot>
        </table-wrap>
        <table-wrap id="T3" position="float">
          <label>Table 3</label>
          <caption>
            <p>Benchmarking results: mean training time and standard deviation in seconds for different regression models.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th valign="top" align="left" rowspan="1" colspan="1">
                  <bold>Dataset</bold>
                </th>
                <th valign="top" align="left" rowspan="1" colspan="1">
                  <bold>Toolbox</bold>
                </th>
                <th valign="top" align="center" colspan="4" style="border-bottom: thin solid #000000;" rowspan="1">
                  <bold>Regression model</bold>
                </th>
              </tr>
              <tr>
                <th valign="top" align="left" colspan="2" rowspan="1"/>
                <th valign="top" align="left" rowspan="1" colspan="1">
                  <bold>Ridge</bold>
                </th>
                <th valign="top" align="center" rowspan="1" colspan="1">
                  <bold>Kernel Ridge</bold>
                </th>
                <th valign="top" align="center" rowspan="1" colspan="1">
                  <bold>SVR (linear)</bold>
                </th>
                <th valign="top" align="center" rowspan="1" colspan="1">
                  <bold>SVR (RBF)</bold>
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td valign="top" align="left" rowspan="1" colspan="1">MEG single-subjects</td>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MVPA-Light</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.0016</bold> ± 0.00006</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.019</bold> ± 0.0001</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">LIBSVM</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.02 ± 0.001</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.0041</bold> ± 0.0002</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MATLAB</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.0061 ± 0.0002</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.018</bold> ± 0.037</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.023 ± 0.0005</td>
              </tr>
              <tr style="border-bottom: thin solid #000000;">
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" rowspan="1" colspan="1">Scikit Learn</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.0069 ± 0.0003</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.023 ± 0.003</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.654 ± 0.0647</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.481 ± 0.02</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">R</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.055 ± 0.0027</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">1.59 ± 0.094</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.43 ± 0.002</td>
              </tr>
              <tr>
                <td valign="top" align="left" rowspan="1" colspan="1">MEG super-subject</td>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MVPA-Light</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.015</bold> ± 0.001</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>7.38</bold> ± 0.023</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">LIBSVM</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.653</bold> ± 0.038</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.121</bold> ± 0.014</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MATLAB</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.186 ± 0.007</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">6.931 ± 0.237</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">9.9798 ± 0.239</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">Scikit Learn</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.062 ± 0.005</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">14.51 ± 0.21</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">3.213 ± 0.394</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">31.61 ± 1.51</td>
              </tr>
              <tr style="border-bottom: thin solid #000000;">
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" rowspan="1" colspan="1">R</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.547 ± 0.0079</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">465.08 ± 49.83</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">151.66 ± 26.76</td>
              </tr>
              <tr>
                <td valign="top" align="left" rowspan="1" colspan="1">fMRI</td>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MVPA-Light</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.165</bold> ± 0.0042</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">2.026 ± 0.256</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">LIBSVM</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>4.334</bold> ± 1.48</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>2.819</bold> ± 0.0412</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">MATLAB</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">OOM</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">4.545 ± 0.353</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">4.563 ± 0.284</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">Scikit Learn</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">0.638 ± 0.022</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1"><bold>0.476</bold> ± 0.01</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">16.138 ± 3.64</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">9.999 ± 0.59</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"/>
                <td valign="top" align="left" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">R</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">7.503 ± 0.593</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">–</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">37.211 ± 2.056</td>
                <td valign="top" align="center" style="border-bottom: thin solid #000000;" rowspan="1" colspan="1">41.037 ± 2.298</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p><italic>For each combination of dataset and model, the fastest model is marked in bold. OOM, out of memory error; (p), primal form; (d), dual form</italic>.</p>
          </table-wrap-foot>
        </table-wrap>
        <p><italic>LDA</italic>. The MVPA-Light implementation consistently outperforms other implementations in terms of training time, in some cases by orders of magnitude. For the fMRI dataset, it is almost 100 times faster than Scikit Learn, whereas MATLAB and R both run out of memory. It is worth noting that a shrinkage value of 0.01 was applied for the MVPA-Light and MATLAB implementations. For R, low performance was achieved with rda (regularized LDA), so the standard unregularized LDA was used. For Scikit Learn, the default solver does not allow for shrinkage so no shrinkage was applied.</p>
        <p><italic>LogReg</italic>. The MVPA-Light implementation of Logistic Regression outperforms the competitors for the MEG single-subjects data. It is outperformed by the R implementation for the MEG super-subject. For the fMRI data, it causes an out of memory error and the best performing model is LIBLINEAR.</p>
        <p><italic>Naive Bayes</italic>. The MVPA-Light implementation consistently outperforms other implementations, in some cases by orders of magnitude. Scikit Learn is consistently second best, followed by R and MATLAB.</p>
        <p><italic>SVM</italic>. For linear SVM, LIBLINEAR yields the best training speed except for the fMRI data, where MVPA-Light performs best. For RBF kernels, MVPA-Light's SVM consistently outperforms the competitors, closely followed by MATLAB's fitcsvm. Significant differences are obtained for different toolboxes, with R being the slowest in many cases. The good performance of MVPA-Light's SVM may appear surprising at first glance, given some of its contenders run using C code. First, MVPA-Light uses a large tolerance value; this implies that its algorithm might perform fewer iterations than LIBSVM, although this has not been investigated. If this is the case, it does not seem to be detrimental to classification performance, as <xref ref-type="fig" rid="F5">Figure 5</xref> illustrates. Second, the advantages of LIBSVM might not play out during a single training iteration. It has an integrated cross-validation procedure, which is likely to be substantially faster than cross-validation using MVPA-Light, although this has not been investigated either.</p>
        <p><italic>Ridge and Kernel Ridge</italic>. MVPA-Light's models lead the field except for the fMRI data, where Scikit Learn's kernel ridge outperforms MVPA-Light. No results are available for R's krr model; it does not appear to have an interface for fixing hyperparameters and instead performs an expensive search using leave-one-out cross-validation, so it was omitted.</p>
        <p><italic>SVR</italic>. MVPA-Light exclusively relies on LIBSVM for SVR, which leads the field except for one case, in which it closely trails the MATLAB implementation. Overall, R yields the slowest implementation.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="discussion" id="s3">
    <title>3. Discussion</title>
    <p>MVPA-Light offers a suite of classifiers, regression models and metrics for multivariate pattern analysis. A high-level interface facilitates common MVPA tasks such as cross-validated classification across time, generalization, and searchlight analysis. The toolbox supports hyperparameter tuning, pre-computed kernels, and statistical significance testing of the MVPA results.</p>
    <p>MVPA-Light also provides a nested preprocessing pipeline that applies operations to training and test sets separately. Among others, it features over- and undersampling, PCA, and scaling operations. It also includes an averaging approach wherein samples are assigned to groups and then averaged in order to increase signal-to-noise ratio. For linear classifiers, this approach has been explored by (Cichy et al., <xref rid="B10" ref-type="bibr">2015</xref>; Cichy and Pantazis, <xref rid="B9" ref-type="bibr">2017</xref>). Recently, it has been generalized to non-linear kernel methods (Treder, <xref rid="B47" ref-type="bibr">2018</xref>). Either approach can be used in the toolbox by adding the operation <monospace>average_samples</monospace> or <monospace>average_kernel</monospace> to the preprocessing pipeline. To showcase some of its features, analyses of an MEEG (Wakeman and Henson, <xref rid="B52" ref-type="bibr">2015</xref>) and an fMRI (Haxby et al., <xref rid="B21" ref-type="bibr">2001</xref>) dataset are reported. The results illustrate some ways in which the toolbox can aid in quantifying the similarity of representations, measuring the information content, localizing discriminative information in the time-frequency plane, highlighting shared representations across different time points or frequencies, and establishing statistical significance.</p>
    <p>A benchmarking analysis was conducted in order to compare MVPA-Light (including LIBSVM and LIBLINEAR) to models provided in the MATLAB Statistics Toolbox, various R packages, and Scikit Learn for Python. While classification performance is largely consistent across different platforms, training time varies considerably. The MVPA-Light implementations of LDA, Naive Bayes, and Ridge Regression consistently outperform their competitors, in some cases by orders of magnitude. For Logistic Regression and SVM, the MVPA-Light implementations and LIBLINEAR lead the field. In all but one case, MVPA-Light's classifiers are faster than the contenders in MATLAB, R, and Scikit Learn. Overall, the fastest classifier is MVPA-Light's LDA and the fastest regression model is MVPA-Light's Ridge Regression. Partially, the success of MVPA-Light is due to specialization: MVPA-Light models tend to have fewer hyperparameters than other models, and MVPA-Light features separate optimized implementations for binary LDA and multi-class LDA, whereas the other toolboxes have a single implementation. Furthermore, MVPA-Light's LDA and Ridge Regression dynamically switch between primal and dual form. This can increase computational efficiency especially when dealing with a large dataset.</p>
    <p>The benchmarking results should not be interpreted as final verdicts on the respective toolboxes. Undoubtedly, training speed can be improved by finding an optimal set of hyperparameters for a model. For instance, increasing regularization tends to lead to smoother loss surfaces and often faster convergence for gradient descent algorithms. The strategy for the present analysis was to change default parameters minimally and, if so, only in order to increase comparability e.g., by setting a regularization parameter to a common value. Although MVPA-Light will likely perform well in other situations, too, the present results are mostly indicative of <italic>default performance</italic>, obtained with minimal user interference. This is a relevant measure since it is our belief that the burden of hyperparameter selection should be taken off the user as much as possible.</p>
    <sec>
      <title>3.1. Setting Up a MVPA Pipeline</title>
      <p>If one is spoilt for choice, selecting a model, metrics, and preprocessing steps can be challenging. This section offers practical advice in this regard. Such recommendations tend to be subjective to some extent, hence users are encouraged to perform their own MVPA experiments and compare different models, hyperparameter settings etc. To prevent a statistical bias, extensive experiments should not be performed on the dataset at hand. Instead, a similar dataset e.g., recorded using the same hardware with a similar paradigm can be used for experimentation.</p>
    </sec>
    <sec>
      <title>3.2. Preprocessing the Data</title>
      <p>Although MVPA can be applied to raw data, this may negatively affect performance, so data has ideally been cleaned and corrupted trials have been rejected. It is useful to normalize the data for numerical stability by e.g., z-scoring across trials such that each feature has mean = 0 and standard deviation = 1. This is particularly important for Logistic Regression which uses the exponential function. It also applies to LDA and kernel methods because lack of normalization can lead to results being dominated by the features with the largest scaling. Generally speaking, preprocessing operations should be nested in the cross-validation loop i.e., performed on the training set first and then applied to the test set. The <monospace>cfg.preprocess</monospace> option serves this purpose. In some cases such as demeaning, it may be admissible to perform the operation globally on the whole dataset, but one then needs to assure that there is no information leakage from the test set that could bias the results. The same argumentation applies to unsupervised techniques such as PCA. Any preprocessing steps involving the class labels, such as CSP (Blankertz et al., <xref rid="B6" ref-type="bibr">2008</xref>), also need to be nested. Furthermore, for kernel methods, computation can be speeded up by precomputing the kernel matrix using <monospace>compute_kernel_matrix</monospace>, although this approach does not work when generalization is required.</p>
    </sec>
    <sec>
      <title>3.3. Choosing a Classifier</title>
      <p>Linear classifiers perform well in a large variety of tasks. LDA is a good default model, since it is fast and robust thanks to regularization (Blankertz et al., <xref rid="B5" ref-type="bibr">2011</xref>). Logistic Regression and linear SVM are more resilient to outliers than LDA, so may be preferred for noisy or strongly non-Gaussian data. Logistic Regression has a hyperparameter-free regularization by default, hence it is more user-friendly than SVM which requires setting the hyperparameter <italic>c</italic>. Naive Bayes should only be used after the features have been decorrelated using PCA or ICA. For non-linear problems, kernel FDA or SVM can be used. Again, SVM requires <italic>c</italic> to be set, whereas for kernel FDA the default regularization often works well. Regarding the choice of a kernel, the RBF kernel is adequate for most classification tasks, but its hyperparameter <monospace>gamma</monospace> determining the kernel width might require tuning. If maximizing classification accuracy is vital, it is worth to try an ensemble of classifiers.</p>
    </sec>
    <sec>
      <title>3.4. Choosing a Regression Model</title>
      <p>Ridge regression tends to perform well on a variety of tasks. If the data is noisy, linear Support Vector Regression (SVR) using LIBLINEAR can be applied. If the problem is non-linear, either kernel ridge or kernel SVR using LIBSVM with a RBF kernel is recommended.</p>
    </sec>
    <sec>
      <title>3.5. Metrics</title>
      <p>The most common classification metric is accuracy. For multi-class problems, it is useful to complement it with a confusion matrix. For two classes, AUC is a good alternative to accuracy since it is more robust to class imbalances and invariant to shifts of the classifier threshold. When the roles of the classes are asymmetric (e.g., patients vs. controls), it is useful to report precision and recall along with their harmonic mean (F1 score). If in doubt, report multiple metrics.</p>
    </sec>
    <sec>
      <title>3.6. Cross-Validation</title>
      <p>Classification and regression metrics should be cross-validated. Unless the number of samples is very small, leave-one-out cross-validation should be avoided because it suffers from a large bias; instead, use 5- or 10-fold cross-validation (James et al., <xref rid="B24" ref-type="bibr">2013</xref>). Since samples are randomly assigned to folds, repeating the cross-validation is recommended to get a more stable estimate.</p>
    </sec>
    <sec>
      <title>3.7. Conclusion</title>
      <p>MVPA-Light is a comprehensive toolbox for multivariate pattern analysis. Its models perform competitively compared to other implementations. Future development of MVPA-Light will include additional feature extraction techniques for oscillations, such as Common Spatial Patterns (Blankertz et al., <xref rid="B6" ref-type="bibr">2008</xref>) and the Riemannian geometry approach (Barachant et al., <xref rid="B1" ref-type="bibr">2013</xref>), and further computational improvements, such as efficient permutation testing for LDA/KFDA (Treder, <xref rid="B46" ref-type="bibr">2019</xref>) and faster calculation of the regularization path for SVM (Hastie et al., <xref rid="B18" ref-type="bibr">2004</xref>).</p>
    </sec>
  </sec>
  <sec sec-type="data-availability" id="s4">
    <title>Data Availability Statement</title>
    <p>The MEEG dataset can be found in the OpenNeuro repository (<ext-link ext-link-type="uri" xlink:href="https://openneuro.org/datasets/ds000117/versions/1.0.3">https://openneuro.org/datasets/ds000117/versions/1.0.3</ext-link>). The fMRI dataset can be found on the PyMVPA website (<ext-link ext-link-type="uri" xlink:href="http://www.pymvpa.org/datadb/haxby2001.html">http://www.pymvpa.org/datadb/haxby2001.html</ext-link>). Scripts and figures used in this paper are available in the accompanying GitHub repository (github.com/treder/MVPA-Light-Paper).</p>
  </sec>
  <sec id="s5">
    <title>Author Contributions</title>
    <p>MT developed the toolbox, performed all analyses and authored the manuscript.</p>
  </sec>
  <sec id="s6">
    <title>Conflict of Interest</title>
    <p>The author declares that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p>
  </sec>
</body>
<back>
  <ack>
    <p>I would like to thank colleagues from the Psychology department at University of Birmingham for advice and early adaptation of the toolbox, Jan-Mathijs Schoffelen and Sophie Arana for their efforts toward integrating it into FieldTrip, and Hong-Viet Ngo and the reviewers for insightful comments on the manuscript. Many thanks to all contributors to the GitHub repository<xref ref-type="fn" rid="fn0003"><sup>3</sup></xref>.</p>
  </ack>
  <fn-group>
    <fn id="fn0001">
      <p>
        <sup>1</sup>
        <ext-link ext-link-type="uri" xlink:href="http://www.fieldtriptoolbox.org/tutorial/mvpa_light/">
          <monospace>http://www.fieldtriptoolbox.org/tutorial/mvpa_light/</monospace>
        </ext-link>
      </p>
    </fn>
    <fn id="fn0002">
      <p>
        <sup>2</sup>
        <ext-link ext-link-type="uri" xlink:href="https://github.com/treder/MVPA-Light-Paper">https://github.com/treder/MVPA-Light-Paper</ext-link>
      </p>
    </fn>
    <fn id="fn0003">
      <p>
        <sup>3</sup>
        <ext-link ext-link-type="uri" xlink:href="https://github.com/treder/MVPA-Light/graphs/contributors">
          <monospace>https://github.com/treder/MVPA-Light/graphs/contributors</monospace>
        </ext-link>
      </p>
    </fn>
  </fn-group>
  <sec sec-type="supplementary-material" id="s7">
    <title>Supplementary Material</title>
    <p>The Supplementary Material for this article can be found online at: <ext-link ext-link-type="uri" xlink:href="https://www.frontiersin.org/articles/10.3389/fnins.2020.00289/full#supplementary-material">https://www.frontiersin.org/articles/10.3389/fnins.2020.00289/full#supplementary-material</ext-link></p>
    <supplementary-material content-type="local-data" id="SM1">
      <media xlink:href="Related_Article_1.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Barachant</surname><given-names>A.</given-names></name><name><surname>Bonnet</surname><given-names>S.</given-names></name><name><surname>Congedo</surname><given-names>M.</given-names></name><name><surname>Jutten</surname><given-names>C.</given-names></name></person-group> (<year>2013</year>). <article-title>Classification of covariance matrices using a Riemannian-based kernel for BCI applications</article-title>. <source>Neurocomputing</source>
<volume>112</volume>, <fpage>172</fpage>–<lpage>178</lpage>. <pub-id pub-id-type="doi">10.1016/j.neucom.2012.12.039</pub-id></mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bischl</surname><given-names>B.</given-names></name><name><surname>Lang</surname><given-names>M.</given-names></name><name><surname>Kotthoff</surname><given-names>L.</given-names></name><name><surname>Schiffner</surname><given-names>J.</given-names></name><name><surname>Richter</surname><given-names>J.</given-names></name><name><surname>Studerus</surname><given-names>E.</given-names></name><etal/></person-group> (<year>2000</year>). <article-title>mlr: Machine Learning in R</article-title>. <source>J. Mach. Learn. Res.</source>
<volume>17</volume>, <fpage>1</fpage>–<lpage>5</lpage>.</mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bishop</surname><given-names>C. M.</given-names></name></person-group> (<year>2007</year>). <article-title>Pattern recognition and machine learning</article-title>. <source>J. Electron. Imaging</source>
<volume>16</volume>:<fpage>049901</fpage>
<pub-id pub-id-type="doi">10.1117/1.2819119</pub-id></mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Blankertz</surname><given-names>B.</given-names></name><name><surname>Acqualagna</surname><given-names>L.</given-names></name><name><surname>Dähne</surname><given-names>S.</given-names></name><name><surname>Haufe</surname><given-names>S.</given-names></name><name><surname>Schultze-Kraft</surname><given-names>M.</given-names></name><name><surname>Sturm</surname><given-names>I.</given-names></name><etal/></person-group>. (<year>2016</year>). <article-title>The Berlin brain-computer interface: progress beyond communication and control</article-title>. <source>Front. Neurosci.</source><volume>10</volume>:<fpage>530</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2016.00530</pub-id><?supplied-pmid 27917107?><pub-id pub-id-type="pmid">27917107</pub-id></mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Blankertz</surname><given-names>B.</given-names></name><name><surname>Lemm</surname><given-names>S.</given-names></name><name><surname>Treder</surname><given-names>M.</given-names></name><name><surname>Haufe</surname><given-names>S.</given-names></name><name><surname>Müller</surname><given-names>K. R.</given-names></name></person-group> (<year>2011</year>). <article-title>Single-trial analysis and classification of ERP components - A tutorial</article-title>. <source>Neuroimage</source>
<volume>56</volume>, <fpage>814</fpage>–<lpage>825</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2010.06.048</pub-id><?supplied-pmid 20600976?><pub-id pub-id-type="pmid">20600976</pub-id></mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Blankertz</surname><given-names>B.</given-names></name><name><surname>Tomioka</surname><given-names>R.</given-names></name><name><surname>Lemm</surname><given-names>S.</given-names></name><name><surname>Kawanabe</surname><given-names>M.</given-names></name><name><surname>Müller</surname><given-names>K. R.</given-names></name></person-group> (<year>2008</year>). <article-title>Optimizing spatial filters for robust EEG single-trial analysis</article-title>. <source>IEEE Signal Process. Magaz.</source>
<volume>25</volume>, <fpage>41</fpage>–<lpage>56</lpage>. <pub-id pub-id-type="doi">10.1109/MSP.2008.4408441</pub-id></mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bode</surname><given-names>S.</given-names></name><name><surname>Feuerriegel</surname><given-names>D.</given-names></name><name><surname>Bennett</surname><given-names>D.</given-names></name><name><surname>Alday</surname><given-names>P. M.</given-names></name></person-group> (<year>2019</year>). <article-title>The Decision Decoding ToolBOX (DDTBOX) – A multivariate pattern analysis toolbox for event-related potentials</article-title>. <source>Neuroinformatics</source>
<volume>17</volume>, <fpage>27</fpage>–<lpage>42</lpage>. <pub-id pub-id-type="doi">10.1007/s12021-018-9375-z</pub-id><?supplied-pmid 29721680?><pub-id pub-id-type="pmid">29721680</pub-id></mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chang</surname><given-names>C.-C.</given-names></name><name><surname>Chang</surname><given-names>C.-C.</given-names></name><name><surname>Lin</surname><given-names>C.-J.</given-names></name></person-group> (<year>2011</year>). <article-title>LIBSVM: a library for support vector machines</article-title>. <source>ACM Trans. Intell. Syst. Technol.</source>
<volume>2</volume>, <fpage>1</fpage>–<lpage>27</lpage>. <pub-id pub-id-type="doi">10.1145/1961189.1961199</pub-id></mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cichy</surname><given-names>R. M.</given-names></name><name><surname>Pantazis</surname><given-names>D.</given-names></name></person-group> (<year>2017</year>). <article-title>Multivariate pattern analysis of MEG and EEG: a comparison of representational structure in time and space</article-title>. <source>Neuroimage</source>
<volume>158</volume>, <fpage>441</fpage>–<lpage>454</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2017.07.023</pub-id><?supplied-pmid 28716718?><pub-id pub-id-type="pmid">28716718</pub-id></mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cichy</surname><given-names>R. M.</given-names></name><name><surname>Ramirez</surname><given-names>F. M.</given-names></name><name><surname>Pantazis</surname><given-names>D.</given-names></name></person-group> (<year>2015</year>). <article-title>Can visual information encoded in cortical columns be decoded from magnetoencephalography data in humans?</article-title>
<source>Neuroimage</source>
<volume>121</volume>, <fpage>193</fpage>–<lpage>204</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2015.07.011</pub-id><?supplied-pmid 26162550?><pub-id pub-id-type="pmid">26162550</pub-id></mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>De Cheveigné</surname><given-names>A.</given-names></name><name><surname>Parra</surname><given-names>L. C.</given-names></name></person-group> (<year>2014</year>). <article-title>Joint decorrelation, a versatile tool for multichannel data analysis</article-title>. <source>Neuroimage</source>
<volume>98</volume>, <fpage>487</fpage>–<lpage>505</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2014.05.068</pub-id><?supplied-pmid 24990357?><pub-id pub-id-type="pmid">24990357</pub-id></mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Duda</surname><given-names>R. O.</given-names></name><name><surname>Hart</surname><given-names>P. E.</given-names></name><name><surname>Stork</surname><given-names>D. G.</given-names></name></person-group> (<year>2001</year>). <source>Pattern Classification</source>. <publisher-loc>New York, NY</publisher-loc>: <publisher-name>Wiley</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fahrenfort</surname><given-names>J. J.</given-names></name><name><surname>van Driel</surname><given-names>J.</given-names></name><name><surname>van Gaal</surname><given-names>S.</given-names></name><name><surname>Olivers</surname><given-names>C. N. L.</given-names></name></person-group> (<year>2018</year>). <article-title>From ERPs to MVPA using the Amsterdam decoding and modeling toolbox (ADAM)</article-title>. <source>Front. Neurosci.</source>
<volume>12</volume>:<fpage>368</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2018.00368</pub-id><?supplied-pmid 30018529?><pub-id pub-id-type="pmid">30018529</pub-id></mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fan</surname><given-names>R.-E.</given-names></name><name><surname>Chang</surname><given-names>K.-W.</given-names></name><name><surname>Hsieh</surname><given-names>C.-J.</given-names></name><name><surname>Wang</surname><given-names>X.-R.</given-names></name><name><surname>Lin</surname><given-names>C.-J.</given-names></name></person-group> (<year>2008</year>). <article-title>LIBLINEAR: a library for large linear classification</article-title>. <source>J. Mach. Learn. Res.</source>
<volume>9</volume>, <fpage>1871</fpage>–<lpage>1874</lpage>. <pub-id pub-id-type="doi">10.5555/1390681.1442794</pub-id></mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Farwell</surname><given-names>L.</given-names></name><name><surname>Donchin</surname><given-names>E.</given-names></name></person-group> (<year>1988</year>). <article-title>Talking Off the Top of Your Head</article-title>. <source>Electroencephalogr. Clin. Neurophysiol.</source>
<volume>70</volume>, <fpage>510</fpage>–<lpage>523</lpage>. <pub-id pub-id-type="doi">10.1016/0013-4694(88)90149-6</pub-id><?supplied-pmid 2461285?><pub-id pub-id-type="pmid">2461285</pub-id></mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Firth</surname><given-names>D.</given-names></name></person-group> (<year>1993</year>). <article-title>Bias reduction of maximum likelihood estimates</article-title>. <source>Biometrika</source>
<volume>80</volume>:<fpage>27</fpage>
<pub-id pub-id-type="doi">10.1093/bio-met/80.1.27</pub-id></mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grootswagers</surname><given-names>T.</given-names></name><name><surname>Wardle</surname><given-names>S. G.</given-names></name><name><surname>Carlson</surname><given-names>T. A.</given-names></name></person-group> (<year>2017</year>). <article-title>Decoding dynamic brain patterns from evoked responses: a tutorial on Multivariate pattern analysis applied to time series neuroimaging data</article-title>. <source>J. Cogn. Neurosci.</source>
<volume>29</volume>, <fpage>677</fpage>–<lpage>697</lpage>. <pub-id pub-id-type="doi">10.1162/jocna01068</pub-id><?supplied-pmid 27779910?><pub-id pub-id-type="pmid">27779910</pub-id></mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hastie</surname><given-names>T.</given-names></name><name><surname>Rosset</surname><given-names>S.</given-names></name><name><surname>Tibshirani</surname><given-names>R.</given-names></name><name><surname>Zhu</surname><given-names>J.</given-names></name></person-group> (<year>2004</year>). <article-title>The entire regularization path for the support vector machine</article-title>. <source>J. Mach. Learn. Res.</source>
<volume>5</volume>, <fpage>1391</fpage>–<lpage>1415</lpage>. <pub-id pub-id-type="doi">10.5555/1005332.1044706</pub-id></mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Hastie</surname><given-names>T.</given-names></name><name><surname>Tibshirani</surname><given-names>R.</given-names></name><name><surname>Friedman</surname><given-names>J.</given-names></name></person-group> (<year>2009</year>). <source>The Elements of Statistical Learning</source>. <publisher-loc>New York, NY</publisher-loc>: <publisher-name>Springer New York Inc</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Haxby</surname><given-names>J. V.</given-names></name></person-group> (<year>2012</year>). <article-title>Multivariate pattern analysis of fMRI: the early beginnings</article-title>. <source>Neuroimage</source>
<volume>62</volume>, <fpage>852</fpage>–<lpage>855</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2012.03.016</pub-id><?supplied-pmid 22425670?><pub-id pub-id-type="pmid">22425670</pub-id></mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Haxby</surname><given-names>J. V.</given-names></name><name><surname>Gobbini</surname><given-names>M. I.</given-names></name><name><surname>Furey</surname><given-names>M. L.</given-names></name><name><surname>Ishai</surname><given-names>A.</given-names></name><name><surname>Schouten</surname><given-names>J. L.</given-names></name><name><surname>Pietrini</surname><given-names>P.</given-names></name></person-group> (<year>2001</year>). <article-title>Distributed and overlapping representations of faces and objects in ventral temporal cortex</article-title>. <source>Science</source>
<volume>293</volume>, <fpage>2425</fpage>–<lpage>2430</lpage>. <pub-id pub-id-type="doi">10.1126/science.1063736</pub-id><?supplied-pmid 11577229?><pub-id pub-id-type="pmid">11577229</pub-id></mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hearst</surname><given-names>M.</given-names></name><name><surname>Dumais</surname><given-names>S.</given-names></name><name><surname>Osuna</surname><given-names>E.</given-names></name><name><surname>Platt</surname><given-names>J.</given-names></name><name><surname>Schölkopf</surname><given-names>B.</given-names></name></person-group> (<year>1998</year>). <article-title>Support vector machines</article-title>. <source>IEEE Intell. Syst. Appl.</source>
<volume>13</volume>, <fpage>18</fpage>–<lpage>28</lpage>. <pub-id pub-id-type="doi">10.1109/5254.708428</pub-id></mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hebart</surname><given-names>M. N.</given-names></name><name><surname>Görgen</surname><given-names>K.</given-names></name><name><surname>Haynes</surname><given-names>J.-D.</given-names></name></person-group> (<year>2015</year>). <article-title>The Decoding Toolbox (TDT): a versatile software package for multivariate analyses of functional imaging data</article-title>. <source>Front. Neuroinform.</source>
<volume>8</volume>:<fpage>88</fpage>. <pub-id pub-id-type="doi">10.3389/fninf.2014.00088</pub-id><?supplied-pmid 25610393?><pub-id pub-id-type="pmid">25610393</pub-id></mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>James</surname><given-names>G.</given-names></name><name><surname>Witten</surname><given-names>D.</given-names></name><name><surname>Hastie</surname><given-names>T.</given-names></name><name><surname>Tibishirani</surname><given-names>R.</given-names></name></person-group> (<year>2013</year>). <source>An Introduction to Statistical Learning</source>. Springer.</mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>King</surname><given-names>G.</given-names></name><name><surname>Zeng</surname><given-names>L.</given-names></name></person-group> (<year>2001</year>). <article-title>Logistic regression in rare events data</article-title>. <source>Polit. Anal.</source>
<volume>9</volume>, <fpage>137</fpage>–<lpage>163</lpage>. <pub-id pub-id-type="doi">10.1093/oxfordjournals.pan.a004868</pub-id></mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>King</surname><given-names>J.-R.</given-names></name><name><surname>Dehaene</surname><given-names>S.</given-names></name></person-group> (<year>2014</year>). <article-title>Characterizing the dynamics of mental representations: the temporal generalization method</article-title>. <source>Trends Cogn. Sci.</source>
<volume>18</volume>, <fpage>203</fpage>–<lpage>210</lpage>. <pub-id pub-id-type="doi">10.1016/j.tics.2014.01.002</pub-id><?supplied-pmid 24593982?><pub-id pub-id-type="pmid">24593982</pub-id></mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kothe</surname><given-names>C. A.</given-names></name><name><surname>Makeig</surname><given-names>S.</given-names></name></person-group> (<year>2013</year>). <article-title>BCILAB: a platform for brain–computer interface development</article-title>. <source>J. Neural Eng.</source>
<volume>10</volume>:<fpage>056014</fpage>. <pub-id pub-id-type="doi">10.1088/1741-2560/10/5/056014</pub-id><?supplied-pmid 23985960?><pub-id pub-id-type="pmid">23985960</pub-id></mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kriegeskorte</surname><given-names>N.</given-names></name><name><surname>Goebel</surname><given-names>R.</given-names></name><name><surname>Bandettini</surname><given-names>P.</given-names></name></person-group> (<year>2006</year>). <article-title>Information-based functional brain mapping</article-title>. <source>Proc. Natl. Acad. Sci. U.S.A.</source>
<volume>103</volume>, <fpage>3863</fpage>–<lpage>3868</lpage>. <pub-id pub-id-type="doi">10.1073/pnas.0600244103</pub-id><?supplied-pmid 16537458?><pub-id pub-id-type="pmid">16537458</pub-id></mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kuhn</surname><given-names>M.</given-names></name></person-group> (<year>2008</year>). <article-title>Building predictive models in R using the caret Package</article-title>. <source>J. Stat. Softw.</source>
<volume>28</volume>, <fpage>1</fpage>–<lpage>26</lpage>. <pub-id pub-id-type="doi">10.18637/jss.v028.i05</pub-id><pub-id pub-id-type="pmid">27774042</pub-id></mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ledoit</surname><given-names>O.</given-names></name><name><surname>Wolf</surname><given-names>M.</given-names></name></person-group> (<year>2004</year>). <article-title>Honey, I shrunk the sample covariance matrix</article-title>. <source>J. Portfolio Manage.</source>
<volume>30</volume>, <fpage>110</fpage>–<lpage>119</lpage>. <pub-id pub-id-type="doi">10.3905/jpm.2004.110</pub-id></mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lemm</surname><given-names>S.</given-names></name><name><surname>Blankertz</surname><given-names>B.</given-names></name><name><surname>Dickhaus</surname><given-names>T.</given-names></name><name><surname>Müller</surname><given-names>K. R.</given-names></name></person-group> (<year>2011</year>). <article-title>Introduction to machine learning for brain imaging</article-title>. <source>Neuroimage</source>
<volume>56</volume>, <fpage>387</fpage>–<lpage>399</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2010.11.004</pub-id><?supplied-pmid 21172442?><pub-id pub-id-type="pmid">21172442</pub-id></mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Maris</surname><given-names>E.</given-names></name><name><surname>Oostenveld</surname><given-names>R.</given-names></name></person-group> (<year>2007</year>). <article-title>Nonparametric statistical testing of EEG- and MEG-data</article-title>. <source>J. Neurosci. Methods</source>
<volume>164</volume>, <fpage>177</fpage>–<lpage>190</lpage>. <pub-id pub-id-type="doi">10.1016/j.jneumeth.2007.03.024</pub-id><?supplied-pmid 17517438?><pub-id pub-id-type="pmid">17517438</pub-id></mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Mika</surname><given-names>S.</given-names></name><name><surname>Ratsch</surname><given-names>G.</given-names></name><name><surname>Weston</surname><given-names>J.</given-names></name><name><surname>Schölkopf</surname><given-names>B.</given-names></name><name><surname>Müller</surname><given-names>K.-R.</given-names></name></person-group> (<year>1999</year>). <article-title>“Fisher discriminant analysis with kernels,”</article-title> in <source>Neural Networks for Signal Processing IX: Proceedings of the 1999 IEEE Signal Processing Society Workshop (Cat. No.98TH8468)</source> (<publisher-loc>IEEE</publisher-loc>), <fpage>41</fpage>–<lpage>48</lpage>.<?supplied-pmid 18244377?></mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Misaki</surname><given-names>M.</given-names></name><name><surname>Kim</surname><given-names>Y.</given-names></name><name><surname>Bandettini</surname><given-names>P. A.</given-names></name><name><surname>Kriegeskorte</surname><given-names>N.</given-names></name></person-group> (<year>2010</year>). <article-title>Comparison of multivariate classifiers and response normalizations for pattern-information fMRI</article-title>. <source>Neuroimage</source>
<volume>53</volume>, <fpage>103</fpage>–<lpage>118</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2010.05.051</pub-id><?supplied-pmid 20580933?><pub-id pub-id-type="pmid">20580933</pub-id></mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mumford</surname><given-names>J. A.</given-names></name><name><surname>Poldrack</surname><given-names>R. A.</given-names></name></person-group> (<year>2007</year>). <article-title>Modeling group fMRI data</article-title>. <source>Soc. Cogn. Affect. Neurosci.</source>
<volume>2</volume>, <fpage>251</fpage>–<lpage>257</lpage>. <pub-id pub-id-type="doi">10.1093/scan/nsm019</pub-id><?supplied-pmid 18985145?><pub-id pub-id-type="pmid">18985145</pub-id></mixed-citation>
    </ref>
    <ref id="B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mur</surname><given-names>M.</given-names></name><name><surname>Bandettini</surname><given-names>P. A.</given-names></name><name><surname>Kriegeskorte</surname><given-names>N.</given-names></name></person-group> (<year>2009</year>). <article-title>Revealing representational content with pattern-information fMRI - An introductory guide</article-title>. <source>Soc. Cogn. Affect. Neurosci.</source>
<volume>4</volume>, <fpage>101</fpage>–<lpage>109</lpage>. <pub-id pub-id-type="doi">10.1093/scan/nsn044</pub-id><?supplied-pmid 19151374?><pub-id pub-id-type="pmid">19151374</pub-id></mixed-citation>
    </ref>
    <ref id="B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Norman</surname><given-names>K. A.</given-names></name><name><surname>Polyn</surname><given-names>S. M.</given-names></name><name><surname>Detre</surname><given-names>G. J.</given-names></name><name><surname>Haxby</surname><given-names>J. V.</given-names></name></person-group> (<year>2006</year>). <article-title>Beyond mind-reading: multi-voxel pattern analysis of fMRI data</article-title>. <source>Trends Cogn. Sci.</source>
<volume>10</volume>, <fpage>424</fpage>–<lpage>430</lpage>. <pub-id pub-id-type="doi">10.1016/j.tics.2006.07.005</pub-id><?supplied-pmid 16899397?><pub-id pub-id-type="pmid">16899397</pub-id></mixed-citation>
    </ref>
    <ref id="B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Oostenveld</surname><given-names>R.</given-names></name><name><surname>Fries</surname><given-names>P.</given-names></name><name><surname>Maris</surname><given-names>E.</given-names></name><name><surname>Schoffelen</surname><given-names>J.-M.</given-names></name></person-group> (<year>2011</year>). <article-title>FieldTrip: open source software for advanced analysis of MEG, EEG, and invasive electrophysiological data</article-title>. <source>Comput. Intell. Neurosci.</source>
<volume>2011</volume>, <fpage>1</fpage>–<lpage>9</lpage>. <pub-id pub-id-type="doi">10.1155/2011/156869</pub-id><?supplied-pmid 21253357?><pub-id pub-id-type="pmid">21837235</pub-id></mixed-citation>
    </ref>
    <ref id="B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Oosterhof</surname><given-names>N. N.</given-names></name><name><surname>Connolly</surname><given-names>A. C.</given-names></name><name><surname>Haxby</surname><given-names>J. V.</given-names></name></person-group> (<year>2016</year>). <article-title>CoSMoMVPA: multi-modal multivariate pattern analysis of neuroimaging data in Matlab/GNU Octave</article-title>. <source>Front. Neuroinform.</source>
<volume>10</volume>:<fpage>27</fpage>. <pub-id pub-id-type="doi">10.3389/fninf.2016.00027</pub-id><?supplied-pmid 27499741?><pub-id pub-id-type="pmid">27499741</pub-id></mixed-citation>
    </ref>
    <ref id="B40">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pedregosa</surname><given-names>F.</given-names></name><name><surname>Varoquaux</surname><given-names>G.</given-names></name><name><surname>Gramfort</surname><given-names>A.</given-names></name><name><surname>Michel</surname><given-names>V.</given-names></name><name><surname>Thirion</surname><given-names>B.</given-names></name><name><surname>Grisel</surname><given-names>O.</given-names></name><etal/></person-group> (<year>2011</year>). <article-title>Scikit-learn: machine learning in Python</article-title>. <source>J. Mach. Learn. Res.</source>
<volume>12</volume>, <fpage>2825</fpage>–<lpage>2830</lpage>. <pub-id pub-id-type="doi">10.5555/1953048.2078195</pub-id></mixed-citation>
    </ref>
    <ref id="B41">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pereira</surname><given-names>F.</given-names></name><name><surname>Mitchell</surname><given-names>T.</given-names></name><name><surname>Botvinick</surname><given-names>M.</given-names></name></person-group> (<year>2009</year>). <article-title>Machine learning classifiers and fMRI: a tutorial overview</article-title>. <source>Neuroimage</source>
<volume>45</volume>(<issue>1 Suppl.</issue>), <fpage>S199</fpage>–<lpage>S209</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2008.11.007</pub-id><?supplied-pmid 19070668?><pub-id pub-id-type="pmid">19070668</pub-id></mixed-citation>
    </ref>
    <ref id="B42">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rahman</surname><given-names>M. S.</given-names></name><name><surname>Sultana</surname><given-names>M.</given-names></name></person-group> (<year>2017</year>). <article-title>Performance of Firth-and logF-type penalized methods in risk prediction for small or sparse binary data</article-title>. <source>BMC Med. Res. Methodol.</source>
<volume>17</volume>:<fpage>33</fpage>
<pub-id pub-id-type="doi">10.1186/s12874-017-0313-9</pub-id><pub-id pub-id-type="pmid">28231767</pub-id></mixed-citation>
    </ref>
    <ref id="B43">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Schölkopf</surname><given-names>B.</given-names></name><name><surname>Smola</surname><given-names>A.</given-names></name></person-group> (<year>2001</year>). <source>Learning With Kernels: Support Vector Machines, Regularization, Optimization, and Beyond</source>. <publisher-loc>Cambridge, MA</publisher-loc>: <publisher-name>MIT Press</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B44">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schrouff</surname><given-names>J.</given-names></name><name><surname>Rosa</surname><given-names>M. J.</given-names></name><name><surname>Rondina</surname><given-names>J. M.</given-names></name><name><surname>Marquand</surname><given-names>A. F.</given-names></name><name><surname>Chu</surname><given-names>C.</given-names></name><name><surname>Ashburner</surname><given-names>J.</given-names></name><etal/></person-group>. (<year>2013</year>). <article-title>PRoNTo: pattern recognition for neuroimaging toolbox</article-title>. <source>Neuroinformatics</source><volume>11</volume>, <fpage>319</fpage>–<lpage>337</lpage>. <pub-id pub-id-type="doi">10.1007/s12021-013-9178-1</pub-id><?supplied-pmid 23417655?><pub-id pub-id-type="pmid">23417655</pub-id></mixed-citation>
    </ref>
    <ref id="B45">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sokolova</surname><given-names>M.</given-names></name><name><surname>Lapalme</surname><given-names>G.</given-names></name></person-group> (<year>2009</year>). <article-title>A systematic analysis of performance measures for classification tasks</article-title>. <source>Inform. Process. Manage.</source>
<volume>45</volume>, <fpage>427</fpage>–<lpage>437</lpage>. <pub-id pub-id-type="doi">10.1016/j.ipm.2009.03.002</pub-id></mixed-citation>
    </ref>
    <ref id="B46">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Treder</surname><given-names>M.</given-names></name></person-group> (<year>2019</year>). <article-title>“Direct calculation of out-of-sample predictions in multi-class kernel FDA,”</article-title> in <source>27th European Symposium on Artificial Neural Networks (ESANN)</source> (<publisher-loc>Bruges</publisher-loc>), <fpage>245</fpage>–<lpage>250</lpage>.</mixed-citation>
    </ref>
    <ref id="B47">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Treder</surname><given-names>M. S.</given-names></name></person-group> (<year>2018</year>). <article-title>Improving SNR and reducing training time of classifiers in large datasets via kernel averaging</article-title>. <source>Lecture Notes Comput. Sci.</source>
<volume>11309</volume>, <fpage>239</fpage>–<lpage>248</lpage>. <pub-id pub-id-type="doi">10.1007/978-3-030-05587-523</pub-id></mixed-citation>
    </ref>
    <ref id="B48">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Treder</surname><given-names>M. S.</given-names></name><name><surname>Porbadnigk</surname><given-names>A. K.</given-names></name><name><surname>Shahbazi Avarvand</surname><given-names>F.</given-names></name><name><surname>Müller</surname><given-names>K.-R.</given-names></name><name><surname>Blankertz</surname><given-names>B.</given-names></name></person-group> (<year>2016</year>). <article-title>The LDA beamformer: optimal estimation of ERP source time series using linear discriminant analysis</article-title>. <source>Neuroimage</source>
<volume>129</volume>, <fpage>279</fpage>–<lpage>291</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2016.01.019</pub-id><?supplied-pmid 26804780?><pub-id pub-id-type="pmid">26804780</pub-id></mixed-citation>
    </ref>
    <ref id="B49">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Treder</surname><given-names>M. S.</given-names></name><name><surname>Purwins</surname><given-names>H.</given-names></name><name><surname>Miklody</surname><given-names>D.</given-names></name><name><surname>Sturm</surname><given-names>I.</given-names></name><name><surname>Blankertz</surname><given-names>B.</given-names></name></person-group> (<year>2014</year>). <article-title>Decoding auditory attention to instruments in polyphonic music using single-trial EEG classification</article-title>. <source>J. Neural Eng.</source>
<volume>11</volume>:<fpage>026009</fpage>. <pub-id pub-id-type="doi">10.1088/1741-2560/11/2/026009</pub-id><?supplied-pmid 24608228?><pub-id pub-id-type="pmid">24608228</pub-id></mixed-citation>
    </ref>
    <ref id="B50">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Varoquaux</surname><given-names>G.</given-names></name><name><surname>Raamana</surname><given-names>P.</given-names></name><name><surname>Engemann</surname><given-names>D.</given-names></name><name><surname>Hoyos-Idrobo</surname><given-names>A.</given-names></name><name><surname>Schwartz</surname><given-names>Y.</given-names></name><name><surname>Thirion</surname><given-names>B.</given-names></name></person-group> (<year>2017</year>). <article-title>Assessing and tuning brain decoders: cross-validation, caveats, and guidelines</article-title>. <source>Neuroimage</source>
<volume>145B</volume>, <fpage>166</fpage>–<lpage>179</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuroimage.2016.10.038</pub-id><?supplied-pmid 27989847?><pub-id pub-id-type="pmid">27989847</pub-id></mixed-citation>
    </ref>
    <ref id="B51">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wakeman</surname><given-names>D. G.</given-names></name><name><surname>Henson</surname><given-names>R. N.</given-names></name></person-group> (<year>2014</year>). OpenfMRI.</mixed-citation>
    </ref>
    <ref id="B52">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wakeman</surname><given-names>D. G.</given-names></name><name><surname>Henson</surname><given-names>R. N.</given-names></name></person-group> (<year>2015</year>). <article-title>A multi-subject, multi-modal human neuroimaging dataset</article-title>. <source>Sci. Data</source>
<volume>2</volume>:<fpage>150001</fpage>. <pub-id pub-id-type="doi">10.1038/sdata.2015.1</pub-id><?supplied-pmid 25977808?><pub-id pub-id-type="pmid">25977808</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
