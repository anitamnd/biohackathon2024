<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<?covid-19-tdm?>
<?noissn?>
<front>
  <journal-meta>
    <journal-id journal-id-type="publisher-id">978-3-030-52482-1</journal-id>
    <journal-id journal-id-type="doi">10.1007/978-3-030-52482-1</journal-id>
    <journal-id journal-id-type="nlm-ta">Reversible Computation</journal-id>
    <journal-title-group>
      <journal-title>Reversible Computation</journal-title>
      <journal-subtitle>12th International Conference, RC 2020, Oslo, Norway, July 9-10, 2020, Proceedings</journal-subtitle>
    </journal-title-group>
    <isbn publication-format="print">978-3-030-52481-4</isbn>
    <isbn publication-format="electronic">978-3-030-52482-1</isbn>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7342053</article-id>
    <article-id pub-id-type="publisher-id">14</article-id>
    <article-id pub-id-type="doi">10.1007/978-3-030-52482-1_14</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>ReverCSP: Time-Travelling in CSP Computations</article-title>
    </title-group>
    <contrib-group content-type="book editors">
      <contrib contrib-type="editor">
        <name>
          <surname>Lanese</surname>
          <given-names>Ivan</given-names>
        </name>
        <address>
          <email>ivan.lanese@gmail.com</email>
        </address>
        <xref ref-type="aff" rid="Aff8">8</xref>
      </contrib>
      <contrib contrib-type="editor">
        <name>
          <surname>Rawski</surname>
          <given-names>Mariusz</given-names>
        </name>
        <address>
          <email>mariusz.rawski@gmail.com</email>
        </address>
        <xref ref-type="aff" rid="Aff9">9</xref>
      </contrib>
      <aff id="Aff8"><label>8</label><institution-wrap><institution-id institution-id-type="GRID">grid.6292.f</institution-id><institution-id institution-id-type="ISNI">0000 0004 1757 1758</institution-id><institution>University of Bologna, </institution></institution-wrap>Bologna, Bologna Italy </aff>
      <aff id="Aff9"><label>9</label><institution-wrap><institution-id institution-id-type="GRID">grid.12847.38</institution-id><institution-id institution-id-type="ISNI">0000 0004 1937 1290</institution-id><institution>University of Warsaw, </institution></institution-wrap>Warsaw, Poland </aff>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-3569-6218</contrib-id>
        <name>
          <surname>Galindo</surname>
          <given-names>Carlos</given-names>
        </name>
        <xref ref-type="aff" rid="Aff10">10</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-8697-4970</contrib-id>
        <name>
          <surname>Nishida</surname>
          <given-names>Naoki</given-names>
        </name>
        <xref ref-type="aff" rid="Aff11">11</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-5096-0008</contrib-id>
        <name>
          <surname>Silva</surname>
          <given-names>Josep</given-names>
        </name>
        <address>
          <email>jsilva@dsic.upv.es</email>
        </address>
        <xref ref-type="aff" rid="Aff10">10</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-5103-4153</contrib-id>
        <name>
          <surname>Tamarit</surname>
          <given-names>Salvador</given-names>
        </name>
        <xref ref-type="aff" rid="Aff10">10</xref>
      </contrib>
      <aff id="Aff10"><label>10</label><institution-wrap><institution-id institution-id-type="GRID">grid.157927.f</institution-id><institution-id institution-id-type="ISNI">0000 0004 1770 5832</institution-id><institution>Departament de Sistemes Informàtics i Computació, </institution><institution>Universitat Politècnica de València, </institution></institution-wrap>Camino de Vera sn, 46022 Valencia, Spain </aff>
      <aff id="Aff11"><label>11</label><institution-wrap><institution-id institution-id-type="GRID">grid.27476.30</institution-id><institution-id institution-id-type="ISNI">0000 0001 0943 978X</institution-id><institution>Graduate School of Informatics, </institution><institution>Nagoya University, </institution></institution-wrap>Furo-cho, Chikusa-ku, Nagoya, 464-8603 Japan </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>17</day>
      <month>06</month>
      <year>2020</year>
    </pub-date>
    <volume>12227</volume>
    <fpage>239</fpage>
    <lpage>245</lpage>
    <permissions>
      <copyright-statement>© Springer Nature Switzerland AG 2020</copyright-statement>
      <license>
        <license-p>This article is made available via the PMC Open Access Subset for unrestricted research re-use and secondary analysis in any form or by any means with acknowledgement of the original source. These permissions are granted for the duration of the World Health Organization (WHO) declaration of COVID-19 as a global pandemic.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p id="Par1">This paper presents <italic>reverCSP</italic>, a tool to animate both forward and backward CSP computations. This ability to reverse computations can be done step by step or backtracking to a given desired state of interest. <italic>reverCSP</italic> allows us to reverse computations exactly in the same order in which they happened, or also in a causally-consistent way. Therefore, <italic>reverCSP</italic> is a tool that can be especially useful to comprehend, analyze, and debug computations. <italic>reverCSP</italic> is an open-source project publicly available for the community. We describe the tool and its functionality, and we provide implementation details so that it can be reimplemented for other languages.</p>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Reversible computations</kwd>
      <kwd>CSP</kwd>
      <kwd>Tracing</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© Springer Nature Switzerland AG 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Introduction</title>
    <p id="Par2">The Communicating Sequential Processes (CSP) is nowadays one of the must used process algebras [<xref ref-type="bibr" rid="CR16">16</xref>]. The analysis of CSP computations has traditionally been based on the so-called <italic>CSP traces</italic>. Roughly, CSP traces are a representation to specify all possible computations that may occur in a system, and they are represented with sequences of events. Among the different analyses defined over traces we have security analysis [<xref ref-type="bibr" rid="CR6">6</xref>], livelock analysis [<xref ref-type="bibr" rid="CR3">3</xref>], and deadlock analysis [<xref ref-type="bibr" rid="CR7">7</xref>, <xref ref-type="bibr" rid="CR17">17</xref>].</p>
    <p id="Par3">Unfortunately, CSP traces are not very appropriate for debugging because they do not relate the computations with the source code. For this reason, a data structure called CSP track [<xref ref-type="bibr" rid="CR12">12</xref>] was defined to overcome that problem. CSP tracks were originally conceived for program comprehension and debugging because they can represent forward CSP computations with the advantage that every single step of the operational semantics is associated with the positions in the source code (i.e., initial and final line and column) of the literals of the specification participating in that step. This means that, with a CSP track, one can see directly in the source code the parts that are being executed.</p>
    <sec id="FPar1">
      <title>Example 1</title>
      <p id="Par4">Consider the following CSP specification:<xref ref-type="fn" rid="Fn1">1</xref>
<graphic position="anchor" xlink:href="501864_1_En_14_Figa_HTML" id="MO1"/>
</p>
      <p id="Par6">The only possible traces of this specification are:
<inline-graphic xlink:href="501864_1_En_14_Figb_HTML.gif" id="d30e507"/>
</p>
      <p id="Par7">If we consider the trace
<inline-graphic xlink:href="501864_1_En_14_Figc_HTML.gif" id="d30e512"/>
, it can be produced by two different computations due to the non-deterministic evaluation order of the processes. While the first event (a) is deterministic, the b events are not (they could correspond to either process P or Q). Therefore, a trace
<inline-graphic xlink:href="501864_1_En_14_Figd_HTML.gif" id="d30e528"/>
does not give information about what parts of the computation have been executed and in what order.</p>
      <p id="Par8">In contrast, if we observe the track in Fig. <xref rid="Fig1" ref-type="fig">1</xref>, we can see that it represents the source code literals inside nodes (at the top right); each node is labelled with its associated timestamp (at the top left) and they contain pairs line-column to uniquely identify the literals in the CSP specification. Synchronizations are represented with a dashed edge. For the time being the reader can ignore the green text and lines.<fig id="Fig1"><label>Fig. 1.</label><caption><p>Extended track of the computation produced by the trace
<inline-graphic xlink:href="501864_1_En_14_Fige_HTML.gif" id="d30e543"/>
in <italic>reverCSP</italic>.</p></caption><graphic xlink:href="501864_1_En_14_Fig1_HTML" id="MO6"/></fig>
</p>
      <p>In this paper we present a new tool called <italic>reverCSP</italic> that uses an extension of CSP tracks to animate and reverse computations. We explain how to download and install the tool, and we explain its functionality and architecture.</p>
    </sec>
  </sec>
  <sec id="Sec2">
    <title>Recording the History of a CSP Computation</title>
    <p id="Par10">According to the Landauer’s embedding principle [<xref ref-type="bibr" rid="CR8">8</xref>] a record of a computation can make that computation reversible. In order to record CSP computations we have defined an extension of CSP tracks [<xref ref-type="bibr" rid="CR12">12</xref>] so that they also store the exact time when each literal in the track was executed. This gives us the ability to know exactly in what order where the literals executed and, thus, to reverse computations. Observe in Fig. <xref rid="Fig1" ref-type="fig">1</xref> that each node has a label with a timestamp that represents the instant where this node was generated. Therefore, synchronized events have the same timestamp.</p>
    <p id="Par11">With the timestamp we can serialize the program. For instance, if we only focus on event nodes (those in bold) then it is trivial to generate the associated trace
<inline-graphic xlink:href="501864_1_En_14_Figf_HTML.gif" id="d30e573"/>
following the sequence:
<inline-graphic xlink:href="501864_1_En_14_Figg_HTML.gif" id="d30e576"/>
. Timestamps together with synchronizations also allow us to define a causally-consistent relation between nodes. This relation allows us to perform (forward and backward) causally-consistent steps. These steps group a set of nodes that must happen before a given action (a visible event or the end of the computation represented with SKIP or STOP) and after another action that already happened.</p>
    <sec id="FPar2">
      <title>Example 2</title>
      <p id="Par12">Consider again the track in Fig. <xref rid="Fig1" ref-type="fig">1</xref>. Those nodes that belong to the same causally-consistent step have been grouped inside an area marked with a dotted green line. The causal relation is represented by the identifier of the causally-consistent steps. Step X.Y cannot be undone until any suffix of X.Y has been undone. This means that steps 1.1, 1.2, and 1.3 must be undone (in any order) before undoing step 1. Similarly, step 1.2.1 must be undone before undoing step 1.2. Steps 1.2.1 and 1.3.1 can be undone in any order. All this information is automatically computed by <italic>reverCSP</italic> and used to control that steps are (un)done (and offered to the user) in the correct order.</p>
    </sec>
  </sec>
  <sec id="Sec3">
    <title>The System <italic>reverCSP</italic></title>
    <sec id="Sec4">
      <title>Downloading and Installation</title>
      <p id="Par13">The <italic>reverCSP</italic> system is open-source and free. It can be downloaded from: <ext-link ext-link-type="uri" xlink:href="https://github.com/tamarit/reverCSP">https://github.com/tamarit/reverCSP</ext-link>. The system can be run either on Linux or in a Docker container. The later is the simplest, as the user only needs to install docker and run the following commands:<graphic position="anchor" xlink:href="501864_1_En_14_Figh_HTML" id="MO9"/>
</p>
      <p id="Par14">Then, from within the shell inside the docker container, the user can run the script reverCSP, accompanied by the path to a CSP specification file, as can be seen in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. The two volumes exposed to docker (the -v option) allow the user to view the generated PDF files in the output folder and to add new specifications to be analyzed.<fig id="Fig2"><label>Fig. 2.</label><caption><p>Main menu (left) and a series of user actions and the resulting states (right). (Color figure online)</p></caption><graphic xlink:href="501864_1_En_14_Fig2_HTML" id="MO10"/></fig>
</p>
      <p id="Par15">The system uses the Erlang/OTP framework<xref ref-type="fn" rid="Fn2">2</xref> to animate CSP specifications, and it (optionally) uses Graphviz<xref ref-type="fn" rid="Fn3">3</xref> to produce PDF outputs of the tracks. Otherwise, only DOT files will be produced. Both systems are also freely available under open-source licenses.</p>
    </sec>
    <sec id="Sec5">
      <title>Main Functionality</title>
      <p id="Par18"><italic>reverCSP</italic> implements in Erlang a reversible CSP interpreter with two phases:<list list-type="bullet"><list-item><p id="Par19"><bold>Generation of tracks.</bold> Tracks can be generated using a random number of steps (a random execution) or following the computation steps defined by the user (user-directed execution). This means that, at any point of the computation, the user can choose how to proceed and the associated track is dynamically generated. For instance, a user can perform, say, 50 random steps, then go backward, say 20 steps, and then go forward again but selecting a different rule to be applied. Thus, a different computation (and track) is produced.</p></list-item><list-item><p id="Par20"><bold>Exploration of tracks.</bold> Provided that we have a track generated, it can be traversed backward. The traversal is done with computation steps that can be deterministic (using the Undo option) or causally-consistent (using the Reverse evaluation option). After each step, the system shows the current expression and it gives the option to output the trace and the track. Figure <xref rid="Fig2" ref-type="fig">2</xref> shows the menu displayed during a computation (left), followed by the computation steps selected by the user (right). The states reached are in black, the user actions are in blue and the changes in the state produced by the last action selected are in red.</p></list-item></list>
</p>
    </sec>
    <sec id="Sec6">
      <title>Architecture and Implementation Details</title>
      <p id="Par21">Figure <xref rid="Fig3" ref-type="fig">3</xref> shows the architecture of <italic>reverCSP</italic>. The source code is parsed by module CSP tracker to produce an initial state (of the operational semantics). This state is used by module Forward Computation to perform a forward step and generate the associated track. If we want to reverse the computation, then module Backward Computation can update the state with the information of the track. When required, module CSP tracker serves the parsed code to the other modules and performs semantic steps from a given state. The interface interacts with the user and continuously displays the trace of the computation.<fig id="Fig3"><label>Fig. 3.</label><caption><p><italic>reverCSP</italic> architecture.</p></caption><graphic xlink:href="501864_1_En_14_Fig3_HTML" id="MO11"/></fig>
</p>
    </sec>
  </sec>
  <sec id="Sec7">
    <title>Related Work</title>
    <p id="Par22">There exist different works that propose techniques for rollback-recovery [<xref ref-type="bibr" rid="CR5">5</xref>] and for reversibility in sequential systems [<xref ref-type="bibr" rid="CR15">15</xref>] and concurrent systems [<xref ref-type="bibr" rid="CR11">11</xref>]. Our system, <italic>reverCSP</italic>, is a replay debugger that uses tracks to record the execution. In the core of our tool we use a library called CSP-tracker [<xref ref-type="bibr" rid="CR13">13</xref>] that can be invoked to produce tracks. One interesting tool that is related to our work is CauDEr [<xref ref-type="bibr" rid="CR10">10</xref>]. It can also causal-consistently reverse computations, but in this case for Erlang and using a different notion of track. The idea of reversing computations in a causally-consistent manner was introduced in [<xref ref-type="bibr" rid="CR4">4</xref>] for CCS. Since then, different approaches have emerged. A survey that very nicely describes some of those approaches is [<xref ref-type="bibr" rid="CR9">9</xref>].</p>
    <p id="Par23">There are other systems such as [<xref ref-type="bibr" rid="CR1">1</xref>, <xref ref-type="bibr" rid="CR2">2</xref>] and [<xref ref-type="bibr" rid="CR11">11</xref>] that are somehow related to our tool. The work in [<xref ref-type="bibr" rid="CR1">1</xref>] proposes a modular framework that can be used to define causal-consistent reversible extensions of different concurrent models and languages. The extension of tracks that we defined was inspired by that work. Another interesting work that also proposes a tool that can reverse computations, this time for a CSP-based language embedded in Scala, was presented by Brown and Sabry [<xref ref-type="bibr" rid="CR2">2</xref>]. Unfortunately, the implementation is not publicly available. Finally, Lanese et al. [<xref ref-type="bibr" rid="CR11">11</xref>] proposed a novel approach called <italic>controlled causal-consistent replay</italic> where the debugger displays all and only the causes of an error. These approaches are also related to causally-consistent dynamic slicing [<xref ref-type="bibr" rid="CR14">14</xref>], but there are important differences: They target pi calculus and we target CSP. Our tool is based on tracks to reverse computations, while dynamic slicing uses execution traces to compute program slices that contain the parts of the source that could influence a given behavior.</p>
  </sec>
  <sec id="Sec8">
    <title>Conclusions</title>
    <p id="Par24">This paper described <italic>reverCSP</italic>, a tool for the animation and analysis of CSP specifications. On the practical side, <italic>reverCSP</italic> can be seen as a CSP animator with the ability to replay and reverse computations. This ability is provided by the fact that <italic>reverCSP</italic> records every execution step of the computation in a graph-like data structure called track.</p>
    <p id="Par25">We have extended the original definition of track to incorporate timestamps that make explicit the order in which the components of the specification were executed; and this order allows us to reverse the computation. <italic>reverCSP</italic> implements different functionalities such as step-by-step forward and backward execution, random (multiple) steps, undo, and rollback. Besides, it allows to perform both deterministic and causally-consistent reversible steps.</p>
    <p id="Par26">Because <italic>reverCSP</italic> (re)generates the corresponding part of the track with every computation step, the complete track is available to perform different post-mortem analyses. One of them is program slicing, which was already implemented in a tool called CSP-tracker. As future work we plan to adapt our analyses to also implement a causally-consistent dynamic program slicer based on tracks for CSP.</p>
  </sec>
</body>
<back>
  <fn-group>
    <fn id="Fn1">
      <label>1</label>
      <p id="Par5">Those readers non familiar with the CSP syntax are referred to [<xref ref-type="bibr" rid="CR16">16</xref>], where all CSP syntax constructs are explained.</p>
    </fn>
    <fn id="Fn2">
      <label>2</label>
      <p id="Par16"><ext-link ext-link-type="uri" xlink:href="https://www.erlang.org/">https://www.erlang.org/</ext-link>.</p>
    </fn>
    <fn id="Fn3">
      <label>3</label>
      <p id="Par17"><ext-link ext-link-type="uri" xlink:href="https://www.graphviz.org/">https://www.graphviz.org/</ext-link>.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>This work has been partially supported by the EU (FEDER) and the Spanish MCI/AEI under grants TIN2016-76843-C4-1-R and PID2019-104735RB-C41, and by the <italic>Generalitat Valenciana</italic> under grant Prometeo/2019/098 (DeepTrust).</p>
  </ack>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <mixed-citation publication-type="other">Bernadet, A., Lanese, I.: A modular formalization of reversibility for concurrent models and languages. In: Proceedings of ICE 2016, EPTCS (2016)</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brown</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Sabry</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Reversible communicating processes</article-title>
        <source>Electron. Proc. Theor. Comput. Sci.</source>
        <year>2016</year>
        <volume>203</volume>
        <fpage>45</fpage>
        <lpage>59</lpage>
        <pub-id pub-id-type="doi">10.4204/EPTCS.203.4</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Conserva Filhoa</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Oliveira</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Sampaio</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Cavalcanti</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Compositional and local livelock analysis for CSP</article-title>
        <source>Inf. Process. Lett</source>
        <year>2018</year>
        <volume>133</volume>
        <fpage>21</fpage>
        <lpage>25</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ipl.2017.12.011</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Danos</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Krivine</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Gardner</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Yoshida</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Reversible communicating systems</article-title>
        <source>CONCUR 2004 - Concurrency Theory</source>
        <year>2004</year>
        <publisher-loc>Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>292</fpage>
        <lpage>307</lpage>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Elnozahy</surname>
            <given-names>ENM</given-names>
          </name>
          <name>
            <surname>Alvisi</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>Y-M</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>DB</given-names>
          </name>
        </person-group>
        <article-title>A survey of rollback- recovery protocols in message-passing systems</article-title>
        <source>ACM Comput. Surv.</source>
        <year>2002</year>
        <volume>34</volume>
        <issue>3</issue>
        <fpage>375</fpage>
        <lpage>408</lpage>
        <pub-id pub-id-type="doi">10.1145/568522.568525</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <mixed-citation publication-type="other">Fang, Y., Zhu, H., Zeyda, F., Fei, Y.: Modeling and analysis of the disruptor framework in csp. In: Proceedings of CCWC 2018. IEEE Computer Society (2018)</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ladkin</surname>
            <given-names>PB</given-names>
          </name>
          <name>
            <surname>Simons</surname>
            <given-names>BB</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Fussell</surname>
            <given-names>DS</given-names>
          </name>
          <name>
            <surname>Malek</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Static deadlock analysis for CSP-type communications</article-title>
        <source>Responsive Computer Systems: Steps Toward Fault-Tolerant Real-Time Systems</source>
        <year>1995</year>
        <publisher-loc>Boston</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>89</fpage>
        <lpage>102</lpage>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Landauer</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Irreversibility and heat generation in the computing process</article-title>
        <source>IBM J. Res. Dev.</source>
        <year>1961</year>
        <volume>5</volume>
        <fpage>183</fpage>
        <lpage>191</lpage>
        <pub-id pub-id-type="doi">10.1147/rd.53.0183</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lanese</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Antares Mezzina</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Tiezzi</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Causal-consistent reversibility</article-title>
        <source>Bull. EATCS</source>
        <year>2014</year>
        <volume>114</volume>
        <fpage>17</fpage>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Lanese</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Nishida</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Palacios</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Vidal</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Gallagher</surname>
            <given-names>JP</given-names>
          </name>
          <name>
            <surname>Sulzmann</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>CauDEr: a causal-consistent reversible debugger for erlang</article-title>
        <source>Functional and Logic Programming</source>
        <year>2018</year>
        <publisher-loc>Cham</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>247</fpage>
        <lpage>263</lpage>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Lanese</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Palacios</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Vidal</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Pérez</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Yoshida</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Causal-consistent replay debugging for message passing programs</article-title>
        <source>Formal Techniques for Distributed Objects, Components, and Systems</source>
        <year>2019</year>
        <publisher-loc>Cham</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>167</fpage>
        <lpage>184</lpage>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Llorens</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Oliver</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Silva</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Tamarit</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Dynamic slicing of concurrent specification languages</article-title>
        <source>Parallel Comput.</source>
        <year>2016</year>
        <volume>53</volume>
        <fpage>1</fpage>
        <lpage>22</lpage>
        <pub-id pub-id-type="doi">10.1016/j.parco.2016.01.006</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Llorens</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Oliver</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Silva</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Tamarit</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Tracking CSP computations</article-title>
        <source>J. Log. Algebr. Meth. Program.</source>
        <year>2019</year>
        <volume>102</volume>
        <fpage>138</fpage>
        <lpage>175</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jlamp.2018.10.002</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <mixed-citation publication-type="other">Perera, R., Garg, D., Cheney, J.: Causally consistent dynamic slicing. In Proceedings of CONCUR 2016, LIPIcs, vol. 59, pp. 18:1–18:15 (2016)</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Phillips</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Ulidowski</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Yuen</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Glück</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Yokoyama</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>A reversible process calculus and the modelling of the ERK signalling pathway</article-title>
        <source>Reversible Computation</source>
        <year>2013</year>
        <publisher-loc>Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>218</fpage>
        <lpage>232</lpage>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Roscoe</surname>
            <given-names>AW</given-names>
          </name>
        </person-group>
        <source>The Theory and Practice of Concurrency</source>
        <year>1997</year>
        <publisher-loc>Upper Saddle River</publisher-loc>
        <publisher-name>Prentice Hall PTR</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <mixed-citation publication-type="other">Zhao, H., Zhu, H., Yucheng, F., Xiao, L.: Modeling and verifying storm using CSP. In: Proceedings of HASE 2019. IEEE Computer Society (2019)</mixed-citation>
    </ref>
  </ref-list>
</back>
