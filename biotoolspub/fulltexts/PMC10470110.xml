<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName nlm2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Front Genet</journal-id>
    <journal-id journal-id-type="iso-abbrev">Front Genet</journal-id>
    <journal-id journal-id-type="publisher-id">Front. Genet.</journal-id>
    <journal-title-group>
      <journal-title>Frontiers in Genetics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1664-8021</issn>
    <publisher>
      <publisher-name>Frontiers Media S.A.</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10470110</article-id>
    <article-id pub-id-type="publisher-id">1220408</article-id>
    <article-id pub-id-type="doi">10.3389/fgene.2023.1220408</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genetics</subject>
        <subj-group>
          <subject>Technology and Code</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Accelerated matrix-vector multiplications for matrices involving genotype covariates with applications in genomic prediction</article-title>
      <alt-title alt-title-type="left-running-head">Freudenberg et al.</alt-title>
      <alt-title alt-title-type="right-running-head">
        <ext-link xlink:href="https://doi.org/10.3389/fgene.2023.1220408" ext-link-type="uri">10.3389/fgene.2023.1220408</ext-link>
      </alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Freudenberg</surname>
          <given-names>Alexander</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="c001" ref-type="corresp">*</xref>
        <uri xlink:href="https://loop.frontiersin.org/people/2279485/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Vandenplas</surname>
          <given-names>Jeremie</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">
          <sup>2</sup>
        </xref>
        <uri xlink:href="https://loop.frontiersin.org/people/1094210/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Schlather</surname>
          <given-names>Martin</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">
          <sup>1</sup>
        </xref>
        <uri xlink:href="https://loop.frontiersin.org/people/2381219/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Pook</surname>
          <given-names>Torsten</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">
          <sup>2</sup>
        </xref>
        <uri xlink:href="https://loop.frontiersin.org/people/941529/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Evans</surname>
          <given-names>Ross</given-names>
        </name>
        <xref rid="aff3" ref-type="aff">
          <sup>3</sup>
        </xref>
        <uri xlink:href="https://loop.frontiersin.org/people/1698900/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ten Napel</surname>
          <given-names>Jan</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">
          <sup>2</sup>
        </xref>
        <uri xlink:href="https://loop.frontiersin.org/people/2198502/overview"/>
      </contrib>
    </contrib-group>
    <aff id="aff1"><sup>1</sup><institution>Chair of Applied Stochastics</institution>, <institution>University of Mannheim</institution>, <addr-line>Mannheim</addr-line>, <country>Germany</country></aff>
    <aff id="aff2"><sup>2</sup><institution>Animal Breeding and Genomics, Wageningen UR</institution>, <addr-line>Wageningen</addr-line>, <country>Netherlands</country></aff>
    <aff id="aff3"><sup>3</sup><institution>Irish Cattle Breeding Federation</institution>, <addr-line>Ballincollig</addr-line>, <country>Ireland</country></aff>
    <author-notes>
      <fn fn-type="edited-by">
        <p><bold>Edited by:</bold><ext-link xlink:href="https://loop.frontiersin.org/people/37713/overview" ext-link-type="uri">Dorian Garrick</ext-link>, Massey University, New Zealand</p>
      </fn>
      <fn fn-type="edited-by">
        <p><bold>Reviewed by:</bold><ext-link xlink:href="https://loop.frontiersin.org/people/774102/overview" ext-link-type="uri">Hao Cheng</ext-link>, University of California, Davis, United States</p>
        <p><ext-link xlink:href="https://loop.frontiersin.org/people/1161300/overview" ext-link-type="uri">Mohammad Ali Nilforooshan</ext-link>, Livestock Improvement Corporation, New Zealand</p>
      </fn>
      <corresp id="c001">*Correspondence: Alexander Freudenberg, <email>alexander.freudenberg@uni-mannheim.de</email>
</corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>17</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2023</year>
    </pub-date>
    <volume>14</volume>
    <elocation-id>1220408</elocation-id>
    <history>
      <date date-type="received">
        <day>10</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>03</day>
        <month>8</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2023 Freudenberg, Vandenplas, Schlather, Pook, Evans and Ten Napel.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <copyright-holder>Freudenberg, Vandenplas, Schlather, Pook, Evans and Ten Napel</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY). The use, distribution or reproduction in other forums is permitted, provided the original author(s) and the copyright owner(s) are credited and that the original publication in this journal is cited, in accordance with accepted academic practice. No use, distribution or reproduction is permitted which does not comply with these terms.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>In the last decade, a number of methods have been suggested to deal with large amounts of genetic data in genomic predictions. Yet, steadily growing population sizes and the suboptimal use of computational resources are pushing the practical application of these approaches to their limits. As an extension to the C/CUDA library <italic>miraculix</italic>, we have developed tailored solutions for the computation of genotype matrix multiplications which is a critical bottleneck in the empirical evaluation of many statistical models. We demonstrate the benefits of our solutions at the example of single-step models which make repeated use of this kind of multiplication. Targeting modern Nvidia<sup>®</sup> GPUs as well as a broad range of CPU architectures, our implementation significantly reduces the time required for the estimation of breeding values in large population sizes. <italic>miraculix</italic> is released under the Apache 2.0 license and is freely available at <ext-link xlink:href="https://github.com/alexfreudenberg/miraculix" ext-link-type="uri">https://github.com/alexfreudenberg/miraculix</ext-link>.</p>
    </abstract>
    <kwd-group>
      <kwd>GPU</kwd>
      <kwd>SNP</kwd>
      <kwd>high-performance computing</kwd>
      <kwd>genomic data</kwd>
      <kwd>single-step model</kwd>
      <kwd>quantitative genomics</kwd>
    </kwd-group>
    <funding-group>
      <funding-statement>Analyses in this article were performed on the HPC systems bwUniCluster and Helix funded by the state of Baden-Württemberg through bwHPC and the German Research Foundation (DFG) through grant INST 35/1597-1 FUGG. AF acknowledges financial support from the Research Training Group “Statistical Modeling of Complex Systems” funded by the German Science Foundation. The publication of this article was funded by the University of Mannheim.</funding-statement>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>section-at-acceptance</meta-name>
        <meta-value>Computational Genomics</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="s1">
    <title>1 Introduction</title>
    <p>Over the past 15 years, the incorporation of genomic information has become essential for ensuring progress in breeding (<xref rid="B24" ref-type="bibr">Schaeffer, 2006</xref>). A routine task in animal breeding is the estimation of breeding values within a population, that is, the estimation of the average additive effects of the alleles that an individual passes on to its offspring. Though breeding values are estimated most accurately through the use genomic data, it is usually too costly to genotype a whole population. This is particularly true when analyzing large populations, like national dairy evaluations with millions of animals (<xref rid="B18" ref-type="bibr">Misztal et al., 2022</xref>). This circumstance has sparked a debate on how to combine pedigree information of ungenotyped animals with Single Nucleotide Polymorphism (SNP) data of genotyped animals to analyze phenotypic records.</p>
    <p>Due to its desirable statistical properties, the single-step genomic BLUP (ssGBLUP) model (<xref rid="B10" ref-type="bibr">Legarra et al., 2009</xref>; <xref rid="B3" ref-type="bibr">Christensen and Lund, 2010</xref>) has gained popularity in animal breeding, combining both the genomic relationship matrix (GRM) <bold>G</bold> and the pedigree-based relationship matrix <bold>A</bold> into a generalized relationship matrix <bold>H</bold>. Large population sizes used in animal breeding programs, ranging from tens of thousands to millions of individuals, have motivated research in computational strategies to solve the associated mixed model equations (MME) efficiently through the use of high-performance computing (HPC) techniques. One of the proposed approaches is the algorithm for Proven and Young Animals (APY), which approximates the inverse of the GRM, <bold>G</bold>
<sup>−1</sup>, through genomic recursion on a subset of core animals (<xref rid="B17" ref-type="bibr">Misztal et al., 2014</xref>). As an alternative concept, the original ssGBLUP model was reformulated to, first, allow the use of well-established numerical software (<xref rid="B9" ref-type="bibr">Legarra and Ducrocq, 2012</xref>) and, second, avoid the explicit construction and inversion of the GRM <bold>G</bold> using the Woodbury decomposition. The resulting models were coined single-step GT(A)BLUP models (<xref rid="B12" ref-type="bibr">Mäntysaari et al., 2017</xref>; <xref rid="B13" ref-type="bibr">Mäntysaari et al., 2020</xref>). Additionally, single-step SNP BLUP (ssSNPBLUP) models were proposed to estimate SNP effects directly, similarly avoiding <bold>G</bold> and its inverse (<xref rid="B5" ref-type="bibr">Fernando et al., 2014</xref>; <xref rid="B11" ref-type="bibr">Liu et al., 2014</xref>; <xref rid="B27" ref-type="bibr">Taskinen et al., 2017</xref>).</p>
    <p>Considering the computational aspects of these approaches, the use of highly-optimized sparse matrix operations has been established, thanks to the sparse characteristics of the pedigree-based relationship matrix. Additionally, established iterative-solver algorithms [e.g., the preconditioned conjugate gradient (PCG)] can be employed in the resulting equation systems (<xref rid="B25" ref-type="bibr">Strandén and Lidauer, 1999</xref>; <xref rid="B16" ref-type="bibr">Misztal et al., 2009</xref>) to avoid explicit construction of the full coefficient matrix.</p>
    <p>Nevertheless, the computational load of the remaining mathematical operations and slow PCG convergence have been somewhat prohibitive to the application of ssGTABLUP and ssSNPBLUP models in ultra-large-scale settings. To mitigate this issue, a number of numerical advances have been proposed to improve convergence speed (<xref rid="B30" ref-type="bibr">Vandenplas et al., 2018</xref>). So far, however, improvements in accelerating the involved matrix arithmetics have been limited to the application of shared-memory parallel libraries, such as the Intel<sup>®</sup> Math Kernel Library (MKL) and PARDISO (<xref rid="B1" ref-type="bibr">Alappat et al., 2020</xref>), and unpacking the compressed SNP matrix <bold>M</bold> into the CPU cache for the matrix-matrix product in the PCG iteration (<xref rid="B16" ref-type="bibr">Misztal et al., 2009</xref>; <xref rid="B31" ref-type="bibr">Vandenplas et al., 2020</xref>). Bit-level algorithms have been employed by, for instance, the popular PLINK software (<xref rid="B2" ref-type="bibr">Chang et al., 2015</xref>) in the efficient implementation of genome-wide association studies (GWAS), which rely on similar genotype matrix operations. Yet, these routines are not accessible for use in single-step BLUP evaluations. The software PLINK also implements BLAS-based routines for the calculation of <bold>G</bold> on a Nvidia<sup>®</sup> GPU in its version 2.0. However, this functionality works on uncompressed SNP data stored in single-precision floating-point values, thereby significantly limiting possible problem sizes. Other authors have used GPUs to accelerate model training for machine learning algorithms in genomic selection (<xref rid="B34" ref-type="bibr">Xu et al., 2021</xref>). In parallel to this work, efficient approaches for the multiplication of matrices of mixed input data types have been suggested for use in transformer machine learning models, in particular with sub-byte integer data formats (<xref rid="B8" ref-type="bibr">Kim et al., 2022</xref>).</p>
    <p>In this study, we present tailored algorithms for the multiplication of a compressed SNP matrix by a matrix of small width stored in floating-point format for CPUs and Nvidia<sup>®</sup> GPUs. Our CPU code is optimized for all major instruction set architectures. To take advantage of the instruction-level parallelism capabilities of modern CPUs, our implementation uses Single Instruction-stream Multiple Data-stream (SIMD) operations explicitly (<xref rid="B26" ref-type="bibr">Tanenbaum, 2016</xref>). Extending the Nvidia<sup>®</sup> CUTLASS library (<xref rid="B29" ref-type="bibr">Thakkar et al., 2023</xref>), our GPU approach benefits from fast tile iterators in the data movement during the matrix-matrix multiplication.</p>
    <p>We demonstrate how these advances can drastically reduce the computing times of genotype matrix multiplications on CPUs and GPUs compared to double-precision matrix multiplication routines provided by the Intel<sup>®</sup> MKL, while simultaneously reducing memory requirements. We provide scripts for reproducing our results in the GitHub repository. Additionally, using genomic data provided by the Irish Cattle Breeding Federation and the genetic evaluation software MiXBLUP (<xref rid="B28" ref-type="bibr">ten Napel et al., 2021</xref>), we show how our novel approaches bring down total run times in solving single-step evaluations by up to 62%, thereby paving the way to include even larger population sizes in genomic evaluations.</p>
    <p>We provide our implementation as part of the C/CUDA software library <italic>miraculix</italic> (<ext-link xlink:href="https://github.com/alexfreudenberg/miraculix" ext-link-type="uri">https://github.com/alexfreudenberg/miraculix</ext-link>). Interfaces to call the library from higher-level languages such as Fortran, R and Julia are provided. Through the modular structure of the <italic>miraculix</italic> library, which also supplies functions for the calculation of <bold>G</bold>, the code should be easily modifiable by researchers and practitioners interested in accelerating computations in other BLUP models (<xref rid="B14" ref-type="bibr">Meuwissen et al., 2001</xref>; <xref rid="B33" ref-type="bibr">VanRaden, 2008</xref>) or other genomic analyses.</p>
  </sec>
  <sec sec-type="methods" id="s2">
    <title>2 Methods</title>
    <p>The efficient multiplication of the genotype matrix by a double-precision matrix plays an important role in many genomic analyses. In this section, we explain how this multiplication can be decomposed to reduce the computational costs involved. Then, we propose novel techniques for the multiplication of a compressed SNP matrix with a double-precision matrix on CPUs and GPUs. We illustrate the role of an efficient genotype matrix multiplication at the example of single-step models. Lastly, we describe the methodology which we used for evaluating our approaches.</p>
    <sec id="s2-1">
      <title>2.1 Computational bottlenecks</title>
      <p>We consider the commonly encountered operation of multiplying the centered SNP matrix <bold>Z</bold>, or its transpose <bold>Z</bold>′, by a matrix of low width. Here, the matrix <bold>Z</bold> can be computed as<disp-formula id="equ1"><mml:math id="m1" overflow="scroll"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="bold">M</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:math></disp-formula>where <inline-formula id="inf1"><mml:math id="m2" overflow="scroll"><mml:mi mathvariant="bold">M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mn>0,1,2</mml:mn></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>s</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:math></inline-formula> denotes the uncentered genotype matrix containing the <italic>n</italic>
<sub>s</sub> SNP genotypes (coded as 0 for one homozygous genotype, 1 for the heterozygous genotype, or 2 for the alternate homozygous genotype) of <italic>n</italic>
<sub>g</sub> genotyped animals. Furthermore, <bold>p</bold> denotes the vector of allele frequencies and the subtraction of <inline-formula id="inf2"><mml:math id="m3" overflow="scroll"><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> centers the columns of <bold>M</bold>.</p>
      <p>Considering an arbitrary matrix <inline-formula id="inf3"><mml:math id="m4" overflow="scroll"><mml:mi mathvariant="bold">Λ</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>s</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>, we first note that the multiplication of <bold>Z</bold> with <bold>Λ</bold> can be reformulated into<disp-formula id="equ2"><mml:math id="m5" overflow="scroll"><mml:mi mathvariant="bold">Z</mml:mi><mml:mi mathvariant="bold">Λ</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="bold">M</mml:mi><mml:mi mathvariant="bold">Λ</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold">Λ</mml:mi><mml:mo>.</mml:mo></mml:math></disp-formula>
</p>
      <p>Since subtracting the matrix <inline-formula id="inf4"><mml:math id="m6" overflow="scroll"><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold">Λ</mml:mi></mml:math></inline-formula> consists of a vector-matrix multiplication and subsequent additions of matrices of rank one, it is computationally cheap and can be achieved with BLAS Level-1 operations. The multiplication of the transposed matrix <inline-formula id="inf5"><mml:math id="m7" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> with an arbitrary matrix <inline-formula id="inf6"><mml:math id="m8" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> is decomposed similarly into<disp-formula id="equ3"><mml:math id="m9" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">M</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mi mathvariant="bold">p</mml:mi><mml:msubsup><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mo>.</mml:mo></mml:math></disp-formula>
</p>
      <p>Here, we use the distinction between <bold>Λ</bold> and <inline-formula id="inf7"><mml:math id="m10" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> to emphasize that <bold>Z</bold> and <bold>Z</bold>′ cannot be multiplied with the same matrix because they have different dimensions. Due to the low cost of SNP genotyping, the matrix <bold>M</bold> can have extremely large dimensions, capturing the genomic information of millions of animals. Furthermore, whereas <bold>Λ</bold> is a regular matrix of double-precision, the SNP matrix is usually stored in a compressed format to save memory. For instance, the PLINK 1 binary file format stores the genotypes of four individuals in eight bits (corresponding to one byte), utilizing that one entry of <bold>M</bold> only requires two bits of storage. This compressed data format prevents naive calls to BLAS routines, and decompressing it explicitly is inefficient and increases memory requirements. Only recently, the problem of matrix multiplication of mixed input data types has gained attention (<xref rid="B8" ref-type="bibr">Kim et al., 2022</xref>) and no off-the-shelf solution exists for compressed 2-bit integer data types.</p>
      <p>In general, algorithms for genotype matrix multiplications that operate on compressed data can be expected to be more efficient due to the better utilization of memory movements. In cases where the multiplication <bold>ZΛ</bold> needs to be evaluated repeatedly for varying <bold>Λ</bold>, an optional conversion of the uncentered SNP matrix <bold>M</bold> to a different storage format is comparatively cheap. Therefore, switching the storage format has the potential to yield efficiency gains.</p>
    </sec>
    <sec id="s2-2">
      <title>2.2 Acceleration of the genotype matrix-matrix multiplication</title>
      <sec id="s2-2-1">
        <title>2.2.1 Previous approach</title>
        <p><xref rid="B31" ref-type="bibr">Vandenplas et al. (2020)</xref> proposed a decompress-on-the-fly approach, consisting of unpacking tiles of submatrices of <bold>M</bold> small enough to store the result in the cache and perform matrix multiplication on these tiles. Briefly, modern computer architecture implements different levels of cache memory (commonly, L1, L2, and L3) to reduce access times to repeatedly processed data. While infrequently used data can be stored in the random access memory (RAM) or even on the disk, accessing it over the memory bus combined with the lower clock cycles of the RAM compared to the CPU dramatically slows down the execution of the program. While low levels of cache close to the core allow faster memory reads, they come with lower capacity (<xref rid="B26" ref-type="bibr">Tanenbaum, 2016</xref>). Hence, efficient code which processes large amounts of data strives to reduce data movement along the memory hierarchy and utilizes the fast access times of low-level caches. In the aforementioned local decompression approach by <xref rid="B31" ref-type="bibr">Vandenplas et al. (2020)</xref>, small submatrices of SNP data in PLINK 1 binary format are sequentially converted to double-precision floating-point values. Since these small submatrices are used repeatedly in a loop, they should not be evicted from the L1 cache. Therefore, the unpacked SNP data is readily at hand when new tiles of <bold>Λ</bold> are loaded and can be multiplied without additional conversion operations.</p>
      </sec>
      <sec id="s2-2-2">
        <title>2.2.2 The <italic>5codes</italic> algorithm for CPUs</title>
        <p>Building on the idea of keeping frequently used data close to the core, our novel approach for CPU computations aims to reduce data streams of <bold>Λ</bold> through the cache hierarchy by fully avoiding decompression. To explain this approach, we assume that there are no missing values at this point. Instead, they are coded as zero and their effect is taken into account when subtracting <inline-formula id="inf8"><mml:math id="m11" overflow="scroll"><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold">Λ</mml:mi></mml:math></inline-formula> or <inline-formula id="inf9"><mml:math id="m12" overflow="scroll"><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> later. Since the number of missing values is usually not substantial, this correction comes at a low cost.</p>
        <p>We view the problem of storing compressed SNP data through the lens of combinatorics: Since there are only three possible states (0, 1, and 2) for a SNP, any vector <bold>m</bold> ∈ {0,1,2}<sup>5</sup> of five contiguous SNPs can assume only one of 3<sup>5</sup> = 243 values. Assuming there are no missing values, this format requires only 80% of the memory required for storing SNP values in 2 bits. Hence, each realized vector <bold>m</bold> can be stored in one 8-bit unsigned integer while preserving the order of the SNPs. During preprocessing, we convert the input data to this compressed format, which we coined <italic>5codes</italic>. At multiplication time, we treat the columns of <bold>Λ</bold> separately and load a vector <inline-formula id="inf10"><mml:math id="m13" overflow="scroll"><mml:mi mathvariant="bold">λ</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> of five entries in a column of <bold>Λ</bold>, which is stored in double precision. Subsequently, we compute all possible results of the scalar product<disp-formula id="equ4"><mml:math id="m14" overflow="scroll"><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">m</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold-italic">λ</mml:mi><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mtext>for</mml:mtext><mml:mspace width="0.3333em"/><mml:mi mathvariant="bold">m</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mfenced open="{" close="}"><mml:mrow><mml:mn>0,1,2</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:math></disp-formula>and store them in a hash table. Then, we iterate over the five columns of <bold>M</bold> under consideration and look up the values of <bold>x</bold> depending on the realization of <bold>m</bold>. We provide pseudo-code for one iteration of this approach in <xref rid="alg1" ref-type="statement">Algorithm 1</xref>. The multiplication <inline-formula id="inf11"><mml:math id="m15" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">M</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is achieved analogously.</p>
        <p>It is worth noting that at least 16 of these tables fit into the L1 cache because each hash table holds 3<sup>5</sup> = 243 double-precision values of 64 bits and the L1 cache in modern CPU architectures typically holds between 32 and 96 KB. Since the hash table of the different values of <bold>x</bold> only needs to be computed once for every five-row tile of <bold>Λ</bold>, we keep register instructions to a minimum. Furthermore, compressed matrix values are loaded into integer registers whereas real values are stored in SIMD registers. The implementation aims to optimize load operations and store operations. For instance, if SIMD registers of 256-bit width are available, one entry of the hash table contains a vector of four double-precision floating-point values.</p>
        <p>The computation is parallelized among the available processor cores by splitting <bold>M</bold> and <bold>Λ</bold> into chunks along the column axis and row axis respectively. Finally, the results of each thread are united by a single reduction operation at the end that computes the sum of all individual results.</p>
        <p>As discussed above, genotype centering is not a bottleneck due to its low complexity. Thanks to the structure of the <italic>5codes</italic> encoding, the centering can actually be included in the hash table for the operation <bold>ZΛ</bold>, meaning that instead of holding the possible values of <bold>m</bold>′<bold><italic>λ</italic></bold>, the hash table can store the centered values<disp-formula id="equ5"><mml:math id="m16" overflow="scroll"><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold">λ</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">m</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold">λ</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold-italic">λ</mml:mi><mml:mo>.</mml:mo></mml:math></disp-formula>
</p>
        <p>Subtracting 2 ⋅<bold>p<italic>′λ</italic>
</bold> at this point further reduces the number of memory accesses and decreases numerical accumulation errors.</p>
        <p>
          <statement content-type="algorithm" id="alg1">
            <label>Algorithm 1</label>
            <p>Pseudo-code for the <italic>5codes</italic> algorithm for the multiplication of five columns of SNPs <bold>M</bold> with a vector <italic><bold>λ</bold></italic> of length 5. The multiplication of five columns of <bold>M<italic>′</italic>
</bold> is analogous. Note that the variable <monospace>idx</monospace> in the algorithm is smaller than 243. For a general number of SNPs <italic>n</italic>
<sub>s</sub>, five columns of <bold>M</bold> are multiplied at a time.<list list-type="simple"><list-item><p><bold>Data:</bold> Compressed SNP matrix <inline-formula id="inf12"><mml:math id="m17" overflow="scroll"><mml:mi mathvariant="bold">M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mn>0,1,2</mml:mn></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula>, floating-point vector <inline-formula id="inf13"><mml:math id="m18" overflow="scroll"><mml:mi mathvariant="bold-italic">λ</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula>
</p></list-item><list-item><p><bold>Result:</bold> Genotype matrix multiplication <bold>x = M<italic>λ</italic>
</bold>
</p></list-item><list-item><p><bold>1</bold><monospace>/* Compute and store the dot products of </monospace><bold><italic>λ</italic></bold><monospace> with all possible SNP vectors */</monospace></p></list-item><list-item><p><bold>2 for</bold><bold>m</bold> ∈ {0,1,2}<sup>5</sup> <bold>do</bold>
</p></list-item><list-item><p><bold>3</bold>   <sans-serif>idx</sans-serif> ← <bold>m</bold>
<sub>1</sub> × 3<sup>0</sup> + <bold>m</bold>
<sub>2</sub> × 3<sup>1</sup> + <bold>m</bold>
<sub>3</sub> × 3<sup>2</sup> + <bold>m</bold>
<sub>4</sub> × 3<sup>3</sup> + <bold>m</bold>
<sub>5</sub> × 3<sup>4</sup>
</p></list-item><list-item><p><bold>4 </bold><monospace>  /* Compute and store </monospace><bold>m</bold>′<italic>λ</italic><monospace>*/</monospace></p></list-item><list-item><p><bold>5 </bold><sans-serif>  table[</sans-serif><sans-serif>idx</sans-serif><sans-serif>]</sans-serif> ← <bold>m</bold>
<sub>1</sub> × <italic><bold>λ</bold></italic>
<sub>1</sub> + <bold>m</bold>
<sub>2</sub> × <italic><bold>λ</bold></italic>
<sub>2</sub> + <bold>m</bold>
<sub>3</sub> × <italic><bold>λ</bold></italic>
<sub>3</sub> + <bold>m</bold>
<sub>4</sub> × <italic><bold>λ</bold></italic>
<sub>4</sub> + <bold>m</bold>
<sub>5</sub> × <italic><bold>λ</bold></italic>
<sub>5</sub>
</p></list-item><list-item><p><bold>6 end</bold></p></list-item><list-item><p><bold>7</bold><monospace>/* Compute</monospace><bold>M<italic>λ</italic>
</bold><monospace>by looking up the realization of</monospace><bold>m</bold><monospace>in the matrix</monospace><bold>M</bold><monospace>. */</monospace></p></list-item><list-item><p><bold>8 for</bold> <italic>j</italic> ← 1 <bold><italic>to </italic></bold>
<italic>n</italic>
<sub>g</sub>
<bold>do</bold>
</p></list-item><list-item><p><bold>9 </bold>  <sans-serif>key</sans-serif> ←<bold>M</bold>
<sub><italic>j</italic>,1</sub> × 3<sup>0</sup> + <bold>M</bold>
<sub><italic>j</italic>,2</sub> × 3<sup>1</sup> + <bold>M</bold>
<sub><italic>j</italic>,3</sub> × 3<sup>2</sup> + <bold>M</bold>
<sub><italic>j</italic>,4</sub> × 3<sup>3</sup> + <bold>M</bold>
<sub><italic>j</italic>,5</sub> × 3<sup>4</sup>
</p></list-item><list-item><p><bold>10</bold>   <italic>x</italic>[<italic>j</italic>] ← <sans-serif>table[</sans-serif>
<sans-serif>key</sans-serif>
<sans-serif>]</sans-serif>
</p></list-item><list-item><p><bold>11 end</bold></p></list-item></list>
</p>
          </statement>
        </p>
      </sec>
      <sec id="s2-2-3">
        <title>2.2.3 SNP matrix multiplication with mixed data types on GPUs</title>
        <p>To make use of the powerful HPC capabilities of modern Nvidia<sup>®</sup> GPUs, we also implement a matrix multiplication routine in CUDA, in which we extend the CUTLASS library (<xref rid="B29" ref-type="bibr">Thakkar et al., 2023</xref>) in its version 2.10. CUTLASS is a C++ template library for high-performance matrix operations on Nvidia<sup>®</sup> GPUs. In contrast to CPU operations, GPU functions need to align parallel operations both within thread blocks as well as within warps of threads (<xref rid="B21" ref-type="bibr">Sanders and Kandrot, 2010</xref>). CUTLASS assists this task by providing a framework that allows software solutions to target only a subset of levels in this hierarchy. In our case, we implement a template specialization for the Single Instruction Multiple Threads (SIMT) subsection within warp-level API in CUTLASS. Since computing times for our GPU approach are mostly driven by data movements instead of algebraic operations, we do not make use of the <italic>5codes</italic> algorithm in this implementation but distribute scalar products of four-dimensional vectors to the cores of the GPU. Therefore, we keep the established PLINK 8-bit-sized format for storing a four-dimensional vector corresponding to four SNPs, where each SNP is coded as either 0 for the homozygous genotype, 1 for a missing genotype, 2 for the heterozygous genotype and 3 for the alternate homozygous genotype. For compatibility with CUTLASS, we introduce a new interleaved data type for double-precision vectors of size four. Furthermore, fitting the genotype matrix multiplication into the CUTLASS framework requires adding a new scalar-product microkernel for this specific combination of data types and adjusting the CUTLASS interfaces upstream accordingly. The microkernel uses bitmasks to extract the SNP values from the compressed storage format and converts them into double-precision floating-point values for immediate multiplication afterward. Through the highly efficient memory access iterators in CUTLASS, we are able to move data quickly from the device memory to the shared memory to the cores and back. Furthermore, in order to reduce memory allocations and data movement between the host and the device, we preallocate memory for the matrix <bold>Λ</bold> and transfer data objects which are required in every PCG iteration (that is, <bold>M</bold> and <bold>p</bold>) only once at start-up time. To our knowledge, this is the first implementation of matrix multiplication of 2-bit integers with double-precision floating-point values, which we designed in parallel to the recent work of <xref rid="B8" ref-type="bibr">Kim et al. (2022)</xref> who extended the CUTLASS library to include, among others, matrix multiplication of 4-bit integers with half-precision floating-point values.</p>
      </sec>
      <sec id="s2-2-4">
        <title>2.2.4 Memory management</title>
        <p>Since both the CPU and GPU approaches exploit a compressed storage format for the SNP matrix, the question arises of how to efficiently calculate the transposed matrix product <inline-formula id="inf14"><mml:math id="m19" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">M</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. A memory-efficient implementation would transpose chunks of <bold>M</bold> of low dimension which are iterated over. For instance, transposing sub-matrices of dimensions 16 by 16 in PLINK 1 binary format would allow distributing the transpose operation in a warp of threads on a GPU. However, thanks to the compressed data storage, we are not memory-bound with the current number of genotyped animals and SNPs, and we, therefore, choose to transpose <bold>M</bold> as a whole during start-up and store it separately to reduce computation time associated with transposition. For instance, the dataset of 2.61 m animals with 47 k SNP markers we use in this article for testing purposes only requires about 57 gigabytes of RAM for both <bold>M</bold> and <bold>M</bold>′ combined.</p>
      </sec>
    </sec>
    <sec id="s2-3">
      <title>2.3 SNP matrix multiplications in single-step models</title>
      <p>Single-step models in animal breeding programs commonly comprise hundreds of thousands or even millions of animals. Therefore, the MME for these models need to be solved iteratively in practice, commonly through the PCG algorithm. To this end, each iteration requires multiplying the corresponding coefficient matrix with a candidate vector.</p>
      <p>To illustrate the necessity of a fast genotype matrix multiplication, we give an overview of the matrix operations involved in the ssSNPBLUP approach, proposed by <xref rid="B11" ref-type="bibr">Liu et al. (2014)</xref>, and the ssGTABLUP approach, introduced by <xref rid="B12" ref-type="bibr">Mäntysaari et al. (2017)</xref>. Both univariate models can be easily extended to multivariate applications. The numerical treatment of these approaches is described in detail by <xref rid="B32" ref-type="bibr">Vandenplas et al. (2023)</xref> who found that they have similar computational costs per iteration when applied to large datasets since they require the same matrix computations.</p>
      <p>A standard univariate mixed model for ssGBLUP can be written as:<disp-formula id="equ6"><mml:math id="m20" overflow="scroll"><mml:mi mathvariant="bold">y</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="bold">X</mml:mi><mml:mi mathvariant="bold">b</mml:mi><mml:mo>+</mml:mo><mml:mfenced open="[" close="]"><mml:mrow><mml:mtable class="matrix"><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="center"><mml:mn mathvariant="bold">0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mn mathvariant="bold">0</mml:mn></mml:mtd><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced open="[" close="]"><mml:mrow><mml:mtable class="matrix"><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">u</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">u</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi mathvariant="bold">e</mml:mi></mml:math></disp-formula>where <bold>y</bold> is the vector of records, <bold>b</bold> is the vector of <italic>n</italic>
<sub>fixed</sub> fixed effects, <bold>u</bold>
<sub><italic>n</italic></sub> is the vector of additive genetic effects for the non-genotyped animals, <bold>u</bold>
<sub><italic>g</italic></sub> is the vector of additive genetic effects for the genotyped animals, and <bold>e</bold> is the vector of residuals. The matrices <bold>X</bold>, <bold>W</bold>
<sub><italic>n</italic></sub>, and <bold>W</bold>
<sub><italic>g</italic></sub> are incidence matrices relating records in <bold>y</bold> to the corresponding effects. The random effects vector <bold>u</bold>
<sub><italic>g</italic></sub> can be decomposed into <bold>u</bold>
<sub><italic>g</italic></sub> = <bold>a</bold>
<sub><italic>g</italic></sub> + <bold>Zg</bold>, where <bold>g</bold> is the vector of SNP effects and <bold>a</bold>
<sub><italic>g</italic></sub> contains the residual polygenic effects.</p>
      <p>Due to the assumed covariance structure, the ssSNPBLUP system of equations proposed by <xref rid="B11" ref-type="bibr">Liu et al. (2014)</xref> involves the matrix <bold>Σ</bold>
<sup>−1</sup> defined as<disp-formula id="equ7"><mml:math id="m21" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Σ</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"><mml:mrow><mml:mtable class="matrix"><mml:mtr><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd columnalign="center"><mml:mn mathvariant="bold">0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mtd><mml:mtd columnalign="center"><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mi mathvariant="bold">Z</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mn mathvariant="bold">0</mml:mn></mml:mtd><mml:mtd columnalign="center"><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mtd><mml:mtd columnalign="center"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:mi mathvariant="bold">I</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:msubsup><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:math></disp-formula>where the scalar <inline-formula id="inf15"><mml:math id="m22" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:math></inline-formula> is the inverse of the additive genetic variance, <italic>w</italic> between 0 and 1 is the proportion of variance not explained by SNP markers, called residual polygenic effects, and <inline-formula id="inf16"><mml:math id="m23" overflow="scroll"><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msubsup><mml:mrow><mml:mo movablelimits="false" form="prefix">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>s</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mfenced open="(" close=")"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula> for <inline-formula id="inf17"><mml:math id="m24" overflow="scroll"><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>s</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi mathvariant="bold">p</mml:mi></mml:math></inline-formula>. Furthermore, the matrix<disp-formula id="equ8"><mml:math id="m25" overflow="scroll"><mml:mi mathvariant="bold">A</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"><mml:mrow><mml:mtable class="matrix"><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:math></disp-formula>denotes the pedigree-based relationship matrix and<disp-formula id="equ9"><mml:math id="m26" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"><mml:mrow><mml:mtable class="matrix"><mml:mtr><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>.</mml:mo></mml:math></disp-formula>is its inverse, which is sparse (<xref rid="B7" ref-type="bibr">Henderson, 1976</xref>). Here, <italic>n</italic> and <italic>g</italic> denote non-genotyped and genotyped animals respectively. The inverse of <bold>A</bold>
<sub><italic>gg</italic></sub> can be computed as<disp-formula id="equ10"><mml:math id="m27" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mfenced open="(" close=")"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:math></disp-formula>
</p>
      <p>Because the coefficient matrices of the ssSNPBLUP and ssGTABLUP models are too large to be constructed explicitly, it is decomposed into submatrices which are multiplied separately (<xref rid="B31" ref-type="bibr">Vandenplas et al., 2020</xref>). Importantly, most of these submatrices (e.g., <bold>A</bold>
<sup><italic>nn</italic></sup>, <bold>A</bold>
<sup><italic>ng</italic></sup>, <bold>A</bold>
<sup><italic>gn</italic></sup>, <bold>A</bold>
<sup><italic>gg</italic></sup>) in <bold>Σ</bold>
<sup>−1</sup> are sparse and can be multiplied by a vector or a matrix at a relatively low cost by using iteration-on-data techniques (<xref rid="B23" ref-type="bibr">Schaeffer and Kennedy, 1986</xref>) and sparse matrix operations (<xref rid="B10" ref-type="bibr">Legarra et al., 2009</xref>; <xref rid="B31" ref-type="bibr">Vandenplas et al., 2020</xref>). Additionally, although the matrix <inline-formula id="inf18"><mml:math id="m28" overflow="scroll"><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> is not sparse in general, equation systems involving <inline-formula id="inf19"><mml:math id="m29" overflow="scroll"><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> can be solved by using forward and backward substitution techniques with the Cholesky factor of <bold>A</bold>
<sup><italic>nn</italic></sup>, which only needs to be computed once. Therefore, this calculation is also not computationally demanding in practice. In contrast, the multiplication of <bold>Z</bold> by an arbitrary matrix of low width <bold>Λ</bold> has been a computational bottleneck so far.</p>
    </sec>
    <sec id="s2-4">
      <title>2.4 Evaluation</title>
      <p>Since both the <italic>5codes</italic> algorithm and our GPU approach take advantage of modern hardware architectures, it can be expected that they outperform the existing implementations. To quantify the benefits, we used simulated data to benchmark our concepts for genotype data of various sizes. Afterward, considering the ssSNPBLUP and ssGTABLUP systems of equations on a large population of Irish beef and dairy cattle, we evaluated the wall clock times for estimating the breeding values in this population using the PCG implementation in the software MiXBLUP (<xref rid="B28" ref-type="bibr">ten Napel et al., 2021</xref>). We compared our novel approaches with the wall clock time required by the current Fortran-based matrix multiplication implementation in MiXBLUP.</p>
      <sec id="s2-4-1">
        <title>2.4.1 Simulated data</title>
        <p>For benchmarking our two novel approaches, we simulated genotype data of various dimensions using the software suite PLINK (<xref rid="B2" ref-type="bibr">Chang et al., 2015</xref>). Mimicking the population sizes of many breeding programs in practice, we generated genotype data of three distinct animal populations with a varying number of individuals: a small population with 102 k animals, a medium population with 751 k animals and a large population with 3.1 m animals. For each population, 50,241 SNPs were simulated, resulting in memory requirements of approx. 1.2 GB in compressed storage format (38.2 GB in double-precision) for the small population, 8.8 GB (281.2 GB) for the medium population, and 36.3 GB (1,160.6 GB) for the large population. Furthermore, we simulated a matrix <bold>Λ</bold> of 10 normally distributed traits.</p>
      </sec>
      <sec id="s2-4-2">
        <title>2.4.2 Cattle data</title>
        <p>We tested our two novel approaches when integrated into the PCG solver using data from the routine six-trait calving-difficulty evaluation for Irish dairy and beef cattle performed by Irish Cattle Breeding Federation (ICBF; Ireland) in March 2022. We solved the equation systems associated with the ssSNPBLUP and ssGTABLUP models. The single-step genomic evaluations were based on the same multi-trait animal model and variance components as the current official routine breeding value evaluation described in more detail in <xref rid="B4" ref-type="bibr">Evans et al. (2019)</xref> and <xref rid="B32" ref-type="bibr">Vandenplas et al. (2023)</xref>. Briefly, after extraction and editing, the data file included 16.59 m data records (across 6 traits), and the pedigree included 26.46 m animals. The genotypes of 2.61 m animals included 47,006 SNP markers from 29 bovine autosomes, with a minor allele frequency greater or equal to 0.01. The genotype data were from a range of 30 different arrays ranging from 3 to 850 k SNPs that had been imputed using FImpute (<xref rid="B22" ref-type="bibr">Sargolzaei et al., 2014</xref>) to a 50 k SNP set based on version 3 of the International Beef and Dairy (IDB) chip. For both single-step approaches, the genotype matrix was centered using observed allele frequencies and the proportion of residual polygenic effects was set to <italic>w</italic> = 0.20.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="results" id="s3">
    <title>3 Results</title>
    <sec id="s3-1">
      <title>3.1 Benchmarks</title>
      <p>In <xref rid="F1" ref-type="fig">Figure 1</xref>, we assess the performance of consecutively multiplying <bold>ZΛ</bold> and <inline-formula id="inf20"><mml:math id="m30" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, as required in each iteration of a PCG solver. We compare our implementation of the <italic>5codes</italic> algorithm and the GPU implementation with two alternative solutions: 1) The decompress-on-the-fly approach implemented in Fortran and proposed by <xref rid="B31" ref-type="bibr">Vandenplas et al. (2020)</xref>, which we will call “original solution” below, and 2) a single call to the double-precision matrix multiplication function (<monospace>dgemm</monospace>) which is part of all major BLAS libraries. As for the latter, we first needed to inflate the full SNP matrix to double-precision floating-point values and store both the SNP matrix as well as its transpose in memory. We use the BLAS library included in the Intel<sup>®</sup> Math Kernel Library (MKL). For compilation, we used the Intel<sup>®</sup> compiler in its version 2021.4.0 and employed compilation options to natively optimize our code to the available hardware. We ran our CPU benchmarks on a single AMD<sup>®</sup> Milan EPYC 7513 (2.6 GHz) CPU and our GPU implementation on an Nvidia<sup>®</sup> H100. Since our implementation of the <italic>5codes</italic> algorithm did not display considerable scalability advances beyond 20 cores (see <xref rid="T1" ref-type="table">Table 1</xref>) and the software MiXBLUP recommends a similar number of cores for parallelizing computations, we refrain from testing it on more cores.</p>
      <fig position="float" id="F1">
        <label>FIGURE 1</label>
        <caption>
          <p>Total wall clock time for consecutively calculating <bold>ZΛ</bold> and <inline-formula id="inf21"><mml:math id="m31" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> on a system with a dual-socket AMD<sup>®</sup> Milan EPYC 7513 (2.6 GHz) processor, 2 TB of RAM and a single Nvidia<sup>®</sup> H100 GPU. Annotations show formatted computing times in seconds. CPU calculations used 20 dedicated cores. No test was performed for the BLAS routine with the large population size, as this would have required ca. 2.27 TB of RAM. Results are the average of 10 repeated calculations.</p>
        </caption>
        <graphic xlink:href="fgene-14-1220408-g001" position="float"/>
      </fig>
      <table-wrap position="float" id="T1">
        <label>TABLE 1</label>
        <caption>
          <p>Computation wall clock times in seconds of the GPU implementation and the CPU algorithm <italic>5codes</italic> for the multiplication of the genotype matrix Z and its transposed Z′ with simulated matrices Λ and <inline-formula id="inf22"><mml:math id="m32" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. CPU operations were performed with 2 TB of RAM on the Intel<sup>®</sup> Xeon Gold 6230 (2.1 GHz) and the AMD<sup>®</sup> EPYC 7513 (2.6 GHz) on 1 core, 10 cores and 20 cores. The V100 GPUs were equipped with 32 GB of device memory, while the A100 and H100 models had a capacity of 80 GB. Dashes (−) indicate out-of-memory events. Results are the average of 10 repeated calculations.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead valign="top">
            <tr>
              <th align="left" rowspan="1" colspan="1">Population</th>
              <th rowspan="2" align="left" colspan="1">Operation</th>
              <th colspan="3" align="center" rowspan="1">Nvidia<sup>®</sup>
</th>
              <th colspan="3" align="center" rowspan="1">Intel<sup>®</sup>
</th>
              <th colspan="3" align="center" rowspan="1">AMD<sup>®</sup>
</th>
            </tr>
            <tr>
              <th align="left" rowspan="1" colspan="1">Size</th>
              <th align="left" rowspan="1" colspan="1">V100</th>
              <th align="left" rowspan="1" colspan="1">A100</th>
              <th align="left" rowspan="1" colspan="1">H100</th>
              <th align="left" rowspan="1" colspan="1">1c</th>
              <th align="left" rowspan="1" colspan="1">10c</th>
              <th align="left" rowspan="1" colspan="1">20c</th>
              <th align="left" rowspan="1" colspan="1">1c</th>
              <th align="left" rowspan="1" colspan="1">10c</th>
              <th align="left" rowspan="1" colspan="1">20c</th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td rowspan="2" align="left" colspan="1">Small</td>
              <td align="left" rowspan="1" colspan="1">
                <inline-formula id="inf229">
                  <mml:math id="m239" overflow="scroll">
                    <mml:mrow>
                      <mml:mi mathvariant="bold">Z</mml:mi>
                      <mml:mi mathvariant="bold">Λ</mml:mi>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td align="left" rowspan="1" colspan="1">0.10</td>
              <td align="left" rowspan="1" colspan="1">0.06</td>
              <td align="left" rowspan="1" colspan="1">0.05</td>
              <td align="left" rowspan="1" colspan="1">2.24</td>
              <td align="left" rowspan="1" colspan="1">0.36</td>
              <td align="left" rowspan="1" colspan="1">0.35</td>
              <td align="left" rowspan="1" colspan="1">1.71</td>
              <td align="left" rowspan="1" colspan="1">0.38</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <inline-formula id="inf23">
                  <mml:math id="m33" overflow="scroll">
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">Z</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>′</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mrow>
                          <mml:mi mathvariant="bold">Λ</mml:mi>
                        </mml:mrow>
                        <mml:mo>~</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td align="left" rowspan="1" colspan="1">0.10</td>
              <td align="left" rowspan="1" colspan="1">0.06</td>
              <td align="left" rowspan="1" colspan="1">0.05</td>
              <td align="left" rowspan="1" colspan="1">2.29</td>
              <td align="left" rowspan="1" colspan="1">0.37</td>
              <td align="left" rowspan="1" colspan="1">0.29</td>
              <td align="left" rowspan="1" colspan="1">1.75</td>
              <td align="left" rowspan="1" colspan="1">0.30</td>
              <td align="left" rowspan="1" colspan="1">0.28</td>
            </tr>
            <tr>
              <td rowspan="2" align="left" colspan="1">Medium</td>
              <td align="left" rowspan="1" colspan="1">
                <bold>ZΛ</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">0.69</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
              <td align="left" rowspan="1" colspan="1">0.35</td>
              <td align="left" rowspan="1" colspan="1">16.03</td>
              <td align="left" rowspan="1" colspan="1">2.61</td>
              <td align="left" rowspan="1" colspan="1">2.51</td>
              <td align="left" rowspan="1" colspan="1">12.53</td>
              <td align="left" rowspan="1" colspan="1">2.96</td>
              <td align="left" rowspan="1" colspan="1">2.94</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <inline-formula id="inf24">
                  <mml:math id="m34" overflow="scroll">
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">Z</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>′</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mrow>
                          <mml:mi mathvariant="bold">Λ</mml:mi>
                        </mml:mrow>
                        <mml:mo>~</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td align="left" rowspan="1" colspan="1">0.70</td>
              <td align="left" rowspan="1" colspan="1">0.47</td>
              <td align="left" rowspan="1" colspan="1">0.36</td>
              <td align="left" rowspan="1" colspan="1">16.81</td>
              <td align="left" rowspan="1" colspan="1">2.50</td>
              <td align="left" rowspan="1" colspan="1">1.81</td>
              <td align="left" rowspan="1" colspan="1">13.00</td>
              <td align="left" rowspan="1" colspan="1">2.08</td>
              <td align="left" rowspan="1" colspan="1">1.33</td>
            </tr>
            <tr>
              <td rowspan="2" align="left" colspan="1">Large</td>
              <td align="left" rowspan="1" colspan="1">
                <bold>ZΛ</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">-</td>
              <td align="left" rowspan="1" colspan="1">1.87</td>
              <td align="left" rowspan="1" colspan="1">1.42</td>
              <td align="left" rowspan="1" colspan="1">76.42</td>
              <td align="left" rowspan="1" colspan="1">12.31</td>
              <td align="left" rowspan="1" colspan="1">12.24</td>
              <td align="left" rowspan="1" colspan="1">51.72</td>
              <td align="left" rowspan="1" colspan="1">10.99</td>
              <td align="left" rowspan="1" colspan="1">11.03</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <inline-formula id="inf25">
                  <mml:math id="m35" overflow="scroll">
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">Z</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>′</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mrow>
                          <mml:mi mathvariant="bold">Λ</mml:mi>
                        </mml:mrow>
                        <mml:mo>~</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td align="left" rowspan="1" colspan="1">-</td>
              <td align="left" rowspan="1" colspan="1">1.94</td>
              <td align="left" rowspan="1" colspan="1">1.47</td>
              <td align="left" rowspan="1" colspan="1">83.44</td>
              <td align="left" rowspan="1" colspan="1">12.73</td>
              <td align="left" rowspan="1" colspan="1">10.04</td>
              <td align="left" rowspan="1" colspan="1">53.68</td>
              <td align="left" rowspan="1" colspan="1">8.36</td>
              <td align="left" rowspan="1" colspan="1">5.55</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Evaluating our two novel approaches against a crude call to the BLAS-based double-precision matrix multiplication function shows that computing times can be reduced by more than 99.7% (98.1%) for the small and medium populations on the GPU (CPU). Unfortunately, the genotype data of the large population in double precision required approx. 2.27 TB of RAM, which could not be met in our hardware setup, hindering us from benchmarking the BLAS library on this dataset. Similarly, the CPU-based original solution for multiplying compressed SNP matrices with <bold>Λ</bold> took about 19 times longer on all population sizes compared to the GPU implementation and three times longer compared to the <italic>5codes</italic> algorithm.</p>
      <p>To mitigate the impact of hardware-specific optimizations which might limit the reproducibility of our results, we further test our CPU code on Intel<sup>®</sup> and AMD<sup>®</sup> processors (Intel<sup>®</sup> Xeon Gold 6230 and AMD<sup>®</sup> Milan EPYC 7513) and our GPU code on three generations of Nvidia<sup>®</sup> datacenter GPUs (Volta V100, Ampere A100 and Hopper H100). Results displayed in <xref rid="T1" ref-type="table">Table 1</xref> are the average computing times of 10 replicates.</p>
      <p>As for the GPU implementation, our findings suggest that reductions in computing times of approx. 25% (50%) can be achieved when using the recently introduced H100 compared to the A100 (V100). More importantly, the V100 ships with 16 GB or 32 GB of device RAM, limiting the potential problem sizes in our application. Yet, this issue could be mitigated by using multiple GPUs. Since both the transposed and the untransposed matrix are stored on the device, computing times for both multiplications do not differ substantially.</p>
      <p>Despite using the Intel<sup>®</sup> C/C++ Classic Compiler with Intel-specific optimizations, the <italic>5codes</italic> algorithm performs slightly better on the more powerful AMD<sup>®</sup> chip than on the Xeon Gold 6230. We observe that our implementation scales reasonably well to 10 cores, decreasing computing times by at least a factor of 5. However, increasing the number of cores to 20 only yields mild performance improvements and even comes with a penalty in some cases (see <xref rid="T1" ref-type="table">Table 1</xref>).</p>
      <p>Overall, our evaluations suggest that the GPU implementation significantly outperforms the <italic>5codes</italic> implementation, though practical applications should evaluate the costs and benefits of adding a GPU to their hardware setup based on their respective compute time restraints.</p>
    </sec>
    <sec id="s3-2">
      <title>3.2 Impact on single-step genomic evaluations</title>
      <p>We solved the equation systems associated with the ssSNPBLUP and ssGTABLUP models with the program hpblup, a PCG-based solver used by the software MiXBLUP 3.1 (<xref rid="B28" ref-type="bibr">ten Napel et al., 2021</xref>), which links against the <italic>miraculix</italic> library and toggles the use of our two novel implementations through an option. Experiments were performed with 180 GB of RAM on a single AMD<sup>®</sup> EPYC 7513 CPU for the <italic>5codes</italic> algorithm and a single Nvidia<sup>®</sup> A100 for the GPU implementation. For the CPU tests, we used 15 dedicated cores, as this is the recommended setting in MiXBLUP. The PCG was iterated until a square relative residual below 10<sup>–13</sup> was achieved. To put our observed computing times into perspective, we also solved both models with the current approach for multiplying genotype matrices implemented in MiXBLUP 3.1 (which we will call “current” below).</p>
      <p>Results are displayed in <xref rid="T2" ref-type="table">Table 2</xref>. Due to the different nature of the effects estimated, the computing times should be evaluated separately for the two models. For the ssSNPBLUP equation system, we observe that the average wall clock time is reduced by approx. 72% (11%) for the multiplication <bold>ZΛ</bold> and by approx. 95% (76%) for <inline-formula id="inf26"><mml:math id="m36" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> on GPUs (CPUs) respectively. When solving the ssGTABLUP equation system, the average time for multiplying <bold>ZΛ</bold> was slightly higher in the <italic>5codes</italic> algorithm. Yet, both <italic>5codes</italic> and the GPU implementation significantly decreased the time for computing <inline-formula id="inf27"><mml:math id="m37" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
      <table-wrap position="float" id="T2">
        <label>TABLE 2</label>
        <caption>
          <p>Computation wall clock times of single-step genomic models on ICBF cattle data in seconds. The SNP matrix Z and its transposed Z′ are multiplied by matrices Λ and <inline-formula id="inf28"><mml:math id="m38" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> respectively to compute the candidate matrix in the PCG. All computations were performed on one AMD Milan EPYC 7513 CPU with 15 dedicated cores. GPU computations were performed on a single Nvidia<sup>®</sup> A100 GPU with 80 GB device memory. Both models were trained to a relative error below 10<sup>–13</sup>. The total time contains preprocessing (I/O operations and set-up of the preconditioner matrix), solving of the MME, and postprocessing (mainly I/O operations).</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead valign="top">
            <tr>
              <th rowspan="2" align="left" colspan="1">Wall clock time (s)</th>
              <th colspan="3" align="center" rowspan="1">ssSNPBLUP</th>
              <th colspan="3" align="center" rowspan="1">ssGTABLUP</th>
            </tr>
            <tr>
              <th align="left" rowspan="1" colspan="1">Current</th>
              <th align="left" rowspan="1" colspan="1">5codes</th>
              <th align="left" rowspan="1" colspan="1">GPU</th>
              <th align="left" rowspan="1" colspan="1">Current</th>
              <th align="left" rowspan="1" colspan="1">5codes</th>
              <th align="left" rowspan="1" colspan="1">GPU</th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" rowspan="1" colspan="1">Average time <inline-formula id="inf129"><mml:math id="m139" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow></mml:math></inline-formula>
</td>
              <td align="left" rowspan="1" colspan="1">5.41</td>
              <td align="left" rowspan="1" colspan="1">4.81</td>
              <td align="left" rowspan="1" colspan="1">1.50</td>
              <td align="left" rowspan="1" colspan="1">8.76</td>
              <td align="left" rowspan="1" colspan="1">10.38</td>
              <td align="left" rowspan="1" colspan="1">1.53</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Average time <inline-formula id="inf29"><mml:math id="m39" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>
</td>
              <td align="left" rowspan="1" colspan="1">29.68</td>
              <td align="left" rowspan="1" colspan="1">7.05</td>
              <td align="left" rowspan="1" colspan="1">1.62</td>
              <td align="left" rowspan="1" colspan="1">28.66</td>
              <td align="left" rowspan="1" colspan="1">6.83</td>
              <td align="left" rowspan="1" colspan="1">1.58</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Average time per iteration</td>
              <td align="left" rowspan="1" colspan="1">51.43</td>
              <td align="left" rowspan="1" colspan="1">32.32</td>
              <td align="left" rowspan="1" colspan="1">14.16</td>
              <td align="left" rowspan="1" colspan="1">50.38</td>
              <td align="left" rowspan="1" colspan="1">35.21</td>
              <td align="left" rowspan="1" colspan="1">16.25</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Number of iterations</td>
              <td align="left" rowspan="1" colspan="1">389</td>
              <td align="left" rowspan="1" colspan="1">362</td>
              <td align="left" rowspan="1" colspan="1">385</td>
              <td align="left" rowspan="1" colspan="1">212</td>
              <td align="left" rowspan="1" colspan="1">212</td>
              <td align="left" rowspan="1" colspan="1">212</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Preprocessing time</td>
              <td align="left" rowspan="1" colspan="1">2953</td>
              <td align="left" rowspan="1" colspan="1">3191</td>
              <td align="left" rowspan="1" colspan="1">3186</td>
              <td align="left" rowspan="1" colspan="1">3493</td>
              <td align="left" rowspan="1" colspan="1">4068</td>
              <td align="left" rowspan="1" colspan="1">3184</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Total time</td>
              <td align="left" rowspan="1" colspan="1">23275</td>
              <td align="left" rowspan="1" colspan="1">15195</td>
              <td align="left" rowspan="1" colspan="1">8961</td>
              <td align="left" rowspan="1" colspan="1">14504</td>
              <td align="left" rowspan="1" colspan="1">11863</td>
              <td align="left" rowspan="1" colspan="1">7138</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>As the genotype matrix multiplication constitutes a significant portion of the time per iteration in the PCG solver, the <italic>5codes</italic> implementation reduced the time for solving the ssSNPBLUP model from approx. 6.47 h to 4.22 h on the CPU. Similarly, the wall clock time for solving the ssGTABLUP model was reduced from 4.03 h to 3.30 h. Outperforming these results, the GPU approach only required 2.49 h for the ssSNPBLUP model and 1.98 h for the ssGTABLUP model. A similar number of iterations was observed for solving all models, though the <italic>5codes</italic> algorithm required 27 iterations less for solving the MME associated with the ssSNPBLUP model, which might be explained by its inherently higher precision.</p>
    </sec>
  </sec>
  <sec sec-type="discussion" id="s4">
    <title>4 Discussion</title>
    <p>We have presented novel approaches for multiplying centered genotype matrices <bold>M</bold> by a continuously-scaled matrix <bold>Λ</bold> which are applicable both on CPUs as well as on modern GPUs. Useful applications include single-step genomic models that are used to compute breeding value estimates when only a subset of animals are genotyped and/or phenotyped. Yet, similar computational operations are employed in other fields of modern genetics. For instance, genome-wide association studies could benefit from a fast genotype matrix multiplication at various computational bottlenecks: the multiplication of the SNP matrix by a phenotype vector is an essential part of the calculation of genotype-phenotype correlations (<xref rid="B35" ref-type="bibr">Yang et al., 2011</xref>). Additionally, many genome-wide association studies use the results of a principal component analysis (PCA) of <bold>G</bold> for population stratification (<xref rid="B20" ref-type="bibr">Price et al., 2006</xref>; <xref rid="B15" ref-type="bibr">Meuwissen et al., 2017</xref>; <xref rid="B19" ref-type="bibr">Ødegård et al., 2018</xref>) and hence are to gain from a fast genotype matrix multiplication as well.</p>
    <p>Through our optimized algorithms we were able to achieve a speed-up of critical operations by a factor of up to 3 compared to the methodology by <xref rid="B31" ref-type="bibr">Vandenplas et al. (2020)</xref> using CPUs, and a factor of up to 20 using GPUs. Thanks to this acceleration, we have shown how our software library can be used by researchers and practitioners to estimate breeding values in a population of 26.46 m animals, 2.61 m of which were genotyped, in a reasonable time of approx. 2 h.</p>
    <p>Nevertheless, the growth of breeding populations as well as the steadily falling costs of genotyping will result in genomic datasets of ever-growing size. Therefore, there are several avenues for further research to utilize computing resources even more efficiently.</p>
    <p>First, as indicated in <xref rid="s2" ref-type="sec">Section 2</xref>, system memory requirements might be reduced by a factor of approximately two by transposing the compressed genotype matrix on-the-fly during matrix multiplication instead of storing the transpose explicitly. With Nvidia<sup>®</sup> GPUs currently limited to at most 94 GB device memory and most compute set-ups limited to hundreds of gigabytes of RAM, this improvement would extend the dimensions of possible problem sizes addressable with our proposed matrix-multiplication microkernel.</p>
    <p>Second, though our GPU implementation uses highly efficient data access iterators provided by the CUTLASS library, a further reduction in computing time might be achieved by using warp-level-coordinated matrix operations, which have been added as hardware instructions on the latest generations of GPUs [see, e.g., the CUTLASS documentation for how this has been tackled in general tensor-tensor operations (<xref rid="B29" ref-type="bibr">Thakkar et al., 2023</xref>)]. Additionally, we have seen that our <italic>5codes</italic> implementation suffers from scalability issues when extending the number of cores.</p>
    <p>Finally, it should be noted that in the evaluation of single-step models, the preprocessing time required by the PCG solver (e.g., to set up the preconditioner) now constitutes a significant portion of the total computation time. Reducing this contribution holds the potential for additional performance improvements.</p>
    <p>Notwithstanding these potential improvements, our software can be used in a variety of computational tasks in genomics to reduce computing times.</p>
  </sec>
</body>
<back>
  <ack>
    <p>The authors thank Associate Editor Dorian Garrick and two referees for their review and valuable suggestions to the manuscript. A preprint of this work was posted on bioRxiv (<xref rid="B6" ref-type="bibr">Freudenberg et al., 2023</xref>).</p>
  </ack>
  <sec sec-type="data-availability" id="s5">
    <title>Data availability statement</title>
    <p>The data analyzed in this study is subject to the following licenses/restrictions: Individual genotype, pedigree and phenotype data used in this study are managed by the Irish Cattle Breeding Federation and cannot be made publicly available. Reasonable requests for the cattle data can be made to the Irish Cattle Breeding Federation. Requests will be considered on a case-by-case basis, subject to approval by the data owner and compliance with any legal and ethical requirements related to data access and use. Requests to access these datasets should be directed to <email>query@icbf.com</email>, Website: <ext-link xlink:href="https://www.icbf.com/" ext-link-type="uri">https://www.icbf.com/</ext-link>.</p>
  </sec>
  <sec id="s6">
    <title>Author contributions</title>
    <p>MS designed and implemented the <italic>5codes</italic> algorithm. AF designed and implemented the GPU solution. AF, JV, and MS implemented interfaces to the algorithms. AF and JV wrote and ran analyses for this script. RE preprocessed and curated the ICBF cattle data. TP and JT provided valuable suggestions for the experiment design and the focus of this study. All authors contributed to the article and approved the submitted version.</p>
  </sec>
  <sec sec-type="COI-statement" id="s8">
    <title>Conflict of interest</title>
    <p>MiXBLUP is developed and marketed by the Animal Breeding and Genomics group at Wageningen UR Livestock Research, of which JV, TP, and JT are employees. The cattle data used in this study is proprietary and the intellectual property of the Irish Cattle Breeding Federation, at which RE is an employee.</p>
    <p>The remaining authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p>
  </sec>
  <sec sec-type="disclaimer" id="s9">
    <title>Publisher’s note</title>
    <p>All claims expressed in this article are solely those of the authors and do not necessarily represent those of their affiliated organizations, or those of the publisher, the editors and the reviewers. Any product that may be evaluated in this article, or claim that may be made by its manufacturer, is not guaranteed or endorsed by the publisher.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Alappat</surname><given-names>C.</given-names></name><name><surname>Basermann</surname><given-names>A.</given-names></name><name><surname>Bishop</surname><given-names>A. R.</given-names></name><name><surname>Fehske</surname><given-names>H.</given-names></name><name><surname>Hager</surname><given-names>G.</given-names></name><name><surname>Schenk</surname><given-names>O.</given-names></name><etal/></person-group> (<year>2020</year>). <article-title>A recursive algebraic coloring technique for hardware-efficient symmetric sparse matrix-vector multiplication</article-title>. <source>ACM Trans. Parallel Comput.</source>
<volume>7</volume>, <fpage>1</fpage>–<lpage>37</lpage>. <pub-id pub-id-type="doi">10.1145/3399732</pub-id>
</mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chang</surname><given-names>C. C.</given-names></name><name><surname>Chow</surname><given-names>C. C.</given-names></name><name><surname>Tellier</surname><given-names>L. C.</given-names></name><name><surname>Vattikuti</surname><given-names>S.</given-names></name><name><surname>Purcell</surname><given-names>S. M.</given-names></name><name><surname>Lee</surname><given-names>J. J.</given-names></name></person-group> (<year>2015</year>). <article-title>Second-generation PLINK: rising to the challenge of larger and richer datasets</article-title>. <source>GigaScience</source>
<volume>4</volume>, <fpage>137422</fpage>–<lpage>s14015</lpage>. <pub-id pub-id-type="doi">10.1186/s13742-015-0047-8</pub-id>
</mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Christensen</surname><given-names>O.</given-names></name><name><surname>Lund</surname><given-names>M.</given-names></name></person-group> (<year>2010</year>). <article-title>Genomic prediction when some animals are not genotyped</article-title>. <source>Genet. Sel. Evol.</source>
<volume>42</volume>, <fpage>2</fpage>. <pub-id pub-id-type="doi">10.1186/1297-9686-42-2</pub-id>
<pub-id pub-id-type="pmid">20105297</pub-id></mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Evans</surname><given-names>R.</given-names></name><name><surname>Cromie</surname><given-names>A.</given-names></name><name><surname>Pabiou</surname><given-names>T.</given-names></name></person-group> (<year>2019</year>). “<article-title>Genetic evaluations for dam-type specific calving performance traits in a multi-breed population</article-title>,” in <source>Book of abstracts of the 70th annual meeting of the European federation of animal science</source>. Editors <person-group person-group-type="editor"><name><surname>E</surname><given-names>S.</given-names></name><etal/></person-group>
<fpage>468</fpage>.</mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fernando</surname><given-names>R. L.</given-names></name><name><surname>Dekkers</surname><given-names>J. C.</given-names></name><name><surname>Garrick</surname><given-names>D. J.</given-names></name></person-group> (<year>2014</year>). <article-title>A class of Bayesian methods to combine large numbers of genotyped and non-genotyped animals for whole-genome analyses</article-title>. <source>Genet. Sel. Evol.</source>
<volume>46</volume>, <fpage>1</fpage>–<lpage>13</lpage>. <pub-id pub-id-type="doi">10.1186/1297-9686-46-50</pub-id>
</mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Freudenberg</surname><given-names>A.</given-names></name><name><surname>Vandenplas</surname><given-names>J.</given-names></name><name><surname>Schlather</surname><given-names>M.</given-names></name><name><surname>Pook</surname><given-names>T.</given-names></name><name><surname>Evans</surname><given-names>R.</given-names></name><name><surname>ten Napel</surname><given-names>J.</given-names></name></person-group> (<year>2023</year>). <article-title>Accelerated computations for iterative-solver techniques in single-step BLUP models</article-title>. <source>Prepr. bioRxiv</source>. <pub-id pub-id-type="doi">10.1101/2023.07.06.547949</pub-id>
</mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Henderson</surname><given-names>C. R.</given-names></name></person-group> (<year>1976</year>). <article-title>A simple method for computing the inverse of a numerator relationship matrix used in prediction of breeding values</article-title>. <source>Biometrics</source>
<volume>32</volume>, <fpage>69</fpage>–<lpage>83</lpage>.</mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>Y. J.</given-names></name><name><surname>Henry</surname><given-names>R.</given-names></name><name><surname>Fahim</surname><given-names>R.</given-names></name><name><surname>Hassan</surname><given-names>H.</given-names></name></person-group> (<year>2022</year>). “<article-title>Who says elephants can’t run: bringing large scale MoE models into cloud scale production</article-title>,” in <source>Proceedings of the third workshop on simple and efficient natural language processing (SustaiNLP)</source>. Editors <person-group person-group-type="editor"><name><surname>Fan</surname><given-names>A.</given-names></name><name><surname>Gurevych</surname><given-names>I.</given-names></name><name><surname>Hou</surname><given-names>Y.</given-names></name><name><surname>Kozareva</surname><given-names>Z.</given-names></name><name><surname>Luccioni</surname><given-names>S.</given-names></name><name><surname>Moosavi</surname><given-names>N. S.</given-names></name><etal/></person-group> (<publisher-loc>Abu Dhabi, United Arab Emirates (Hybrid)</publisher-loc>: <publisher-name>Association for Computational Linguistics</publisher-name>), <fpage>36</fpage>–<lpage>43</lpage>.</mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Legarra</surname><given-names>A.</given-names></name><name><surname>Ducrocq</surname><given-names>V.</given-names></name></person-group> (<year>2012</year>). <article-title>Computational strategies for national integration of phenotypic, genomic, and pedigree data in a single-step best linear unbiased prediction</article-title>. <source>J. Dairy Sci.</source>
<volume>95</volume>, <fpage>4629</fpage>–<lpage>4645</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2011-4982</pub-id>
<pub-id pub-id-type="pmid">22818478</pub-id></mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Legarra</surname><given-names>A.</given-names></name><name><surname>Aguilar</surname><given-names>I.</given-names></name><name><surname>Misztal</surname><given-names>I.</given-names></name></person-group> (<year>2009</year>). <article-title>A relationship matrix including full pedigree and genomic information</article-title>. <source>J. Dairy Sci.</source>
<volume>92</volume>, <fpage>4656</fpage>–<lpage>4663</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2009-2061</pub-id>
<pub-id pub-id-type="pmid">19700729</pub-id></mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>Z.</given-names></name><name><surname>Goddard</surname><given-names>M. E.</given-names></name><name><surname>Reinhardt</surname><given-names>F.</given-names></name><name><surname>Reents</surname><given-names>R.</given-names></name></person-group> (<year>2014</year>). <article-title>A single-step genomic model with direct estimation of marker effects</article-title>. <source>J. Dairy Sci.</source>
<volume>97</volume>, <fpage>5833</fpage>–<lpage>5850</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2014-7924</pub-id>
<pub-id pub-id-type="pmid">25022678</pub-id></mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mäntysaari</surname><given-names>E. A.</given-names></name><name><surname>Evans</surname><given-names>R. D.</given-names></name><name><surname>Strandén</surname><given-names>I.</given-names></name></person-group> (<year>2017</year>). <article-title>Efficient single-step genomic evaluation for a multibreed beef cattle population having many genotyped animals</article-title>. <source>J. Animal Sci.</source>
<volume>95</volume>, <fpage>4728</fpage>–<lpage>4737</lpage>. <pub-id pub-id-type="doi">10.2527/jas2017.1912</pub-id>
</mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mäntysaari</surname><given-names>E.</given-names></name><name><surname>Koivula</surname><given-names>M.</given-names></name><name><surname>Strandén</surname><given-names>I.</given-names></name></person-group> (<year>2020</year>). <article-title>Symposium review: single-step genomic evaluations in dairy cattle</article-title>. <source>J. Dairy Sci.</source>
<volume>103</volume>, <fpage>5314</fpage>–<lpage>5326</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2019-17754</pub-id>
<pub-id pub-id-type="pmid">32331883</pub-id></mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Meuwissen</surname><given-names>T. H. E.</given-names></name><name><surname>Hayes</surname><given-names>B.</given-names></name><name><surname>Goddard</surname><given-names>M. E.</given-names></name></person-group> (<year>2001</year>). <article-title>Prediction of total genetic value using genome-wide dense marker maps</article-title>. <source>Genetics</source>
<volume>157</volume>, <fpage>1819</fpage>–<lpage>1829</lpage>. <pub-id pub-id-type="doi">10.1093/genetics/157.4.1819</pub-id>
<pub-id pub-id-type="pmid">11290733</pub-id></mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Meuwissen</surname><given-names>T.</given-names></name><name><surname>Indahl</surname><given-names>U.</given-names></name><name><surname>Ødegård</surname><given-names>J.</given-names></name></person-group> (<year>2017</year>). <article-title>Variable selection models for genomic selection using whole-genome sequence data and singular value decomposition</article-title>. <source>Genet. Sel. Evol.</source>
<volume>49</volume>, <fpage>94</fpage>. <pub-id pub-id-type="doi">10.1186/s12711-017-0369-3</pub-id>
<pub-id pub-id-type="pmid">29281962</pub-id></mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Misztal</surname><given-names>I.</given-names></name><name><surname>Legarra</surname><given-names>A.</given-names></name><name><surname>Aguilar</surname><given-names>I.</given-names></name></person-group> (<year>2009</year>). <article-title>Computing procedures for genetic evaluation including phenotypic, full pedigree, and genomic information</article-title>. <source>J. Dairy Sci.</source>
<volume>92</volume>, <fpage>4648</fpage>–<lpage>4655</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2009-2064</pub-id>
<pub-id pub-id-type="pmid">19700728</pub-id></mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Misztal</surname><given-names>I.</given-names></name><name><surname>Legarra</surname><given-names>A.</given-names></name><name><surname>Aguilar</surname><given-names>I.</given-names></name></person-group> (<year>2014</year>). <article-title>Using recursion to compute the inverse of the genomic relationship matrix</article-title>. <source>J. Dairy Sci.</source>
<volume>97</volume>, <fpage>3943</fpage>–<lpage>3952</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2013-7752</pub-id>
<pub-id pub-id-type="pmid">24679933</pub-id></mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Misztal</surname><given-names>I.</given-names></name><name><surname>Lourenco</surname><given-names>D.</given-names></name><name><surname>Tsuruta</surname><given-names>S.</given-names></name><name><surname>Aguilar</surname><given-names>I.</given-names></name><name><surname>Masuda</surname><given-names>Y.</given-names></name><name><surname>Bermann</surname><given-names>M.</given-names></name><etal/></person-group> (<year>2022</year>). “<article-title>668. How ssGBLUP became suitable for national dairy cattle evaluations</article-title>,” in <source>Proceedings of 12th world congress on genetics applied to Livestock production (WCGALP)</source>. Editors <person-group person-group-type="editor"><name><surname>Veerkamp</surname><given-names>R. F.</given-names></name><name><surname>de Haas</surname><given-names>Y.</given-names></name></person-group> (<publisher-name>Wageningen Academic Publishers</publisher-name>), <fpage>2757</fpage>–<lpage>2760</lpage>. <pub-id pub-id-type="doi">10.3920/978-90-8686-940-4_668</pub-id>
</mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ødegård</surname><given-names>J.</given-names></name><name><surname>Indahl</surname><given-names>U.</given-names></name><name><surname>Strandén</surname><given-names>I.</given-names></name><name><surname>Meuwissen</surname><given-names>T. H.</given-names></name></person-group> (<year>2018</year>). <article-title>Large-scale genomic prediction using singular value decomposition of the genotype matrix</article-title>. <source>Genet. Sel. Evol.</source>
<volume>50</volume>. <pub-id pub-id-type="doi">10.1186/s12711-018-0373-2</pub-id>
</mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Price</surname><given-names>A. L.</given-names></name><name><surname>Patterson</surname><given-names>N. J.</given-names></name><name><surname>Plenge</surname><given-names>R. M.</given-names></name><name><surname>Weinblatt</surname><given-names>M. E.</given-names></name><name><surname>Shadick</surname><given-names>N. A.</given-names></name><name><surname>Reich</surname><given-names>D.</given-names></name></person-group> (<year>2006</year>). <article-title>Principal components analysis corrects for stratification in genome-wide association studies</article-title>. <source>Nat. Genet.</source>
<volume>38</volume>, <fpage>904</fpage>–<lpage>909</lpage>. <pub-id pub-id-type="doi">10.1038/ng1847</pub-id>
<pub-id pub-id-type="pmid">16862161</pub-id></mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Sanders</surname><given-names>J.</given-names></name><name><surname>Kandrot</surname><given-names>E.</given-names></name></person-group> (<year>2010</year>). <source>CUDA by example: An introduction to general-purpose GPU programming</source>. <publisher-name>Addison-Wesley Professional</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sargolzaei</surname><given-names>M.</given-names></name><name><surname>Chesnais</surname><given-names>J. P.</given-names></name><name><surname>Schenkel</surname><given-names>F. S.</given-names></name></person-group> (<year>2014</year>). <article-title>A new approach for efficient genotype imputation using information from relatives</article-title>. <source>BMC Genomics</source>
<volume>15</volume>, <fpage>478</fpage>. <pub-id pub-id-type="doi">10.1186/1471-2164-15-478</pub-id>
<pub-id pub-id-type="pmid">24935670</pub-id></mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schaeffer</surname><given-names>L.</given-names></name><name><surname>Kennedy</surname><given-names>B.</given-names></name></person-group> (<year>1986</year>). <article-title>Computing strategies for solving mixed model equations</article-title>. <source>J. Dairy Sci.</source>
<volume>69</volume>, <fpage>575</fpage>–<lpage>579</lpage>. <pub-id pub-id-type="doi">10.3168/jds.S0022-0302(86)80441-6</pub-id>
</mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schaeffer</surname><given-names>L.</given-names></name></person-group> (<year>2006</year>). <article-title>Strategy for applying genome-wide selection in dairy cattle</article-title>. <source>J. Animal Breed. Genet.</source>
<volume>123</volume>, <fpage>218</fpage>–<lpage>223</lpage>. <pub-id pub-id-type="doi">10.1111/j.1439-0388.2006.00595.x</pub-id>
</mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Strandén</surname><given-names>I.</given-names></name><name><surname>Lidauer</surname><given-names>M.</given-names></name></person-group> (<year>1999</year>). <article-title>Solving large mixed linear models using preconditioned conjugate gradient iteration</article-title>. <source>J. Dairy Sci.</source>
<volume>82</volume>, <fpage>2779</fpage>–<lpage>2787</lpage>. <pub-id pub-id-type="doi">10.3168/jds.S0022-0302(99)75535-9</pub-id>
<pub-id pub-id-type="pmid">10629826</pub-id></mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Tanenbaum</surname><given-names>A. S.</given-names></name></person-group> (<year>2016</year>). <source>Structured computer organization</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>Pearson Education India</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Taskinen</surname><given-names>M.</given-names></name><name><surname>Mäntysaari</surname><given-names>E.</given-names></name><name><surname>Strandén</surname><given-names>I.</given-names></name></person-group> (<year>2017</year>). <article-title>Single-step SNP-BLUP with on-the-fly imputed genotypes and residual polygenic effects</article-title>. <source>Genet. Sel. Evol.</source>
<volume>49</volume>. <pub-id pub-id-type="doi">10.1186/s12711-017-0310-9</pub-id>
</mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>ten Napel</surname><given-names>J.</given-names></name><name><surname>Vandenplas</surname><given-names>J.</given-names></name><name><surname>Lidauer</surname><given-names>M. H.</given-names></name><name><surname>Strandén</surname><given-names>I.</given-names></name><name><surname>Taskinen</surname><given-names>M.</given-names></name><name><surname>Mäntysaari</surname><given-names>E. A.</given-names></name><etal/></person-group> (<year>2021</year>). <source><italic>MiXBLUP 3.0.1 manual</italic>. Animal breeding and genomics</source>. <comment>v3.0 edn</comment>. <publisher-loc>Wageningen, the Netherlands</publisher-loc>: <publisher-name>Wageningen University &amp; Research</publisher-name>. <comment>Last accessed 16th of July 2023</comment>.</mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Thakkar</surname><given-names>V.</given-names></name><name><surname>Ramani</surname><given-names>P.</given-names></name><name><surname>Cecka</surname><given-names>C.</given-names></name><name><surname>Shivam</surname><given-names>A.</given-names></name><name><surname>Lu</surname><given-names>H.</given-names></name><name><surname>Yan</surname><given-names>E.</given-names></name><etal/></person-group> (<year>2023</year>). <source>Cutlass</source>.</mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vandenplas</surname><given-names>J.</given-names></name><name><surname>Eding</surname><given-names>H.</given-names></name><name><surname>Calus</surname><given-names>M. P.</given-names></name><name><surname>Vuik</surname><given-names>C.</given-names></name></person-group> (<year>2018</year>). <article-title>Deflated preconditioned conjugate gradient method for solving single-step BLUP models efficiently</article-title>. <source>Genet. Sel. Evol.</source>
<volume>50</volume>, <fpage>1</fpage>–<lpage>17</lpage>. <pub-id pub-id-type="doi">10.1186/s12711-018-0429-3</pub-id>
<pub-id pub-id-type="pmid">29373954</pub-id></mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vandenplas</surname><given-names>J.</given-names></name><name><surname>Eding</surname><given-names>H.</given-names></name><name><surname>Bosmans</surname><given-names>M.</given-names></name><name><surname>Calus</surname><given-names>M. P.</given-names></name></person-group> (<year>2020</year>). <article-title>Computational strategies for the preconditioned conjugate gradient method applied to ssSNPBLUP, with an application to a multivariate maternal model</article-title>. <source>Genet. Sel. Evol.</source>
<volume>52</volume>, <fpage>1</fpage>–<lpage>10</lpage>. <pub-id pub-id-type="doi">10.1186/s12711-020-00543-9</pub-id>
<pub-id pub-id-type="pmid">31941436</pub-id></mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vandenplas</surname><given-names>J.</given-names></name><name><surname>ten Napel</surname><given-names>J.</given-names></name><name><surname>Darbaghshahi</surname><given-names>S. N.</given-names></name><name><surname>Evans</surname><given-names>R.</given-names></name><name><surname>Calus</surname><given-names>M. P.</given-names></name><name><surname>Veerkamp</surname><given-names>R.</given-names></name><etal/></person-group> (<year>2023</year>). <article-title>Efficient large-scale single-step evaluations and indirect genomic prediction of genotyped selection candidates</article-title>. <source>Genet. Sel. Evol.</source>
<volume>55</volume>, <fpage>1</fpage>–<lpage>17</lpage>. <pub-id pub-id-type="doi">10.1186/s12711-023-00808-z</pub-id>
<pub-id pub-id-type="pmid">36604633</pub-id></mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>VanRaden</surname><given-names>P.</given-names></name></person-group> (<year>2008</year>). <article-title>Efficient methods to compute genomic predictions</article-title>. <source>J. Dairy Sci.</source>
<volume>91</volume>, <fpage>4414</fpage>–<lpage>4423</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2007-0980</pub-id>
<pub-id pub-id-type="pmid">18946147</pub-id></mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Xu</surname><given-names>Y.</given-names></name><name><surname>Laurie</surname><given-names>J. D.</given-names></name><name><surname>Wang</surname><given-names>X.</given-names></name></person-group> (<year>2021</year>). <article-title>CropGBM: an ultra-efficient machine learning toolbox for genomic selection-assisted breeding in crops</article-title> in <source>Springer protocols handbooks</source> (<publisher-name>Springer Protocols Handbooks</publisher-name>), <fpage>133</fpage>–<lpage>150</lpage>. <pub-id pub-id-type="doi">10.1007/978-1-0716-1526-3_5</pub-id>
</mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>J.</given-names></name><name><surname>Lee</surname><given-names>S.</given-names></name><name><surname>Goddard</surname><given-names>M.</given-names></name><name><surname>Visscher</surname><given-names>P.</given-names></name></person-group> (<year>2011</year>). <article-title>Gcta: a tool for genome-wide complex trait analysis</article-title>. <source>Am. J. Hum. Genet.</source>
<volume>88</volume>, <fpage>76</fpage>–<lpage>82</lpage>. <pub-id pub-id-type="doi">10.1016/j.ajhg.2010.11.011</pub-id>
<pub-id pub-id-type="pmid">21167468</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName nlm2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Front Genet</journal-id>
    <journal-id journal-id-type="iso-abbrev">Front Genet</journal-id>
    <journal-id journal-id-type="publisher-id">Front. Genet.</journal-id>
    <journal-title-group>
      <journal-title>Frontiers in Genetics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1664-8021</issn>
    <publisher>
      <publisher-name>Frontiers Media S.A.</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10470110</article-id>
    <article-id pub-id-type="publisher-id">1220408</article-id>
    <article-id pub-id-type="doi">10.3389/fgene.2023.1220408</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genetics</subject>
        <subj-group>
          <subject>Technology and Code</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Accelerated matrix-vector multiplications for matrices involving genotype covariates with applications in genomic prediction</article-title>
      <alt-title alt-title-type="left-running-head">Freudenberg et al.</alt-title>
      <alt-title alt-title-type="right-running-head">
        <ext-link xlink:href="https://doi.org/10.3389/fgene.2023.1220408" ext-link-type="uri">10.3389/fgene.2023.1220408</ext-link>
      </alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Freudenberg</surname>
          <given-names>Alexander</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="c001" ref-type="corresp">*</xref>
        <uri xlink:href="https://loop.frontiersin.org/people/2279485/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Vandenplas</surname>
          <given-names>Jeremie</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">
          <sup>2</sup>
        </xref>
        <uri xlink:href="https://loop.frontiersin.org/people/1094210/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Schlather</surname>
          <given-names>Martin</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">
          <sup>1</sup>
        </xref>
        <uri xlink:href="https://loop.frontiersin.org/people/2381219/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Pook</surname>
          <given-names>Torsten</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">
          <sup>2</sup>
        </xref>
        <uri xlink:href="https://loop.frontiersin.org/people/941529/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Evans</surname>
          <given-names>Ross</given-names>
        </name>
        <xref rid="aff3" ref-type="aff">
          <sup>3</sup>
        </xref>
        <uri xlink:href="https://loop.frontiersin.org/people/1698900/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ten Napel</surname>
          <given-names>Jan</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">
          <sup>2</sup>
        </xref>
        <uri xlink:href="https://loop.frontiersin.org/people/2198502/overview"/>
      </contrib>
    </contrib-group>
    <aff id="aff1"><sup>1</sup><institution>Chair of Applied Stochastics</institution>, <institution>University of Mannheim</institution>, <addr-line>Mannheim</addr-line>, <country>Germany</country></aff>
    <aff id="aff2"><sup>2</sup><institution>Animal Breeding and Genomics, Wageningen UR</institution>, <addr-line>Wageningen</addr-line>, <country>Netherlands</country></aff>
    <aff id="aff3"><sup>3</sup><institution>Irish Cattle Breeding Federation</institution>, <addr-line>Ballincollig</addr-line>, <country>Ireland</country></aff>
    <author-notes>
      <fn fn-type="edited-by">
        <p><bold>Edited by:</bold><ext-link xlink:href="https://loop.frontiersin.org/people/37713/overview" ext-link-type="uri">Dorian Garrick</ext-link>, Massey University, New Zealand</p>
      </fn>
      <fn fn-type="edited-by">
        <p><bold>Reviewed by:</bold><ext-link xlink:href="https://loop.frontiersin.org/people/774102/overview" ext-link-type="uri">Hao Cheng</ext-link>, University of California, Davis, United States</p>
        <p><ext-link xlink:href="https://loop.frontiersin.org/people/1161300/overview" ext-link-type="uri">Mohammad Ali Nilforooshan</ext-link>, Livestock Improvement Corporation, New Zealand</p>
      </fn>
      <corresp id="c001">*Correspondence: Alexander Freudenberg, <email>alexander.freudenberg@uni-mannheim.de</email>
</corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>17</day>
      <month>8</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2023</year>
    </pub-date>
    <volume>14</volume>
    <elocation-id>1220408</elocation-id>
    <history>
      <date date-type="received">
        <day>10</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>03</day>
        <month>8</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2023 Freudenberg, Vandenplas, Schlather, Pook, Evans and Ten Napel.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <copyright-holder>Freudenberg, Vandenplas, Schlather, Pook, Evans and Ten Napel</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY). The use, distribution or reproduction in other forums is permitted, provided the original author(s) and the copyright owner(s) are credited and that the original publication in this journal is cited, in accordance with accepted academic practice. No use, distribution or reproduction is permitted which does not comply with these terms.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>In the last decade, a number of methods have been suggested to deal with large amounts of genetic data in genomic predictions. Yet, steadily growing population sizes and the suboptimal use of computational resources are pushing the practical application of these approaches to their limits. As an extension to the C/CUDA library <italic>miraculix</italic>, we have developed tailored solutions for the computation of genotype matrix multiplications which is a critical bottleneck in the empirical evaluation of many statistical models. We demonstrate the benefits of our solutions at the example of single-step models which make repeated use of this kind of multiplication. Targeting modern Nvidia<sup>®</sup> GPUs as well as a broad range of CPU architectures, our implementation significantly reduces the time required for the estimation of breeding values in large population sizes. <italic>miraculix</italic> is released under the Apache 2.0 license and is freely available at <ext-link xlink:href="https://github.com/alexfreudenberg/miraculix" ext-link-type="uri">https://github.com/alexfreudenberg/miraculix</ext-link>.</p>
    </abstract>
    <kwd-group>
      <kwd>GPU</kwd>
      <kwd>SNP</kwd>
      <kwd>high-performance computing</kwd>
      <kwd>genomic data</kwd>
      <kwd>single-step model</kwd>
      <kwd>quantitative genomics</kwd>
    </kwd-group>
    <funding-group>
      <funding-statement>Analyses in this article were performed on the HPC systems bwUniCluster and Helix funded by the state of Baden-Württemberg through bwHPC and the German Research Foundation (DFG) through grant INST 35/1597-1 FUGG. AF acknowledges financial support from the Research Training Group “Statistical Modeling of Complex Systems” funded by the German Science Foundation. The publication of this article was funded by the University of Mannheim.</funding-statement>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>section-at-acceptance</meta-name>
        <meta-value>Computational Genomics</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="s1">
    <title>1 Introduction</title>
    <p>Over the past 15 years, the incorporation of genomic information has become essential for ensuring progress in breeding (<xref rid="B24" ref-type="bibr">Schaeffer, 2006</xref>). A routine task in animal breeding is the estimation of breeding values within a population, that is, the estimation of the average additive effects of the alleles that an individual passes on to its offspring. Though breeding values are estimated most accurately through the use genomic data, it is usually too costly to genotype a whole population. This is particularly true when analyzing large populations, like national dairy evaluations with millions of animals (<xref rid="B18" ref-type="bibr">Misztal et al., 2022</xref>). This circumstance has sparked a debate on how to combine pedigree information of ungenotyped animals with Single Nucleotide Polymorphism (SNP) data of genotyped animals to analyze phenotypic records.</p>
    <p>Due to its desirable statistical properties, the single-step genomic BLUP (ssGBLUP) model (<xref rid="B10" ref-type="bibr">Legarra et al., 2009</xref>; <xref rid="B3" ref-type="bibr">Christensen and Lund, 2010</xref>) has gained popularity in animal breeding, combining both the genomic relationship matrix (GRM) <bold>G</bold> and the pedigree-based relationship matrix <bold>A</bold> into a generalized relationship matrix <bold>H</bold>. Large population sizes used in animal breeding programs, ranging from tens of thousands to millions of individuals, have motivated research in computational strategies to solve the associated mixed model equations (MME) efficiently through the use of high-performance computing (HPC) techniques. One of the proposed approaches is the algorithm for Proven and Young Animals (APY), which approximates the inverse of the GRM, <bold>G</bold>
<sup>−1</sup>, through genomic recursion on a subset of core animals (<xref rid="B17" ref-type="bibr">Misztal et al., 2014</xref>). As an alternative concept, the original ssGBLUP model was reformulated to, first, allow the use of well-established numerical software (<xref rid="B9" ref-type="bibr">Legarra and Ducrocq, 2012</xref>) and, second, avoid the explicit construction and inversion of the GRM <bold>G</bold> using the Woodbury decomposition. The resulting models were coined single-step GT(A)BLUP models (<xref rid="B12" ref-type="bibr">Mäntysaari et al., 2017</xref>; <xref rid="B13" ref-type="bibr">Mäntysaari et al., 2020</xref>). Additionally, single-step SNP BLUP (ssSNPBLUP) models were proposed to estimate SNP effects directly, similarly avoiding <bold>G</bold> and its inverse (<xref rid="B5" ref-type="bibr">Fernando et al., 2014</xref>; <xref rid="B11" ref-type="bibr">Liu et al., 2014</xref>; <xref rid="B27" ref-type="bibr">Taskinen et al., 2017</xref>).</p>
    <p>Considering the computational aspects of these approaches, the use of highly-optimized sparse matrix operations has been established, thanks to the sparse characteristics of the pedigree-based relationship matrix. Additionally, established iterative-solver algorithms [e.g., the preconditioned conjugate gradient (PCG)] can be employed in the resulting equation systems (<xref rid="B25" ref-type="bibr">Strandén and Lidauer, 1999</xref>; <xref rid="B16" ref-type="bibr">Misztal et al., 2009</xref>) to avoid explicit construction of the full coefficient matrix.</p>
    <p>Nevertheless, the computational load of the remaining mathematical operations and slow PCG convergence have been somewhat prohibitive to the application of ssGTABLUP and ssSNPBLUP models in ultra-large-scale settings. To mitigate this issue, a number of numerical advances have been proposed to improve convergence speed (<xref rid="B30" ref-type="bibr">Vandenplas et al., 2018</xref>). So far, however, improvements in accelerating the involved matrix arithmetics have been limited to the application of shared-memory parallel libraries, such as the Intel<sup>®</sup> Math Kernel Library (MKL) and PARDISO (<xref rid="B1" ref-type="bibr">Alappat et al., 2020</xref>), and unpacking the compressed SNP matrix <bold>M</bold> into the CPU cache for the matrix-matrix product in the PCG iteration (<xref rid="B16" ref-type="bibr">Misztal et al., 2009</xref>; <xref rid="B31" ref-type="bibr">Vandenplas et al., 2020</xref>). Bit-level algorithms have been employed by, for instance, the popular PLINK software (<xref rid="B2" ref-type="bibr">Chang et al., 2015</xref>) in the efficient implementation of genome-wide association studies (GWAS), which rely on similar genotype matrix operations. Yet, these routines are not accessible for use in single-step BLUP evaluations. The software PLINK also implements BLAS-based routines for the calculation of <bold>G</bold> on a Nvidia<sup>®</sup> GPU in its version 2.0. However, this functionality works on uncompressed SNP data stored in single-precision floating-point values, thereby significantly limiting possible problem sizes. Other authors have used GPUs to accelerate model training for machine learning algorithms in genomic selection (<xref rid="B34" ref-type="bibr">Xu et al., 2021</xref>). In parallel to this work, efficient approaches for the multiplication of matrices of mixed input data types have been suggested for use in transformer machine learning models, in particular with sub-byte integer data formats (<xref rid="B8" ref-type="bibr">Kim et al., 2022</xref>).</p>
    <p>In this study, we present tailored algorithms for the multiplication of a compressed SNP matrix by a matrix of small width stored in floating-point format for CPUs and Nvidia<sup>®</sup> GPUs. Our CPU code is optimized for all major instruction set architectures. To take advantage of the instruction-level parallelism capabilities of modern CPUs, our implementation uses Single Instruction-stream Multiple Data-stream (SIMD) operations explicitly (<xref rid="B26" ref-type="bibr">Tanenbaum, 2016</xref>). Extending the Nvidia<sup>®</sup> CUTLASS library (<xref rid="B29" ref-type="bibr">Thakkar et al., 2023</xref>), our GPU approach benefits from fast tile iterators in the data movement during the matrix-matrix multiplication.</p>
    <p>We demonstrate how these advances can drastically reduce the computing times of genotype matrix multiplications on CPUs and GPUs compared to double-precision matrix multiplication routines provided by the Intel<sup>®</sup> MKL, while simultaneously reducing memory requirements. We provide scripts for reproducing our results in the GitHub repository. Additionally, using genomic data provided by the Irish Cattle Breeding Federation and the genetic evaluation software MiXBLUP (<xref rid="B28" ref-type="bibr">ten Napel et al., 2021</xref>), we show how our novel approaches bring down total run times in solving single-step evaluations by up to 62%, thereby paving the way to include even larger population sizes in genomic evaluations.</p>
    <p>We provide our implementation as part of the C/CUDA software library <italic>miraculix</italic> (<ext-link xlink:href="https://github.com/alexfreudenberg/miraculix" ext-link-type="uri">https://github.com/alexfreudenberg/miraculix</ext-link>). Interfaces to call the library from higher-level languages such as Fortran, R and Julia are provided. Through the modular structure of the <italic>miraculix</italic> library, which also supplies functions for the calculation of <bold>G</bold>, the code should be easily modifiable by researchers and practitioners interested in accelerating computations in other BLUP models (<xref rid="B14" ref-type="bibr">Meuwissen et al., 2001</xref>; <xref rid="B33" ref-type="bibr">VanRaden, 2008</xref>) or other genomic analyses.</p>
  </sec>
  <sec sec-type="methods" id="s2">
    <title>2 Methods</title>
    <p>The efficient multiplication of the genotype matrix by a double-precision matrix plays an important role in many genomic analyses. In this section, we explain how this multiplication can be decomposed to reduce the computational costs involved. Then, we propose novel techniques for the multiplication of a compressed SNP matrix with a double-precision matrix on CPUs and GPUs. We illustrate the role of an efficient genotype matrix multiplication at the example of single-step models. Lastly, we describe the methodology which we used for evaluating our approaches.</p>
    <sec id="s2-1">
      <title>2.1 Computational bottlenecks</title>
      <p>We consider the commonly encountered operation of multiplying the centered SNP matrix <bold>Z</bold>, or its transpose <bold>Z</bold>′, by a matrix of low width. Here, the matrix <bold>Z</bold> can be computed as<disp-formula id="equ1"><mml:math id="m1" overflow="scroll"><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="bold">M</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:math></disp-formula>where <inline-formula id="inf1"><mml:math id="m2" overflow="scroll"><mml:mi mathvariant="bold">M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mn>0,1,2</mml:mn></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>s</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:math></inline-formula> denotes the uncentered genotype matrix containing the <italic>n</italic>
<sub>s</sub> SNP genotypes (coded as 0 for one homozygous genotype, 1 for the heterozygous genotype, or 2 for the alternate homozygous genotype) of <italic>n</italic>
<sub>g</sub> genotyped animals. Furthermore, <bold>p</bold> denotes the vector of allele frequencies and the subtraction of <inline-formula id="inf2"><mml:math id="m3" overflow="scroll"><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula> centers the columns of <bold>M</bold>.</p>
      <p>Considering an arbitrary matrix <inline-formula id="inf3"><mml:math id="m4" overflow="scroll"><mml:mi mathvariant="bold">Λ</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>s</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>, we first note that the multiplication of <bold>Z</bold> with <bold>Λ</bold> can be reformulated into<disp-formula id="equ2"><mml:math id="m5" overflow="scroll"><mml:mi mathvariant="bold">Z</mml:mi><mml:mi mathvariant="bold">Λ</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="bold">M</mml:mi><mml:mi mathvariant="bold">Λ</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold">Λ</mml:mi><mml:mo>.</mml:mo></mml:math></disp-formula>
</p>
      <p>Since subtracting the matrix <inline-formula id="inf4"><mml:math id="m6" overflow="scroll"><mml:mn>2</mml:mn><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold">Λ</mml:mi></mml:math></inline-formula> consists of a vector-matrix multiplication and subsequent additions of matrices of rank one, it is computationally cheap and can be achieved with BLAS Level-1 operations. The multiplication of the transposed matrix <inline-formula id="inf5"><mml:math id="m7" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> with an arbitrary matrix <inline-formula id="inf6"><mml:math id="m8" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> is decomposed similarly into<disp-formula id="equ3"><mml:math id="m9" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">M</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mi mathvariant="bold">p</mml:mi><mml:msubsup><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mo>.</mml:mo></mml:math></disp-formula>
</p>
      <p>Here, we use the distinction between <bold>Λ</bold> and <inline-formula id="inf7"><mml:math id="m10" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> to emphasize that <bold>Z</bold> and <bold>Z</bold>′ cannot be multiplied with the same matrix because they have different dimensions. Due to the low cost of SNP genotyping, the matrix <bold>M</bold> can have extremely large dimensions, capturing the genomic information of millions of animals. Furthermore, whereas <bold>Λ</bold> is a regular matrix of double-precision, the SNP matrix is usually stored in a compressed format to save memory. For instance, the PLINK 1 binary file format stores the genotypes of four individuals in eight bits (corresponding to one byte), utilizing that one entry of <bold>M</bold> only requires two bits of storage. This compressed data format prevents naive calls to BLAS routines, and decompressing it explicitly is inefficient and increases memory requirements. Only recently, the problem of matrix multiplication of mixed input data types has gained attention (<xref rid="B8" ref-type="bibr">Kim et al., 2022</xref>) and no off-the-shelf solution exists for compressed 2-bit integer data types.</p>
      <p>In general, algorithms for genotype matrix multiplications that operate on compressed data can be expected to be more efficient due to the better utilization of memory movements. In cases where the multiplication <bold>ZΛ</bold> needs to be evaluated repeatedly for varying <bold>Λ</bold>, an optional conversion of the uncentered SNP matrix <bold>M</bold> to a different storage format is comparatively cheap. Therefore, switching the storage format has the potential to yield efficiency gains.</p>
    </sec>
    <sec id="s2-2">
      <title>2.2 Acceleration of the genotype matrix-matrix multiplication</title>
      <sec id="s2-2-1">
        <title>2.2.1 Previous approach</title>
        <p><xref rid="B31" ref-type="bibr">Vandenplas et al. (2020)</xref> proposed a decompress-on-the-fly approach, consisting of unpacking tiles of submatrices of <bold>M</bold> small enough to store the result in the cache and perform matrix multiplication on these tiles. Briefly, modern computer architecture implements different levels of cache memory (commonly, L1, L2, and L3) to reduce access times to repeatedly processed data. While infrequently used data can be stored in the random access memory (RAM) or even on the disk, accessing it over the memory bus combined with the lower clock cycles of the RAM compared to the CPU dramatically slows down the execution of the program. While low levels of cache close to the core allow faster memory reads, they come with lower capacity (<xref rid="B26" ref-type="bibr">Tanenbaum, 2016</xref>). Hence, efficient code which processes large amounts of data strives to reduce data movement along the memory hierarchy and utilizes the fast access times of low-level caches. In the aforementioned local decompression approach by <xref rid="B31" ref-type="bibr">Vandenplas et al. (2020)</xref>, small submatrices of SNP data in PLINK 1 binary format are sequentially converted to double-precision floating-point values. Since these small submatrices are used repeatedly in a loop, they should not be evicted from the L1 cache. Therefore, the unpacked SNP data is readily at hand when new tiles of <bold>Λ</bold> are loaded and can be multiplied without additional conversion operations.</p>
      </sec>
      <sec id="s2-2-2">
        <title>2.2.2 The <italic>5codes</italic> algorithm for CPUs</title>
        <p>Building on the idea of keeping frequently used data close to the core, our novel approach for CPU computations aims to reduce data streams of <bold>Λ</bold> through the cache hierarchy by fully avoiding decompression. To explain this approach, we assume that there are no missing values at this point. Instead, they are coded as zero and their effect is taken into account when subtracting <inline-formula id="inf8"><mml:math id="m11" overflow="scroll"><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold">Λ</mml:mi></mml:math></inline-formula> or <inline-formula id="inf9"><mml:math id="m12" overflow="scroll"><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi><mml:mn mathvariant="bold">1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> later. Since the number of missing values is usually not substantial, this correction comes at a low cost.</p>
        <p>We view the problem of storing compressed SNP data through the lens of combinatorics: Since there are only three possible states (0, 1, and 2) for a SNP, any vector <bold>m</bold> ∈ {0,1,2}<sup>5</sup> of five contiguous SNPs can assume only one of 3<sup>5</sup> = 243 values. Assuming there are no missing values, this format requires only 80% of the memory required for storing SNP values in 2 bits. Hence, each realized vector <bold>m</bold> can be stored in one 8-bit unsigned integer while preserving the order of the SNPs. During preprocessing, we convert the input data to this compressed format, which we coined <italic>5codes</italic>. At multiplication time, we treat the columns of <bold>Λ</bold> separately and load a vector <inline-formula id="inf10"><mml:math id="m13" overflow="scroll"><mml:mi mathvariant="bold">λ</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> of five entries in a column of <bold>Λ</bold>, which is stored in double precision. Subsequently, we compute all possible results of the scalar product<disp-formula id="equ4"><mml:math id="m14" overflow="scroll"><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">m</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold-italic">λ</mml:mi><mml:mo>,</mml:mo><mml:mspace width="1em"/><mml:mtext>for</mml:mtext><mml:mspace width="0.3333em"/><mml:mi mathvariant="bold">m</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mfenced open="{" close="}"><mml:mrow><mml:mn>0,1,2</mml:mn></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:math></disp-formula>and store them in a hash table. Then, we iterate over the five columns of <bold>M</bold> under consideration and look up the values of <bold>x</bold> depending on the realization of <bold>m</bold>. We provide pseudo-code for one iteration of this approach in <xref rid="alg1" ref-type="statement">Algorithm 1</xref>. The multiplication <inline-formula id="inf11"><mml:math id="m15" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">M</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is achieved analogously.</p>
        <p>It is worth noting that at least 16 of these tables fit into the L1 cache because each hash table holds 3<sup>5</sup> = 243 double-precision values of 64 bits and the L1 cache in modern CPU architectures typically holds between 32 and 96 KB. Since the hash table of the different values of <bold>x</bold> only needs to be computed once for every five-row tile of <bold>Λ</bold>, we keep register instructions to a minimum. Furthermore, compressed matrix values are loaded into integer registers whereas real values are stored in SIMD registers. The implementation aims to optimize load operations and store operations. For instance, if SIMD registers of 256-bit width are available, one entry of the hash table contains a vector of four double-precision floating-point values.</p>
        <p>The computation is parallelized among the available processor cores by splitting <bold>M</bold> and <bold>Λ</bold> into chunks along the column axis and row axis respectively. Finally, the results of each thread are united by a single reduction operation at the end that computes the sum of all individual results.</p>
        <p>As discussed above, genotype centering is not a bottleneck due to its low complexity. Thanks to the structure of the <italic>5codes</italic> encoding, the centering can actually be included in the hash table for the operation <bold>ZΛ</bold>, meaning that instead of holding the possible values of <bold>m</bold>′<bold><italic>λ</italic></bold>, the hash table can store the centered values<disp-formula id="equ5"><mml:math id="m16" overflow="scroll"><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold">λ</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">m</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold">λ</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">p</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi mathvariant="bold-italic">λ</mml:mi><mml:mo>.</mml:mo></mml:math></disp-formula>
</p>
        <p>Subtracting 2 ⋅<bold>p<italic>′λ</italic>
</bold> at this point further reduces the number of memory accesses and decreases numerical accumulation errors.</p>
        <p>
          <statement content-type="algorithm" id="alg1">
            <label>Algorithm 1</label>
            <p>Pseudo-code for the <italic>5codes</italic> algorithm for the multiplication of five columns of SNPs <bold>M</bold> with a vector <italic><bold>λ</bold></italic> of length 5. The multiplication of five columns of <bold>M<italic>′</italic>
</bold> is analogous. Note that the variable <monospace>idx</monospace> in the algorithm is smaller than 243. For a general number of SNPs <italic>n</italic>
<sub>s</sub>, five columns of <bold>M</bold> are multiplied at a time.<list list-type="simple"><list-item><p><bold>Data:</bold> Compressed SNP matrix <inline-formula id="inf12"><mml:math id="m17" overflow="scroll"><mml:mi mathvariant="bold">M</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">{</mml:mo><mml:mrow><mml:mn>0,1,2</mml:mn></mml:mrow><mml:mo stretchy="false">}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>g</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula>, floating-point vector <inline-formula id="inf13"><mml:math id="m18" overflow="scroll"><mml:mi mathvariant="bold-italic">λ</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula>
</p></list-item><list-item><p><bold>Result:</bold> Genotype matrix multiplication <bold>x = M<italic>λ</italic>
</bold>
</p></list-item><list-item><p><bold>1</bold><monospace>/* Compute and store the dot products of </monospace><bold><italic>λ</italic></bold><monospace> with all possible SNP vectors */</monospace></p></list-item><list-item><p><bold>2 for</bold><bold>m</bold> ∈ {0,1,2}<sup>5</sup> <bold>do</bold>
</p></list-item><list-item><p><bold>3</bold>   <sans-serif>idx</sans-serif> ← <bold>m</bold>
<sub>1</sub> × 3<sup>0</sup> + <bold>m</bold>
<sub>2</sub> × 3<sup>1</sup> + <bold>m</bold>
<sub>3</sub> × 3<sup>2</sup> + <bold>m</bold>
<sub>4</sub> × 3<sup>3</sup> + <bold>m</bold>
<sub>5</sub> × 3<sup>4</sup>
</p></list-item><list-item><p><bold>4 </bold><monospace>  /* Compute and store </monospace><bold>m</bold>′<italic>λ</italic><monospace>*/</monospace></p></list-item><list-item><p><bold>5 </bold><sans-serif>  table[</sans-serif><sans-serif>idx</sans-serif><sans-serif>]</sans-serif> ← <bold>m</bold>
<sub>1</sub> × <italic><bold>λ</bold></italic>
<sub>1</sub> + <bold>m</bold>
<sub>2</sub> × <italic><bold>λ</bold></italic>
<sub>2</sub> + <bold>m</bold>
<sub>3</sub> × <italic><bold>λ</bold></italic>
<sub>3</sub> + <bold>m</bold>
<sub>4</sub> × <italic><bold>λ</bold></italic>
<sub>4</sub> + <bold>m</bold>
<sub>5</sub> × <italic><bold>λ</bold></italic>
<sub>5</sub>
</p></list-item><list-item><p><bold>6 end</bold></p></list-item><list-item><p><bold>7</bold><monospace>/* Compute</monospace><bold>M<italic>λ</italic>
</bold><monospace>by looking up the realization of</monospace><bold>m</bold><monospace>in the matrix</monospace><bold>M</bold><monospace>. */</monospace></p></list-item><list-item><p><bold>8 for</bold> <italic>j</italic> ← 1 <bold><italic>to </italic></bold>
<italic>n</italic>
<sub>g</sub>
<bold>do</bold>
</p></list-item><list-item><p><bold>9 </bold>  <sans-serif>key</sans-serif> ←<bold>M</bold>
<sub><italic>j</italic>,1</sub> × 3<sup>0</sup> + <bold>M</bold>
<sub><italic>j</italic>,2</sub> × 3<sup>1</sup> + <bold>M</bold>
<sub><italic>j</italic>,3</sub> × 3<sup>2</sup> + <bold>M</bold>
<sub><italic>j</italic>,4</sub> × 3<sup>3</sup> + <bold>M</bold>
<sub><italic>j</italic>,5</sub> × 3<sup>4</sup>
</p></list-item><list-item><p><bold>10</bold>   <italic>x</italic>[<italic>j</italic>] ← <sans-serif>table[</sans-serif>
<sans-serif>key</sans-serif>
<sans-serif>]</sans-serif>
</p></list-item><list-item><p><bold>11 end</bold></p></list-item></list>
</p>
          </statement>
        </p>
      </sec>
      <sec id="s2-2-3">
        <title>2.2.3 SNP matrix multiplication with mixed data types on GPUs</title>
        <p>To make use of the powerful HPC capabilities of modern Nvidia<sup>®</sup> GPUs, we also implement a matrix multiplication routine in CUDA, in which we extend the CUTLASS library (<xref rid="B29" ref-type="bibr">Thakkar et al., 2023</xref>) in its version 2.10. CUTLASS is a C++ template library for high-performance matrix operations on Nvidia<sup>®</sup> GPUs. In contrast to CPU operations, GPU functions need to align parallel operations both within thread blocks as well as within warps of threads (<xref rid="B21" ref-type="bibr">Sanders and Kandrot, 2010</xref>). CUTLASS assists this task by providing a framework that allows software solutions to target only a subset of levels in this hierarchy. In our case, we implement a template specialization for the Single Instruction Multiple Threads (SIMT) subsection within warp-level API in CUTLASS. Since computing times for our GPU approach are mostly driven by data movements instead of algebraic operations, we do not make use of the <italic>5codes</italic> algorithm in this implementation but distribute scalar products of four-dimensional vectors to the cores of the GPU. Therefore, we keep the established PLINK 8-bit-sized format for storing a four-dimensional vector corresponding to four SNPs, where each SNP is coded as either 0 for the homozygous genotype, 1 for a missing genotype, 2 for the heterozygous genotype and 3 for the alternate homozygous genotype. For compatibility with CUTLASS, we introduce a new interleaved data type for double-precision vectors of size four. Furthermore, fitting the genotype matrix multiplication into the CUTLASS framework requires adding a new scalar-product microkernel for this specific combination of data types and adjusting the CUTLASS interfaces upstream accordingly. The microkernel uses bitmasks to extract the SNP values from the compressed storage format and converts them into double-precision floating-point values for immediate multiplication afterward. Through the highly efficient memory access iterators in CUTLASS, we are able to move data quickly from the device memory to the shared memory to the cores and back. Furthermore, in order to reduce memory allocations and data movement between the host and the device, we preallocate memory for the matrix <bold>Λ</bold> and transfer data objects which are required in every PCG iteration (that is, <bold>M</bold> and <bold>p</bold>) only once at start-up time. To our knowledge, this is the first implementation of matrix multiplication of 2-bit integers with double-precision floating-point values, which we designed in parallel to the recent work of <xref rid="B8" ref-type="bibr">Kim et al. (2022)</xref> who extended the CUTLASS library to include, among others, matrix multiplication of 4-bit integers with half-precision floating-point values.</p>
      </sec>
      <sec id="s2-2-4">
        <title>2.2.4 Memory management</title>
        <p>Since both the CPU and GPU approaches exploit a compressed storage format for the SNP matrix, the question arises of how to efficiently calculate the transposed matrix product <inline-formula id="inf14"><mml:math id="m19" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">M</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. A memory-efficient implementation would transpose chunks of <bold>M</bold> of low dimension which are iterated over. For instance, transposing sub-matrices of dimensions 16 by 16 in PLINK 1 binary format would allow distributing the transpose operation in a warp of threads on a GPU. However, thanks to the compressed data storage, we are not memory-bound with the current number of genotyped animals and SNPs, and we, therefore, choose to transpose <bold>M</bold> as a whole during start-up and store it separately to reduce computation time associated with transposition. For instance, the dataset of 2.61 m animals with 47 k SNP markers we use in this article for testing purposes only requires about 57 gigabytes of RAM for both <bold>M</bold> and <bold>M</bold>′ combined.</p>
      </sec>
    </sec>
    <sec id="s2-3">
      <title>2.3 SNP matrix multiplications in single-step models</title>
      <p>Single-step models in animal breeding programs commonly comprise hundreds of thousands or even millions of animals. Therefore, the MME for these models need to be solved iteratively in practice, commonly through the PCG algorithm. To this end, each iteration requires multiplying the corresponding coefficient matrix with a candidate vector.</p>
      <p>To illustrate the necessity of a fast genotype matrix multiplication, we give an overview of the matrix operations involved in the ssSNPBLUP approach, proposed by <xref rid="B11" ref-type="bibr">Liu et al. (2014)</xref>, and the ssGTABLUP approach, introduced by <xref rid="B12" ref-type="bibr">Mäntysaari et al. (2017)</xref>. Both univariate models can be easily extended to multivariate applications. The numerical treatment of these approaches is described in detail by <xref rid="B32" ref-type="bibr">Vandenplas et al. (2023)</xref> who found that they have similar computational costs per iteration when applied to large datasets since they require the same matrix computations.</p>
      <p>A standard univariate mixed model for ssGBLUP can be written as:<disp-formula id="equ6"><mml:math id="m20" overflow="scroll"><mml:mi mathvariant="bold">y</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="bold">X</mml:mi><mml:mi mathvariant="bold">b</mml:mi><mml:mo>+</mml:mo><mml:mfenced open="[" close="]"><mml:mrow><mml:mtable class="matrix"><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="center"><mml:mn mathvariant="bold">0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mn mathvariant="bold">0</mml:mn></mml:mtd><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced open="[" close="]"><mml:mrow><mml:mtable class="matrix"><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">u</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">u</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi mathvariant="bold">e</mml:mi></mml:math></disp-formula>where <bold>y</bold> is the vector of records, <bold>b</bold> is the vector of <italic>n</italic>
<sub>fixed</sub> fixed effects, <bold>u</bold>
<sub><italic>n</italic></sub> is the vector of additive genetic effects for the non-genotyped animals, <bold>u</bold>
<sub><italic>g</italic></sub> is the vector of additive genetic effects for the genotyped animals, and <bold>e</bold> is the vector of residuals. The matrices <bold>X</bold>, <bold>W</bold>
<sub><italic>n</italic></sub>, and <bold>W</bold>
<sub><italic>g</italic></sub> are incidence matrices relating records in <bold>y</bold> to the corresponding effects. The random effects vector <bold>u</bold>
<sub><italic>g</italic></sub> can be decomposed into <bold>u</bold>
<sub><italic>g</italic></sub> = <bold>a</bold>
<sub><italic>g</italic></sub> + <bold>Zg</bold>, where <bold>g</bold> is the vector of SNP effects and <bold>a</bold>
<sub><italic>g</italic></sub> contains the residual polygenic effects.</p>
      <p>Due to the assumed covariance structure, the ssSNPBLUP system of equations proposed by <xref rid="B11" ref-type="bibr">Liu et al. (2014)</xref> involves the matrix <bold>Σ</bold>
<sup>−1</sup> defined as<disp-formula id="equ7"><mml:math id="m21" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Σ</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"><mml:mrow><mml:mtable class="matrix"><mml:mtr><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd columnalign="center"><mml:mn mathvariant="bold">0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mfenced open="(" close=")"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mtd><mml:mtd columnalign="center"><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mi mathvariant="bold">Z</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mn mathvariant="bold">0</mml:mn></mml:mtd><mml:mtd columnalign="center"><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mtd><mml:mtd columnalign="center"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mi mathvariant="bold">Z</mml:mi><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfrac><mml:mi mathvariant="bold">I</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:msubsup><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:math></disp-formula>where the scalar <inline-formula id="inf15"><mml:math id="m22" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:math></inline-formula> is the inverse of the additive genetic variance, <italic>w</italic> between 0 and 1 is the proportion of variance not explained by SNP markers, called residual polygenic effects, and <inline-formula id="inf16"><mml:math id="m23" overflow="scroll"><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msubsup><mml:mrow><mml:mo movablelimits="false" form="prefix">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>s</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mfenced open="(" close=")"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:math></inline-formula> for <inline-formula id="inf17"><mml:math id="m24" overflow="scroll"><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>s</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi mathvariant="bold">p</mml:mi></mml:math></inline-formula>. Furthermore, the matrix<disp-formula id="equ8"><mml:math id="m25" overflow="scroll"><mml:mi mathvariant="bold">A</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"><mml:mrow><mml:mtable class="matrix"><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="center"><mml:msub><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:math></disp-formula>denotes the pedigree-based relationship matrix and<disp-formula id="equ9"><mml:math id="m26" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mfenced open="[" close="]"><mml:mrow><mml:mtable class="matrix"><mml:mtr><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd columnalign="center"><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>.</mml:mo></mml:math></disp-formula>is its inverse, which is sparse (<xref rid="B7" ref-type="bibr">Henderson, 1976</xref>). Here, <italic>n</italic> and <italic>g</italic> denote non-genotyped and genotyped animals respectively. The inverse of <bold>A</bold>
<sub><italic>gg</italic></sub> can be computed as<disp-formula id="equ10"><mml:math id="m27" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mfenced open="(" close=")"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>g</mml:mi></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:math></disp-formula>
</p>
      <p>Because the coefficient matrices of the ssSNPBLUP and ssGTABLUP models are too large to be constructed explicitly, it is decomposed into submatrices which are multiplied separately (<xref rid="B31" ref-type="bibr">Vandenplas et al., 2020</xref>). Importantly, most of these submatrices (e.g., <bold>A</bold>
<sup><italic>nn</italic></sup>, <bold>A</bold>
<sup><italic>ng</italic></sup>, <bold>A</bold>
<sup><italic>gn</italic></sup>, <bold>A</bold>
<sup><italic>gg</italic></sup>) in <bold>Σ</bold>
<sup>−1</sup> are sparse and can be multiplied by a vector or a matrix at a relatively low cost by using iteration-on-data techniques (<xref rid="B23" ref-type="bibr">Schaeffer and Kennedy, 1986</xref>) and sparse matrix operations (<xref rid="B10" ref-type="bibr">Legarra et al., 2009</xref>; <xref rid="B31" ref-type="bibr">Vandenplas et al., 2020</xref>). Additionally, although the matrix <inline-formula id="inf18"><mml:math id="m28" overflow="scroll"><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> is not sparse in general, equation systems involving <inline-formula id="inf19"><mml:math id="m29" overflow="scroll"><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:math></inline-formula> can be solved by using forward and backward substitution techniques with the Cholesky factor of <bold>A</bold>
<sup><italic>nn</italic></sup>, which only needs to be computed once. Therefore, this calculation is also not computationally demanding in practice. In contrast, the multiplication of <bold>Z</bold> by an arbitrary matrix of low width <bold>Λ</bold> has been a computational bottleneck so far.</p>
    </sec>
    <sec id="s2-4">
      <title>2.4 Evaluation</title>
      <p>Since both the <italic>5codes</italic> algorithm and our GPU approach take advantage of modern hardware architectures, it can be expected that they outperform the existing implementations. To quantify the benefits, we used simulated data to benchmark our concepts for genotype data of various sizes. Afterward, considering the ssSNPBLUP and ssGTABLUP systems of equations on a large population of Irish beef and dairy cattle, we evaluated the wall clock times for estimating the breeding values in this population using the PCG implementation in the software MiXBLUP (<xref rid="B28" ref-type="bibr">ten Napel et al., 2021</xref>). We compared our novel approaches with the wall clock time required by the current Fortran-based matrix multiplication implementation in MiXBLUP.</p>
      <sec id="s2-4-1">
        <title>2.4.1 Simulated data</title>
        <p>For benchmarking our two novel approaches, we simulated genotype data of various dimensions using the software suite PLINK (<xref rid="B2" ref-type="bibr">Chang et al., 2015</xref>). Mimicking the population sizes of many breeding programs in practice, we generated genotype data of three distinct animal populations with a varying number of individuals: a small population with 102 k animals, a medium population with 751 k animals and a large population with 3.1 m animals. For each population, 50,241 SNPs were simulated, resulting in memory requirements of approx. 1.2 GB in compressed storage format (38.2 GB in double-precision) for the small population, 8.8 GB (281.2 GB) for the medium population, and 36.3 GB (1,160.6 GB) for the large population. Furthermore, we simulated a matrix <bold>Λ</bold> of 10 normally distributed traits.</p>
      </sec>
      <sec id="s2-4-2">
        <title>2.4.2 Cattle data</title>
        <p>We tested our two novel approaches when integrated into the PCG solver using data from the routine six-trait calving-difficulty evaluation for Irish dairy and beef cattle performed by Irish Cattle Breeding Federation (ICBF; Ireland) in March 2022. We solved the equation systems associated with the ssSNPBLUP and ssGTABLUP models. The single-step genomic evaluations were based on the same multi-trait animal model and variance components as the current official routine breeding value evaluation described in more detail in <xref rid="B4" ref-type="bibr">Evans et al. (2019)</xref> and <xref rid="B32" ref-type="bibr">Vandenplas et al. (2023)</xref>. Briefly, after extraction and editing, the data file included 16.59 m data records (across 6 traits), and the pedigree included 26.46 m animals. The genotypes of 2.61 m animals included 47,006 SNP markers from 29 bovine autosomes, with a minor allele frequency greater or equal to 0.01. The genotype data were from a range of 30 different arrays ranging from 3 to 850 k SNPs that had been imputed using FImpute (<xref rid="B22" ref-type="bibr">Sargolzaei et al., 2014</xref>) to a 50 k SNP set based on version 3 of the International Beef and Dairy (IDB) chip. For both single-step approaches, the genotype matrix was centered using observed allele frequencies and the proportion of residual polygenic effects was set to <italic>w</italic> = 0.20.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="results" id="s3">
    <title>3 Results</title>
    <sec id="s3-1">
      <title>3.1 Benchmarks</title>
      <p>In <xref rid="F1" ref-type="fig">Figure 1</xref>, we assess the performance of consecutively multiplying <bold>ZΛ</bold> and <inline-formula id="inf20"><mml:math id="m30" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, as required in each iteration of a PCG solver. We compare our implementation of the <italic>5codes</italic> algorithm and the GPU implementation with two alternative solutions: 1) The decompress-on-the-fly approach implemented in Fortran and proposed by <xref rid="B31" ref-type="bibr">Vandenplas et al. (2020)</xref>, which we will call “original solution” below, and 2) a single call to the double-precision matrix multiplication function (<monospace>dgemm</monospace>) which is part of all major BLAS libraries. As for the latter, we first needed to inflate the full SNP matrix to double-precision floating-point values and store both the SNP matrix as well as its transpose in memory. We use the BLAS library included in the Intel<sup>®</sup> Math Kernel Library (MKL). For compilation, we used the Intel<sup>®</sup> compiler in its version 2021.4.0 and employed compilation options to natively optimize our code to the available hardware. We ran our CPU benchmarks on a single AMD<sup>®</sup> Milan EPYC 7513 (2.6 GHz) CPU and our GPU implementation on an Nvidia<sup>®</sup> H100. Since our implementation of the <italic>5codes</italic> algorithm did not display considerable scalability advances beyond 20 cores (see <xref rid="T1" ref-type="table">Table 1</xref>) and the software MiXBLUP recommends a similar number of cores for parallelizing computations, we refrain from testing it on more cores.</p>
      <fig position="float" id="F1">
        <label>FIGURE 1</label>
        <caption>
          <p>Total wall clock time for consecutively calculating <bold>ZΛ</bold> and <inline-formula id="inf21"><mml:math id="m31" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> on a system with a dual-socket AMD<sup>®</sup> Milan EPYC 7513 (2.6 GHz) processor, 2 TB of RAM and a single Nvidia<sup>®</sup> H100 GPU. Annotations show formatted computing times in seconds. CPU calculations used 20 dedicated cores. No test was performed for the BLAS routine with the large population size, as this would have required ca. 2.27 TB of RAM. Results are the average of 10 repeated calculations.</p>
        </caption>
        <graphic xlink:href="fgene-14-1220408-g001" position="float"/>
      </fig>
      <table-wrap position="float" id="T1">
        <label>TABLE 1</label>
        <caption>
          <p>Computation wall clock times in seconds of the GPU implementation and the CPU algorithm <italic>5codes</italic> for the multiplication of the genotype matrix Z and its transposed Z′ with simulated matrices Λ and <inline-formula id="inf22"><mml:math id="m32" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. CPU operations were performed with 2 TB of RAM on the Intel<sup>®</sup> Xeon Gold 6230 (2.1 GHz) and the AMD<sup>®</sup> EPYC 7513 (2.6 GHz) on 1 core, 10 cores and 20 cores. The V100 GPUs were equipped with 32 GB of device memory, while the A100 and H100 models had a capacity of 80 GB. Dashes (−) indicate out-of-memory events. Results are the average of 10 repeated calculations.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead valign="top">
            <tr>
              <th align="left" rowspan="1" colspan="1">Population</th>
              <th rowspan="2" align="left" colspan="1">Operation</th>
              <th colspan="3" align="center" rowspan="1">Nvidia<sup>®</sup>
</th>
              <th colspan="3" align="center" rowspan="1">Intel<sup>®</sup>
</th>
              <th colspan="3" align="center" rowspan="1">AMD<sup>®</sup>
</th>
            </tr>
            <tr>
              <th align="left" rowspan="1" colspan="1">Size</th>
              <th align="left" rowspan="1" colspan="1">V100</th>
              <th align="left" rowspan="1" colspan="1">A100</th>
              <th align="left" rowspan="1" colspan="1">H100</th>
              <th align="left" rowspan="1" colspan="1">1c</th>
              <th align="left" rowspan="1" colspan="1">10c</th>
              <th align="left" rowspan="1" colspan="1">20c</th>
              <th align="left" rowspan="1" colspan="1">1c</th>
              <th align="left" rowspan="1" colspan="1">10c</th>
              <th align="left" rowspan="1" colspan="1">20c</th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td rowspan="2" align="left" colspan="1">Small</td>
              <td align="left" rowspan="1" colspan="1">
                <inline-formula id="inf229">
                  <mml:math id="m239" overflow="scroll">
                    <mml:mrow>
                      <mml:mi mathvariant="bold">Z</mml:mi>
                      <mml:mi mathvariant="bold">Λ</mml:mi>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td align="left" rowspan="1" colspan="1">0.10</td>
              <td align="left" rowspan="1" colspan="1">0.06</td>
              <td align="left" rowspan="1" colspan="1">0.05</td>
              <td align="left" rowspan="1" colspan="1">2.24</td>
              <td align="left" rowspan="1" colspan="1">0.36</td>
              <td align="left" rowspan="1" colspan="1">0.35</td>
              <td align="left" rowspan="1" colspan="1">1.71</td>
              <td align="left" rowspan="1" colspan="1">0.38</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <inline-formula id="inf23">
                  <mml:math id="m33" overflow="scroll">
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">Z</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>′</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mrow>
                          <mml:mi mathvariant="bold">Λ</mml:mi>
                        </mml:mrow>
                        <mml:mo>~</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td align="left" rowspan="1" colspan="1">0.10</td>
              <td align="left" rowspan="1" colspan="1">0.06</td>
              <td align="left" rowspan="1" colspan="1">0.05</td>
              <td align="left" rowspan="1" colspan="1">2.29</td>
              <td align="left" rowspan="1" colspan="1">0.37</td>
              <td align="left" rowspan="1" colspan="1">0.29</td>
              <td align="left" rowspan="1" colspan="1">1.75</td>
              <td align="left" rowspan="1" colspan="1">0.30</td>
              <td align="left" rowspan="1" colspan="1">0.28</td>
            </tr>
            <tr>
              <td rowspan="2" align="left" colspan="1">Medium</td>
              <td align="left" rowspan="1" colspan="1">
                <bold>ZΛ</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">0.69</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
              <td align="left" rowspan="1" colspan="1">0.35</td>
              <td align="left" rowspan="1" colspan="1">16.03</td>
              <td align="left" rowspan="1" colspan="1">2.61</td>
              <td align="left" rowspan="1" colspan="1">2.51</td>
              <td align="left" rowspan="1" colspan="1">12.53</td>
              <td align="left" rowspan="1" colspan="1">2.96</td>
              <td align="left" rowspan="1" colspan="1">2.94</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <inline-formula id="inf24">
                  <mml:math id="m34" overflow="scroll">
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">Z</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>′</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mrow>
                          <mml:mi mathvariant="bold">Λ</mml:mi>
                        </mml:mrow>
                        <mml:mo>~</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td align="left" rowspan="1" colspan="1">0.70</td>
              <td align="left" rowspan="1" colspan="1">0.47</td>
              <td align="left" rowspan="1" colspan="1">0.36</td>
              <td align="left" rowspan="1" colspan="1">16.81</td>
              <td align="left" rowspan="1" colspan="1">2.50</td>
              <td align="left" rowspan="1" colspan="1">1.81</td>
              <td align="left" rowspan="1" colspan="1">13.00</td>
              <td align="left" rowspan="1" colspan="1">2.08</td>
              <td align="left" rowspan="1" colspan="1">1.33</td>
            </tr>
            <tr>
              <td rowspan="2" align="left" colspan="1">Large</td>
              <td align="left" rowspan="1" colspan="1">
                <bold>ZΛ</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">-</td>
              <td align="left" rowspan="1" colspan="1">1.87</td>
              <td align="left" rowspan="1" colspan="1">1.42</td>
              <td align="left" rowspan="1" colspan="1">76.42</td>
              <td align="left" rowspan="1" colspan="1">12.31</td>
              <td align="left" rowspan="1" colspan="1">12.24</td>
              <td align="left" rowspan="1" colspan="1">51.72</td>
              <td align="left" rowspan="1" colspan="1">10.99</td>
              <td align="left" rowspan="1" colspan="1">11.03</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <inline-formula id="inf25">
                  <mml:math id="m35" overflow="scroll">
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi mathvariant="bold">Z</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>′</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mrow>
                      <mml:mover accent="true">
                        <mml:mrow>
                          <mml:mi mathvariant="bold">Λ</mml:mi>
                        </mml:mrow>
                        <mml:mo>~</mml:mo>
                      </mml:mover>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td align="left" rowspan="1" colspan="1">-</td>
              <td align="left" rowspan="1" colspan="1">1.94</td>
              <td align="left" rowspan="1" colspan="1">1.47</td>
              <td align="left" rowspan="1" colspan="1">83.44</td>
              <td align="left" rowspan="1" colspan="1">12.73</td>
              <td align="left" rowspan="1" colspan="1">10.04</td>
              <td align="left" rowspan="1" colspan="1">53.68</td>
              <td align="left" rowspan="1" colspan="1">8.36</td>
              <td align="left" rowspan="1" colspan="1">5.55</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Evaluating our two novel approaches against a crude call to the BLAS-based double-precision matrix multiplication function shows that computing times can be reduced by more than 99.7% (98.1%) for the small and medium populations on the GPU (CPU). Unfortunately, the genotype data of the large population in double precision required approx. 2.27 TB of RAM, which could not be met in our hardware setup, hindering us from benchmarking the BLAS library on this dataset. Similarly, the CPU-based original solution for multiplying compressed SNP matrices with <bold>Λ</bold> took about 19 times longer on all population sizes compared to the GPU implementation and three times longer compared to the <italic>5codes</italic> algorithm.</p>
      <p>To mitigate the impact of hardware-specific optimizations which might limit the reproducibility of our results, we further test our CPU code on Intel<sup>®</sup> and AMD<sup>®</sup> processors (Intel<sup>®</sup> Xeon Gold 6230 and AMD<sup>®</sup> Milan EPYC 7513) and our GPU code on three generations of Nvidia<sup>®</sup> datacenter GPUs (Volta V100, Ampere A100 and Hopper H100). Results displayed in <xref rid="T1" ref-type="table">Table 1</xref> are the average computing times of 10 replicates.</p>
      <p>As for the GPU implementation, our findings suggest that reductions in computing times of approx. 25% (50%) can be achieved when using the recently introduced H100 compared to the A100 (V100). More importantly, the V100 ships with 16 GB or 32 GB of device RAM, limiting the potential problem sizes in our application. Yet, this issue could be mitigated by using multiple GPUs. Since both the transposed and the untransposed matrix are stored on the device, computing times for both multiplications do not differ substantially.</p>
      <p>Despite using the Intel<sup>®</sup> C/C++ Classic Compiler with Intel-specific optimizations, the <italic>5codes</italic> algorithm performs slightly better on the more powerful AMD<sup>®</sup> chip than on the Xeon Gold 6230. We observe that our implementation scales reasonably well to 10 cores, decreasing computing times by at least a factor of 5. However, increasing the number of cores to 20 only yields mild performance improvements and even comes with a penalty in some cases (see <xref rid="T1" ref-type="table">Table 1</xref>).</p>
      <p>Overall, our evaluations suggest that the GPU implementation significantly outperforms the <italic>5codes</italic> implementation, though practical applications should evaluate the costs and benefits of adding a GPU to their hardware setup based on their respective compute time restraints.</p>
    </sec>
    <sec id="s3-2">
      <title>3.2 Impact on single-step genomic evaluations</title>
      <p>We solved the equation systems associated with the ssSNPBLUP and ssGTABLUP models with the program hpblup, a PCG-based solver used by the software MiXBLUP 3.1 (<xref rid="B28" ref-type="bibr">ten Napel et al., 2021</xref>), which links against the <italic>miraculix</italic> library and toggles the use of our two novel implementations through an option. Experiments were performed with 180 GB of RAM on a single AMD<sup>®</sup> EPYC 7513 CPU for the <italic>5codes</italic> algorithm and a single Nvidia<sup>®</sup> A100 for the GPU implementation. For the CPU tests, we used 15 dedicated cores, as this is the recommended setting in MiXBLUP. The PCG was iterated until a square relative residual below 10<sup>–13</sup> was achieved. To put our observed computing times into perspective, we also solved both models with the current approach for multiplying genotype matrices implemented in MiXBLUP 3.1 (which we will call “current” below).</p>
      <p>Results are displayed in <xref rid="T2" ref-type="table">Table 2</xref>. Due to the different nature of the effects estimated, the computing times should be evaluated separately for the two models. For the ssSNPBLUP equation system, we observe that the average wall clock time is reduced by approx. 72% (11%) for the multiplication <bold>ZΛ</bold> and by approx. 95% (76%) for <inline-formula id="inf26"><mml:math id="m36" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> on GPUs (CPUs) respectively. When solving the ssGTABLUP equation system, the average time for multiplying <bold>ZΛ</bold> was slightly higher in the <italic>5codes</italic> algorithm. Yet, both <italic>5codes</italic> and the GPU implementation significantly decreased the time for computing <inline-formula id="inf27"><mml:math id="m37" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>.</p>
      <table-wrap position="float" id="T2">
        <label>TABLE 2</label>
        <caption>
          <p>Computation wall clock times of single-step genomic models on ICBF cattle data in seconds. The SNP matrix Z and its transposed Z′ are multiplied by matrices Λ and <inline-formula id="inf28"><mml:math id="m38" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> respectively to compute the candidate matrix in the PCG. All computations were performed on one AMD Milan EPYC 7513 CPU with 15 dedicated cores. GPU computations were performed on a single Nvidia<sup>®</sup> A100 GPU with 80 GB device memory. Both models were trained to a relative error below 10<sup>–13</sup>. The total time contains preprocessing (I/O operations and set-up of the preconditioner matrix), solving of the MME, and postprocessing (mainly I/O operations).</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead valign="top">
            <tr>
              <th rowspan="2" align="left" colspan="1">Wall clock time (s)</th>
              <th colspan="3" align="center" rowspan="1">ssSNPBLUP</th>
              <th colspan="3" align="center" rowspan="1">ssGTABLUP</th>
            </tr>
            <tr>
              <th align="left" rowspan="1" colspan="1">Current</th>
              <th align="left" rowspan="1" colspan="1">5codes</th>
              <th align="left" rowspan="1" colspan="1">GPU</th>
              <th align="left" rowspan="1" colspan="1">Current</th>
              <th align="left" rowspan="1" colspan="1">5codes</th>
              <th align="left" rowspan="1" colspan="1">GPU</th>
            </tr>
          </thead>
          <tbody valign="top">
            <tr>
              <td align="left" rowspan="1" colspan="1">Average time <inline-formula id="inf129"><mml:math id="m139" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow></mml:math></inline-formula>
</td>
              <td align="left" rowspan="1" colspan="1">5.41</td>
              <td align="left" rowspan="1" colspan="1">4.81</td>
              <td align="left" rowspan="1" colspan="1">1.50</td>
              <td align="left" rowspan="1" colspan="1">8.76</td>
              <td align="left" rowspan="1" colspan="1">10.38</td>
              <td align="left" rowspan="1" colspan="1">1.53</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Average time <inline-formula id="inf29"><mml:math id="m39" overflow="scroll"><mml:msup><mml:mrow><mml:mi mathvariant="bold">Z</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">Λ</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>
</td>
              <td align="left" rowspan="1" colspan="1">29.68</td>
              <td align="left" rowspan="1" colspan="1">7.05</td>
              <td align="left" rowspan="1" colspan="1">1.62</td>
              <td align="left" rowspan="1" colspan="1">28.66</td>
              <td align="left" rowspan="1" colspan="1">6.83</td>
              <td align="left" rowspan="1" colspan="1">1.58</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Average time per iteration</td>
              <td align="left" rowspan="1" colspan="1">51.43</td>
              <td align="left" rowspan="1" colspan="1">32.32</td>
              <td align="left" rowspan="1" colspan="1">14.16</td>
              <td align="left" rowspan="1" colspan="1">50.38</td>
              <td align="left" rowspan="1" colspan="1">35.21</td>
              <td align="left" rowspan="1" colspan="1">16.25</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Number of iterations</td>
              <td align="left" rowspan="1" colspan="1">389</td>
              <td align="left" rowspan="1" colspan="1">362</td>
              <td align="left" rowspan="1" colspan="1">385</td>
              <td align="left" rowspan="1" colspan="1">212</td>
              <td align="left" rowspan="1" colspan="1">212</td>
              <td align="left" rowspan="1" colspan="1">212</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Preprocessing time</td>
              <td align="left" rowspan="1" colspan="1">2953</td>
              <td align="left" rowspan="1" colspan="1">3191</td>
              <td align="left" rowspan="1" colspan="1">3186</td>
              <td align="left" rowspan="1" colspan="1">3493</td>
              <td align="left" rowspan="1" colspan="1">4068</td>
              <td align="left" rowspan="1" colspan="1">3184</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Total time</td>
              <td align="left" rowspan="1" colspan="1">23275</td>
              <td align="left" rowspan="1" colspan="1">15195</td>
              <td align="left" rowspan="1" colspan="1">8961</td>
              <td align="left" rowspan="1" colspan="1">14504</td>
              <td align="left" rowspan="1" colspan="1">11863</td>
              <td align="left" rowspan="1" colspan="1">7138</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>As the genotype matrix multiplication constitutes a significant portion of the time per iteration in the PCG solver, the <italic>5codes</italic> implementation reduced the time for solving the ssSNPBLUP model from approx. 6.47 h to 4.22 h on the CPU. Similarly, the wall clock time for solving the ssGTABLUP model was reduced from 4.03 h to 3.30 h. Outperforming these results, the GPU approach only required 2.49 h for the ssSNPBLUP model and 1.98 h for the ssGTABLUP model. A similar number of iterations was observed for solving all models, though the <italic>5codes</italic> algorithm required 27 iterations less for solving the MME associated with the ssSNPBLUP model, which might be explained by its inherently higher precision.</p>
    </sec>
  </sec>
  <sec sec-type="discussion" id="s4">
    <title>4 Discussion</title>
    <p>We have presented novel approaches for multiplying centered genotype matrices <bold>M</bold> by a continuously-scaled matrix <bold>Λ</bold> which are applicable both on CPUs as well as on modern GPUs. Useful applications include single-step genomic models that are used to compute breeding value estimates when only a subset of animals are genotyped and/or phenotyped. Yet, similar computational operations are employed in other fields of modern genetics. For instance, genome-wide association studies could benefit from a fast genotype matrix multiplication at various computational bottlenecks: the multiplication of the SNP matrix by a phenotype vector is an essential part of the calculation of genotype-phenotype correlations (<xref rid="B35" ref-type="bibr">Yang et al., 2011</xref>). Additionally, many genome-wide association studies use the results of a principal component analysis (PCA) of <bold>G</bold> for population stratification (<xref rid="B20" ref-type="bibr">Price et al., 2006</xref>; <xref rid="B15" ref-type="bibr">Meuwissen et al., 2017</xref>; <xref rid="B19" ref-type="bibr">Ødegård et al., 2018</xref>) and hence are to gain from a fast genotype matrix multiplication as well.</p>
    <p>Through our optimized algorithms we were able to achieve a speed-up of critical operations by a factor of up to 3 compared to the methodology by <xref rid="B31" ref-type="bibr">Vandenplas et al. (2020)</xref> using CPUs, and a factor of up to 20 using GPUs. Thanks to this acceleration, we have shown how our software library can be used by researchers and practitioners to estimate breeding values in a population of 26.46 m animals, 2.61 m of which were genotyped, in a reasonable time of approx. 2 h.</p>
    <p>Nevertheless, the growth of breeding populations as well as the steadily falling costs of genotyping will result in genomic datasets of ever-growing size. Therefore, there are several avenues for further research to utilize computing resources even more efficiently.</p>
    <p>First, as indicated in <xref rid="s2" ref-type="sec">Section 2</xref>, system memory requirements might be reduced by a factor of approximately two by transposing the compressed genotype matrix on-the-fly during matrix multiplication instead of storing the transpose explicitly. With Nvidia<sup>®</sup> GPUs currently limited to at most 94 GB device memory and most compute set-ups limited to hundreds of gigabytes of RAM, this improvement would extend the dimensions of possible problem sizes addressable with our proposed matrix-multiplication microkernel.</p>
    <p>Second, though our GPU implementation uses highly efficient data access iterators provided by the CUTLASS library, a further reduction in computing time might be achieved by using warp-level-coordinated matrix operations, which have been added as hardware instructions on the latest generations of GPUs [see, e.g., the CUTLASS documentation for how this has been tackled in general tensor-tensor operations (<xref rid="B29" ref-type="bibr">Thakkar et al., 2023</xref>)]. Additionally, we have seen that our <italic>5codes</italic> implementation suffers from scalability issues when extending the number of cores.</p>
    <p>Finally, it should be noted that in the evaluation of single-step models, the preprocessing time required by the PCG solver (e.g., to set up the preconditioner) now constitutes a significant portion of the total computation time. Reducing this contribution holds the potential for additional performance improvements.</p>
    <p>Notwithstanding these potential improvements, our software can be used in a variety of computational tasks in genomics to reduce computing times.</p>
  </sec>
</body>
<back>
  <ack>
    <p>The authors thank Associate Editor Dorian Garrick and two referees for their review and valuable suggestions to the manuscript. A preprint of this work was posted on bioRxiv (<xref rid="B6" ref-type="bibr">Freudenberg et al., 2023</xref>).</p>
  </ack>
  <sec sec-type="data-availability" id="s5">
    <title>Data availability statement</title>
    <p>The data analyzed in this study is subject to the following licenses/restrictions: Individual genotype, pedigree and phenotype data used in this study are managed by the Irish Cattle Breeding Federation and cannot be made publicly available. Reasonable requests for the cattle data can be made to the Irish Cattle Breeding Federation. Requests will be considered on a case-by-case basis, subject to approval by the data owner and compliance with any legal and ethical requirements related to data access and use. Requests to access these datasets should be directed to <email>query@icbf.com</email>, Website: <ext-link xlink:href="https://www.icbf.com/" ext-link-type="uri">https://www.icbf.com/</ext-link>.</p>
  </sec>
  <sec id="s6">
    <title>Author contributions</title>
    <p>MS designed and implemented the <italic>5codes</italic> algorithm. AF designed and implemented the GPU solution. AF, JV, and MS implemented interfaces to the algorithms. AF and JV wrote and ran analyses for this script. RE preprocessed and curated the ICBF cattle data. TP and JT provided valuable suggestions for the experiment design and the focus of this study. All authors contributed to the article and approved the submitted version.</p>
  </sec>
  <sec sec-type="COI-statement" id="s8">
    <title>Conflict of interest</title>
    <p>MiXBLUP is developed and marketed by the Animal Breeding and Genomics group at Wageningen UR Livestock Research, of which JV, TP, and JT are employees. The cattle data used in this study is proprietary and the intellectual property of the Irish Cattle Breeding Federation, at which RE is an employee.</p>
    <p>The remaining authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p>
  </sec>
  <sec sec-type="disclaimer" id="s9">
    <title>Publisher’s note</title>
    <p>All claims expressed in this article are solely those of the authors and do not necessarily represent those of their affiliated organizations, or those of the publisher, the editors and the reviewers. Any product that may be evaluated in this article, or claim that may be made by its manufacturer, is not guaranteed or endorsed by the publisher.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Alappat</surname><given-names>C.</given-names></name><name><surname>Basermann</surname><given-names>A.</given-names></name><name><surname>Bishop</surname><given-names>A. R.</given-names></name><name><surname>Fehske</surname><given-names>H.</given-names></name><name><surname>Hager</surname><given-names>G.</given-names></name><name><surname>Schenk</surname><given-names>O.</given-names></name><etal/></person-group> (<year>2020</year>). <article-title>A recursive algebraic coloring technique for hardware-efficient symmetric sparse matrix-vector multiplication</article-title>. <source>ACM Trans. Parallel Comput.</source>
<volume>7</volume>, <fpage>1</fpage>–<lpage>37</lpage>. <pub-id pub-id-type="doi">10.1145/3399732</pub-id>
</mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chang</surname><given-names>C. C.</given-names></name><name><surname>Chow</surname><given-names>C. C.</given-names></name><name><surname>Tellier</surname><given-names>L. C.</given-names></name><name><surname>Vattikuti</surname><given-names>S.</given-names></name><name><surname>Purcell</surname><given-names>S. M.</given-names></name><name><surname>Lee</surname><given-names>J. J.</given-names></name></person-group> (<year>2015</year>). <article-title>Second-generation PLINK: rising to the challenge of larger and richer datasets</article-title>. <source>GigaScience</source>
<volume>4</volume>, <fpage>137422</fpage>–<lpage>s14015</lpage>. <pub-id pub-id-type="doi">10.1186/s13742-015-0047-8</pub-id>
</mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Christensen</surname><given-names>O.</given-names></name><name><surname>Lund</surname><given-names>M.</given-names></name></person-group> (<year>2010</year>). <article-title>Genomic prediction when some animals are not genotyped</article-title>. <source>Genet. Sel. Evol.</source>
<volume>42</volume>, <fpage>2</fpage>. <pub-id pub-id-type="doi">10.1186/1297-9686-42-2</pub-id>
<pub-id pub-id-type="pmid">20105297</pub-id></mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Evans</surname><given-names>R.</given-names></name><name><surname>Cromie</surname><given-names>A.</given-names></name><name><surname>Pabiou</surname><given-names>T.</given-names></name></person-group> (<year>2019</year>). “<article-title>Genetic evaluations for dam-type specific calving performance traits in a multi-breed population</article-title>,” in <source>Book of abstracts of the 70th annual meeting of the European federation of animal science</source>. Editors <person-group person-group-type="editor"><name><surname>E</surname><given-names>S.</given-names></name><etal/></person-group>
<fpage>468</fpage>.</mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fernando</surname><given-names>R. L.</given-names></name><name><surname>Dekkers</surname><given-names>J. C.</given-names></name><name><surname>Garrick</surname><given-names>D. J.</given-names></name></person-group> (<year>2014</year>). <article-title>A class of Bayesian methods to combine large numbers of genotyped and non-genotyped animals for whole-genome analyses</article-title>. <source>Genet. Sel. Evol.</source>
<volume>46</volume>, <fpage>1</fpage>–<lpage>13</lpage>. <pub-id pub-id-type="doi">10.1186/1297-9686-46-50</pub-id>
</mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Freudenberg</surname><given-names>A.</given-names></name><name><surname>Vandenplas</surname><given-names>J.</given-names></name><name><surname>Schlather</surname><given-names>M.</given-names></name><name><surname>Pook</surname><given-names>T.</given-names></name><name><surname>Evans</surname><given-names>R.</given-names></name><name><surname>ten Napel</surname><given-names>J.</given-names></name></person-group> (<year>2023</year>). <article-title>Accelerated computations for iterative-solver techniques in single-step BLUP models</article-title>. <source>Prepr. bioRxiv</source>. <pub-id pub-id-type="doi">10.1101/2023.07.06.547949</pub-id>
</mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Henderson</surname><given-names>C. R.</given-names></name></person-group> (<year>1976</year>). <article-title>A simple method for computing the inverse of a numerator relationship matrix used in prediction of breeding values</article-title>. <source>Biometrics</source>
<volume>32</volume>, <fpage>69</fpage>–<lpage>83</lpage>.</mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>Y. J.</given-names></name><name><surname>Henry</surname><given-names>R.</given-names></name><name><surname>Fahim</surname><given-names>R.</given-names></name><name><surname>Hassan</surname><given-names>H.</given-names></name></person-group> (<year>2022</year>). “<article-title>Who says elephants can’t run: bringing large scale MoE models into cloud scale production</article-title>,” in <source>Proceedings of the third workshop on simple and efficient natural language processing (SustaiNLP)</source>. Editors <person-group person-group-type="editor"><name><surname>Fan</surname><given-names>A.</given-names></name><name><surname>Gurevych</surname><given-names>I.</given-names></name><name><surname>Hou</surname><given-names>Y.</given-names></name><name><surname>Kozareva</surname><given-names>Z.</given-names></name><name><surname>Luccioni</surname><given-names>S.</given-names></name><name><surname>Moosavi</surname><given-names>N. S.</given-names></name><etal/></person-group> (<publisher-loc>Abu Dhabi, United Arab Emirates (Hybrid)</publisher-loc>: <publisher-name>Association for Computational Linguistics</publisher-name>), <fpage>36</fpage>–<lpage>43</lpage>.</mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Legarra</surname><given-names>A.</given-names></name><name><surname>Ducrocq</surname><given-names>V.</given-names></name></person-group> (<year>2012</year>). <article-title>Computational strategies for national integration of phenotypic, genomic, and pedigree data in a single-step best linear unbiased prediction</article-title>. <source>J. Dairy Sci.</source>
<volume>95</volume>, <fpage>4629</fpage>–<lpage>4645</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2011-4982</pub-id>
<pub-id pub-id-type="pmid">22818478</pub-id></mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Legarra</surname><given-names>A.</given-names></name><name><surname>Aguilar</surname><given-names>I.</given-names></name><name><surname>Misztal</surname><given-names>I.</given-names></name></person-group> (<year>2009</year>). <article-title>A relationship matrix including full pedigree and genomic information</article-title>. <source>J. Dairy Sci.</source>
<volume>92</volume>, <fpage>4656</fpage>–<lpage>4663</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2009-2061</pub-id>
<pub-id pub-id-type="pmid">19700729</pub-id></mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>Z.</given-names></name><name><surname>Goddard</surname><given-names>M. E.</given-names></name><name><surname>Reinhardt</surname><given-names>F.</given-names></name><name><surname>Reents</surname><given-names>R.</given-names></name></person-group> (<year>2014</year>). <article-title>A single-step genomic model with direct estimation of marker effects</article-title>. <source>J. Dairy Sci.</source>
<volume>97</volume>, <fpage>5833</fpage>–<lpage>5850</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2014-7924</pub-id>
<pub-id pub-id-type="pmid">25022678</pub-id></mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mäntysaari</surname><given-names>E. A.</given-names></name><name><surname>Evans</surname><given-names>R. D.</given-names></name><name><surname>Strandén</surname><given-names>I.</given-names></name></person-group> (<year>2017</year>). <article-title>Efficient single-step genomic evaluation for a multibreed beef cattle population having many genotyped animals</article-title>. <source>J. Animal Sci.</source>
<volume>95</volume>, <fpage>4728</fpage>–<lpage>4737</lpage>. <pub-id pub-id-type="doi">10.2527/jas2017.1912</pub-id>
</mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mäntysaari</surname><given-names>E.</given-names></name><name><surname>Koivula</surname><given-names>M.</given-names></name><name><surname>Strandén</surname><given-names>I.</given-names></name></person-group> (<year>2020</year>). <article-title>Symposium review: single-step genomic evaluations in dairy cattle</article-title>. <source>J. Dairy Sci.</source>
<volume>103</volume>, <fpage>5314</fpage>–<lpage>5326</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2019-17754</pub-id>
<pub-id pub-id-type="pmid">32331883</pub-id></mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Meuwissen</surname><given-names>T. H. E.</given-names></name><name><surname>Hayes</surname><given-names>B.</given-names></name><name><surname>Goddard</surname><given-names>M. E.</given-names></name></person-group> (<year>2001</year>). <article-title>Prediction of total genetic value using genome-wide dense marker maps</article-title>. <source>Genetics</source>
<volume>157</volume>, <fpage>1819</fpage>–<lpage>1829</lpage>. <pub-id pub-id-type="doi">10.1093/genetics/157.4.1819</pub-id>
<pub-id pub-id-type="pmid">11290733</pub-id></mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Meuwissen</surname><given-names>T.</given-names></name><name><surname>Indahl</surname><given-names>U.</given-names></name><name><surname>Ødegård</surname><given-names>J.</given-names></name></person-group> (<year>2017</year>). <article-title>Variable selection models for genomic selection using whole-genome sequence data and singular value decomposition</article-title>. <source>Genet. Sel. Evol.</source>
<volume>49</volume>, <fpage>94</fpage>. <pub-id pub-id-type="doi">10.1186/s12711-017-0369-3</pub-id>
<pub-id pub-id-type="pmid">29281962</pub-id></mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Misztal</surname><given-names>I.</given-names></name><name><surname>Legarra</surname><given-names>A.</given-names></name><name><surname>Aguilar</surname><given-names>I.</given-names></name></person-group> (<year>2009</year>). <article-title>Computing procedures for genetic evaluation including phenotypic, full pedigree, and genomic information</article-title>. <source>J. Dairy Sci.</source>
<volume>92</volume>, <fpage>4648</fpage>–<lpage>4655</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2009-2064</pub-id>
<pub-id pub-id-type="pmid">19700728</pub-id></mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Misztal</surname><given-names>I.</given-names></name><name><surname>Legarra</surname><given-names>A.</given-names></name><name><surname>Aguilar</surname><given-names>I.</given-names></name></person-group> (<year>2014</year>). <article-title>Using recursion to compute the inverse of the genomic relationship matrix</article-title>. <source>J. Dairy Sci.</source>
<volume>97</volume>, <fpage>3943</fpage>–<lpage>3952</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2013-7752</pub-id>
<pub-id pub-id-type="pmid">24679933</pub-id></mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Misztal</surname><given-names>I.</given-names></name><name><surname>Lourenco</surname><given-names>D.</given-names></name><name><surname>Tsuruta</surname><given-names>S.</given-names></name><name><surname>Aguilar</surname><given-names>I.</given-names></name><name><surname>Masuda</surname><given-names>Y.</given-names></name><name><surname>Bermann</surname><given-names>M.</given-names></name><etal/></person-group> (<year>2022</year>). “<article-title>668. How ssGBLUP became suitable for national dairy cattle evaluations</article-title>,” in <source>Proceedings of 12th world congress on genetics applied to Livestock production (WCGALP)</source>. Editors <person-group person-group-type="editor"><name><surname>Veerkamp</surname><given-names>R. F.</given-names></name><name><surname>de Haas</surname><given-names>Y.</given-names></name></person-group> (<publisher-name>Wageningen Academic Publishers</publisher-name>), <fpage>2757</fpage>–<lpage>2760</lpage>. <pub-id pub-id-type="doi">10.3920/978-90-8686-940-4_668</pub-id>
</mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ødegård</surname><given-names>J.</given-names></name><name><surname>Indahl</surname><given-names>U.</given-names></name><name><surname>Strandén</surname><given-names>I.</given-names></name><name><surname>Meuwissen</surname><given-names>T. H.</given-names></name></person-group> (<year>2018</year>). <article-title>Large-scale genomic prediction using singular value decomposition of the genotype matrix</article-title>. <source>Genet. Sel. Evol.</source>
<volume>50</volume>. <pub-id pub-id-type="doi">10.1186/s12711-018-0373-2</pub-id>
</mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Price</surname><given-names>A. L.</given-names></name><name><surname>Patterson</surname><given-names>N. J.</given-names></name><name><surname>Plenge</surname><given-names>R. M.</given-names></name><name><surname>Weinblatt</surname><given-names>M. E.</given-names></name><name><surname>Shadick</surname><given-names>N. A.</given-names></name><name><surname>Reich</surname><given-names>D.</given-names></name></person-group> (<year>2006</year>). <article-title>Principal components analysis corrects for stratification in genome-wide association studies</article-title>. <source>Nat. Genet.</source>
<volume>38</volume>, <fpage>904</fpage>–<lpage>909</lpage>. <pub-id pub-id-type="doi">10.1038/ng1847</pub-id>
<pub-id pub-id-type="pmid">16862161</pub-id></mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Sanders</surname><given-names>J.</given-names></name><name><surname>Kandrot</surname><given-names>E.</given-names></name></person-group> (<year>2010</year>). <source>CUDA by example: An introduction to general-purpose GPU programming</source>. <publisher-name>Addison-Wesley Professional</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sargolzaei</surname><given-names>M.</given-names></name><name><surname>Chesnais</surname><given-names>J. P.</given-names></name><name><surname>Schenkel</surname><given-names>F. S.</given-names></name></person-group> (<year>2014</year>). <article-title>A new approach for efficient genotype imputation using information from relatives</article-title>. <source>BMC Genomics</source>
<volume>15</volume>, <fpage>478</fpage>. <pub-id pub-id-type="doi">10.1186/1471-2164-15-478</pub-id>
<pub-id pub-id-type="pmid">24935670</pub-id></mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schaeffer</surname><given-names>L.</given-names></name><name><surname>Kennedy</surname><given-names>B.</given-names></name></person-group> (<year>1986</year>). <article-title>Computing strategies for solving mixed model equations</article-title>. <source>J. Dairy Sci.</source>
<volume>69</volume>, <fpage>575</fpage>–<lpage>579</lpage>. <pub-id pub-id-type="doi">10.3168/jds.S0022-0302(86)80441-6</pub-id>
</mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schaeffer</surname><given-names>L.</given-names></name></person-group> (<year>2006</year>). <article-title>Strategy for applying genome-wide selection in dairy cattle</article-title>. <source>J. Animal Breed. Genet.</source>
<volume>123</volume>, <fpage>218</fpage>–<lpage>223</lpage>. <pub-id pub-id-type="doi">10.1111/j.1439-0388.2006.00595.x</pub-id>
</mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Strandén</surname><given-names>I.</given-names></name><name><surname>Lidauer</surname><given-names>M.</given-names></name></person-group> (<year>1999</year>). <article-title>Solving large mixed linear models using preconditioned conjugate gradient iteration</article-title>. <source>J. Dairy Sci.</source>
<volume>82</volume>, <fpage>2779</fpage>–<lpage>2787</lpage>. <pub-id pub-id-type="doi">10.3168/jds.S0022-0302(99)75535-9</pub-id>
<pub-id pub-id-type="pmid">10629826</pub-id></mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Tanenbaum</surname><given-names>A. S.</given-names></name></person-group> (<year>2016</year>). <source>Structured computer organization</source>. <publisher-loc>New York</publisher-loc>: <publisher-name>Pearson Education India</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Taskinen</surname><given-names>M.</given-names></name><name><surname>Mäntysaari</surname><given-names>E.</given-names></name><name><surname>Strandén</surname><given-names>I.</given-names></name></person-group> (<year>2017</year>). <article-title>Single-step SNP-BLUP with on-the-fly imputed genotypes and residual polygenic effects</article-title>. <source>Genet. Sel. Evol.</source>
<volume>49</volume>. <pub-id pub-id-type="doi">10.1186/s12711-017-0310-9</pub-id>
</mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>ten Napel</surname><given-names>J.</given-names></name><name><surname>Vandenplas</surname><given-names>J.</given-names></name><name><surname>Lidauer</surname><given-names>M. H.</given-names></name><name><surname>Strandén</surname><given-names>I.</given-names></name><name><surname>Taskinen</surname><given-names>M.</given-names></name><name><surname>Mäntysaari</surname><given-names>E. A.</given-names></name><etal/></person-group> (<year>2021</year>). <source><italic>MiXBLUP 3.0.1 manual</italic>. Animal breeding and genomics</source>. <comment>v3.0 edn</comment>. <publisher-loc>Wageningen, the Netherlands</publisher-loc>: <publisher-name>Wageningen University &amp; Research</publisher-name>. <comment>Last accessed 16th of July 2023</comment>.</mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Thakkar</surname><given-names>V.</given-names></name><name><surname>Ramani</surname><given-names>P.</given-names></name><name><surname>Cecka</surname><given-names>C.</given-names></name><name><surname>Shivam</surname><given-names>A.</given-names></name><name><surname>Lu</surname><given-names>H.</given-names></name><name><surname>Yan</surname><given-names>E.</given-names></name><etal/></person-group> (<year>2023</year>). <source>Cutlass</source>.</mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vandenplas</surname><given-names>J.</given-names></name><name><surname>Eding</surname><given-names>H.</given-names></name><name><surname>Calus</surname><given-names>M. P.</given-names></name><name><surname>Vuik</surname><given-names>C.</given-names></name></person-group> (<year>2018</year>). <article-title>Deflated preconditioned conjugate gradient method for solving single-step BLUP models efficiently</article-title>. <source>Genet. Sel. Evol.</source>
<volume>50</volume>, <fpage>1</fpage>–<lpage>17</lpage>. <pub-id pub-id-type="doi">10.1186/s12711-018-0429-3</pub-id>
<pub-id pub-id-type="pmid">29373954</pub-id></mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vandenplas</surname><given-names>J.</given-names></name><name><surname>Eding</surname><given-names>H.</given-names></name><name><surname>Bosmans</surname><given-names>M.</given-names></name><name><surname>Calus</surname><given-names>M. P.</given-names></name></person-group> (<year>2020</year>). <article-title>Computational strategies for the preconditioned conjugate gradient method applied to ssSNPBLUP, with an application to a multivariate maternal model</article-title>. <source>Genet. Sel. Evol.</source>
<volume>52</volume>, <fpage>1</fpage>–<lpage>10</lpage>. <pub-id pub-id-type="doi">10.1186/s12711-020-00543-9</pub-id>
<pub-id pub-id-type="pmid">31941436</pub-id></mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vandenplas</surname><given-names>J.</given-names></name><name><surname>ten Napel</surname><given-names>J.</given-names></name><name><surname>Darbaghshahi</surname><given-names>S. N.</given-names></name><name><surname>Evans</surname><given-names>R.</given-names></name><name><surname>Calus</surname><given-names>M. P.</given-names></name><name><surname>Veerkamp</surname><given-names>R.</given-names></name><etal/></person-group> (<year>2023</year>). <article-title>Efficient large-scale single-step evaluations and indirect genomic prediction of genotyped selection candidates</article-title>. <source>Genet. Sel. Evol.</source>
<volume>55</volume>, <fpage>1</fpage>–<lpage>17</lpage>. <pub-id pub-id-type="doi">10.1186/s12711-023-00808-z</pub-id>
<pub-id pub-id-type="pmid">36604633</pub-id></mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>VanRaden</surname><given-names>P.</given-names></name></person-group> (<year>2008</year>). <article-title>Efficient methods to compute genomic predictions</article-title>. <source>J. Dairy Sci.</source>
<volume>91</volume>, <fpage>4414</fpage>–<lpage>4423</lpage>. <pub-id pub-id-type="doi">10.3168/jds.2007-0980</pub-id>
<pub-id pub-id-type="pmid">18946147</pub-id></mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Xu</surname><given-names>Y.</given-names></name><name><surname>Laurie</surname><given-names>J. D.</given-names></name><name><surname>Wang</surname><given-names>X.</given-names></name></person-group> (<year>2021</year>). <article-title>CropGBM: an ultra-efficient machine learning toolbox for genomic selection-assisted breeding in crops</article-title> in <source>Springer protocols handbooks</source> (<publisher-name>Springer Protocols Handbooks</publisher-name>), <fpage>133</fpage>–<lpage>150</lpage>. <pub-id pub-id-type="doi">10.1007/978-1-0716-1526-3_5</pub-id>
</mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Yang</surname><given-names>J.</given-names></name><name><surname>Lee</surname><given-names>S.</given-names></name><name><surname>Goddard</surname><given-names>M.</given-names></name><name><surname>Visscher</surname><given-names>P.</given-names></name></person-group> (<year>2011</year>). <article-title>Gcta: a tool for genome-wide complex trait analysis</article-title>. <source>Am. J. Hum. Genet.</source>
<volume>88</volume>, <fpage>76</fpage>–<lpage>82</lpage>. <pub-id pub-id-type="doi">10.1016/j.ajhg.2010.11.011</pub-id>
<pub-id pub-id-type="pmid">21167468</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
