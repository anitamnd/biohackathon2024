<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311309</article-id>
    <article-id pub-id-type="pmid">37387174</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad264</article-id>
    <article-id pub-id-type="publisher-id">btad264</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>isONform: reference-free transcriptome reconstruction from Oxford Nanopore data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Petri</surname>
          <given-names>Alexander J</given-names>
        </name>
        <aff><institution>Department of Mathematics, Science for Life Laboratory, Stockholm University</institution>, Stockholm 106 91, <country country="SE">Sweden</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-7378-2320</contrib-id>
        <name>
          <surname>Sahlin</surname>
          <given-names>Kristoffer</given-names>
        </name>
        <aff><institution>Department of Mathematics, Science for Life Laboratory, Stockholm University</institution>, Stockholm 106 91, <country country="SE">Sweden</country></aff>
        <xref rid="btad264-cor1" ref-type="corresp"/>
        <!--ksahlin@math.su.se-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad264-cor1">Corresponding author. Department of Mathematics, Science for Life Laboratory, Stockholm University, Stockholm 106 91, Sweden. E-mail: <email>ksahlin@math.su.se</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i222</fpage>
    <lpage>i231</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad264.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>With advances in long-read transcriptome sequencing, we can now fully sequence transcripts, which greatly improves our ability to study transcription processes. A popular long-read transcriptome sequencing technique is Oxford Nanopore Technologies (ONT), which through its cost-effective sequencing and high throughput, has the potential to characterize the transcriptome in a cell. However, due to transcript variability and sequencing errors, long cDNA reads need substantial bioinformatic processing to produce a set of isoform predictions from the reads. Several genome and annotation-based methods exist to produce transcript predictions. However, such methods require high-quality genomes and annotations and are limited by the accuracy of long-read splice aligners. In addition, gene families with high heterogeneity may not be well represented by a reference genome and would benefit from reference-free analysis. Reference-free methods to predict transcripts from ONT, such as RATTLE, exist, but their sensitivity is not comparable to reference-based approaches.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present isONform, a high-sensitivity algorithm to construct isoforms from ONT cDNA sequencing data. The algorithm is based on iterative bubble popping on gene graphs built from fuzzy seeds from the reads. Using simulated, synthetic, and biological ONT cDNA data, we show that isONform has substantially higher sensitivity than RATTLE albeit with some loss in precision. On biological data, we show that isONform’s predictions have substantially higher consistency with the annotation-based method StringTie2 compared with RATTLE. We believe isONform can be used both for isoform construction for organisms without well-annotated genomes and as an orthogonal method to verify predictions of reference-based methods.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>
          <ext-link xlink:href="https://github.com/aljpetri/isONform" ext-link-type="uri">https://github.com/aljpetri/isONform</ext-link>
        </p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Swedish Research Council</institution>
            <institution-id institution-id-type="DOI">10.13039/501100004359</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>2021-04000</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Long-read sequencing techniques such as Oxford Nanopore Technologies (ONT) and Pacific Biosciences (PacBio) can produce reads covering the majority of transcripts from end-to-end. Such sequencing techniques have proven to enable a better understanding of the transcriptional landscape of cells (<xref rid="btad264-B1" ref-type="bibr">Bayega et al. 2018</xref>; <xref rid="btad264-B2" ref-type="bibr">Byrne et al. 2019</xref>; <xref rid="btad264-B5" ref-type="bibr">Cole et al. 2020</xref>). However, while long-read methods omit the need for transcript assembly as needed with short reads, transcript 3′ and 5′ variability, RNA degradation, long-read sequencing error profiles, and other sequencing artifacts inhibit downstream analysis of long-read data. Particularly, recovering the actual isoforms from long-read transcriptomic datasets has proven difficult, with studies observing thousands of low-quality and potentially spurious transcript predictions (<xref rid="btad264-B11" ref-type="bibr">Hoang et al. 2017</xref>; <xref rid="btad264-B15" ref-type="bibr">Kuo et al. 2020</xref>).</p>
    <sec>
      <title>1.1 Genome- and annotation-based methods</title>
      <p>Due to the noise in these datasets, a common approach to predict transcripts is to align the transcriptomic reads to a reference genome using a long-read splice aligner such as minimap2 (<xref rid="btad264-B16" ref-type="bibr">Li 2018</xref>), deSALT (<xref rid="btad264-B18" ref-type="bibr">Liu et al. 2019</xref>), or uLTRA (<xref rid="btad264-B31" ref-type="bibr">Sahlin and Mäkinen 2021</xref>). Several tools for reconstructing transcripts from long-read splice alignments have been proposed (<xref rid="btad264-B14" ref-type="bibr">Kovaka et al. 2019</xref>; <xref rid="btad264-B35" ref-type="bibr">Tung et al. 2019</xref>; <xref rid="btad264-B33" ref-type="bibr">Tang et al. 2020</xref>; <xref rid="btad264-B15" ref-type="bibr">Kuo et al. 2020</xref>; <xref rid="btad264-B38" ref-type="bibr">Wyman et al. 2020</xref>; <xref rid="btad264-B12" ref-type="bibr">Holmqvist et al. 2021</xref>; <xref rid="btad264-B22" ref-type="bibr">Orabi et al. 2022</xref>; <xref rid="btad264-B3" ref-type="bibr">Chen et al. 2022</xref>; <xref rid="btad264-B37" ref-type="bibr">Volden et al. 2022</xref>; <xref rid="btad264-B24" ref-type="bibr">Prjibelski et al. 2023</xref>). These tools typically predict transcripts by requiring both alignments and transcript annotations (<xref rid="btad264-B14" ref-type="bibr">Kovaka et al. 2019</xref>; <xref rid="btad264-B35" ref-type="bibr">Tung et al. 2019</xref>; <xref rid="btad264-B33" ref-type="bibr">Tang et al. 2020</xref>; <xref rid="btad264-B15" ref-type="bibr">Kuo et al. 2020</xref>; <xref rid="btad264-B38" ref-type="bibr">Wyman et al. 2020</xref>; <xref rid="btad264-B12" ref-type="bibr">Holmqvist et al. 2021</xref>; <xref rid="btad264-B3" ref-type="bibr">Chen et al. 2022</xref>; <xref rid="btad264-B37" ref-type="bibr">Volden et al. 2022</xref>), or requiring alignments but with the ability to predict transcripts outside annotations (<xref rid="btad264-B22" ref-type="bibr">Orabi et al. 2022</xref>; <xref rid="btad264-B24" ref-type="bibr">Prjibelski et al. 2023</xref>). A thorough community-effort benchmarking of many of these tools using several different sequencing techniques and genomes has recently been performed as part of the LRGASP challenge (<xref rid="btad264-B23" ref-type="bibr">Pardo-Palacios et al. 2021</xref>), and preliminary results of challenge 1 (<xref rid="btad264-B19" ref-type="bibr">LRGASP 2022</xref>) show a large discrepancy between methods in isoform detection, even for organisms with high-quality reference genomes such as mouse and human.</p>
      <p>Larger discrepancies in predicted transcripts between methods can be explained by the different algorithms they use, as well as error levels and artifacts of the sequencing techniques. However, there are also inherent limitations with predicting transcripts from alignments to a linear reference genome. Such limitations include predicting transcripts from fused genes, gene copies, or exons that are not present in the linear genome or shortcomings in splice alignment, which the predictions fundamentally rely on. For example, in the study by <xref rid="btad264-B31" ref-type="bibr">Sahlin and Mäkinen (2021)</xref>, we showed that long-read splice alignment methods have limitations such as (i) small exons not being detected by read aligners, (ii) overfitting to canonical splice sites, and (iii) not aligning over long introns. Additionally, relying on a reference genome and reference annotation limits the methods to organisms and genes for which reference annotations exist.</p>
    </sec>
    <sec>
      <title>1.2 Genome- and annotation-agnostic methods</title>
      <p>By not relying on high quality genome assemblies and annotations, reference-free approaches are important for research of lesser known organisms/gene families. In addition, they can overcome the splice-alignment limitations and the bias introduced by linear reference genomes. So far, relatively few methods have been proposed for reference-free transcript predictions. Some tools have been proposed for PacBio sequencing such as isoseq3 (<xref rid="btad264-B10" ref-type="bibr">Gordon et al. 2015</xref>) and IsoCon (<xref rid="btad264-B32" ref-type="bibr">Sahlin et al. 2018</xref>) but are limited to PacBio data and IsoCon is only applicable to targeted sequencing. While there exists recent unpublished work (<xref rid="btad264-B20" ref-type="bibr">Nip et al. 2022</xref>), the only published tool for reference-free transcriptome reconstruction of ONT reads is RATTLE (<xref rid="btad264-B7" ref-type="bibr">de la Rubia et al. 2022</xref>). However, as we show in our study, RATTLE has low transcript prediction sensitivity and misses many transcripts present in data. Some challenges of reference-free transcript reconstruction are highly variable abundance, alternative splicing, as well as long-read error profiles.</p>
    </sec>
    <sec>
      <title>1.3 Our contribution</title>
      <p>We have previously demonstrated algorithms for clustering and error correction of long transcriptomic reads through isONclust (<xref rid="btad264-B29" ref-type="bibr">Sahlin and Medvedev 2020</xref>) and isONcorrect (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>). We here introduce an algorithm and its implementation, isONform, for the final step of this pipeline to produce transcript predictions. IsONform builds a graph based on paired-minimizer seeds, that, similarly to minimizer-based genome assembly approaches (<xref rid="btad264-B25" ref-type="bibr">Rautiainen and Marschall 2021</xref>; <xref rid="btad264-B9" ref-type="bibr">Ekim et al. 2021</xref>), aims to sparsely represent the sequence information in the data. IsONform then employs iterative bubble popping on the graph to remove errors while keeping exon differences. When no poppable bubbles exist, isoform predictions can be traced from the graph by following paths of full-length reads. A fundamental difference between our isON pipeline (isONclust, isONcorrect, and isONform) and RATTLE’s pipeline (cluster, error correct, and polish) is that the isON pipeline works with clusters of reads from a gene, while RATTLE clusters by transcript. This allows isON’s error correction and consensus prediction (isONform) to leverage shared exons among splice variants, thus, the potential to recover more transcripts with higher base-level accuracy compared with predictions by RATTLE. However, to benefit from shared exons in different transcripts, it also requires a more sophisticated consensus generation algorithm able to separate isoforms at the consensus calling step, compared with RATTLE, which only does base-level polishing per transcript in the consensus (polishing) step. Using simulated and synthetic reads, we show that isONform recovers substantially more isoforms than RATTLE. On biological data, we show that isONform has much higher consistency with the reference-based tool StringTie2 compared with RATTLE. We believe that isONform (integrated into our isON pipeline) has two primary use cases. First, it can be used for isoform construction for organisms without well-annotated genomes. Second, it can be used as an orthogonal method to verify consistency in reference-based prediction since systematic limitations exist, as described in Section 1.1.</p>
    </sec>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>In Section 2.1, we give a high level overview of the algorithm. In Section 2.2, we introduce notation and formally define minimizer pairs and the graph structure that isONform uses. Finally, we describe the algorithm in depth in Section 2.3 and implementation details in Section 2.4.</p>
    <sec>
      <title>2.1 Algorithm overview</title>
      <p>The input of our algorithm are clustered and error-corrected reads from isONclust (<xref rid="btad264-B29" ref-type="bibr">Sahlin and Medvedev 2020</xref>) and isONcorrect (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>). Each cluster represents reads from isoforms from a gene family and can be processed individually and in parallel with isONform. The output is a set of predicted transcripts in fastq format. We describe the algorithm for reads from a single cluster. In step 1, reads are partitioned into intervals using “minimizer pairs” (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>) as seeds. In step 2, a weighted interval scheduling (WIS) problem is solved to find a set of maximally weighted and nonoverlapping minimizer pairs (NOMPs) for each read as done in isONcorrect (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>). In step 3, the set of NOMPs is used to construct a directed acyclic graph (DAG) in which vertices represent the NOMPs and neighboring NOMPs are connected with an edge. In step 4, the graph is simplified by an iterative bubble-popping algorithm designed to remove errors and mutations between reads while keeping exon differences. In step 5, predicted isoforms are generated by finding supported paths through the graph. Finally, step 6 removes any redundant isoform predictions caused mainly by the larger 3′ and 5′ variability using pairwise alignment of predicted isoforms. The isoform predictions remaining after this step constitute the final predictions. An overview of the algorithm is shown in <xref rid="btad264-F1" ref-type="fig">Fig. 1</xref>.</p>
      <fig position="float" id="btad264-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Overview of the isONform algorithm. IsONform takes as input clustered and error-corrected reads generated with isONclust and isONcorrect, respectively. The example illustrates a cluster consisting of five reads (<italic toggle="yes">r</italic><sub>1</sub> to <italic toggle="yes">r</italic><sub>5</sub>) from three isoforms, where <italic toggle="yes">p</italic> denotes positions of minimizers on <italic toggle="yes">r</italic><sub>1</sub>. isONform uses all minimizer pairs from minimizers at distance <italic toggle="yes">x<sub>min</sub></italic> to <italic toggle="yes">x<sub>max</sub></italic>. The figure shows an example of 10 minimizer pairs on <italic toggle="yes">r</italic><sub>2</sub>. Each minimizer pair is assigned a weight formed from the length of the minimizer pairs and its abundance in the cluster. The instance is then sent to a weighted interval scheduler, which is used to find the set of NOMPs. In our example, we find five segments for <italic toggle="yes">r</italic><sub>1</sub> while the scheduler finds four instances for <italic toggle="yes">r</italic><sub>2</sub>. A DAG is built up by the NOMPs, and we add a global source node <italic toggle="yes">s</italic> as well as a global sink node <italic toggle="yes">t</italic> (step 3). An iterative bubble-popping approach is employed to merge similar paths in the graph (step 4). This reduces the number of paths supported by reads (step 5). We finally perform postmerging of the transcripts due to 3′ and 5′ variability. For each isoform, a consensus sequence is generated from all reads appointed to it using the SPOA algorithm.</p>
        </caption>
        <graphic xlink:href="btad264f1" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.2 Preliminaries</title>
      <p>isONform uses the same generation of minimizers and minimizer-pairs as described in isONcorrect (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>). We describe them here for completeness.</p>
      <sec>
        <title>2.2.1 Minimizers</title>
        <p>Minimizers (<xref rid="btad264-B26" ref-type="bibr">Roberts et al. 2004</xref>) are subsampled <italic toggle="yes">k</italic>-mers. Let <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula> denote a string of nucleotides, which we refer to as “read.” We use <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to refer to the nucleotide located at the <italic toggle="yes">i</italic>-th position of <italic toggle="yes">r</italic>. Given two integers <italic toggle="yes">k</italic> and <italic toggle="yes">w</italic> such that <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>w</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, the minimizer of <italic toggle="yes">r</italic> at position <italic toggle="yes">p</italic> is the lexicographically smallest k-mer <italic toggle="yes">m</italic> that starts inside the interval <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We then say that <italic toggle="yes">m</italic> is a minimizer of the read <italic toggle="yes">r</italic>, or, alternatively, is a positional minimizer <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of read <italic toggle="yes">r</italic>. Let <italic toggle="yes">M</italic>(<italic toggle="yes">r</italic>) be the set of positional minimizers of read <italic toggle="yes">r</italic>. In the following example, we use <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="italic">ACGGATCAC</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, yielding the set of positional minimizers <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <title>2.2.2 Minimizer pairs</title>
        <p>Let <italic toggle="yes">x<sub>min</sub></italic> and <italic toggle="yes">x<sub>max</sub></italic> be two positive integer parameters. We let <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">max</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the ordered set (according to increasing <italic toggle="yes">p<sub>i</sub></italic> then <italic toggle="yes">p<sub>j</sub></italic>) of paired positional minimizers separated by at least <italic toggle="yes">x<sub>min</sub></italic> and at most <italic toggle="yes">x<sub>max</sub></italic> nucleotides in <italic toggle="yes">r</italic>. Similarly, we denote the sequence of paired minimizers as <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">Str</mml:mi><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. <italic toggle="yes">W<sub>r</sub></italic> with the positions omitted but duplicates retained. The above example with the following parameters <italic toggle="yes">x<sub>min</sub></italic> = 2, <italic toggle="yes">x<sub>max</sub></italic> = 4 therefore yields <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">str</mml:mi><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Given a set of reads <italic toggle="yes">R</italic>, we let <italic toggle="yes">W</italic> be the union of all <italic toggle="yes">W<sub>r</sub></italic> for the reads in <italic toggle="yes">R</italic> and we let <italic toggle="yes">StrW</italic> be the union of all <italic toggle="yes">StrW<sub>r</sub></italic>. Besides error correction (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>), minimizer pairs have also been used in genome assembly (<xref rid="btad264-B4" ref-type="bibr">Chin and Khalak 2019</xref>).</p>
      </sec>
      <sec>
        <title>2.2.3 Nonoverlapping minimizer pairs</title>
        <p>For each read, isONform, similarly to isONcorrect, produces a subset of NOMPs from the set of minimizer pairs. The NOMPs are decided upon by the solution to a WIS problem. Specifically, the minimizer pairs span an “interval” on the read. The input to the WIS problem is a set of minimizer pairs (intervals) <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">a<sub>j</sub></italic> &lt; <italic toggle="yes">b<sub>j</sub></italic>. The number of reads supporting an interval <italic toggle="yes">I<sub>j</sub></italic> (provided in <italic toggle="yes">StrW</italic>) gives a weight <italic toggle="yes">w<sub>j</sub></italic> to <italic toggle="yes">I<sub>j</sub></italic>. The solution to the WIS problem outputs a subset <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>′</mml:mo><mml:mo>⊂</mml:mo><mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></inline-formula> of nonoverlapping intervals for which the sum of weights is maximized. Our intervals in the solution <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> correspond to NOMPs that we index in the order they appear on the read, e.g. <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is the <italic toggle="yes">j</italic>th NOMP in <italic toggle="yes">r</italic>. The WIS problem can be solved exactly by applying a dynamic programming algorithm that runs with <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time complexity, with <italic toggle="yes">n</italic> denoting the number of intervals (<xref rid="btad264-B13" ref-type="bibr">Kleinberg and Tardos 2006</xref>).</p>
      </sec>
      <sec>
        <title>2.2.4 Graphs of nonoverlapping minimizer pairs</title>
        <p>We represent the NOMPs as vertices, where <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> denotes the <italic toggle="yes">i-</italic>th NOMP on read <italic toggle="yes">r</italic>. We draw a directed edge <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> between two vertices <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> represent neighboring NOMPs on a read. This forms a directed graph <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where we insert a global source and sink node <italic toggle="yes">s</italic> and <italic toggle="yes">t</italic>, respectively. We draw a directed edge <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from the global source to the first NOMP <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> on each read. Similarly, we draw a directed edge <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>″</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from the last minimizer pair <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>″</mml:mo></mml:mrow></mml:math></inline-formula> on each read to the global sink. A read spells a path from the global source to the sink.</p>
        <p>Each node <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> also contains information on the start and end position and the length (span) of the NOMP on read <italic toggle="yes">r</italic>. Furthermore, each edge <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> has a length <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> associated with it, representing the distance between the <italic toggle="yes">i-</italic>th and (<italic toggle="yes">i</italic> + 1)-th NOMP on <italic toggle="yes">r</italic>. Therefore, a path <italic toggle="yes">p</italic> in <italic toggle="yes">G</italic> that follows a read <italic toggle="yes">r</italic> has a corresponding length (<inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>), start, and stop position on <italic toggle="yes">r</italic>. The graph is built up by iterating through the reads in order of appearance in the fastq file. A NOMP that is shared between reads will be represented by a single node. A NOMP is considered shared if it has the same minimizer pair and they do not have a difference in their pairwise distance larger than <italic toggle="yes">δ</italic> (parameter to isONform). However, isONform stores the length of each NOMP in the vertex. A detailed description of the graph construction is given in Section 2.3.1.</p>
      </sec>
      <sec>
        <title>2.2.5 Bubbles and multibubbles</title>
        <p>We define a bubble as a pair of paths with a shared start node <italic toggle="yes">b<sub>s</sub></italic> and end node <italic toggle="yes">b<sub>e</sub></italic> where the internal path nodes are disjoint. Note that nodes that are not part of the bubble can be reached from nodes belonging to the bubble. If the bubble additionally has at least one read supporting each path from <italic toggle="yes">b<sub>s</sub></italic> to <italic toggle="yes">b<sub>e</sub></italic> we denote it as “read-supported bubble.” We will detect and resolve what we refer to as read-supported multibubbles. An example of a multibubble structure is shown in <xref rid="btad264-F2" ref-type="fig">Fig. 2a</xref>. Multibubbles have similar characteristics as superbubbles (<xref rid="btad264-B21" ref-type="bibr">Onodera et al. 2013</xref>) except that multibubbles allow nodes not part of the multibubble to be reachable from nodes in the multibubble and for several bubbles to start/end in one node, i.e. they do not fulfil the minimality and the matching criteria (<xref rid="btad264-B21" ref-type="bibr">Onodera et al. 2013</xref>). Let <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> a directed graph and (<italic toggle="yes">s</italic>, <italic toggle="yes">t</italic>) being an unordered pair of distinct vertices. Then, a multibubble is defined if it satisfies the following criteria:</p>
        <fig position="float" id="btad264-F2">
          <label>Figure 2.</label>
          <caption>
            <p>Bubble popping on a graph. (a) Our initial graph. There are three bubbles in this graph ({a, b, c, d},{s’,a, c, d, g, h, i, e}, and {s’,a, b, d, e, f, g, h, i, j, k, l, m, t’}). The bubble popping starts with the smallest bubble (fewest vertices) and continues until no more bubbles can be popped. (b) Bubble {a, b, c, d} was popped and its nodes linearized. (c) Bubble {s’,a, b, c, d, g, h, i, e} was popped and its nodes linearized. (d) The bubble in (c) could also be popped and we now have a single path from <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, representing a single isoform in the graph.</p>
          </caption>
          <graphic xlink:href="btad264f2" position="float"/>
        </fig>
        <list list-type="bullet">
          <list-item>
            <p><bold>Reachability</bold>: <italic toggle="yes">t</italic> can be reached from <italic toggle="yes">s.</italic></p>
          </list-item>
          <list-item>
            <p><bold>Acyclicity</bold>: the subgraph induced by <italic toggle="yes">U</italic> is acyclic where <italic toggle="yes">U</italic> is the set of vertices as described above.</p>
          </list-item>
        </list>
        <p>then we say that the subgraph in the description of the acyclicity condition forms a multibubble and <italic toggle="yes">s</italic>, <italic toggle="yes">t</italic> and <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>U</mml:mi><mml:mo>∖</mml:mo><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> are the multibubble’s source, sink and interior respectively.</p>
      </sec>
    </sec>
    <sec>
      <title>2.3 Algorithm</title>
      <p>Steps 1 and 2 consist of constructing minimizer pairs and solving the WIS problem to produce NOMPs as input to isONform. These steps are performed identically to isONcorrect.</p>
      <sec>
        <title>2.3.1 Step 3: graph construction</title>
        <p>The graph is built up by iterating through the reads in order of appearance in the fastq file, and adding vertices and edges from the NOMPs produced in step 2. We want to keep the graph acyclic. Repetitive NOMPs within a read may cause a cycle. Also, since NOMPs are fuzzy seeds, they may have different lengths. Therefore, we want to identify larger length differences between NOMPs shared between reads. Finally, there can be gaps between neighboring NOMPs in reads. If two reads share two neighboring NOMPs, the gap between the two NOMPs may differ, indicating a structural difference between the reads. We handle those cases as follows.</p>
        <p><bold>Preserving acyclicity:</bold> For each new <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to be added to <italic toggle="yes">G</italic>, if <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is already found in the graph it may create a cycle if we add the edge <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> connecting it to its predecessor. We can prevent <italic toggle="yes">G</italic> becoming cyclic by looking at the topological order of the graph. If <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> would introduce a cycle, we instead add a new vertex <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to <italic toggle="yes">G</italic> representing <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
        <p><bold>Differences in NOMP span:</bold> For each <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to be added to <italic toggle="yes">G</italic>, if the NOMP is already found in the graph, we check the length difference of <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and the NOMP of the node existing in the graph. If the NOMP lengths differ by more than <italic toggle="yes">δ</italic> nucleotides, we add a new node. If a NOMP is already represented by two or more NOMPs, <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is added to the vertex that has the NOMP with the closest distance to <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
        <p><bold>Differences between NOMPs:</bold> In a similar fashion to checking differences in NOMP span, if we find two reads <italic toggle="yes">r</italic> and <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> having the same neighboring NOMPs <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> = <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> but <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo>δ</mml:mo></mml:mrow></mml:math></inline-formula> then we create a separate vertex <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> for the second NOMP while adding the first NOMP to the vertex already in the graph.</p>
      </sec>
      <sec>
        <title>2.3.2 Step 4: iterative bubble popping</title>
        <p>NOMPs are indel tolerant seeds, but sequencing errors and exon differences may result in local bubbles (<xref rid="btad264-B39" ref-type="bibr">Zerbino and Birney 2008</xref>) in <italic toggle="yes">G</italic>. It requires only a few bubbles to lead to many reads having unique paths through <italic toggle="yes">G</italic> (possibly exponentially increasing with the number of bubbles), which yields redundant consensus sequences. The purpose of the iterative bubble-popping step is to remove local bubbles in the graph caused by read errors and SNP differences while preserving differences at the exon level between reads.</p>
        <p><bold>Overview:</bold> At a high level, <italic toggle="yes">G</italic> may contain several multibubbles sharing vertices. We find disjoint “read-supported bubbles” that we can pop during each iteration of our iterative bubble popping. We start by analyzing the smallest bubbles (with respect to the number of vertices) and gradually test and pop bubbles until no more new bubbles can be detected in the graph. We test if a bubble is poppable by forming a consensus (using SPOA, <xref rid="btad264-B36" ref-type="bibr">Vaser et al. 2017</xref>) of the subsequences of reads corresponding to each path in the bubble. If such consensuses do not differ in length by more than <italic toggle="yes">δ</italic> and have sequence similarity higher than <italic toggle="yes">α</italic> (parameter to isONform), we pop the bubble. Otherwise, we save it as unpoppable. If a bubble can be popped, we use the relative distance information to reorder (or “linearize”) the vertices of the two paths. At each new iteration, the bubbles we previously investigated could either be popped or were stored as unpoppable. Bubbles that have been deemed to be unpoppable are skipped in the following iterations. During each iteration, the bubble-popping approach reduces the number of edges in our graph. A graphical overview of this process is illustrated in <xref rid="btad264-F2" ref-type="fig">Fig. 2</xref>.</p>
        <p><bold>Details:</bold> In detail, the process of iterative bubble popping is performed as follows:</p>
        <list list-type="order">
          <list-item>
            <p>We identify all vertices having more than one out-edge <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> as well as all vertices <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> that have more than one in-edge. These vertices are potential source and sink vertices of bubbles.</p>
          </list-item>
          <list-item>
            <p>We then generate all potential pairs of <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mtext>TOP</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mtext>TOP</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, with <italic toggle="yes">TOP</italic> denoting the topological order. We sort the bubbles by the number of nodes participating in the bubble in increasing order. We verify that <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> have at least two reads in common, the minimum needed for each path in the bubble to be supported by one read.</p>
          </list-item>
          <list-item>
            <p>For each potential <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-bubble, we verify the eligibility by following the supporting reads from <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. If we find at least two paths with disjoint sets of internal nodes, with each set being supported by at least one read, we store it as a read-supported bubble <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">B</italic> is the set of bubbles. Note that <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can contain more than two paths. If the paths <italic toggle="yes">p</italic> and <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> overlap, a smaller bubble should exist between the reads, and we ignore the bubble. This may happen if a previous bubble has been deemed to be unpoppable.</p>
          </list-item>
          <list-item>
            <p>For each <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>, we iterate over the paths <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula> and produce a consensus sequence formed by all the reads supporting the path using the SPOA algorithm (<xref rid="btad264-B36" ref-type="bibr">Vaser et al. 2017</xref>).</p>
          </list-item>
          <list-item>
            <p>The two consensuses from each pair of paths <italic toggle="yes">p</italic> and <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> in step 4 are then aligned via the parasail algorithm (<xref rid="btad264-B6" ref-type="bibr">Daily 2016</xref>). Suppose the alignment between the path consensuses for <italic toggle="yes">p</italic> and <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> does not yield a mismatch longer than <italic toggle="yes">δ</italic>, and the consensuses have sequence similarity higher than <italic toggle="yes">α</italic>. In that case, we deem a bubble to be poppable. We then merge the paths by linearizing the path nodes with <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
          </list-item>
          <list-item>
            <p>The linearization of nodes in <italic toggle="yes">p</italic> and <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is performed by inferring the distance of each vertex (in sequence space) to <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. This is done by averaging the sequence distance from <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> to vertex <italic toggle="yes">v</italic> of each supporting read. If two paths have been linearized through steps 4–6, we postpone steps 4–6 for bubbles overlapping with this bubble to the next iteration of the bubble-popping approach.</p>
          </list-item>
          <list-item>
            <p>After steps 1–6, we have linearized several bubbles or marked them as unpoppable in <italic toggle="yes">G</italic>. We then repeat the algorithm starting with step 1 for the modified graph. We stop the iterative bubble popping process if we detect less than N (isONform parameter, default 1) new bubbles during an iteration.</p>
          </list-item>
        </list>
      </sec>
      <sec>
        <title>2.3.3 Step 5: generation of isoforms</title>
        <p>After performing the iterative bubble popping, we extract isoform predictions by following reads from <italic toggle="yes">s</italic> to <italic toggle="yes">t</italic> in <italic toggle="yes">G</italic>. We arbitrarily pick a read <italic toggle="yes">r</italic> from the pool of reads and trace its path <italic toggle="yes">p</italic> through <italic toggle="yes">G</italic>. By the construction of <italic toggle="yes">G</italic>, it is implied that all the reads sharing <italic toggle="yes">p</italic> as path from <italic toggle="yes">s</italic> to <italic toggle="yes">t</italic> also share all vertices and edges with <italic toggle="yes">r</italic>. All reads having <italic toggle="yes">p</italic> as path from <italic toggle="yes">s</italic> to <italic toggle="yes">t</italic> in <italic toggle="yes">G</italic> make up one isoform prediction in isONform. We produce the consensus sequence by applying the SPOA algorithm, forming a partial-order alignment graph from the reads, from which we can extract a consensus sequence.</p>
      </sec>
      <sec>
        <title>2.3.4 Step 6: removal of start and end variability</title>
        <p>Reads produced via long-read sequencing of biological sequences may have high variability at the 3′ and 5′ ends. We remove redundancy in predictions due to the ends variability as follows. The predicted consensus sequences are pairwise aligned. We merge two predictions if they differ in the ends with no internal difference larger than <italic toggle="yes">δ</italic>, inferred from their semiglobal alignment. We perform the merging by iterating over the isoform predictions from shortest to longest prediction, merging shorter predictions into longer ones. The final isoforms are generated by running SPOA (<xref rid="btad264-B36" ref-type="bibr">Vaser et al. 2017</xref>) on the merged set of reads. Ends variability merging has the downside of potentially collapsing transcripts with true variability in start and end sites but is commonly employed to reduce redundant predictions both in reference-based (<xref rid="btad264-B15" ref-type="bibr">Kuo et al. 2020</xref>) and reference-free (<xref rid="btad264-B10" ref-type="bibr">Gordon et al. 2015</xref>) software. For example, official PacBio software isoseq3 (<xref rid="btad264-B10" ref-type="bibr">Gordon et al. 2015</xref>) merges transcripts with less than 30 nt and 100 nt difference in the 3′ and 5′ ends, respectively.</p>
      </sec>
    </sec>
    <sec>
      <title>2.4 Implementation details and output</title>
      <p>Mature coding RNAs typically have poly-A tails attached to them, possibly bearing large variability in length. We compress poly-A regions in our data by searching the last 100 nucleotides in reads for stretches of more than 12 consecutive A’s. We compress these stretches into one nucleotide each. In addition, similarly to the isONcorrect algorithm, we divide large gene clusters into smaller batches of 1000 (parameter to isONform) reads and process them individually. We noted this strategy to be faster than considering all reads of a cluster which may contain up to 54,889 reads (the largest cluster in Drosophila). This batching strategy, however, requires us to run a postmerging step of the isoform predictions produced for each batch. We perform this merging identically to step 6 in the isONform algorithm. All the consensus sequences with an abundance of at least <italic toggle="yes">X</italic> reads (parameter to isONform, default 5) remaining after this final merging step constitute the final isoform predictions. In isONform, parasail is used with the following parameters 2, −2, 12, and 1 for match score, mismatch penalty, gap opening penalty, and gap extension, respectively. For the consensus calling via SPOA we call the method with the following parameters 0, 0, −2 for l, r, and g.</p>
      <p>The predicted isoforms are written in fastq format. The predictions that did not pass the abundance threshold are written into a separate file. Additionally, isONform writes the read id mappings for each isoform into a file, making it possible to identify which reads were appointed to the same isoform and its read abundance. The algorithm is available at <ext-link xlink:href="https://github.com/aljpetri/isONform" ext-link-type="uri">https://github.com/aljpetri/isONform</ext-link>.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We used a biological, a synthetic and a simulated dataset to investigate the performance of isONform as well as isONclust and isONcorrect which constitute preprocessing steps. We will refer to the running all three of those tools as isON pipeline. For all analyses we ran the full isON pipeline and compared its predictions with the predictions of the RATTLE pipeline (<xref rid="btad264-B7" ref-type="bibr">de la Rubia et al. 2022</xref>), which also consists of a clustering, an error correction and a consensus step. For the Drosophila dataset, which lacks ground truth annotations, we additionally compared the isON pipeline with the reference-based transcript predictor StringTie2 (<xref rid="btad264-B14" ref-type="bibr">Kovaka et al. 2019</xref>). The analysis scripts are available at <ext-link xlink:href="https://github.com/aljpetri/isONform_analysis" ext-link-type="uri">https://github.com/aljpetri/isONform_analysis</ext-link>.</p>
    <sec>
      <title>3.1 Simulated data</title>
      <sec>
        <title>3.1.1 Generation of simulated reads</title>
        <p>For each simulated instance, we picked a SIRV transcript as a reference transcript but introduced alternative splicing by splitting the transcript into exons with lengths 20, 50, 100, and 200 chosen randomly. In each experiment, <italic toggle="yes">n</italic> isoforms were generated from the original sequence by subsampling a subset of the exons. We kept only isoforms that were longer than 100 base pairs. We then generated reads from the <italic toggle="yes">n</italic> isoforms where each isoform had an abundance of 8, 16, 32, or 64 reads. The reads were simulated as in (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>) to simulate full-length reads from transcripts with a median error rate of 7.0%.</p>
      </sec>
      <sec>
        <title>3.1.2 Simulated data results</title>
        <p>We ran the isON and RATTLE pipelines on the simulated reads and obtained predicted isoforms. We then used parasail to find the best match of each predicted isoform to the set of ground truth isoforms. For each simulated number of true isoforms, we ran ten replicate simulations. We calculated the precision and recall as follows. We aligned in an all-vs-all comparison the predicted transcripts to the ground truth isoforms with parasail. In this comparison, each prediction will have a best matching ground truth isoform. Several predictions may have the same best matching ground truth isoform, and some matching ground truth isoform may not have any prediction. Now, the best aligning prediction we label as a true positive (TP), and any redundant predictions aligning to the same isoform we classify as a false positive (FP). If a ground truth isoform did not have any best matching prediction we label it as a false negative (FN). We obtain precision as <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mtext>Precision</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FP</mml:mtext></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> and recall as <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mtext>Recall</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FN</mml:mtext></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. We additionally computed the identity for each TP and FP transcript prediction. The identity is computed as the number of nucleotide matches divided by the total length of the alignment region. We use semi-global alignment scoring for the pairwise alignment (ends are not penalized), but the identity is computed from the global alignment, to penalize incomplete ends in the reconstruction. We also compute the fraction of complete reconstructions, defined as a prediction reconstructed at least 95% in length (<xref rid="btad264-B20" ref-type="bibr">Nip et al. 2022</xref>). The precision, recall, and the average identity (%) per experiment are visualized in <xref rid="btad264-F3" ref-type="fig">Fig. 3</xref>. While we observe almost perfect precision for RATTLE, it has a much lower recall than isONform. isONform recovers almost all isoforms in each experiment with low cost in precision, while RATTLE misses nearly half of the true isoforms as the number of true isoforms increases. We also observe higher identity for isONform’s predictions compared with those of RATTLE (<xref rid="btad264-F3" ref-type="fig">Fig. 3</xref>). In addition, 99% of isONform’s predictions are classified as complete, while only 93% of RATTLE’s predictions are complete.</p>
        <fig position="float" id="btad264-F3">
          <label>Figure 3.</label>
          <caption>
            <p>Performance of isONform versus RATTLE on Simulated reads. The data were collected by running each algorithm on 10 different instances for each number of isoforms indicated. Left and center panels show precision and recall, respectively, of isONform’s and RATTLE’s predictions. The right panel shows percent identity of the predictions.</p>
          </caption>
          <graphic xlink:href="btad264f3" position="float"/>
        </fig>
      </sec>
    </sec>
    <sec>
      <title>3.2 Preprocessing of SIRV and Drosophila reads</title>
      <p>The SIRV and Drosophila datasets consist of roughly 1.6M and 3.4M, full length reads (<xref rid="btad264-T1" ref-type="table">Table 1</xref> in <xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>) with a median error rate of roughly 6.9% and 7%, respectively (<xref rid="btad264-T2" ref-type="table">Table 2</xref> in <xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>). Full-length reads amongst all reads sequenced with ONT are processed using pychopper (<ext-link xlink:href="https://github.com/nanoporetech/pychopper" ext-link-type="uri">https://github.com/nanoporetech/pychopper</ext-link>, commit 6dca13d). In the SIRV dataset, five of the 68 transcripts are perfect substrings of other isoforms. As they confound the alignments of the reads and downstream FP and TP evaluations, we filtered those transcripts out before performing the analysis with subsampled SIRV data.</p>
    </sec>
    <sec>
      <title>3.3 Spike-in (SIRV) analysis</title>
      <sec>
        <title>3.3.1 Controlled SIRV simulations</title>
        <p>For the SIRV data, we performed a similar analysis as described for the simulated data by simulating various abundances of reads from a fixed number of isoforms. We obtained the read abundances and isoforms as follows. We aligned all SIRV reads to the 63 distinct SIRV transcripts using minimap2. Each read has a primary alignment to a reference isoform. We subsample reads from a fixed number of isoforms from the resulting SAM file of alignments, with an abundance of either 8, 16, 32, or 64 reads. Similarly to the simulated data, we ran the isON pipeline and the RATTLE pipeline and computed precision and recall values as well as percent identity of the predictions with respect to the original transcripts. The results are displayed in <xref rid="btad264-F4" ref-type="fig">Fig. 4</xref>. As for the simulated data, isONform has substantially higher recall over RATTLE with a small cost of slightly reduced precision. The RATTLE pipeline misses nearly half of the predictions at higher isoform numbers, while recall stays close to perfect for isONform. IsONform’s predictions also have a higher percent identity (<xref rid="btad264-F4" ref-type="fig">Fig. 4</xref>), and 97% of the predictions are complete reconstructions, while only 92% of RATTLE’s predictions are complete.</p>
        <fig position="float" id="btad264-F4">
          <label>Figure 4.</label>
          <caption>
            <p>Performance of isONform versus RATTLE on SIRV reads. The data were collected by running each algorithm on 10 different instances for each number of isoforms. Left and center panels show precision and recall, respectively, of isONform’s and RATTLE’s predictions. The right panel shows percent identity of the predictions.</p>
          </caption>
          <graphic xlink:href="btad264f4" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.3.2 Precision–recall trade-off</title>
        <p>We also investigated how precision and recall of RATTLE and isONform varied on our SIM and controlled SIRV datasets (experiment details in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>). Similar to previous experiments we observe that isONform has a substantially higher recall than RATTLE on both SIRV (<xref rid="btad264-F5" ref-type="fig">Fig. 5</xref>) and SIM (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref>), while generating slightly more redundant predictions when minimal abundance is low. RATTLE has fairly stable precision and recall estimates across different abundances, indicating that it over-clusters the reads into transcript predictions. Based on the abundances from these experiments, a cutoff of 5 seems to be a good compromise between precision and recall in isONform.</p>
        <fig position="float" id="btad264-F5">
          <label>Figure 5.</label>
          <caption>
            <p>Precision and recall of isONform and RATTLE for reconstruction of 50 SIRV isoforms at variable abundances when filtering output by minimal read support (<italic toggle="yes">x</italic>-axis) of predicted isoforms.</p>
          </caption>
          <graphic xlink:href="btad264f5" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.3.3 Abundance estimates on the SIRV dataset</title>
        <p>We ran the isON and RATTLE pipelines on a subset of 100 000 SIRV reads to explore what happens with reference-free transcript predictions and their read support (abundance) at high coverages. We aligned the reads and the predicted transcripts from each pipeline against the SIRV transcriptome with minimap2. Each predicted transcript has a read coverage associated with it. If several predicted isoforms were appointed to the same original isoform, we added up their support to the given reference isoform. We then plotted the sum of reads supporting each reference transcript. We observed that isONform’s abundance estimates closely resembled the original read abundances (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref>), in contrast to RATTLE’s abundances. RATTLE only reconstructed 19 of the original transcripts in the data, while isONform reconstructed 62 out of 63 transcripts. As for precision, isONform generated a total of 374 isoform predictions (using 5 as minimal read support cutoff), suggesting a substantial redundancy in its predictions to ground truth. RATTLE generated 20 predictions. Nevertheless, with the highly variable abundance between transcripts, it is notable that isONform only missed one of the 63 transcripts while reducing read redundancy by over 200 times. Several isoforms were missing from RATTLE’s predictions (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref>) and since some isoforms have higher abundance than the original reads, we suppose RATTLE appoints reads from several isoforms into a single prediction. As for complete reconstructions, 97% and 89% of isONform’s and RATTLE’s predictions were classified as complete, respectively.</p>
      </sec>
    </sec>
    <sec>
      <title>3.4 Drosophila analysis</title>
      <p>We compared transcript predictions of the annotation-based tool StringTie2 with predictions from the isON and RATTLE pipelines. Since the data lack ground truth, we evaluate consistency between the tools. We aligned the transcript predictions to the Drosophila genome using uLTRA (<xref rid="btad264-B31" ref-type="bibr">Sahlin and Mäkinen 2021</xref>) and classified the predictions with the terminology described in (<xref rid="btad264-B34" ref-type="bibr">Tardaguila et al. 2018</xref>). Specifically, a prediction can be a Full Splice Match (FSM; matching a reference annotation at all splice sites), an Incomplete Splice Match (ISM; matching a reference annotation but missing at least one splice site in beginning or end), a Novel In Catalogue (NIC; all splice sites exists but as a novel combination), and a Novel Not in Catalogue (NNC; at least one splice site is not found in annotation).</p>
      <p>Overall, isONform’s predictions contained 2060 more unique FSMs than RATTLE’s (<xref rid="btad264-T1" ref-type="table">Table 1</xref>). In addition, isONform’s FSM and NIC predictions were broadly consistent with StringTie2’s predictions (<xref rid="btad264-F6" ref-type="fig">Fig. 6</xref>). For example, 2356 FSM predictions were produced by isONform and StringTie2, but not by RATTLE, while only 586 predictions were made by StringTie2 and RATTLE but not by isONform. Notably, a smaller set of FSM predictions (356) was predicted by both isONform and RATTLE that was not predicted by StringTie2. For the NIC, 50 predictions were produced by isONform and StringTie2, but not by RATTLE. Only three predictions were made by StringTie2 and RATTLE but not by isONform.</p>
      <fig position="float" id="btad264-F6">
        <label>Figure 6.</label>
        <caption>
          <p>Overlaps of predicted FSMs and NICs for isONform, RATTLE, and StringTie2 on the Drosophila dataset.</p>
        </caption>
        <graphic xlink:href="btad264f6" position="float"/>
      </fig>
      <table-wrap position="float" id="btad264-T1">
        <label>Table 1.</label>
        <caption>
          <p>Statistics of isON, RATTLE, and StringTie2 pipelines on the Drosophila dataset.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">StringTie2</th>
              <th rowspan="1" colspan="1">RATTLE</th>
              <th rowspan="1" colspan="1">isONform</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Total predictions</td>
              <td rowspan="1" colspan="1">15 589</td>
              <td rowspan="1" colspan="1">11 773</td>
              <td rowspan="1" colspan="1">27 134</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Median % identity</td>
              <td rowspan="1" colspan="1">100.0</td>
              <td rowspan="1" colspan="1">97.7</td>
              <td rowspan="1" colspan="1">98.3</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FSM</td>
              <td rowspan="1" colspan="1">9009</td>
              <td rowspan="1" colspan="1">6082</td>
              <td rowspan="1" colspan="1">12 347</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Unique FSMs</td>
              <td rowspan="1" colspan="1">8951</td>
              <td rowspan="1" colspan="1">6077</td>
              <td rowspan="1" colspan="1">8137</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">NIC</td>
              <td rowspan="1" colspan="1">145</td>
              <td rowspan="1" colspan="1">97</td>
              <td rowspan="1" colspan="1">174</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Unique NICs</td>
              <td rowspan="1" colspan="1">144</td>
              <td rowspan="1" colspan="1">97</td>
              <td rowspan="1" colspan="1">174</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ISM</td>
              <td rowspan="1" colspan="1">2141</td>
              <td rowspan="1" colspan="1">961</td>
              <td rowspan="1" colspan="1">2663</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">NNC</td>
              <td rowspan="1" colspan="1">1363</td>
              <td rowspan="1" colspan="1">1962</td>
              <td rowspan="1" colspan="1">2381</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Transcripts no splice sites</td>
              <td rowspan="1" colspan="1">2931</td>
              <td rowspan="1" colspan="1">2671</td>
              <td rowspan="1" colspan="1">9569</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p>We measure the number of overall predictions and their percent identity. StringTie2 has a perfect identity as it extracts transcripts using the reference genome, which could miss any biological SNV or indel variation. We also classify each prediction according to FSM, NIC, ISM, NNC, and transcripts without splice sites. We measure both total and unique number of FSM and NIC. Unique FSM and NIC are counted by merging predictions with identical splice site coordinates. In addition, the number of overall predictions for each tool as well as the number of full splice matches that were detected.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap position="float" id="btad264-T2">
        <label>Table 2.</label>
        <caption>
          <p>Wall clock time and RAM usage analysis for the Drosophila dataset for each pipeline and tool.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Pipeline</th>
              <th align="center" rowspan="1" colspan="1">Tool</th>
              <th align="center" rowspan="1" colspan="1">Peak memory</th>
              <th align="center" rowspan="1" colspan="1">Runtime</th>
              <th align="center" rowspan="1" colspan="1">Total runtime</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">StringTie2</td>
              <td rowspan="1" colspan="1">preprocess</td>
              <td rowspan="1" colspan="1">11.1 Gb</td>
              <td rowspan="1" colspan="1">5 min</td>
              <td rowspan="1" colspan="1">&lt; 6 min</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">run_StringTie2</td>
              <td rowspan="1" colspan="1">0.2 Gb</td>
              <td rowspan="1" colspan="1">&lt; 1 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">postprocess</td>
              <td rowspan="1" colspan="1">0.1 Gb</td>
              <td rowspan="1" colspan="1">&lt; 1 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RATTLE</td>
              <td rowspan="1" colspan="1">rattle cluster</td>
              <td rowspan="1" colspan="1">44.4 Gb</td>
              <td rowspan="1" colspan="1">3 h 53 min</td>
              <td rowspan="1" colspan="1">6 h 17 min</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">rattle correct</td>
              <td rowspan="1" colspan="1">21.3 Gb</td>
              <td rowspan="1" colspan="1">2 h 12 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">rattle polish</td>
              <td rowspan="1" colspan="1">0.9 Gb</td>
              <td rowspan="1" colspan="1">12 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">isON</td>
              <td rowspan="1" colspan="1">isONclust</td>
              <td rowspan="1" colspan="1">23.5 Gb</td>
              <td rowspan="1" colspan="1">1 h 10 min</td>
              <td rowspan="1" colspan="1">23 h 36 min</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">isONclust write</td>
              <td rowspan="1" colspan="1">6.7 Gb</td>
              <td rowspan="1" colspan="1">1 h 23 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">isONcorrect</td>
              <td rowspan="1" colspan="1">2.0 Gb</td>
              <td rowspan="1" colspan="1">4 h 56 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">isONform</td>
              <td rowspan="1" colspan="1">1.5 Gb</td>
              <td rowspan="1" colspan="1">16 h 10 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p>Total runtime indicates the overall runtime of the respective pipeline. StringTie2 preprocessing consists of aligning the reads to the annotation via Minimap2 and using samtools to index the alignment file. The StringTie2 postprocessing consists of calling gffread to generate a fasta file with predictions.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>However, isONform, also predicted many more isoforms (27 134) than StringTie2 (15 589) and RATTLE (11 773), with a large increase in the predictions of FSM, ISM, and predictions with no splice sites. Nevertheless, due to the high sensitivity of isONform and the orthogonal approach compared with a reference-based method, isONform could be used in combination with a reference-based approach even for well-annotated genomes. We believe this could be beneficial since LRGASP (<xref rid="btad264-B23" ref-type="bibr">Pardo-Palacios et al. 2021</xref>) found that reference-based methods seem to over-fit predictions to the annotation (<xref rid="btad264-B19" ref-type="bibr">LRGASP 2022</xref>) and, in general, produce discordant predictions (<xref rid="btad264-B19" ref-type="bibr">LRGASP 2022</xref>).</p>
    </sec>
    <sec>
      <title>3.5 Runtime analysis and memory usage assessment</title>
      <p>We computed runtime and peak memory usage for StringTie2, and the RATTLE and isON pipelines on the Drosophila dataset.</p>
      <p>All tools were run on a CentOS 7, with two 10-core Intel Xeon V4 CPUs each. The reference-based tool StringTie2 is very fast. The reference-free tools RATTLE and isONform are significantly slower, taking approximately 6 and 32 h. The runtime bottleneck in the isON pipeline is isONform. As for memory, the isON pipeline uses 23.5 Gb (peak during running isONclust), while RATTLE uses 44.4 Gb (peak during RATTLE cluster). We note that all the tools in the isON pipeline are implemented in python, while RATTLE is implemented in C++. We believe the isON pipeline could be significantly sped up and have its memory footprint lowered when implemented in a compiled language. We profiled the python implementation of isONform on various read cluster sizes. We found that about 70% of isONform’s runtime is spent in step 1 (constructing the minimizer pairs and their support for each read), which has time complexity <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if <italic toggle="yes">n</italic> denotes the number of reads in the batch and <italic toggle="yes">m</italic> denotes the maximum number of minimizer pairs observed within the <italic toggle="yes">n</italic> reads. While this construction step is shared with isONcorrect, isONcorrect does not compute it for each read, but stores previously corrected intervals to practically remove the cubic complexity. Such optimization may be possible also in isONform. This step is also suitable for compiled programs as it would involve only raw iteration and adding structs to a vector. About 20% of isONform’s runtime is consumed by step 4 (iterative bubble popping). The remaining 10% is evenly distributed over steps 3, 5, and 6.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>We presented a novel computational tool, isONform, capable of generating isoform predictions without a reference genome or annotation from long-read sequencing data. For simulated and SIRV data, isONform reconstructed substantially more isoforms than RATTLE at the cost of reduced precision. On our Drosophila dataset, isONform produced more consistent predictions with StringTie2 compared to RATTLE. We see at least two valuable use cases for isONform. First, it can produce an approximate reference transcriptome for organisms without high-quality assemblies or well-annotated genomes. Second, it can serve as a complementary prediction method to a reference-based method due to its orthogonal approach neither relying on a reference genome, transcript annotation, nor read alignments. Such orthogonal approaches may be valuable, as the community benchmarking project LRGASP (<xref rid="btad264-B23" ref-type="bibr">Pardo-Palacios et al. 2021</xref>) found that reference-based methods seem to over-fit predictions to reference annotations (<xref rid="btad264-B19" ref-type="bibr">LRGASP 2022</xref>) while noting considerable disagreement among methods (<xref rid="btad264-B19" ref-type="bibr">LRGASP 2022</xref>).</p>
    <sec>
      <title>4.1 Future work</title>
      <p>Currently isONform has a high runtime, which may be alleviated by implementing the algorithm in a compiled programming language. Particularly since 70% of isONform’s runtime is due to step 1 (constructing all minimizer pairs) which is suitable for compiled languages. Another possible improvement to isONform could be to use alternative seeding constructs to minimizer pairs. For example, using syncmers (<xref rid="btad264-B8" ref-type="bibr">Edgar 2021</xref>) instead of minimizers in isONcorrect produced solutions of NOMPs with higher WIS score (<xref rid="btad264-B17" ref-type="bibr">Lindbom Gunnari 2021</xref>). In addition, instead of using minimizer or syncmer-pairs as described here, linking syncmers using the strobemer method (<xref rid="btad264-B27" ref-type="bibr">Sahlin 2021</xref>), has demonstrated to be efficient for read mapping (<xref rid="btad264-B28" ref-type="bibr">Sahlin 2022</xref>) and could be an alternative to minimizer pairs that requires fewer seeds and, hence, improves runtime. At the preprocessing level to isONform, we found that some of isONform’s redundant predictions stem from residing in separate clusters in isONclust, which could be improved within the isONclust algorithm. Finally, isONform currently produces isoforms differing on exon-level. In the future, we hope to produce transcripts with different SNP stucture, which can be done by aligning the original reads to the transcript predictions and calling variants.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Conclusion</title>
    <p>We presented an algorithm and its implementation, isONform, capable of constructing polished isoforms from long-read ONT cDNA sequencing data without relying on a reference. Using simulated and synthetic data, we demonstrated that isONform produces accurate transcript predictions and has substantially higher recall than other reference-free algorithms, such as RATTLE. We also used biological data to show that isONform has a higher consistency with the reference-based approach StringTie2 compared to RATTLE. IsONform may be used for organisms where a high-quality genome is unavailable or when studying transcripts from genes or gene families that are not well represented in the genome.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad264_Supplementary_Data</label>
      <media xlink:href="btad264_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>Parts of the evaluation were enabled by resources in project snic2022-5-592 provided by the Swedish National Infrastructure for Computing (SNIC) at UPPMAX, partially funded by the Swedish Research Council through grant agreement no. 2018-05973.</p>
  </ack>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> is available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>K.S. was supported by the Swedish Research Council (SRC, Vetenskapsrådet) under Grant No. 2021-04000.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad264-B1">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Bayega</surname><given-names>A</given-names></string-name>, <string-name><surname>Wang</surname><given-names>YC</given-names></string-name>, <string-name><surname>Oikonomopoulos.</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><part-title>Transcript Profiling Using Long-Read Sequencing Technologies</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Raghavachari</surname><given-names>N</given-names></string-name>, <string-name><surname>Garcia-Reyero</surname><given-names>N</given-names></string-name></person-group>. (eds) Gene Expression Analysis. Methods in Molecular Biology, <year>2018</year>, vol <volume>1783</volume>. <publisher-name>Humana Press</publisher-name>, <publisher-loc>New York, NY</publisher-loc><year>2018</year>.</mixed-citation>
    </ref>
    <ref id="btad264-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Byrne</surname><given-names>A</given-names></string-name>, <string-name><surname>Cole</surname><given-names>C</given-names></string-name>, <string-name><surname>Volden</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Realizing the potential of full-length transcriptome sequencing</article-title>. <source>Philos Trans R Soc Lond B Biol Sci</source><year>2019</year>;<volume>374</volume>:<fpage>20190097</fpage>.<pub-id pub-id-type="pmid">31587638</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B3">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>Y</given-names></string-name>, <string-name><surname>Sim</surname><given-names>A</given-names></string-name>, <string-name><surname>Wan</surname><given-names>YK</given-names></string-name></person-group><etal>et al</etal> Context-aware transcript quantification from long read rna-seq data with bambu. <italic toggle="yes">bioRxiv</italic><year>2022</year>. <pub-id pub-id-type="doi">10.1101/2022.11.14.516358</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad264-B4">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chin</surname><given-names>C-S</given-names></string-name>, <string-name><surname>Khalak</surname><given-names>A.</given-names></string-name></person-group> Human genome assembly in 100 minutes. <italic toggle="yes">bioRxiv</italic><year>2019</year>. <pub-id pub-id-type="doi">10.1101/705616</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad264-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cole</surname><given-names>C</given-names></string-name>, <string-name><surname>Byrne</surname><given-names>A</given-names></string-name>, <string-name><surname>Adams</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Complete characterization of the human immune cell transcriptome using accurate full-length cdna sequencing</article-title>. <source>Genome Res</source><year>2020</year>;<volume>30</volume>:<fpage>589</fpage>–<lpage>601</lpage>.<pub-id pub-id-type="pmid">32312742</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Daily</surname><given-names>J.</given-names></string-name></person-group><article-title>Parasail: Simd c library for global, semi-global, and local pairwise sequence alignments</article-title>. <source>BMC Bioinf</source><year>2016</year>;<volume>17</volume>:<fpage>1</fpage>–<lpage>11</lpage>.</mixed-citation>
    </ref>
    <ref id="btad264-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>de la Rubia</surname><given-names>I</given-names></string-name>, <string-name><surname>Srivastava</surname><given-names>A</given-names></string-name>, <string-name><surname>Xue</surname><given-names>W</given-names></string-name></person-group><etal>et al</etal><article-title>Rattle: reference-free reconstruction and quantification of transcriptomes from nanopore sequencing</article-title>. <source>Genome Biol</source><year>2022</year>;<volume>23</volume>:<fpage>1</fpage>–<lpage>21</lpage>.<pub-id pub-id-type="pmid">34980209</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Edgar</surname><given-names>R.</given-names></string-name></person-group><article-title>Syncmers are more sensitive than minimizers for selecting conserved k-mers in biological sequences</article-title>. <source>PeerJ</source><year>2021</year>;<volume>9</volume>:<fpage>e10805</fpage>.<pub-id pub-id-type="pmid">33604186</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ekim</surname><given-names>B</given-names></string-name>, <string-name><surname>Berger</surname><given-names>B</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R.</given-names></string-name></person-group><article-title>Minimizer-space de bruijn graphs: whole-genome assembly of long reads in minutes on a personal computer</article-title>. <source>Cell Syst</source><year>2021</year>;<volume>12</volume>:<fpage>958</fpage>–<lpage>68.e6</lpage>.<pub-id pub-id-type="pmid">34525345</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gordon</surname><given-names>SP</given-names></string-name>, <string-name><surname>Tseng</surname><given-names>E</given-names></string-name>, <string-name><surname>Salamov</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Widespread polycistronic transcripts in fungi revealed by single-molecule mrna sequencing</article-title>. <source>PLoS ONE</source><year>2015</year>;<volume>10</volume>:<fpage>e0132628</fpage>.<pub-id pub-id-type="pmid">26177194</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hoang</surname><given-names>NV</given-names></string-name>, <string-name><surname>Furtado</surname><given-names>A</given-names></string-name>, <string-name><surname>Mason</surname><given-names>PJ</given-names></string-name></person-group><etal>et al</etal><article-title>A survey of the complex transcriptome from the highly polyploid sugarcane genome using full-length isoform sequencing and de novo assembly from short read sequencing</article-title>. <source>BMC Genom</source><year>2017</year>;<volume>18</volume>:<fpage>395</fpage>.</mixed-citation>
    </ref>
    <ref id="btad264-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Holmqvist</surname><given-names>I</given-names></string-name>, <string-name><surname>Bäckerholm</surname><given-names>A</given-names></string-name>, <string-name><surname>Tian</surname><given-names>Y</given-names></string-name></person-group><etal>et al</etal><article-title>Flame: long-read bioinformatics tool for comprehensive spliceome characterization</article-title>. <source>RNA</source><year>2021</year>;<volume>27</volume>:<fpage>1127</fpage>–<lpage>39</lpage>.<pub-id pub-id-type="pmid">34253685</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B13">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Kleinberg</surname><given-names>J</given-names></string-name>, <string-name><surname>Tardos</surname><given-names>E.</given-names></string-name></person-group><source>Algorithm Design</source>. <publisher-loc>Boston</publisher-loc>: <publisher-name>Pearson Education India</publisher-name>, <year>2006</year>.</mixed-citation>
    </ref>
    <ref id="btad264-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kovaka</surname><given-names>S</given-names></string-name>, <string-name><surname>Zimin</surname><given-names>AV</given-names></string-name>, <string-name><surname>Pertea</surname><given-names>GM</given-names></string-name></person-group><etal>et al</etal><article-title>Transcriptome assembly from long-read rna-seq alignments with stringtie2</article-title>. <source>Genome Biol</source><year>2019</year>;<volume>20</volume>:<fpage>278</fpage>.<pub-id pub-id-type="pmid">31842956</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kuo</surname><given-names>RI</given-names></string-name>, <string-name><surname>Cheng</surname><given-names>Y</given-names></string-name>, <string-name><surname>Zhang</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Illuminating the dark side of the human transcriptome with long read transcript sequencing</article-title>. <source>BMC Genom</source><year>2020</year>;<volume>21</volume>:<fpage>751</fpage>.</mixed-citation>
    </ref>
    <ref id="btad264-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>3094</fpage>–<lpage>100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B17">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Lindbom Gunnari</surname><given-names>S.</given-names></string-name></person-group> Improving indexing for computational error-correction of RNA sequences with syncmers. Bachelor’s Thesis, Stockholm University, Sweden, <year>2021</year>.</mixed-citation>
    </ref>
    <ref id="btad264-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>B</given-names></string-name>, <string-name><surname>Liu</surname><given-names>Y</given-names></string-name>, <string-name><surname>Li</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>deSALT: fast and accurate long transcriptomic read alignment with de bruijn graph-based index</article-title>. <source>Genome Biol</source><year>2019</year>;<volume>20</volume>:<fpage>274</fpage>.<pub-id pub-id-type="pmid">31842925</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B19">
      <mixed-citation publication-type="other"><collab>LRGASP</collab><year>2022</year>. Challenge 1 preliminary results. <ext-link xlink:href="https://www.gencodegenes.org/pages/LRGASP/" ext-link-type="uri">https://www.gencodegenes.org/pages/LRGASP/</ext-link>.</mixed-citation>
    </ref>
    <ref id="btad264-B20">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Nip</surname><given-names>KM</given-names></string-name>, <string-name><surname>Hafezqorani</surname><given-names>S</given-names></string-name>, <string-name><surname>Gagalova</surname><given-names>KK</given-names></string-name></person-group><etal>et al</etal> Reference-free assembly of long-read transcriptome sequencing data with rna-bloom2. <italic toggle="yes">bioRxiv</italic> 2022. <pub-id pub-id-type="doi">10.1101/2022.08.07.503110</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad264-B21">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Onodera</surname><given-names>T</given-names></string-name>, <string-name><surname>Sadakane</surname><given-names>K</given-names></string-name>, <string-name><surname>Shibuya</surname><given-names>T.</given-names></string-name></person-group><part-title>Detecting superbubbles in assembly graphs</part-title>. In: <source>International Workshop on Algorithms in Bioinformatics</source>. <publisher-name>Springer</publisher-name>, <year>2013</year>, <fpage>338</fpage>–<lpage>348</lpage>.</mixed-citation>
    </ref>
    <ref id="btad264-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Orabi</surname><given-names>B</given-names></string-name>, <string-name><surname>Xie</surname><given-names>N</given-names></string-name>, <string-name><surname>McConeghy</surname><given-names>B</given-names></string-name></person-group><etal>et al</etal><article-title>Freddie: annotation-independent detection and discovery of transcriptomic alternative splicing isoforms using long-read sequencing</article-title>. <source>Nucl Acids Res</source><year>2022</year>;51(2):e11.</mixed-citation>
    </ref>
    <ref id="btad264-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pardo-Palacios</surname><given-names>F</given-names></string-name>, <string-name><surname>Reese</surname><given-names>F</given-names></string-name>, <string-name><surname>Carbonell-Sala</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Systematic assessment of long-read rna-seq methods for transcript identification and quantification</article-title>. <source>Res Square</source><year>2021</year>.</mixed-citation>
    </ref>
    <ref id="btad264-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Prjibelski</surname><given-names>AD</given-names></string-name>, <string-name><surname>Mikheenko</surname><given-names>A</given-names></string-name>, <string-name><surname>Joglekar</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Accurate isoform discovery with isoquant using long reads</article-title>. <source>Nat Biotechnol</source><year>2023</year>.</mixed-citation>
    </ref>
    <ref id="btad264-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rautiainen</surname><given-names>M</given-names></string-name>, <string-name><surname>Marschall</surname><given-names>T.</given-names></string-name></person-group><article-title>MBG: minimizer-based sparse de Bruijn graph construction</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>2476</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">33475133</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hayes</surname><given-names>W</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name></person-group><etal>et al</etal><article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source><year>2004</year>;<volume>20</volume>:<fpage>3363</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Effective sequence similarity detection with strobemers</article-title>. <source>Genome Res</source><year>2021</year>;<volume>31</volume>:<fpage>2080</fpage>–<lpage>94</lpage>. 34667119[pmid].<pub-id pub-id-type="pmid">34667119</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Strobealign: flexible seed size enables ultra-fast and accurate read alignment</article-title>. <source>Genome Biol</source><year>2022</year>;<volume>23</volume>:<fpage>260</fpage>.<pub-id pub-id-type="pmid">36522758</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>De novo clustering of long-read transcriptome data using a greedy, quality value-based algorithm</article-title>. <source>J Comput Biol</source><year>2020</year>;<volume>27</volume>:<fpage>472</fpage>–<lpage>84</lpage>.<pub-id pub-id-type="pmid">32181688</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>Error correction enables use of oxford nanopore technology for reference-free transcriptome analysis</article-title>. <source>Nat Commun</source><year>2021</year>;<volume>12</volume>:<fpage>1</fpage>–<lpage>13</lpage>.<pub-id pub-id-type="pmid">33397941</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K</given-names></string-name>, <string-name><surname>Mäkinen</surname><given-names>V.</given-names></string-name></person-group><article-title>Accurate spliced alignment of long RNA sequencing reads</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>4643</fpage>–<lpage>51</lpage>.<pub-id pub-id-type="pmid">34302453</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K</given-names></string-name>, <string-name><surname>Tomaszkiewicz</surname><given-names>M</given-names></string-name>, <string-name><surname>Makova</surname><given-names>KD</given-names></string-name></person-group><etal>et al</etal><article-title>Deciphering highly similar multigene family transcripts from iso-seq data with isocon</article-title>. <source>Nat Commun</source><year>2018</year>;<volume>9</volume>:<fpage>4601</fpage>.<pub-id pub-id-type="pmid">30389934</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tang</surname><given-names>AD</given-names></string-name>, <string-name><surname>Soulette</surname><given-names>CM</given-names></string-name>, <string-name><surname>van Baren</surname><given-names>MJ</given-names></string-name></person-group><etal>et al</etal><article-title>Full-length transcript characterization of sf3b1 mutation in chronic lymphocytic leukemia reveals downregulation of retained introns</article-title>. <source>Nat Commun</source><year>2020</year>;<volume>11</volume>:<fpage>1</fpage>–<lpage>12</lpage>.<pub-id pub-id-type="pmid">31911652</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tardaguila</surname><given-names>M</given-names></string-name>, <string-name><surname>De La Fuente</surname><given-names>L</given-names></string-name>, <string-name><surname>Marti</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>Sqanti: extensive characterization of long-read transcript sequences for quality control in full-length transcriptome identification and quantification</article-title>. <source>Genome Res</source><year>2018</year>;<volume>28</volume>:<fpage>396</fpage>–<lpage>411</lpage>.<pub-id pub-id-type="pmid">29440222</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tung</surname><given-names>LH</given-names></string-name>, <string-name><surname>Shao</surname><given-names>M</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>Quantifying the benefit offered by transcript assembly with scallop-lr on single-molecule long reads</article-title>. <source>Genome Biol</source><year>2019</year>;<volume>20</volume>:<fpage>1</fpage>–<lpage>18</lpage>.<pub-id pub-id-type="pmid">30606230</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vaser</surname><given-names>R</given-names></string-name>, <string-name><surname>Sović</surname><given-names>I</given-names></string-name>, <string-name><surname>Nagarajan</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Fast and accurate de novo genome assembly from long uncorrected reads</article-title>. <source>Genome Res</source><year>2017</year>;<volume>27</volume>:<fpage>737</fpage>–<lpage>46</lpage>.<pub-id pub-id-type="pmid">28100585</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B37">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Volden</surname><given-names>R</given-names></string-name>, <string-name><surname>Schimke</surname><given-names>K</given-names></string-name>, <string-name><surname>Byrne</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal> Identifying and quantifying isoforms from accurate full-length transcriptome sequencing reads with mandalorion. <italic toggle="yes">bioRxiv</italic><year>2022</year>. <pub-id pub-id-type="doi">10.1101/2022.06.29.498139</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad264-B38">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Wyman</surname><given-names>D</given-names></string-name>, <string-name><surname>Balderrama-Gutierrez</surname><given-names>G</given-names></string-name>, <string-name><surname>Reese</surname><given-names>F</given-names></string-name></person-group><etal>et al</etal> A technology-agnostic long-read analysis pipeline for transcriptome discovery and quantification. <italic toggle="yes">bioRxiv</italic><year>2020</year>. <pub-id pub-id-type="doi">10.1101/672931</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad264-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zerbino</surname><given-names>DR</given-names></string-name>, <string-name><surname>Birney</surname><given-names>E.</given-names></string-name></person-group><article-title>Velvet: algorithms for de novo short read assembly using de bruijn graphs</article-title>. <source>Genome Res</source><year>2008</year>;<volume>18</volume>:<fpage>821</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">18349386</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311309</article-id>
    <article-id pub-id-type="pmid">37387174</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad264</article-id>
    <article-id pub-id-type="publisher-id">btad264</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>isONform: reference-free transcriptome reconstruction from Oxford Nanopore data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Petri</surname>
          <given-names>Alexander J</given-names>
        </name>
        <aff><institution>Department of Mathematics, Science for Life Laboratory, Stockholm University</institution>, Stockholm 106 91, <country country="SE">Sweden</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-7378-2320</contrib-id>
        <name>
          <surname>Sahlin</surname>
          <given-names>Kristoffer</given-names>
        </name>
        <aff><institution>Department of Mathematics, Science for Life Laboratory, Stockholm University</institution>, Stockholm 106 91, <country country="SE">Sweden</country></aff>
        <xref rid="btad264-cor1" ref-type="corresp"/>
        <!--ksahlin@math.su.se-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad264-cor1">Corresponding author. Department of Mathematics, Science for Life Laboratory, Stockholm University, Stockholm 106 91, Sweden. E-mail: <email>ksahlin@math.su.se</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i222</fpage>
    <lpage>i231</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad264.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>With advances in long-read transcriptome sequencing, we can now fully sequence transcripts, which greatly improves our ability to study transcription processes. A popular long-read transcriptome sequencing technique is Oxford Nanopore Technologies (ONT), which through its cost-effective sequencing and high throughput, has the potential to characterize the transcriptome in a cell. However, due to transcript variability and sequencing errors, long cDNA reads need substantial bioinformatic processing to produce a set of isoform predictions from the reads. Several genome and annotation-based methods exist to produce transcript predictions. However, such methods require high-quality genomes and annotations and are limited by the accuracy of long-read splice aligners. In addition, gene families with high heterogeneity may not be well represented by a reference genome and would benefit from reference-free analysis. Reference-free methods to predict transcripts from ONT, such as RATTLE, exist, but their sensitivity is not comparable to reference-based approaches.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present isONform, a high-sensitivity algorithm to construct isoforms from ONT cDNA sequencing data. The algorithm is based on iterative bubble popping on gene graphs built from fuzzy seeds from the reads. Using simulated, synthetic, and biological ONT cDNA data, we show that isONform has substantially higher sensitivity than RATTLE albeit with some loss in precision. On biological data, we show that isONform’s predictions have substantially higher consistency with the annotation-based method StringTie2 compared with RATTLE. We believe isONform can be used both for isoform construction for organisms without well-annotated genomes and as an orthogonal method to verify predictions of reference-based methods.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>
          <ext-link xlink:href="https://github.com/aljpetri/isONform" ext-link-type="uri">https://github.com/aljpetri/isONform</ext-link>
        </p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Swedish Research Council</institution>
            <institution-id institution-id-type="DOI">10.13039/501100004359</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>2021-04000</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Long-read sequencing techniques such as Oxford Nanopore Technologies (ONT) and Pacific Biosciences (PacBio) can produce reads covering the majority of transcripts from end-to-end. Such sequencing techniques have proven to enable a better understanding of the transcriptional landscape of cells (<xref rid="btad264-B1" ref-type="bibr">Bayega et al. 2018</xref>; <xref rid="btad264-B2" ref-type="bibr">Byrne et al. 2019</xref>; <xref rid="btad264-B5" ref-type="bibr">Cole et al. 2020</xref>). However, while long-read methods omit the need for transcript assembly as needed with short reads, transcript 3′ and 5′ variability, RNA degradation, long-read sequencing error profiles, and other sequencing artifacts inhibit downstream analysis of long-read data. Particularly, recovering the actual isoforms from long-read transcriptomic datasets has proven difficult, with studies observing thousands of low-quality and potentially spurious transcript predictions (<xref rid="btad264-B11" ref-type="bibr">Hoang et al. 2017</xref>; <xref rid="btad264-B15" ref-type="bibr">Kuo et al. 2020</xref>).</p>
    <sec>
      <title>1.1 Genome- and annotation-based methods</title>
      <p>Due to the noise in these datasets, a common approach to predict transcripts is to align the transcriptomic reads to a reference genome using a long-read splice aligner such as minimap2 (<xref rid="btad264-B16" ref-type="bibr">Li 2018</xref>), deSALT (<xref rid="btad264-B18" ref-type="bibr">Liu et al. 2019</xref>), or uLTRA (<xref rid="btad264-B31" ref-type="bibr">Sahlin and Mäkinen 2021</xref>). Several tools for reconstructing transcripts from long-read splice alignments have been proposed (<xref rid="btad264-B14" ref-type="bibr">Kovaka et al. 2019</xref>; <xref rid="btad264-B35" ref-type="bibr">Tung et al. 2019</xref>; <xref rid="btad264-B33" ref-type="bibr">Tang et al. 2020</xref>; <xref rid="btad264-B15" ref-type="bibr">Kuo et al. 2020</xref>; <xref rid="btad264-B38" ref-type="bibr">Wyman et al. 2020</xref>; <xref rid="btad264-B12" ref-type="bibr">Holmqvist et al. 2021</xref>; <xref rid="btad264-B22" ref-type="bibr">Orabi et al. 2022</xref>; <xref rid="btad264-B3" ref-type="bibr">Chen et al. 2022</xref>; <xref rid="btad264-B37" ref-type="bibr">Volden et al. 2022</xref>; <xref rid="btad264-B24" ref-type="bibr">Prjibelski et al. 2023</xref>). These tools typically predict transcripts by requiring both alignments and transcript annotations (<xref rid="btad264-B14" ref-type="bibr">Kovaka et al. 2019</xref>; <xref rid="btad264-B35" ref-type="bibr">Tung et al. 2019</xref>; <xref rid="btad264-B33" ref-type="bibr">Tang et al. 2020</xref>; <xref rid="btad264-B15" ref-type="bibr">Kuo et al. 2020</xref>; <xref rid="btad264-B38" ref-type="bibr">Wyman et al. 2020</xref>; <xref rid="btad264-B12" ref-type="bibr">Holmqvist et al. 2021</xref>; <xref rid="btad264-B3" ref-type="bibr">Chen et al. 2022</xref>; <xref rid="btad264-B37" ref-type="bibr">Volden et al. 2022</xref>), or requiring alignments but with the ability to predict transcripts outside annotations (<xref rid="btad264-B22" ref-type="bibr">Orabi et al. 2022</xref>; <xref rid="btad264-B24" ref-type="bibr">Prjibelski et al. 2023</xref>). A thorough community-effort benchmarking of many of these tools using several different sequencing techniques and genomes has recently been performed as part of the LRGASP challenge (<xref rid="btad264-B23" ref-type="bibr">Pardo-Palacios et al. 2021</xref>), and preliminary results of challenge 1 (<xref rid="btad264-B19" ref-type="bibr">LRGASP 2022</xref>) show a large discrepancy between methods in isoform detection, even for organisms with high-quality reference genomes such as mouse and human.</p>
      <p>Larger discrepancies in predicted transcripts between methods can be explained by the different algorithms they use, as well as error levels and artifacts of the sequencing techniques. However, there are also inherent limitations with predicting transcripts from alignments to a linear reference genome. Such limitations include predicting transcripts from fused genes, gene copies, or exons that are not present in the linear genome or shortcomings in splice alignment, which the predictions fundamentally rely on. For example, in the study by <xref rid="btad264-B31" ref-type="bibr">Sahlin and Mäkinen (2021)</xref>, we showed that long-read splice alignment methods have limitations such as (i) small exons not being detected by read aligners, (ii) overfitting to canonical splice sites, and (iii) not aligning over long introns. Additionally, relying on a reference genome and reference annotation limits the methods to organisms and genes for which reference annotations exist.</p>
    </sec>
    <sec>
      <title>1.2 Genome- and annotation-agnostic methods</title>
      <p>By not relying on high quality genome assemblies and annotations, reference-free approaches are important for research of lesser known organisms/gene families. In addition, they can overcome the splice-alignment limitations and the bias introduced by linear reference genomes. So far, relatively few methods have been proposed for reference-free transcript predictions. Some tools have been proposed for PacBio sequencing such as isoseq3 (<xref rid="btad264-B10" ref-type="bibr">Gordon et al. 2015</xref>) and IsoCon (<xref rid="btad264-B32" ref-type="bibr">Sahlin et al. 2018</xref>) but are limited to PacBio data and IsoCon is only applicable to targeted sequencing. While there exists recent unpublished work (<xref rid="btad264-B20" ref-type="bibr">Nip et al. 2022</xref>), the only published tool for reference-free transcriptome reconstruction of ONT reads is RATTLE (<xref rid="btad264-B7" ref-type="bibr">de la Rubia et al. 2022</xref>). However, as we show in our study, RATTLE has low transcript prediction sensitivity and misses many transcripts present in data. Some challenges of reference-free transcript reconstruction are highly variable abundance, alternative splicing, as well as long-read error profiles.</p>
    </sec>
    <sec>
      <title>1.3 Our contribution</title>
      <p>We have previously demonstrated algorithms for clustering and error correction of long transcriptomic reads through isONclust (<xref rid="btad264-B29" ref-type="bibr">Sahlin and Medvedev 2020</xref>) and isONcorrect (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>). We here introduce an algorithm and its implementation, isONform, for the final step of this pipeline to produce transcript predictions. IsONform builds a graph based on paired-minimizer seeds, that, similarly to minimizer-based genome assembly approaches (<xref rid="btad264-B25" ref-type="bibr">Rautiainen and Marschall 2021</xref>; <xref rid="btad264-B9" ref-type="bibr">Ekim et al. 2021</xref>), aims to sparsely represent the sequence information in the data. IsONform then employs iterative bubble popping on the graph to remove errors while keeping exon differences. When no poppable bubbles exist, isoform predictions can be traced from the graph by following paths of full-length reads. A fundamental difference between our isON pipeline (isONclust, isONcorrect, and isONform) and RATTLE’s pipeline (cluster, error correct, and polish) is that the isON pipeline works with clusters of reads from a gene, while RATTLE clusters by transcript. This allows isON’s error correction and consensus prediction (isONform) to leverage shared exons among splice variants, thus, the potential to recover more transcripts with higher base-level accuracy compared with predictions by RATTLE. However, to benefit from shared exons in different transcripts, it also requires a more sophisticated consensus generation algorithm able to separate isoforms at the consensus calling step, compared with RATTLE, which only does base-level polishing per transcript in the consensus (polishing) step. Using simulated and synthetic reads, we show that isONform recovers substantially more isoforms than RATTLE. On biological data, we show that isONform has much higher consistency with the reference-based tool StringTie2 compared with RATTLE. We believe that isONform (integrated into our isON pipeline) has two primary use cases. First, it can be used for isoform construction for organisms without well-annotated genomes. Second, it can be used as an orthogonal method to verify consistency in reference-based prediction since systematic limitations exist, as described in Section 1.1.</p>
    </sec>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>In Section 2.1, we give a high level overview of the algorithm. In Section 2.2, we introduce notation and formally define minimizer pairs and the graph structure that isONform uses. Finally, we describe the algorithm in depth in Section 2.3 and implementation details in Section 2.4.</p>
    <sec>
      <title>2.1 Algorithm overview</title>
      <p>The input of our algorithm are clustered and error-corrected reads from isONclust (<xref rid="btad264-B29" ref-type="bibr">Sahlin and Medvedev 2020</xref>) and isONcorrect (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>). Each cluster represents reads from isoforms from a gene family and can be processed individually and in parallel with isONform. The output is a set of predicted transcripts in fastq format. We describe the algorithm for reads from a single cluster. In step 1, reads are partitioned into intervals using “minimizer pairs” (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>) as seeds. In step 2, a weighted interval scheduling (WIS) problem is solved to find a set of maximally weighted and nonoverlapping minimizer pairs (NOMPs) for each read as done in isONcorrect (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>). In step 3, the set of NOMPs is used to construct a directed acyclic graph (DAG) in which vertices represent the NOMPs and neighboring NOMPs are connected with an edge. In step 4, the graph is simplified by an iterative bubble-popping algorithm designed to remove errors and mutations between reads while keeping exon differences. In step 5, predicted isoforms are generated by finding supported paths through the graph. Finally, step 6 removes any redundant isoform predictions caused mainly by the larger 3′ and 5′ variability using pairwise alignment of predicted isoforms. The isoform predictions remaining after this step constitute the final predictions. An overview of the algorithm is shown in <xref rid="btad264-F1" ref-type="fig">Fig. 1</xref>.</p>
      <fig position="float" id="btad264-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Overview of the isONform algorithm. IsONform takes as input clustered and error-corrected reads generated with isONclust and isONcorrect, respectively. The example illustrates a cluster consisting of five reads (<italic toggle="yes">r</italic><sub>1</sub> to <italic toggle="yes">r</italic><sub>5</sub>) from three isoforms, where <italic toggle="yes">p</italic> denotes positions of minimizers on <italic toggle="yes">r</italic><sub>1</sub>. isONform uses all minimizer pairs from minimizers at distance <italic toggle="yes">x<sub>min</sub></italic> to <italic toggle="yes">x<sub>max</sub></italic>. The figure shows an example of 10 minimizer pairs on <italic toggle="yes">r</italic><sub>2</sub>. Each minimizer pair is assigned a weight formed from the length of the minimizer pairs and its abundance in the cluster. The instance is then sent to a weighted interval scheduler, which is used to find the set of NOMPs. In our example, we find five segments for <italic toggle="yes">r</italic><sub>1</sub> while the scheduler finds four instances for <italic toggle="yes">r</italic><sub>2</sub>. A DAG is built up by the NOMPs, and we add a global source node <italic toggle="yes">s</italic> as well as a global sink node <italic toggle="yes">t</italic> (step 3). An iterative bubble-popping approach is employed to merge similar paths in the graph (step 4). This reduces the number of paths supported by reads (step 5). We finally perform postmerging of the transcripts due to 3′ and 5′ variability. For each isoform, a consensus sequence is generated from all reads appointed to it using the SPOA algorithm.</p>
        </caption>
        <graphic xlink:href="btad264f1" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.2 Preliminaries</title>
      <p>isONform uses the same generation of minimizers and minimizer-pairs as described in isONcorrect (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>). We describe them here for completeness.</p>
      <sec>
        <title>2.2.1 Minimizers</title>
        <p>Minimizers (<xref rid="btad264-B26" ref-type="bibr">Roberts et al. 2004</xref>) are subsampled <italic toggle="yes">k</italic>-mers. Let <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula> denote a string of nucleotides, which we refer to as “read.” We use <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to refer to the nucleotide located at the <italic toggle="yes">i</italic>-th position of <italic toggle="yes">r</italic>. Given two integers <italic toggle="yes">k</italic> and <italic toggle="yes">w</italic> such that <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>w</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, the minimizer of <italic toggle="yes">r</italic> at position <italic toggle="yes">p</italic> is the lexicographically smallest k-mer <italic toggle="yes">m</italic> that starts inside the interval <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We then say that <italic toggle="yes">m</italic> is a minimizer of the read <italic toggle="yes">r</italic>, or, alternatively, is a positional minimizer <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of read <italic toggle="yes">r</italic>. Let <italic toggle="yes">M</italic>(<italic toggle="yes">r</italic>) be the set of positional minimizers of read <italic toggle="yes">r</italic>. In the following example, we use <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="italic">ACGGATCAC</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, yielding the set of positional minimizers <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <title>2.2.2 Minimizer pairs</title>
        <p>Let <italic toggle="yes">x<sub>min</sub></italic> and <italic toggle="yes">x<sub>max</sub></italic> be two positive integer parameters. We let <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">max</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the ordered set (according to increasing <italic toggle="yes">p<sub>i</sub></italic> then <italic toggle="yes">p<sub>j</sub></italic>) of paired positional minimizers separated by at least <italic toggle="yes">x<sub>min</sub></italic> and at most <italic toggle="yes">x<sub>max</sub></italic> nucleotides in <italic toggle="yes">r</italic>. Similarly, we denote the sequence of paired minimizers as <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">Str</mml:mi><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. <italic toggle="yes">W<sub>r</sub></italic> with the positions omitted but duplicates retained. The above example with the following parameters <italic toggle="yes">x<sub>min</sub></italic> = 2, <italic toggle="yes">x<sub>max</sub></italic> = 4 therefore yields <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">str</mml:mi><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>C</mml:mi><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Given a set of reads <italic toggle="yes">R</italic>, we let <italic toggle="yes">W</italic> be the union of all <italic toggle="yes">W<sub>r</sub></italic> for the reads in <italic toggle="yes">R</italic> and we let <italic toggle="yes">StrW</italic> be the union of all <italic toggle="yes">StrW<sub>r</sub></italic>. Besides error correction (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>), minimizer pairs have also been used in genome assembly (<xref rid="btad264-B4" ref-type="bibr">Chin and Khalak 2019</xref>).</p>
      </sec>
      <sec>
        <title>2.2.3 Nonoverlapping minimizer pairs</title>
        <p>For each read, isONform, similarly to isONcorrect, produces a subset of NOMPs from the set of minimizer pairs. The NOMPs are decided upon by the solution to a WIS problem. Specifically, the minimizer pairs span an “interval” on the read. The input to the WIS problem is a set of minimizer pairs (intervals) <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">a<sub>j</sub></italic> &lt; <italic toggle="yes">b<sub>j</sub></italic>. The number of reads supporting an interval <italic toggle="yes">I<sub>j</sub></italic> (provided in <italic toggle="yes">StrW</italic>) gives a weight <italic toggle="yes">w<sub>j</sub></italic> to <italic toggle="yes">I<sub>j</sub></italic>. The solution to the WIS problem outputs a subset <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>′</mml:mo><mml:mo>⊂</mml:mo><mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></inline-formula> of nonoverlapping intervals for which the sum of weights is maximized. Our intervals in the solution <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> correspond to NOMPs that we index in the order they appear on the read, e.g. <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is the <italic toggle="yes">j</italic>th NOMP in <italic toggle="yes">r</italic>. The WIS problem can be solved exactly by applying a dynamic programming algorithm that runs with <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time complexity, with <italic toggle="yes">n</italic> denoting the number of intervals (<xref rid="btad264-B13" ref-type="bibr">Kleinberg and Tardos 2006</xref>).</p>
      </sec>
      <sec>
        <title>2.2.4 Graphs of nonoverlapping minimizer pairs</title>
        <p>We represent the NOMPs as vertices, where <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> denotes the <italic toggle="yes">i-</italic>th NOMP on read <italic toggle="yes">r</italic>. We draw a directed edge <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> between two vertices <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> represent neighboring NOMPs on a read. This forms a directed graph <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where we insert a global source and sink node <italic toggle="yes">s</italic> and <italic toggle="yes">t</italic>, respectively. We draw a directed edge <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from the global source to the first NOMP <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> on each read. Similarly, we draw a directed edge <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>″</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from the last minimizer pair <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>″</mml:mo></mml:mrow></mml:math></inline-formula> on each read to the global sink. A read spells a path from the global source to the sink.</p>
        <p>Each node <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> also contains information on the start and end position and the length (span) of the NOMP on read <italic toggle="yes">r</italic>. Furthermore, each edge <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> has a length <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> associated with it, representing the distance between the <italic toggle="yes">i-</italic>th and (<italic toggle="yes">i</italic> + 1)-th NOMP on <italic toggle="yes">r</italic>. Therefore, a path <italic toggle="yes">p</italic> in <italic toggle="yes">G</italic> that follows a read <italic toggle="yes">r</italic> has a corresponding length (<inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>), start, and stop position on <italic toggle="yes">r</italic>. The graph is built up by iterating through the reads in order of appearance in the fastq file. A NOMP that is shared between reads will be represented by a single node. A NOMP is considered shared if it has the same minimizer pair and they do not have a difference in their pairwise distance larger than <italic toggle="yes">δ</italic> (parameter to isONform). However, isONform stores the length of each NOMP in the vertex. A detailed description of the graph construction is given in Section 2.3.1.</p>
      </sec>
      <sec>
        <title>2.2.5 Bubbles and multibubbles</title>
        <p>We define a bubble as a pair of paths with a shared start node <italic toggle="yes">b<sub>s</sub></italic> and end node <italic toggle="yes">b<sub>e</sub></italic> where the internal path nodes are disjoint. Note that nodes that are not part of the bubble can be reached from nodes belonging to the bubble. If the bubble additionally has at least one read supporting each path from <italic toggle="yes">b<sub>s</sub></italic> to <italic toggle="yes">b<sub>e</sub></italic> we denote it as “read-supported bubble.” We will detect and resolve what we refer to as read-supported multibubbles. An example of a multibubble structure is shown in <xref rid="btad264-F2" ref-type="fig">Fig. 2a</xref>. Multibubbles have similar characteristics as superbubbles (<xref rid="btad264-B21" ref-type="bibr">Onodera et al. 2013</xref>) except that multibubbles allow nodes not part of the multibubble to be reachable from nodes in the multibubble and for several bubbles to start/end in one node, i.e. they do not fulfil the minimality and the matching criteria (<xref rid="btad264-B21" ref-type="bibr">Onodera et al. 2013</xref>). Let <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> a directed graph and (<italic toggle="yes">s</italic>, <italic toggle="yes">t</italic>) being an unordered pair of distinct vertices. Then, a multibubble is defined if it satisfies the following criteria:</p>
        <fig position="float" id="btad264-F2">
          <label>Figure 2.</label>
          <caption>
            <p>Bubble popping on a graph. (a) Our initial graph. There are three bubbles in this graph ({a, b, c, d},{s’,a, c, d, g, h, i, e}, and {s’,a, b, d, e, f, g, h, i, j, k, l, m, t’}). The bubble popping starts with the smallest bubble (fewest vertices) and continues until no more bubbles can be popped. (b) Bubble {a, b, c, d} was popped and its nodes linearized. (c) Bubble {s’,a, b, c, d, g, h, i, e} was popped and its nodes linearized. (d) The bubble in (c) could also be popped and we now have a single path from <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, representing a single isoform in the graph.</p>
          </caption>
          <graphic xlink:href="btad264f2" position="float"/>
        </fig>
        <list list-type="bullet">
          <list-item>
            <p><bold>Reachability</bold>: <italic toggle="yes">t</italic> can be reached from <italic toggle="yes">s.</italic></p>
          </list-item>
          <list-item>
            <p><bold>Acyclicity</bold>: the subgraph induced by <italic toggle="yes">U</italic> is acyclic where <italic toggle="yes">U</italic> is the set of vertices as described above.</p>
          </list-item>
        </list>
        <p>then we say that the subgraph in the description of the acyclicity condition forms a multibubble and <italic toggle="yes">s</italic>, <italic toggle="yes">t</italic> and <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>U</mml:mi><mml:mo>∖</mml:mo><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> are the multibubble’s source, sink and interior respectively.</p>
      </sec>
    </sec>
    <sec>
      <title>2.3 Algorithm</title>
      <p>Steps 1 and 2 consist of constructing minimizer pairs and solving the WIS problem to produce NOMPs as input to isONform. These steps are performed identically to isONcorrect.</p>
      <sec>
        <title>2.3.1 Step 3: graph construction</title>
        <p>The graph is built up by iterating through the reads in order of appearance in the fastq file, and adding vertices and edges from the NOMPs produced in step 2. We want to keep the graph acyclic. Repetitive NOMPs within a read may cause a cycle. Also, since NOMPs are fuzzy seeds, they may have different lengths. Therefore, we want to identify larger length differences between NOMPs shared between reads. Finally, there can be gaps between neighboring NOMPs in reads. If two reads share two neighboring NOMPs, the gap between the two NOMPs may differ, indicating a structural difference between the reads. We handle those cases as follows.</p>
        <p><bold>Preserving acyclicity:</bold> For each new <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to be added to <italic toggle="yes">G</italic>, if <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is already found in the graph it may create a cycle if we add the edge <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> connecting it to its predecessor. We can prevent <italic toggle="yes">G</italic> becoming cyclic by looking at the topological order of the graph. If <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> would introduce a cycle, we instead add a new vertex <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to <italic toggle="yes">G</italic> representing <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
        <p><bold>Differences in NOMP span:</bold> For each <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to be added to <italic toggle="yes">G</italic>, if the NOMP is already found in the graph, we check the length difference of <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and the NOMP of the node existing in the graph. If the NOMP lengths differ by more than <italic toggle="yes">δ</italic> nucleotides, we add a new node. If a NOMP is already represented by two or more NOMPs, <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is added to the vertex that has the NOMP with the closest distance to <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
        <p><bold>Differences between NOMPs:</bold> In a similar fashion to checking differences in NOMP span, if we find two reads <italic toggle="yes">r</italic> and <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> having the same neighboring NOMPs <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> = <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mi>j</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>NOMP</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> but <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mo>δ</mml:mo></mml:mrow></mml:math></inline-formula> then we create a separate vertex <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> for the second NOMP while adding the first NOMP to the vertex already in the graph.</p>
      </sec>
      <sec>
        <title>2.3.2 Step 4: iterative bubble popping</title>
        <p>NOMPs are indel tolerant seeds, but sequencing errors and exon differences may result in local bubbles (<xref rid="btad264-B39" ref-type="bibr">Zerbino and Birney 2008</xref>) in <italic toggle="yes">G</italic>. It requires only a few bubbles to lead to many reads having unique paths through <italic toggle="yes">G</italic> (possibly exponentially increasing with the number of bubbles), which yields redundant consensus sequences. The purpose of the iterative bubble-popping step is to remove local bubbles in the graph caused by read errors and SNP differences while preserving differences at the exon level between reads.</p>
        <p><bold>Overview:</bold> At a high level, <italic toggle="yes">G</italic> may contain several multibubbles sharing vertices. We find disjoint “read-supported bubbles” that we can pop during each iteration of our iterative bubble popping. We start by analyzing the smallest bubbles (with respect to the number of vertices) and gradually test and pop bubbles until no more new bubbles can be detected in the graph. We test if a bubble is poppable by forming a consensus (using SPOA, <xref rid="btad264-B36" ref-type="bibr">Vaser et al. 2017</xref>) of the subsequences of reads corresponding to each path in the bubble. If such consensuses do not differ in length by more than <italic toggle="yes">δ</italic> and have sequence similarity higher than <italic toggle="yes">α</italic> (parameter to isONform), we pop the bubble. Otherwise, we save it as unpoppable. If a bubble can be popped, we use the relative distance information to reorder (or “linearize”) the vertices of the two paths. At each new iteration, the bubbles we previously investigated could either be popped or were stored as unpoppable. Bubbles that have been deemed to be unpoppable are skipped in the following iterations. During each iteration, the bubble-popping approach reduces the number of edges in our graph. A graphical overview of this process is illustrated in <xref rid="btad264-F2" ref-type="fig">Fig. 2</xref>.</p>
        <p><bold>Details:</bold> In detail, the process of iterative bubble popping is performed as follows:</p>
        <list list-type="order">
          <list-item>
            <p>We identify all vertices having more than one out-edge <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> as well as all vertices <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> that have more than one in-edge. These vertices are potential source and sink vertices of bubbles.</p>
          </list-item>
          <list-item>
            <p>We then generate all potential pairs of <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mtext>TOP</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mtext>TOP</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, with <italic toggle="yes">TOP</italic> denoting the topological order. We sort the bubbles by the number of nodes participating in the bubble in increasing order. We verify that <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> have at least two reads in common, the minimum needed for each path in the bubble to be supported by one read.</p>
          </list-item>
          <list-item>
            <p>For each potential <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-bubble, we verify the eligibility by following the supporting reads from <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. If we find at least two paths with disjoint sets of internal nodes, with each set being supported by at least one read, we store it as a read-supported bubble <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">B</italic> is the set of bubbles. Note that <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can contain more than two paths. If the paths <italic toggle="yes">p</italic> and <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> overlap, a smaller bubble should exist between the reads, and we ignore the bubble. This may happen if a previous bubble has been deemed to be unpoppable.</p>
          </list-item>
          <list-item>
            <p>For each <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>, we iterate over the paths <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula> and produce a consensus sequence formed by all the reads supporting the path using the SPOA algorithm (<xref rid="btad264-B36" ref-type="bibr">Vaser et al. 2017</xref>).</p>
          </list-item>
          <list-item>
            <p>The two consensuses from each pair of paths <italic toggle="yes">p</italic> and <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> in step 4 are then aligned via the parasail algorithm (<xref rid="btad264-B6" ref-type="bibr">Daily 2016</xref>). Suppose the alignment between the path consensuses for <italic toggle="yes">p</italic> and <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> does not yield a mismatch longer than <italic toggle="yes">δ</italic>, and the consensuses have sequence similarity higher than <italic toggle="yes">α</italic>. In that case, we deem a bubble to be poppable. We then merge the paths by linearizing the path nodes with <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
          </list-item>
          <list-item>
            <p>The linearization of nodes in <italic toggle="yes">p</italic> and <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is performed by inferring the distance of each vertex (in sequence space) to <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. This is done by averaging the sequence distance from <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> to vertex <italic toggle="yes">v</italic> of each supporting read. If two paths have been linearized through steps 4–6, we postpone steps 4–6 for bubbles overlapping with this bubble to the next iteration of the bubble-popping approach.</p>
          </list-item>
          <list-item>
            <p>After steps 1–6, we have linearized several bubbles or marked them as unpoppable in <italic toggle="yes">G</italic>. We then repeat the algorithm starting with step 1 for the modified graph. We stop the iterative bubble popping process if we detect less than N (isONform parameter, default 1) new bubbles during an iteration.</p>
          </list-item>
        </list>
      </sec>
      <sec>
        <title>2.3.3 Step 5: generation of isoforms</title>
        <p>After performing the iterative bubble popping, we extract isoform predictions by following reads from <italic toggle="yes">s</italic> to <italic toggle="yes">t</italic> in <italic toggle="yes">G</italic>. We arbitrarily pick a read <italic toggle="yes">r</italic> from the pool of reads and trace its path <italic toggle="yes">p</italic> through <italic toggle="yes">G</italic>. By the construction of <italic toggle="yes">G</italic>, it is implied that all the reads sharing <italic toggle="yes">p</italic> as path from <italic toggle="yes">s</italic> to <italic toggle="yes">t</italic> also share all vertices and edges with <italic toggle="yes">r</italic>. All reads having <italic toggle="yes">p</italic> as path from <italic toggle="yes">s</italic> to <italic toggle="yes">t</italic> in <italic toggle="yes">G</italic> make up one isoform prediction in isONform. We produce the consensus sequence by applying the SPOA algorithm, forming a partial-order alignment graph from the reads, from which we can extract a consensus sequence.</p>
      </sec>
      <sec>
        <title>2.3.4 Step 6: removal of start and end variability</title>
        <p>Reads produced via long-read sequencing of biological sequences may have high variability at the 3′ and 5′ ends. We remove redundancy in predictions due to the ends variability as follows. The predicted consensus sequences are pairwise aligned. We merge two predictions if they differ in the ends with no internal difference larger than <italic toggle="yes">δ</italic>, inferred from their semiglobal alignment. We perform the merging by iterating over the isoform predictions from shortest to longest prediction, merging shorter predictions into longer ones. The final isoforms are generated by running SPOA (<xref rid="btad264-B36" ref-type="bibr">Vaser et al. 2017</xref>) on the merged set of reads. Ends variability merging has the downside of potentially collapsing transcripts with true variability in start and end sites but is commonly employed to reduce redundant predictions both in reference-based (<xref rid="btad264-B15" ref-type="bibr">Kuo et al. 2020</xref>) and reference-free (<xref rid="btad264-B10" ref-type="bibr">Gordon et al. 2015</xref>) software. For example, official PacBio software isoseq3 (<xref rid="btad264-B10" ref-type="bibr">Gordon et al. 2015</xref>) merges transcripts with less than 30 nt and 100 nt difference in the 3′ and 5′ ends, respectively.</p>
      </sec>
    </sec>
    <sec>
      <title>2.4 Implementation details and output</title>
      <p>Mature coding RNAs typically have poly-A tails attached to them, possibly bearing large variability in length. We compress poly-A regions in our data by searching the last 100 nucleotides in reads for stretches of more than 12 consecutive A’s. We compress these stretches into one nucleotide each. In addition, similarly to the isONcorrect algorithm, we divide large gene clusters into smaller batches of 1000 (parameter to isONform) reads and process them individually. We noted this strategy to be faster than considering all reads of a cluster which may contain up to 54,889 reads (the largest cluster in Drosophila). This batching strategy, however, requires us to run a postmerging step of the isoform predictions produced for each batch. We perform this merging identically to step 6 in the isONform algorithm. All the consensus sequences with an abundance of at least <italic toggle="yes">X</italic> reads (parameter to isONform, default 5) remaining after this final merging step constitute the final isoform predictions. In isONform, parasail is used with the following parameters 2, −2, 12, and 1 for match score, mismatch penalty, gap opening penalty, and gap extension, respectively. For the consensus calling via SPOA we call the method with the following parameters 0, 0, −2 for l, r, and g.</p>
      <p>The predicted isoforms are written in fastq format. The predictions that did not pass the abundance threshold are written into a separate file. Additionally, isONform writes the read id mappings for each isoform into a file, making it possible to identify which reads were appointed to the same isoform and its read abundance. The algorithm is available at <ext-link xlink:href="https://github.com/aljpetri/isONform" ext-link-type="uri">https://github.com/aljpetri/isONform</ext-link>.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We used a biological, a synthetic and a simulated dataset to investigate the performance of isONform as well as isONclust and isONcorrect which constitute preprocessing steps. We will refer to the running all three of those tools as isON pipeline. For all analyses we ran the full isON pipeline and compared its predictions with the predictions of the RATTLE pipeline (<xref rid="btad264-B7" ref-type="bibr">de la Rubia et al. 2022</xref>), which also consists of a clustering, an error correction and a consensus step. For the Drosophila dataset, which lacks ground truth annotations, we additionally compared the isON pipeline with the reference-based transcript predictor StringTie2 (<xref rid="btad264-B14" ref-type="bibr">Kovaka et al. 2019</xref>). The analysis scripts are available at <ext-link xlink:href="https://github.com/aljpetri/isONform_analysis" ext-link-type="uri">https://github.com/aljpetri/isONform_analysis</ext-link>.</p>
    <sec>
      <title>3.1 Simulated data</title>
      <sec>
        <title>3.1.1 Generation of simulated reads</title>
        <p>For each simulated instance, we picked a SIRV transcript as a reference transcript but introduced alternative splicing by splitting the transcript into exons with lengths 20, 50, 100, and 200 chosen randomly. In each experiment, <italic toggle="yes">n</italic> isoforms were generated from the original sequence by subsampling a subset of the exons. We kept only isoforms that were longer than 100 base pairs. We then generated reads from the <italic toggle="yes">n</italic> isoforms where each isoform had an abundance of 8, 16, 32, or 64 reads. The reads were simulated as in (<xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>) to simulate full-length reads from transcripts with a median error rate of 7.0%.</p>
      </sec>
      <sec>
        <title>3.1.2 Simulated data results</title>
        <p>We ran the isON and RATTLE pipelines on the simulated reads and obtained predicted isoforms. We then used parasail to find the best match of each predicted isoform to the set of ground truth isoforms. For each simulated number of true isoforms, we ran ten replicate simulations. We calculated the precision and recall as follows. We aligned in an all-vs-all comparison the predicted transcripts to the ground truth isoforms with parasail. In this comparison, each prediction will have a best matching ground truth isoform. Several predictions may have the same best matching ground truth isoform, and some matching ground truth isoform may not have any prediction. Now, the best aligning prediction we label as a true positive (TP), and any redundant predictions aligning to the same isoform we classify as a false positive (FP). If a ground truth isoform did not have any best matching prediction we label it as a false negative (FN). We obtain precision as <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mtext>Precision</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FP</mml:mtext></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> and recall as <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mtext>Recall</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FN</mml:mtext></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. We additionally computed the identity for each TP and FP transcript prediction. The identity is computed as the number of nucleotide matches divided by the total length of the alignment region. We use semi-global alignment scoring for the pairwise alignment (ends are not penalized), but the identity is computed from the global alignment, to penalize incomplete ends in the reconstruction. We also compute the fraction of complete reconstructions, defined as a prediction reconstructed at least 95% in length (<xref rid="btad264-B20" ref-type="bibr">Nip et al. 2022</xref>). The precision, recall, and the average identity (%) per experiment are visualized in <xref rid="btad264-F3" ref-type="fig">Fig. 3</xref>. While we observe almost perfect precision for RATTLE, it has a much lower recall than isONform. isONform recovers almost all isoforms in each experiment with low cost in precision, while RATTLE misses nearly half of the true isoforms as the number of true isoforms increases. We also observe higher identity for isONform’s predictions compared with those of RATTLE (<xref rid="btad264-F3" ref-type="fig">Fig. 3</xref>). In addition, 99% of isONform’s predictions are classified as complete, while only 93% of RATTLE’s predictions are complete.</p>
        <fig position="float" id="btad264-F3">
          <label>Figure 3.</label>
          <caption>
            <p>Performance of isONform versus RATTLE on Simulated reads. The data were collected by running each algorithm on 10 different instances for each number of isoforms indicated. Left and center panels show precision and recall, respectively, of isONform’s and RATTLE’s predictions. The right panel shows percent identity of the predictions.</p>
          </caption>
          <graphic xlink:href="btad264f3" position="float"/>
        </fig>
      </sec>
    </sec>
    <sec>
      <title>3.2 Preprocessing of SIRV and Drosophila reads</title>
      <p>The SIRV and Drosophila datasets consist of roughly 1.6M and 3.4M, full length reads (<xref rid="btad264-T1" ref-type="table">Table 1</xref> in <xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>) with a median error rate of roughly 6.9% and 7%, respectively (<xref rid="btad264-T2" ref-type="table">Table 2</xref> in <xref rid="btad264-B30" ref-type="bibr">Sahlin and Medvedev 2021</xref>). Full-length reads amongst all reads sequenced with ONT are processed using pychopper (<ext-link xlink:href="https://github.com/nanoporetech/pychopper" ext-link-type="uri">https://github.com/nanoporetech/pychopper</ext-link>, commit 6dca13d). In the SIRV dataset, five of the 68 transcripts are perfect substrings of other isoforms. As they confound the alignments of the reads and downstream FP and TP evaluations, we filtered those transcripts out before performing the analysis with subsampled SIRV data.</p>
    </sec>
    <sec>
      <title>3.3 Spike-in (SIRV) analysis</title>
      <sec>
        <title>3.3.1 Controlled SIRV simulations</title>
        <p>For the SIRV data, we performed a similar analysis as described for the simulated data by simulating various abundances of reads from a fixed number of isoforms. We obtained the read abundances and isoforms as follows. We aligned all SIRV reads to the 63 distinct SIRV transcripts using minimap2. Each read has a primary alignment to a reference isoform. We subsample reads from a fixed number of isoforms from the resulting SAM file of alignments, with an abundance of either 8, 16, 32, or 64 reads. Similarly to the simulated data, we ran the isON pipeline and the RATTLE pipeline and computed precision and recall values as well as percent identity of the predictions with respect to the original transcripts. The results are displayed in <xref rid="btad264-F4" ref-type="fig">Fig. 4</xref>. As for the simulated data, isONform has substantially higher recall over RATTLE with a small cost of slightly reduced precision. The RATTLE pipeline misses nearly half of the predictions at higher isoform numbers, while recall stays close to perfect for isONform. IsONform’s predictions also have a higher percent identity (<xref rid="btad264-F4" ref-type="fig">Fig. 4</xref>), and 97% of the predictions are complete reconstructions, while only 92% of RATTLE’s predictions are complete.</p>
        <fig position="float" id="btad264-F4">
          <label>Figure 4.</label>
          <caption>
            <p>Performance of isONform versus RATTLE on SIRV reads. The data were collected by running each algorithm on 10 different instances for each number of isoforms. Left and center panels show precision and recall, respectively, of isONform’s and RATTLE’s predictions. The right panel shows percent identity of the predictions.</p>
          </caption>
          <graphic xlink:href="btad264f4" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.3.2 Precision–recall trade-off</title>
        <p>We also investigated how precision and recall of RATTLE and isONform varied on our SIM and controlled SIRV datasets (experiment details in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>). Similar to previous experiments we observe that isONform has a substantially higher recall than RATTLE on both SIRV (<xref rid="btad264-F5" ref-type="fig">Fig. 5</xref>) and SIM (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref>), while generating slightly more redundant predictions when minimal abundance is low. RATTLE has fairly stable precision and recall estimates across different abundances, indicating that it over-clusters the reads into transcript predictions. Based on the abundances from these experiments, a cutoff of 5 seems to be a good compromise between precision and recall in isONform.</p>
        <fig position="float" id="btad264-F5">
          <label>Figure 5.</label>
          <caption>
            <p>Precision and recall of isONform and RATTLE for reconstruction of 50 SIRV isoforms at variable abundances when filtering output by minimal read support (<italic toggle="yes">x</italic>-axis) of predicted isoforms.</p>
          </caption>
          <graphic xlink:href="btad264f5" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.3.3 Abundance estimates on the SIRV dataset</title>
        <p>We ran the isON and RATTLE pipelines on a subset of 100 000 SIRV reads to explore what happens with reference-free transcript predictions and their read support (abundance) at high coverages. We aligned the reads and the predicted transcripts from each pipeline against the SIRV transcriptome with minimap2. Each predicted transcript has a read coverage associated with it. If several predicted isoforms were appointed to the same original isoform, we added up their support to the given reference isoform. We then plotted the sum of reads supporting each reference transcript. We observed that isONform’s abundance estimates closely resembled the original read abundances (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref>), in contrast to RATTLE’s abundances. RATTLE only reconstructed 19 of the original transcripts in the data, while isONform reconstructed 62 out of 63 transcripts. As for precision, isONform generated a total of 374 isoform predictions (using 5 as minimal read support cutoff), suggesting a substantial redundancy in its predictions to ground truth. RATTLE generated 20 predictions. Nevertheless, with the highly variable abundance between transcripts, it is notable that isONform only missed one of the 63 transcripts while reducing read redundancy by over 200 times. Several isoforms were missing from RATTLE’s predictions (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref>) and since some isoforms have higher abundance than the original reads, we suppose RATTLE appoints reads from several isoforms into a single prediction. As for complete reconstructions, 97% and 89% of isONform’s and RATTLE’s predictions were classified as complete, respectively.</p>
      </sec>
    </sec>
    <sec>
      <title>3.4 Drosophila analysis</title>
      <p>We compared transcript predictions of the annotation-based tool StringTie2 with predictions from the isON and RATTLE pipelines. Since the data lack ground truth, we evaluate consistency between the tools. We aligned the transcript predictions to the Drosophila genome using uLTRA (<xref rid="btad264-B31" ref-type="bibr">Sahlin and Mäkinen 2021</xref>) and classified the predictions with the terminology described in (<xref rid="btad264-B34" ref-type="bibr">Tardaguila et al. 2018</xref>). Specifically, a prediction can be a Full Splice Match (FSM; matching a reference annotation at all splice sites), an Incomplete Splice Match (ISM; matching a reference annotation but missing at least one splice site in beginning or end), a Novel In Catalogue (NIC; all splice sites exists but as a novel combination), and a Novel Not in Catalogue (NNC; at least one splice site is not found in annotation).</p>
      <p>Overall, isONform’s predictions contained 2060 more unique FSMs than RATTLE’s (<xref rid="btad264-T1" ref-type="table">Table 1</xref>). In addition, isONform’s FSM and NIC predictions were broadly consistent with StringTie2’s predictions (<xref rid="btad264-F6" ref-type="fig">Fig. 6</xref>). For example, 2356 FSM predictions were produced by isONform and StringTie2, but not by RATTLE, while only 586 predictions were made by StringTie2 and RATTLE but not by isONform. Notably, a smaller set of FSM predictions (356) was predicted by both isONform and RATTLE that was not predicted by StringTie2. For the NIC, 50 predictions were produced by isONform and StringTie2, but not by RATTLE. Only three predictions were made by StringTie2 and RATTLE but not by isONform.</p>
      <fig position="float" id="btad264-F6">
        <label>Figure 6.</label>
        <caption>
          <p>Overlaps of predicted FSMs and NICs for isONform, RATTLE, and StringTie2 on the Drosophila dataset.</p>
        </caption>
        <graphic xlink:href="btad264f6" position="float"/>
      </fig>
      <table-wrap position="float" id="btad264-T1">
        <label>Table 1.</label>
        <caption>
          <p>Statistics of isON, RATTLE, and StringTie2 pipelines on the Drosophila dataset.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">StringTie2</th>
              <th rowspan="1" colspan="1">RATTLE</th>
              <th rowspan="1" colspan="1">isONform</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Total predictions</td>
              <td rowspan="1" colspan="1">15 589</td>
              <td rowspan="1" colspan="1">11 773</td>
              <td rowspan="1" colspan="1">27 134</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Median % identity</td>
              <td rowspan="1" colspan="1">100.0</td>
              <td rowspan="1" colspan="1">97.7</td>
              <td rowspan="1" colspan="1">98.3</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">FSM</td>
              <td rowspan="1" colspan="1">9009</td>
              <td rowspan="1" colspan="1">6082</td>
              <td rowspan="1" colspan="1">12 347</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Unique FSMs</td>
              <td rowspan="1" colspan="1">8951</td>
              <td rowspan="1" colspan="1">6077</td>
              <td rowspan="1" colspan="1">8137</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">NIC</td>
              <td rowspan="1" colspan="1">145</td>
              <td rowspan="1" colspan="1">97</td>
              <td rowspan="1" colspan="1">174</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Unique NICs</td>
              <td rowspan="1" colspan="1">144</td>
              <td rowspan="1" colspan="1">97</td>
              <td rowspan="1" colspan="1">174</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ISM</td>
              <td rowspan="1" colspan="1">2141</td>
              <td rowspan="1" colspan="1">961</td>
              <td rowspan="1" colspan="1">2663</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">NNC</td>
              <td rowspan="1" colspan="1">1363</td>
              <td rowspan="1" colspan="1">1962</td>
              <td rowspan="1" colspan="1">2381</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Transcripts no splice sites</td>
              <td rowspan="1" colspan="1">2931</td>
              <td rowspan="1" colspan="1">2671</td>
              <td rowspan="1" colspan="1">9569</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p>We measure the number of overall predictions and their percent identity. StringTie2 has a perfect identity as it extracts transcripts using the reference genome, which could miss any biological SNV or indel variation. We also classify each prediction according to FSM, NIC, ISM, NNC, and transcripts without splice sites. We measure both total and unique number of FSM and NIC. Unique FSM and NIC are counted by merging predictions with identical splice site coordinates. In addition, the number of overall predictions for each tool as well as the number of full splice matches that were detected.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap position="float" id="btad264-T2">
        <label>Table 2.</label>
        <caption>
          <p>Wall clock time and RAM usage analysis for the Drosophila dataset for each pipeline and tool.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Pipeline</th>
              <th align="center" rowspan="1" colspan="1">Tool</th>
              <th align="center" rowspan="1" colspan="1">Peak memory</th>
              <th align="center" rowspan="1" colspan="1">Runtime</th>
              <th align="center" rowspan="1" colspan="1">Total runtime</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">StringTie2</td>
              <td rowspan="1" colspan="1">preprocess</td>
              <td rowspan="1" colspan="1">11.1 Gb</td>
              <td rowspan="1" colspan="1">5 min</td>
              <td rowspan="1" colspan="1">&lt; 6 min</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">run_StringTie2</td>
              <td rowspan="1" colspan="1">0.2 Gb</td>
              <td rowspan="1" colspan="1">&lt; 1 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">postprocess</td>
              <td rowspan="1" colspan="1">0.1 Gb</td>
              <td rowspan="1" colspan="1">&lt; 1 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RATTLE</td>
              <td rowspan="1" colspan="1">rattle cluster</td>
              <td rowspan="1" colspan="1">44.4 Gb</td>
              <td rowspan="1" colspan="1">3 h 53 min</td>
              <td rowspan="1" colspan="1">6 h 17 min</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">rattle correct</td>
              <td rowspan="1" colspan="1">21.3 Gb</td>
              <td rowspan="1" colspan="1">2 h 12 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">rattle polish</td>
              <td rowspan="1" colspan="1">0.9 Gb</td>
              <td rowspan="1" colspan="1">12 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">isON</td>
              <td rowspan="1" colspan="1">isONclust</td>
              <td rowspan="1" colspan="1">23.5 Gb</td>
              <td rowspan="1" colspan="1">1 h 10 min</td>
              <td rowspan="1" colspan="1">23 h 36 min</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">isONclust write</td>
              <td rowspan="1" colspan="1">6.7 Gb</td>
              <td rowspan="1" colspan="1">1 h 23 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">isONcorrect</td>
              <td rowspan="1" colspan="1">2.0 Gb</td>
              <td rowspan="1" colspan="1">4 h 56 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">isONform</td>
              <td rowspan="1" colspan="1">1.5 Gb</td>
              <td rowspan="1" colspan="1">16 h 10 min</td>
              <td rowspan="1" colspan="1"/>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p>Total runtime indicates the overall runtime of the respective pipeline. StringTie2 preprocessing consists of aligning the reads to the annotation via Minimap2 and using samtools to index the alignment file. The StringTie2 postprocessing consists of calling gffread to generate a fasta file with predictions.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>However, isONform, also predicted many more isoforms (27 134) than StringTie2 (15 589) and RATTLE (11 773), with a large increase in the predictions of FSM, ISM, and predictions with no splice sites. Nevertheless, due to the high sensitivity of isONform and the orthogonal approach compared with a reference-based method, isONform could be used in combination with a reference-based approach even for well-annotated genomes. We believe this could be beneficial since LRGASP (<xref rid="btad264-B23" ref-type="bibr">Pardo-Palacios et al. 2021</xref>) found that reference-based methods seem to over-fit predictions to the annotation (<xref rid="btad264-B19" ref-type="bibr">LRGASP 2022</xref>) and, in general, produce discordant predictions (<xref rid="btad264-B19" ref-type="bibr">LRGASP 2022</xref>).</p>
    </sec>
    <sec>
      <title>3.5 Runtime analysis and memory usage assessment</title>
      <p>We computed runtime and peak memory usage for StringTie2, and the RATTLE and isON pipelines on the Drosophila dataset.</p>
      <p>All tools were run on a CentOS 7, with two 10-core Intel Xeon V4 CPUs each. The reference-based tool StringTie2 is very fast. The reference-free tools RATTLE and isONform are significantly slower, taking approximately 6 and 32 h. The runtime bottleneck in the isON pipeline is isONform. As for memory, the isON pipeline uses 23.5 Gb (peak during running isONclust), while RATTLE uses 44.4 Gb (peak during RATTLE cluster). We note that all the tools in the isON pipeline are implemented in python, while RATTLE is implemented in C++. We believe the isON pipeline could be significantly sped up and have its memory footprint lowered when implemented in a compiled language. We profiled the python implementation of isONform on various read cluster sizes. We found that about 70% of isONform’s runtime is spent in step 1 (constructing the minimizer pairs and their support for each read), which has time complexity <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if <italic toggle="yes">n</italic> denotes the number of reads in the batch and <italic toggle="yes">m</italic> denotes the maximum number of minimizer pairs observed within the <italic toggle="yes">n</italic> reads. While this construction step is shared with isONcorrect, isONcorrect does not compute it for each read, but stores previously corrected intervals to practically remove the cubic complexity. Such optimization may be possible also in isONform. This step is also suitable for compiled programs as it would involve only raw iteration and adding structs to a vector. About 20% of isONform’s runtime is consumed by step 4 (iterative bubble popping). The remaining 10% is evenly distributed over steps 3, 5, and 6.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>We presented a novel computational tool, isONform, capable of generating isoform predictions without a reference genome or annotation from long-read sequencing data. For simulated and SIRV data, isONform reconstructed substantially more isoforms than RATTLE at the cost of reduced precision. On our Drosophila dataset, isONform produced more consistent predictions with StringTie2 compared to RATTLE. We see at least two valuable use cases for isONform. First, it can produce an approximate reference transcriptome for organisms without high-quality assemblies or well-annotated genomes. Second, it can serve as a complementary prediction method to a reference-based method due to its orthogonal approach neither relying on a reference genome, transcript annotation, nor read alignments. Such orthogonal approaches may be valuable, as the community benchmarking project LRGASP (<xref rid="btad264-B23" ref-type="bibr">Pardo-Palacios et al. 2021</xref>) found that reference-based methods seem to over-fit predictions to reference annotations (<xref rid="btad264-B19" ref-type="bibr">LRGASP 2022</xref>) while noting considerable disagreement among methods (<xref rid="btad264-B19" ref-type="bibr">LRGASP 2022</xref>).</p>
    <sec>
      <title>4.1 Future work</title>
      <p>Currently isONform has a high runtime, which may be alleviated by implementing the algorithm in a compiled programming language. Particularly since 70% of isONform’s runtime is due to step 1 (constructing all minimizer pairs) which is suitable for compiled languages. Another possible improvement to isONform could be to use alternative seeding constructs to minimizer pairs. For example, using syncmers (<xref rid="btad264-B8" ref-type="bibr">Edgar 2021</xref>) instead of minimizers in isONcorrect produced solutions of NOMPs with higher WIS score (<xref rid="btad264-B17" ref-type="bibr">Lindbom Gunnari 2021</xref>). In addition, instead of using minimizer or syncmer-pairs as described here, linking syncmers using the strobemer method (<xref rid="btad264-B27" ref-type="bibr">Sahlin 2021</xref>), has demonstrated to be efficient for read mapping (<xref rid="btad264-B28" ref-type="bibr">Sahlin 2022</xref>) and could be an alternative to minimizer pairs that requires fewer seeds and, hence, improves runtime. At the preprocessing level to isONform, we found that some of isONform’s redundant predictions stem from residing in separate clusters in isONclust, which could be improved within the isONclust algorithm. Finally, isONform currently produces isoforms differing on exon-level. In the future, we hope to produce transcripts with different SNP stucture, which can be done by aligning the original reads to the transcript predictions and calling variants.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Conclusion</title>
    <p>We presented an algorithm and its implementation, isONform, capable of constructing polished isoforms from long-read ONT cDNA sequencing data without relying on a reference. Using simulated and synthetic data, we demonstrated that isONform produces accurate transcript predictions and has substantially higher recall than other reference-free algorithms, such as RATTLE. We also used biological data to show that isONform has a higher consistency with the reference-based approach StringTie2 compared to RATTLE. IsONform may be used for organisms where a high-quality genome is unavailable or when studying transcripts from genes or gene families that are not well represented in the genome.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad264_Supplementary_Data</label>
      <media xlink:href="btad264_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>Parts of the evaluation were enabled by resources in project snic2022-5-592 provided by the Swedish National Infrastructure for Computing (SNIC) at UPPMAX, partially funded by the Swedish Research Council through grant agreement no. 2018-05973.</p>
  </ack>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> is available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>K.S. was supported by the Swedish Research Council (SRC, Vetenskapsrådet) under Grant No. 2021-04000.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad264-B1">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Bayega</surname><given-names>A</given-names></string-name>, <string-name><surname>Wang</surname><given-names>YC</given-names></string-name>, <string-name><surname>Oikonomopoulos.</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><part-title>Transcript Profiling Using Long-Read Sequencing Technologies</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Raghavachari</surname><given-names>N</given-names></string-name>, <string-name><surname>Garcia-Reyero</surname><given-names>N</given-names></string-name></person-group>. (eds) Gene Expression Analysis. Methods in Molecular Biology, <year>2018</year>, vol <volume>1783</volume>. <publisher-name>Humana Press</publisher-name>, <publisher-loc>New York, NY</publisher-loc><year>2018</year>.</mixed-citation>
    </ref>
    <ref id="btad264-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Byrne</surname><given-names>A</given-names></string-name>, <string-name><surname>Cole</surname><given-names>C</given-names></string-name>, <string-name><surname>Volden</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Realizing the potential of full-length transcriptome sequencing</article-title>. <source>Philos Trans R Soc Lond B Biol Sci</source><year>2019</year>;<volume>374</volume>:<fpage>20190097</fpage>.<pub-id pub-id-type="pmid">31587638</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B3">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>Y</given-names></string-name>, <string-name><surname>Sim</surname><given-names>A</given-names></string-name>, <string-name><surname>Wan</surname><given-names>YK</given-names></string-name></person-group><etal>et al</etal> Context-aware transcript quantification from long read rna-seq data with bambu. <italic toggle="yes">bioRxiv</italic><year>2022</year>. <pub-id pub-id-type="doi">10.1101/2022.11.14.516358</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad264-B4">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Chin</surname><given-names>C-S</given-names></string-name>, <string-name><surname>Khalak</surname><given-names>A.</given-names></string-name></person-group> Human genome assembly in 100 minutes. <italic toggle="yes">bioRxiv</italic><year>2019</year>. <pub-id pub-id-type="doi">10.1101/705616</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad264-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cole</surname><given-names>C</given-names></string-name>, <string-name><surname>Byrne</surname><given-names>A</given-names></string-name>, <string-name><surname>Adams</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Complete characterization of the human immune cell transcriptome using accurate full-length cdna sequencing</article-title>. <source>Genome Res</source><year>2020</year>;<volume>30</volume>:<fpage>589</fpage>–<lpage>601</lpage>.<pub-id pub-id-type="pmid">32312742</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Daily</surname><given-names>J.</given-names></string-name></person-group><article-title>Parasail: Simd c library for global, semi-global, and local pairwise sequence alignments</article-title>. <source>BMC Bioinf</source><year>2016</year>;<volume>17</volume>:<fpage>1</fpage>–<lpage>11</lpage>.</mixed-citation>
    </ref>
    <ref id="btad264-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>de la Rubia</surname><given-names>I</given-names></string-name>, <string-name><surname>Srivastava</surname><given-names>A</given-names></string-name>, <string-name><surname>Xue</surname><given-names>W</given-names></string-name></person-group><etal>et al</etal><article-title>Rattle: reference-free reconstruction and quantification of transcriptomes from nanopore sequencing</article-title>. <source>Genome Biol</source><year>2022</year>;<volume>23</volume>:<fpage>1</fpage>–<lpage>21</lpage>.<pub-id pub-id-type="pmid">34980209</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Edgar</surname><given-names>R.</given-names></string-name></person-group><article-title>Syncmers are more sensitive than minimizers for selecting conserved k-mers in biological sequences</article-title>. <source>PeerJ</source><year>2021</year>;<volume>9</volume>:<fpage>e10805</fpage>.<pub-id pub-id-type="pmid">33604186</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ekim</surname><given-names>B</given-names></string-name>, <string-name><surname>Berger</surname><given-names>B</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R.</given-names></string-name></person-group><article-title>Minimizer-space de bruijn graphs: whole-genome assembly of long reads in minutes on a personal computer</article-title>. <source>Cell Syst</source><year>2021</year>;<volume>12</volume>:<fpage>958</fpage>–<lpage>68.e6</lpage>.<pub-id pub-id-type="pmid">34525345</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gordon</surname><given-names>SP</given-names></string-name>, <string-name><surname>Tseng</surname><given-names>E</given-names></string-name>, <string-name><surname>Salamov</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Widespread polycistronic transcripts in fungi revealed by single-molecule mrna sequencing</article-title>. <source>PLoS ONE</source><year>2015</year>;<volume>10</volume>:<fpage>e0132628</fpage>.<pub-id pub-id-type="pmid">26177194</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hoang</surname><given-names>NV</given-names></string-name>, <string-name><surname>Furtado</surname><given-names>A</given-names></string-name>, <string-name><surname>Mason</surname><given-names>PJ</given-names></string-name></person-group><etal>et al</etal><article-title>A survey of the complex transcriptome from the highly polyploid sugarcane genome using full-length isoform sequencing and de novo assembly from short read sequencing</article-title>. <source>BMC Genom</source><year>2017</year>;<volume>18</volume>:<fpage>395</fpage>.</mixed-citation>
    </ref>
    <ref id="btad264-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Holmqvist</surname><given-names>I</given-names></string-name>, <string-name><surname>Bäckerholm</surname><given-names>A</given-names></string-name>, <string-name><surname>Tian</surname><given-names>Y</given-names></string-name></person-group><etal>et al</etal><article-title>Flame: long-read bioinformatics tool for comprehensive spliceome characterization</article-title>. <source>RNA</source><year>2021</year>;<volume>27</volume>:<fpage>1127</fpage>–<lpage>39</lpage>.<pub-id pub-id-type="pmid">34253685</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B13">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Kleinberg</surname><given-names>J</given-names></string-name>, <string-name><surname>Tardos</surname><given-names>E.</given-names></string-name></person-group><source>Algorithm Design</source>. <publisher-loc>Boston</publisher-loc>: <publisher-name>Pearson Education India</publisher-name>, <year>2006</year>.</mixed-citation>
    </ref>
    <ref id="btad264-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kovaka</surname><given-names>S</given-names></string-name>, <string-name><surname>Zimin</surname><given-names>AV</given-names></string-name>, <string-name><surname>Pertea</surname><given-names>GM</given-names></string-name></person-group><etal>et al</etal><article-title>Transcriptome assembly from long-read rna-seq alignments with stringtie2</article-title>. <source>Genome Biol</source><year>2019</year>;<volume>20</volume>:<fpage>278</fpage>.<pub-id pub-id-type="pmid">31842956</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kuo</surname><given-names>RI</given-names></string-name>, <string-name><surname>Cheng</surname><given-names>Y</given-names></string-name>, <string-name><surname>Zhang</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Illuminating the dark side of the human transcriptome with long read transcript sequencing</article-title>. <source>BMC Genom</source><year>2020</year>;<volume>21</volume>:<fpage>751</fpage>.</mixed-citation>
    </ref>
    <ref id="btad264-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>3094</fpage>–<lpage>100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B17">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Lindbom Gunnari</surname><given-names>S.</given-names></string-name></person-group> Improving indexing for computational error-correction of RNA sequences with syncmers. Bachelor’s Thesis, Stockholm University, Sweden, <year>2021</year>.</mixed-citation>
    </ref>
    <ref id="btad264-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>B</given-names></string-name>, <string-name><surname>Liu</surname><given-names>Y</given-names></string-name>, <string-name><surname>Li</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>deSALT: fast and accurate long transcriptomic read alignment with de bruijn graph-based index</article-title>. <source>Genome Biol</source><year>2019</year>;<volume>20</volume>:<fpage>274</fpage>.<pub-id pub-id-type="pmid">31842925</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B19">
      <mixed-citation publication-type="other"><collab>LRGASP</collab><year>2022</year>. Challenge 1 preliminary results. <ext-link xlink:href="https://www.gencodegenes.org/pages/LRGASP/" ext-link-type="uri">https://www.gencodegenes.org/pages/LRGASP/</ext-link>.</mixed-citation>
    </ref>
    <ref id="btad264-B20">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Nip</surname><given-names>KM</given-names></string-name>, <string-name><surname>Hafezqorani</surname><given-names>S</given-names></string-name>, <string-name><surname>Gagalova</surname><given-names>KK</given-names></string-name></person-group><etal>et al</etal> Reference-free assembly of long-read transcriptome sequencing data with rna-bloom2. <italic toggle="yes">bioRxiv</italic> 2022. <pub-id pub-id-type="doi">10.1101/2022.08.07.503110</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad264-B21">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Onodera</surname><given-names>T</given-names></string-name>, <string-name><surname>Sadakane</surname><given-names>K</given-names></string-name>, <string-name><surname>Shibuya</surname><given-names>T.</given-names></string-name></person-group><part-title>Detecting superbubbles in assembly graphs</part-title>. In: <source>International Workshop on Algorithms in Bioinformatics</source>. <publisher-name>Springer</publisher-name>, <year>2013</year>, <fpage>338</fpage>–<lpage>348</lpage>.</mixed-citation>
    </ref>
    <ref id="btad264-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Orabi</surname><given-names>B</given-names></string-name>, <string-name><surname>Xie</surname><given-names>N</given-names></string-name>, <string-name><surname>McConeghy</surname><given-names>B</given-names></string-name></person-group><etal>et al</etal><article-title>Freddie: annotation-independent detection and discovery of transcriptomic alternative splicing isoforms using long-read sequencing</article-title>. <source>Nucl Acids Res</source><year>2022</year>;51(2):e11.</mixed-citation>
    </ref>
    <ref id="btad264-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pardo-Palacios</surname><given-names>F</given-names></string-name>, <string-name><surname>Reese</surname><given-names>F</given-names></string-name>, <string-name><surname>Carbonell-Sala</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Systematic assessment of long-read rna-seq methods for transcript identification and quantification</article-title>. <source>Res Square</source><year>2021</year>.</mixed-citation>
    </ref>
    <ref id="btad264-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Prjibelski</surname><given-names>AD</given-names></string-name>, <string-name><surname>Mikheenko</surname><given-names>A</given-names></string-name>, <string-name><surname>Joglekar</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Accurate isoform discovery with isoquant using long reads</article-title>. <source>Nat Biotechnol</source><year>2023</year>.</mixed-citation>
    </ref>
    <ref id="btad264-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rautiainen</surname><given-names>M</given-names></string-name>, <string-name><surname>Marschall</surname><given-names>T.</given-names></string-name></person-group><article-title>MBG: minimizer-based sparse de Bruijn graph construction</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>2476</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">33475133</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hayes</surname><given-names>W</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name></person-group><etal>et al</etal><article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source><year>2004</year>;<volume>20</volume>:<fpage>3363</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Effective sequence similarity detection with strobemers</article-title>. <source>Genome Res</source><year>2021</year>;<volume>31</volume>:<fpage>2080</fpage>–<lpage>94</lpage>. 34667119[pmid].<pub-id pub-id-type="pmid">34667119</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Strobealign: flexible seed size enables ultra-fast and accurate read alignment</article-title>. <source>Genome Biol</source><year>2022</year>;<volume>23</volume>:<fpage>260</fpage>.<pub-id pub-id-type="pmid">36522758</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>De novo clustering of long-read transcriptome data using a greedy, quality value-based algorithm</article-title>. <source>J Comput Biol</source><year>2020</year>;<volume>27</volume>:<fpage>472</fpage>–<lpage>84</lpage>.<pub-id pub-id-type="pmid">32181688</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>Error correction enables use of oxford nanopore technology for reference-free transcriptome analysis</article-title>. <source>Nat Commun</source><year>2021</year>;<volume>12</volume>:<fpage>1</fpage>–<lpage>13</lpage>.<pub-id pub-id-type="pmid">33397941</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K</given-names></string-name>, <string-name><surname>Mäkinen</surname><given-names>V.</given-names></string-name></person-group><article-title>Accurate spliced alignment of long RNA sequencing reads</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>4643</fpage>–<lpage>51</lpage>.<pub-id pub-id-type="pmid">34302453</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K</given-names></string-name>, <string-name><surname>Tomaszkiewicz</surname><given-names>M</given-names></string-name>, <string-name><surname>Makova</surname><given-names>KD</given-names></string-name></person-group><etal>et al</etal><article-title>Deciphering highly similar multigene family transcripts from iso-seq data with isocon</article-title>. <source>Nat Commun</source><year>2018</year>;<volume>9</volume>:<fpage>4601</fpage>.<pub-id pub-id-type="pmid">30389934</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tang</surname><given-names>AD</given-names></string-name>, <string-name><surname>Soulette</surname><given-names>CM</given-names></string-name>, <string-name><surname>van Baren</surname><given-names>MJ</given-names></string-name></person-group><etal>et al</etal><article-title>Full-length transcript characterization of sf3b1 mutation in chronic lymphocytic leukemia reveals downregulation of retained introns</article-title>. <source>Nat Commun</source><year>2020</year>;<volume>11</volume>:<fpage>1</fpage>–<lpage>12</lpage>.<pub-id pub-id-type="pmid">31911652</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tardaguila</surname><given-names>M</given-names></string-name>, <string-name><surname>De La Fuente</surname><given-names>L</given-names></string-name>, <string-name><surname>Marti</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>Sqanti: extensive characterization of long-read transcript sequences for quality control in full-length transcriptome identification and quantification</article-title>. <source>Genome Res</source><year>2018</year>;<volume>28</volume>:<fpage>396</fpage>–<lpage>411</lpage>.<pub-id pub-id-type="pmid">29440222</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tung</surname><given-names>LH</given-names></string-name>, <string-name><surname>Shao</surname><given-names>M</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>Quantifying the benefit offered by transcript assembly with scallop-lr on single-molecule long reads</article-title>. <source>Genome Biol</source><year>2019</year>;<volume>20</volume>:<fpage>1</fpage>–<lpage>18</lpage>.<pub-id pub-id-type="pmid">30606230</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vaser</surname><given-names>R</given-names></string-name>, <string-name><surname>Sović</surname><given-names>I</given-names></string-name>, <string-name><surname>Nagarajan</surname><given-names>N</given-names></string-name></person-group><etal>et al</etal><article-title>Fast and accurate de novo genome assembly from long uncorrected reads</article-title>. <source>Genome Res</source><year>2017</year>;<volume>27</volume>:<fpage>737</fpage>–<lpage>46</lpage>.<pub-id pub-id-type="pmid">28100585</pub-id></mixed-citation>
    </ref>
    <ref id="btad264-B37">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Volden</surname><given-names>R</given-names></string-name>, <string-name><surname>Schimke</surname><given-names>K</given-names></string-name>, <string-name><surname>Byrne</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal> Identifying and quantifying isoforms from accurate full-length transcriptome sequencing reads with mandalorion. <italic toggle="yes">bioRxiv</italic><year>2022</year>. <pub-id pub-id-type="doi">10.1101/2022.06.29.498139</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad264-B38">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Wyman</surname><given-names>D</given-names></string-name>, <string-name><surname>Balderrama-Gutierrez</surname><given-names>G</given-names></string-name>, <string-name><surname>Reese</surname><given-names>F</given-names></string-name></person-group><etal>et al</etal> A technology-agnostic long-read analysis pipeline for transcriptome discovery and quantification. <italic toggle="yes">bioRxiv</italic><year>2020</year>. <pub-id pub-id-type="doi">10.1101/672931</pub-id>.</mixed-citation>
    </ref>
    <ref id="btad264-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zerbino</surname><given-names>DR</given-names></string-name>, <string-name><surname>Birney</surname><given-names>E.</given-names></string-name></person-group><article-title>Velvet: algorithms for de novo short read assembly using de bruijn graphs</article-title>. <source>Genome Res</source><year>2008</year>;<volume>18</volume>:<fpage>821</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">18349386</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
