<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4058916</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btu294</article-id>
    <article-id pub-id-type="publisher-id">btu294</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb 2014 Proceedings Papers Committee</subject>
        <subj-group subj-group-type="heading">
          <subject>Original Papers</subject>
          <subj-group subj-group-type="heading">
            <subject>Population Genomics</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Privacy preserving protocol for detecting genetic relatives using rare variants</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Hormozdiari</surname>
          <given-names>Farhad</given-names>
        </name>
        <xref ref-type="aff" rid="btu294-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="btu294-COR1">*</xref>
        <xref ref-type="author-notes" rid="btu294-FN1">
          <sup>†</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Joo</surname>
          <given-names>Jong Wha J</given-names>
        </name>
        <xref ref-type="aff" rid="btu294-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="author-notes" rid="btu294-FN1">
          <sup>†</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wadia</surname>
          <given-names>Akshay</given-names>
        </name>
        <xref ref-type="aff" rid="btu294-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Guan</surname>
          <given-names>Feng</given-names>
        </name>
        <xref ref-type="aff" rid="btu294-AFF1">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ostrosky</surname>
          <given-names>Rafail</given-names>
        </name>
        <xref ref-type="aff" rid="btu294-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Sahai</surname>
          <given-names>Amit</given-names>
        </name>
        <xref ref-type="aff" rid="btu294-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Eskin</surname>
          <given-names>Eleazar</given-names>
        </name>
        <xref ref-type="aff" rid="btu294-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btu294-AFF1">
          <sup>4</sup>
        </xref>
        <xref ref-type="corresp" rid="btu294-COR1">*</xref>
      </contrib>
    </contrib-group>
    <aff id="btu294-AFF1"><sup>1</sup>Department of Computer Science, <sup>2</sup>Bioinformatics IDP, <sup>3</sup>Department of Mathematics and <sup>4</sup>Department of Human Genetics, University of California, LA 90095, USA</aff>
    <author-notes>
      <corresp id="btu294-COR1">*To whom correspondence should be addressed.</corresp>
      <fn id="btu294-FN1">
        <p><sup>†</sup>The authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint First Authors.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>11</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>11</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>30</volume>
    <issue>12</issue>
    <fpage>i204</fpage>
    <lpage>i211</lpage>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/3.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> High-throughput sequencing technologies have impacted many areas of genetic research. One such area is the identification of relatives from genetic data. The standard approach for the identification of genetic relatives collects the genomic data of all individuals and stores it in a database. Then, each pair of individuals is compared to detect the set of genetic relatives, and the matched individuals are informed. The main drawback of this approach is the requirement of sharing your genetic data with a trusted third party to perform the relatedness test.</p>
      <p><bold>Results:</bold> In this work, we propose a secure protocol to detect the genetic relatives from sequencing data while not exposing any information about their genomes. We assume that individuals have access to their genome sequences but do not want to share their genomes with anyone else. Unlike previous approaches, our approach uses both common and rare variants which provide the ability to detect much more distant relationships securely. We use a simulated data generated from the 1000 genomes data and illustrate that we can easily detect up to fifth degree cousins which was not possible using the existing methods. We also show in the 1000 genomes data with cryptic relationships that our method can detect these individuals.</p>
      <p><bold>Availability:</bold> The software is freely available for download at <ext-link ext-link-type="uri" xlink:href="http://genetics.cs.ucla.edu/crypto/">http://genetics.cs.ucla.edu/crypto/</ext-link>.</p>
      <p><bold>Contact:</bold><email>fhormoz@cs.ucla.edu</email> or <email>eeskin@cs.ucla.edu</email></p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu294/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online</p>
    </abstract>
    <counts>
      <page-count count="1"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 INTRODUCTION</title>
    <p>Detecting relatives from genetic data is one of the fundamental problems in genetics. As genotype-chip technologies reduce the cost of collecting genetic data for each individual, many personal genomic companies provide various services. One such service is the identification of relatives using genetic data. The underling idea of this service is to collect genotypes of different individuals and to store their data in a database. Then, the genotype for each pair of individuals is compared and any pair of individuals that appear to be genetically related are notified of a match.</p>
    <p>Unfortunately, the current version of this service provided by all companies requires individuals to share their genetic data with a trusted company.</p>
    <p><xref rid="btu294-B8" ref-type="bibr">Homer <italic>et al.</italic> (2008)</xref> already raised many privacy issues by showing that we can detect the existence of an individual in a pool of individuals when the minor allele frequency is available. Thus, the disease status of any individual involved in a GWAS might be exposed to the public. Furthermore, <xref rid="btu294-B13" ref-type="bibr">Sankararaman <italic>et al.</italic> (2009)</xref> extended the work (<xref rid="btu294-B8" ref-type="bibr">Homer <italic>et al.</italic>, 2008</xref>) and showed that with access to thousands of variant summary statistics is enough for detecting the existence of an individual in a pool.</p>
    <p>Recently, <xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic> (2013)</xref> have proposed a secure method for detecting the genetic relatives using genotype data. This method uses the ‘fuzzy’ encryption (<xref rid="btu294-B5" ref-type="bibr">Dodis <italic>et al.</italic>, 2008</xref>; <xref rid="btu294-B9" ref-type="bibr">Ishai <italic>et al.</italic>, 2011</xref>). The ‘fuzzy’ encryption is very similar to the traditional encryption and decryption protocols where each individual has a public key and a private key. Public key for each individual is accessible by all the other individuals and the private key for each individual is hidden from all the other individuals. In the traditional protocol, we use the same private key to decrypt the message that was used to encrypt the message in the first place. However, in the ‘fuzzy’ encryption the two keys should be only close but not necessarily the same. Thus, an individual can detect the genetic relatives by downloading the available public key for all other individuals and compare their public key with his private key. They show if two individuals are genetically related their secure method can detect them while not leaking any information. Moreover, this method is designed such that individuals who are not related to others will not obtain any information. A drawback of this approach is that it can only be applied to common variants.</p>
    <p>We propose a novel encoding mechanism that convert each individual’s haplotypes to a set of integer values such that the comparison between two sets approximate the genetic comparison between the two individuals where each individual has access only to its own variants list. The main innovations of our approach compared to <xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic> (2013)</xref> is that we use a novel encoding which allows for us to utilize all variants in an individual’s genome. This is challenging because many of the variants have not yet been discovered. In addition, our cryptographic scheme uses list decoding which has some advantages to other approaches for fuzzy encryption.</p>
    <p>We use both simulated and real data to show the utility of our method. We generated series of family relationships using the 1000 genomes data as the founder of the population. Then, we randomly generated offsprings for different generations. With the simulated data, we show that our secure protocol could detect up to fifth degree cousins. However, the previous method (<xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic>, 2013</xref>) can only detect up to third degree cousins. Furthermore, we use Luhya in Webuye (LWK) population from the 1000 genomes data (<xref rid="btu294-B3" ref-type="bibr">1000 Genomes Project Consortium, 2010</xref>, <xref rid="btu294-B4" ref-type="bibr">2012</xref>) that contains cryptic relationships to show that method could detect these cryptic individuals.</p>
  </sec>
  <sec>
    <title>2 METHODS</title>
    <sec sec-type="intro">
      <title>2.1 Overview</title>
      <p>Our method uses the ‘fuzzy’ encryption, which is a new method in the field of cryptography (<xref rid="btu294-B5" ref-type="bibr">Dodis <italic>et al.</italic>, 2008</xref>; <xref rid="btu294-B9" ref-type="bibr">Ishai <italic>et al.</italic>, 2011</xref>). The ‘fuzzy’ encryption is similar to the traditional encryption and decryption protocols where each individual has a public key and a private key. The public key for each individual is accessible by all other individuals and the private key for each individual is hidden from all other individuals. In a traditional protocol to decrypt the message we use the same private key that was used to encrypt the message in the first place as shown in <xref ref-type="fig" rid="btu294-F1">Figure 1</xref>A. However, in ‘fuzzy’ encryption, decryption is possible only if the Hamming distance between the two keys is less than a predefined threshold ‘<italic>t</italic>’ as shown in <xref ref-type="fig" rid="btu294-F1">Figure 1</xref>B. The ‘fuzzy’ decryption terminates successfully if the Hamming distance between the keys is &lt;‘<italic>t</italic>’ and it fails otherwise. Mostly, the keys used in ‘fuzzy’ encryption are in form of extremely long vectors which are sparse and the sparsity allows us to compute the Hamming distance efficiently using ‘fuzzy’ encryption.
<fig id="btu294-F1" position="float"><label>Fig. 1.</label><caption><p>In traditional encryption and decryption protocol, each individual generates two codes using the key generation process. The public key (<italic>P<sub>k</sub></italic>) is accessible by every one, and the private key (<italic>S<sub>k</sub></italic>) should be kept secret. In order to send a secure message to a sender we will use the public key available by the sender to encode the message. Then, the receiver will use the secret key (private), which was generated for the sender with the public key in the key generation process, to decrypt the message as shown in panel (<bold>A</bold>). The Fuzzy extractor is similar to traditional encryption and decryption protocol with one major difference, that the private key to decrypt the encrypted message has to be close to the original private key, which was generated in key generation process, and not necessary the same key as shown in panel (<bold>B</bold>)</p></caption><graphic xlink:href="btu294f1"/></fig></p>
      <p>Fuzzy extractors can be used to implement secure comparison of sets of a fixed size (number of elements in a set) which is the basis of our approach to private relative identification. The secure comparison of sets works as follows. Each individual has a set of elements which is private to the individual. Using the cryptographic protocol based on fuzzy extractors, each individual is able to identify which other individuals have a set with at least ‘<italic>t</italic>’ elements in common. The way the protocol works is that each individual releases some public information referred to as a ‘secure sketch’ and then individuals compare their sets against the sketches of others. The individual can recognize if the sets of the two individuals contain at least ‘<italic>t</italic>’ common elements.</p>
      <p>The way secure set comparison is implemented using fuzzy extractors is that the private keys that are generated encode the membership of each element of the set. We consider all sets contain <italic>k</italic> elements, each of which is binary vectors of length <italic>m</italic>, then there are a total of 2<italic><sup>m</sup></italic> possible elements. The private keys are binary vectors of length 2<italic><sup>m</sup></italic> with <italic>k</italic> ‘1’s encoding which element exists in an individual’s set. We use fuzzy extractors to generate public keys for these private keys where the threshold for decryption is <inline-formula><mml:math id="n1"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> Any pair of private keys which have Hamming distance <inline-formula><mml:math id="n2"><mml:mrow><mml:mo>&lt;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are correspond to sets that have at least ‘<italic>t</italic>’ elements in common. Any pair of private keys that have Hamming distance of <inline-formula><mml:math id="n3"><mml:mrow><mml:mo>&gt;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> will have &lt;‘<italic>t</italic>’ elements in common. Each individual can release their public keys and other individuals can detect if their sets have at least ‘<italic>t</italic>’ elements in common by attempting to decrypt the public key using their private key.</p>
      <p>In this work similar to previous work (<xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic>, 2013</xref>), we use the fuzzy extractor to compute the symmetric set difference as a black box. Our goal is to encode the two haplotypes (diploid genome) for each individual to a set such that the symmetric set difference between individuals corresponds to the genetic similarity between the two individuals. In the previous method (<xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic>, 2013</xref>), only the common variants are used and assumed the list of variants between all the individuals are the same, as a result we convert the haplotypes to a set by considering non-overlaping segments. Thus, the symmetric set difference between the generated sets can approximate the hamming distance between their haplotypes. However, in our work we want to utilize the rare variants and relax the assumption that all individuals have access to the list of all the variants between all the individuals. In this work each haplotype is compared against the reference genome and the positions where they differ are marked as ‘1’ and the rest are marked as ‘0’. Thus, individuals that are related have more positions in the haplotype marked similarly as compared to the unrelated individuals. Using the encoded genome we generate ‘sketch’ that contains private information and is used as the private key. From the sketch we generate the ‘secure sketch’ and use it as the public key. In order for two individuals ‘A’ and ‘B’ to detect if they are related or not, individual ‘A’ compares its private sketch with the secure sketch obtained from individual ‘B’. If the two individuals are related the ‘fuzzy’ encryption method terminates successfully, if not the program fails.</p>
      <p>We need to show our method is secure as each individual release a public key that is generated from each genome that contains private data. We need to show the amount of information obtained from public key is small relative to the total amount of data in each genome. We use entropy to measure the amount of information. Entropy is a known quantity to measure the amount of information in a data and entropy is an additive quantity. Thus, in order to show our method is secure we have to show the entropy in the human genome is much larger than the entropy in the public key (sketch). The entropy in ‘fuzzy’ encryption is bounded by <inline-formula><mml:math id="n4"><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>s</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> where ‘<italic>t</italic>’ is the number of elements that are in common between the sets and <italic>s</italic> is the number of elements in each set. Intuitively, this value corresponds to the strength of an encryption. If there are 100 bits of entropy remaining, a brute force approach to identify the set would require the same effort to crack 100-bit encryption. As long as this number is &gt;100 bits, the protocol is relatively secure.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Estimating genetic relatives by comparing sets</title>
      <p>There exist a series of methods to detect the relatedness among different individuals and even build the family tree using the Identity by descent (IBD) (<xref rid="btu294-B10" ref-type="bibr">Li <italic>et al.</italic>, 2010</xref>; <xref rid="btu294-B16" ref-type="bibr">Stevens <italic>et al.</italic>, 2011</xref>; <xref rid="btu294-B18" ref-type="bibr">Wang, 2011</xref>). In this section we describe a simple method to approximate the relatedness using the haplotype data which can be used to build a secure protocol.</p>
      <p>We assume that we have <italic>N</italic> individuals and we have access to each individual’s variants and the reference genome. In our method we only consider single-base variants which include both common and rare variants. Furthermore, we assume we have access to the phased haplotypes of each individual, in the case we have unphased haplotypes, we can phase them by using the existing methods (<xref rid="btu294-B2" ref-type="bibr">Browning and Browning, 2007</xref>; <xref rid="btu294-B10" ref-type="bibr">Li,Y. <italic>et al.</italic>, 2010</xref>; <xref rid="btu294-B14" ref-type="bibr">Scheet and Stephens, 2006</xref>; <xref rid="btu294-B15" ref-type="bibr">Stephens and Scheet, 2010</xref>), we phased the individuals using a reference dataset of individuals which did not contain any individuals that are related to the ones we are phasing. We convert the two haplotypes for each individual to a single set such that the set comparison between the two individuals’ haplotypes can estimate the genetic relatedness. In our method, unlike the previous method, the list of all the variants is not the same between all the individuals. Thus, we need to convert each individual’s haplotypes to a binary string such that the hamming distance between the two strings estimates the similarity between the two individuals. Furthermore, the variants that occur in the same positions in the haplotype should be compared against each other. Thus, we use the reference genome to align the variants such the same variants are compared. We convert each individual genome (donor) to binary genome by comparing each donor genome to the reference genome, we convert each position to ‘0’ when there exists no variants between the donor and the reference genome and otherwise ‘1’. We partition each binary genome to non-overlapping segments of 30 000 bp. We generate a set for each individual such that each element of the set contains the segment data (string of length 30 000 which represents the binary genome of that segment) and the segment position. We compute the summation of the binary value of the segment position and the segment data and store the computed value in a set. In order to compute the summation we used the arithmetic addition operation for binary numbers. More formally, let <italic>H<sub>i</sub></italic> indicates the <italic>i</italic>-th individual binary haplotypes where <inline-formula><mml:math id="n5"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msubsup><mml:mi>H</mml:mi><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>H</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula><mml:math id="n6"><mml:mrow><mml:msubsup><mml:mi>H</mml:mi><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n7"><mml:mrow><mml:msubsup><mml:mi>H</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> represent the first and second haplotypes, respectively, for <italic>i</italic>-th individual. In our model we consider two haplotypes for each individual as we assume we are dealing with diploid genomes (two copies of each chromosome). Moreover, <inline-formula><mml:math id="n8"><mml:mrow><mml:msubsup><mml:mi>H</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:msubsup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mn>30 000</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> represent the <italic>j</italic>-th segment of the <italic>i</italic>-th individual’s binary haplotype. We use <italic>S<sub>i</sub></italic> to indicate the set for <italic>i</italic>-th individual and <italic>s<sub>ij</sub></italic> to indicate the <italic>j</italic>-th element of the set <italic>S<sub>i</sub></italic> representing the <italic>j</italic>-th segment of genome.
<disp-formula><graphic xlink:href="btu294um1.jpg" position="float"/></disp-formula>
where <inline-formula><mml:math id="n10"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the binary representation of an integer number and <italic>M</italic> denotes total number of base pair in each genome, in the case of human genome <italic>M</italic> = 3 billions.</p>
      <p>If the distance score between two individuals is &lt;‘<italic>t</italic>’ we consider them as related individuals and if the distance score is &gt;‘<italic>t</italic>’ we consider them as unrelated individuals. We assume the value of ‘<italic>t</italic>’ is computed using a training set where the true relationship between each pair of individuals is known.</p>
      <p>In order to compute the number of matched segments between two individuals, we count the number of shared haplotypes for each segment between the two individuals. There exist three possible values for each segment: zero, one and two. Zero indicates both haplotypes in that segment are different between the two individuals, two indicates both haplotypes in that segment are the same between the two individuals and one indicates only one of the haplotypes is the same between the two individuals.</p>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Protecting privacy during identification of relatives</title>
      <p>In order for individuals to securely compute the symmetric difference between their genomic sets, we define a sketch where we hash the value of each element in the genomic sets (<italic>S<sub>i</sub></italic>). Let <italic>K<sub>i</sub></italic> indicates the sketch of <italic>i</italic>-th individual and <italic>k<sub>ij</sub></italic> indicates the <italic>j</italic>-th element of the <italic>K<sub>i</sub></italic> that is obtained by hashing the <italic>j</italic>-th element of the <italic>i</italic>-th individual genome set.
<disp-formula><mml:math id="n11"><mml:mrow><mml:msub><mml:mi>k</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mn>24</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
where <italic>r</italic> is a random binary number of size 100 that is referred to as the salt, and <inline-formula><mml:math id="n12"><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mrow><mml:mn>24</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a collision-resistance hash function that returns the first 24 bits. One of the main properties of the elements in the secure set is that the similarity between two chunks is preserved. If two segments differ in one base pair their corresponding elements in the secure set differs due to the hash function.</p>
      <p>Collision-resistance hash function has two main properties: first, collision-resistance hash function is one-way function. Second, finding distinct values which have the same hashed value is hard. We consider function <italic>f</italic> to be a one way function such that given <italic>x</italic> computing <italic>f</italic>(<italic>x</italic>) is easy. However, given the <italic>f</italic>(<italic>x</italic>) computing the <italic>x</italic> is hard. It is worth mentioning two segments obtained from the same genomic position in the genome for two different individuals that differ in one base pair have a different sketch element. Thus, reverse engineering the genome given the secure set is extremely hard based on the hardness of inverting one way functions.</p>
      <p>However, using the sketch for identification leaks information. We can compare the sketch of other individuals with our own sketch to detect which genome segments are similar. Thus, this results in the leak of information. We use the sketch as the private key and use the improved version of the Juels–Sudan construction (<xref rid="btu294-B5" ref-type="bibr">Dodis <italic>et al.</italic>, 2008</xref>; <xref rid="btu294-B9" ref-type="bibr">Ishai <italic>et al.</italic>, 2011</xref>) that uses list decoding, followed by a hash check to generate a secure sketch that is used as public key for individuals.</p>
      <p>Using the above encoding, each individual is represented by a set containing 24-bit elements. Individuals are related if they share at least ‘<italic>t</italic>’ of their elements. We can then use the secure set comparison from Section 2.1 to allow individuals to identify their relatives without requiring them to release their genomes.</p>
      <p>The amount of entropy in ‘fuzzy’ encryption is bounded by <inline-formula><mml:math id="n13"><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>s</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> where <italic>t</italic> is the number of elements that are in common between the sets sand <italic>s</italic> is number of chunks. In the case of human <inline-formula><mml:math id="n14"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>3 000 000 000</mml:mn></mml:mrow><mml:mrow><mml:mn>30 000</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>100 000.</mml:mn></mml:mrow></mml:math></inline-formula> Although computing the exact entropy of the human genome needs enormous number of individuals, <xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic> (2013)</xref> show that the approximate amount of entropy in the human genome is much higher than <inline-formula><mml:math id="n15"><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>s</mml:mi></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> More detail is provided in Appendix A.</p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 Haplotype encoding independent of genome builds</title>
      <p>The encoding mentioned in Section 2.2 depends on the genome build that is used to call variants. Thus, individuals using different genome builds are unable to compare their sets. In this section we propose a new encoding which makes the encoding independent from the genome build which is used to call the variants. Our encoding is based on the observation that variant positions are typically identifiable using the 500-bp flanking sequence and the number of variants which differ in flanking sequence between different builds is extremely low.</p>
      <p>In this encoding each segment is of size 30 000 bp and each segment starts from a known common SNP in the dbSNP (<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/SNP/">http://www.ncbi.nlm.nih.gov/SNP/</ext-link>). Then, for each variant in the segment we consider the flanking sequence of length 500 bp around the variant. Virtually all common SNPs have been identified in the HapMap and 1000G projects. We concatenate all the flanking sequences around each variant in a segment to represent the segment uniquely. Then, the collision resistance hash function is applied as described above to generate elements of the set.</p>
    </sec>
    <sec id="SEC2.5">
      <title>2.5 Generating simulated data</title>
      <p>In order for us to evaluate our method we must generate realistic simulations. We generate simulation by randomly mating individuals and generating a pedigree using a recombination rate of 10<sup>−</sup><sup>7</sup>.</p>
      <p>Since sequence errors and phasing errors affect the amount of matching in real data, for our simulations to be valid, we must use similar error rates. We utilize our real data to estimate the effect of these errors on matching in order to guide our simulations as follows. We first generate simulations without any error rates and compute the amount of matching for siblings unrelated individuals in real data compared to our simulated data. We then increase the error rate until the amounts of sharing are comparable and then utilize these parameters in our simulations.</p>
    </sec>
  </sec>
  <sec>
    <title>3 RESULTS</title>
    <sec id="SEC3.1">
      <title>3.1 Simulated data</title>
      <p>In order to assess the performance of our method, we generated simulated data for different levels of relatedness using the 1000 genomes data. We used the LWK population which consists of 116 individuals. Among these 116 individuals 19 individuals have cryptic relationships that are removed from our data-generating process, and we used the remaining individuals as the founder individuals. In the first step, we used the founder individuals to generate offspring by randomly mating the individuals. Moreover, for simplicity we assume there exist no polygamy in the simulated data, thus each individual is mated with only one individual. In the next step, we use the generated offsprings to generate offsprings of the next generation by pairing together unrelated individuals from the current generation. We continue to generate new offsprings until we have sufficient number of distant relatives. In our case, we generated 10 generations from the founder individuals. Using this data we can check different levels of relatedness such as sibling, first-degree cousins, and second-degree cousins and up to sixth-degree cousins. We utilized a recombination rate of 10<sup>−</sup><sup>7</sup>. We utilized a sequencing-error and phasing-error rate which is consistent with what we observe as the effect of errors on the amount of matching compared to what is expected in real data as we describe in Section 2.</p>
      <p>We compute the similarity score for each pair of individuals using our encoding. We show there exists a separation between the related and unrelated pairs of individuals which is shown in <xref ref-type="fig" rid="btu294-F2">Figure 2</xref>. We set the cut-off to 25 390 segments to separate the related individuals from unrelated individuals. In Appendix A we describe a principle way to select the cut-off.
<fig id="btu294-F2" position="float"><label>Fig. 2.</label><caption><p>There exists a clear separation between the related and unrelated individuals. We use the LWK population from the 1000 genomes data as the founder and we use the cut-off of 25 390 segments to distinguish the related and unrelated individuals</p></caption><graphic xlink:href="btu294f2"/></fig></p>
      <p><xref ref-type="fig" rid="btu294-F3">Figure 3</xref>A indicates the histogram of similarity scores for different individuals. All pairs of individuals that have the same relationship are shown with the same color in the histogram. There exist a separation between the number of segments shared between related individuals compared to unrelated individuals, we set the cut-off to 25 390 segments to separate the related individuals from unrelated individuals. This result indicates that we can easily distinguish up to fifth-degree cousins using the rare variants. We note that in a previous approach, <xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic> (2013)</xref> were able to distinguish only up to third-degree cousins which only utilize the common variants. The result of common variants is shown in <xref ref-type="fig" rid="btu294-F3">Figure 3</xref>B.
<fig id="btu294-F3" position="float"><label>Fig. 3.</label><caption><p>The histogram of the number of matched segments between different individuals in the simulated data. We used the set of unrelated individuals in the LWK population from the 1000 genomes data as the founder. Panel (<bold>A</bold>) indicates our method which uses the rare variants to detect the relativeness between the different individuals and panel (<bold>B</bold>) indicates the result of the method proposed by <xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic> (2013)</xref>. Thus, utilizing the rare variants, we can detect up to fifth-degree cousin as opposed to the third-degree cousin</p></caption><graphic xlink:href="btu294f3"/></fig></p>
      <p>We run our method to generate the secure sketch (public key) for each simulated individual and then each individual uses the secure sketch of another individuals and compare to its own sketch (private key). As expected, for each pair of individuals that are related, the program terminates successfully. However, for unrelated pairs of individuals the program fails.</p>
      <p>We use another population from the 1000 genomes to generate simulated data using the same process to make sure our results are not specific to only one population. We use the Mexican Ancestry in Los Angeles, California (MXL) population. The MXL consist of 69 individuals where nine individuals have cryptic relationships. We removed the cryptic-related individuals so that the founders are unrelated. We observe there exists a separation between the related and unrelated using our method of comparing sets. We can detect up to fifth-degree cousins using our method. The results are similar to the LWK population and for the sake of space we did not show the results.</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Real data</title>
      <p>In order to assess the results of our method we used the 1000 genomes data. Although the 1000 genomes data consist of unrelated individuals, there exists three populations that contain cryptic (not known before sequencing) relationships. These three populations are African Ancestry in Southwest (ASW), and LWK. We used the final phase of data. The ASW population consists of 66 individuals where 10 individuals have cryptic relationships. The LWK population consists of 116 individuals where 19 individuals have cryptic relationships. The cryptic relationships in this data are parent–child, sibling or second-order relationships.</p>
      <p>In order to detect if two individuals are related or not there exist series of methods, the standard method is KING method (<xref rid="btu294-B12" ref-type="bibr">Manichaikul <italic>et al.</italic>, 2010</xref>). In this work we use a simpler idea which can be used to build a secure protocol. We divide the genome to segments of length 30 000 bits. Then, for each pair of individuals we count the number of segments which are identical and then use a threshold to distinguish between related and unrelated individuals. As shown in <xref ref-type="fig" rid="btu294-F4">Figure 4</xref> there exists a clear separation between the related and unrelated individuals based on the number of matched segments. Thus, the threshold of 25 390 number of segments can discriminate the related and unrelated individuals.
<fig id="btu294-F4" position="float"><label>Fig. 4.</label><caption><p>The histogram of the number of matched segments between different individuals in the 1000 genomes data. We used the ASW and LWK populations. For each pair of individuals we count the number of segments that are exactly match. We can use a cut-off of 25 390 segments to distinguish between the related and unrelated individuals in this dataset</p></caption><graphic xlink:href="btu294f4"/></fig></p>
      <p>We run our method to generate the secure sketch (public key) for each individual in the 1000 genomes data. Then, each individual uses the secure sketches of other individuals and compare it with their own sketch (private key). As expected, for each pair of individuals that are related, the program terminates successfully. However, for unrelated pairs of individuals the program fails.</p>
      <p>In order to check if the new encoding mention in Section 2.4 works, we used the known list of SNPs from Hg18 and Hg19 obtained from the HapMap project. For each SNP we consider 500-bp sequence around the SNP in both builds of Hg18 and Hg19. Then, we used the SSHA-256 to hash each string (1000 bp) and compared the hash value for the same SNPs in the two different builds. In our experiment we observed only 0.002 fraction of the SNPs will not have the same hash value. Meaning only 0.002 of SNPs are not mapped to the right SNP position when two different genome builds are used. As a result, the majority of SNPs are mapped to the same flanking sequence when moving from Hg19 to Hg18. Thus, the encoding which utilizes the flanking sequence can easily use a different genome build to generate keys to be compared with the other individual’s public key that was generated using a different genome build.</p>
    </sec>
  </sec>
  <sec>
    <title>4 DISCUSSION</title>
    <p>Sequencing technologies have made personal genomics possible and many companies are providing information about ancestry and health of individuals by utilizing genetic data. However, to obtain these information, each individual has to share their genomic data. The sharing of genomic data raises privacy issues.</p>
    <p>One solution to the privacy issue is to use a trusted third party for detecting relatedness, however, individuals may not feel comfortable to share their genetic data with a trusted party for detecting related individuals. In this article, we demonstrate detecting the relatedness between two individuals where both individuals have access to their genetic data and no third party is needed.</p>
    <p>Recently, <xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic> (2013)</xref> have proposed a secure method for detecting the genetic relatives using genotype data. This method uses the ‘fuzzy’ encryption. A limitation of <xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic> (2013)</xref> is that only previously know variants which are common can be used in the method. Unfortunately, common variants are not as nearly as informative for identifying relatives as rare variants which are typically shared with only close family members.</p>
    <p>In this work, we provide a secure method for individuals to detect the genetic relatives from sequencing data without exposing any information about their genomes that utilizes both common and rare variants and through simulated data, we demonstrate, we can detect up to fifth-degree cousins. We also show in two populations from the 1000 genomes data that contains cryptic relationships, our method can detect these individuals. Our method also utilized an encoding that allows us to compare individuals who utilized different genome builds for calling their variants. Thus, genomes encoded using today’s genome build can be used to detect relatives called using future builds.</p>
    <p>The input to our method is the phased haplotypes, in the case we have unpashed data, we phase our data using an existing method (<xref rid="btu294-B2" ref-type="bibr">Browning and Browning, 2007</xref>; <xref rid="btu294-B10" ref-type="bibr">Li,Y. <italic>et al.</italic>, 2010</xref>; <xref rid="btu294-B14" ref-type="bibr">Scheet and Stephens, 2006</xref>); <xref rid="btu294-B15" ref-type="bibr">Stephens and Scheet, 2010</xref>). We phased the individuals using a reference dataset of individuals which did not contain any individuals that are related to the ones we are phasing. We note that sequencing errors and phasing errors decrease the amount of segment matches between related individuals because an error in a segment that matches will appear as a segment that does not match. Our experiments over real data already implicitly take into account the sequencing and phasing errors because any errors decrease our observed amount of similarity among related pairs. As sequencing technologies mature and the error rates decrease, we expect that the number of matches between related individuals will increase accordingly.</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGMENTS</title>
    <p>We acknowledge the support of the NINDS Informatics Center for Neurogenetics and Neurogenomics (P30 NS062691). This material is based upon work supported by the Defense Advanced Research Projects Agency through the U.S. Office of Naval Research under Contract N00014-11-1-0389. The views expressed are those of the authors and do not reflect the official policy or position of the Department of Defense, the National Science Foundation, the National Institute of Health or the U.S. Government.</p>
    <p><italic>Funding</italic>: <funding-source>National Science Foundation (NSF)</funding-source> (grants <award-id>0513612</award-id>, <award-id>0731455</award-id>, <award-id>0729049</award-id>, <award-id>0916676</award-id> and <award-id>1320589</award-id> to F.H., J.J. and E.E.; grant <award-id>1065276</award-id> to E.E., A.S. and R.O.; grants <award-id>1136174</award-id>, <award-id>0916574</award-id> and <award-id>0830803</award-id> to A.S. and R.O.; grants <award-id>1228984</award-id> and <award-id>1118096</award-id> to A.S., in part; grants <award-id>1016540</award-id> and <award-id>1118126</award-id> to R.O.); <funding-source>National Institutes of Health (NIH)</funding-source> (grants <award-id>K25-HL080079</award-id>, <award-id>U01-DA024417</award-id>, <award-id>P01-HL30568</award-id> and <award-id>PO1-HL28481</award-id> to F.H., J.J. and E.E.); Xerox Faculty Research Award (A.S. and R.O.); DARPA/ONR PROCEED award (to A.S., in part); <funding-source>US–Israel BSF</funding-source> (grant <award-id>2008411</award-id> to R.O.).</p>
    <p><italic>Conflict of interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="btu294-B1">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Blahut</surname>
            <given-names>RE</given-names>
          </name>
        </person-group>
        <source>Theory and Practice of Error-correcting Codes</source>
        <year>1983</year>
        <publisher-loc> Reading, MA</publisher-loc>
        <publisher-name>Addison-Wesley</publisher-name>
      </element-citation>
    </ref>
    <ref id="btu294-B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Browning</surname>
            <given-names>SR</given-names>
          </name>
          <name>
            <surname>Browning</surname>
            <given-names>BL</given-names>
          </name>
        </person-group>
        <article-title>Rapid and accurate haplotype phasing and missing-data inference for whole-genome association studies by use of localized haplotype clustering</article-title>
        <source>Am. J. Hum. Genet.</source>
        <year>2007</year>
        <volume>81</volume>
        <fpage>10841097</fpage>
      </element-citation>
    </ref>
    <ref id="btu294-B3">
      <element-citation publication-type="journal">
        <collab>Genomes Project Consortium</collab>
        <article-title>A map of human genome variation from population-scale sequencing</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>467</volume>
        <fpage>1061</fpage>
        <lpage>1073</lpage>
        <pub-id pub-id-type="pmid">20981092</pub-id>
      </element-citation>
    </ref>
    <ref id="btu294-B4">
      <element-citation publication-type="journal">
        <collab>Genomes Project Consortium</collab>
        <article-title>An integrated map of genetic variation from 1,092 human genomes</article-title>
        <source>Nature</source>
        <year>2012</year>
        <volume>491</volume>
        <fpage>56</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="pmid">23128226</pub-id>
      </element-citation>
    </ref>
    <ref id="btu294-B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dodis</surname>
            <given-names>Y</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Fuzzy extractors: How to generate strong keys from biometrics and other noisy data</article-title>
        <source>SIAM J. Comput.</source>
        <year>2008</year>
        <volume>38</volume>
        <fpage>97</fpage>
        <lpage>139</lpage>
      </element-citation>
    </ref>
    <ref id="btu294-B6">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Guruswami</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Sudan</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Improved decoding of reed-solomon and algebraic-geometric codes</article-title>
        <source>Foundations of Computer Science, 1998. Proceedings of 39th Annual Symposium on, Palo Alto, CA</source>
        <year>1998</year>
        <publisher-name>IEEE</publisher-name>
        <fpage>28</fpage>
        <lpage>37</lpage>
      </element-citation>
    </ref>
    <ref id="btu294-B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>He</surname>
            <given-names>D</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Indetifying genetics relatives without compromising privacy</article-title>
        <source>Genome Res.</source>
        <year>2013</year>
        <volume>24</volume>
        <fpage>664</fpage>
        <lpage>672</lpage>
        <pub-id pub-id-type="pmid">24614977</pub-id>
      </element-citation>
    </ref>
    <ref id="btu294-B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Homer</surname>
            <given-names>N</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Resolving individuals contributing trace amounts of DNA to highly complex mixtures using high-density SNP genotyping microarrays</article-title>
        <source>PLoS Genet.</source>
        <year>2008</year>
        <volume>4</volume>
        <fpage>e1000167</fpage>
        <pub-id pub-id-type="pmid">18769715</pub-id>
      </element-citation>
    </ref>
    <ref id="btu294-B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ishai</surname>
            <given-names>Y</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Efficient non-interactive secure computation</article-title>
        <source>SIAM J. Comput.</source>
        <year>2011</year>
        <volume>38</volume>
        <fpage>97</fpage>
        <lpage>139</lpage>
      </element-citation>
    </ref>
    <ref id="btu294-B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>X</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Efficient identification of identical-by-descent status in pedigrees with many untyped individuals</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>i191</fpage>
        <lpage>i198</lpage>
        <pub-id pub-id-type="pmid">20529905</pub-id>
      </element-citation>
    </ref>
    <ref id="btu294-B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mach: using sequence and genotype data to estimate haplotypes and unobserved genotypes</article-title>
        <source>Genet. Epidemiol.</source>
        <year>2010</year>
        <volume>34</volume>
        <fpage>816834</fpage>
      </element-citation>
    </ref>
    <ref id="btu294-B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Manichaikul</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Robust relationship inference in genome-wide association studies</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>2867</fpage>
        <lpage>2873</lpage>
        <pub-id pub-id-type="pmid">20926424</pub-id>
      </element-citation>
    </ref>
    <ref id="btu294-B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sankararaman</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Genomic privacy and limits of individual detection in a pool</article-title>
        <source>Nat. Genet.</source>
        <year>2009</year>
        <volume>41</volume>
        <fpage>965</fpage>
        <lpage>967</lpage>
        <pub-id pub-id-type="pmid">19701190</pub-id>
      </element-citation>
    </ref>
    <ref id="btu294-B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Scheet</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Stephens</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>A fast and flexible statistical model for large-scale population genotype data: applications to inferring missing genotypes and haplotypic phase</article-title>
        <source>Am. J. Hum. Genet.</source>
        <year>2006</year>
        <volume>78</volume>
        <fpage>629644</fpage>
      </element-citation>
    </ref>
    <ref id="btu294-B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stephens</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Scheet</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Accounting for decay of linkage disequilibrium in haplotype inference and missing-data imputation</article-title>
        <source>Am. J. Hum. Genet.</source>
        <year>2010</year>
        <volume>76</volume>
        <fpage>449462</fpage>
      </element-citation>
    </ref>
    <ref id="btu294-B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stevens</surname>
            <given-names>EL</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Inference of relationships in population data using identity-by-descent and identity-by-state</article-title>
        <source>PLos Genet.</source>
        <year>2011</year>
        <volume>7</volume>
        <fpage>e1002287</fpage>
        <pub-id pub-id-type="pmid">21966277</pub-id>
      </element-citation>
    </ref>
    <ref id="btu294-B17">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Van Lint</surname>
            <given-names>JH</given-names>
          </name>
        </person-group>
        <source>Introduction to Coding Theory</source>
        <year>1982</year>
        <volume>Vol. 86</volume>
        <publisher-name>Springer-Verlag Berlin Heidelberg</publisher-name>
      </element-citation>
    </ref>
    <ref id="btu294-B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Unbiased relatedness estimation in structured populations</article-title>
        <source>Genetics</source>
        <year>2011</year>
        <volume>187</volume>
        <fpage>887</fpage>
        <lpage>901</lpage>
        <pub-id pub-id-type="pmid">21212234</pub-id>
      </element-citation>
    </ref>
  </ref-list>
  <app-group>
    <app id="btu294-APP1">
      <title>APPENDIX A</title>
      <sec>
        <title>A1 SEPARATION CUT-OFF BETWEEN RELATED AND UNRELATED INDIVIDUALS</title>
        <p>In this section we describe a principled way to select a cut-off to separate the related from unrelated individuals. Using real data we observe the number of segments shared between unrelated individuals follows a normal distribution <inline-formula><mml:math id="n16"><mml:mrow><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where the mean of the distribution is 19 325 and the standard deviation is 1080. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu294/-/DC1">Supplementary Figure S1</ext-link> illustrates the QQplot of the number of matched segments between each pair of unrelated individuals in LWK population. Unfortunately, the real data lack sufficient number of related individuals to observe if the number of segments between related individuals follows a normal distribution or not.</p>
        <p>Given that the number of shared segments for unrelated individuals follows a normal distribution <inline-formula><mml:math id="n17"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo>∼</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>μ</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>σ</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> we select a cut-off value of <italic>c</italic> such that the probability of observing a value &gt;<italic>c</italic> for the number of matched segment in unrelated individuals is extremely small such as 1<italic>e</italic> − 8.
<disp-formula><mml:math id="n18"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo>≥</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mn>1</mml:mn><mml:mi>e</mml:mi><mml:mo>−</mml:mo><mml:mn>8</mml:mn></mml:mrow></mml:math></disp-formula>
</p>
        <p>Thus, in our real data we set the cut-off to 25 390 (<italic>c</italic> = 25 390).</p>
      </sec>
      <sec>
        <title>A2 IMPROVED JUELS–SUDAN CONSTRUCTION</title>
        <p>In more detail, the idea of a secure sketch is based on the notion of an <italic>error correcting code</italic> (ECC) [<xref rid="btu294-B1" ref-type="bibr">Blahut (1983)</xref>, <xref rid="btu294-B17" ref-type="bibr">Van Lint (1982)</xref> provide good introductory treatment of the theory or error correction]. An ECC is used to provide a reliable means of communication over noisy channels. Here, we provide a very brief and simplified overview of ECC that is sufficient for our purposes. For positive integers <italic>n</italic>, <italic>k</italic>, <italic>d</italic>, an (<italic>n</italic>, <italic>k</italic>, <italic>d</italic>) ECC is a <italic>k</italic>-dimensional subspace of an <italic>n</italic>-dimensional vector space. Each element of the <italic>k</italic>-dimensional subspace is called a <italic>codeword</italic>. The parameter <italic>d</italic> specifies the <italic>distance</italic> of the code, which means that the Hamming distance (the Hamming distance between two <italic>n</italic>-dimensional vectors is the number of co-ordinates where they differ) between any two code words is at least <italic>d</italic>. Thus intuitively, the distance of a code is a measure of how ‘spread-out’ the code words are in the <italic>n</italic>-dimensional space. Finally, the ECC comes with a mechanism to ‘correct small errors’. This means that given a codeword <italic>v</italic>, if we change a small number of coordinates of <italic>v</italic> to get a vector <italic>w</italic>, then there exists an algorithm that on input <italic>w</italic>, outputs the ‘correct’ codeword <italic>v</italic>. Formally, an ECC comes with an efficient <italic>Decoding Algorithm</italic>, which works as follows: given any <italic>n</italic>-dimensional vector <italic>w</italic> as input, if there exists a codeword within distance <italic>d</italic>/2 of <italic>w</italic>, then the decoding algorithm outputs that vector, otherwise, it outputs an error message specifying that decoding failed. Note that as the distance of the code is <italic>d</italic>, there can be at most a single codeword within a distance <italic>d</italic>/2 of any vector <italic>w</italic>. This is called unique decoding.</p>
        <p>The Juels–Sudan construction that we use from <xref rid="btu294-B5" ref-type="bibr">Dodis <italic>et al.</italic> (2008)</xref> is based on a particular kind of ECC, called the Reed–Solomon code. We first give a brief overview of the Reed–Solomon construction, and then describe the Juels–Sudan construction. An (<italic>n</italic>, <italic>k</italic>, <italic>d</italic>) Reed–Solomon code is a particular kind of ECC that is defined as follows: fix a finite field <italic>F</italic> (in our case, the field <italic>F</italic> will be the Galois field <inline-formula><mml:math id="n19"><mml:mrow><mml:mi>G</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>24</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> and consider the <italic>n</italic>-dimensional vector space <italic>F<sup>n</sup></italic>. To define the <italic>k</italic>-dimensional subspace of code words, we begin by fixing a sequence of <italic>n</italic> points <inline-formula><mml:math id="n20"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> where each <italic>a<sub>i</sub></italic> is an element of <italic>F</italic>. The subspace of code words is obtained by evaluating all the degree <italic>k</italic> – 1 polynomials (over <italic>F</italic>) on the points <inline-formula><mml:math id="n21"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> i.e. let <inline-formula><mml:math id="n22"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be a degree <italic>k</italic> – 1 polynomial whose coefficients are elements of <italic>F</italic>. Then the corresponding code word is <inline-formula><mml:math id="n23"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> The code word subspace consists of the evaluations of all degree <italic>k</italic> – 1 polynomials. It follows from elementary algebra that the distance of the Reed–Solomon code is <inline-formula><mml:math id="n24"><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math></inline-formula> The details of the decoding algorithm can be found in <xref rid="btu294-B1" ref-type="bibr">Blahut (1983)</xref>, <xref rid="btu294-B17" ref-type="bibr">Van Lint (1982)</xref>.</p>
        <p>Now we are ready to describe the improved Juels–Sudan construction from <xref rid="btu294-B5" ref-type="bibr">Dodis <italic>et al.</italic> (2008)</xref>. Recall that the genome is represented as a set of 24-bit strings, which we take to be elements from the field <inline-formula><mml:math id="n25"><mml:mrow><mml:mi>G</mml:mi><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mrow><mml:mn>24</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> Let <inline-formula><mml:math id="n26"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>w</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mtext>
</mml:mtext><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be such a set. Our task is to convert the genome sketch <italic>s</italic><sub>1</sub> to a ‘secure sketch’ <italic>ss</italic><sub>1</sub>, which satisfies two properties: (i) the secure sketch should not reveal too much information about <italic>s</italic><sub>1</sub>, and (ii) given the genome sketch <inline-formula><mml:math id="n27"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mtext>
</mml:mtext><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of another individual and the secure sketch <italic>ss</italic><sub>1</sub> of the first individual, we should be able to determine if the two individuals are related or not. The Juels–Sudan algorithm uses algebraic techniques to achieve this.</p>
        <p>One of the main ideas of the Juels–Sudan construction is to represent the genome sketch as a polynomial. In particular, we first construct a polynomial <italic>p</italic>(<italic>x</italic>) whose roots are the <italic>w<sub>i</sub></italic>s; that is <inline-formula><mml:math id="n28"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msubsup><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> Note that anyone who knows <italic>p</italic>(<italic>x</italic>) can obtain the entire genome sketch by simply finding the roots of <italic>p</italic>(<italic>x</italic>). Thus, in particular, we can not use <italic>p</italic>(<italic>x</italic>) itself as the secure sketch (as it reveals too much information about the genome). Instead, the idea is to reveal only a small part of the polynomial <italic>p</italic>(<italic>x</italic>), and reconstruct the rest using error correction. This is done as follows: <italic>p</italic>(<italic>x</italic>) is split into two polynomials <inline-formula><mml:math id="n29"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width=".4em"/><mml:mtext>and</mml:mtext><mml:mspace width=".4em"/><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> Polynomial <inline-formula><mml:math id="n30"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a degree-<italic>n</italic> polynomial that matches <italic>p</italic>(<italic>x</italic>) in the <italic>ℓ</italic> highest coefficients, and all the other coefficients are 0 (here, the parameter <italic>ℓ</italic> will be determined later). The polynomial <inline-formula><mml:math id="n31"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a degree-<italic>n</italic> − <italic>ℓ</italic> polynomial that matches with <italic>p</italic>(<italic>x</italic>) in the <inline-formula><mml:math id="n32"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula> smallest coefficients. Thus, <inline-formula><mml:math id="n33"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> Only the polynomial <inline-formula><mml:math id="n34"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is released in public. To complete the scheme, we have to show two things: (i) revealing <inline-formula><mml:math id="n35"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> does not reveal too much information about the genome sketch, and (ii) given <inline-formula><mml:math id="n36"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> and the genome sketch of another individual, we can find out if there is a match or not.</p>
        <p>We first describe how matches are determined. Let <inline-formula><mml:math id="n37"><mml:mrow><mml:mo>{</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mtext>
</mml:mtext><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the genome sketch of another individual. Note that if we can reconstruct the polynomial <italic>p</italic>(<italic>x</italic>), then it is easy to check if there is a match or not (as <italic>p</italic>(<italic>x</italic>) contains all information about the sketch <inline-formula><mml:math id="n38"><mml:mrow><mml:mo>{</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>w</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mtext>
</mml:mtext><mml:mo>}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> As <inline-formula><mml:math id="n39"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is publicly available, our task is to reconstruct <inline-formula><mml:math id="n40"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> First, note the following mathematical fact: as <italic>w<sub>i</sub></italic> is a root of <italic>p</italic>(<italic>x</italic>), we have, <inline-formula><mml:math id="n41"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> which implies that <inline-formula><mml:math id="n42"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="n43"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> This implies that even though we do not have <inline-formula><mml:math id="n44"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> we can evaluate it on <italic>w<sub>i</sub></italic> given <inline-formula><mml:math id="n45"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> which is publicly available. Further, if we can evaluate <inline-formula><mml:math id="n46"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> on large enough number of points, then we can reconstruct <inline-formula><mml:math id="n47"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using elementary algebra (by a process called polynomial interpolation). However, we do not have access to the <italic>w<sub>i</sub></italic>s, but only to <italic>v<sub>i</sub></italic>s. But if the individuals are related, then the genome sketches of the individuals are close together, which means most of the <italic>w<sub>i</sub></italic>s are the same as <italic>v<sub>i</sub></italic>s. Thus, if we evaluate <inline-formula><mml:math id="n48"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mtext>(x)</mml:mtext></mml:mrow></mml:math></inline-formula> on the <italic>v<sub>i</sub></italic>s, we obtain a ‘noisy’ version of the evaluations of <inline-formula><mml:math id="n49"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> And this can now be corrected using error correction. In particular, we construct the <italic>n</italic>-dimensional vector <inline-formula><mml:math id="n50"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> and run the decoding algorithm of the Reed–Solomon code on it. If the two genome sequences are close by, then this algorithm outputs closest code word, which is <inline-formula><mml:math id="n51"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> from which <inline-formula><mml:math id="n52"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can be reconstructed.</p>
        <p>Now we come to the first point above, namely that revealing <inline-formula><mml:math id="n53"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>high</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> does not reveal too much information about the genome. Clearly, the amount of information released depends on the value of <italic>ℓ</italic>; the smaller the value of <italic>ℓ</italic>, the smaller the amount of information released. On the other hand, we can not make <italic>ℓ</italic> too small, as then we will not have enough information to decode (note that we are trying to reconstruct an <italic>n</italic> − <italic>ℓ</italic>-degree polynomial from <italic>n</italic> noisy points). Let <italic>t</italic> be the threshold for matching, i.e. if two individuals are related, then there genome sketches have at least <italic>t</italic> points in common. Then, to minimize the value of <italic>ℓ</italic>, we need to find the largest degree of the polynomial <inline-formula><mml:math id="n54"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that can be correctly decoded given <italic>n</italic> points, with threshold <italic>t</italic>. For the Reed–Solomon code with unique decoding, this turns out to be <italic>t</italic>, and thus the remaining entropy is equivalent to <italic>t</italic> field elements.</p>
        <p>Unfortunately, the way we have described the Juels–Sudan scheme above does not work for our application. The reason is that unique decoding of Reed–Solomon requires that the agreement be very high, as compared to the size of the genome sketch. However, in our application, even if the individuals are related, the agreement can be very small. Thus, we move to a more sophisticated error correction scheme called ‘list-decoding’ for Reed–Solomon codes. The main advantage of list-decoding over unique decoding is that it can tolerate very small agreement thresholds also. The scheme remains essentially as we have described so far, except that in the reconstruction step, instead of using unique decoding to reconstruct <inline-formula><mml:math id="n55"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mtext>low</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> we use the list-decoding algorithm from <xref rid="btu294-B6" ref-type="bibr">Guruswami and Sudan (1998)</xref>. The remaining entropy in this case turns out to be <inline-formula><mml:math id="n56"><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> field elements. In the case of human <inline-formula><mml:math id="n57"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>3 000 000 000</mml:mn></mml:mrow><mml:mrow><mml:mn>30 000</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>100 000.</mml:mn></mml:mrow></mml:math></inline-formula> Although computing the exact entropy of the human genome needs enormous number of individuals, <xref rid="btu294-B7" ref-type="bibr">He <italic>et al.</italic> (2013)</xref> show that the approximate amount of entropy in the human genome is much higher than <inline-formula><mml:math id="n58"><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>s</mml:mi></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula></p>
      </sec>
    </app>
  </app-group>
</back>
