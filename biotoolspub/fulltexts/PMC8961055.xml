<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with OASIS Tables with MathML3 v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-archive-oasis-article1-mathml3.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jats-oasis2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Eng Life Sci</journal-id>
    <journal-id journal-id-type="iso-abbrev">Eng Life Sci</journal-id>
    <journal-id journal-id-type="doi">10.1002/(ISSN)1618-2863</journal-id>
    <journal-id journal-id-type="publisher-id">ELSC</journal-id>
    <journal-title-group>
      <journal-title>Engineering in Life Sciences</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1618-0240</issn>
    <issn pub-type="epub">1618-2863</issn>
    <publisher>
      <publisher-name>John Wiley and Sons Inc.</publisher-name>
      <publisher-loc>Hoboken</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8961055</article-id>
    <article-id pub-id-type="doi">10.1002/elsc.202100108</article-id>
    <article-id pub-id-type="publisher-id">ELSC1477</article-id>
    <article-categories>
      <subj-group subj-group-type="overline">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="heading">
        <subject>Research Articles</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title><monospace>bletl</monospace> ‐ A Python package for integrating BioLector microcultivation devices in the Design‐Build‐Test‐Learn cycle</article-title>
      <alt-title alt-title-type="left-running-head">OSTHEGE et al.</alt-title>
    </title-group>
    <contrib-group>
      <contrib id="elsc1477-cr-0001" contrib-type="author">
        <name>
          <surname>Osthege</surname>
          <given-names>Michael</given-names>
        </name>
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-2734-7624</contrib-id>
        <xref rid="elsc1477-aff-0001" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="elsc1477-aff-0002" ref-type="aff">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib id="elsc1477-cr-0002" contrib-type="author">
        <name>
          <surname>Tenhaef</surname>
          <given-names>Niklas</given-names>
        </name>
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-9375-4156</contrib-id>
        <xref rid="elsc1477-aff-0001" ref-type="aff">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib id="elsc1477-cr-0003" contrib-type="author">
        <name>
          <surname>Zyla</surname>
          <given-names>Rebecca</given-names>
        </name>
        <xref rid="elsc1477-aff-0001" ref-type="aff">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib id="elsc1477-cr-0004" contrib-type="author">
        <name>
          <surname>Müller</surname>
          <given-names>Carolin</given-names>
        </name>
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-6277-1009</contrib-id>
        <xref rid="elsc1477-aff-0001" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="elsc1477-aff-0002" ref-type="aff">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib id="elsc1477-cr-0005" contrib-type="author">
        <name>
          <surname>Hemmerich</surname>
          <given-names>Johannes</given-names>
        </name>
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-9786-6315</contrib-id>
        <xref rid="elsc1477-aff-0001" ref-type="aff">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib id="elsc1477-cr-0006" contrib-type="author">
        <name>
          <surname>Wiechert</surname>
          <given-names>Wolfgang</given-names>
        </name>
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8501-0694</contrib-id>
        <xref rid="elsc1477-aff-0001" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="elsc1477-aff-0003" ref-type="aff">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib id="elsc1477-cr-0007" contrib-type="author">
        <name>
          <surname>Noack</surname>
          <given-names>Stephan</given-names>
        </name>
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-9784-3626</contrib-id>
        <xref rid="elsc1477-aff-0001" ref-type="aff">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib id="elsc1477-cr-0008" contrib-type="author" corresp="yes">
        <name>
          <surname>Oldiges</surname>
          <given-names>Marco</given-names>
        </name>
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-0704-5597</contrib-id>
        <xref rid="elsc1477-aff-0001" ref-type="aff">
          <sup>1</sup>
        </xref>
        <xref rid="elsc1477-aff-0002" ref-type="aff">
          <sup>2</sup>
        </xref>
        <address>
          <email>m.oldiges@fz-juelich.de</email>
        </address>
      </contrib>
    </contrib-group>
    <aff id="elsc1477-aff-0001">
      <label>
        <sup>1</sup>
      </label>
      <institution>Forschungszentrum Jülich GmbH</institution>
      <city>Jülich</city>
      <country country="DE">Germany</country>
    </aff>
    <aff id="elsc1477-aff-0002">
      <label>
        <sup>2</sup>
      </label>
      <named-content content-type="organisation-division">Institute of Biotechnology</named-content>
      <institution>RWTH Aachen University</institution>
      <city>Aachen</city>
      <country country="DE">Germany</country>
    </aff>
    <aff id="elsc1477-aff-0003">
      <label>
        <sup>3</sup>
      </label>
      <named-content content-type="organisation-division">Computational Systems Biotechnology (AVT.CSB)</named-content>
      <institution>RWTH Aachen University</institution>
      <city>Aachen</city>
      <country country="DE">Germany</country>
    </aff>
    <author-notes>
      <corresp id="correspondenceTo"><label>*</label><bold>Correspondence</bold><break/>Marco Oldiges, Forschungszentrum Jülich GmbH, 52428 Jülich, Germany.<break/>Email: <email>m.oldiges@fz-juelich.de</email><break/></corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>01</day>
      <month>3</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="collection">
      <month>3</month>
      <year>2022</year>
    </pub-date>
    <volume>22</volume>
    <issue seq="130">3-4</issue>
    <issue-id pub-id-type="doi">10.1002/elsc.v22.3-4</issue-id>
    <issue-title content-type="special-issue-title">Dedicated to Professor Thomas Scheper</issue-title>
    <fpage>242</fpage>
    <lpage>259</lpage>
    <history>
      <date date-type="rev-recd">
        <day>16</day>
        <month>1</month>
        <year>2022</year>
      </date>
      <date date-type="received">
        <day>23</day>
        <month>8</month>
        <year>2021</year>
      </date>
      <date date-type="accepted">
        <day>28</day>
        <month>1</month>
        <year>2022</year>
      </date>
    </history>
    <permissions>
      <!--&#x000a9; 2022 Wiley&#x02010;VCH GmbH-->
      <copyright-statement content-type="article-copyright">© 2022 The Authors. <italic toggle="yes">Engineering in Life Sciences</italic> published by Wiley‐VCH GmbH</copyright-statement>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open access article under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link> License, which permits use, distribution and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="file:ELSC-22-242.pdf"/>
    <abstract>
      <title>Abstract</title>
      <p>Microbioreactor (MBR) devices have emerged as powerful cultivation tools for tasks of microbial phenotyping and bioprocess characterization and provide a wealth of online process data in a highly parallelized manner. Such datasets are difficult to interpret in short time by manual workflows. In this study, we present the Python package bletl and show how it enables robust data analyses and the application of machine learning techniques without tedious data parsing and preprocessing. <monospace>bletl</monospace> reads raw result files from BioLector I, II and Pro devices to make all the contained information available to Python‐based data analysis workflows. Together with standard tooling from the Python scientific computing ecosystem, interactive visualizations and spline‐based derivative calculations can be performed. Additionally, we present a new method for unbiased quantification of time‐variable specific growth rate <mml:math id="jats-math-1" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> based on unsupervised switchpoint detection with Student‐t distributed random walks. With an adequate calibration model, this method enables practitioners to quantify time‐variable growth rate with Bayesian uncertainty quantification and automatically detect switch‐points that indicate relevant metabolic changes. Finally, we show how time series feature extraction enables the application of machine learning methods to MBR data, resulting in unsupervised phenotype characterization. As an example, Neighbor Embedding (t‐SNE) is performed to visualize datasets comprising a variety of growth/DO/pH phenotypes.</p>
    </abstract>
    <kwd-group kwd-group-type="author-generated">
      <kwd id="elsc1477-kwd-0001">BioLector</kwd>
      <kwd id="elsc1477-kwd-0002">feature extraction</kwd>
      <kwd id="elsc1477-kwd-0003">growth rate</kwd>
      <kwd id="elsc1477-kwd-0004">microbial phenotyping</kwd>
      <kwd id="elsc1477-kwd-0005">uncertainty quantification</kwd>
    </kwd-group>
    <funding-group>
      <award-group id="funding-0001">
        <funding-source>
          <institution-wrap>
            <institution>Bundesministerium für Bildung und Forschung
</institution>
            <institution-id institution-id-type="doi">10.13039/501100002347</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>031B0463A</award-id>
      </award-group>
      <award-group id="funding-0002">
        <funding-source>Deutsche Forschungsgemeinschaft (DFG, German Research Foundation)</funding-source>
        <award-id>491111487</award-id>
      </award-group>
    </funding-group>
    <counts>
      <fig-count count="9"/>
      <table-count count="1"/>
      <page-count count="18"/>
      <word-count count="8466"/>
    </counts>
    <custom-meta-group>
      <custom-meta>
        <meta-name>source-schema-version-number</meta-name>
        <meta-value>2.0</meta-value>
      </custom-meta>
      <custom-meta>
        <meta-name>cover-date</meta-name>
        <meta-value>March 2022</meta-value>
      </custom-meta>
      <custom-meta>
        <meta-name>details-of-publishers-convertor</meta-name>
        <meta-value>Converter:WILEY_ML3GV2_TO_JATSPMC version:6.1.2 mode:remove_FC converted:29.03.2022</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <p content-type="self-citation">
      <mixed-citation publication-type="journal" id="elsc202100156-cit-0035"><string-name><surname>Osthege</surname><given-names>M</given-names></string-name>, <string-name><surname>Tenhaef</surname><given-names>N</given-names></string-name>, <string-name><surname>Zyla</surname><given-names>R</given-names></string-name>. <article-title><monospace>bletl</monospace> ‐ A Python package for integrating BioLector microcultivation devices in the Design‐Build‐Test‐Learn cycle</article-title>. <source>Eng Life Sci</source>. <year>2022</year>;<volume>22</volume>:<fpage>242</fpage>–<lpage>259</lpage>. <pub-id pub-id-type="doi">10.1002/elsc.202100108</pub-id></mixed-citation>
    </p>
    <fn-group>
      <fn id="elsc1477-note-001">
        <p>Michael Osthege and Niklas Tenhaef contributed equally to this study.</p>
      </fn>
    </fn-group>
  </notes>
</front>
<body>
  <def-list list-content="abbreviations" id="elsc1477-lp-0001">
    <title>Abbreviation</title>
    <def-item>
      <term>bletl</term>
      <def>
        <p>BioLector Extract, Transform, Load</p>
      </def>
    </def-item>
    <def-item>
      <term>BS</term>
      <def>
        <p>backscatter</p>
      </def>
    </def-item>
    <def-item>
      <term>DBTL</term>
      <def>
        <p>Design ‐ Build ‐ Test ‐ Learn</p>
      </def>
    </def-item>
    <def-item>
      <term>DO</term>
      <def>
        <p>Dissolved Oxygen</p>
      </def>
    </def-item>
    <def-item>
      <term>FAIR</term>
      <def>
        <p>Findability, Accessibility, Interoperability, Reusability</p>
      </def>
    </def-item>
    <def-item>
      <term>IPTG</term>
      <def>
        <p>Isopropyl‐<mml:math id="jats-math-2" display="inline"><mml:mrow><mml:mi>β</mml:mi></mml:mrow></mml:math>‐D‐thiogalactopyranosid</p>
      </def>
    </def-item>
    <def-item>
      <term>MAP</term>
      <def>
        <p>maximum <italic toggle="yes">a‐posteriori</italic>
</p>
      </def>
    </def-item>
    <def-item>
      <term>MBR</term>
      <def>
        <p>microbioreactor</p>
      </def>
    </def-item>
    <def-item>
      <term>MCMC</term>
      <def>
        <p>Markov‐chain Monte Carlo</p>
      </def>
    </def-item>
    <def-item>
      <term>NUTS</term>
      <def>
        <p>No‐U‐Turn Sampler</p>
      </def>
    </def-item>
    <def-item>
      <term>PCA</term>
      <def>
        <p>Principal Component Analysis</p>
      </def>
    </def-item>
    <def-item>
      <term>t‐SNE</term>
      <def>
        <p>t‐distributed Stochastic Neighbor Embedding</p>
      </def>
    </def-item>
  </def-list>
  <sec id="elsc1477-sec-0010">
    <label>1</label>
    <title>INTRODUCTION</title>
    <p>The development of innovative bioprocesses is nowadays often carried out in a Design ‐ Build ‐ Test ‐ Learn 31 (DBTL) cycle [<xref rid="elsc1477-bib-0001" ref-type="bibr">1</xref>], where fast iterations of this cycle are desired to shorten development times and therefore save costs. This acceleration can be enabled by modern genetic engineering tools, lab automation and standardized data analysis pipelines. One aspect in the “Test” part of the DBTL cycle of a bioprocess is the cultivation of the microorganisms to be tested. This is often performed in microbioreactor systems, since they provide a good balance between adequate throughput and scalability of the results to laboratory scale bioreactors as the gold standard [<xref rid="elsc1477-bib-0002" ref-type="bibr">2</xref>, <xref rid="elsc1477-bib-0003" ref-type="bibr">3</xref>].</p>
    <p>A typical microbioreactor system will provide transient monitoring of biomass formation, dissolved oxygen, pH, and fluorescence. Usually, the researcher has access to additional environmental data such as temperature, shaking or stirrer frequencies, humidity, and gas atmosphere. Analyzing this heterogeneous, multi‐dimensional data in a quick and thorough manner can be challenging, especially since vendor software often covers only a limited amount of use cases.</p>
    <p>From our experience, most researchers try to alleviate such problems by employing spreadsheets of varying complexity, available with various software solutions. While presenting an easy way for simple calculations and visualizations, extensive analysis of the data quickly results in hardly maintainable documents, which are challenging for colleagues to comprehend, error‐prone and easy to break. Most importantly, such multi‐step manual data transformations do not comply with the FAIR data principles, because it is often not accessibly documented which operations were applied. In contrast, our <monospace>bletl</monospace> package directly addresses the accessibility aspect and creates incentives to, for example, retain the original data.</p>
    <boxed-text position="float" content-type="box">
      <sec id="elsc1477-sec-0020">
        <title>PRACTICAL APPLICATION</title>
        <p>The <monospace>bletl</monospace> package can be used to analyze microbioreactor datasets in both data analysis and autonomous experimentation workflows. Using the example of BioLector datasets, we show that loading such datasets into commonly used data structures with one line of Python code is a significant improvement over spreadsheet or hand‐crafted scripting approaches. On top of established standard data structures, practitioners may continue with their favorite data analysis routines, or make use of the additional analysis functions that we specifically tailored to the analysis of microbioreactor time series.</p>
        <p>Particularly our function to fit cross‐validated smoothing splines can be used for <italic toggle="yes">on‐line</italic> signals from any microbioreactor system and has the potential to improve robustness and objectivity of many data analyses. Likewise, our random walk based <mml:math id="jats-math-3" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> method for inferring growth rates under uncertainty, but also the time‐series feature extraction may be applied to <italic toggle="yes">on‐line</italic> data from other cultivation systems as well.</p>
        <p>Our package can be installed from PyPI, its code is available on <ext-link xlink:href="https://github.com/JuBiotech/bletl" ext-link-type="uri">https://github.com/JuBiotech/bletl</ext-link> and extensive documentation online at <ext-link xlink:href="https://bletl.readthedocs.io" ext-link-type="uri">https://bletl.readthedocs.io</ext-link>.</p>
      </sec>
    </boxed-text>
    <p>Automated data analysis pipelines solve this problem by removing the repetitive and error‐prone manual workflows in favor of standardized workflows defined in code. Such workflows offer many advantages, if done correctly: (a) data processing is clearly understandable and documented; (b) every step is carried out for every input data file in the same way, guaranteeing the integrity and reproducibility of the results; (c) data processing can be autonomously started after data generation; and (d) such a pipeline can be run on remote systems, which is especially useful for computational demanding calculations. Such data analysis pipelines are routinely used, for example, for sequencing data [<xref rid="elsc1477-bib-0004" ref-type="bibr">4</xref>], but seldom used for microbioreactor data. While multiple Python packages for working with microplate reader data can be found on PyPI [<xref rid="elsc1477-bib-0005" ref-type="bibr">5</xref>, <xref rid="elsc1477-bib-0006" ref-type="bibr">6</xref>], we would like to emphasize that microplate readers are typically not designed for cultivation and <italic toggle="yes">on‐line</italic> measurement. Furthermore, most of these implementations are tailored to specific experimental designs or research applications, making them less useful for application in other fields.</p>
    <p>Automated data analysis opens up possibilities for at‐line analysis and subsequent intervention during an experiment: Cruz Bournazou et al. report a framework for online experimental redesign of 10 mL 2mag microbioreactors using a data pipeline implemented in MATLAB [<xref rid="elsc1477-bib-0007" ref-type="bibr">7</xref>]. Prior work employing <italic toggle="yes">at‐line</italic> data processing from the BioLector platform includes Jansen et al. [<xref rid="elsc1477-bib-0008" ref-type="bibr">8</xref>] where a Python‐based process control system was employed to control pH and enzyme addition with a liquid handling robot, but the code was not released alongside the publication. Hemmerich et al. [<xref rid="elsc1477-bib-0009" ref-type="bibr">9</xref>] published MATLAB scripts for growth rate calculation from BioLector data, but the code acts on the XLSX file format that cannot be obtained without a human‐in‐the‐loop. A search for “BioLector” on PyPI, the most popular package registry in the Python ecosystem, revealed two Python packages <monospace>BioLectorPy</monospace> for plotting, and <monospace>getgrowth</monospace> for growth rate calculation from BioLector data, but the corresponding code is not in a public repository. These examples show that while automatable parsing and processing of BioLector data have been reported in literature, all prior work is tailored to specific use cases and neither unit‐tested nor universally applicable.</p>
    <p>In this study, we introduce <monospace>bletl</monospace> as a first‐of‐its‐kind open‐source Python package for reliable standalone and <italic toggle="yes">at‐line</italic> parsing and analysis of BioLector microbioreactor data. The name <monospace>bletl</monospace> is inspired by the fact that it simplifies the implementation of <underline underline-style="single">e</underline>xtract, <underline underline-style="single">t</underline>ransform, <underline underline-style="single">l</underline>oad data processing workflows specifically for BioLector datasets. It is capable of parsing raw BioLector data without involving vendor software, making necessary calibrations for fluorescent‐based measurement of pH and dissolved oxygen, and presenting all measurement, environmental and meta data in the easily accessible, <monospace>DataFrame</monospace> format from the popular <monospace>pandas</monospace> library [<xref rid="elsc1477-bib-0010" ref-type="bibr">10</xref>, <xref rid="elsc1477-bib-0011" ref-type="bibr">11</xref>]. Currently, <monospace>bletl</monospace> is designed to parse data from the devices BioLector I, II, and Pro manufactured by Beckman Coulter Life Sciences, but its general design and methods can be applied also for other devices. Specifically, its analysis submodules are built on top of standard data structures from the Python ecosystem, thereby providing the user with generally applicable data analysis routines for high‐resolution biological time series data. For example, we provide functions for data smoothing by cross‐validated spline approximation, growth rate analysis and time series feature extraction. Building on top of our recent work on uncertainty quantification and calibration modeling [<xref rid="elsc1477-bib-0012" ref-type="bibr">12</xref>], we introduce a new method for Bayesian analysis of time‐variable specific growth rate and benchmark the objectivity of the method on a synthetic dataset in comparison with commonly used alternative growth rate calculation methods. In addition to an extensive documentation and automated software tests, we provide application examples on a dataset without biological surprises, such that it is well suited for method understanding. With <monospace>bletl</monospace> , scientists using microbioreactors have a powerful tool to make their data analysis less cumbersome and error‐prone, while they can directly benefit from state‐of‐the‐art machine learning techniques.</p>
  </sec>
  <sec id="elsc1477-sec-0030">
    <label>2</label>
    <title>MATERIALS AND METHODS</title>
    <sec id="elsc1477-sec-0040">
      <label>2.1</label>
      <title>Core package</title>
      <p>The <monospace>bletl</monospace> package includes the data structures that are common to datasets originating from BioLector I, II and Pro microbioreactors. Parsing of raw data is deferred to <italic toggle="yes">parsers</italic> that may implement logic that is specific to a certain BioLector model or file type. Core functionality and analysis methods are extensively tested by automated testing pipelines for Python versions 3.7, 3.8, and 3.9. Support for Python 3.10 will be added as soon as all dependencies are compatible.</p>
      <sec id="elsc1477-sec-0050">
        <label>2.1.1</label>
        <title>Parsing and data structures</title>
        <p>Parsing of raw data typically begins with a call to the <monospace>bletl.parse</monospace> function, which first determines the file type from its content. The parsing procedure does not only ingest the data into accessible Python data structures, but also takes care of re‐naming tabular data columns to a standardized naming scheme and type‐casting values to integer, float, or string types. After the BioLector model and file type version are identified, a matching <italic toggle="yes">parser</italic> is selected, thereby enabling a plug‐in system for specialized parsers for different file type versions or the new BioLector XT device. The parsing logic is highly dependent on the BioLector model, but generally follows the pattern of first separating the file header of metadata from the table of measurement data. Logical blocks of information, such as the table of filtersets are then parsed into <monospace>pandas.DataFrame</monospace> objects. These tabular data structures are collected as attributes on a <monospace>bletl.BLData</monospace> object which is returned to the user. The <monospace>BLData</monospace> class is a Python dictionary data type with additional <monospace>properties</monospace> and <monospace>methods</monospace>. Via its properties, the user may access various <monospace>DataFrame</monospace> tables of relevant metadata, including the aforementioned tables of filtersets, comments or environment parameters such as chamber temperature or humidity. Users of prototype BioLectors, or the new BioLector XT are invited to contribute parsers to <ext-link xlink:href="https://github.com/JuBiotech/bletl" ext-link-type="uri">https://github.com/JuBiotech/bletl</ext-link>. A UML diagram of the relevant classes is shown in Figure <xref rid="elsc1477-fig-0001" ref-type="fig">1</xref>.</p>
        <fig position="float" fig-type="FIGURE" id="elsc1477-fig-0001">
          <label>FIGURE 1</label>
          <caption>
            <p>UML diagram of relevant classes in the <monospace>bletl</monospace> package. Device‐specific parsers are implemented by inheriting from a common base class that defines the interface needed for integration with the <monospace>bletl.parse</monospace> function (top). Data structures for an entire BioLector dataset (<monospace>BLData</monospace>) and data from one filterset (<monospace>FilterTimeSeries</monospace>) are used to group relevant attributes and provide methods for convenient data access and summarization. Results of the <mml:math id="jats-math-4" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> method are managed as <monospace>GrowthRateResult</monospace> objects, providing various attributes needed for visualization. Custom feature extraction methods, for example to extract model‐based parameters like in [<xref rid="elsc1477-bib-0013" ref-type="bibr">13</xref>], may be implemented by inheriting from the <monospace>Extractor</monospace> base class</p>
          </caption>
          <graphic xlink:href="ELSC-22-242-g008" position="anchor" id="jats-graphic-1"/>
        </fig>
        <p>Key‐value pairs in the <monospace>BLData</monospace> dictionary are the names of filtersets and corresponding <monospace>FilterTimeSeries</monospace> objects. This second important type from the <monospace>bletl</monospace> package hosts all measurements that were obtained with the same filterset. Like the <monospace>BLData</monospace> class it provides additional methods such as <monospace>FilterTimeSeries.get_timeseries</monospace> for easy access of time/value vectors.</p>
      </sec>
    </sec>
    <sec id="elsc1477-sec-0060">
      <label>2.2</label>
      <title>Analysis methods</title>
      <p>In submodules of the <monospace>bletl</monospace> package, various functions are provided to facilitate higher‐throughput and automated data analysis from bioprocess timeseries data.</p>
      <p>One often used feature is the <monospace>find_do_peak</monospace> function that implements a Dissolved Oxygen (DO)‐peak detection heuristic similar to the one found in the m2p‐labs <italic toggle="yes">RoboLector</italic> software. The DO‐peak detection algorithm finds a cycle number corresponding to a DO rise, constrained by user‐provided threshold and delay parameters.</p>
      <p>Additional, more elaborate analysis functions were implemented to allow for advanced data analysis or experimental control.</p>
      <sec id="elsc1477-sec-0070">
        <label>2.2.1</label>
        <title>Spline approximations</title>
        <p>To accommodate for the measurement noise in <italic toggle="yes">on‐line</italic> measured time series, various smoothing procedures may be applied to the raw signal. A popular choice for interpolation are spline functions, specifically <italic toggle="yes">smoothing splines</italic> that can reproduce reasonable interpolations without strong assumptions about the underlying relationship. With <monospace>bletl.get_crossvalidated_smoothing_spline</monospace> we implemented a convenience function for fitting smoothing splines using either <monospace>scipy</monospace> or <monospace>csaps</monospace> [<xref rid="elsc1477-bib-0014" ref-type="bibr">14</xref>, <xref rid="elsc1477-bib-0015" ref-type="bibr">15</xref>] for the underlying implementation Code 1. Both smoothing spline implementations require a hyperparameter that influences the amount of smoothing. Because the choice of the smoothing hyperparameter strongly influences the final result we automatically apply stratified k‐fold cross‐validation for determining its optimal value. The implementation can be found in the code repository of the <monospace>bletl</monospace> project [<xref rid="elsc1477-bib-0016" ref-type="bibr">16</xref>].</p>
        <p>
          <bold>Code 1: Code to obtain a cross validated smoothing spline for pH data</bold>
        </p>
        <p>The user must provide vectors for time and value of a time series to which the spline will be fitted (line 1). A spline is then obtained in line 2, while specifying the preferred spline method. The returned object behaves like a SciPy spline and can, for example, be called on a vector of high‐resolution time points to evaluate interpolated values.</p>
        <p>
          <inline-graphic xlink:href="ELSC-22-242-g009.jpg" xlink:title="image"/>
        </p>
      </sec>
      <sec id="elsc1477-sec-0080">
        <label>2.2.2</label>
        <title>Growth rate analysis</title>
        <p>A “calibration‐free” approach to calculate time‐variable specific growth rate <mml:math id="jats-math-5" display="inline"><mml:mrow><mml:mrow><mml:mi>μ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math> (<xref rid="elsc1477-disp-0001" ref-type="disp-formula">1</xref>) relies on the previously introduced spline approximations, combined with the popular assumption of a linear backscatter <mml:math id="jats-math-6" display="inline"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math> versus biomass <mml:math id="jats-math-7" display="inline"><mml:mrow><mml:mi>X</mml:mi></mml:mrow></mml:math> relationship (<xref rid="elsc1477-disp-0002" ref-type="disp-formula">2</xref>).
<disp-formula id="elsc1477-disp-0001"><label>(1)</label><mml:math id="jats-math-8" display="block"><mml:mrow><mml:mrow><mml:mi>μ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>·</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula>
<disp-formula id="elsc1477-disp-0002"><label>(2)</label><mml:math id="jats-math-9" display="block"><mml:mrow><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mo>·</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>⇔</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>b</mml:mi></mml:mrow><mml:mi>a</mml:mi></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
</p>
        <p>Substituting the biomass <mml:math id="jats-math-10" display="inline"><mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math> in (<xref rid="elsc1477-disp-0001" ref-type="disp-formula">1</xref>), the slope parameter <mml:math id="jats-math-11" display="inline"><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:math> cancels out such that only a “blank” <mml:math id="jats-math-12" display="inline"><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:math> and the measured backscatter <mml:math id="jats-math-13" display="inline"><mml:mrow><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math> are needed for a specific growth rate calculation (<xref rid="elsc1477-disp-0003" ref-type="disp-formula">3</xref>).
<disp-formula id="elsc1477-disp-0003"><label>(3)</label><mml:math id="jats-math-14" display="block"><mml:mrow><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>⇔</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>a</mml:mi></mml:mfrac><mml:mo>·</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>·</mml:mo><mml:mfrac><mml:mi>a</mml:mi><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>⇔</mml:mo><mml:mi>μ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfrac><mml:mo>·</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
</p>
        <p>Finally, the backscatter curve <mml:math id="jats-math-15" display="inline"><mml:mrow><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math> can be approximated by a smoothing spline <mml:math id="jats-math-16" display="inline"><mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>YS</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>blanked</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math> to obtain a differentiable function (<xref rid="elsc1477-disp-0004" ref-type="disp-formula">4</xref>).
<disp-formula id="elsc1477-disp-0004"><label>(4)</label><mml:math id="jats-math-17" display="block"><mml:mrow><mml:mrow><mml:mspace width="1em"/><mml:mi>μ</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>S</mml:mi><mml:mo>˙</mml:mo></mml:mover><mml:mi>YS</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>blanked</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mi>YS</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>blanked</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula>
</p>
        <p>An alternative approach is to construct a <italic toggle="yes">generative</italic> model of the biomass growth. In essence, the time series of observations is modeled as a deterministic function of an initial biomass concentration <mml:math id="jats-math-18" display="inline"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math> and a vector of specific growth rates <mml:math id="jats-math-19" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> at all time points where observations were made. The structure of this model assumes exponential growth between the time steps, which is a robust assumption for high‐frequency time series such as the ones obtained from BioLector processes.
<disp-formula id="elsc1477-disp-0005"><label>(5)</label><graphic xlink:href="ELSC-22-242-e021.jpg" position="float"/></disp-formula>
</p>
        <p>The convenience function <monospace>bletl.growth.fit_mu_t</monospace> creates the generative <mml:math id="jats-math-21" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> model (<xref rid="elsc1477-disp-0005" ref-type="disp-formula">5</xref>) from user‐provided vectors of observation time points <mml:math id="jats-math-22" display="inline"><mml:mrow><mml:mover accent="true"><mml:mi>t</mml:mi><mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:math>, backscatter values <mml:math id="jats-math-23" display="inline"><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:math> and a calibration model built with the <monospace>calibr8</monospace> package. The calibration model used for this study is based on an asymmetric logistic function of the log‐biomass concentration. Most importantly it describes the distribution of backscatter observations that can be expected from an underlying biomass concentration, thereby enabling uncertainty quantification that accounts for precision of the measurement method. A thorough introduction can be found in [<xref rid="elsc1477-bib-0012" ref-type="bibr">12</xref>], but generally a calibration model can be constructed in three steps:
<list list-type="simple" id="elsc1477-list-0001"><list-item><label>1.</label><p><bold>Acquisition of calibration data</bold>, preferably singular replicates at a high number of concentrations ranging three orders of magnitude up to 2−3× the biomass concentration expected in experiments.</p></list-item><list-item><label>2.</label><p>Definition of the model class and <bold>parameter estimation</bold>.</p></list-item><list-item><label>3.</label><p><bold>Quality checks</bold> and iteration over 1‐3 until the quality of the data and model is satisfactory.</p></list-item></list>
</p>
        <p>For calibrations of biomass/backscatter relationships in the BioLector system we recommend the procedure described in the methods section of [<xref rid="elsc1477-bib-0012" ref-type="bibr">12</xref>].</p>
        <p>To contrast this approach from the smooth, continuous <mml:math id="jats-math-24" display="inline"><mml:mrow><mml:mrow><mml:mi>μ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math> from (<xref rid="elsc1477-disp-0004" ref-type="disp-formula">4</xref>) we use the <mml:math id="jats-math-25" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> notation to underline that the approach discretizes the growth rate into a step function. The model is built with the probabilistic programming language PyMC [<xref rid="elsc1477-bib-0017" ref-type="bibr">17</xref>, <xref rid="elsc1477-bib-0018" ref-type="bibr">18</xref>] and an optimal parameter set, the maximum <italic toggle="yes">a‐posteriori</italic> (MAP) estimate, is found automatically by optimization. Additionally, the user may decide to perform Markov‐chain Monte Carlo (MCMC) sampling using advanced sampling algorithms such as No‐U‐Turn Sampler (NUTS) from the PyMC [<xref rid="elsc1477-bib-0017" ref-type="bibr">17</xref>] package to infer probability distributions for the model parameters <mml:math id="jats-math-26" display="inline"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math> and <mml:math id="jats-math-27" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math>. Both MAP and MCMC parameter estimation methods are based on the log‐posterior probability of the model. For MAP estimation the PyMC framework obtains gradients by auto‐differentiation and employs the L‐BFGS‐B minimization algorithm from SciPy. Whereas MAP estimation yields one point in the parameter space with relatively little computational effort, MCMC parameter estimation is more expensive, but yields thousands of points (samples) that approximate the joint posterior probability distribution. For the application shown here, the most relevant advantages of MCMC parameter estimation are the uncertainty quantification of model parameters and the more reliable convergence compared to optimization. For a more comprehensive introduction to Bayesian methods we recommend [<xref rid="elsc1477-bib-0019" ref-type="bibr">19</xref>].</p>
        <p>In the generative <mml:math id="jats-math-28" display="inline"><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> model, the vector of growth rates is modeled with either a Gaussian or Student‐t distributed random walk (Figure <xref rid="elsc1477-fig-0002" ref-type="fig">2</xref>). This does not only result in a smoothing of the growth rate vector, but enables additional flexibility with respect to switchpoints in the growth rate. A <monospace>drift_scale</monospace> parameter must be given to configure the random walk with a realistic assumption of how much growth rate varies over time. Small <monospace>drift_scale</monospace> corresponds to the assumption that growth rate is rather stable, whereas large <monospace>drift_scale</monospace> allows the model to describe a more fluctuating growth rate distribution. On the technical level, the <monospace>drift_scale</monospace> parametrizes the width of the Student‐t random walk prior (<xref rid="elsc1477-disp-0006" ref-type="disp-formula">6</xref>), pulling the values of the random walk closer together, since the prior‐probability is a term in the log‐posterior probability of the model.
<disp-formula id="elsc1477-disp-0006"><label>(6)</label><mml:math id="jats-math-29" display="block"><mml:mrow><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>log</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>prior</mml:mi></mml:msub><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mover><mml:mi>μ</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>=</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mi>logpdf</mml:mi><mml:mi>StudentT</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>·</mml:mo><mml:mspace width="0.33em"/><mml:mo stretchy="true">(</mml:mo><mml:msub><mml:mover><mml:mi>μ</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mover><mml:mi>μ</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mrow><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>drift</mml:mi><mml:mo>_</mml:mo><mml:mi>scale</mml:mi><mml:mo>,</mml:mo><mml:mi>ν</mml:mi><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
</p>
        <fig position="float" fig-type="FIGURE" id="elsc1477-fig-0002">
          <label>FIGURE 2</label>
          <caption>
            <p>Switchpoint detection with a Student‐t random walk. A microbial growth curve with fluctuating specific growth rate <mml:math id="jats-math-30" display="inline"><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:math> may be discretized into segments of exponential growth with constant growth rate (solid lines). Modeling such a sequence of growth rates with a random walk assigns prior probabilities to every value of <mml:math id="jats-math-31" display="inline"><mml:mrow><mml:mrow><mml:mi>μ</mml:mi><mml:mo>∈</mml:mo><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math>, centered on the values of previous iterations (A, colored areas). When fitting the model these prior probabilities “pull” subsequent values in <mml:math id="jats-math-32" display="inline"><mml:mrow><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:math> towards each other, leading to a smoothing and counteracting overfitting. Using a fat‐tailed Student‐t distribution for the random walk prior, the penalty for large jumps is less extreme compared to a Normal distribution, thereby allowing for jumps in the random walk (5th segment)</p>
          </caption>
          <graphic xlink:href="ELSC-22-242-g012" position="anchor" id="jats-graphic-3"/>
        </fig>
        <p>Additionally, the user may provide previously known time points at which growth rate switches are expected. Examples of such switchpoints are the time of induction, occurrence of oxygen limitation or the time at which the carbon source is depleted. If <mml:math id="jats-math-33" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> is described by a Student‐t random walk, switchpoints can be detected automatically by inspecting the prior probabilities of the estimated growth rate in every segment (Figure <xref rid="elsc1477-fig-0002" ref-type="fig">2</xref>). Our implementation automatically classifies elements of <mml:math id="jats-math-34" display="inline"><mml:mrow><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:math> as switchpoints as soon as their prior probability is <mml:math id="jats-math-35" display="inline"><mml:mrow><mml:mrow><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.33em"/><mml:mo>%</mml:mo></mml:mrow></mml:mrow></mml:math>.</p>
        <p>While there has been prior work on using random walks and cumulative sums for outlier detection [<xref rid="elsc1477-bib-0020" ref-type="bibr">20</xref>, <xref rid="elsc1477-bib-0021" ref-type="bibr">21</xref>, <xref rid="elsc1477-bib-0022" ref-type="bibr">22</xref>], we are not aware of prior work using Student‐t random walks for the unsupervised detection of changepoints in time series data. The general idea of modeling exponential growth from a random‐walk of the growth rate was inspired by early versions of the “Rt.live” model of COVID‐19 effective reproduction numbers [<xref rid="elsc1477-bib-0023" ref-type="bibr">23</xref>].</p>
      </sec>
      <sec id="elsc1477-sec-0090">
        <label>2.2.3</label>
        <title>Feature extraction</title>
        <p>The <monospace>bletl.features</monospace> submodule implements functions for the automated extraction of both biologically and statistically motivated time series features. An abstract <monospace>Extractor</monospace> class may be inherited to implement feature extraction of characteristic features such as DO peaks. Additionally, our <monospace>TSFreshExtractor</monospace> uses the open source Python package <monospace>tsfresh</monospace> [<xref rid="elsc1477-bib-0024" ref-type="bibr">24</xref>] to extract hundreds of features from variable length time series automatically. Examples of such features are times of min/max values, quantiles, autocorrelation lags or fourier transform coefficients.</p>
        <p>Starting from a <monospace>bletl.BLData</monospace> object containing one or more <monospace>FilterTimeSeries</monospace>, the <monospace>bletl.features.from_bldata</monospace> function extracts features from multiple filtersets using a user‐specified mapping of <monospace>Extractor</monospace> objects. Optionally, a dictionary of well‐wise cycle numbers can be passed to truncate time series to the relevant cycles. The results are returned as a <monospace>DataFrame</monospace> for maximal compatibility with downstream analysis operations. For details on the implementation we refer to the code and documentation [<xref rid="elsc1477-bib-0016" ref-type="bibr">16</xref>, <xref rid="elsc1477-bib-0025" ref-type="bibr">25</xref>].</p>
        <p>Code 2 shows how the function is applied to our demonstration data set. The resulting <monospace>DataFrame</monospace> comprised 2343 feature columns for each of the 48 wells in the input data. Feature columns with <monospace>NaN</monospace>, <mml:math id="jats-math-36" display="inline"><mml:mrow><mml:mrow><mml:mo>±</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:mrow></mml:math> entries or without variability in their values were dropped, resulting in 1282 features available for further analysis.</p>
        <p>
          <bold>Code 2: Code to run feature extraction from three filtersets</bold>
        </p>
        <p>The name of each filterset is mapped to a list of <monospace>Extractors</monospace> that may include user‐defined feature extraction implementations. The <monospace>last_cycle</monospace> keyword argument can be used to pass a mapping of well IDs to the last relevant cycle numbers. Extracted features are returned in the form of a <monospace>pandas.DataFrame</monospace>
</p>
        <p>
          <inline-graphic xlink:href="ELSC-22-242-g013.jpg" xlink:title="image"/>
        </p>
      </sec>
      <sec id="elsc1477-sec-0100">
        <label>2.2.4</label>
        <title>Visualization by t‐SNE</title>
        <p>Starting from features extracted with <monospace>bletl.features</monospace> we applied the t‐SNE technique to find a two‐dimensional embedding for the visualization of local structure in the dataset [<xref rid="elsc1477-bib-0026" ref-type="bibr">26</xref>]. The general idea behind t‐SNE is to find a low‐dimensional arrangement of records from a high‐dimensional dataset, such that the dissimilarity (Kullback‐Leibler divergence) between the two distributions is minimized [<xref rid="elsc1477-bib-0026" ref-type="bibr">26</xref>]. The method is frequently used for visualization of local structure in complex datasets such as huge collections of images, single‐cell transcriptomics records, or high‐dimensional latent representations of word embeddings obtained from neural networks [<xref rid="elsc1477-bib-0026" ref-type="bibr">26</xref>, <xref rid="elsc1477-bib-0027" ref-type="bibr">27</xref>, <xref rid="elsc1477-bib-0028" ref-type="bibr">28</xref>]. Examples of t‐SNE visualizations are shown in Section 3.4.</p>
        <p>For the application of t‐SNE to BioLector time series, we cleaned extracted features such that features with <monospace>NaN</monospace> values, or without diversity were removed. After feature‐cleaning, the t‐SNE implementation from scikit‐learn was applied with a perplexity setting of 10 and initialization by PCA. The corresponding code can be found in the <xref rid="elsc1477-supl-0001" ref-type="supplementary-material">Supporting material</xref> on GitHub [<xref rid="elsc1477-bib-0029" ref-type="bibr">29</xref>].</p>
      </sec>
    </sec>
    <sec id="elsc1477-sec-0110">
      <label>2.3</label>
      <title>Media and cultivation conditions</title>
      <p>The dataset presented as an application example in this study was obtained in an automated cultivation workflow on the previously described microbial phenotyping platform. 48 cultures of <italic toggle="yes">Corynebacterium glutamicum</italic> ATCC 13032 harboring the pPBEx2[<xref rid="elsc1477-bib-0030" ref-type="bibr">30</xref>]‐based plasmid pCMEx8‐NprE‐Cutinase (GenBank accession number OL456171) were cultivated in CGXII medium (recipe as in [<xref rid="elsc1477-bib-0012" ref-type="bibr">12</xref>]) with different carbon sources. Carbon sources were prepared as C‐equimolar, random combinations of <mml:math id="jats-math-37" display="inline"><mml:mrow><mml:mrow><mml:mn>8</mml:mn><mml:mspace width="0.33em"/><mml:mfrac><mml:msub><mml:mi>g</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mi>L</mml:mi></mml:mfrac></mml:mrow></mml:mrow></mml:math> glucose, fructose, maltose, sucrose, gluconate, lactate, glutamate or <italic toggle="yes">myo</italic>‐inositol. For every well except A01, where glucose was the sole carbon source, three different carbon sources were chosen at random. A total of 140 µL of C‐equimolar carbon source stock were added to each well. The 140 µL were split into seven parts of 20  µL and such that at least one part was used for each selected carbon source and the remaining four parts were assigned randomly. The resulting media composition in terms of pipetted volume, and carbon mass per microliter can be found in Section 4.1.</p>
      <p>Cultivation was done as previously described [<xref rid="elsc1477-bib-0031" ref-type="bibr">31</xref>]. Briefly, 800 µL CGXII medium were inoculated to an optical density at 600 nm of 0.2. Cultures were grown in a MTP‐48‐BOH 1 FlowerPlate in a BioLector Pro (both Beckman Coulter Life Sciences, USA) at 1400 rpm, 30 °C and <mml:math id="jats-math-38" display="inline"><mml:mrow><mml:mo>≥</mml:mo></mml:mrow></mml:math>85% humidity. Expression was induced autonomously with 10 µL isopropyl‐<mml:math id="jats-math-39" display="inline"><mml:mrow><mml:mi>β</mml:mi></mml:mrow></mml:math>‐D‐thiogalactopyranosid (IPTG) (final concentration 100 µM) when cultures reached a backscatter value of 5.82, corresponding to approximately <mml:math id="jats-math-40" display="inline"><mml:mrow><mml:mrow><mml:mn>4</mml:mn><mml:mspace width="0.33em"/><mml:mfrac><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>C</mml:mi><mml:mi>D</mml:mi><mml:mi>W</mml:mi></mml:mrow></mml:msub><mml:mi>L</mml:mi></mml:mfrac></mml:mrow></mml:mrow></mml:math>. Culture from each well was harvested 4 h after induction.</p>
    </sec>
  </sec>
  <sec id="elsc1477-sec-0120">
    <label>3</label>
    <title>RESULTS AND DISCUSSION</title>
    <sec id="elsc1477-sec-0130">
      <label>3.1</label>
      <title>Basic visualization workflow</title>
      <p>Every analysis begins with loading data into a structure that can be used for further analysis. In the case of a BioLector experiment, the data are multiple tables that hold information about filtersets, environment variables such as temperature or humidity, as well as the well‐wise measurements. In most cases the result files already contain relevant meta information such as lot number or process temperature and parsing them with <monospace>bletl</monospace> comes down to a single line of Python (Code 3).</p>
      <p><bold>Code 3</bold>: <bold>Parsing of a BioLector result file</bold></p>
      <p>The <monospace>bletl.parse</monospace> function automatically determines the file type (BioLector I, II or Pro) and applies calibration of optode measurements based on lot number and temperature from the file. Optionally, lot number and temperature, or calibration parameters may be passed to override the values from the file. The function can also process a list of result file paths and automatically concatenate them to a single <monospace>BLData</monospace> object.</p>
      <p>
        <inline-graphic xlink:href="ELSC-22-242-g010.jpg" xlink:title="image"/>
      </p>
      <p>The <monospace>bletl.BLData</monospace> type is a dictionary‐like data structure into which results are loaded. It has additional properties through which process metadata and measurements that are not tied to individual wells can be obtained. Its text representation, which appears when the object is displayed in an interactive Jupyter notebook session shows the names of filtersets and the amount of data they contain (Code 3).</p>
      <p>Elements in the <monospace>BLData</monospace> object are the <monospace>FilterTimeSeries</monospace>, that contain the well‐wise measurements. The simplest way to access the time series of a particular filterset and well is via the <monospace>BLData.get_timeseries(well, filterset)</monospace> or <monospace>FilterTimeSeries.get_timeseries(well)</monospace> methods. Optionally, the user may pass cycle number via the <monospace>last_cycle</monospace> keyword‐argument of <monospace>get_timeseries</monospace> to retrieve only the data up to that specific cycle number. This is useful in situations where wells were sampled and might only be analyzed up to the sampling time point.</p>
      <p>In the dataset presented here, cultures were induced and sampled by a robotic liquid handler. Induction was triggered <italic toggle="yes">at‐line</italic> based on latest backscatter observations and sampling was performed 4 h after the induction events Section <xref rid="elsc1477-sec-0110" ref-type="sec">2.3</xref>. The metadata of these induction and sampling events were logged into an XLSX file and loaded into a <monospace>pandas.DataFrame</monospace> for the analysis Table <xref rid="elsc1477-tbl-0001" ref-type="table">1</xref>.</p>
      <table-wrap position="float" id="elsc1477-tbl-0001" content-type="TABLE">
        <label>TABLE 1</label>
        <caption>
          <p>Excerpt of sampling event log</p>
        </caption>
        <table frame="hsides" rules="groups">
          <col align="left" span="1"/>
          <col align="left" span="1"/>
          <col align="left" span="1"/>
          <col align="left" span="1"/>
          <col align="left" span="1"/>
          <col align="left" span="1"/>
          <thead>
            <tr style="border-bottom:solid 1px #000000">
              <th align="left" rowspan="1" colspan="1">well</th>
              <th align="left" rowspan="1" colspan="1">Timestamp</th>
              <th align="left" rowspan="1" colspan="1">Time</th>
              <th align="left" rowspan="1" colspan="1">Cycle</th>
              <th align="left" rowspan="1" colspan="1">Volume</th>
              <th align="left" rowspan="1" colspan="1">Supernatant_well</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>A01</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">2020‐07‐21T08:10:04.721Z</td>
              <td align="left" rowspan="1" colspan="1">13.076466</td>
              <td align="left" rowspan="1" colspan="1">61</td>
              <td align="left" rowspan="1" colspan="1">−950</td>
              <td align="left" rowspan="1" colspan="1">H01</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>A02</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">2020‐07‐21T07:05:04.299Z</td>
              <td align="left" rowspan="1" colspan="1">11.993016</td>
              <td align="left" rowspan="1" colspan="1">56</td>
              <td align="left" rowspan="1" colspan="1">−950</td>
              <td align="left" rowspan="1" colspan="1">G01</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>A03</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">2020‐07‐21T08:10:04.786Z</td>
              <td align="left" rowspan="1" colspan="1">13.076485</td>
              <td align="left" rowspan="1" colspan="1">61</td>
              <td align="left" rowspan="1" colspan="1">−950</td>
              <td align="left" rowspan="1" colspan="1">F01</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>A04</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">2020‐07‐21T08:10:04.841Z</td>
              <td align="left" rowspan="1" colspan="1">13.076500</td>
              <td align="left" rowspan="1" colspan="1">61</td>
              <td align="left" rowspan="1" colspan="1">−950</td>
              <td align="left" rowspan="1" colspan="1">E01</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>A05</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">2020‐07‐21T06:26:17.384Z</td>
              <td align="left" rowspan="1" colspan="1">11.346651</td>
              <td align="left" rowspan="1" colspan="1">53</td>
              <td align="left" rowspan="1" colspan="1">−950</td>
              <td align="left" rowspan="1" colspan="1">D01</td>
            </tr>
          </tbody>
        </table>
        <permissions>
          <copyright-holder>John Wiley &amp; Sons, Ltd.</copyright-holder>
        </permissions>
      </table-wrap>
      <p>The meta information about induction and sampling events is important for the analysis, because backscatter, pH and DO observations made after a well was <italic toggle="yes">sacrifice</italic>‐sampled must be truncated before analysis or visualization.</p>
      <p>With the data structures provided by our <monospace>bletl</monospace> package, the data analysis workflow for a BioLector experiment is no different to any standard data analysis performed with Python. Such analyses are often driven by interactive exploration of the data. This is facilitated by interactive plots using helper functions from, for example, the <monospace>ipywidgets</monospace> library. Code 4 and Figure <xref rid="elsc1477-fig-0003" ref-type="fig">3</xref> show the code and resulting interactive plot of measurement results from a BioLector dataset. The <monospace>ipywidgets</monospace> library is used to wrap a plotting function and create interactive input elements for selecting the filterset and wells to show.</p>
      <fig position="float" fig-type="FIGURE" id="elsc1477-fig-0003">
        <label>FIGURE 3</label>
        <caption>
          <p>Interactive plot of well‐wise measurements. A <monospace>plot_custom</monospace> function, defined in lines 1‐17 takes a comma‐separated text of well IDs and the name of a filterset as parameters for the visualization. In line 4 it iterates over the well IDs to create lines plots of the measurements, passing the number of the last relevant cycle from the event log (Table <xref rid="elsc1477-tbl-0001" ref-type="table">1</xref>) to truncate the data. Line 21 passes the list of filtersets in the dataset (Code 3) as options for the <monospace>fs</monospace> keyword‐argument of the plotting function, thereby populating the dropdown menu</p>
        </caption>
        <graphic xlink:href="ELSC-22-242-g011" position="anchor" id="jats-graphic-5"/>
      </fig>
      <p>
        <bold>Code 4: Use of <monospace>bletl</monospace> and <monospace>ipywidgets</monospace> to generate an interactive plot</bold>
      </p>
      <p>By using the function <monospace>get_timeseries</monospace>, measurements of specified wells and filtersets are extracted from the dataset. The parameter <monospace>last_cycle</monospace> is used to truncated the vectors according to the sampling time point.</p>
      <p>
        <inline-graphic xlink:href="ELSC-22-242-g007.jpg" xlink:title="image"/>
      </p>
    </sec>
    <sec id="elsc1477-sec-0140">
      <label>3.2</label>
      <title>Splines for time series smoothing and derivatives</title>
      <p>Optical <italic toggle="yes">on‐line</italic> measurements as those performed by the BioLector are inevitably subject to measurement noise. While the measurement noise of DO and pH signals in the BioLector II/Pro system was greatly reduced compared to the BioLector I model, it still requires special attention in subsequent data analysis procedures. Particularly in automated <italic toggle="yes">at‐line</italic> decision making such as triggered induction or sampling, measurement noise can cause problems with threshold‐based heuristics. With noisy <italic toggle="yes">on‐line</italic> signals, such as optode measurements in BioLector I datasets, smoothing splines can yield more accessible visualizations and allow for finer‐grained comparisons. Furthermore, the slope of the signals may be used for more sophisticated analysis or decisions.</p>
      <p>For <italic toggle="yes">at‐line</italic> triggers based on such noisy process values, a smoothing of the signal can increase the reproducibility of detecting, for example, a pH threshold. At the same time, the slope of process values often gives more process insight compared to absolute values alone. For example, a dissolved oxygen tension of 60 % alone is not very meaningful, but the observation of a strong positive slope tells the process engineer that the microbes might grow with reduced oxygen uptake rate. The calculation and visualization of pH and DO slopes is therefore an important tool for process data analysis.</p>
      <p>Splines are a popular choice for both smoothing and derivative calculation, because they make few assumptions about the data and are available in most standard data analysis software. There are however multiple flavors of <italic toggle="yes">smoothing splines</italic> and they come with a smoothing parameter whose value has a considerable effect on the results. In <monospace>bletl.splines</monospace> we implemented a convenience function that automatically performs k‐fold cross‐validation on the smoothing parameter of either a <monospace>UnivariateSpline</monospace> cubic spline from <monospace>scipy</monospace> or a <monospace>UnivariateCubicSmoothingSpline</monospace> from <italic toggle="yes">csaps</italic> (cf. Section <xref rid="elsc1477-sec-0070" ref-type="sec">2.2.1</xref>).</p>
      <p>In Figure <xref rid="elsc1477-fig-0004" ref-type="fig">4</xref> the two spline methods were applied to pH and DO time series of well A01 from our demonstration dataset. Both smoothing spline methods find interpolations (solid lines) of the raw data that are almost indistinguishable. Their 1st derivative however reveals that the <monospace>UnivariateCubicSmoothingSpline</monospace> (ucss) from the <monospace>csaps</monospace> package is much more wiggly compared to the <monospace>UnivariateSpline</monospace> (us) from SciPy.</p>
      <fig position="float" fig-type="FIGURE" id="elsc1477-fig-0004">
        <label>FIGURE 4</label>
        <caption>
          <p>Splines fitted to pH and DO time series. Both spline methods <monospace>“us”</monospace> (blue) and <monospace>“ucss”</monospace> (orange) were applied to measurements of pH (A) and DO (C). The resulting reconstruction/interpolation is largely identical (A, C) with most notable differences between the methods at the start/end, as well as their derivatives (B, D), where the <monospace>“ucss”</monospace> method has considerably more <italic toggle="yes">wiggly</italic> derivatives. With a zoomed‐in time axis (gray area in C) the bottom row <bold>(E, F</bold>) shows extrapolations (dotted lines) of splines fitted to data subsets of different length (solid lines). The <monospace>“ucss”</monospace> method extrapolates in straight lines, whereas the <monospace>“us”</monospace> method extrapolates with a curvature</p>
        </caption>
        <graphic xlink:href="ELSC-22-242-g004" position="anchor" id="jats-graphic-7"/>
      </fig>
      <p>The bottom row shows a comparison of both methods in a simulated <italic toggle="yes">at‐line</italic> situation where the DO time series grows point by point at the time of the characteristic substrate‐depletion DO‐peak. In this situation the <monospace>“us”</monospace> method produces strong alternating positive or negative slopes and curved extrapolation at the end of the curve. In contrast, the splines obtained with the <monospace>“ucss”</monospace> method extrapolate with an (almost) constant slope. Taking both scenarios into account, the choice between the <monospace>“us”</monospace> and <monospace>“ucss”</monospace> depends on the use case. As a rule of thumb, <monospace>“us”</monospace> is more suited when steady derivatives are desired, whereas the more stable extrapolation of the <monospace>“ucss”</monospace> splines should be preferred for <italic toggle="yes">at‐line</italic> applications.</p>
    </sec>
    <sec id="elsc1477-sec-0150">
      <label>3.3</label>
      <title>Growth rate and timeseries analysis</title>
      <p>Most cultivations in microbioreactors such as the BioLector are conducted to extract key performance characteristics of the bioprocesses from the <italic toggle="yes">on‐line</italic> measurements. One such performance indicator is the specific growth rate <mml:math id="jats-math-41" display="inline"><mml:mrow><mml:mi>μ</mml:mi></mml:mrow></mml:math>. In applications where unlimited exponential growth is observed, a constant maximum specific growth rate <mml:math id="jats-math-42" display="inline"><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math> can be calculated by regression with an exponential function [<xref rid="elsc1477-bib-0009" ref-type="bibr">9</xref>]. Many processes however do not fulfill this assumption and require a more detailed analysis with time‐variable specific growth rate. Unlimited exponential growth may be terminated by nutrient limitation, or the characteristics of strain and cultivation media may lead to multiple growth phases. For example, overflow metabolism of <italic toggle="yes">E. coli</italic> growth on glucose can lead to an accumulation of acetic acid which is metabolized in a second growth phase. Accordingly, switchpoints in growth rate can indicate limitations, changes in metabolism or regulation.</p>
      <p>From temporally highly resolved backscatter observations combined with a detailed biomass/backscatter correlation model, variable specific growth rate can be calculated using our <monospace>bletl.growth.fit_mu_t</monospace> function. This model describes the data in a generative fashion by first discretizing time into many segments of exponential growth, followed by simulating the biomass curve resulting from a growth rate that drifts over time. For this it assumes an initial biomass concentration <mml:math id="jats-math-43" display="inline"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math> and a vector of growth rates <mml:math id="jats-math-44" display="inline"><mml:mrow><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:math>, calculates biomass concentrations deterministically and compares them to the observed backscatter using a calibration model built with the <monospace>calibr8</monospace> package [<xref rid="elsc1477-bib-0012" ref-type="bibr">12</xref>]. Parameters <mml:math id="jats-math-45" display="inline"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math> and <mml:math id="jats-math-46" display="inline"><mml:mrow><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:math> can be obtained through optimization or MCMC. In this analysis we specified a prior belief in <mml:math id="jats-math-47" display="inline"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math> centered around 0.25 g/L, corresponding to typical inoculation density for BioLector experiments. The prior for <mml:math id="jats-math-48" display="inline"><mml:mrow><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover></mml:mrow></mml:math> is a random walk of either a Normal or Students‐<italic toggle="yes">t</italic> distribution, which pulls the neighboring entries in the growth rate vector closer to each other, resulting in a smooth drift of <mml:math id="jats-math-49" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> (Section <xref rid="elsc1477-sec-0080" ref-type="sec">2.2.2</xref>). While this method makes few assumptions about the underlying process and therefore can be applied to many datasets, practitioners wanting to encode process knowledge should also consider differential‐equation based modeling approaches for which Python packages such as <monospace>pyFOOMB</monospace> or <monospace>murefi</monospace> can be applied [<xref rid="elsc1477-bib-0012" ref-type="bibr">12</xref>, <xref rid="elsc1477-bib-0032" ref-type="bibr">32</xref>].</p>
      <p>To benchmark the objectivity of the method, we generated a synthetic dataset from a vector of growth rates (Figure <xref rid="elsc1477-fig-0005" ref-type="fig">5 A, B</xref>). The comparison of the inference result with the ground truth (Figure <xref rid="elsc1477-fig-0005" ref-type="fig">5</xref>) shows that with the correct calibration model it yields unbiased estimates of the underlying growth rate. Figure <xref rid="elsc1477-fig-0005" ref-type="fig">5</xref> also shows that the <monospace>drift_scale</monospace> parameter can be tuned to reflect an assumption about the stability of growth rate in the model. Low <monospace>drift_scale</monospace> constrains the model towards stable exponential growth and correspondingly narrow uncertainties (Figure <xref rid="elsc1477-fig-0005" ref-type="fig">5, C, D</xref>). Large <monospace>drift_scale</monospace> on the other hand encodes the prior belief that growth rate is unstable, leading the model to infer rather unstable growth rates with much higher uncertainty (Figure <xref rid="elsc1477-fig-0005" ref-type="fig">5, E, F</xref>). In the example from Figure <xref rid="elsc1477-fig-0005" ref-type="fig">5</xref> a drift scale of 0.0025 gave the best results and enabled the model to detect all switchpoints without additional false positives.</p>
      <fig position="float" fig-type="FIGURE" id="elsc1477-fig-0005">
        <label>FIGURE 5</label>
        <caption>
          <p>Inference of growth rate from a synthetic dataset. A vector of growth rates (A) exhibiting switchpoints and a smooth fluctuation was used to simulate biomass concentrations (not shown) and corresponding backscatter observations (B). The magnitude of the <monospace>drift_scale</monospace> parameter (scale of the Students‐t distribution in the random walk) effects stability, switchpoint detection and uncertainty (C‐F), but in all cases the model fit is unbiased compared to the ground truth. Small <monospace>drift_scale</monospace> settings constrain the model to stable growth rates, which are inferred with little uncertainty (C, D). Large <monospace>drift_scale</monospace> allows for larger variance in the growth rate, leading to more uncertainty and fewer automatically detected switchpoints (E, F). The green density bands visualize the posterior probability density, with dashed lines marking the 5 and 95% percentiles</p>
        </caption>
        <graphic xlink:href="ELSC-22-242-g003" position="anchor" id="jats-graphic-9"/>
      </fig>
      <p>In Figure <xref rid="elsc1477-fig-0006" ref-type="fig">6</xref> we applied our generative <mml:math id="jats-math-50" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> method to data from well F02 of the example dataset. The carbon source composition in this well were three parts fructose, three parts gluconate and one part lactate, causing a change in growth phase at around 9.35 h. The orange line shows the maximum <italic toggle="yes">a‐posteriori</italic> estimate of <mml:math id="jats-math-51" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math>, obtained by optimization. Automatically detected growth rate switchpoints are shown as dashed lines. The green density visualizes the percentiles of the posterior probability distribution of the biomass concentration (left) and growth rate (right). The MAP estimate (orange line),is largely in agreement with the full posterior probability distribution obtained by MCMC. This similarity of MAP and the full posterior distribution is not always the case in Bayesian data analysis, but since the computational runtime to obtain the MAP estimate (seconds) is around 100x lower compared to the runtime of a full MCMC parameter estimation (minutes), it is often the first step when analyzing a new dataset.</p>
      <fig position="float" fig-type="FIGURE" id="elsc1477-fig-0006">
        <label>FIGURE 6</label>
        <caption>
          <p>Model prediction of variable growth rate. Biomass concentrations inferred from backscatter observations (A) are well explained by the drift of specific growth rate over time (B). At two timesteps the specific growth rate changed significantly, which resulted in the automatic detection of switchpoints (vertical dashed orange lines). These switchpoints in <mml:math id="jats-math-52" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> at 9.35 and 10.65 h coincide with changes in the Dissolved Oxygen (DO), indicating a change in cell metabolism. The green density bands visualize the posterior probability density, with dashed lines marking the 5 and 95% percentiles</p>
        </caption>
        <graphic xlink:href="ELSC-22-242-g001" position="anchor" id="jats-graphic-11"/>
      </fig>
      <p>The comparison of growth rate over time (right, orange/green) with dissolved oxygen tension (blue) shows that both detected switchpoints in the growth rate fall together with severe changes in the dissolved oxygen concentration. The first switch from <mml:math id="jats-math-53" display="inline"><mml:mrow><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0.4</mml:mn><mml:mspace width="3.33333pt"/><mml:mfrac><mml:mn>1</mml:mn><mml:mi>h</mml:mi></mml:mfrac></mml:mrow></mml:mrow></mml:math> to <mml:math id="jats-math-54" display="inline"><mml:mrow><mml:mrow><mml:mo>≈</mml:mo><mml:mn>0.2</mml:mn><mml:mspace width="3.33333pt"/><mml:mfrac><mml:mn>1</mml:mn><mml:mi>h</mml:mi></mml:mfrac></mml:mrow></mml:mrow></mml:math> coincides with a temporary increase in DO, whereas the second switch from <mml:math id="jats-math-55" display="inline"><mml:mrow><mml:mrow><mml:mo>≈</mml:mo><mml:mn>0.2</mml:mn><mml:mspace width="3.33333pt"/><mml:mfrac><mml:mn>1</mml:mn><mml:mi>h</mml:mi></mml:mfrac></mml:mrow></mml:mrow></mml:math> to <mml:math id="jats-math-56" display="inline"><mml:mrow><mml:mrow><mml:mo>≈</mml:mo><mml:mn>0.05</mml:mn><mml:mspace width="3.33333pt"/><mml:mfrac><mml:mn>1</mml:mn><mml:mi>h</mml:mi></mml:mfrac></mml:mrow></mml:mrow></mml:math> falls together with the final rise in oxygen concentration.</p>
      <p>One key aspect of growth rate calculation are the assumptions made about the biomass/backscatter relationship. The aforementioned <mml:math id="jats-math-57" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> method relies on a <italic toggle="yes">calibration model</italic> of backscatter versus biomass concentration to simultaneously describe the relationship and measurement noise with a non‐linear calibration model. This raises the question to what extent growth rate may be quantified with less sophisticated calibrations.</p>
      <p>In Figure <xref rid="elsc1477-fig-0007" ref-type="fig">7</xref> we compare the results of a “calibration‐free” <mml:math id="jats-math-58" display="inline"><mml:mrow><mml:mrow><mml:mi>μ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math> spline approach (Section <xref rid="elsc1477-sec-0080" ref-type="sec">2.2.2</xref>) with the <mml:math id="jats-math-59" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> method using linear or logistic calibration models. Note that the “calibration‐free” approach also makes the assumption of a linear relationship between biomass concentration and backscatter observations, just without specifying the slope that cancels out in the growth rate calculation (Section <xref rid="elsc1477-sec-0080" ref-type="sec">2.2.2</xref>).</p>
      <fig position="float" fig-type="FIGURE" id="elsc1477-fig-0007">
        <label>FIGURE 7</label>
        <caption>
          <p>Comparison of growth rate calculation methods. Spline‐based <mml:math id="jats-math-60" display="inline"><mml:mrow><mml:mrow><mml:mi>μ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math> growth rate calculation based on blank subtraction (orange) yields a point estimate that fluctuates considerably compared to the “gold standard” of the generative <mml:math id="jats-math-61" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> method with detailed biomass/backscatter calibration (green). When the generative method is used with linear calibration models, the choice of calibration concentrations and the decision for (blue) or against (red) fixing the intercept at a blank backscatter has considerable effects on the quality of the outcome. The density bands visualize the posterior probability density, with dashed lines marking the 5 and 95 % percentiles</p>
        </caption>
        <graphic xlink:href="ELSC-22-242-g002" position="anchor" id="jats-graphic-13"/>
      </fig>
      <p>Compared to the alternatives, the growth rate curve resulting from the spline method exhibits strong oscillatory artifacts at the beginning of the curve, where the biomass concentration is low. The blue density shows the results of the generative <mml:math id="jats-math-62" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> method combined with a linear biomass/backscatter calibration that uses calibration data up to 6 g/L and fixes the intercept to a blank value. This model can still detect the switchpoints, but is biased towards considerably higher growth rates (blue). In contrast, a linear calibration with 6–30 g/L that does not fix the intercept parameter to a blank value leads to a strong under‐estimation of the growth rate, largely explained by the lack of fit error of the calibration model (Figure S1). For detailed guidance on the construction and diagnosis of calibration models we refer to [<xref rid="elsc1477-bib-0012" ref-type="bibr">12</xref>].</p>
      <p>The strength of non‐linearities in the biomass/backscatter relationship may depend on the BioLector model and device at hand, but from Figure <xref rid="elsc1477-fig-0007" ref-type="fig">7</xref> we must conclude that a realistic, unbiased biomass/backscatter calibration is indispensable. Such a calibration is not necessarily non‐linear, but when quantitative estimates of specific growth rates are desired, practitioners should first perform a thorough acquisition of calibration data before committing to a possibly biased model. Due to the availability of computational fast, unbiased growth rate quantification with the <mml:math id="jats-math-63" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> method, we found no convincing advantages of spline‐based growth rate estimation.</p>
    </sec>
    <sec id="elsc1477-sec-0160">
      <label>3.4</label>
      <title>Time series feature extraction</title>
      <p>It was previously shown that high‐resolution timeseries of culture backscatter can be correlated with product measurements through the use of dimension‐reduction techniques and regression models [<xref rid="elsc1477-bib-0013" ref-type="bibr">13</xref>]. With <monospace>bletl.features</monospace> we provide an implementation for configurable and automated extraction of large numbers of features from bioprocess timeseries data. These features may be used as the input to a broad spectrum of machine learning pipelines making use of techniques such as dimension reduction, regression, unsupervised visualization or clustering.</p>
      <p>To demonstrate how one might use these methods, we applied feature extraction and t‐SNE to the previously introduced dataset to obtain a visualization of local structures in the high‐dimensional data. Probably the most popular example of a t‐SNE visualization are two‐dimensional embeddings of the MNIST handwritten digit dataset. Already with just 48 images from the MNIST dataset, t‐SNE can find a two‐dimensional arrangement of the 784‐dimensional (28 x 28 pixel) records that recovers local similarities between the digits (Figure <xref rid="elsc1477-fig-0008" ref-type="fig">8</xref>).</p>
      <fig position="float" fig-type="FIGURE" id="elsc1477-fig-0008">
        <label>FIGURE 8</label>
        <caption>
          <p>t‐SNE from extracted time series features. Small tiles in subplots BS3, pH and DO correspond to culture wells and were arranged according to the t‐SNE result. The time series inside were truncated at the time of harvest. As with any t‐SNE visualization, the large‐scale arrangement, rotation or axis units are meaningless, since the technique prioritizes local structure. Note that tiles arranged in close proximity are have similar time series characteristics in all three filtersets. For comparison, a t‐SNE embedding of 48 random handwritten 1/2/3 digits from the MNIST dataset is shown in the lower right</p>
        </caption>
        <graphic xlink:href="ELSC-22-242-g005" position="anchor" id="jats-graphic-15"/>
      </fig>
      <p>However, time series from microbioreactors are typically of unequal length and therefore cannot be fed into the t‐SNE algorithm directly. In a preprocessing step the time series must first be transformed into a fixed number of features. For this demonstration example we extracted initially 2343 features from the full dataset using both biologically motivated, as well as the statistical time series feature extractors. The t‐SNE visualization shown in Figure <xref rid="elsc1477-fig-0008" ref-type="fig">8</xref> was then prepared from a cleaned set of 1282 features (Section <xref rid="elsc1477-sec-0090" ref-type="sec">2.2.3</xref>).</p>
      <p>Note that the experiment for this application example was purposely designed to not create clusters by, for example, including multiple replicates of the same medium design. Instead, the randomly distributed medium designs were intended to result in growth phenotypes that can be morphed into each other. And indeed there are examples of such morphing in Figure <xref rid="elsc1477-fig-0008" ref-type="fig">8</xref>, for example the records in the lower‐left are arranged by the strength of the DO‐minimum. Nevertheless, the coloring of the embedding by carbon source composition (Figure <xref rid="elsc1477-fig-0009" ref-type="fig">9</xref>) reveals that the t‐SNE arrangement is strongly correlated with the presence of gluconate, glutamate and particularly lactate in the cultivation supernatant. Hence, without investigating the metabolic details, the application of unsupervised machine learning methods to this BioLector dataset recovered local similarities and revealed that presence of lactate in the medium lead to a distinctive growth phenotype.</p>
      <fig position="float" fig-type="FIGURE" id="elsc1477-fig-0009">
        <label>FIGURE 9</label>
        <caption>
          <p>t‐SNE embedding colored by carbon sources. The color intensity encodes the amount of carbon provided via each of the eight carbon sources. Note that with the exception of one well containing 100 % glucose (dark blue, center right) each well contains three carbon sources. Almost all wells that included lactate as a carbon source are closely arranged in the t‐SNE embedding, indicating that they are in close proximity in the high dimensional feature space. Likewise, gluconate or glutamate containing wells are closely arranged. In contrast, none of the monomeric or dimeric sugars lead to characteristic BS/pH/DO phenotypes</p>
        </caption>
        <graphic xlink:href="ELSC-22-242-g006" position="anchor" id="jats-graphic-17"/>
      </fig>
      <p>The observation that a t‐SNE of extracted time series features does not only recover similarities between individual wells, but also aspects of the experiment design shows that our feature extraction is a viable solution to make BioLector datasets amenable to machine learning methods. In contrast to the extraction of manually engineered features [<xref rid="elsc1477-bib-0013" ref-type="bibr">13</xref>], our feature extraction workflow works out of the box and with few lines of code. The example from Figure <xref rid="elsc1477-fig-0008" ref-type="fig">8</xref> shows that t‐SNE can readily deal with large numbers of feature dimensions, even when there are few records in the dataset. Other machine learning methods however may need redundant features to be removed, for which dimension reduction techniques such as linear discriminant analysis could be applied.</p>
    </sec>
  </sec>
  <sec id="elsc1477-sec-0170">
    <label>4</label>
    <title>CONCLUDING REMARKS</title>
    <p>As we elaborated on in Section <xref rid="elsc1477-sec-0010" ref-type="sec">1</xref>, <monospace>bletl</monospace> is the first (publicly available) Python package to parse and process raw BioLector datasets entirely, without dropping potentially relevant metadata. With the examples in Section <xref rid="elsc1477-sec-0130" ref-type="sec">3.1</xref> we showed how <monospace>bletl</monospace> thereby makes BioLector datasets accessible to standard Python‐based data analysis workflows. The switch to Python‐based data processing facilitates not only interactive and robust data analysis, but also enables the application of machine learning techniques such as crossvalidated smoothing splines to BioLector datasets. Nevertheless, many scientists who are not yet proficient in Python‐based data analysis workflows might be concerned with the initial complexity of the learning curve. That is one of the reasons why the documentation of the <monospace>bletl</monospace> package comes with ready‐to‐use examples. The code of the library is thoroughly tested in automated test pipelines to reduce the chance of unexpected failures.</p>
    <p>In Section <xref rid="elsc1477-sec-0140" ref-type="sec">3.2</xref> we characterized two strategies for smoothing noisy <italic toggle="yes">on‐line</italic> signals and showed that subtle differences in implementation can have substantial consequences on the results. This again highlights the need for standardized data structures, robust data analysis routines and thoroughly tested, open‐sourced implementations that are distributed through versioned releases. Compared to the state of the art in bioprocess research (see Section <xref rid="elsc1477-sec-0010" ref-type="sec">1</xref>) where data analysis scripts are seldomly published and rarely versioned, the analysis submodule of our <monospace>bletl</monospace> package provides generally applicable, transparent and characterized implementations.</p>
    <p>For the analysis of specific growth rate under not necessarily unlimited exponential growth conditions, we presented a random‐walk based <mml:math id="jats-math-64" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> model that can also detect switchpoints automatically. Within seconds our method determines time‐variable growth rates by optimization and by leveraging state of the art probabilistic machine learning, it also quantifies Bayesian uncertainties. We showed on a synthetic dataset that the method is not only unbiased, but also offers the practitioner a tuning knob for the bias‐variance tradeoff between narrow uncertainties and growth rate flexibility (Figure <xref rid="elsc1477-fig-0005" ref-type="fig">5</xref>). While random walks and cumulative sums are well established methods for time series changepoint detection in other fields [<xref rid="elsc1477-bib-0020" ref-type="bibr">20</xref>, <xref rid="elsc1477-bib-0021" ref-type="bibr">21</xref>, <xref rid="elsc1477-bib-0022" ref-type="bibr">22</xref>], we found no instances where this method was applied in the context of specific growth rate estimation. Furthermore, most prior work uses normally distributed random walks, while we have found Student‐t random walks to yield much clearer results.</p>
    <p>In comparison with alternative approaches we found that while analyses with less exact, or even without calibration models may still find the same general trends, a quantitative statement about specific growth rate can only be made with accurate calibrations Figure S1. Observing the popularity of growth rate determination in the bioprocess research community, we view our <mml:math id="jats-math-65" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> as an important contribution to improve objectivity and reproducibility of this metric. Nevertheless, we would like to remind that with some organisms the biomass/backscatter relationship can depend on morphology, requiring much more sophisticated models, or even making it infeasible to determine growth rate from backscatter at all.</p>
    <p>With Section <xref rid="elsc1477-sec-0160" ref-type="sec">3.4</xref> we presented a generally applicable method to extract features for machine learning applications from time series data of microbioreactor experiments. By visualizing the high‐dimensional time series features with t‐SNE we showed that the features indeed have the information content needed to reconstruct patterns from the experimental design. The visualization of a high‐dimensional BioLector dataset in a two‐dimensional arrangement that maintains local structure (Figure <xref rid="elsc1477-fig-0008" ref-type="fig">8</xref>) is just one example of how our <monospace>bletl</monospace> package enriches the exploratory data analysis of microbioreactor experiments.</p>
    <p>Overall we conclude that Python packages to parse experimental data into standardized data structures are a valuable asset for quantitative, qualitative and exploratory research. As of today, <monospace>bletl</monospace> is only able to handle data from BioLector devices. However, it can be extended to other microcultivation devices by implementing additional parser classes. We also welcome contributions and feedback to this open‐source project. For example, more functions for interactive visualizations, tailored to this specific type of datasets, could be added in the future.</p>
  </sec>
  <sec sec-type="COI-statement" id="elsc1477-sec-0190">
    <title>CONFLICT OF INTEREST</title>
    <p>The authors have declared no conflict of interest.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supporting information</title>
    <supplementary-material id="elsc1477-supl-0001" position="float" content-type="local-data">
      <caption>
        <p>Supporting Information.</p>
      </caption>
      <media xlink:href="ELSC-22-242-s001.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="elsc1477-sec-0180">
    <title>ACKNOWLEDGMENTS</title>
    <p>The bletl package was developed by Michael Osthege and Niklas Tenhaef. The random‐walk <mml:math id="jats-math-66" display="inline"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi><mml:mo>⃗</mml:mo></mml:mover><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math> method was devised and implemented by Michael Osthege. Feature extraction and cross validation routines were prototyped by Rebecca Zyla using a comprehensive data set provided by Johannes Hemmerich. The strain and experimental workflow for the dataset used in this study were produced by Carolin Müller. Marco Oldiges, Stephan Noack and Wolfgang Wiechert reviewed the manuscript, organized funding and were responsible for supervision and project coordination. This work was funded by the German Federal Ministry of Education and Research (BMBF, Grant. No. 031B0463A) as part of the project “Digitalization In Industrial Biotechnology”, DigInBio. Open Access publication funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) – 491111487.</p>
  </ack>
  <sec sec-type="data-availability" id="elsc1477-sec-0210">
    <title>DATA AVAILABILITY STATEMENT</title>
    <p>The data is openly available in a public repository (<ext-link xlink:href="https://github.com/JuBiotech/bletl-paper" ext-link-type="uri" specific-use="software is-supplemented-by">https://github.com/JuBiotech/bletl-paper</ext-link>) and issued a DOI (<ext-link xlink:href="https://doi.org/10.5281/zenodo.5235460" ext-link-type="uri" specific-use="dataset is-supplemented-by">https://doi.org/10.5281/zenodo.5235460</ext-link>).</p>
  </sec>
  <ref-list id="elsc1477-bibl-0001">
    <title>REFERENCES</title>
    <ref id="elsc1477-bib-0001">
      <label>1</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0001"><string-name><surname>Nielsen</surname><given-names>J</given-names></string-name>, <string-name><surname>Keasling</surname><given-names>JD</given-names></string-name>. <article-title>Engineering cellular metabolism</article-title>. <source>Cell</source>. <year>2016</year>;<volume>164</volume>(<issue>6</issue>):<fpage>1185</fpage>–<lpage>1197</lpage>.<pub-id pub-id-type="pmid">26967285</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0002">
      <label>2</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0002"><string-name><surname>Rohe</surname><given-names>P</given-names></string-name>, <string-name><surname>Venkanna</surname><given-names>D</given-names></string-name>, <string-name><surname>Kleine</surname><given-names>B</given-names></string-name>, <string-name><surname>Freudl</surname><given-names>R</given-names></string-name>, <string-name><surname>Oldiges</surname><given-names>M</given-names></string-name>. <article-title>An automated workflow for enhancing microbial bioprocess optimization on a novel microbioreactor platform</article-title>. <source>Microb Cell Fact</source>. <year>2012</year>;<volume>11</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>14</lpage>.<pub-id pub-id-type="pmid">22214286</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0003">
      <label>3</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0003"><string-name><surname>Hemmerich</surname><given-names>J</given-names></string-name>, <string-name><surname>Noack</surname><given-names>S</given-names></string-name>, <string-name><surname>Wiechert</surname><given-names>W</given-names></string-name>, <string-name><surname>Oldiges</surname><given-names>M</given-names></string-name>. <article-title>Microbioreactor systems for accelerated bioprocess development</article-title>. <source>Biotechnol J</source>. <year>2018</year>;<volume>13</volume>(<issue>4</issue>):<elocation-id>1700141</elocation-id>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0004">
      <label>4</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0004"><string-name><surname>Vieth</surname><given-names>B</given-names></string-name>, <string-name><surname>Parekh</surname><given-names>S</given-names></string-name>, <string-name><surname>Ziegenhain</surname><given-names>C</given-names></string-name>, <string-name><surname>Enard</surname><given-names>W</given-names></string-name>, <string-name><surname>Hellmann</surname><given-names>I</given-names></string-name>. <article-title>A systematic evaluation of single cell RNA‐seq analysis pipelines</article-title>. <source>Nat Commun</source>. <year>2019</year>;<volume>10</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>11</lpage>.<pub-id pub-id-type="pmid">30602773</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0005">
      <label>5</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0005"><collab collab-type="authors">Tecan OD Analyzer</collab>
. <ext-link xlink:href="https://pypi.org/project/tecan-od-analyzer/" ext-link-type="uri">https://pypi.org/project/tecan‐od‐analyzer/</ext-link>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0006">
      <label>6</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0006"><collab collab-type="authors">wellcompare</collab>
. <ext-link xlink:href="https://pypi.org/project/wellcompare/" ext-link-type="uri">https://pypi.org/project/wellcompare/</ext-link>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0007">
      <label>7</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0007"><string-name><surname>Cruz Bournazou</surname><given-names>M</given-names></string-name>, <string-name><surname>Barz</surname><given-names>T</given-names></string-name>, <string-name><surname>Nickel</surname><given-names>D</given-names></string-name>, et al.. <article-title>Online optimal experimental re‐design in robotic parallel fed‐batch cultivation facilities</article-title>. <source>Biotechnol Bioeng</source>. <year>2017</year>;<volume>114</volume>(<issue>3</issue>):<fpage>610</fpage>–<lpage>619</lpage>.<pub-id pub-id-type="pmid">27696353</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0008">
      <label>8</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0008"><string-name><surname>Jansen</surname><given-names>R</given-names></string-name>, <string-name><surname>Tenhaef</surname><given-names>N</given-names></string-name>, <string-name><surname>Moch</surname><given-names>M</given-names></string-name>, <string-name><surname>Wiechert</surname><given-names>W</given-names></string-name>, <string-name><surname>Noack</surname><given-names>S</given-names></string-name>, <string-name><surname>Oldiges</surname><given-names>M</given-names></string-name>. <article-title>FeedER: a feedback‐regulated enzyme‐based slow‐release system for fed‐batch cultivation in microtiter plates</article-title>. <source>Bioprocess Biosyst Eng</source>. <year>2019</year>;<volume>42</volume>(<issue>11</issue>):<fpage>1843</fpage>–<lpage>1852</lpage>.<pub-id pub-id-type="pmid">31399865</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0009">
      <label>9</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0009"><string-name><surname>Hemmerich</surname><given-names>J</given-names></string-name>, <string-name><surname>Wiechert</surname><given-names>W</given-names></string-name>, <string-name><surname>Oldiges</surname><given-names>M</given-names></string-name>. <article-title>Automated growth rate determination in high‐throughput microbioreactor systems</article-title>. <source>BMC Res Notes</source>. <year>2017</year>;<volume>10</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">28057050</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0010">
      <label>10</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0010"><string-name><surname>McKinney</surname><given-names>W</given-names></string-name>. <part-title>Data Structures for Statistical Computing in Python</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Walt</surname><given-names>S. v. d</given-names></string-name></person-group>, <person-group person-group-type="editor"><string-name><surname>Millman</surname><given-names>J.</given-names></string-name></person-group>, eds. <article-title>
Proc 9th Python Sci CConf
</article-title>. <year>2010</year>:<fpage>56</fpage>‐<lpage>61</lpage>. <pub-id pub-id-type="doi">10.25080/Majora-92bf1922-00a</pub-id>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0011">
      <label>11</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0011">The pandas development team. pandas‐dev/pandas: Pandas. Version latest. Feb. 2020. DOI: 10.5281/zenodo. 3509134. URL: <pub-id pub-id-type="doi">10.5281/zenodo.3509134</pub-id>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0012">
      <label>12</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0012"><string-name><surname>Helleckes</surname><given-names>LM</given-names></string-name>, <string-name><surname>Osthege</surname><given-names>M</given-names></string-name>, <string-name><surname>Wiechert</surname><given-names>W</given-names></string-name>, <string-name><surname>Lieres</surname><given-names>vE</given-names></string-name>, <string-name><surname>Oldiges</surname><given-names>M</given-names></string-name>. <article-title>Bayesian calibration, process modeling and uncertainty quantification in biotechnology</article-title>. <italic toggle="yes">bioRxiv</italic><year>2021</year>. <pub-id pub-id-type="doi">10.1101/2021.06.30.450546</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0013">
      <label>13</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0013"><string-name><surname>Ladner</surname><given-names>T</given-names></string-name>, <string-name><surname>Mühlmann</surname><given-names>M</given-names></string-name>, <string-name><surname>Schulte</surname><given-names>A</given-names></string-name>, <string-name><surname>Wandrey</surname><given-names>G</given-names></string-name>, <string-name><surname>Büchs</surname><given-names>J</given-names></string-name>. <article-title>Prediction of <italic toggle="yes">Escherichia coli</italic> expression performance in microtiter plates by analyzing only the temporal development of scattered light during culture</article-title>. <source>J Biol Eng</source>. <year>2017</year>;<volume>11</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>15</lpage>.<pub-id pub-id-type="pmid">28074108</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0014">
      <label>14</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0014"><string-name><surname>Virtanen</surname><given-names>P</given-names></string-name>, <string-name><surname>Gommers</surname><given-names>R</given-names></string-name>, <string-name><surname>Oliphant</surname><given-names>TE</given-names></string-name>, et al. <article-title>SciPy 1.0: Fundamental Algorithms for Scientific Computing in Python</article-title>. <source>Nat Methods</source>. <year>2020</year>;<volume>17</volume>:<fpage>261</fpage>–<lpage>272</lpage>. <pub-id pub-id-type="doi">10.1038/s41592-019-0686-2</pub-id>.<pub-id pub-id-type="pmid">32015543</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0015">
      <label>15</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0015"><string-name><surname>Prilepin</surname><given-names>E</given-names></string-name>. <article-title>CSAPS ‐ Cubic Spline Approximation (Smoothing)</article-title>. Version 1.0.4. June 8, <year>2021</year>. <ext-link xlink:href="https://github.com/espdev/csaps" ext-link-type="uri">https://github.com/espdev/csaps</ext-link>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0016">
      <label>16</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0016"><string-name><surname>Osthege</surname><given-names>M</given-names></string-name>, <string-name><surname>Tenhaef</surname><given-names>N</given-names></string-name>, <string-name><surname>Helleckes</surname><given-names>L</given-names></string-name>. JuBiotech/bletl: v1.0.0. Version v1.0.0. July 2021. DOI: 10.5281/zenodo.5101435. <pub-id pub-id-type="doi">10.5281/zenodo.5101435</pub-id>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0017">
      <label>17</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0017"><string-name><surname>Salvatier</surname><given-names>J</given-names></string-name>, <string-name><surname>Wiecki</surname><given-names>TV</given-names></string-name>, <string-name><surname>Fonnesbeck</surname><given-names>C</given-names></string-name>. <article-title>Probabilistic programming in Python using PyMC3</article-title>. <source>PeerJ Computer Science</source>. <year>2016</year>;<volume>2</volume>:<fpage>e55</fpage>. DOI: 10.7717/peerj‐cs.55. URL: <pub-id pub-id-type="doi">10.7717/peerj-cs.55</pub-id>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0018">
      <label>18</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0018"><string-name><surname>Salvatier</surname><given-names>J</given-names></string-name>, <string-name><surname>Wiecki</surname><given-names>T</given-names></string-name>, <string-name><surname>Patil</surname><given-names>A</given-names></string-name>, et al. pymc‐devs/pymc3: PyMC3 3.11.2 (14 March 2021). Version v3.11.2. Mar. 2021. DOI: 10.5281/zenodo.4603971. <pub-id pub-id-type="doi">10.5281/zenodo.4603971</pub-id>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0019">
      <label>19</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0019"><string-name><surname>Schoot</surname><given-names>v. dR</given-names></string-name>, <string-name><surname>Depaoli</surname><given-names>S</given-names></string-name>, <string-name><surname>King</surname><given-names>R</given-names></string-name>, et al. <article-title>Bayesian statistics and modelling</article-title>. <source>Nat Rev Methods Primers</source>. <year>2021</year>;<volume>1</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>26</lpage>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0020">
      <label>20</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0020"><string-name><surname>Hinkley</surname><given-names>DV</given-names></string-name>. <article-title>Inference about the change‐point from cumulative sum tests</article-title>. <source>Biometrika</source>. <year>1971</year>;<volume>58</volume>(<issue>3</issue>):<fpage>509</fpage>‐<lpage>523</lpage>. ISSN: 0006‐3444. DOI: 10.1093/biomet/58.3.509.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0021">
      <label>21</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0021"><string-name><surname>Lee</surname><given-names>S</given-names></string-name>, <string-name><surname>Ha</surname><given-names>J</given-names></string-name>, <string-name><surname>Na</surname><given-names>O</given-names></string-name>, <string-name><surname>Na</surname><given-names>S</given-names></string-name>. <article-title>The Cusum Test for Parameter Change in Time Series Models</article-title>. <source>Scand J Stat</source>. <year>2003</year>;<volume>30</volume>(<issue>4</issue>):<fpage>781</fpage>‐<lpage>796</lpage>. DOI: <pub-id pub-id-type="doi">10.1111/1467-9469.00364</pub-id>. eprint:</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0022">
      <label>22</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0022"><string-name><surname>Moonesinghe</surname><given-names>HDK</given-names></string-name>, <string-name><surname>Tan</surname><given-names>PN</given-names></string-name>. <article-title>OutRank: A Graph‐based outlier detection framework using random walk</article-title>. <source>Int J Artif Intell Tools</source>. <year>2008</year>;<volume>17</volume>(<issue>01</issue>):<fpage>19</fpage>‐<lpage>36</lpage>. DOI: <pub-id pub-id-type="doi">10.1142/S0218213008003753</pub-id>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0023">
      <label>23</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0023"><string-name><surname>Systrom</surname><given-names>K</given-names></string-name>, <string-name><surname>Vladek</surname><given-names>T</given-names></string-name>, <string-name><surname>Krieger</surname><given-names>M</given-names></string-name>. Rt.live. <ext-link xlink:href="https://github.com/rtcovidlive/covid-model" ext-link-type="uri">https://github.com/rtcovidlive/covid‐model</ext-link>; 2020.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0024">
      <label>24</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0024"><string-name><surname>Christ</surname><given-names>M</given-names></string-name>, <string-name><surname>Braun</surname><given-names>N</given-names></string-name>, <string-name><surname>Neuffer</surname><given-names>J</given-names></string-name>, <string-name><surname>Kempa‐Liehr</surname><given-names>AW</given-names></string-name>. <article-title>Time Series FeatuRe Extraction on basis of Scalable Hypothesis tests (tsfresh ‐ A Python package)</article-title>. <source>Neurocomputing</source>. <year>2018</year>;<volume>307</volume>:<fpage>72</fpage>‐<lpage>77</lpage>. ISSN: 0925‐2312. DOI: <pub-id pub-id-type="doi">10.1016/j.neucom.2018.03.067</pub-id>. URL:</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0025">
      <label>25</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0025"><monospace>bletl</monospace><ext-link xlink:href="https://bletl.readthedocs.io" ext-link-type="uri">https://bletl.readthedocs.io</ext-link>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0026">
      <label>26</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0026"><string-name><surname>Van der Maaten</surname><given-names>L</given-names></string-name>, <string-name><surname>Hinton</surname><given-names>G</given-names></string-name>. <article-title>Visualizing data using t‐SNE</article-title>. <source>Journal of Machine Learning Research</source>. <year>2008</year>;<volume>9</volume>(<issue>11</issue>). <ext-link xlink:href="https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf" ext-link-type="uri">https://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf</ext-link></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0027">
      <label>27</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0027"><string-name><surname>Kobak</surname><given-names>D</given-names></string-name>, <string-name><surname>Berens</surname><given-names>P</given-names></string-name>. <article-title>The art of using t‐SNE for single‐cell transcriptomics</article-title>. <source>Nat Commun</source>. <year>2019</year>;<volume>10</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>14</lpage>.<pub-id pub-id-type="pmid">30602773</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0028">
      <label>28</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0028"><string-name><surname>Liu</surname><given-names>S</given-names></string-name>, <string-name><surname>Bremer</surname><given-names>PT</given-names></string-name>, <string-name><surname>Thiagarajan</surname><given-names>JJ</given-names></string-name>, et al. <article-title>Visual exploration of semantic relationships in neural word embeddings</article-title>. <source>IEEE Trans Visual Comput Graphics</source>. <year>2017</year>;<volume>24</volume>(<issue>1</issue>):<fpage>553</fpage>–<lpage>562</lpage>.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0029">
      <label>29</label>
      <mixed-citation publication-type="miscellaneous" id="elsc1477-cit-0029"><string-name><surname>Osthege</surname><given-names>M</given-names></string-name>. JuBiotech/bletl‐paper: v1.0.1. Version v1.0.1. Aug. 2021. DOI: 10.5281/zenodo.5235460.</mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0030">
      <label>30</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0030"><string-name><surname>Bakkes</surname><given-names>PJ</given-names></string-name>, <string-name><surname>Ramp</surname><given-names>P</given-names></string-name>, <string-name><surname>Bida</surname><given-names>A</given-names></string-name>, Dohmen‐<string-name><surname>Olma</surname><given-names>D</given-names></string-name>, <string-name><surname>Bott</surname><given-names>M</given-names></string-name>, <string-name><surname>Freudl</surname><given-names>R</given-names></string-name>. <article-title>Improved pEKEx2‐derived expression vectors for tightly controlled production of recombinant proteins in <italic toggle="yes">Corynebacterium glutamicum</italic>
</article-title>. <source>Plasmid</source>. <year>2020</year>;<volume>112</volume>:<elocation-id>102540</elocation-id>. <pub-id pub-id-type="doi">10.1016/j.plasmid.2020.102540</pub-id>.<pub-id pub-id-type="pmid">32991924</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0031">
      <label>31</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0031">Müller C, <string-name><surname>Igwe</surname><given-names>CL</given-names></string-name>, <string-name><surname>Wiechert</surname><given-names>W</given-names></string-name>, <string-name><surname>Oldiges</surname><given-names>M</given-names></string-name>. <article-title>Scaling production of GFP1‐10 detector protein in <italic toggle="yes">E. coli</italic> for secretion screening by split GFP assay</article-title>. <source>Microb Cell Fact</source>. <year>2021</year>;<volume>20</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>11</lpage>. <pub-id pub-id-type="doi">10.1186/s12934-021-01672-6</pub-id>.<pub-id pub-id-type="pmid">33397389</pub-id></mixed-citation>
    </ref>
    <ref id="elsc1477-bib-0032">
      <label>32</label>
      <mixed-citation publication-type="journal" id="elsc1477-cit-0032"><string-name><surname>Hemmerich</surname><given-names>J</given-names></string-name>, <string-name><surname>Tenhaef</surname><given-names>N</given-names></string-name>, <string-name><surname>Wiechert</surname><given-names>W</given-names></string-name>, <string-name><surname>Noack</surname><given-names>S</given-names></string-name>. <article-title>pyFOOMB: Python framework for object oriented modeling of bioprocesses</article-title>. <source>Eng Life Sci</source>. <year>2021</year>;<volume>21</volume>(<issue>3‐4</issue>):<fpage>242</fpage>‐<lpage>257</lpage>. DOI: <pub-id pub-id-type="doi">10.1002/elsc.202000088</pub-id>.<pub-id pub-id-type="pmid">33716622</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
