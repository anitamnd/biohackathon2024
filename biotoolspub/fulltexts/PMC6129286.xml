<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6129286</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/bty597</article-id>
    <article-id pub-id-type="publisher-id">bty597</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Eccb 2018: European Conference on Computational Biology Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genome</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A fast adaptive algorithm for computing whole-genome homology maps</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Jain</surname>
          <given-names>Chirag</given-names>
        </name>
        <xref ref-type="aff" rid="bty597-aff1">1</xref>
        <xref ref-type="aff" rid="bty597-aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Koren</surname>
          <given-names>Sergey</given-names>
        </name>
        <xref ref-type="aff" rid="bty597-aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Dilthey</surname>
          <given-names>Alexander</given-names>
        </name>
        <xref ref-type="aff" rid="bty597-aff2">2</xref>
        <xref ref-type="aff" rid="bty597-aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Phillippy</surname>
          <given-names>Adam M</given-names>
        </name>
        <xref ref-type="aff" rid="bty597-aff2">2</xref>
        <xref ref-type="corresp" rid="bty597-cor1"/>
        <!--<email>adam.phillippy@nih.gov</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Aluru</surname>
          <given-names>Srinivas</given-names>
        </name>
        <xref ref-type="aff" rid="bty597-aff1">1</xref>
        <xref ref-type="corresp" rid="bty597-cor1"/>
        <!--<email>aluru@cc.gatech.edu</email>-->
      </contrib>
    </contrib-group>
    <aff id="bty597-aff1"><label>1</label>School of Computational Science and Engineering, Georgia Institute of Technology, Atlanta, GA, USA</aff>
    <aff id="bty597-aff2"><label>2</label>Genome Informatics Section, Computational and Statistical Genomics Branch, National Human Genome Research Institute, National Institutes of Health, Bethesda, MD, USA</aff>
    <aff id="bty597-aff3"><label>3</label>Institute of Medical Microbiology, University Hospital of Düsseldorf, Düsseldorf, Germany</aff>
    <author-notes>
      <corresp id="bty597-cor1">To whom correspondence should be addressed. E-mail: <email>adam.phillippy@nih.gov</email> or <email>aluru@cc.gatech.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>01</day>
      <month>9</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2018-09-08">
      <day>08</day>
      <month>9</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>08</day>
      <month>9</month>
      <year>2018</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>34</volume>
    <issue>17</issue>
    <fpage>i748</fpage>
    <lpage>i756</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2018. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2018</copyright-year>
      <license license-type="cc-by" xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="bty597.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Whole-genome alignment is an important problem in genomics for comparing different species, mapping draft assemblies to reference genomes and identifying repeats. However, for large plant and animal genomes, this task remains compute and memory intensive. In addition, current practical methods lack any guarantee on the characteristics of output alignments, thus making them hard to tune for different application requirements.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We introduce an approximate algorithm for computing local alignment boundaries between long DNA sequences. Given a minimum alignment length and an identity threshold, our algorithm computes the desired alignment boundaries and identity estimates using kmer-based statistics, and maintains sufficient probabilistic guarantees on the output sensitivity. Further, to prioritize higher scoring alignment intervals, we develop a plane-sweep based filtering technique which is theoretically optimal and practically efficient. Implementation of these ideas resulted in a fast and accurate assembly-to-genome and genome-to-genome mapper. As a result, we were able to map an error-corrected whole-genome NA12878 human assembly to the hg38 human reference genome in about 1 min total execution time and &lt;4 GB memory using eight CPU threads, achieving significant improvement in memory-usage over competing methods. Recall accuracy of computed alignment boundaries was consistently found to be <inline-formula><mml:math id="IM1"><mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>97</mml:mn><mml:mi>%</mml:mi></mml:mrow></mml:math></inline-formula> on multiple datasets. Finally, we performed a sensitive self-alignment of the human genome to compute all duplications of length ≥1 Kbp and <inline-formula><mml:math id="IM2"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>90</mml:mn><mml:mi>%</mml:mi></mml:mrow></mml:math></inline-formula> identity. The reported output achieves good recall and covers twice the number of bases than the current UCSC browser’s segmental duplication annotation.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>
          <ext-link ext-link-type="uri" xlink:href="https://github.com/marbl/MashMap">https://github.com/marbl/MashMap</ext-link>
        </p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">Intramural Research Program</named-content>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">National Human Genome Research Institute</named-content>
          <named-content content-type="funder-identifier">10.13039/100000051</named-content>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">National Institutes of Health</named-content>
          <named-content content-type="funder-identifier">10.13039/100000002</named-content>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">U.S. National Science Foundation</named-content>
        </funding-source>
        <award-id>CCF-1816027</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Algorithms for inferring homology between DNA sequences have undergone continuous advances for &gt;3 decades, mainly in the direction of achieving better accuracy to compare distant genomes, as well as better compute efficiency to scale with growing data. Up until the last decade, reconstruction of a complete reference genome through sequencing and assembly was deemed a major landmark in genomics (<xref rid="bty597-B19" ref-type="bibr">Lander <italic>et al.</italic>, 2001</xref>; <xref rid="bty597-B32" ref-type="bibr">Venter <italic>et al.</italic>, 2001</xref>). However, it did not take long for high-throughput sequencing technologies to fuel population-wide genomics projects through low-cost genome assemblies (e.g. the Genome 10 K project, <xref rid="bty597-B10" ref-type="bibr">Haussler <italic>et al.</italic>, 2009</xref>). Analysis of these new genome assemblies, for both population-scale biological studies and timely diagnosis in clinical settings, requires faster and memory-efficient algorithms for facilitating whole-genome comparisons.</p>
    <p>It is well-known that computing local alignments using an exact dynamic programming algorithm at the whole-genome scale is computationally prohibitive. This bottleneck motivated the development of seed-and-extend based genome aligners. Within the seed-and-extend paradigm, the two common approaches adopted to compute exact matches are either implemented using a hash table for <italic>k</italic>-mers (e.g. <xref rid="bty597-B1" ref-type="bibr">Altschul <italic>et al.</italic>, 1997</xref>; <xref rid="bty597-B22" ref-type="bibr">Ma <italic>et al.</italic>, 2002</xref>; <xref rid="bty597-B29" ref-type="bibr">Schwartz <italic>et al.</italic>, 2003</xref>; <xref rid="bty597-B34" ref-type="bibr">Yorukoglu <italic>et al.</italic>, 2016</xref>) or suffix trees and its variants (<xref rid="bty597-B6" ref-type="bibr">Brudno <italic>et al.</italic>, 2003</xref>; <xref rid="bty597-B5" ref-type="bibr">Bray <italic>et al.</italic>, 2003</xref>; <xref rid="bty597-B7" ref-type="bibr">Delcher <italic>et al.</italic>, 1999</xref>; <xref rid="bty597-B23" ref-type="bibr">Marçais <italic>et al.</italic>, 2018</xref>; <xref rid="bty597-B33" ref-type="bibr">Vyverman <italic>et al.</italic>, 2013</xref>). A third category includes cross-correlation based algorithms (e.g. Satsuma by <xref rid="bty597-B9" ref-type="bibr">Grabherr <italic>et al.</italic>, 2010</xref>). However, these approaches still remain computationally intensive. For instance, Nucmer (<xref rid="bty597-B18" ref-type="bibr">Kurtz <italic>et al.</italic>, 2004</xref>) and LAST (<xref rid="bty597-B16" ref-type="bibr">Kiełbasa <italic>et al.</italic>, 2011</xref>), two widely used genome-to-genome aligners, require 10 or more CPU hours to align a human genome assembly to a human reference genome.</p>
    <p>The primary motivation behind this work is to develop a new genome-to-genome mapping algorithm that is fast and memory-efficient while maintaining accuracy on par with sensitive aligners. We seek a new problem formulation that also provides a convenient handle for users to specify how diverged the input genomes are, based on their knowledge of which organisms are being compared, expected quality of genome assembly, and sensitivity requirements of any further downstream biological analysis.</p>
    <p>The inspiration behind our algorithmic strategy stems from recent developments in techniques for long-read analyses. MinHash-based estimation of Jaccard similarity of <italic>k</italic>-mer sets between DNA sequences has been adopted for state-of-the-art long read genome assembly (<xref rid="bty597-B17" ref-type="bibr">Koren <italic>et al.</italic>, 2017</xref>) and long read mapping (<xref rid="bty597-B13" ref-type="bibr">Jain <italic>et al.</italic>, 2017</xref>). Through our previous work Mashmap (<xref rid="bty597-B13" ref-type="bibr">Jain <italic>et al.</italic>, 2017</xref>), we demonstrated that a MinHash-based approximate mapping algorithm can compute long-read mapping boundaries with accuracy on par with alignment-based methods, while exhibiting two orders of magnitude speedup. Mashmap operates by assuming an error-distribution model, links alignment identity to Jaccard similarity, and provides probabilistic guarantees on output sensitivity. However, this algorithm is limited to end-to-end mapping of input sequences, which makes it impractical for contig mapping or <italic>split-read</italic> mapping. Here, we introduce new algorithmic strategies to compute local alignment boundaries for both whole-genome and split-read mapping applications.</p>
    <p>Given minimum identity and length requirements for local alignments, we formulate the characteristics of homologies we intend to compute. Our new algorithm internally makes use of our previous end-to-end approximate read mapping framework (<xref rid="bty597-B13" ref-type="bibr">Jain <italic>et al.</italic>, 2017</xref>) by applying it to non-overlapping substrings of the query sequence. We mathematically show that all valid local alignment boundaries, which satisfy the user-specified alignment identity and length thresholds, are reported with high probability. Further, we formulate a heuristic to prioritize mappings with higher scores. We leverage the classic plane-sweep technique from computational geometry to develop an <inline-formula><mml:math id="IM3"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> algorithm to solve the filtering problem, with <italic>n</italic> being the count of total mappings.</p>
    <p>We demonstrate the practical utility of our algorithm Mashmap2 by evaluating accuracy and computational performance using real data instances, which include mapping mammalian genome assemblies and ultra-long nanopore reads to the reference genomes, and sensitive self-alignment analysis of the human genome. We compared the performance of Mashmap2 against a recent fast alignment-free method Minimap2 (<xref rid="bty597-B20" ref-type="bibr">Li, 2018</xref>) and the widely used alignment-based method Nucmer (<xref rid="bty597-B18" ref-type="bibr">Kurtz <italic>et al.</italic>, 2004</xref>; <xref rid="bty597-B23" ref-type="bibr">Marçais <italic>et al.</italic>, 2018</xref>). Mashmap2 operates in about a minute and 4 GB memory, including both indexing and mapping stages, to map human genome assembly to a reference when given minimum alignment identity and length requirements of 95% and 10 Kbp, respectively. This makes it one of the most resource-efficient software for genome-to-genome mapping, especially with respect to the memory-usage. This performance is achieved while maintaining output sensitivity percentage in the high 90 s. We also demonstrate its direct applicability in computing all ≥1 Kbp long duplications in the human genome with high accuracy. We expect that the performance and sensitivity guarantees provided by our algorithm will allow fast evaluation of draft assemblies versus a reference genome, scalable construction of whole-genome homology maps, and rapid split-read mapping of long reads to large reference databases.</p>
  </sec>
  <sec>
    <title>2 The Mashmap2 algorithm</title>
    <p>We designed Mashmap2 to enable fast computation of homology maps between two sequences or a sequence and itself. It consists of two algorithmic components. The first computes approximate boundaries and alignment scores for all pairs of substrings that exceed a user specified length and identity threshold. The second applies a novel filtering algorithm to optionally weed out redundant, paralogous mappings.</p>
    <sec>
      <title>2.1 Computing local alignment boundaries</title>
      <p>Consider all local mappings of the form <inline-formula><mml:math id="IM4"><mml:mrow><mml:mi>Q</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mn>..</mml:mn><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> between sequences <italic>Q</italic> (query) and <italic>R</italic> (reference) of length <italic>l</italic><sub>0</sub> or more, such that <inline-formula><mml:math id="IM5"><mml:mrow><mml:mi>Q</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mn>..</mml:mn><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> aligns with a substring of <italic>R</italic> with per-base error-rate <inline-formula><mml:math id="IM6"><mml:mrow><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mtext>ε</mml:mtext></mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="IM7"><mml:mrow><mml:mo>|</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>|</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Alignment algorithms have quadratic time complexity, therefore an exact evaluation of the local mappings between all possible substring combinations will require at least <inline-formula><mml:math id="IM8"><mml:mrow><mml:mi>Ω</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>Q</mml:mi><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. As such, solving this problem exactly is computationally prohibitive for typical sizes of real datasets. Instead of explicitly computing all such structures, we seek at least one inexact seed mapping of length <inline-formula><mml:math id="IM9"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> along the path of each optimal alignment. Doing so, while maintaining high sensitivity and sufficient specificity will allow computation of the local alignments efficiently using an appropriate alignment algorithm.</p>
      <p>In our approach, we leverage our previous alignment-free end-to-end read mapping algorithm, designed for mapping noisy long reads (<xref rid="bty597-B13" ref-type="bibr">Jain <italic>et al.</italic>, 2017</xref>). This allows us to benefit from its attractive properties including probabilistic guarantees on quality, and algorithmic and space efficiency. We continue to assume the same error model that was used in this work, also restated here. We assume that alignment errors, i.e, substitutions and indels in a valid alignment, occur independently and follow a Poisson distribution. We also simplify by assuming that <italic>k</italic>-mers are independent entities in sequences. For a given per-base error rate threshold <inline-formula><mml:math id="IM10"><mml:mrow><mml:msub><mml:mrow><mml:mtext>ε</mml:mtext></mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, the read-mapping algorithm reports all target mapping coordinates and identity estimates of a read in the reference, where it aligns end-to-end with <inline-formula><mml:math id="IM11"><mml:mrow><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mtext>ε</mml:mtext></mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> per-base error rate, with high probability. This is achieved by linking Jaccard coefficient between the <italic>k</italic>-mer spectra of the read and its mapping region to the alignment-error rate, under the assumed error distribution model.</p>
      <sec>
        <title>2.1.1 Proposed algorithm</title>
        <p>We first split the query sequence <italic>Q</italic> into <inline-formula><mml:math id="IM12"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> sized non-overlapping fragments. If a substring of <italic>Q</italic>, say <italic>Q<sub>sub</sub></italic>, of length <inline-formula><mml:math id="IM13"><mml:mrow><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> aligns against a substring of <italic>R</italic> with <inline-formula><mml:math id="IM14"><mml:mrow><mml:mtext>ε</mml:mtext><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mtext>ε</mml:mtext></mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> per-base error rate, then following statements hold true:
<list list-type="bullet"><list-item><p>There is at least one <inline-formula><mml:math id="IM15"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> sized query fragment that maps end-to-end along the optimal alignment path. This is because at least <inline-formula><mml:math id="IM16"><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>u</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> fragments completely span <italic>Q<sub>sub</sub></italic> (see <xref ref-type="fig" rid="bty597-F1">Fig. 1</xref>).</p></list-item><list-item><p>Under the assumed error distribution, the expected count of errors in a sub-interval is proportional to its length. Therefore, the above <inline-formula><mml:math id="IM17"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> sized fragment should map along the optimal alignment path with <inline-formula><mml:math id="IM18"><mml:mrow><mml:mtext>ε</mml:mtext><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> expected errors.</p></list-item></list></p>
        <fig id="bty597-F1" orientation="portrait" position="float">
          <label>Fig. 1.</label>
          <caption>
            <p>A local alignment depicting the inclusion of a length <inline-formula><mml:math id="IM19"><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> fragment of the query sequence</p>
          </caption>
          <graphic xlink:href="bty597f1"/>
        </fig>
        <p>Accordingly, the read mapping routine in Mashmap can be used to map each fragment with <inline-formula><mml:math id="IM20"><mml:mrow><mml:msub><mml:mrow><mml:mtext>ε</mml:mtext></mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> error-rate threshold. Let <italic>p</italic> be the probability that a fragment is mapped to the desired target position on the reference, computed as described by <xref rid="bty597-B13" ref-type="bibr">Jain <italic>et al.</italic> (2017)</xref>. Probability of reporting at least one seed mapping along the optimal alignment is given by <inline-formula><mml:math id="IM21"><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>u</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mtext> </mml:mtext><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. We show that these probability scores are sufficiently high, between 0.92 and 1.00 for alignment error rate thresholds <inline-formula><mml:math id="IM22"><mml:mrow><mml:msub><mml:mrow><mml:mtext>ε</mml:mtext></mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of 10% and 20%, respectively (<xref ref-type="fig" rid="bty597-F2">Fig. 2</xref>).</p>
        <fig id="bty597-F2" orientation="portrait" position="float">
          <label>Fig. 2.</label>
          <caption>
            <p>Probability of mapping at least one seed fragment for two different error-rate thresholds <inline-formula><mml:math id="IM23"><mml:mrow><mml:msub><mml:mrow><mml:mtext>ε</mml:mtext></mml:mrow><mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>10</mml:mn><mml:mi>%</mml:mi><mml:mo>,</mml:mo><mml:mn>20</mml:mn><mml:mi>%</mml:mi></mml:mrow></mml:math></inline-formula>. As true error rate <inline-formula><mml:math id="IM24"><mml:mtext>ε</mml:mtext></mml:math></inline-formula> decreases, the probability values accordingly improve as expected. Similarly, longer alignments spanning more fragments are more likely to be reported. Most importantly, all the sensitivity scores are consistently above 90%. To compute the probability values, sketch size for Minhash based Jaccard estimation was assumed as 200, and the <italic>k</italic>-mer size was set to 16. These parameter values are internally computed by Mashmap (<xref rid="bty597-B13" ref-type="bibr">Jain <italic>et al.</italic>, 2017</xref>)</p>
          </caption>
          <graphic xlink:href="bty597f2"/>
        </fig>
        <p>The above seed matches and their alignment identity estimates are further processed to compute approximate local boundaries and their scores. After computing all seed matches, matches which involve consecutive query sequence fragments are merged together if they are mapped closely in the same order on the reference sequence. Suppose mappings from the consecutive query fragments <inline-formula><mml:math id="IM25"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are mapped to reference positions with begin positions <inline-formula><mml:math id="IM26"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, respectively, then they are grouped together as a local alignment segment if <inline-formula><mml:math id="IM27"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mo>…</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="IM28"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. The alignment boundaries are estimated as the first and last mapping offsets of the group. The corresponding alignment scores are estimated as their average identity estimate multiplied by the sum of the fragment lengths. We use these alignment boundaries and the scores as input to a subsequent filtering algorithm.</p>
      </sec>
    </sec>
    <sec>
      <title>2.2 A geometric algorithm for filtering alignments</title>
      <p>Large mammalian genomes and plant genomes have abundant repetitive sequences. As a consequence, a large fraction of inferior mappings are reported due to paralogous genomic segments or false positive mappings resulting from simple sequence repeats. Furthermore, from a biological perspective, closely examining all alternative mappings may not be feasible. Therefore, different strategies are adopted to identify biologically relevant outputs. We formulate a filtering heuristic for our mapping application, and develop an <inline-formula><mml:math id="IM29"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> algorithm to solve it. We also prove that <inline-formula><mml:math id="IM30"><mml:mrow><mml:mi>Ω</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> runtime is necessary to solve this problem. The effectiveness of this algorithm on real genomic data is demonstrated later, in the Results section.</p>
      <sec>
        <title>2.2.1 Problem formulation</title>
        <p>Suppose all output mappings of a query sequence are laid out as weighted segment intervals, with the alignment scores used as weights (<xref ref-type="fig" rid="bty597-F3">Fig. 3</xref>). We propose the following filtering heuristic: a segment is termed redundant if and only if it is subsumed by higher scoring segments at all of its positions. Therefore, the objective is to identify all <italic>good</italic> (non-redundant) segments. In practice, there can be multiple alignments with equal scores. Therefore, segment scores are allowed to be non-unique.</p>
        <fig id="bty597-F3" orientation="portrait" position="float">
          <label>Fig. 3.</label>
          <caption>
            <p>Left figure is a toy example to illustrate line segments corresponding to multiple local alignments obtained between a query and reference sequence. Each alignment segment is labeled with an alignment score. Suppose we want to filter best mappings for the query sequence. These segments are laid out as weighted intervals over the query sequence (right figure). In the above case, two intervals marked with a cross are completely subsumed by higher scoring intervals, and therefore, will be labeled as redundant by our filtering heuristic</p>
          </caption>
          <graphic xlink:href="bty597f3"/>
        </fig>
        <p>A sub-optimal <inline-formula><mml:math id="IM31"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> algorithm for solving the above problem can be readily developed by doing an all to all comparison among the segments. However, it would lead to practically slow implementation for typical input sizes. The formulated filtering problem bears resemblance to the line segment intersection test problem for which <xref rid="bty597-B30" ref-type="bibr">Shamos and Hoey (1976)</xref> gave a classic <inline-formula><mml:math id="IM32"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> algorithm using plane-sweep technique. Accordingly, we summarize their algorithm next, and subsequently describe the modifications made to solve the filtering problem.</p>
      </sec>
      <sec>
        <title>2.2.2 The Shamos–Hoey algorithm</title>
        <p>Similar to the filtering problem, the problem of detecting whether <italic>n</italic> segments have an intersecting pair has a trivial <inline-formula><mml:math id="IM33"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> solution. Shamos and Hoey solved this problem using a plane-sweep based <inline-formula><mml:math id="IM34"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time algorithm. The algorithm defines an ordering between segments in the 2D plane. The main loop of the algorithm conceptually <italic>sweeps</italic> a vertical line from left to right, and while doing so, the sweep-line status data-structure <inline-formula><mml:math id="IM35"><mml:mi>ℒ</mml:mi></mml:math></inline-formula> dynamically holds segments which intersect the sweep-line. The sweep-line halts at 2<italic>n</italic> endpoints of the input segments, and the order of segments in <inline-formula><mml:math id="IM36"><mml:mi>ℒ</mml:mi></mml:math></inline-formula> is evaluated to detect any intersection. For efficiency, this algorithm chooses a balanced tree to implement the sweep-line status <inline-formula><mml:math id="IM37"><mml:mi>ℒ</mml:mi></mml:math></inline-formula>. As such, it spends <inline-formula><mml:math id="IM38"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time at each halting point, and therefore, the total runtime is bounded by <inline-formula><mml:math id="IM39"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This algorithm is popular not only for its theoretical and practical efficiency, but also for ease of implementation.</p>
        <p>In our problem as well, evaluating segments which intersect the vertical sweep-line at 2<italic>n</italic> endpoints is sufficient to identify all <italic>good</italic> segments. However, evaluating all intersecting segments at each endpoint is inefficient, and again leads to a quadratic algorithm. Therefore, we devise a new ordering scheme among segments which will enable us to evaluate only a subset of intersecting segments at each endpoint.</p>
      </sec>
      <sec>
        <title>2.2.3 Proposed algorithm for alignment filtering</title>
        <p>We define an order between segments as follows: Between two segments, the segment with higher score is considered as greater, but if the scores are equal, then the segment with the latter starting position is considered as greater. This particular ordering helps avoid redundant computations, and will be crucial for bounding the runtime later.</p>
        <p>Similar to the Shamos–Hoey algorithm, we also use a height-balanced Binary Search Tree (BST) as the data-structure for the sweep-line status <inline-formula><mml:math id="IM40"><mml:mi>ℒ</mml:mi></mml:math></inline-formula>, which tracks the segments that intersect the vertical sweep line. <inline-formula><mml:math id="IM41"><mml:mi>ℒ</mml:mi></mml:math></inline-formula> is required to support the following operations in our algorithm:
<list list-type="order"><list-item><p><italic>insert</italic>(<italic>s</italic>). Insert segment <italic>s</italic> into <inline-formula><mml:math id="IM42"><mml:mi>ℒ</mml:mi></mml:math></inline-formula>.</p></list-item><list-item><p><italic>delete</italic>(<italic>s</italic>). Delete segment <italic>s</italic> from <inline-formula><mml:math id="IM43"><mml:mi>ℒ</mml:mi></mml:math></inline-formula>.</p></list-item><list-item><p><italic>mark_good</italic>(). Mark all segments with highest score as <italic>good</italic> in <inline-formula><mml:math id="IM44"><mml:mi>ℒ</mml:mi></mml:math></inline-formula>.</p></list-item></list></p>
        <p>Note that the <italic>insert</italic> and <italic>delete</italic> operations are naturally supported in <inline-formula><mml:math id="IM45"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time in BSTs, whereas the <italic>mark_good</italic> function can be realized as a sequence of <italic>maximum</italic> and <italic>predecessor</italic> operations. If there are <italic>k</italic> segments with equal and highest scores in <inline-formula><mml:math id="IM46"><mml:mi>ℒ</mml:mi></mml:math></inline-formula>, the function <italic>mark_good</italic> uses <inline-formula><mml:math id="IM47"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. With the data-structures and the operations defined above, we give an outline of the complete filtering procedure in Algorithm 1. The main loop of the algorithm iterates over the 2<italic>n</italic> segment endpoints, which is analogous to the sweep line moving from left to right, halting at the 2<italic>n</italic> points. In each iteration, we update the sweep-line status <inline-formula><mml:math id="IM48"><mml:mi>ℒ</mml:mi></mml:math></inline-formula> so that it holds the segments which intersect the sweep line, and mark the highest-scoring segments as <italic>good</italic> using the <italic>mark_good</italic> function.<statement><title>Lemma 1. </title><p>Algorithm 1 solves the filtering problem correctly.</p><p><boxed-text id="bty597-BOX1" position="float" orientation="portrait"><sec><title>Algorithm 1. Plane-sweep based alignment filtering algorithm</title><p><inline-graphic xlink:href="bty597ilf1.jpg"/></p></sec></boxed-text></p></statement><statement><title>Proof. </title><p>Consider a function <inline-formula><mml:math id="IM49"><mml:mrow><mml:mi>S</mml:mi><mml:mo>:</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> from positions in the query sequence to subsets of segments <inline-formula><mml:math id="IM50"><mml:mrow><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. A segment <inline-formula><mml:math id="IM51"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> if and only if it is among the highest scoring segments which overlap with the query sequence at position <italic>pos.</italic> Clearly, a union of all subsets in the domain of function <italic>S</italic> equals the set of <italic>good</italic> segments. If we perform a linear scan on the domain, from begin to end position of the query sequence, then value of <italic>S</italic> can change only at the 2<italic>n</italic> endpoints of the segments. Therefore, the highest scoring segments overlapping at the 2<italic>n</italic> endpoints constitute the set of <italic>good</italic> segments, which is precisely what Algorithm 1 computes.□</p></statement></p>
        <p>We make an additional modification to the above algorithm for efficiency, specifically in the <italic>mark_good</italic> function. In this function, we mark the highest scoring segments in the tree <inline-formula><mml:math id="IM52"><mml:mi>ℒ</mml:mi></mml:math></inline-formula> as <italic>good.</italic> We execute this by traversing the segments in decreasing order in <inline-formula><mml:math id="IM53"><mml:mi>ℒ</mml:mi></mml:math></inline-formula>, starting from the maximum. However, we terminate the traversal if a segment is observed as marked <italic>good</italic> already. This helps to avoid redundant computations, and the algorithm still remains correct due to the following property:<statement><title>Lemma 2. </title><p>Consider all the segments with equal and highest scores in <inline-formula><mml:math id="IM54"><mml:mi>ℒ</mml:mi></mml:math></inline-formula>: <inline-formula><mml:math id="IM55"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, ordered in non-increasing manner. Suppose segment s<sub>j</sub> has been marked good in one of the previous iterations of the algorithm, then the segments <inline-formula><mml:math id="IM56"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> must have already been marked good as well.</p></statement><statement><title>Proof. </title><p>The aforementioned property is satisfied by default during the first iteration of the algorithm because there cannot be any previously marked segments. Suppose this property remains true till iteration <italic>i</italic>, and we are currently executing iteration <italic>i</italic> + 1. Segments <inline-formula><mml:math id="IM57"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi>ℒ</mml:mi></mml:mrow></mml:math></inline-formula>, so we know that the sweep line intersects these segments. Also, the ordering of the segments is maintained based on their scores and begin positions, and since the scores of these segments are equal, therefore <inline-formula><mml:math id="IM58"><mml:mrow><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo></mml:mrow></mml:math></inline-formula><inline-formula><mml:math id="IM59"><mml:mrow><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mo>…</mml:mo></mml:mrow></mml:math></inline-formula><inline-formula><mml:math id="IM60"><mml:mrow><mml:mo>≥</mml:mo><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Now consider the iteration when segment <italic>s<sub>j</sub></italic> was marked <italic>good.</italic> Then, the sweep line must have intersected the segments <inline-formula><mml:math id="IM61"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> as well. Therefore, if the segment <italic>s<sub>j</sub></italic> was marked, then the segments <inline-formula><mml:math id="IM62"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> must have been marked within or before the same iteration.□</p><p>The total cost of sorting, <italic>insert</italic> and <italic>delete</italic> operations in Algorithm 1 is clearly <inline-formula><mml:math id="IM63"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Because the revised <italic>mark_good</italic> function marks at most <italic>n</italic> segments throughout the algorithm, its runtime is also bounded by <inline-formula><mml:math id="IM64"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, we conclude that the runtime complexity of our alignment filtering algorithm is bounded by <inline-formula><mml:math id="IM65"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement><statement><title>Theorem 1. </title><p>Given n alignment segments, Algorithm 1 solves the alignment filtering problem in <inline-formula><mml:math id="IM66"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time.</p></statement><statement><title>Theorem 2. </title><p>The above proposed filtering algorithm is optimal given the objective function.</p></statement><statement><title>Proof. </title><p>The INTEGER ELEMENT UNIQUENESS problem (given <italic>n</italic> integers, decide whether they are all unique) is known to have a lower bound of <inline-formula><mml:math id="IM67"><mml:mrow><mml:mi>Ω</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> assuming the algebraic decision-tree model (<xref rid="bty597-B21" ref-type="bibr">Lubiw and Rácz, 1991</xref>). A simple transformation can be designed to show that
<disp-formula><mml:math id="M1"><mml:mrow><mml:mtext>INTEGER ELEMENT UNIQUENESS </mml:mtext><mml:msub><mml:mrow><mml:mo>∝</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mtext> ALIGNMENT FILTERING </mml:mtext></mml:mrow></mml:math></disp-formula></p><p>Let <inline-formula><mml:math id="IM68"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be a set of <italic>n</italic> integer elements. For each element <italic>x<sub>i</sub></italic>, construct a segment with begin position, end position and score as <italic>x<sub>i</sub></italic>, <italic>x<sub>i</sub></italic> and <italic>i,</italic> respectively. Because each segment is assigned a unique score, all the <italic>n</italic> elements are unique if and only if the filtering algorithm reports all the segments as <italic>good.</italic></p></statement></p>
      </sec>
    </sec>
    <sec>
      <title>2.3 Related work for filtering alignments</title>
      <p>There can be many alternative formulations of the filtering criteria. For instance, BLAST (<xref rid="bty597-B1" ref-type="bibr">Altschul <italic>et al.</italic>, 1997</xref>) filters out alignments if they are fully contained in <inline-formula><mml:math id="IM69"><mml:mrow><mml:mo>≥</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula> alignments of higher scores (<xref rid="bty597-B4" ref-type="bibr">Berman <italic>et al.</italic>, 1999</xref>). Berman <italic>et al.</italic> also discussed a weaker alternative filtering condition where a match is filtered out if each position in a segment is covered by <inline-formula><mml:math id="IM70"><mml:mrow><mml:mo>≥</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula> segments of higher score. Note that our filtering formulation is its special case with <italic>K</italic> = 1. They discussed a different <inline-formula><mml:math id="IM71"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time algorithm to solve the problem based on interval-tree of all input segments. Although a direct performance comparison is not possible due to unavailability of their implementation, the tree size in our plane-sweep based algorithm is limited by the number of overlapping segments which intersect the vertical sweep-line, which can be (and typically is) orders of magnitude smaller than the total count for large datasets. As such, even with the same theoretical complexity, we expect our algorithm to perform faster with less memory usage in practice.</p>
    </sec>
    <sec>
      <title>2.4 Execution for mapping applications</title>
      <p>The above filtering criteria is useful to identify the promising alignments between query and reference genomes. For the genome-to-genome mapping application, we execute the filtering algorithm twice, once to filter best alignments for query sequence, followed by filtering best alignments for reference sequence. Mappings which pass both filters constitute the orthologous matches, required for building a one-to-one homology map. For read mapping however, filtering on just the query sequence is appropriate. Accordingly, Mashmap2 provides two filtering modes: <monospace>one-to-one</monospace> and <monospace>map</monospace> for the two applications, respectively.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We assess the performance of Mashmap2 for genome-to-genome and split-read mapping in comparison to recent versions of state-of-the-art software Minimap2 (<xref rid="bty597-B20" ref-type="bibr">Li, 2018</xref>) and Nucmer (<xref rid="bty597-B23" ref-type="bibr">Marçais <italic>et al.</italic>, 2018</xref>). Results indicate that Mashmap2 provides output of comparable quality, and yields significant gains in memory-usage. Subsequently, we demonstrate the utility of Mashmap2 in accurately computing all 1 Kbp long duplications in the human genome.</p>
    <sec>
      <title>3.1 Genome-to-genome mapping</title>
      <sec>
        <title>3.1.1 Datasets</title>
        <p>To evaluate and compare Mashmap2 for mapping genomes, we used six datasets D1–D6 listed in <xref rid="bty597-T1" ref-type="table">Table 1</xref>. Dataset D1 includes comparison between microbial genomes <italic>E. coli</italic> O157: H7 and <italic>E. coli</italic> K12. The two instances D2 and D3 require mapping of NA12878 human reference genome assemblies to the hg38 human reference genome. Query genome assemblies in both instances D2 and D3 are the recently published assemblies computed using Canu (<xref rid="bty597-B17" ref-type="bibr">Koren <italic>et al.</italic>, 2017</xref>), using ultra-long Oxford Nanopore Technology (ONT) reads (<xref rid="bty597-B14" ref-type="bibr">Jain <italic>et al.</italic>, 2018</xref>). Dataset D3 includes a long-read only Canu assembly whereas assembly in dataset D2 is also error-corrected using Illumina reads. The next two datasets D4, D5 involve inter-species genome comparisons- human vs. gorilla and chimp vs. gorilla, respectively. Finally, to evaluate Mashmap2 for the split-read mapping task, D6 includes raw ultra-long human ONT reads, generated using a single flowcell (<xref rid="bty597-B14" ref-type="bibr">Jain <italic>et al.</italic>, 2018</xref>). We restrict our benchmarking to real data instances because simulations typically fail to capture the full complexity of mutational processes.
<table-wrap id="bty597-T1" orientation="portrait" position="float"><label>Table 1.</label><caption><p>List of datasets used for evaluation</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="2" colspan="1">Id</th><th colspan="2" align="left" rowspan="1">Query sequences (<inline-formula><mml:math id="IM72"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> Kbp)<hr/></th><th rowspan="1" colspan="1"/><th rowspan="2" colspan="1">Reference genome</th></tr><tr><th align="left" rowspan="1" colspan="1">Source</th><th align="left" rowspan="1" colspan="1"># Sequences</th><th align="left" rowspan="1" colspan="1">N50 (bp)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">D1</td><td rowspan="1" colspan="1"><italic>E. coli</italic> O157 genome</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">5.5 M</td><td rowspan="1" colspan="1"><italic>E. coli</italic> K12 MG1655</td></tr><tr><td rowspan="1" colspan="1">D2</td><td rowspan="1" colspan="1">Human genome assembly (ONT+Illumina)</td><td rowspan="1" colspan="1">2269</td><td rowspan="1" colspan="1">7.7 M</td><td rowspan="1" colspan="1">Human (hg38)</td></tr><tr><td rowspan="1" colspan="1">D3</td><td rowspan="1" colspan="1">Human genome assembly (ONT)</td><td rowspan="1" colspan="1">2263</td><td rowspan="1" colspan="1">7.4 M</td><td rowspan="1" colspan="1">Human (hg38)</td></tr><tr><td rowspan="1" colspan="1">D4</td><td rowspan="1" colspan="1">Human (hg38) genome</td><td rowspan="1" colspan="1">365</td><td rowspan="1" colspan="1">145 M</td><td rowspan="1" colspan="1">Gorilla (gorGor5)</td></tr><tr><td rowspan="1" colspan="1">D5</td><td rowspan="1" colspan="1">Chimp (panTro5) genome</td><td rowspan="1" colspan="1">3086</td><td rowspan="1" colspan="1">137 M</td><td rowspan="1" colspan="1">Gorilla (gorGor5)</td></tr><tr><td rowspan="1" colspan="1">D6</td><td rowspan="1" colspan="1">Ultra-long human ONT reads</td><td rowspan="1" colspan="1">7656</td><td rowspan="1" colspan="1">129 K</td><td rowspan="1" colspan="1">Human (hg38)</td></tr></tbody></table><table-wrap-foot><fn id="tblfn1"><p><italic>Note</italic>: Datasets D1–D5 are included to evaluate Mashmap2 for genome-to-genome mapping application, and D6 for long read mapping application. We discarded a small fraction of contigs and reads with length &lt;10 Kbp.</p></fn></table-wrap-foot></table-wrap></p>
      </sec>
      <sec>
        <title>3.1.2 Defining baseline and methodology</title>
        <p>We used MUMmer package (v4.0.0.beta2), which includes the Nucmer4 alignment program for comparing DNA sequences (<xref rid="bty597-B23" ref-type="bibr">Marçais <italic>et al.</italic>, 2018</xref>). Nucmer4 is sensitive enough to report alignments for both assembly and read mapping tasks, therefore we considered its output as truth while evaluating accuracy. In addition, UCSC genome browser (<xref rid="bty597-B15" ref-type="bibr">Kent <italic>et al.</italic>, 2002</xref>) hosts high-quality pairwise syntenic alignment sets between popular mammalian genomes. Therefore, for evaluating the inter-species genome comparisons (D4, D5), we could use these as our truth sets. These alignments were originally computed using BLASTZ (<xref rid="bty597-B29" ref-type="bibr">Schwartz <italic>et al.</italic>, 2003</xref>) with careful parameter tuning and are more reliable for this purpose. We also used Minimap2 (v2.7-r659) (<xref rid="bty597-B20" ref-type="bibr">Li, 2018</xref>) as a baseline for various performance metrics. Minimap2 executes chaining algorithm on fixed-length exact matches to compute alignment boundaries. To our knowledge, it is among the fastest tools available to map DNA sequences in an alignment-free fashion.</p>
        <p>Each software, including ours, exposes many parameters (e.g. <italic>k</italic>-mer or seed length). Default <italic>k</italic>-mer size in Mashmap2 is 16. We mostly conform to default parameters with all software tested, except as noted below. Mashmap2 mainly requires a minimum length and identity for the desired local alignments. In this test, we targeted long alignments, and accordingly fixed the minimum alignment length requirement as 10 Kbp. We set the minimum alignment identity requirement for all the datasets based on their input characteristics as {D1–D2: 95%, D3–D5: 90%, D6: 80%}. Accordingly, we tested Mashmap2 for reporting the alignment boundaries as per the provided requirements. Filtering modes were set to one-to-one and map for datasets D1–D5 and D6, respectively. Nucmer4 was run with default parameters, followed by running <italic>delta-filter</italic>, both components of the MUMmer package. Following its user documentation, <italic>delta-filter</italic> was executed with −1 parameter to construct one-to-one alignment map in datasets D1–D5 and –q parameter for read mapping in D6. Finally, Minimap2 supports genome-to-genome mapping mode using <monospace>–x asm5</monospace> flag, and nanopore read mapping mode using <monospace>-x map-ont</monospace>. We executed all three software in multi-threaded mode using eight CPU threads. All comparisons were done on an Intel Xeon E5-2680 platform with 28 physical cores and 256 GB RAM.</p>
      </sec>
      <sec>
        <title>3.1.3 Runtime and memory usage</title>
        <p>The wall-clock runtime and memory-usage of Mashmap2, Minimap2 and Nucmer4 using datasets D1–D6 are shown in <xref rid="bty597-T2" ref-type="table">Table 2</xref>. The runtimes represent end-to-end time, from reading input sequences to generating the final output. Minimap2 can report base-to-base alignments but does not do so by default. Thus, the final output of Mashmap2 and Minimap2 are alignment boundaries and scores, whereas Nucmer4 outputs base-to-base alignments. Both alignment-free methods Mashmap2 and Minimap2 are able to map most of the query bases to unique positions in all datasets (shown later), therefore base-to-base alignments can be computed quickly for the final output using chaining heuristics and vectorization techniques (<xref rid="bty597-B31" ref-type="bibr">Suzuki and Kasahara, 2018</xref>; <xref rid="bty597-B20" ref-type="bibr">Li, 2018</xref>).
<table-wrap id="bty597-T2" orientation="portrait" position="float"><label>Table 2.</label><caption><p>Total execution time and memory usage comparison of Mashmap2 against Minimap2 and alignment-based tool Nucmer4</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Id</th><th colspan="2" align="left" rowspan="1">Mashmap2<hr/></th><th colspan="2" align="left" rowspan="1">Minimap2<hr/></th><th colspan="2" align="left" rowspan="1">Nucmer4<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">Time</th><th align="left" rowspan="1" colspan="1">Memory</th><th align="left" rowspan="1" colspan="1">Time</th><th align="left" rowspan="1" colspan="1">Memory</th><th align="left" rowspan="1" colspan="1">Time</th><th align="left" rowspan="1" colspan="1">Memory</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">D1</td><td rowspan="1" colspan="1">0.5 s</td><td rowspan="1" colspan="1">16 M</td><td rowspan="1" colspan="1">0.4 s</td><td rowspan="1" colspan="1">85 M</td><td rowspan="1" colspan="1">5.2 s</td><td rowspan="1" colspan="1">138 M</td></tr><tr><td rowspan="1" colspan="1">D2</td><td rowspan="1" colspan="1">1 m 26 s</td><td rowspan="1" colspan="1">3.5 G</td><td rowspan="1" colspan="1">3 m 3 s</td><td rowspan="1" colspan="1">17.3 G</td><td rowspan="1" colspan="1">5 h 1 m</td><td rowspan="1" colspan="1">53 G</td></tr><tr><td rowspan="1" colspan="1">D3</td><td rowspan="1" colspan="1">6 m 33 s</td><td rowspan="1" colspan="1">3.6 G</td><td rowspan="1" colspan="1">3 m 11 s</td><td rowspan="1" colspan="1">15.9 G</td><td rowspan="1" colspan="1">2 h 10 m</td><td rowspan="1" colspan="1">53 G</td></tr><tr><td rowspan="1" colspan="1">D4</td><td rowspan="1" colspan="1">27 m 33 s</td><td rowspan="1" colspan="1">9.0 G</td><td rowspan="1" colspan="1">15 m 6 s</td><td rowspan="1" colspan="1">26.7 G</td><td rowspan="1" colspan="1">33 h 4 m</td><td rowspan="1" colspan="1">57 G</td></tr><tr><td rowspan="1" colspan="1">D5</td><td rowspan="1" colspan="1">25 m 40 s</td><td rowspan="1" colspan="1">7.7 G</td><td rowspan="1" colspan="1">5 m 54 s</td><td rowspan="1" colspan="1">25.7 G</td><td rowspan="1" colspan="1">24 h 58 m</td><td rowspan="1" colspan="1">56 G</td></tr><tr><td rowspan="1" colspan="1">D6</td><td rowspan="1" colspan="1">13 m 6 s</td><td rowspan="1" colspan="1">10.0 G</td><td rowspan="1" colspan="1">3 m 10 s</td><td rowspan="1" colspan="1">10.4 G</td><td rowspan="1" colspan="1">25 m 2 s</td><td rowspan="1" colspan="1">53 G</td></tr></tbody></table><table-wrap-foot><fn id="tblfn2"><p><italic>Note</italic>: All software were run in parallel using eight CPU threads.</p></fn></table-wrap-foot></table-wrap></p>
        <p>From <xref rid="bty597-T2" ref-type="table">Table 2</xref>, we observe that Mashmap2 uses significantly less memory when compared to Minimap2, while Minimap2 generally achieves better runtime. Mashmap2 improves memory-usage by 5.3x, 4.9x, 4.4x, 3.0x, 3.3x and 1.04x for the six datasets, respectively. The performance gap against Nucmer4 is much wider with speedups of 10.4×, 210×, 19.8×, 72.0×, 58.4× and 1.9×, and memory-usage improvements by 8.6×, 15.1×, 14.7×, 6.3×, 7.3× and 5.3× on the datasets D1–D6, respectively. Low memory requirements in Mashmap2 can allow for larger comparisons (e.g. a genome against a big, in-memory reference database).</p>
        <p>Mashmap2 and Minimap2 follow the same initial step of sampling <italic>k</italic>-mers using minimizers (<xref rid="bty597-B26" ref-type="bibr">Roberts <italic>et al.</italic>, 2004</xref>; <xref rid="bty597-B27" ref-type="bibr">Schleimer <italic>et al.</italic>, 2003</xref>), followed by computing their exact matches in the reference genome. Mashmap2 is designed to identify all matches that meet the criteria, while Minimap2 is designed to find the best. This partly explains the differences observed in their running times. The optional filter in Mashmap2, if disabled, enables it to return all hits, e.g. for the use-case of finding all repeats (presented later in Section 3.2). Mashmap2 includes an efficient MinHash-based mechanism to estimate Jaccard similarity and auto-tunes its internal parameters (e.g. <italic>k</italic>-mer sampling rate, Jaccard similarity threshold), conforming to the local alignment identity and length requirements provided by the user. Auto-tuning can help achieve faster runtime and reduce memory-usage with increasing identity and length thresholds (<xref ref-type="fig" rid="bty597-F4">Fig. 4</xref>). It is important to maintain high accuracy while being fast, therefore we next evaluate the quality of output.</p>
        <fig id="bty597-F4" orientation="portrait" position="float">
          <label>Fig. 4.</label>
          <caption>
            <p>Wall time of Mashmap2 decreases with increasing length or identity thresholds using dataset D3 and eight CPU threads. In this experiment, identity and length thresholds were fixed to 90% and 10 Kbp while varying the other parameter. Memory-usage also follows a similar trend (data not shown)</p>
          </caption>
          <graphic xlink:href="bty597f4"/>
        </fig>
      </sec>
      <sec>
        <title>3.1.4 Accuracy</title>
        <p>Accuracy evaluation of Mashmap2 and Minimap2 in comparison to the assumed truth sets is shown in <xref rid="bty597-T3" ref-type="table">Table 3</xref>. As stated before in Section 3.1.2, recall was measured against the assumed true alignments, i.e. Nucmer4 alignments for intra-species comparisons (D1–D3, D6) and UCSC browser pairwise alignments for inter-species comparisons (D4, D5) which satisfy the alignment requirements in terms of minimum length and identity provided to Mashmap2. We also expected Minimap2 to report these alignments because it is designed to compute matches in these identity ranges.
<table-wrap id="bty597-T3" orientation="portrait" position="float"><label>Table 3.</label><caption><p>Accuracy evaluation of Mashmap2 and Minimap2 to do an alignment-free computation of mapping boundaries</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Id</th><th colspan="3" align="left" rowspan="1">Recall scores<hr/></th><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">Fraction of query bases mapped uniquely</th><th align="left" rowspan="1" colspan="1">Precision<xref ref-type="table-fn" rid="tblfn4"><sup>a</sup></xref></th></tr><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">Mashmap2 (%)</th><th align="left" rowspan="1" colspan="1">Minimap2 (%)</th><th align="left" rowspan="1" colspan="1">#True alignments</th><th align="left" rowspan="1" colspan="1">Mashmap2 (%)</th><th align="left" rowspan="1" colspan="1">Minimap2 (%)</th><th align="left" rowspan="1" colspan="1">Mashmap2 (%)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">D1</td><td align="center" rowspan="1" colspan="1">100</td><td align="center" rowspan="1" colspan="1">100%</td><td align="char" char="." rowspan="1" colspan="1">144</td><td align="char" char="." rowspan="1" colspan="1">74.0</td><td align="char" char="." rowspan="1" colspan="1">78.9</td><td align="char" char="." rowspan="1" colspan="1">72.0</td></tr><tr><td rowspan="1" colspan="1">D2</td><td align="char" char="." rowspan="1" colspan="1">97.5</td><td align="char" char="." rowspan="1" colspan="1">98.3</td><td align="char" char="." rowspan="1" colspan="1">35 186</td><td align="char" char="." rowspan="1" colspan="1">96.8</td><td align="char" char="." rowspan="1" colspan="1">96.3</td><td align="char" char="." rowspan="1" colspan="1">50.0</td></tr><tr><td rowspan="1" colspan="1">D3</td><td align="char" char="." rowspan="1" colspan="1">97.1</td><td align="char" char="." rowspan="1" colspan="1">98.1</td><td align="char" char="." rowspan="1" colspan="1">37 807</td><td align="char" char="." rowspan="1" colspan="1">96.9</td><td align="char" char="." rowspan="1" colspan="1">96.0</td><td align="char" char="." rowspan="1" colspan="1">55.2</td></tr><tr><td rowspan="1" colspan="1">D4</td><td align="char" char="." rowspan="1" colspan="1">97.0</td><td align="char" char="." rowspan="1" colspan="1">97.7</td><td align="char" char="." rowspan="1" colspan="1">63 908</td><td align="char" char="." rowspan="1" colspan="1">87.5</td><td align="char" char="." rowspan="1" colspan="1">91.3</td><td align="char" char="." rowspan="1" colspan="1">75.9</td></tr><tr><td rowspan="1" colspan="1">D5</td><td align="char" char="." rowspan="1" colspan="1">97.5</td><td align="char" char="." rowspan="1" colspan="1">98.0</td><td align="char" char="." rowspan="1" colspan="1">65 289</td><td align="char" char="." rowspan="1" colspan="1">89.8</td><td align="char" char="." rowspan="1" colspan="1">93.2</td><td align="char" char="." rowspan="1" colspan="1">57.3</td></tr><tr><td rowspan="1" colspan="1">D6</td><td align="char" char="." rowspan="1" colspan="1">99.3</td><td align="char" char="." rowspan="1" colspan="1">99.5</td><td align="char" char="." rowspan="1" colspan="1">4349</td><td align="char" char="." rowspan="1" colspan="1">89.9</td><td align="char" char="." rowspan="1" colspan="1">84.6</td><td align="char" char="." rowspan="1" colspan="1">34.8</td></tr></tbody></table><table-wrap-foot><fn id="tblfn3"><p><italic>Note</italic>: Recall was measured against the truth sets assumed (Section 3.1.2).</p></fn><fn id="tblfn4"><p><sup>a</sup>Fraction of mappings which satisfied alignment thresholds in Mashmap2.</p></fn></table-wrap-foot></table-wrap></p>
        <p>A reported local alignment boundary estimate by Mashmap2 or Minimap2 was assumed to recall a true alignment if it overlapped with the alignment on both query and reference sequences, and if the mapping strand matched. From <xref rid="bty597-T3" ref-type="table">Table 3</xref>, we observe that both Mashmap2 and Minimap2 consistently achieved high recall scores <inline-formula><mml:math id="IM73"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>97</mml:mn><mml:mi>%</mml:mi></mml:mrow></mml:math></inline-formula>, with Minimap2 performing slightly better. Obtaining high recall scores by itself is not sufficient, because it can be achieved by mapping a query sequence to all possible positions. In parallel to achieving high recall scores, both Mashmap2 and Minimap2 mapped a large fraction of query genome assemblies to unique mapping positions in the reference genomes. To show this, we computed the fraction of base-pairs of the query sequence that are mapped to a single position on the reference genome (<xref rid="bty597-T3" ref-type="table">Table 3</xref>).</p>
        <p>Next, we evaluated the precision, i.e. what fraction of Mashmap2 mappings yield one or more alignments above the specified length and identity thresholds. We used LAST (Kiełbasa <italic>et al.</italic>, 2011) to compute the alignments. The precision score of Mashmap2 averages to 57.5% across all the datasets, varying from 34.8% (in D6) to 75.9% (in D4). The corresponding scores for Minimap2 using the same threshold values are much lower (average = 15%), but Minimap2 follows different design principles and lacks similar guarantees on the characteristics of its output. In the current context of tasks that require such guarantees, Mashmap2 provides better precision on all datasets.</p>
      </sec>
      <sec>
        <title>3.1.5 Efficacy of the filtering algorithm</title>
        <p>Eukaryotic genomes contain many repetitive sequences, therefore, the motivation behind our plane-sweep based filtering heuristic is to discard noisy mappings, and compute promising matches between the query and reference genomes. We show the importance and effectiveness of our filtering strategy in <xref rid="bty597-T4" ref-type="table">Table 4</xref>. Note that a large fraction of the initial mappings was pruned out by the filter. While doing so, high recall scores against the assumed true sets were maintained (see <xref rid="bty597-T4" ref-type="table">Table 4</xref>). Although we do not present the contribution of this phase to the total runtime, the plane-sweep algorithm is fast in practice; it used an insignificant fraction of the total runtime.
<table-wrap id="bty597-T4" orientation="portrait" position="float"><label>Table 4.</label><caption><p>Effectiveness of the filtering algorithm in Mashmap2</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Id</th><th colspan="3" align="left" rowspan="1">Count of output mappings<hr/></th><th colspan="2" align="left" rowspan="1">Recall scores<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">Without filter</th><th align="left" rowspan="1" colspan="1">With filter</th><th align="left" rowspan="1" colspan="1">Ratio (without/with)</th><th align="left" rowspan="1" colspan="1">Without filter (%)</th><th align="left" rowspan="1" colspan="1">With filter (%)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">D1</td><td align="char" char="." rowspan="1" colspan="1">145</td><td align="char" char="." rowspan="1" colspan="1">82</td><td align="center" rowspan="1" colspan="1">1.77</td><td align="char" char="." rowspan="1" colspan="1">100.0</td><td align="char" char="." rowspan="1" colspan="1">100.0</td></tr><tr><td rowspan="1" colspan="1">D2</td><td align="char" char="." rowspan="1" colspan="1">6, 541, 930</td><td align="char" char="." rowspan="1" colspan="1">3985</td><td align="char" char="." rowspan="1" colspan="1">1642</td><td align="char" char="." rowspan="1" colspan="1">99.9</td><td align="char" char="." rowspan="1" colspan="1">97.5</td></tr><tr><td rowspan="1" colspan="1">D3</td><td align="char" char="." rowspan="1" colspan="1">53, 331, 538</td><td align="char" char="." rowspan="1" colspan="1">3137</td><td align="char" char="." rowspan="1" colspan="1">17 001</td><td align="char" char="." rowspan="1" colspan="1">99.7</td><td align="char" char="." rowspan="1" colspan="1">97.1</td></tr><tr><td rowspan="1" colspan="1">D4</td><td align="char" char="." rowspan="1" colspan="1">152, 536, 106</td><td align="char" char="." rowspan="1" colspan="1">4756</td><td align="char" char="." rowspan="1" colspan="1">32 072</td><td align="char" char="." rowspan="1" colspan="1">100.0</td><td align="char" char="." rowspan="1" colspan="1">97.0</td></tr><tr><td rowspan="1" colspan="1">D5</td><td align="char" char="." rowspan="1" colspan="1">152, 266, 777</td><td align="char" char="." rowspan="1" colspan="1">13 834</td><td align="char" char="." rowspan="1" colspan="1">11 007</td><td align="char" char="." rowspan="1" colspan="1">100.0</td><td align="char" char="." rowspan="1" colspan="1">97.5</td></tr><tr><td rowspan="1" colspan="1">D6</td><td align="char" char="." rowspan="1" colspan="1">18, 604, 261</td><td align="char" char="." rowspan="1" colspan="1">12 930</td><td align="char" char="." rowspan="1" colspan="1">1439</td><td align="char" char="." rowspan="1" colspan="1">99.9</td><td align="char" char="." rowspan="1" colspan="1">99.3</td></tr></tbody></table><table-wrap-foot><fn id="tblfn5"><p><italic>Note</italic>: A large fraction of mappings were filtered out by the algorithm, while the recall scores remained largely unaffected. Last column in this table is copied from <xref rid="bty597-T3" ref-type="table">Table 3</xref> for convenience.</p></fn></table-wrap-foot></table-wrap></p>
      </sec>
    </sec>
    <sec>
      <title>3.2 Computing duplications in the human genome</title>
      <p>Soon after the publication of the human genome, it was realized that the genome is replete with repetitive sequences (<xref rid="bty597-B12" ref-type="bibr">International Human Genome Sequencing Consortium, 2004</xref>). Intra- and inter-chromosomal duplications have been found to play a vital role in genome evolution, its stability and diseases (<xref rid="bty597-B8" ref-type="bibr">Emanuel and Shaikh, 2001</xref>; <xref rid="bty597-B24" ref-type="bibr">Pu <italic>et al.</italic>, 2018</xref>), and knowing the location of such repeats can be important for many genomic analyses. Yet, fully annotating all repeats in a genome can be computationally challenging. To demonstrate the scalability of Mashmap2, we computed all ≥1 Kbp duplications in the human genome (GRCh38, <xref rid="bty597-B28" ref-type="bibr">Schneider <italic>et al.</italic>, 2017</xref>) with <inline-formula><mml:math id="IM74"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>90</mml:mn></mml:mrow></mml:math></inline-formula>% alignment identity. The importance of these duplications has been known for a long time (<xref rid="bty597-B3" ref-type="bibr">Bailey <italic>et al.</italic>, 2002</xref>; <xref rid="bty597-B8" ref-type="bibr">Emanuel and Shaikh, 2001</xref>); accordingly the UCSC genome browser also maintains them as a public database (named as segmental duplications) for the human genome. The goal of our experiment is to recover as many duplications as possible. Due to the probabilistic guarantees provided by our algorithm (Section 2.1), we expect it to compute such duplications with a high recall value. Typical genome-to-genome aligners including Minimap2, Nucmer4 and BLASTZ do not provide such guarantees, and typically require extensive parameter tuning as well as preprocessing of input to perform this task (e.g. <xref rid="bty597-B2" ref-type="bibr">Bailey <italic>et al.</italic>, 2001</xref>, <xref rid="bty597-B3" ref-type="bibr">2002</xref>). We show that Mashmap2 serves as a straight-forward and accurate solution to address such applications.</p>
      <sec sec-type="methods">
        <title>3.2.1 Methodology</title>
        <p>We used 24 chromosome sequences (1–22, X, Y) and mitochondrial DNA from the hg38 version of the human genome as our input sequence set. To compute all <inline-formula><mml:math id="IM75"><mml:mo>≥</mml:mo></mml:math></inline-formula>1 Kbp, <inline-formula><mml:math id="IM76"><mml:mo>≥</mml:mo></mml:math></inline-formula>90% identity duplications, we directly used Mashmap2 with the same length and identity requirements, with filtering disabled. From its output, we discarded short (<inline-formula><mml:math id="IM77"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>500</mml:mn></mml:mrow></mml:math></inline-formula>bp) mappings with <inline-formula><mml:math id="IM78"><mml:mrow><mml:mo>&lt;</mml:mo><mml:mn>90</mml:mn><mml:mi>%</mml:mi></mml:mrow></mml:math></inline-formula> estimated identity, plus the trivial duplications (i.e. regions matching with themselves), and were left with 2.1 billion candidate mappings. The count of reported mappings is high due to several high-copy repeat families in the genome, not all of which exceed our minimum thresholds. To remove the shorter or lower identity mappings, each of the approximate alignments was processed using LAST to compute a base-level alignment. This resulted in 210 million validated alignments with <inline-formula><mml:math id="IM79"><mml:mo>≥</mml:mo></mml:math></inline-formula>1 Kbp length and <inline-formula><mml:math id="IM80"><mml:mo>≥</mml:mo></mml:math></inline-formula>90% identity. We note that a large fraction of the candidate mappings failed to satisfy the specified cutoffs here. This is because Mashmap2 looks at the Jaccard similarity of <italic>k</italic>-mer sets to evaluate the mappings, but does not consider the distribution of <italic>k</italic>-mer match positions. As a result, frequently occurring exact repeats of length &lt;1 Kbp in the human genome can also qualify as a match in the output. For example, an exact 300 bp <italic>Alu</italic> repeat induces many shared <italic>k</italic>-mers in a 1 Kbp window, resulting in an artificially high identity estimate for the larger window. It may be possible to improve the specificity by further considering the distribution of <italic>k</italic>-mer matches. This experiment took 120 CPU hours for executing Mashmap2 and 24 000 CPU hours for validating all reported mappings using LAST. We show a dot-plot visualization of the reported alignments in <xref ref-type="fig" rid="bty597-F5">Figure 5</xref>, which appears dense due to extensive duplications in the human genome. Finally, we converted the alignments into BED format to compare against the UCSC database using Bedtools (<xref rid="bty597-B25" ref-type="bibr">Quinlan and Hall, 2010</xref>); the accuracy results are discussed next.</p>
        <fig id="bty597-F5" orientation="portrait" position="float">
          <label>Fig. 5.</label>
          <caption>
            <p>Visualization of ≥1 Kbp duplications in the human genome computed using Mashmap2. Alignments are colored based on their lengths: blue 1–5 Kbp, red 5–10 Kbp, black &gt;10 Kbp. Majority of blue and red mappings occur due to SINEs and LINEs repeats, respectively. Right plot is a magnification of ≥1 Kbp duplications within chromosome 7. Chromosome 7 is known to be one of the most duplicated human chromosomes. Large clustered duplications in red circle are associated with Williams-Beuren syndrome (<xref rid="bty597-B11" ref-type="bibr">Hillier <italic>et al.</italic>, 2003</xref>)</p>
          </caption>
          <graphic xlink:href="bty597f5"/>
        </fig>
      </sec>
      <sec>
        <title>3.2.2 Accuracy evaluation and insights</title>
        <p>The UCSC Segmental Duplications database for the hg38 human genome was computed using a standard pipeline proposed by <xref rid="bty597-B2" ref-type="bibr">Bailey <italic>et al.</italic> (2001)</xref>, and was last updated in 2014. It is important to note that prior to computing genomic duplications, their method removed high-copy repeat elements (e.g. LINEs, <italic>Alu</italic>s) from the genome. Therefore, this database is not an exhaustive set of all <inline-formula><mml:math id="IM81"><mml:mo>≥</mml:mo></mml:math></inline-formula>1 Kbp, <inline-formula><mml:math id="IM82"><mml:mo>≥</mml:mo></mml:math></inline-formula>90% identity duplications in the genome, but a significant fraction of them. Nonetheless, low-copy repeat annotations have a higher likelihood of being missed by a mapper. Therefore, checking the recall against this database serves as an appropriate test to evaluate Mashmap2 in computing all homologous mappings of the specified characteristics.</p>
        <p>To measure recall on each chromosome, we computed coverage of those UCSC duplication annotations that have overlap with Mashmap2 duplications, and divided it by the coverage of all UCSC duplication annotations. Therefore, a 100% recall score would imply that all base-pairs which are annotated as segmental duplication in the UCSC database are part of one or more Mashmap2 alignments. We show these recall scores for each chromosome as well for the complete genome in <xref ref-type="fig" rid="bty597-F6">Figure 6</xref>. Recall is consistently observed to be above 90% for each chromosome, and the aggregate recall for the complete genome is 97.15%. Among the 2.85% missed alignments, a large fraction of alignments were not recalled because difference in the alignment parameters can affect alignment identity and length. As a result, same regions can yield slightly different alignments using LAST and BLAST. If we relax the alignment identity and length cutoff in LAST to 88% and 950 bp, respectively, the recall score improves to 98.28%. High recall scores achieved here, as well as in our prior experiments, demonstrate high sensitivity of our algorithm for any specified alignment characteristics by the user, which is consistent with the theory in Section 2.1.</p>
        <fig id="bty597-F6" orientation="portrait" position="float">
          <label>Fig. 6.</label>
          <caption>
            <p>Recall scores of duplications computed using Mashmap2 against the UCSC segmental duplication database. Above 90% recall scores are achieved on each chromosome consistently. The red dotted line shows the aggregate recall score of 97.15% for the complete genome</p>
          </caption>
          <graphic xlink:href="bty597f6"/>
        </fig>
        <p>Finally, we compared the coverage of our alignments versus the UCSC database. Since our method did an exhaustive search of all duplications with <inline-formula><mml:math id="IM83"><mml:mo>≥</mml:mo></mml:math></inline-formula>1 Kbp length and <inline-formula><mml:math id="IM84"><mml:mo>≥</mml:mo></mml:math></inline-formula>90% identity without masking any genomic repeats, we observe that our algorithm attains either equal or higher coverage on each chromosome (<xref ref-type="fig" rid="bty597-F7">Fig. 7</xref>). For the complete genome, coverage of our alignments is 10.3%; 5% higher than the coverage of UCSC annotations. We further examined the subset of our duplications which do not overlap with UCSC segmental duplications. Indeed a large coverage fraction (82%) comprises of high-copy repeats (i.e. coverage depth &gt;50), potentially due to common repeat elements, which explains the wide gap in the coverage observed. The remaining 18% coverage fraction, however, is composed of low-copy repeats, with coverage depth <inline-formula><mml:math id="IM85"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>50</mml:mn></mml:mrow></mml:math></inline-formula> indicating the potential to uncover novel segmental duplications. Validating this possibility requires a more careful inspection of the output, and will be our future work. Mashmap2 alignments are available online at <ext-link ext-link-type="uri" xlink:href="https://gembox.cbcb.umd.edu/mashmap/index.html">https://gembox.cbcb.umd.edu/mashmap/index.html</ext-link>.</p>
        <fig id="bty597-F7" orientation="portrait" position="float">
          <label>Fig. 7.</label>
          <caption>
            <p>Comparison of genomic coverage between the UCSC Segmental Duplication database and Mashmap2 output alignments. Both methods reported equal coverage 83% on mitochondrial chromosome (not shown above to keep the plot legible). Coverage of duplications computed using our method is significantly higher, owing to its exhaustive search of all repeats with <inline-formula><mml:math id="IM86"><mml:mo>≥</mml:mo></mml:math></inline-formula>1 Kbp length and <inline-formula><mml:math id="IM87"><mml:mo>≥</mml:mo></mml:math></inline-formula>90% identity without repeat masking</p>
          </caption>
          <graphic xlink:href="bty597f7"/>
        </fig>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>In this work, we presented a fast algorithm for computing homology maps between whole genomes. We have given both theoretical and experimental evidence of the sensitivity provided, in terms of computing local alignment boundaries based on the minimum alignment length and identity parameters. To the best of our knowledge, this is the first practical and scalable algorithm to provide such guarantees. This formulation grants a convenient mechanism for users to execute this algorithm based on the underlying applications, including (but not limited to) mapping genome assemblies of variable quality, aligning long reads to reference genomes, or computing segmental duplications in large genomes. Additionally, we formulated a filtering heuristic, and proposed an optimal plane-sweep based filtering algorithm for prioritizing alignments based on their scores and locations. The filtering algorithm is practically fast, accurate and easy to implement in few lines of code using standard libraries. When mapping a human genome assembly to the human reference genome, Mashmap2 takes only about a minute from reading input sequences to generating the final alignment boundaries, identity estimates, and a dot-plot for visualization. Because of the underlying auto-tuning mechanism in Mashmap2, performance depends on the sensitivity requirements provided to the algorithm. As the pace of whole-genome sequencing continues to increase, faster practical algorithms and theoretical advances will help analyze available and forthcoming data.</p>
    <p>Although our algorithm optimizes mapping of a single genome assembly to a single reference genome, its runtime would scale linearly when mapping to multiple reference genomes. Planned future work includes development of sub-linear algorithms using existing ideas of non-linear reference genome representations. We also plan to evaluate biological novelty of the human segmental duplications computed in this work.</p>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>We thank Pavel Pevzner for motivating evaluation of segmental duplications. We also acknowledge the use of computing resources provided through the Partnership for an Advanced Computing Environment (PACE) at the Georgia Institute of Technology, and the Biowulf system at the National Institutes of Health, Bethesda, MD (<ext-link ext-link-type="uri" xlink:href="https://hpc.nih.gov/">https://hpc.nih.gov/</ext-link>).</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>This research was supported in part by the Intramural Research Program of the National Human Genome Research Institute, National Institutes of Health, and the U.S. National Science Foundation under CCF-1816027.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="bty597-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Altschul</surname><given-names>S.F.</given-names></name><etal>et al</etal></person-group> (<year>1997</year>) 
<article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>. <source>Nucleic Acids Res.</source>, <volume>25</volume>, <fpage>3389</fpage>–<lpage>3402</lpage>.<pub-id pub-id-type="pmid">9254694</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bailey</surname><given-names>J.A.</given-names></name><etal>et al</etal></person-group> (<year>2001</year>) 
<article-title>Segmental duplications: organization and impact within the current human genome project assembly</article-title>. <source>Genome Res.</source>, <volume>11</volume>, <fpage>1005</fpage>–<lpage>1017</lpage>.<pub-id pub-id-type="pmid">11381028</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bailey</surname><given-names>J.A.</given-names></name><etal>et al</etal></person-group> (<year>2002</year>) 
<article-title>Recent segmental duplications in the human genome</article-title>. <source>Science</source>, <volume>297</volume>, <fpage>1003</fpage>–<lpage>1007</lpage>.<pub-id pub-id-type="pmid">12169732</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B4">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Berman</surname><given-names>P.</given-names></name><etal>et al</etal></person-group> (<year>1999</year>) 
<article-title>Winnowing sequences from a database search</article-title>. In: <source>Proceedings of the Third Annual International Conference on Computational Molecular Biology</source>. 
<publisher-name>ACM</publisher-name>, pp. <fpage>50</fpage>–<lpage>58</lpage>.</mixed-citation>
    </ref>
    <ref id="bty597-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bray</surname><given-names>N.</given-names></name><etal>et al</etal></person-group> (<year>2003</year>) 
<article-title>AVID: a global alignment program</article-title>. <source>Genome Res.</source>, <volume>13</volume>, <fpage>97</fpage>–<lpage>102</lpage>.<pub-id pub-id-type="pmid">12529311</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Brudno</surname><given-names>M.</given-names></name><etal>et al</etal></person-group> (<year>2003</year>) 
<article-title>Fast and sensitive multiple alignment of large genomic sequences</article-title>. <source>BMC Bioinformatics</source>, <volume>4</volume>, <fpage>66</fpage>.<pub-id pub-id-type="pmid">14693042</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Delcher</surname><given-names>A.L.</given-names></name><etal>et al</etal></person-group> (<year>1999</year>) 
<article-title>Alignment of whole genomes</article-title>. <source>Nucleic Acids Res.</source>, <volume>27</volume>, <fpage>2369</fpage>–<lpage>2376</lpage>.<pub-id pub-id-type="pmid">10325427</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Emanuel</surname><given-names>B.S.</given-names></name>, <name name-style="western"><surname>Shaikh</surname><given-names>T.H.</given-names></name></person-group> (<year>2001</year>) 
<article-title>Segmental duplications: an ‘expanding’role in genomic instability and disease</article-title>. <source>Nat. Rev. Genet.</source>, <volume>2</volume>, <fpage>791</fpage>–<lpage>800</lpage>.<pub-id pub-id-type="pmid">11584295</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Grabherr</surname><given-names>M.G.</given-names></name><etal>et al</etal></person-group> (<year>2010</year>) 
<article-title>Genome-wide synteny through highly sensitive sequence alignment: satsuma</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>1145</fpage>–<lpage>1151</lpage>.<pub-id pub-id-type="pmid">20208069</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Haussler</surname><given-names>D.</given-names></name><etal>et al</etal></person-group> (<year>2009</year>) 
<article-title>Genome 10K: a proposal to obtain whole-genome sequence for 10 000 vertebrate species</article-title>. <source>J. Hered.</source>, <volume>100</volume>, <fpage>659</fpage>–<lpage>674</lpage>.<pub-id pub-id-type="pmid">19892720</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Hillier</surname><given-names>L.W.</given-names></name><etal>et al</etal></person-group> (<year>2003</year>) 
<article-title>The DNA sequence of human chromosome 7</article-title>. <source>Nature</source>, <volume>424</volume>, <fpage>157</fpage>.<pub-id pub-id-type="pmid">12853948</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B12">
      <mixed-citation publication-type="journal"><collab>Human Genome Sequencing Consortium,I.</collab> (<year>2004</year>) 
<article-title>Finishing the euchromatic sequence of the human genome</article-title>. <source>Nature</source>, <volume>431</volume>, <fpage>931</fpage>–<lpage>945</lpage>.<pub-id pub-id-type="pmid">15496913</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B13">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Jain</surname><given-names>C.</given-names></name><etal>et al</etal></person-group> (<year>2017</year>) 
<article-title>A fast approximate algorithm for mapping long reads to large reference databases</article-title>. In: <source>International Conference on Research in Computational Molecular Biology</source>. 
<publisher-name>Springer</publisher-name>, pp. <fpage>66</fpage>–<lpage>81</lpage>.</mixed-citation>
    </ref>
    <ref id="bty597-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jain</surname><given-names>M.</given-names></name><etal>et al</etal></person-group> (<year>2018</year>) 
<article-title>Nanopore sequencing and assembly of a human genome with ultra-long reads</article-title>. <source>Nat. Biotechnol.</source>, <volume>36</volume>, <fpage>338</fpage>–<lpage>345</lpage>.<pub-id pub-id-type="pmid">29431738</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kent</surname><given-names>W.J.</given-names></name><etal>et al</etal></person-group> (<year>2002</year>) 
<article-title>The human genome browser at UCSC</article-title>. <source>Genome Res.</source>, <volume>12</volume>, <fpage>996</fpage>–<lpage>1006</lpage>.<pub-id pub-id-type="pmid">12045153</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kiełbasa</surname><given-names>S.M.</given-names></name><etal>et al</etal></person-group> (<year>2011</year>) 
<article-title>Adaptive seeds tame genomic sequence comparison</article-title>. <source>Genome Res.</source>, <volume>21</volume>, <fpage>487</fpage>–<lpage>493</lpage>.<pub-id pub-id-type="pmid">21209072</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Koren</surname><given-names>S.</given-names></name><etal>et al</etal></person-group> (<year>2017</year>) 
<article-title>Canu: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>. <source>Genome Res.</source>, <volume>27</volume>, <fpage>722</fpage>–<lpage>736</lpage>.<pub-id pub-id-type="pmid">28298431</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kurtz</surname><given-names>S.</given-names></name><etal>et al</etal></person-group> (<year>2004</year>) 
<article-title>Versatile and open software for comparing large genomes</article-title>. <source>Genome Biol.</source>, <volume>5</volume>, <fpage>R12</fpage>.<pub-id pub-id-type="pmid">14759262</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lander</surname><given-names>E.S.</given-names></name><etal>et al</etal></person-group> (<year>2001</year>) 
<article-title>Initial sequencing and analysis of the human genome</article-title>. <source>Nature</source>, <volume>409</volume>, <fpage>860</fpage>–<lpage>921</lpage>.<pub-id pub-id-type="pmid">11237011</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source>. <comment>doi: 10.1093/bioinformatics/bty191</comment>.</mixed-citation>
    </ref>
    <ref id="bty597-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lubiw</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Rácz</surname><given-names>A.</given-names></name></person-group> (<year>1991</year>) 
<article-title>A lower bound for the integer element distinctness problem</article-title>. <source>Inf. Comput.</source>, <volume>94</volume>, <fpage>83</fpage>–<lpage>92</lpage>.</mixed-citation>
    </ref>
    <ref id="bty597-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ma</surname><given-names>B.</given-names></name><etal>et al</etal></person-group> (<year>2002</year>) 
<article-title>Patternhunter: faster and more sensitive homology search</article-title>. <source>Bioinformatics</source>, <volume>18</volume>, <fpage>440</fpage>–<lpage>445</lpage>.<pub-id pub-id-type="pmid">11934743</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Marçais</surname><given-names>G.</given-names></name><etal>et al</etal></person-group> (<year>2018</year>) 
<article-title>MUMmer4: a fast and versatile genome alignment system</article-title>. <source>PLoS Comput. Biol.</source>, <volume>14</volume>, <fpage>e1005944</fpage>.<pub-id pub-id-type="pmid">29373581</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Pu</surname><given-names>L.</given-names></name><etal>et al</etal></person-group> (<year>2018</year>) 
<article-title>Detection and analysis of ancient segmental duplications in mammalian genomes</article-title>. <source>Genome Res.</source>, <volume>28</volume>, <fpage>901</fpage>–<lpage>909</lpage>.<pub-id pub-id-type="pmid">29735604</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Quinlan</surname><given-names>A.R.</given-names></name>, <name name-style="western"><surname>Hall</surname><given-names>I.M.</given-names></name></person-group> (<year>2010</year>) 
<article-title>Bedtools: a flexible suite of utilities for comparing genomic features</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>841</fpage>–<lpage>842</lpage>.<pub-id pub-id-type="pmid">20110278</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Roberts</surname><given-names>M.</given-names></name><etal>et al</etal></person-group> (<year>2004</year>) 
<article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source>, <volume>20</volume>, <fpage>3363</fpage>–<lpage>3369</lpage>.<pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B27">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Schleimer</surname><given-names>S.</given-names></name><etal>et al</etal></person-group> (<year>2003</year>) 
<article-title>Winnowing: local algorithms for document fingerprinting</article-title>. In: <source>Proceedings of the 2003 ACM SIGMOD international conference on Management of data</source>. 
<publisher-name>ACM</publisher-name>, pp. <fpage>76</fpage>–<lpage>85</lpage>.</mixed-citation>
    </ref>
    <ref id="bty597-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Schneider</surname><given-names>V.A.</given-names></name><etal>et al</etal></person-group> (<year>2017</year>) 
<article-title>Evaluation of GRCh38 and de novo haploid genome assemblies demonstrates the enduring quality of the reference assembly</article-title>. <source>Genome Res.</source>, <volume>27</volume>, <fpage>849</fpage>–<lpage>864</lpage>.<pub-id pub-id-type="pmid">28396521</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Schwartz</surname><given-names>S.</given-names></name><etal>et al</etal></person-group> (<year>2003</year>) 
<article-title>Human–mouse alignments with BLASTZ</article-title>. <source>Genome Res.</source>, <volume>13</volume>, <fpage>103</fpage>–<lpage>107</lpage>.<pub-id pub-id-type="pmid">12529312</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B30">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Shamos</surname><given-names>M.I.</given-names></name>, <name name-style="western"><surname>Hoey</surname><given-names>D.</given-names></name></person-group> (<year>1976</year>) 
<article-title>Geometric intersection problems</article-title>. In: <source>17th Annual Symposium on Foundations of Computer Science</source>. 
<publisher-name>IEEE</publisher-name>, pp. <fpage>208</fpage>–<lpage>215</lpage>.</mixed-citation>
    </ref>
    <ref id="bty597-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Suzuki</surname><given-names>H.</given-names></name>, <name name-style="western"><surname>Kasahara</surname><given-names>M.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Introducing difference recurrence relations for faster semi-global alignment of long sequences</article-title>. <source>BMC Bioinformatics</source>, <volume>19</volume>, <fpage>1</fpage>–<lpage>45</lpage>.<pub-id pub-id-type="pmid">29291722</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Venter</surname><given-names>J.C.</given-names></name><etal>et al</etal></person-group> (<year>2001</year>) 
<article-title>The sequence of the human genome</article-title>. <source>Science</source>, <volume>291</volume>, <fpage>1304</fpage>–<lpage>1351</lpage>.<pub-id pub-id-type="pmid">11181995</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Vyverman</surname><given-names>M.</given-names></name><etal>et al</etal></person-group> (<year>2013</year>) 
<article-title>essamem: finding maximal exact matches using enhanced sparse suffix arrays</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>802</fpage>–<lpage>804</lpage>.<pub-id pub-id-type="pmid">23349213</pub-id></mixed-citation>
    </ref>
    <ref id="bty597-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Yorukoglu</surname><given-names>D.</given-names></name><etal>et al</etal></person-group> (<year>2016</year>) 
<article-title>Compressive mapping for next-generation sequencing</article-title>. <source>Nat. Biotechnol.</source>, <volume>34</volume>, <fpage>374</fpage>.<pub-id pub-id-type="pmid">27054987</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
