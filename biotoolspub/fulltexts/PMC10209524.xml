<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10209524</article-id>
    <article-id pub-id-type="pmid">37171886</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad313</article-id>
    <article-id pub-id-type="publisher-id">btad313</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Applications Note</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genome Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>copMEM2: robust and scalable maximum exact match finding</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-1714-1224</contrib-id>
        <name>
          <surname>Grabowski</surname>
          <given-names>Szymon</given-names>
        </name>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/conceptualization" degree-contribution="lead">Conceptualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Data curation" vocab-term-identifier="http://credit.niso.org/contributor-roles/data-curation" degree-contribution="supporting">Data curation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Formal analysis" vocab-term-identifier="http://credit.niso.org/contributor-roles/formal-analysis" degree-contribution="equal">Formal analysis</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="http://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="http://credit.niso.org/contributor-roles/investigation" degree-contribution="lead">Investigation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="http://credit.niso.org/contributor-roles/methodology" degree-contribution="lead">Methodology</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="http://credit.niso.org/contributor-roles/project-administration" degree-contribution="supporting">Project administration</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Resources" vocab-term-identifier="http://credit.niso.org/contributor-roles/resources" degree-contribution="equal">Resources</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Software" vocab-term-identifier="http://credit.niso.org/contributor-roles/software" degree-contribution="equal">Software</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="http://credit.niso.org/contributor-roles/supervision" degree-contribution="equal">Supervision</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Validation" vocab-term-identifier="http://credit.niso.org/contributor-roles/validation" degree-contribution="equal">Validation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Visualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/visualization" degree-contribution="equal">Visualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="http://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="lead">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="http://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing - review &amp; editing</role>
        <aff><institution>Institute of Applied Computer Science, Lodz University of Technology</institution>, <addr-line>18 Stefanowskiego Street</addr-line>, Lodz, <country country="PL">Poland</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-1708-5760</contrib-id>
        <name>
          <surname>Bieniecki</surname>
          <given-names>Wojciech</given-names>
        </name>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/conceptualization" degree-contribution="supporting">Conceptualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Data curation" vocab-term-identifier="http://credit.niso.org/contributor-roles/data-curation" degree-contribution="lead">Data curation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Formal analysis" vocab-term-identifier="http://credit.niso.org/contributor-roles/formal-analysis" degree-contribution="equal">Formal analysis</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Funding acquisition" vocab-term-identifier="http://credit.niso.org/contributor-roles/funding-acquisition" degree-contribution="equal">Funding acquisition</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="http://credit.niso.org/contributor-roles/investigation" degree-contribution="supporting">Investigation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="http://credit.niso.org/contributor-roles/methodology" degree-contribution="supporting">Methodology</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Project administration" vocab-term-identifier="http://credit.niso.org/contributor-roles/project-administration" degree-contribution="lead">Project administration</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Resources" vocab-term-identifier="http://credit.niso.org/contributor-roles/resources" degree-contribution="equal">Resources</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Software" vocab-term-identifier="http://credit.niso.org/contributor-roles/software" degree-contribution="equal">Software</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="http://credit.niso.org/contributor-roles/supervision" degree-contribution="equal">Supervision</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Validation" vocab-term-identifier="http://credit.niso.org/contributor-roles/validation" degree-contribution="equal">Validation</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Visualization" vocab-term-identifier="http://credit.niso.org/contributor-roles/visualization" degree-contribution="equal">Visualization</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="http://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="supporting">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="http://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="http://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing - review &amp; editing</role>
        <aff><institution>Institute of Applied Computer Science, Lodz University of Technology</institution>, <addr-line>18 Stefanowskiego Street</addr-line>, Lodz, <country country="PL">Poland</country></aff>
        <xref rid="btad313-cor1" ref-type="corresp"/>
        <!--wbieniec@kis.p.lodz.pl-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Robinson</surname>
          <given-names>Dr Peter</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad313-cor1">Corresponding author. Institute of Applied Computer Science, Lodz University of Technology, Poland. E-mail: <email>wbieniec@kis.p.lodz.pl</email> (W.B.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>5</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-05-12">
      <day>12</day>
      <month>5</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>12</day>
      <month>5</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>5</issue>
    <elocation-id>btad313</elocation-id>
    <history>
      <date date-type="received">
        <day>01</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>25</day>
        <month>4</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>04</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>11</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>24</day>
        <month>5</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad313.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Summary</title>
        <p>Finding Maximum Exact Matches, i.e. matches between two strings that cannot be further extended to the left or right, is a classic string problem with applications in genome-to-genome comparisons. The existing tools rarely explicitly address the problem of MEM finding for a pair of very similar genomes, which may be computationally challenging. We present copMEM2, a multithreaded implementation of its predecessor. Together with a few optimizations, including a carefully built predecessor query data structure and sort procedure selection, and taking care for highly similar data, copMEM2 allows to compute all MEMs of minimum length 50 between the human and mouse genomes in 59 s, using 10.40 GB of RAM and 12 threads, being at least a few times faster than its main contenders. On a pair of human genomes, hg18 and hg19, the results are 324 s and 16.57 GB, respectively.</p>
      </sec>
      <sec id="s2">
        <title>Availability and implementation</title>
        <p>copMEM2 is available at <ext-link xlink:href="https://github.com/wbieniec/copmem2" ext-link-type="uri">https://github.com/wbieniec/copmem2</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Lodz University of Technology</institution>
            <institution-id institution-id-type="DOI">10.13039/501100009894</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="5"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p><italic toggle="yes">Maximal exact matches</italic> (MEMs) are exact matches between two strings (genomes) that cannot be further extended to the left or right. Their applications include seeding alignments of sequencing reads for genome assembly (<xref rid="btad313-B4" ref-type="bibr">Liu and Schmidt 2012</xref>), designating anchor points for genome-genome comparisons (<xref rid="btad313-B3" ref-type="bibr">Kurtz et al. 2004</xref>) and referential genome compression (<xref rid="btad313-B5" ref-type="bibr">Liu et al. 2017</xref>). Although the MEM finding problem can be solved in linear time using the suffix tree (<xref rid="btad313-B3" ref-type="bibr">Kurtz et al. 2004</xref>), this approach is memory hungry and can also be beaten in terms of practical speed. Alternatives include making use of a hash table (HT) for <italic toggle="yes">k</italic>-mers sampled from the reference (<italic toggle="yes">R</italic>) genome, applied in E-MEM (<xref rid="btad313-B2" ref-type="bibr">Khiste and Ilie 2015</xref>), sampling both the reference and the query (<italic toggle="yes">Q</italic>) in steps being relatively prime, as proposed in copMEM (<xref rid="btad313-B1" ref-type="bibr">Grabowski and Bieniecki 2019</xref>), and combining the copMEM approach with Bloom filtering the <italic toggle="yes">k</italic>-mers sampled from <italic toggle="yes">Q</italic>, introduced in bfMEM (<xref rid="btad313-B6" ref-type="bibr">Liu et al. 2019</xref>).</p>
    <p>The last two cited works remain the state-of-the-art. copMEM is much faster in single-threaded comparisons, but lacks a multithreaded mode and uses significantly more memory than bfMEM. To address its shortcomings, we propose copMEM2, a multithreaded MEM finding tool, targeting the execution speed and reducing the memory, as well as incorporating an improvement to speed up its processing by orders of magnitude when the pair of genomes is highly similar.</p>
  </sec>
  <sec>
    <title>2 Methods</title>
    <p>The general architecture of the presented tool, copMEM2, resembles copMEM. A HT is built over regularly sampled <italic toggle="yes">k</italic>-mers from the reference genome, then substrings from the query genomes are found via HT, and finally left- and right-extended. As in other tools solving this problem, only MEMs of length at least runtime-specified <italic toggle="yes">L</italic> are sent to the output. One of the novelties of the presented software is that all main phases, i.e. HT construction and match finding, extending, filtering and sorting, are performed in parallel, using multiple threads.</p>
    <p>Apart from the parallel processing, copMEM2 was optimized in a few ways.</p>
    <p>The match sorting algorithm is no longer only std::sort (based on quick sort), but rather two radix sort variants, a most significant digit (MSD) one (<ext-link xlink:href="https://github.com/voutcn/kxsort" ext-link-type="uri">https://github.com/voutcn/kxsort</ext-link>) and a least significant digit (LSD) radix sort on the most significant 6 bytes in match tuples (i.e. 6 digit passes) followed with std::sort in remaining buckets (this works faster than LSD radix sort over the whole keys), which, together with std::sort, are selected for different cases.</p>
    <p>The matches are ordered by their starting position in <italic toggle="yes">Q</italic>, and then by their starting position in <italic toggle="yes">R</italic>. One option is to find all matches for each successive sequence (chromosome) in <italic toggle="yes">Q</italic> and then sort them appropriately, but for small <italic toggle="yes">L</italic> and large chromosomes it may require several gigabytes of memory. Our implemented solution is to sort matches in blocks (of <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> elements), with large enough overlaps between blocks to prevent incorrect order on block boundaries. In the unlikely case of having the overlap too small, a slower and more memory demanding rescue procedure is called.</p>
    <p>Mapping the starting match position to a sequence in <italic toggle="yes">R</italic>, which requires a predecessor query, no longer uses std::lower_bound, but builds a static data structure with predecessor answers for regularly sampled positions, in gaps dictated by the shortest reference sequence length. The preprocessing cost is more than offset with constant-time query handling.</p>
    <p>We also noted that copMEM (i.e. the predecessor of the currently presented algorithm), similarly to most other competitors, is slow if <italic toggle="yes">R</italic> and <italic toggle="yes">Q</italic> genomes are very similar (e.g. two individuals of the same species). According to our knowledge, the only MEM finding tool which directly addresses this problem is E-MEM2 (<xref rid="btad313-B7" ref-type="bibr">Portes de Cerqueira Cesar 2020</xref>) (<ext-link xlink:href="https://ir.lib.uwo.ca/etd/6837/" ext-link-type="uri">https://ir.lib.uwo.ca/etd/6837/</ext-link>), which is not publicly available. We (essentially) implemented the idea from E-MEM2, which is to discard a MEM (of length at least <italic toggle="yes">L</italic>) if it is fully contained in a MEM found at a previously sampled position in <italic toggle="yes">Q</italic>. In this way the number of accesses to <italic toggle="yes">R</italic> is hugely reduced in highly similar genomes, which avoids a great number of possibly costly match extensions.</p>
    <p>Found MEMs are stored in internal buffers (one per thread) and occasionally dumped to temporary disk files; those files are merged into one at the end. This simple idea may reduce the memory usage a few times, if the total number of MEMs is huge (e.g. for <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>50</mml:mn></mml:mrow></mml:math></inline-formula>).</p>
    <p>The sampling parameters for <italic toggle="yes">R</italic> and <italic toggle="yes">Q</italic> are <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, respectively, and they always differ by 1 in copMEM. This is relaxed in copMEM2: <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> may be increased as much as possible to have the condition <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>⋅</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>≤</mml:mo><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">K</italic> is the seed size, still fulfilled, and <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> coprime. Note this helps, e.g., for <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>80</mml:mn></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">K</italic> is set to 44, as copMEM sets <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, while copMEM2 to <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>7</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and even more for <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>132</mml:mn><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>44</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where the parameters are changed from <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>8</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>11</mml:mn><mml:mo>,</mml:mo><mml:mn>8</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    <p>Additionally, we included a memory-frugal mode (-mf), in which a smaller HT and smaller buffers imply reduced memory usage, for a little penalty in performance.</p>
    <p>Below we present in detail only three of the ideas incorporated in copMEM2; descriptions of the other ones can be found in the supplementary material.</p>
    <sec>
      <title>2.1 Dealing with large match lists</title>
      <p>Taming the memory usage and computational time for ordering the matches before they are dumped to disk is one of the challenges we faced in copMEM2.</p>
      <p>Found matches, in the form of triples of integers, are appended to a list. Such a list has to be created for each sequence from <italic toggle="yes">Q</italic> and should finally be sorted and pushed to a file before memory is freed. However, the lists can be very long and occupy several GBs in the memory, especially for a small <italic toggle="yes">L</italic> and multiple threads running in parallel.</p>
      <p>Our MEM-finding algorithm does not guarantee that matches will be found sequentially nor that they will be unique. Nevertheless, we have noticed that the obtained list is partially sorted, i.e. it is unlikely that a MEM on the unsorted list is far from its final (correct) location, so there is no need to keep the entire list in memory.</p>
      <p>The procedure does the following:</p>
      <list list-type="bullet">
        <list-item>
          <p>it appends a match to the match list <italic toggle="yes">Matches</italic>,</p>
        </list-item>
        <list-item>
          <p>if the current size of <italic toggle="yes">Matches</italic> reaches <monospace>MATCH_BLOCK</monospace> (set to <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) elements, it</p>
          <list list-type="bullet">
            <list-item>
              <p>sorts the list <italic toggle="yes">Matches</italic>,</p>
            </list-item>
            <list-item>
              <p>dumps <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mn>3</mml:mn><mml:mo>/</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> of <monospace>MATCH_BLOCK</monospace> elements from the beginning of <italic toggle="yes">Matches</italic>,</p>
            </list-item>
            <list-item>
              <p>removes dumped elements from <italic toggle="yes">Matches</italic> (up to one-fourth remains).</p>
            </list-item>
          </list>
        </list-item>
      </list>
      <p>An illustrating example is given in the supplementary material.</p>
    </sec>
    <sec>
      <title>2.2 Match sorting strategy</title>
      <p>In copMEM the matches were sorted with std::sort. In copMEM2, they are sorted with three sorting algorithms: std::sort (which is based on quick sort, combined with insertion sort for small subsets), the kxsort implementation of MSD radix sort (<ext-link xlink:href="https://github.com/voutcn/kxsort" ext-link-type="uri">https://github.com/voutcn/kxsort</ext-link>), and our own 6-digit (i.e. 6-byte) LSD radix sort implementation followed with std::sort to order properly the remaining (usually small) intervals.</p>
      <p>The details of our solution were worked out based on the following observations: (i) std::sort is a good choice for small match subsets, (ii) kxsort is more memory frugal than our LSD radix sort, and (iii) the hybrid of 6-pass LSD radix sort and std::sort may be the fastest choice, unless the data don’t fit the L3 cache, which indeed is a problem in a multiple thread scenario. In particular, we apply std::sort for collections up to <monospace>MATCHES_SORT_T1</monospace> (default value: 1024) items, otherwise one of the other radix sort algorithms is used. When the number of working threads is up to 2 and <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo>&lt;</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, we use our LSD radix sort based variant and in the remaining cases the kxsort algorithm is applied.</p>
    </sec>
    <sec>
      <title>2.3 Fast sequence search</title>
      <p>Mapping the match position to a sequence in <italic toggle="yes">R</italic> it belongs to, which requires a predecessor query, no longer uses std::lower_bound in copMEM2, but builds a static predecessor query data structure, which stores predecessor answers for regularly sampled positions, in gaps dictated by the shortest reference sequence length. The preprocessing cost is more than offset by constant-time query handling. The position of each found MEM, which requires referring to the HT entries, is absolute, but the textual output requires storing the match locations relatively to the beginning of their corresponding sequences (together with their names) in <italic toggle="yes">R</italic> and <italic toggle="yes">Q</italic> genomes. In copMEM (i.e., our old software) the positions of successive sequences from <italic toggle="yes">R</italic> were stored in a sorted array and each MEM required finding the rightmost sequence from <italic toggle="yes">R</italic>, whose start position was not greater than the MEM’s start position. This translated to a binary search procedure and was implemented with an invocation of the C++ STL’s lower_bound algorithm. In copMEM2 we find the shortest sequence from <italic toggle="yes">R</italic>, let us denote its length by <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, and sample <italic toggle="yes">R</italic> in regular steps of <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, storing the beginning of the <italic toggle="yes">R</italic>’s sequence each sampled position belongs to (plus the reference to its name) in array <italic toggle="yes">Beg</italic> of length <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>Let us illustrate it with a simple example (cf. <xref rid="btad313-F1" ref-type="fig">Fig. 1</xref>). The initial array of sequences is {(<monospace>chr1</monospace>, 0), (<monospace>chr2</monospace>, 4), (<monospace>chr3</monospace>, 7), (<monospace>chr4</monospace>, 13), (<monospace>chr5</monospace>, 17), (<monospace>chr6</monospace>, 27), (<monospace>chr7</monospace>, 32)}. The shortest sequence is <monospace>chr2</monospace>, whose length is 3. For this reason, we sample <italic toggle="yes">R</italic> with step 3. If, e.g. a match starts at position 17 in <italic toggle="yes">R</italic>, we access <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">Beg</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>17</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Beg</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="monospace">chr4</mml:mi><mml:mo>,</mml:mo><mml:mn>13</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and its successor (if exists), i.e. <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">Beg</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>6</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="monospace">chr5</mml:mi><mml:mo>,</mml:mo><mml:mn>17</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. As <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mn>17</mml:mn><mml:mo>≥</mml:mo><mml:mn>17</mml:mn></mml:mrow></mml:math></inline-formula>, we conclude that the match starts in sequence <monospace>chr5</monospace>. Let us have another example, with a match starting at position 14 in <italic toggle="yes">R</italic>. We access <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">Beg</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mn>14</mml:mn><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">Beg</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="monospace">chr3</mml:mi><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Its successor is <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">Beg</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>5</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="monospace">chr4</mml:mi><mml:mo>,</mml:mo><mml:mn>13</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. As <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mn>14</mml:mn><mml:mo>≥</mml:mo><mml:mn>13</mml:mn></mml:mrow></mml:math></inline-formula>, we conclude that the match starts in <monospace>chr4</monospace>. Note also that a match starting at position 12 would belong to <monospace>chr3</monospace> (as <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mn>12</mml:mn><mml:mo>&lt;</mml:mo><mml:mn>13</mml:mn></mml:mrow></mml:math></inline-formula>). In the actual implementation, to avoid divisions, we replace the computed step <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> with the largest power of 2 not greater than <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">min</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (i.e. 3 would be replaced with 2 in this example).</p>
      <fig position="float" id="btad313-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Example of the static predecessor query data structure in copMEM2.</p>
        </caption>
        <graphic xlink:href="btad313f1" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>To evaluate the performance of copMEM2, we chose pairs of real multi-FASTA datasets used in earlier works, plus a pair of human genomes, hg18 and hg19. The <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref> contains the dataset URLs and characteristics. The tests were conducted on Intel Core i9-10940X (14 cores) 3.3 GHz CPU, 128 GB of DDR4-RAM (CL 16, clocked at 2666 MHz), and a fast SSD (ADATA 2 TB M.2 PCIe NVMe XPG SX8200 Pro), running Linux (Debian 11) OS. All codes were written in C++ and compiled with gcc 10.2.1 -O3.</p>
    <p>The presented timings, are median times of 3 runs in a particular setting (pair of datasets, chosen <italic toggle="yes">L</italic>, and possibly the number of threads). Before each run, the RAM memory of the linux machine was filled with a dummy value, to flush disk caches. In other words, all tests were run with a “cold cache.”</p>
    <p>MEM finding times and RAM usages are given in <xref rid="btad313-T1" ref-type="table">Table 1</xref>. Usually 12 threads were selected (-t 12), but to compare copMEM2 with copMEM, it is also run in a single-threaded mode (-t 1). We were not able to obtain E-MEM2 to test it, but according to the results presented in (<xref rid="btad313-B7" ref-type="bibr">Portes de Cerqueira Cesar 2020</xref>, Chap. 4), it would not be competitive to copMEM2, even in the hg18 vs hg19 test.</p>
    <table-wrap position="float" id="btad313-T1">
      <label>Table 1.</label>
      <caption>
        <p>MEM results.<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1">MEM alg.</th>
            <th colspan="4" align="center" rowspan="1"><italic toggle="yes">H. sapiens</italic> vs <italic toggle="yes">M. musculus</italic><hr/></th>
            <th colspan="4" align="center" rowspan="1"><italic toggle="yes">H. sapiens</italic> vs <italic toggle="yes">P. troglodytes</italic><hr/></th>
            <th colspan="4" align="center" rowspan="1"><italic toggle="yes">T. aestivum</italic> vs <italic toggle="yes">T. durum</italic><hr/></th>
            <th colspan="4" align="center" rowspan="1"><italic toggle="yes">hg18</italic> vs <italic toggle="yes">hg19</italic><hr/></th>
          </tr>
          <tr>
            <th align="center" rowspan="1" colspan="1"/>
            <th colspan="2" align="center" rowspan="1">
              <inline-formula id="IE31">
                <mml:math id="IM31" display="inline" overflow="scroll">
                  <mml:mrow>
                    <mml:mi>L</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>50</mml:mn>
                  </mml:mrow>
                </mml:math>
              </inline-formula>
              <hr/>
            </th>
            <th colspan="2" align="center" rowspan="1">
              <inline-formula id="IE32">
                <mml:math id="IM32" display="inline" overflow="scroll">
                  <mml:mrow>
                    <mml:mi>L</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>200</mml:mn>
                  </mml:mrow>
                </mml:math>
              </inline-formula>
              <hr/>
            </th>
            <th colspan="2" align="center" rowspan="1">
              <inline-formula id="IE33">
                <mml:math id="IM33" display="inline" overflow="scroll">
                  <mml:mrow>
                    <mml:mi>L</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>50</mml:mn>
                  </mml:mrow>
                </mml:math>
              </inline-formula>
              <hr/>
            </th>
            <th colspan="2" align="center" rowspan="1">
              <inline-formula id="IE34">
                <mml:math id="IM34" display="inline" overflow="scroll">
                  <mml:mrow>
                    <mml:mi>L</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>200</mml:mn>
                  </mml:mrow>
                </mml:math>
              </inline-formula>
              <hr/>
            </th>
            <th colspan="2" align="center" rowspan="1">
              <inline-formula id="IE35">
                <mml:math id="IM35" display="inline" overflow="scroll">
                  <mml:mrow>
                    <mml:mi>L</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>50</mml:mn>
                  </mml:mrow>
                </mml:math>
              </inline-formula>
              <hr/>
            </th>
            <th colspan="2" align="center" rowspan="1">
              <inline-formula id="IE36">
                <mml:math id="IM36" display="inline" overflow="scroll">
                  <mml:mrow>
                    <mml:mi>L</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>200</mml:mn>
                  </mml:mrow>
                </mml:math>
              </inline-formula>
              <hr/>
            </th>
            <th colspan="2" align="center" rowspan="1">
              <inline-formula id="IE37">
                <mml:math id="IM37" display="inline" overflow="scroll">
                  <mml:mrow>
                    <mml:mi>L</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>50</mml:mn>
                  </mml:mrow>
                </mml:math>
              </inline-formula>
              <hr/>
            </th>
            <th colspan="2" align="center" rowspan="1">
              <inline-formula id="IE38">
                <mml:math id="IM38" display="inline" overflow="scroll">
                  <mml:mrow>
                    <mml:mi>L</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mn>200</mml:mn>
                  </mml:mrow>
                </mml:math>
              </inline-formula>
              <hr/>
            </th>
          </tr>
          <tr>
            <th align="center" rowspan="1" colspan="1"/>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">E-MEM -t 1</td>
            <td rowspan="1" colspan="1">1866.3</td>
            <td rowspan="1" colspan="1">9.24</td>
            <td rowspan="1" colspan="1">497.7</td>
            <td rowspan="1" colspan="1">
              <bold>2.54</bold>
            </td>
            <td rowspan="1" colspan="1">4973.0</td>
            <td rowspan="1" colspan="1">12.44</td>
            <td rowspan="1" colspan="1">806.9</td>
            <td rowspan="1" colspan="1">
              <bold>2.69</bold>
            </td>
            <td rowspan="1" colspan="1">715.0</td>
            <td rowspan="1" colspan="1">13.55</td>
            <td rowspan="1" colspan="1">454.1</td>
            <td rowspan="1" colspan="1">
              <bold>3.85</bold>
            </td>
            <td rowspan="1" colspan="1">—</td>
            <td rowspan="1" colspan="1">—</td>
            <td rowspan="1" colspan="1">141 732.0</td>
            <td rowspan="1" colspan="1">
              <bold>2.62</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">copMEM</td>
            <td rowspan="1" colspan="1">907.5</td>
            <td rowspan="1" colspan="1">17.99</td>
            <td rowspan="1" colspan="1">23.5</td>
            <td rowspan="1" colspan="1">6.52</td>
            <td rowspan="1" colspan="1">3262.9</td>
            <td rowspan="1" colspan="1">44.64</td>
            <td rowspan="1" colspan="1">60.2</td>
            <td rowspan="1" colspan="1">6.62</td>
            <td rowspan="1" colspan="1">362.1</td>
            <td rowspan="1" colspan="1">18.96</td>
            <td rowspan="1" colspan="1">47.8</td>
            <td rowspan="1" colspan="1">9.81</td>
            <td rowspan="1" colspan="1">—</td>
            <td rowspan="1" colspan="1">—</td>
            <td rowspan="1" colspan="1">121 265.0</td>
            <td rowspan="1" colspan="1">6.65</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">bfMEM -t 1</td>
            <td rowspan="1" colspan="1">1815.4</td>
            <td rowspan="1" colspan="1">12.03</td>
            <td rowspan="1" colspan="1">298.1</td>
            <td rowspan="1" colspan="1">4.91</td>
            <td rowspan="1" colspan="1">6509.9</td>
            <td rowspan="1" colspan="1">39.34</td>
            <td rowspan="1" colspan="1">312.3</td>
            <td rowspan="1" colspan="1">5.17</td>
            <td rowspan="1" colspan="1">753.4</td>
            <td rowspan="1" colspan="1">15.81</td>
            <td rowspan="1" colspan="1">376.2</td>
            <td rowspan="1" colspan="1">7.85</td>
            <td rowspan="1" colspan="1">—</td>
            <td rowspan="1" colspan="1">—</td>
            <td rowspan="1" colspan="1">304 931.0</td>
            <td rowspan="1" colspan="1">5.75</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">copMEM2 -t 1</td>
            <td rowspan="1" colspan="1">311.9</td>
            <td rowspan="1" colspan="1">8.14</td>
            <td rowspan="1" colspan="1">25.3</td>
            <td rowspan="1" colspan="1">6.53</td>
            <td rowspan="1" colspan="1">1211.9</td>
            <td rowspan="1" colspan="1">
              <bold>8.19</bold>
            </td>
            <td rowspan="1" colspan="1">44.8</td>
            <td rowspan="1" colspan="1">6.61</td>
            <td rowspan="1" colspan="1">179.6</td>
            <td rowspan="1" colspan="1">10.65</td>
            <td rowspan="1" colspan="1">47.2</td>
            <td rowspan="1" colspan="1">8.46</td>
            <td rowspan="1" colspan="1">2719.2</td>
            <td rowspan="1" colspan="1">24.77</td>
            <td rowspan="1" colspan="1">56.8</td>
            <td rowspan="1" colspan="1">6.57</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">E-MEM -t 12</td>
            <td rowspan="1" colspan="1">1170.9</td>
            <td rowspan="1" colspan="1">9.24</td>
            <td rowspan="1" colspan="1">103.4</td>
            <td rowspan="1" colspan="1">
              <bold>2.54</bold>
            </td>
            <td rowspan="1" colspan="1">3970.0</td>
            <td rowspan="1" colspan="1">12.44</td>
            <td rowspan="1" colspan="1">147.2</td>
            <td rowspan="1" colspan="1">
              <bold>2.69</bold>
            </td>
            <td rowspan="1" colspan="1">251.8</td>
            <td rowspan="1" colspan="1">13.55</td>
            <td rowspan="1" colspan="1">118.3</td>
            <td rowspan="1" colspan="1">
              <bold>3.85</bold>
            </td>
            <td rowspan="1" colspan="1">148 622.0</td>
            <td rowspan="1" colspan="1">20.89</td>
            <td rowspan="1" colspan="1">19 346.0</td>
            <td rowspan="1" colspan="1">
              <bold>2.62</bold>
            </td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">bfMEM -t 12</td>
            <td rowspan="1" colspan="1">517.0</td>
            <td rowspan="1" colspan="1">
              <bold>7.27</bold>
            </td>
            <td rowspan="1" colspan="1">33.2</td>
            <td rowspan="1" colspan="1">6.57</td>
            <td rowspan="1" colspan="1">1931.1</td>
            <td rowspan="1" colspan="1">23.08</td>
            <td rowspan="1" colspan="1">36.8</td>
            <td rowspan="1" colspan="1">7.00</td>
            <td rowspan="1" colspan="1">110.1</td>
            <td rowspan="1" colspan="1">15.82</td>
            <td rowspan="1" colspan="1">50.3</td>
            <td rowspan="1" colspan="1">7.85</td>
            <td rowspan="1" colspan="1">97 505.3</td>
            <td rowspan="1" colspan="1">
              <bold>13.79</bold>
            </td>
            <td rowspan="1" colspan="1">51 779.0</td>
            <td rowspan="1" colspan="1">10.27</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">copMEM2 -t 12</td>
            <td rowspan="1" colspan="1">
              <bold>59.0</bold>
            </td>
            <td rowspan="1" colspan="1">10.40</td>
            <td rowspan="1" colspan="1">9.4</td>
            <td rowspan="1" colspan="1">8.09</td>
            <td rowspan="1" colspan="1">
              <bold>225.0</bold>
            </td>
            <td rowspan="1" colspan="1">10.47</td>
            <td rowspan="1" colspan="1">
              <bold>11.5</bold>
            </td>
            <td rowspan="1" colspan="1">8.47</td>
            <td rowspan="1" colspan="1">
              <bold>31.0</bold>
            </td>
            <td rowspan="1" colspan="1">11.34</td>
            <td rowspan="1" colspan="1">13.1</td>
            <td rowspan="1" colspan="1">9.11</td>
            <td rowspan="1" colspan="1">
              <bold>323.9</bold>
            </td>
            <td rowspan="1" colspan="1">16.57</td>
            <td rowspan="1" colspan="1">
              <bold>18.4</bold>
            </td>
            <td rowspan="1" colspan="1">8.35</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">copMEM2 -t 12 -mf</td>
            <td rowspan="1" colspan="1">63.5</td>
            <td rowspan="1" colspan="1">9.18</td>
            <td rowspan="1" colspan="1">
              <bold>8.8</bold>
            </td>
            <td rowspan="1" colspan="1">7.01</td>
            <td rowspan="1" colspan="1">235.3</td>
            <td rowspan="1" colspan="1">9.25</td>
            <td rowspan="1" colspan="1">14.9</td>
            <td rowspan="1" colspan="1">7.37</td>
            <td rowspan="1" colspan="1">34.2</td>
            <td rowspan="1" colspan="1">
              <bold>10.13</bold>
            </td>
            <td rowspan="1" colspan="1">
              <bold>12.1</bold>
            </td>
            <td rowspan="1" colspan="1">7.92</td>
            <td rowspan="1" colspan="1">329.0</td>
            <td rowspan="1" colspan="1">15.51</td>
            <td rowspan="1" colspan="1">27.4</td>
            <td rowspan="1" colspan="1">7.23</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn1">
          <label>a</label>
          <p>Times in seconds, memory (RAM) usages in GBs (<italic toggle="yes">G</italic> = <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>9</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>).</p>
        </fn>
        <fn id="tblfn2">
          <p>Test platform: Intel Core i9-10940X (14 cores) 3.3 GHz CPU, 128 GB of DDR4-RAM (2666 MHz, CL 16) and a fast SSD (ADATA 2 TB M.2 PCIe NVMe XPG SX8200 Pro), running Linux (Debian 11) OS. All codes written in C++ and compiled with gcc 10.2.1 -O3. The copMEM2 values of <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>50</mml:mn></mml:mrow></mml:math></inline-formula> (resp. <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>200</mml:mn></mml:mrow></mml:math></inline-formula>) are <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>36</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (resp. <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>13</mml:mn><mml:mo>,</mml:mo><mml:mn>11</mml:mn><mml:mo>,</mml:mo><mml:mn>56</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) in the default mode and <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>36</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (resp. <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>13</mml:mn><mml:mo>,</mml:mo><mml:mn>12</mml:mn><mml:mo>,</mml:mo><mml:mn>44</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) in the -mf mode. The bfMEM times and max memory usages include match ordering postprocessing.</p>
        </fn>
        <fn id="tblfn3">
          <p>All genus names are expanded in <xref rid="sup1" ref-type="supplementary-material">Table 1 of the Supplementary Material</xref>.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>In the single-threaded experiments copMEM2 is a clear winner in speed, usually beating its predecessor by a factor of about 2–3 for <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>50</mml:mn></mml:mrow></mml:math></inline-formula>, but rather slightly for <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>200</mml:mn></mml:mrow></mml:math></inline-formula>, where there are not so many matches to process. The gap grows to at least three orders of magnitude in the case of highly similar genomes (hg18 and hg19). Switching to 12 threads boosts copMEM2 by a factor from 5.3 to 8.4 (<inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>50</mml:mn></mml:mrow></mml:math></inline-formula>) and from 2.7 to 3.9 (<inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>200</mml:mn></mml:mrow></mml:math></inline-formula>). In the latter case, the speedup is smaller than offered by E-MEM and bfMEM, but still copMEM2 is always more than three times faster, and the gap is greater for <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>50</mml:mn></mml:mrow></mml:math></inline-formula>. In memory usage, copMEM2 -t 1 is significantly less demanding than copMEM for <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>50</mml:mn></mml:mrow></mml:math></inline-formula>, but the difference is small for <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>200</mml:mn></mml:mrow></mml:math></inline-formula>. The memory-frugal mode (-mf) reduces the RAM usage by more than 1 GB for usually up to 10% longer processing times. Overall, we can say that copMEM2 working in a multithreaded mode, tends to be a few times faster (or orders of magnitudes faster in case of highly similar genomes) than its contenders, while spending a comparable amount of memory (although E-MEM is clearly more succinct for large <italic toggle="yes">L</italic>).</p>
    <p>In the experiments presented in <xref rid="btad313-T2" ref-type="table">Table 2</xref>, pairs of canine and feline genomes were used. Three MEM-finding tools were used, run only in the 12-thread mode. copMEM2 is a clear winner in speed, beating the second bfMEM by a factor from 2.7 (<italic toggle="yes">Felis catus</italic>, <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:math></inline-formula>) to 5.9 (<italic toggle="yes">Canis familiaris</italic>, <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>80</mml:mn></mml:mrow></mml:math></inline-formula>). Its advantage in speed over E-MEM is often about an order of magnitude. In memory usage, E-MEM is the most frugal while copMEM2 and bfMEM use roughly a similar amount of memory. This experiment suggests that these two pairs of genomes are not as similar as the human ones, where the gap in processing times between the tools was a few orders of magnitude.</p>
    <table-wrap position="float" id="btad313-T2">
      <label>Table 2.</label>
      <caption>
        <p>MEM results on pairs of same-species datasets.<xref rid="tblfn3" ref-type="table-fn"><sup>a</sup></xref></p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1"/>
            <th colspan="6" align="center" rowspan="1">Canis familiaris (canFam6 vs canFam4)<hr/></th>
            <th colspan="6" align="center" rowspan="1">Felis catus (felCat9 vs felCat8)<hr/></th>
          </tr>
          <tr>
            <th rowspan="1" colspan="1">Tool</th>
            <th colspan="2" align="center" rowspan="1"> <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>80</mml:mn></mml:mrow></mml:math></inline-formula><hr/></th>
            <th colspan="2" align="center" rowspan="1"> <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:math></inline-formula><hr/></th>
            <th colspan="2" align="center" rowspan="1"> <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>200</mml:mn></mml:mrow></mml:math></inline-formula><hr/></th>
            <th colspan="2" align="center" rowspan="1"> <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>80</mml:mn></mml:mrow></mml:math></inline-formula><hr/></th>
            <th colspan="2" align="center" rowspan="1"> <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn></mml:mrow></mml:math></inline-formula><hr/></th>
            <th colspan="2" align="center" rowspan="1"> <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>200</mml:mn></mml:mrow></mml:math></inline-formula><hr/></th>
          </tr>
          <tr>
            <th align="center" rowspan="1" colspan="1"/>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
            <th align="center" rowspan="1" colspan="1">Time</th>
            <th align="center" rowspan="1" colspan="1">RAM</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">E-MEM -t 12</td>
            <td rowspan="1" colspan="1">751.9</td>
            <td rowspan="1" colspan="1">3.86</td>
            <td rowspan="1" colspan="1">350.2</td>
            <td rowspan="1" colspan="1">3.12</td>
            <td rowspan="1" colspan="1">139.6</td>
            <td rowspan="1" colspan="1">2.03</td>
            <td rowspan="1" colspan="1">2140.9</td>
            <td rowspan="1" colspan="1">10.05</td>
            <td rowspan="1" colspan="1">686.6</td>
            <td rowspan="1" colspan="1">3.36</td>
            <td rowspan="1" colspan="1">160.8</td>
            <td rowspan="1" colspan="1">2.20</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">bfMEM -t 12</td>
            <td rowspan="1" colspan="1">360.9</td>
            <td rowspan="1" colspan="1">9.30</td>
            <td rowspan="1" colspan="1">144.8</td>
            <td rowspan="1" colspan="1">8.51</td>
            <td rowspan="1" colspan="1">47.0</td>
            <td rowspan="1" colspan="1">6.88</td>
            <td rowspan="1" colspan="1">901.1</td>
            <td rowspan="1" colspan="1">14.91</td>
            <td rowspan="1" colspan="1">323.4</td>
            <td rowspan="1" colspan="1">10.04</td>
            <td rowspan="1" colspan="1">49.7</td>
            <td rowspan="1" colspan="1">8.88</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">copMEM2 -t 12</td>
            <td rowspan="1" colspan="1">61.0</td>
            <td rowspan="1" colspan="1">7.64</td>
            <td rowspan="1" colspan="1">36.8</td>
            <td rowspan="1" colspan="1">7.48</td>
            <td rowspan="1" colspan="1">12.2</td>
            <td rowspan="1" colspan="1">6.75</td>
            <td rowspan="1" colspan="1">262.2</td>
            <td rowspan="1" colspan="1">18.47</td>
            <td rowspan="1" colspan="1">119.9</td>
            <td rowspan="1" colspan="1">9.87</td>
            <td rowspan="1" colspan="1">18.0</td>
            <td rowspan="1" colspan="1">7.75</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn4">
          <label>a</label>
          <p>1 GB = <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>9</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> bytes.</p>
        </fn>
        <fn id="tblfn5">
          <p><italic toggle="yes">Note</italic>: The bfMEM times and max memory usages include match ordering postprocessing.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>In the last experiment, we evaluate the impact of the number of working threads on the three MEM-finding tools. We took two cases, in which <italic toggle="yes">L</italic> was set to 300 (large output) and 50 (small output).</p>
    <p><xref rid="btad313-F2" ref-type="fig">Figure 2</xref> shows that for <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>50</mml:mn></mml:mrow></mml:math></inline-formula> E-MEM’s parallelization capabilities are not on a par with bfMEM and copMEM2, and its peak performance is for 6 or 8 threads. For small <italic toggle="yes">L</italic> copMEM2 is about 5.7–5.8 times faster with 14 threads compared to single-threaded runs. For bfMEM the corresponding speedup factors are about 3.7. Note however that bfMEM is a 2-phase tool: after its main processing it requires a postprocessing procedure (which is implemented as a single-threaded one) to order properly the output. For this reason, its overall parallelization in large output scenarios is not so impressive. Without the postprocessing routine, bfMEM’s speedup with 14 threads is close to 7-fold.</p>
    <fig position="float" id="btad313-F2">
      <label>Figure 2.</label>
      <caption>
        <p>The varying performance of the MEM-finding tools with a growing number of threads. (a) Speedup with 14 threads compared to 1 thread, for E-MEM, bfMEM, copMEM2: 1.35, 3.85, 6.55. (b) Speedup with 14 threads compared to 1 thread, for E-MEM, bfMEM, copMEM2: 1.07, 3.73, 6.68. (c) Speedup with 14 threads compared to 1 thread, for E-MEM, bfMEM, copMEM2: 5.36, 11.42, 2.43. (d) Speedup with 14 threads compared to 1 thread, for E-MEM, bfMEM, copMEM2: 6.37, 11.50, 3.50.</p>
      </caption>
      <graphic xlink:href="btad313f2" position="float"/>
    </fig>
    <p>For <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mn>300</mml:mn></mml:mrow></mml:math></inline-formula> bfMEM wins in the parallelization category. Still copMEM2 is the fastest software (for 14 threads it is 3 times faster than bfMEM). The bottlenecks are probably the reading time of the input files, the limited possibilities of prefetching and parallel access to memory.</p>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>Parallelism and algorithmic engineering are powerful tools aiming at software optimization, especially targeting modern hardware. In copMEM2, our proposed MEM-finding solution, we combined a number of ideas augmenting the original copMEM scheme, to obtain significant speedups and memory usage reductions. In particular, copMEM2 running with 12 threads on a multicore CPU is faster than its main competitors roughly by a factor between 3 and more than 10.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad313_Supplementary_Data</label>
      <media xlink:href="btad313_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was financed by the Lodz University of Technology, Faculty of Electrical, Electronic, Computer and Control Engineeringas a part of statutory activity (project no. 501/12-24-1-5418).</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The data underlying this article are available in multiple repositories, with their URLs given in Sec. 1 of the <xref rid="sup1" ref-type="supplementary-material">supplementary material</xref>.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad313-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Grabowski</surname><given-names>S</given-names></string-name>, <string-name><surname>Bieniecki</surname><given-names>W.</given-names></string-name></person-group><article-title>copMEM: finding maximal exact matches via sampling both genomes</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>677</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">30060142</pub-id></mixed-citation>
    </ref>
    <ref id="btad313-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Khiste</surname><given-names>N</given-names></string-name>, <string-name><surname>Ilie</surname><given-names>L.</given-names></string-name></person-group><article-title>E-MEM: efficient computation of maximal exact matches for very large genomes</article-title>. <source>Bioinformatics</source><year>2015</year>;<volume>31</volume>:<fpage>509</fpage>–<lpage>14</lpage>.<pub-id pub-id-type="pmid">25399029</pub-id></mixed-citation>
    </ref>
    <ref id="btad313-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kurtz</surname><given-names>S</given-names></string-name>, <string-name><surname>Phillippy</surname><given-names>A</given-names></string-name>, <string-name><surname>Delcher</surname><given-names>AL</given-names></string-name></person-group><etal>et al</etal><article-title>Versatile and open software for comparing large genomes</article-title>. <source>Genome Biol</source><year>2004</year>;<volume>5</volume>:<fpage>R12</fpage>.<pub-id pub-id-type="pmid">14759262</pub-id></mixed-citation>
    </ref>
    <ref id="btad313-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>Y</given-names></string-name>, <string-name><surname>Schmidt</surname><given-names>B.</given-names></string-name></person-group><article-title>Long read alignment based on maximal exact match seeds</article-title>. <source>Bioinformatics</source><year>2012</year>;<volume>28</volume>:<fpage>i318</fpage>–<lpage>i324</lpage>.<pub-id pub-id-type="pmid">22962447</pub-id></mixed-citation>
    </ref>
    <ref id="btad313-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>Y</given-names></string-name>, <string-name><surname>Peng</surname><given-names>H</given-names></string-name>, <string-name><surname>Wong</surname><given-names>L</given-names></string-name></person-group><etal>et al</etal><article-title>High-speed and high-ratio referential genome compression</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>3364</fpage>–<lpage>72</lpage>.<pub-id pub-id-type="pmid">28651329</pub-id></mixed-citation>
    </ref>
    <ref id="btad313-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>Y</given-names></string-name>, <string-name><surname>Zhang</surname><given-names>LY</given-names></string-name>, <string-name><surname>Li</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Fast detection of maximal exact matches via fixed sampling of query <italic toggle="yes">K</italic>-mers and bloom filtering of index <italic toggle="yes">K</italic>-mers</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>4560</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">30994891</pub-id></mixed-citation>
    </ref>
    <ref id="btad313-B7">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Portes de Cerqueira Cesar</surname><given-names>VL.</given-names></string-name></person-group> Efficient computation of maximal exact matches between genomic sequences. MSc Thesis, The University of Western Ontario, <year>2020</year>.</mixed-citation>
    </ref>
  </ref-list>
</back>
