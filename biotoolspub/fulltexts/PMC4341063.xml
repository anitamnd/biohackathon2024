<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4341063</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btu706</article-id>
    <article-id pub-id-type="publisher-id">btu706</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="heading">
          <subject>Genome Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Using 2<italic>k</italic> + 2 bubble searches to find single nucleotide polymorphisms in <italic>k</italic>-mer graphs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Younsi</surname>
          <given-names>Reda</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>MacLean</surname>
          <given-names>Dan</given-names>
        </name>
        <xref ref-type="corresp" rid="btu706-COR1">*</xref>
      </contrib>
      <aff>The Sainsbury Laboratory, Norwich Research Park, Norwich NR4 7UH, UK</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btu706-COR1">*To whom correspondence should be addressed.</corresp>
      <fn id="FN1">
        <p>Associate Editor: Alfonso Valencia</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>01</day>
      <month>3</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>24</day>
      <month>10</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>24</day>
      <month>10</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>31</volume>
    <issue>5</issue>
    <fpage>642</fpage>
    <lpage>646</lpage>
    <history>
      <date date-type="received">
        <day>24</day>
        <month>4</month>
        <year>2014</year>
      </date>
      <date date-type="rev-recd">
        <day>19</day>
        <month>9</month>
        <year>2014</year>
      </date>
      <date date-type="accepted">
        <day>21</day>
        <month>10</month>
        <year>2014</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Single nucleotide polymorphism (SNP) discovery is an important preliminary for understanding genetic variation. With current sequencing methods, we can sample genomes comprehensively. SNPs are found by aligning sequence reads against longer assembled references. De Bruijn graphs are efficient data structures that can deal with the vast amount of data from modern technologies. Recent work has shown that the topology of these graphs captures enough information to allow the detection and characterization of genetic variants, offering an alternative to alignment-based methods. Such methods rely on depth-first walks of the graph to identify closing bifurcations. These methods are conservative or generate many false-positive results, particularly when traversing highly inter-connected (complex) regions of the graph or in regions of very high coverage.</p>
      <p><bold>Results:</bold> We devised an algorithm that calls SNPs in converted De Bruijn graphs by enumerating 2<italic>k</italic> + 2 cycles. We evaluated the accuracy of predicted SNPs by comparison with SNP lists from alignment-based methods. We tested accuracy of the SNP calling using sequence data from 16 ecotypes of <italic>Arabidopsis thaliana</italic> and found that accuracy was high. We found that SNP calling was even across the genome and genomic feature types. Using sequence-based attributes of the graph to train a decision tree allowed us to increase accuracy of SNP calls further. Together these results indicate that our algorithm is capable of finding SNPs accurately in complex sub-graphs and potentially comprehensively from whole genome graphs.</p>
      <p><bold>Availability and implementation:</bold> The source code for a C++ implementation of our algorithm is available under the GNU Public Licence v3 at: <ext-link ext-link-type="uri" xlink:href="https://github.com/danmaclean/2kplus2">https://github.com/danmaclean/2kplus2</ext-link>. The datasets used in this study are available at the European Nucleotide Archive, reference ERP00565, <ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/ena/data/view/ERP000565">http://www.ebi.ac.uk/ena/data/view/ERP000565</ext-link></p>
      <p>
        <bold>Contact:</bold>
        <email>dan.maclean@tsl.ac.uk</email>
      </p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu706/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="5"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Single nucleotide polymorphisms (SNPs) between genomes of individuals are valuable markers for tracing the genetic basis of inheritable traits or diseases. Rapid detection and creation of large libraries of SNPs is vital for timely investigation and identification of genes associated with important phenotypes. Contemporary sequencing technology can sample genomes comprehensively in only hours, with these data SNP detection is typically achieved by aligning reads to a reference genome and identifying SNPs as a difference between consensus and the reference (<xref rid="btu706-B6" ref-type="bibr">Leggett and MacLean, 2014</xref>). Factors such as the need for a reference sequence and the assumption of a monomorphic sample mean that the consensus approach is limited in organisms for which we lack a reference genome, in outbred diploid samples, bulked population data or analysis of metagenomes. To deal with the very large amount of sequence data that current sequencing technologies produce, De Bruijn graphs have been used to represent <italic>k</italic>-mer (nucleotide subsequences of arbitrary length <italic>k</italic>) overlap patterns in sequence reads. These <italic>k</italic>-mer graphs have been implemented into efficient data structures for large collections of <italic>k</italic>-mers and have proven to be of great utility as the underlying data model over which numerous <italic>de novo</italic> genome assembly algorithms have been implemented (<xref rid="btu706-B11" ref-type="bibr">Pevzner <italic>et</italic>
<italic>al</italic>., 2001</xref>, <xref rid="btu706-B16" ref-type="bibr">Zerbino and Birney, 2008</xref>, <xref rid="btu706-B14" ref-type="bibr">Simpson <italic>et</italic>
<italic>al</italic>., 2009</xref>). Methods based on the De Bruijn graph have been implemented recently that can efficiently identify sample differences in sequence read sets (<xref rid="btu706-B5" ref-type="bibr">Iqbal <italic>et</italic>
<italic>al</italic>., 2012</xref>, <xref rid="btu706-B7" ref-type="bibr">Leggett <italic>et</italic>
<italic>al</italic>., 2013</xref>). <xref rid="btu706-B5" ref-type="bibr">Iqbal et al. (2012)</xref> produced the first model and <italic>de novo</italic> assembly algorithms for variant discovery and genotyping directly from sequence data without using a reference genome. They incorporated a colour attribute for the edges in the graph that represents the sample from which the sequence is derived. In these multi-sample graphs polymorphisms appear as bubbles, a closing bifurcation of length 2<italic>k</italic> + 2 with separate colours on each branch of the bifurcation 1. Discovering bubbles is a promising tactic for identifying SNPs in the graph, the bubble caller in Iqbal <italic>et al.</italic> and the more computationally intensive depth-first search method in <xref rid="btu706-B7" ref-type="bibr">Leggett <italic>et al.</italic> (2013)</xref> proceeds by marking the vertices in the graph that have at least two edges departing from them as starting points and following vertices sequentially until a vertex with at least two edges entering it is reached (<xref ref-type="fig" rid="btu706-F1">Fig. 1</xref>). An alternative micro-assembly approach (<xref rid="btu706-B10" ref-type="bibr">Peterlongo <italic>et</italic>
<italic>al</italic>., 2010</xref>) begins by producing a tree of <italic>k</italic>-mers for an input read set picking a seed <italic>k</italic>-mer and assuming that it lies on one path through a SNP and then looks for an opposite <italic>k</italic>-mer, one substitution different, which would lie on another path through the bubble. If this can be found in the <italic>k</italic>-mer tree, then a recursive algorithm builds paths left and right of each <italic>k</italic>-mer until they join or no <italic>k</italic>-mer can be found. Further to graph structure, the attributes of the sample and sampled sequence reads can be used.
<fig id="btu706-F1" position="float"><label>Fig. 1.</label><caption><p>De Bruijn graph fragment with edge and vertex attributes as represented in the Cortex software and used in this study. Vertices represent <italic>k</italic>-mers from sequence fragments and their reverse complements, edges represent directional overlap between sequence and edge annotations represent the changed base between edges. Coloured numbers in vertices indicate coverage (times the <italic>k</italic>-mer is observed) in the respective ’orange’ or ’green’ coloured sample</p></caption><graphic xlink:href="btu706f1p"/></fig></p>
  </sec>
  <sec>
    <title>2 Approach</title>
    <p>De Bruijn graphs of sequence reads are typically very large with the vast majority of vertices having only a single in and out edge, as such no complex bubbles can exist in these areas and much of the graph need not be searched. Thus, we first build a sub-graph from a branching vertex that has at least two out edges and search sub-graphs for cycles. We retain only cycles of length 2<italic>k</italic> + 2 with two equidistant branching vertices in which the edge paths on each branch are a different colour. Internal nodes may be branching. These constraints allow us to simplify the search for cycles by only checking the locality of the starting branching vertex. Once the algorithm terminates, a simple walk of the vertices in the bubble, collecting the labels, gives the sequence. The two coloured <italic>k</italic> + 1 walks result in separate nucleotide sequences of length <italic>k</italic> + 1 in which the first nucleotide differs between the samples. Our method’s very precise description of a bubble means that it has the potential to be extremely specific and generate highly accurate lists of SNPs from graph structure alone.</p>
  </sec>
  <sec>
    <title>3 Methods</title>
    <sec>
      <title>3.1 Datasets</title>
      <p>We used thirteen sets of Illumina sequence reads from different ecotypes of the model plant <italic>A.</italic><italic>thaliana</italic> with the <italic>A.</italic><italic>thaliana</italic> ecotype Col-0 genome as the common reference (<xref rid="btu706-B15" ref-type="bibr">AGI, 2000</xref>). For each of these, high-quality SNP lists are available at the European Nucleotide Archive under reference ERP000565 (<xref rid="btu706-B3" ref-type="bibr">Gan <italic>et al</italic>., 2011</xref>). Reads are of 36 and 51 bp long with 200- and 400-bp inserts, respectively, with between 27- and 60-fold coverage. <italic>Arabidopsis thaliana</italic> has a small (126 Mbp) tractable genome with only a relatively small repeat content and well-catalogued genetic diversity, making it an ideal test organism.</p>
    </sec>
    <sec>
      <title>3.2 2<italic>k</italic> + 2 Bubble detection algorithm</title>
      <p>We used Cortex (<xref rid="btu706-B5" ref-type="bibr">Iqbal <italic>et</italic>
<italic>al</italic>., 2012</xref>) to build a graph directly from sequence data, removing paths of vertices with coverage 2 or below and tips less than 100 nucleotides in length. The resulting graph is exported and is then transformed to an undirected graph, retaining the edge attributes. Then 2<italic>k</italic> + 2 (<boxed-text id="btu706-BOX1" position="float"><caption><title>Algorithm 1. A bubble detection algorithm (2<italic>k</italic> + 2)</title></caption><p><list list-type="order"><list-item><p><italic>G</italic> is an undirected graph; <inline-formula><mml:math id="MM1"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, edges have attributes <italic>sequence</italic> and <inline-formula><mml:math id="MM2"><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>g</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><italic>T</italic> is the maximum number of sub-graphs to be created, <inline-formula><mml:math id="MM3"><mml:mrow><mml:mi>T</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><italic>S</italic> is an initially empty set of found cycles, <inline-formula><mml:math id="MM4"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mo>⊘</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><italic>C</italic> is an initially empty set of computed contigs, <inline-formula><mml:math id="MM5"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mo>⊘</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><italic>k</italic> is the length of the string in the <italic>sequence</italic> edge attribute, <inline-formula><mml:math id="MM6"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><italic>b</italic> is a list of all branching vertices in <italic>G</italic></p></list-item><list-item><p><bold>while</bold><inline-formula><mml:math id="MM7"><mml:mrow><mml:mi>t</mml:mi><mml:mo>≠</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula><bold>do</bold></p></list-item><list-item><p> Build sub-graph <inline-formula><mml:math id="MM8"><mml:mrow><mml:mi>g</mml:mi><mml:mo>⊂</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p> Select a vertex <italic>v</italic> from <italic>b</italic></p></list-item><list-item><p> Traverse 2<italic>k</italic> + 2 edges in <italic>g</italic>, store vertices passed as <italic>s</italic></p></list-item><list-item><p> <bold>if</bold>
<italic>v</italic> is the current vertex <bold>and</bold>
<italic>s</italic> has 2 equidistant branching vertices with distinct variant colours <bold>then</bold></p></list-item><list-item><p>   <inline-formula><mml:math id="MM9"><mml:mrow><mml:mi>S</mml:mi><mml:mo>←</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p> <bold>end if</bold></p></list-item><list-item><p><bold>end while</bold></p></list-item><list-item><p><bold>for</bold><italic>s</italic> in <italic>S</italic>
<bold>do</bold></p></list-item><list-item><p> <bold>for</bold>
<italic>colour</italic> in (<italic>orange</italic>, <italic>green</italic>, <italic>mixed</italic>) <bold>do</bold></p></list-item><list-item><p>   <italic>c</italic> is empty string</p></list-item><list-item><p>   Traverse edges of <italic>s</italic> that have attribute <italic>colour</italic></p></list-item><list-item><p>   Append last character from edge attribute string <italic>sequence</italic> to <italic>c</italic></p></list-item><list-item><p> <bold>end for</bold></p></list-item><list-item><p> <inline-formula><mml:math id="MM10"><mml:mrow><mml:mi>C</mml:mi><mml:mo>←</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><bold>end for</bold></p></list-item><list-item><p>Output: Set of contigs <italic>C</italic></p></list-item></list></p></boxed-text><xref ref-type="boxed-text" rid="btu706-BOX1">Algorithm 1</xref>) is applied to create short contigs bearing SNPs. The search is based around identifying sub-graphs to search. The size of the sub-graphs is user defined and chosen depending on the complexity of the graph. A small sub-graph in a simple graph structure can return no SNPs and a sub-graph in a very complex structure has a prohibitive running time, there is no algorithmic bound. The algorithm as a whole is fast and can be easily modified for parallel processing. For the datasets used in this study searches ran from 4 to 48 h depending on the structure of the graph. In addition, the algorithm has a free parameter to choose the number of predicted SNPs to call and a time limit parameter to run. The algorithm allows flexible graph search strategies and by cutting the graphs into sub-graphs using a neighbourhood technique, we can speed up the search process and make the search extremely parallel, and therefore, potentially extremely scalable.</p>
    </sec>
    <sec>
      <title>3.3 Using canonical SNP lists to assess accuracy of the algorithm</title>
      <p>To assess the accuracy of the SNPs predicted by 2<italic>k</italic> + 2, we compared our predictions against published lists of SNPs called in the Xiangchao et al. (2011) study. The contigs generated by the 2<italic>k</italic> + 2 algorithm were used as query sequence in a BLASTn search with default settings (<xref rid="btu706-B1" ref-type="bibr">Altschul <italic>et</italic>
<italic>al</italic>., 1990</xref>) against the <italic>A.thaliana</italic> Col-0 reference sequence and used the top hit in the BLASTn to find the position of the predicted SNP in the genome. By comparing the position of the published SNPs with those from our algorithm, we could then calculate the number of SNPs accurately predicted by our algorithm as the number found in the published lists, accuracy is calculated as proportion of predicted SNPs that were included in the known SNP list. We used three measures of accuracy; sensitivity (true positive/true positive + false negative), specificity (true negative/true negative + false positive) and accuracy (proportion of predicted SNPs that were included in the known SNP list). Specificity in this analysis is always very close to 100% because of the very large number of non-SNP genome sites. As our algorithm searches only a subset of the graph defined in parameter <italic>T</italic> (<xref ref-type="boxed-text" rid="btu706-BOX1">Algorithm 1</xref>), we do not search the whole graph. In experiments here, we search a maximum of 200 000 sub-graphs and call accuracy on the number of SNPs retrieved in that set, not the whole graph.</p>
    </sec>
    <sec>
      <title>3.4 Using bubble attributes to filter and improve accuracy</title>
      <p>To use a classification algorithm such as decision trees (<xref rid="btu706-B12" ref-type="bibr">Quinlan, 1986</xref>), 2<italic>k</italic> + 2 bubble edge attributes were used to create a vector of values describing each bubble. We used coverage, summed coverage over each branch of the bubble and the mean number of branching vertices of the sub-graph where the bubble resides (See <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu706/-/DC1">Supplementary Table S1</ext-link> for summaries of the datasets used for classification). Each bubble in a graph was classified as a Real SNP or a false positive according to its presence in the SNP list and were divided into a training set and testing set. Two-third of the dataset is used for training the classifier and one third for testing. To train, we used a decision tree found in the freely available WEKA package (<xref rid="btu706-B4" ref-type="bibr">Hall, 2009</xref>) and kept the default parameters of the classifier.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Results and discussion</title>
    <sec>
      <title>4.1 SNP prediction based on structure alone is highly accurate.</title>
      <p>We ran the 2<italic>k</italic> + 2 algorithm on graphs built with <italic>k</italic> = 21 and predicted SNPs in the thirteen <italic>A.thaliana</italic> ecotypes. On average, we predicted 144541.6146741.9 ± 19560.318183.2 SNPs. The total number of SNPs we predicted increases fairly linearly with the genetic distance of the test ecotype from the reference Col-0 (using the number of canonical SNPs between Col-0 and each ecotype as a proxy for distance, <xref ref-type="fig" rid="btu706-F2">Fig. 2</xref>B) and we achieved mean accuracy of 83.2783.7 ± 3.83.5% of correctly predicted SNPs (<xref ref-type="fig" rid="btu706-F2">Fig. 2</xref>B), indicating that bubble retrieval with our bubble search algorithm alone produces highly accurate SNP predictions and that the algorithm can detect more SNPs when there are more to be detected. The genetic distance of the ecotype from the Col-0 reference does not have a marked effect on accuracy in the majority of cases we examined. For 912 of the ecotypes, we observed accuracy clustered around the 85% mark (<xref ref-type="fig" rid="btu706-F2">Fig. 2</xref>C), indicating a natural limit on the accuracy of the prediction when using bubbles. Four of the ecotypes had lower than 80% accuracy. The accuracy is higher than that seen in the unsorted output of the Cortex (<xref rid="btu706-B5" ref-type="bibr">Iqbal <italic>et</italic>
<italic>al</italic>., 2012</xref>) variant caller, which we reported at around 40% but equivalent to that seen when the output from that program is sorted according to the Bubbleparse metric described in <xref rid="btu706-B7" ref-type="bibr">Leggett <italic>et</italic>
<italic>al</italic>. (2013)</xref>. Independent runs of a later and improved Cortex on a selection of the datasets used here show higher accuracy (93 ± 0.15%, see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu706/-/DC1">Supplementary Data</ext-link>), but recalling a smaller number of the known SNPs than seen in <xref rid="btu706-B7" ref-type="bibr">Leggett <italic>et</italic>
<italic>al</italic>. (2013)</xref> perhaps indicating a tradeoff between recall and accuracy now available in Cortex.
<fig id="btu706-F2" position="float"><label>Fig. 2.</label><caption><p>Accuracy of SNP prediction using the 2<italic>k</italic> + 2 algorithm on 13 <italic>A.thaliana</italic> ecotypes. Panel A (left side) shows distribution of accuracy over all 16 ecotypes. Panel B (top right) gives the number of SNPs predicted found by 2<italic>k</italic> + 2 as a function of the SNPs expected from the canonical list. Panel C (bottom right) gives the number of SNPs accurately predicted as a function of the number of SNPs in the canonical set</p></caption><graphic xlink:href="btu706f2p"/></fig></p>
    </sec>
    <sec>
      <title>4.2 Accuracy of SNP calling is consistent across the genome</title>
      <p>To determine whether our strategy suffered from bias towards particular genomic regions, we compared the position of SNPs predicted by the 2<italic>k</italic> + 2 structure with those from the canonical lists for Col-0 and Tsu-1. Analysis of the proportion of published SNPs found by 2<italic>k</italic> + 2 in windows of 20 kbp across the genome showed consistently high recovery of SNPs. Average recall in the windows was 73% (<xref ref-type="fig" rid="btu706-F3">Fig. 3</xref>). The number of published SNPs detected fell substantially in regions corresponding to the centromeres, though the proportion detected increased due to lower numbers of SNPs in these windows.
<fig id="btu706-F3" position="float"><label>Fig. 3.</label><caption><p>The proportion of consensus-called SNPs predicted by the 2<italic>k</italic> + 2 algorithm in 20 kb windows of the five <italic>Arabidopsis thaliana</italic> nuclear chromosomes SNPs were called on graphs composed of reads from ecotype Tsu-1 relative to the Col-0 common reference. Red peaks indicate the proportion of all SNPs (blue area) found by 2<italic>k</italic> + 2 in each window. Windows reaching 100% likely contain a small number of canonical SNPs, particularly in centromere associated regions</p></caption><graphic xlink:href="btu706f3p"/></fig></p>
      <p>To determine whether SNPs in any particular genomic feature types were preferentially missed by our algorithm, we examined enrichment of feature types in the 2.5% least sensitive 20 kbp windows. The distribution of accuracy–sensitivity estimates in the windows was observed to be approximately normal, and we applied a Bonferroni-corrected hypergeometric test to each feature type, comparing the proportion in the TAIR 9 Gene Ontology annotation of the genome with the proportion in the bottom 2.5% of accuracy–sensitivity windows. We saw that non-coding regions such as pseudogenes and transposable elements were enriched in the sample (<italic>P</italic> &lt; 0.001; <xref ref-type="table" rid="btu706-T1">Table 1</xref>), it is likely because centromeric regions are enriched in these features (<xref rid="btu706-B15" ref-type="bibr">AGI, 2000</xref>). The lack of bias towards successful SNP calls in any particular genomic feature or region indicates that the random search strategy we are using to create sub-graphs does not result in bias towards any specific parts of the genome, and we conclude that the 2<italic>k</italic> + 2 algorithm has the potential to be part of a general SNP finding pipeline.
<table-wrap id="btu706-T1" position="float"><label>Table 1.</label><caption><p>Genomic feature enrichment in the <italic>A.thaliana</italic> genomic 20 kb windows that had the lowest 2.5% called SNP sensitivity rates in Col-0/Tsu-1 data</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Feature</th><th rowspan="1" colspan="1">Genome Proportion</th><th rowspan="1" colspan="1">Sample Proportion</th><th rowspan="1" colspan="1">P</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">Exon</td><td align="char" char="." rowspan="1" colspan="1">0.74</td><td align="char" char="." rowspan="1" colspan="1">0.72</td><td align="char" char="." rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">5’ UTR</td><td align="char" char="." rowspan="1" colspan="1">0.12</td><td align="char" char="." rowspan="1" colspan="1">0.08</td><td align="char" char="." rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">3’ UTR</td><td align="char" char="." rowspan="1" colspan="1">0.11</td><td align="char" char="." rowspan="1" colspan="1">0.11</td><td align="char" char="." rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">miRNA</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">tRNA</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">ncRNA</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">0.01</td><td align="char" char="." rowspan="1" colspan="1">&lt;0.001</td></tr><tr><td rowspan="1" colspan="1">Pseudogene</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">0.01</td><td align="char" char="." rowspan="1" colspan="1">&lt;0.001</td></tr><tr><td rowspan="1" colspan="1">Pseudogenic transcript</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">0.01</td><td align="char" char="." rowspan="1" colspan="1">&lt;0.001</td></tr><tr><td rowspan="1" colspan="1">Pseudogenic exon</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">0.01</td><td align="char" char="." rowspan="1" colspan="1">&lt;0.001</td></tr><tr><td rowspan="1" colspan="1">Transposable element gene</td><td align="char" char="." rowspan="1" colspan="1">0.01</td><td align="char" char="." rowspan="1" colspan="1">0.05</td><td align="char" char="." rowspan="1" colspan="1">&lt;0.001</td></tr><tr><td rowspan="1" colspan="1">snoRNA</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">snRNA</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">rRNA</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">1</td></tr></tbody></table><table-wrap-foot><fn id="btu706-TF1"><p>For each feature type, the proportion of all features in the genome and in the sample and a Bonferroni corrected <italic>P</italic>-value from the hypergeometric test is presented.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec>
      <title>4.3 The 2<italic>k</italic> + 2 algorithm finds SNPs in complex portions of the graph</title>
      <p>To establish the performance of the algorithm in complex regions of the graph, we compared the total number of branching vertices in a 100 vertex sub-graph with the number of SNPs that were predicted when each sub-graph was searched exhaustively. We looked at 54 616, 35 043 and 36 483 randomly sampled sub-graphs with more than two branching vertices for ecotypes Can-0, Bur-0 and Po-0, respectively. The majority of sub-graphs have just a few branching vertices though there are a few very heavily branched sub-graphs with more than 20 out of 100 vertices with branches (<xref ref-type="fig" rid="btu706-F4">Fig. 4</xref>A). The number of SNPs predicted in each sub-graph is most usually 1 (49, 36 and 43 of sub-graphs contain only 1 SNP for Can-0, Bur-0 and Po-0, see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu706/-/DC1">Supplementary Data</ext-link>) regardless of the number of branching vertices. We would expect the total number of SNPs predicted to increase as graph complexity increases, since SNPs nearby in the genome (in particular within <italic>k</italic> of each other) would increase graph complexity. However, this is not observed, for sub-graphs with more than 15 branching vertices, we predict only one SNP in any ecotype (<xref ref-type="fig" rid="btu706-F4">Fig. 4</xref>). Intuitively, we would expect the total number of SNPs predicted to increase as complexity increases as SNPs nearby to each in the genome other would increase graph complexity but this is not observed and for sub-graphs with more than 15 branching vertices, we predict only one SNP in any ecotype 4. Above 90% of predicted SNPs are in sub-graphs with only 2–5 branching vertices (<xref ref-type="fig" rid="btu706-F4">Fig. 4</xref>B and <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu706/-/DC1">Supplementary Data</ext-link>). The result indicates that the algorithm is most successful at retrieving SNPs in sub-graphs with only two branching vertices, though can handle moderately complex graphs and successfully identify SNPs within those sub-graphs. We have not been able to confirm whether SNP density does truly increase with graph complexity, and therefore, cannot rule out whether SNP prediction drop off in more complex regions is a true property of the graph or a failure of the 2<italic>k</italic> + 2 algorithm to detect in these regions.
<fig id="btu706-F4" position="float"><label>Fig. 4.</label><caption><p>Distribution of number of sub-graphs with given number of branching nodes (A, top panel) and the number of SNPs predicted in all sub-graphs with given number of branching nodes (B, bottom panel). Data from three ecotypes Can-0, Bur-0 and Po-0 are presented. Colour scale represents natural log of counts, see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu706/-/DC1">Supplementary Data</ext-link> for real values</p></caption><graphic xlink:href="btu706f4p"/></fig></p>
    </sec>
    <sec>
      <title>4.4 Accuracy is improved by filtering candidate bubbles using a decision tree</title>
      <p>We trained a decision tree to distinguish between known SNPs and non-SNP bubbles and applied it to the predicted bubbles from 16 ecotypes to successfully classify bubbles that represented real SNPs with higher accuracy whilst maintaining similar sensitivity and specificity than using bubble structure alone (<xref ref-type="fig" rid="btu706-F5">Fig. 5</xref>). The specificity ranged between 97.22 and 86.33%, and sensitivities vary between 84.63 and 68.71% each of which is similar to the values seen when using structure alone. Accuracy in the predicted SNP set was from 86.33 to 97.04%, much higher than from structure. This result indicates that structure and extra bubble attributes can give very highly accurate sets of predicted SNP sets. In a similar approach, with very similar <italic>A.thaliana</italic> data <xref rid="btu706-B7" ref-type="bibr">Leggett <italic>et al</italic><italic>.</italic> (2013)</xref> used a ranking heuristic to classify SNPs after initial prediction but found that accuracy of that heuristic was compromised as the number of SNPs predicted increased and in SNP sets of over 100 000 each newly predicted SNP has only a 40% likelihood of being accurate such that SNP sets of the size we predict contained very high numbers of false-positive SNP calls, the 2<italic>k</italic> + 2 algorithm and classifier outperforms that approach significantly returning better than 90% accurate SNP calls for very large SNP sets.
<fig id="btu706-F5" position="float"><label>Fig. 5.</label><caption><p>Classification accuracy of SNPs called using the Decision Tree algorithm to classify bubbles found in 2<italic>k</italic> + 2 searches on graphs made from sequence data of 13 ecotypes of <italic>A.thaliana</italic>. The results are the mean of 10 runs using the decision tree algorithm in WEKA (<xref rid="btu706-B4" ref-type="bibr">Hall 2009</xref>). Results are the mean of correctly classified bubbles that contain SNPs as listed in <xref rid="btu706-B3" ref-type="bibr">Gan <italic>et al.</italic> (2011)</xref></p></caption><graphic xlink:href="btu706f5p"/></fig></p>
    </sec>
  </sec>
  <sec>
    <title>5 Conclusion</title>
    <p>The 2<italic>k</italic> + 2 algorithm takes a graph theoretical approach to identifying topological structures, namely 2<italic>k</italic> + 2 cycles in undirected graphs that can represent SNPs in sequences input to a donor De Bruijn graph. We have shown that 2<italic>k</italic> + 2 can be used to generate sets of SNPs in graphs at high accuracy in the <italic>A.</italic><italic>thaliana</italic> genome which is increased by application of the decision tree classifier. 2<italic>k</italic> + 2 found SNPs across all portions of the <italic>A.</italic><italic>thaliana</italic> genome without bias towards feature type or region. We did not find that all SNPs seen in alignment-based methods using a reference could be detected with this algorithm and in all our experiments, we found that around 70% of SNPs seen by alignment could be predicted. The 2<italic>k</italic> + 2 strategy is, therefore, a useful algorithm that should find general use in reference-free SNP calling strategies in the future.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_31_5_642__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btu706_supplemental-data.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgement</title>
    <p>The authors wish to thank Dr Mario Caccamo, Dr Richard Leggett, Ricardo Ramirez-Gonzalez and Dr Graham Etherington for assistance during this project.</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>R.Y. was funded by a <funding-source>BBSRC</funding-source> (Biotechnology and Biological Sciences Research Council) <funding-source>TRDF2</funding-source> grant (ref: <award-id>BB/I023798/1</award-id>) to D.M. D.M. was supported by The Gatsby Charitable Foundation.</p>
    <p><italic>Conflict of interest</italic>: none declared.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="btu706-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Altschul</surname><given-names>S.F.</given-names></name><etal/></person-group> (<year>1990</year>) <article-title>Basic local alignment search tool</article-title>. <source>J. Mol. Biol.</source>, <volume>215</volume>, <fpage>403</fpage>–<lpage>410</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btu706-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gan</surname><given-names>X.</given-names></name><etal/></person-group> (<year>2011</year>) <article-title>Multiple reference genomes and transcriptomes for <italic>Arabidopsis thaliana</italic></article-title>. <source>Nature</source>, <volume>477</volume>, <fpage>419</fpage>–<lpage>423</lpage>.<pub-id pub-id-type="pmid">21874022</pub-id></mixed-citation>
    </ref>
    <ref id="btu706-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hall</surname><given-names>M.</given-names></name><etal/></person-group> (<year>2009</year>) <article-title>The WEKA data mining software: an update</article-title>. <source>ACM SIGKDD Explor. Newsl.</source><italic>,</italic>
<volume>11</volume>, <fpage>10</fpage>–<lpage>18</lpage>.</mixed-citation>
    </ref>
    <ref id="btu706-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Iqbal</surname><given-names>Z.</given-names></name><etal/></person-group> (<year>2012</year>) <article-title>De novo assembly and genotyping of variants using colored de Bruijn graphs</article-title>. <source>Nat. Genet.</source>, <volume>44</volume>, <fpage>226</fpage>–<lpage>232</lpage>.<pub-id pub-id-type="pmid">22231483</pub-id></mixed-citation>
    </ref>
    <ref id="btu706-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Leggett</surname><given-names>R.M.</given-names></name><name><surname>MacLean</surname><given-names>D.</given-names></name></person-group> (<year>2014</year>) <article-title>Reference-free SNP detection: dealing with the data deluge</article-title>. <source>BMC Genomics</source>, <volume>15</volume>, <fpage>S10</fpage>.<pub-id pub-id-type="pmid">25056481</pub-id></mixed-citation>
    </ref>
    <ref id="btu706-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Leggett</surname><given-names>R.M.</given-names></name><etal/></person-group> (<year>2013</year>) <comment>Identifying and classifying trait linked polymorphisms in non-reference species by walking coloured De Bruijn graphs (submitted)</comment>.</mixed-citation>
    </ref>
    <ref id="btu706-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Peterlongo</surname><given-names>P.</given-names></name><etal/></person-group> (<year>2010</year>) <article-title>Identifying SNPs without a reference genome by comparing raw reads</article-title>. <source>Lect. Notes Comput. Sci.</source>, <volume>6393</volume>, <fpage>147</fpage>–<lpage>158</lpage>.</mixed-citation>
    </ref>
    <ref id="btu706-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pevzner</surname><given-names>P.A.</given-names></name><name><surname>Tang</surname><given-names>H.</given-names></name><name><surname>Waterman</surname><given-names>M.S.</given-names></name></person-group> (<year>2001</year>) <article-title>An Eulerian path approach to DNA fragment assembly</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>98</volume>, <fpage>9748</fpage>–<lpage>9753</lpage>.<pub-id pub-id-type="pmid">11504945</pub-id></mixed-citation>
    </ref>
    <ref id="btu706-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Quinlan</surname><given-names>J.R.</given-names></name></person-group> (<year>1986</year>) <article-title>Induction of decision trees</article-title>. <source>Mach. Learn.</source>, <volume>1</volume>, <fpage>81</fpage>–<lpage>106</lpage>.</mixed-citation>
    </ref>
    <ref id="btu706-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Simpson</surname><given-names>J.T.</given-names></name><etal/></person-group> (<year>2009</year>) <article-title>ABySS: a parallel assembler for short read sequence data</article-title>. <source>Genome Res.</source>, <volume>19</volume>, <fpage>1117</fpage>–<lpage>1123</lpage>.<pub-id pub-id-type="pmid">19251739</pub-id></mixed-citation>
    </ref>
    <ref id="btu706-B15">
      <mixed-citation publication-type="journal"><collab>The Arabidopsis Genome Initiative</collab> (<year>2000</year>) <article-title>Analysis of the genome sequence of the flowering plant <italic>Arabidopsis thaliana</italic></article-title>. <source>Nature</source>, <volume>408</volume>, <fpage>796</fpage>–<lpage>815</lpage>.<pub-id pub-id-type="pmid">11130711</pub-id></mixed-citation>
    </ref>
    <ref id="btu706-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zerbino</surname><given-names>D.R.</given-names></name><name><surname>Birney</surname><given-names>E.</given-names></name></person-group> (<year>2008</year>) <article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>. <source>Genome Res.</source>, <volume>18</volume>, <fpage>821</fpage>–<lpage>829</lpage>.<pub-id pub-id-type="pmid">18349386</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
