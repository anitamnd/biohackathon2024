<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.2 20060430//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.2?>
<?ConverterInfo.XSLTName nlm2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Nucleic Acids Res</journal-id>
    <journal-id journal-id-type="iso-abbrev">Nucleic Acids Res</journal-id>
    <journal-id journal-id-type="publisher-id">Nucleic Acids Research</journal-id>
    <journal-title-group>
      <journal-title>Nucleic Acids Research</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">0305-1048</issn>
    <issn pub-type="epub">1362-4962</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">1635250</article-id>
    <article-id pub-id-type="pmid">17068081</article-id>
    <article-id pub-id-type="doi">10.1093/nar/gkl511</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Computational Biology</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Multiple alignment of protein sequences with repeats and rearrangements</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Phuong</surname>
          <given-names>Tu Minh</given-names>
        </name>
        <xref rid="au1" ref-type="aff">1</xref>
        <xref rid="cor1" ref-type="corresp">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Do</surname>
          <given-names>Chuong B.</given-names>
        </name>
        <xref rid="au2" ref-type="aff">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Edgar</surname>
          <given-names>Robert C.</given-names>
        </name>
        <xref rid="au3" ref-type="aff">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Batzoglou</surname>
          <given-names>Serafim</given-names>
        </name>
        <xref rid="au2" ref-type="aff">2</xref>
        <xref rid="cor1" ref-type="corresp">*</xref>
      </contrib>
      <aff id="au1">
        <sup>1</sup>
        <institution>Department of Computer Science, Posts &amp; Telecommunications Institute of Technology</institution>
        <addr-line>Hanoi, Vietnam</addr-line>
      </aff>
      <aff id="au2">
        <sup>2</sup>
        <institution>Department of Computer Science, Stanford University</institution>
        <addr-line>Stanford, CA, USA</addr-line>
      </aff>
      <aff id="au3">
        <sup>3</sup>
        <addr-line>195 Roque Moraes Drive, Mill Valley CA 94941, USA</addr-line>
      </aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor1"><sup>*</sup>To whom correspondence should be addressed. Email: <email>serafim@cs.stanford.edu</email></corresp>
      <fn>
        <p><sup>*</sup>Correspondence may also be addressed to Tu Minh Phuong. Tel: 844 8692133; Fax: 8434 511408; Email: <email>phuongtm@fpt.com.vn</email></p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>11</month>
      <year>2006</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>26</day>
      <month>11</month>
      <year>2006</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>26</day>
      <month>11</month>
      <year>2006</year>
    </pub-date>
    <volume>34</volume>
    <issue>20</issue>
    <fpage>5932</fpage>
    <lpage>5942</lpage>
    <history>
      <date date-type="received">
        <day>25</day>
        <month>4</month>
        <year>2006</year>
      </date>
      <date date-type="rev-recd">
        <day>28</day>
        <month>6</month>
        <year>2006</year>
      </date>
      <date date-type="accepted">
        <day>05</day>
        <month>7</month>
        <year>2006</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2006 The Author(s)</copyright-statement>
      <copyright-year>2006</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbynclicense">https://creativecommons.org/licenses/by-nc/2.0/uk/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link xlink:href="https://creativecommons.org/licenses/by-nc/2.0/uk/" ext-link-type="uri">http://creativecommons.org/licenses/by-nc/2.0/uk/</ext-link>) which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>Multiple sequence alignments are the usual starting point for analyses of protein structure and evolution. For proteins with repeated, shuffled and missing domains, however, traditional multiple sequence alignment algorithms fail to provide an accurate view of homology between related proteins, because they either assume that the input sequences are globally alignable or require locally alignable regions to appear in the same order in all sequences. In this paper, we present ProDA, a novel system for automated detection and alignment of homologous regions in collections of proteins with arbitrary domain architectures. Given an input set of unaligned sequences, ProDA identifies all homologous regions appearing in one or more sequences, and returns a collection of local multiple alignments for these regions. On a subset of the BAliBASE benchmarking suite containing curated alignments of proteins with complicated domain architectures, ProDA performs well in detecting conserved domain boundaries and clustering domain segments, achieving the highest accuracy to date for this task. We conclude that ProDA is a practical tool for automated alignment of protein sequences with repeats and rearrangements in their domain architecture.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>INTRODUCTION</title>
    <p>Protein multiple sequence alignments have a wide range of applications in bioinformatics, from determination and classification of protein families (<xref rid="b1" ref-type="bibr">1</xref>,<xref rid="b2" ref-type="bibr">2</xref>) to identification of evolutionarily constrained regions for aiding protein structural or functional prediction (<xref rid="b3" ref-type="bibr">3</xref>,<xref rid="b4" ref-type="bibr">4</xref>). In principle, given a set of related sequences, a sequence alignment program identifies and organizes regions shared between some or all of the input sequences, and produces multiple alignments: ordered columns of homologous letters between the sequences interleaved with gaps. In practice, there are diverse kinds of sequence homologies exhibited within classes of related proteins: whereas some protein families share global sequence similarity, other related proteins often have short homologous regions embedded in longer regions of no conservation (<xref rid="b5" ref-type="bibr">5</xref>).</p>
    <p>For many biologically important protein families, domains may be repeated or shuffled (i.e. the order of domains may vary within a set of related proteins). Significantly, most proteins in prokaryotes and eukaryotes have multiple domains (<xref rid="b6" ref-type="bibr">6</xref>), with the number of domain instances ranging from 2 to &gt;100 (<xref rid="b7" ref-type="bibr">7</xref>,<xref rid="b8" ref-type="bibr">8</xref>). Although many current aligners address some variants of local protein homology detection (Previous Work), few existing methods attempt to fully automate the alignment of proteins with complicated domain organization. Rather, obtaining meaningful alignments of such groups of proteins often requires competent application of many existing sequence comparison tools combined with a great deal of manual intervention.</p>
    <p>In this paper, we present ProDA (protein domain aligner), an integrated alignment methodology designed specifically to tackle the problem of aligning proteins with repeated and shuffled domains. At a high level, the algorithm computes local alignments for every pair of sequences, clusters such alignments into blocks of approximately globally alignable subsequences, determines block boundaries, resolves inconsistencies between pairwise alignments and finally multiply aligns these blocks. Algorithmically, ProDA combines several existing ideas in the literature, such as progressive alignment (<xref rid="b9" ref-type="bibr">9</xref>), maximum expected accuracy and probabilistic consistency (<xref rid="b10" ref-type="bibr">10</xref>) and efficient extraction of local alignments from a Smith–Waterman table (<xref rid="b11" ref-type="bibr">11</xref>–<xref rid="b13" ref-type="bibr">13</xref>), with novel heuristics for determining domain boundaries and clustering domains (<xref rid="b14" ref-type="bibr">14</xref>).</p>
    <p>Although accuracy metrics exist for evaluating traditional alignment approaches, these measures do not assess the ability of the aligner to recapitulate the known domain organization of gold-standard alignments. Thus, we designed an ensemble of new accuracy measures that quantify the ability of an aligner to recover the correct domain organization of a set of hand-annotated multi-domain proteins. On reference set 6 of BAliBASE 2.0 (<xref rid="b15" ref-type="bibr">15</xref>), which was specially designed to include protein sequences with complex domain structures, ProDA recovers known domain organizations with higher accuracy than previous methods. We conclude that ProDA is a useful method for automated multiple alignment of multi-domain proteins and represents a significant step towards addressing a problem not solved by traditional protein aligners. Source code, executables and benchmarking scripts for program evaluation are publicly available at <ext-link xlink:href="http://proda.stanford.edu" ext-link-type="uri"/>.</p>
    <sec>
      <title>Previous work</title>
      <p>Global alignment methods implicitly assume that input sequences are related over their whole length with the exception of short insertions and deletions (<xref rid="b16" ref-type="bibr">16</xref>). When this assumption does not hold, such as in the case of multi-domain proteins with differing domain architectures, global algorithms at best produce a partial view of the homology between their input sequences. For these cases, several local multiple alignment algorithms have been developed, including DIALIGN (<xref rid="b8" ref-type="bibr">8</xref>,<xref rid="b17" ref-type="bibr">17</xref>), ITERALIGN (<xref rid="b18" ref-type="bibr">18</xref>) and SATCHMO (<xref rid="b19" ref-type="bibr">19</xref>). The POA multiple alignment algorithm (<xref rid="b20" ref-type="bibr">20</xref>) introduced partial order alignments, which represents homologies between the sequences with a directed acyclic graph. However, these methods still require that homologous regions appear in the same order in each sequence.</p>
      <p>The problem of dealing with repeated and shuffled regions in protein sequences is not unique to multiple sequence alignment. Motif finders, for example, are one class of methods that can detect repeats and rearrangements in biological sequences (<xref rid="b21" ref-type="bibr">21</xref>–<xref rid="b23" ref-type="bibr">23</xref>). These methods construct local multiple alignments from blocks of gap-free sequence fragments. However, motif finders can only find short, well-conserved motifs whose instances typically must have the same length.</p>
      <p>Dealing with repeated and shuffled domains also plays a role in the construction of protein domain databases. A common approach for constructing profiles of domain families is to use a local pairwise aligner such as BLAST (<xref rid="b24" ref-type="bibr">24</xref>,<xref rid="b25" ref-type="bibr">25</xref>) to search for homologous sequence fragments, and then realign the extracted fragments using a global multiple alignment algorithm. MACAW (<xref rid="b26" ref-type="bibr">26</xref>) was the first tool to perform this process in a semi-automatic manner—users must decide which fragments to cluster in an alignable block and where to set fragment boundaries. A later method, DOMAINER (<xref rid="b27" ref-type="bibr">27</xref>) automated these steps and was used to create early versions of the ProDom database of protein domain families (<xref rid="b28" ref-type="bibr">28</xref>); however, the DOMAINER algorithm does not allow for gapped alignments, thus greatly limiting its applicability to distantly related sequences. Mocca (<xref rid="b29" ref-type="bibr">29</xref>) is a method for finding repeats in a set of protein sequences but requires a repeat instance to be pre-specified by the user.</p>
      <p>Repeat-finding algorithms specialize in the detection and alignment of repeats within a single protein sequence (<xref rid="b11" ref-type="bibr">11</xref>,<xref rid="b30" ref-type="bibr">30</xref>–<xref rid="b32" ref-type="bibr">32</xref>). Typically, repeat finders work by finding suboptimal local alignments of a sequence to itself. Repeat libraries are then constructed from collections of suboptimal alignments. Methods for this latter step include graph clustering (<xref rid="b31" ref-type="bibr">31</xref>), heuristic repeat boundary detection (<xref rid="b30" ref-type="bibr">30</xref>) and statistical significance analysis of repeat alignments (<xref rid="b11" ref-type="bibr">11</xref>,<xref rid="b32" ref-type="bibr">32</xref>). Repeat-finding algorithms operate on single sequences, and thus do not directly handle the problem of repeat detection for multiple sequence data; we return to a discussion of their applicability to multiple alignment later (Results).</p>
      <p>For sequences with repeats but no rearrangements, the recent RAlign program applies a novel alignment algorithm that accounts for repeats (<xref rid="b33" ref-type="bibr">33</xref>). However, RAlign returns a global alignment of the input sequences, and thus makes no attempt to identify relationships between homologous segments within the same sequence.</p>
      <p>To date, the only existing tool that directly addresses the local multiple alignment problem is the ABA program of Raphael <italic>et al</italic>. (<xref rid="b12" ref-type="bibr">12</xref>). Given a set of sequences and a set of pairwise local alignments, ABA constructs a weighted, cyclic, directed multi-graph called an A-Bruijn graph to represent the multiple alignment of a set of input sequences. Here, construction of a multiple alignment reduces to construction of the corresponding A-Bruijn graph, where high-multiplicity edges represent aligned protein domains. Though A-Bruijn graphs are flexible enough to represent a large variety of domain organizations, the performance of the actual ABA alignment tool in identifying homology in biological sequences is unknown. In Results, we compare the ABA tool to our own method, ProDA, on real data.</p>
    </sec>
  </sec>
  <sec>
    <title>MATERIALS AND METHODS</title>
    <sec>
      <title>Algorithm overview</title>
      <p>Given <italic>m</italic> protein sequences <italic>S</italic> = {<italic>S</italic><sub>1</sub>, … , <italic>S<sub>m</sub></italic>} and a minimum alignment length <italic>L</italic><sub>min</sub>, ProDA returns a set of aligned regions with length at least <italic>L</italic><sub>min</sub>. The algorithm consists of seven steps (<xref rid="fig1" ref-type="fig">Figure 1</xref>):</p>
      <fig position="float" id="fig1">
        <label>
Figure 1
</label>
        <caption>
          <p>Overview of the ProDA algorithm. (<bold>A</bold>) Compute all-versus-all PLAs. (<bold>B</bold>) Identify possible repeats by computing non-overlapping PLAs. (<bold>C</bold>) Generate a block of possibly alignable regions from the PLAs. (<bold>D</bold>) Compute a guide tree for the block. (<bold>E</bold>) Progressively align sequences in the block and eliminate spurious alignments using heuristic filters. (<bold>F</bold>) Trim the block alignment. (<bold>G</bold>) Discard used PLAs, and repeat the alignment process until no more alignable blocks of length at least <italic>L</italic><sub>min</sub> can be found. The end result is a set of aligned regions with length at least <italic>L</italic><sub>min</sub>.</p>
        </caption>
        <graphic xlink:href="gkl511f1" position="float"/>
      </fig>
      <p>
        <italic>Step 1: Generation of pairwise local alignments (PLAs)</italic>
      </p>
      <p>Using the pair-HMM shown in <xref rid="fig2" ref-type="fig">Figure 2</xref>, compute all local alignments of length at least <italic>L</italic><sub>min</sub> between each pair of sequences in <italic>S</italic>. To do this, repeat the following until no local alignment of length at least <italic>L</italic><sub>min</sub> is found:
<list list-type="order"><list-item><p>Compute the best local alignment using either a variant of posterior decoding (Algorithm Details) or the Viterbi algorithm. Stop if the best local alignment is shorter than <italic>L</italic><sub>min</sub>. Otherwise, store the alignment found.</p></list-item><list-item><p>Mark cells in the dynamic programming matrix corresponding to the best alignment found in substep 1, disallowing them from contributing to future alignments.</p></list-item></list></p>
      <fig position="float" id="fig2">
        <label>
Figure 2
</label>
        <caption>
          <p>Pair HMM for local alignment of two sequences <italic>x</italic> and <italic>y</italic>. State <italic>M</italic> emits two letters, one from each sequence, and corresponds to the two letters being aligned together. State <italic>I<sub>x</sub></italic> emits a letter in sequence <italic>x</italic> that is aligned to a gap, and similarly state <italic>I<sub>y</sub></italic> emits a letter in sequence <italic>y</italic> that is aligned to a gap. States <italic>LF<sub>x</sub></italic> and <italic>LF<sub>y</sub></italic> emit two unaligned flanking subsequences on the left of the local alignment. Similarly, states <italic>RF</italic><sub>x</sub> and <italic>RF</italic><sub>y</sub> emit two unaligned flanking subsequences on the right of the local alignment.</p>
        </caption>
        <graphic xlink:href="gkl511f2" position="float"/>
      </fig>
      <p>
        <italic>Step 2: Inference of repeats from pairwise alignments</italic>
      </p>
      <p>Some local alignments found in Step 1 may simultaneously overlap in both sequences, indicating the presence of repeats. Break overlapping alignments into shorter non-overlapping PLAs that putatively correspond to individual repeats. This step can be seen as a post-processing step for Step 1 and does not guarantee finding all real repeats.</p>
      <p>
        <italic>Step 3: Generation of a block of alignable sequence fragments</italic>
      </p>
      <p>Two sequence fragments are alignable if they align to each other in one PLA or both of them align to a third fragment in two different PLAs. A block of alignable fragments is a set of sequence fragments in which at least one fragment is alignable to all the other fragments. Compute the block <italic>B</italic> with the maximum number of alignable fragments. Define the boundaries of each fragment within the block by averaging the boundary positions of PLAs corresponding to the block fragments.</p>
      <p>
        <italic>Step 4: Construction of guide tree and adjustment of the block</italic>
      </p>
      <p>For the block <italic>B</italic> from Step 3:
<list list-type="order"><list-item><p>For every pair of sequence fragments <italic>b, c</italic> ∈ <italic>B</italic> compute the posterior probabilities <italic>P</italic>(<italic>b<sub>i</sub></italic> ∼ <italic>c<sub>j</sub></italic> ∣ <italic>b</italic>, <italic>c</italic>) that letters <italic>b<sub>i</sub></italic> ∈ <italic>b</italic> and <italic>c<sub>j</sub></italic> ∈ <italic>c</italic> are paired in an alignment generated by the pair HMM of <xref rid="fig3" ref-type="fig">Figure 3</xref>.</p></list-item><list-item><p>Define the expected accuracy of a pairwise alignment <italic>A</italic> between <italic>b</italic> and <italic>c</italic> to be the expected number of correctly aligned pairs of letters, divided by the length of the shorter sequence:
<disp-formula><mml:math id="M1" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>E</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext>accuracy</mml:mtext><mml:mo>(</mml:mo><mml:mi>A</mml:mi><mml:mo>)</mml:mo><mml:mo>∣</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mtext>min</mml:mtext><mml:mo>(</mml:mo><mml:mo>|</mml:mo><mml:mi>b</mml:mi><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mi>c</mml:mi><mml:mo>|</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mfrac><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:munder></mml:mstyle><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
Construct a guide tree for <italic>B</italic> via hierarchical clustering, using <italic>E</italic>(<italic>b</italic>,<italic>c</italic>) = max<italic><sub>A</sub> E</italic>(accuracy(<italic>A</italic>) ∣ <italic>b,c</italic>) as a measure of similarity between two fragments <italic>b</italic> and <italic>c</italic>. Stop the clustering procedure early if the similarity between two clusters to be merged drops below a threshold. Select the largest tree <italic>T</italic> built up to this point as the guide tree for <italic>B</italic>.</p></list-item><list-item><p>Retain only fragments belonging to tree <italic>T</italic> and remove all the other fragments from <italic>B</italic>.</p></list-item><list-item><p>Re-estimate the match scores <italic>P</italic>(<italic>b<sub>i</sub></italic> ∼ <italic>c<sub>j</sub></italic> ∣ <italic>b</italic>, <italic>c</italic>) using the probabilistic consistency transformation, which incorporates similarity of <italic>b</italic> and <italic>c</italic> to other fragments from <italic>B</italic> into the <italic>b</italic>–<italic>c</italic> pairwise comparison.
<disp-formula><mml:math id="M2" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>←</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mo>∈</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:munder></mml:mstyle><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:munder></mml:mstyle><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
</p></list-item></list></p>
      <fig position="float" id="fig3">
        <label>
Figure 3
</label>
        <caption>
          <p>Example of alignments produced by ProDA. Here we show the alignments of four proteins with SWISSPROT ids GRB2_HUMAN, MATK_HUMAN, CRKL_HUMAN and ABL1_HUMAN, respectively. This set was used previously to demonstrate POA (<xref rid="b20" ref-type="bibr">20</xref>) and ABA (<xref rid="b12" ref-type="bibr">12</xref>). In (i) we show each sequence as a line to scale such that one residue always has the same length. Above the line is the PFAM (<xref rid="b21" ref-type="bibr">21</xref>,<xref rid="b42" ref-type="bibr">42</xref>) annotation, below the line are the regions aligned by ProDA. These regions are assigned arbitrary letters that refer to the detailed alignments in (<bold>A</bold>) through (<bold>D</bold>). ABL1_HUMAN is truncated as it is significantly longer than the other sequences (1130 residues, compared with 507 for MATK_HUMAN), and there are no further PFAM annotations or aligned ProDA regions. In this set we observe different domain structures in each protein including a tandem repeat (SH3 in CRKL_HUMAN) and a rearrangement (SH2-SH3 in CRKL_HUMAN and SH3-SH2 in ABL1_HUMAN). In this example, ProDA successfully reconstructs the known domain organization, although the tyrosine kinase domain is split into two segments (C and D).</p>
        </caption>
        <graphic xlink:href="gkl511f3" position="float"/>
      </fig>
      <p>
        <italic>Step 5: Progressive alignment of the block</italic>
      </p>
      <p>For the block and corresponding tree built in Step 4 progressively align fragments according to the order specified in the tree. Alignments are scored using a sum-of-pairs scoring function in which aligned residues are assigned the match quality scores <italic>P</italic>(<italic>b<sub>i</sub></italic> ∼ <italic>c<sub>j</sub></italic> ∣ <italic>b, c</italic>) and gap penalties are set to zero.</p>
      <p>
        <italic>Step 6: Extraction of final alignments from block alignment</italic>
      </p>
      <p>Extract the longest fraction of the block alignment that begins and ends with columns containing no gaps.</p>
      <p>
        <italic>Step 7: Removal of used PLAs</italic>
      </p>
      <p>Remove PLAs corresponding to the fragments of the block to prevent them from contributing to subsequent blocks. If no PLAs remain, stop the algorithm. Otherwise go to Step 3.</p>
      <p>The end result of the algorithm is a set of aligned regions with length at least <italic>L</italic><sub>min</sub>. An example alignment generated via the ProDA algorithm is shown in <xref rid="fig3" ref-type="fig">Figure 3</xref>.</p>
    </sec>
    <sec>
      <title>Algorithm details</title>
      <p>In this section, we provide a detailed description of each step in the ProDA algorithm.</p>
      <sec>
        <title>1. Pairwise local alignment</title>
        <p>The ProDA algorithm begins by performing all-versus-all pairwise local alignments (PLAs). For each pair of sequences <italic>x</italic> and <italic>y</italic> in <italic>S</italic>, ProDA computes a set of high-scoring local alignments using an iterative procedure; in each step of the iterative procedure, a single PLA is found using either a variant of posterior decoding (described below) or the Viterbi algorithm.</p>
        <p>In practice, computing all-versus-all local alignments is the most computationally demanding part of the algorithm. On a Pentium IV 3.6 GHz system with 2 GB memory, ProDA processes all 86 reference sets of proteins within BAliBASE reference 6 in ∼2.5 h when using posterior decoding, and in &lt;1 h when using Viterbi decoding for pairwise alignment.</p>
      </sec>
      <sec>
        <title>Pairwise alignment using posterior decoding</title>
        <p>For each pair of input sequences <italic>x</italic> and <italic>y</italic>, ProDA models the probability distribution over all possible alignments using the pair-HMM shown in <xref rid="fig2" ref-type="fig">Figure 2</xref>. In particular, the ProDA posterior decoding algorithm distinguishes between three types of events: (i) <italic>x<sub>i</sub></italic> ∼ <italic>y<sub>j</sub></italic> = <italic>M</italic>: letters <italic>x<sub>i</sub></italic> and <italic>y<sub>j</sub></italic> are aligned (i.e. emitted simultaneously by the pair-HMM); (ii) <italic>x<sub>i</sub></italic> = <italic>F<sub>x</sub></italic>: letter <italic>x<sub>i</sub></italic> was emitted from one of the <italic>x</italic> flanking states (<italic>LF<sub>x</sub></italic> or <italic>RF<sub>x</sub></italic>); and (iii) <italic>y<sub>j</sub></italic> = <italic>F<sub>y</sub></italic>: letter <italic>y<sub>j</sub></italic> was emitted from one of the <italic>y</italic> flanking states (<italic>LF<sub>y</sub></italic> or <italic>RF<sub>y</sub></italic>). ProDA performs the following steps:
<list list-type="alpha-lower"><list-item><p>Let <italic>Z</italic> denote a set of pairs of positions from <italic>x</italic> and <italic>y</italic> that we do not allow to be aligned. Initially, let <italic>Z</italic> be the empty set.</p></list-item><list-item><p>For each <italic>i</italic> and <italic>j</italic>, compute the posterior probabilities <italic>P</italic>(<italic>x<sub>i</sub></italic> ∼ <italic>y<sub>j</sub></italic> = <italic>M</italic> ∣ <italic>x</italic>, <italic>y</italic>, <italic>Z</italic>), <italic>P</italic>(<italic>x<sub>i</sub></italic> = <italic>F<sub>x</sub></italic> ∣ <italic>x</italic>, <italic>y</italic>, <italic>Z</italic>), and <italic>P</italic>(<italic>y<sub>j</sub></italic> = <italic>F<sub>y</sub></italic> ∣ <italic>x</italic>, <italic>y</italic>, <italic>Z</italic>) using a modification of the standard forward and backward algorithms (<xref rid="b28" ref-type="bibr">28</xref>).</p></list-item><list-item><p>Define the quality <italic>q</italic>(<italic>A</italic>) of a local alignment <italic>A</italic> as
<disp-formula><mml:math id="M3" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>q</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>A</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:munder></mml:mstyle><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo>⋅</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∼</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>x</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>y</mml:mi></mml:msub><mml:mo>∣</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mi>Z</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
where the sum is taken over all aligned residue pairs <italic>x<sub>i</sub></italic> ∼ <italic>y<sub>j</sub></italic> in <italic>A</italic>. ProDA computes the local alignment <italic>A</italic><sup>*</sup> that maximizes <italic>q</italic>(<italic>A</italic>) using the Smith–Waterman algorithm (<xref rid="b13" ref-type="bibr">13</xref>).</p></list-item><list-item><p>If <italic>A</italic><sup>*</sup> is shorter than <italic>L</italic><sub>min</sub> then stop. Otherwise, store the local alignment found and proceed to (e).</p></list-item><list-item><p>For each aligned residue pair <italic>x<sub>i</sub></italic> ∼ <italic>y<sub>j</sub></italic> in the local alignment <italic>A</italic>*, we wish to ignore future local alignments from reusing the same residue pair or identifying a repeat of size shorter than <italic>L</italic><sub>min</sub>. To accomplish this, we mark all candidate letter pairs that are within <italic>L</italic><sub>min</sub> residues of (<italic>x<sub>i</sub></italic>,<italic>y<sub>j</sub></italic>) in either sequence <italic>x</italic> or sequence <italic>y</italic>; i.e. set
<disp-formula><mml:math id="M4" overflow="scroll"><mml:mrow><mml:mi>Z</mml:mi><mml:mo>←</mml:mo><mml:mi>Z</mml:mi><mml:mo>∪</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
for all <italic>k</italic> such that −<italic>L</italic><sub>min</sub> &lt; <italic>k</italic> &lt; <italic>L</italic><sub>min</sub> (<xref rid="fig4" ref-type="fig">Figure 4</xref>).</p></list-item><list-item><p>Using our new augmented set <italic>Z</italic> of disallowed residue pairs, go back to Step (b) and recompute the posterior probabilities, noting that we disallow all HMM paths which attempt to align pairs of positions in <italic>Z</italic>.</p></list-item></list></p>
        <fig position="float" id="fig4">
          <label>
Figure 4
</label>
          <caption>
            <p>Marking of used positions in the alignment matrix. If a pair of letters <italic>x<sub>i</sub></italic> and <italic>y<sub>j</sub></italic> are paired in the current local alignment, they are marked (with a closed circle) to denote their exclusion from future local alignments. In addition, all letter pairs within <italic>L</italic><sub>min</sub> residues of (<italic>x<sub>i</sub></italic>,<italic>y<sub>j</sub></italic>) in either sequence <italic>x</italic> or sequence <italic>y</italic> are also marked (with dotted lines) in order to prevent ProDA from identifying repeats of length shorter than <italic>L</italic><sub>min</sub>.</p>
          </caption>
          <graphic xlink:href="gkl511f4" position="float"/>
        </fig>
        <p>Finding all local pairwise alignments between two sequences takes time <italic>O</italic>(<italic>nL</italic><sup>2</sup>), where <italic>L</italic> is the length of each sequence and <italic>n</italic> is the number of local alignments. For <italic>m</italic> sequences, the entire all-versus-all PLA computation takes <italic>O</italic>(<italic>nm</italic><sup>2</sup><italic>L</italic><sup>2</sup>) time. The above algorithm can be used to align a sequence against itself to find repeats by first marking the diagonal as described above. The current implementation of ProDA does not use this option, but instead finds repeats during Step 2.</p>
      </sec>
      <sec>
        <title>Pairwise alignment using Viterbi decoding</title>
        <p>Alternatively, a set of local alignments between sequences <italic>x</italic> and <italic>y</italic> can be computed using Viterbi decoding, by performing steps (a) through (f) above except that we now skip Step (b) and replace Step (c) with the following:</p>
        <p>(c′) Compute the local alignment <italic>A</italic>* that maximizes the alignment probability <italic>P</italic>(<italic>A</italic> ∣ <italic>x, y, Z</italic>) using the Viterbi algorithm (<xref rid="b16" ref-type="bibr">16</xref>).</p>
        <p>We note that there is no need to recompute the entire Viterbi dynamic programming tables in each iteration of procedure above since only a portion of the tables will be affected when marking positions to be added to <italic>Z</italic>. The Waterman–Eggert algorithm (<xref rid="b34" ref-type="bibr">34</xref>) uses this observation to compute the set of top-scoring Viterbi parses efficiently. If each local alignment has length <italic>l</italic> &lt; <italic>L</italic> and there are <italic>n</italic> alignments for each sequence pair, finding all local alignments between two sequences takes time <italic>O</italic>(<italic>L</italic><sup>2</sup>) + <italic>O</italic>(<italic>nl</italic><sup>2</sup>). Thus, the local alignment step for <italic>m</italic> sequences takes time <italic>O</italic>(<italic>m</italic><sup>2</sup><italic>L</italic><sup>2</sup>) + <italic>O</italic>(<italic>nm</italic><sup>2</sup><italic>l</italic><sup>2</sup>).</p>
      </sec>
      <sec>
        <title>2. Inference of repeats from pairwise alignments</title>
        <p>When two sequences share several nearby homologous repeats, a local alignment algorithm will generally find long local alignments spanning several repeat copies, along with shorter alignments containing fewer repeat copies. When two local alignments overlap in both sequences, ProDA breaks them into shorter alignments before proceeding to the subsequent steps (<xref rid="fig5" ref-type="fig">Figure 5</xref>).</p>
        <fig position="float" id="fig5">
          <label>
Figure 5
</label>
          <caption>
            <p>Breaking long local alignments that span several copies of a repeat. The two local alignments AD and MN overlap in both sequence <italic>x</italic> and <italic>y</italic>. Thus, we split AD into AB, BC and CD in order to obtain a set of non-overlapping PLAs.</p>
          </caption>
          <graphic xlink:href="gkl511f5" position="float"/>
        </fig>
        <p>If there are originally <italic>n</italic> local alignments of two sequences, the number of resulting non-overlapping PLAs is at most <italic>O</italic>(<italic>n</italic><sup>2</sup>) [e.g. <italic>n</italic> copies of a perfect tandem repeat yield <italic>n</italic>(<italic>n</italic> − 1)/2 PLAs]. For a local alignment <italic>A</italic>, computing the set of sequence <italic>x</italic> boundaries for all alignments that overlap <italic>A</italic> in sequence <italic>y</italic> takes <italic>O</italic>(<italic>n</italic>) time and splitting <italic>A</italic> takes <italic>O</italic>(<italic>l</italic>) time, so the total running time for repeat inference is <italic>O</italic>(<italic>nm</italic><sup>2</sup><italic>l</italic>).</p>
      </sec>
      <sec>
        <title>3. Blocks of alignable sequence fragments</title>
        <p>From an arbitrary set of PLAs, ProDA forms blocks, or sets of aligned fragments in which at least one fragment is alignable to all others either directly or via a third fragment, using a greedy iterative procedure. In each pass, ProDA selects the largest possible set of sequences to form a block. Then ProDA attempts to determine boundaries for each of the sequences in the block. This latter step can be difficult since PLAs have different lengths and boundaries (<xref rid="fig6" ref-type="fig">Figure 6A</xref>), and moreover, the pairwise alignments within a set of PLAs may be inconsistent with each other (<xref rid="fig6" ref-type="fig">Figure 6B</xref>).</p>
        <fig position="float" id="fig6">
          <label>
Figure 6
</label>
          <caption>
            <p>Challenges in determining fragment boundaries. (<bold>A</bold>) PLAs have different overlaps. (<bold>B</bold>) Different alignments are inconsistent making it hard to decide whether the third fragment should begin from the first or the second ‘L’.</p>
          </caption>
          <graphic xlink:href="gkl511f6" position="float"/>
        </fig>
        <p>ProDA uses a simple heuristic for fragment boundary determination. Recalling the definition of a block, let <italic>b</italic> denote a sequence fragment alignable to all other sequences within the current block whose boundaries we wish to determine. After filtering for outliers (see below), ProDA computes the average index of the first and last residue of sequence <italic>b</italic> in each of the PLAs; these averaged beginning and end coordinates and their projections to the other sequences form the boundaries of the new block.</p>
        <p>Long PLAs that contain many repeats or short PLAs that are similar to parts of real homologous fragments may cause dramatic skews in the average beginning and end index for the block with respect to sequence <italic>b</italic>. To prevent this from occurring, we filter out PLAs whose beginning or ending residue position in sequence <italic>b</italic> differs from the mean by &gt;1 SD, and recompute average beginning and end indices for each block after this filtering has been done. For example, in <xref rid="fig6" ref-type="fig">Figure 6A</xref>, point 1 is an outlier so the left boundary of the block is computed by averaging points 2, 3 and 4.</p>
      </sec>
      <sec>
        <title>4. Guide tree construction</title>
        <p>ProDA uses the same procedure as in ProbCons to build a tree with high expected alignment reliability. In particular, given a set of sequence fragments from a block, define the similarity function <italic>E</italic>(<italic>b</italic>,<italic>c</italic>) to be the expected accuracy of aligning two fragments <italic>b</italic> and <italic>c</italic>. Initially, each fragment is placed in its own cluster. Then, the two most similar clusters are merged to form a new cluster <italic>bc</italic>. The similarity between <italic>bc</italic> and any other cluster <italic>d</italic> is defined as <italic>E</italic>(<italic>b</italic>,<italic>c</italic>)[<italic>E</italic>(<italic>b</italic>,<italic>d</italic>) + <italic>E</italic>(<italic>c</italic>,<italic>d</italic>)]/2.</p>
        <p>ProDA stops merging when the similarity between all pairs of clusters drops below some threshold (0.5 in the current implementation) or when only one cluster remains. The tree corresponding to the largest cluster formed so far is returned. All fragments not belonging to the tree are removed from the block. This early termination removes unrelated fragments that were mistakenly added to the blocks because of errors made in previous steps.</p>
        <p>For each pair of sequences from the adjusted block, ProDA applies the probabilistic consistency transformation as used by ProbCons. As a default, ProDA uses two iterated applications of this transformation, which work well in practice (<xref rid="b10" ref-type="bibr">10</xref>). As with ProbCons, the tree construction and probabilistic consistency transformation steps require <inline-formula><mml:math id="M5" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mi>b</mml:mi><mml:mi>3</mml:mi></mml:msubsup><mml:mi>c</mml:mi><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> time, where <italic>m</italic><sub>b</sub> and <italic>L</italic><sub>b</sub> are the number of fragments and the length of each fragment of block <italic>b</italic>, and <italic>c</italic> is the average number of non-zero elements in posterior probability matrices.</p>
      </sec>
      <sec>
        <title>5. Progressive alignment</title>
        <p>This step is similar to the progressive alignment step of ProbCons. For each progressive alignment step, we run a profile–profile Needleman–Wunsch alignment procedure in which the score for matching a column containing <italic>n</italic><sub>1</sub> non-gap letters to one with <italic>n</italic><sub>2</sub> non-gap letters is computed by summing <italic>n</italic><sub>1</sub><italic>n</italic><sub>2</sub> values from the corresponding pairwise posterior matrices. No gap penalties are used.</p>
      </sec>
      <sec>
        <title>6. Final alignment extraction</title>
        <p>The start and end columns of the multiple alignment from Step 5 often contain gaps as in the example shown in <xref rid="fig7" ref-type="fig">Figure 7</xref>. These gaps correspond to errors in the aligned fragment boundaries and should not be present in the final alignment. Thus, ProDA extracts and returns the longest aligned region whose initial and final columns contain no gaps (the region inside the rectangle in <xref rid="fig7" ref-type="fig">Figure 7</xref>).</p>
        <fig position="float" id="fig7">
          <label>
Figure 7
</label>
          <caption>
            <p>An alignment with gaps in the start and end columns. Block boundaries are determined by extracting the longest subalignment that begins and ends with columns not containing gaps.</p>
          </caption>
          <graphic xlink:href="gkl511f7" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>7. Removing used PLAs</title>
        <p>If two fragments belong to an alignment formed in Step 6, their aligned portions should not occur together in subsequent alignments returned by ProDA. To guarantee this, ProDA identifies all PLAs that contain pairs of fragments from the final alignment above, and removes the used portions of these PLAs from the set of candidate PLAs.</p>
        <p>This is illustrated in <xref rid="fig8" ref-type="fig">Figure 8</xref>, in which the middle section of a PLA belongs to a final alignment generated in Step 5. ProDA removes this middle part, and retains the remaining left and right portions only if they are at least <italic>L</italic><sub>min</sub> in length.</p>
        <fig position="float" id="fig8">
          <label>
Figure 8
</label>
          <caption>
            <p>Adjustment of a PLA containing two fragments from a final block alignment.</p>
          </caption>
          <graphic xlink:href="gkl511f8" position="float"/>
        </fig>
        <p>If there are no more PLAs then the algorithm stops; otherwise it goes back to Step 3.</p>
      </sec>
    </sec>
    <sec>
      <title>Algorithm evaluation</title>
      <p>For global alignments, the sum-of-pairs (SP) score is the most common measure of aligner accuracy. For alignments of proteins with rearrangements, however, using the SP score in isolation gives a poor 1D view of the aligner's overall ability to recover the domain organization of sets of related sequences. To evaluate the empirical performance of ProDA for this task, we define measures that assess the sensitivity and specificity of an aligner at the residue, domain and cluster levels.</p>
      <sec>
        <title>1. Residue-level accuracy</title>
        <p>Let <bold>R</bold> be a collection of reference PLAs. Similarly, let <bold>T</bold> be a corresponding collection of predicted PLAs generated by an alignment algorithm. To assess the residue-level accuracy, we define the following:
<disp-formula><mml:math id="M6" overflow="scroll"><mml:mrow><mml:mrow><mml:mtext>Residue sensitivity</mml:mtext><mml:mo>(</mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:mo>,</mml:mo><mml:mtext mathvariant="bold">T</mml:mtext><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>Number of base pairings in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:mo> </mml:mo><mml:mtext>that also appear in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">T</mml:mtext></mml:mrow><mml:mrow><mml:mtext>Number of base pairings in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="M7" overflow="scroll"><mml:mrow><mml:mrow><mml:mtext>Residue specificity</mml:mtext><mml:mo> </mml:mo><mml:mo>(</mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:mo>,</mml:mo><mml:mtext mathvariant="bold">T</mml:mtext><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>Number of base pairings in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">T</mml:mtext><mml:mo> </mml:mo><mml:mtext>that also appear in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext>Number of base pairings in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">T</mml:mtext></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
Here, our measure of residue sensitivity is equivalent to the SP score used for global multiple alignments.</p>
      </sec>
      <sec>
        <title>2. Domain-level accuracy</title>
        <p>We now characterize the ability of an aligner to recapitulate known domain boundaries (endpoint agreement) and domain positions (midpoint agreement).</p>
      </sec>
      <sec>
        <title>Endpoint agreement</title>
        <p>Let <italic>s</italic> and <italic>t</italic> be two (not necessarily distinct) segments. The endpoint agreement of <italic>s</italic> and <italic>t</italic> measures how well their left and right boundary positions agree. If <italic>s</italic> has boundary positions <italic>i</italic><sub>1</sub> and <italic>i</italic><sub>2</sub> and <italic>t</italic> has boundary positions <italic>j</italic><sub>1</sub> and <italic>j</italic><sub>2</sub>, then the endpoint agreement of <italic>s</italic> and <italic>t</italic> is as follows:
<disp-formula><mml:math id="M8" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>Agreement</mml:mtext></mml:mrow><mml:mrow><mml:mi>E</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mi>s</mml:mi><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mi>t</mml:mi><mml:mo> </mml:mo><mml:mtext>come from the same sequence</mml:mtext><mml:mo> </mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo> </mml:mo><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
where
<disp-formula><mml:math id="M9" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mo> </mml:mo><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mi>c</mml:mi><mml:mo>&lt;</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>≤</mml:mo><mml:mn>2</mml:mn><mml:mi>c</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo> </mml:mo><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>2</mml:mn><mml:mi>c</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
is a function of the distance between <italic>i</italic> and <italic>j</italic> (ranging from 0 to 1). [Here, two positions are considered completely matching whenever they are within a distance <italic>c</italic> from each other, not matching if they are more than <italic>2c</italic> away from each other, or partially matching otherwise; in this last case, the function <italic>f</italic>(<italic>i</italic>, <italic>j</italic>) expresses the degree of matching as a real value from 0 (not matching) to 1 (completely matching).]</p>
        <p>Given a collection of reference PLAs <bold>R</bold> and a collection of predicted PLAs <bold>T</bold>, we define domain endpoint sensitivity and domain endpoint specificity as follows:
<disp-formula><mml:math id="M10" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mtext>Domain sensitivity</mml:mtext><mml:mrow><mml:mi>E</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:mo>,</mml:mo><mml:mtext mathvariant="bold">T</mml:mtext><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mtext>all domains</mml:mtext><mml:mi>s</mml:mi><mml:mtext>in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow></mml:munder></mml:mstyle><mml:mstyle displaystyle="true"><mml:munder><mml:mo>max</mml:mo><mml:mrow><mml:mtext>all domains</mml:mtext><mml:mo> </mml:mo><mml:mi>t</mml:mi><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mtext mathvariant="bold">T</mml:mtext></mml:mrow></mml:munder></mml:mstyle><mml:msub><mml:mtext>Agreement</mml:mtext><mml:mrow><mml:mi>E</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mtext>Number of domains in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="M11" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mtext>Domain specificity</mml:mtext><mml:mrow><mml:mi>E</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:mo>,</mml:mo><mml:mtext mathvariant="bold">T</mml:mtext><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mtext>all domains</mml:mtext><mml:mo> </mml:mo><mml:mi>t</mml:mi><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mtext mathvariant="bold">T</mml:mtext></mml:mrow></mml:munder></mml:mstyle><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>max</mml:mo><mml:mrow><mml:mtext>all domains</mml:mtext><mml:mo> </mml:mo><mml:mi>s</mml:mi><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow></mml:munder></mml:mstyle><mml:msub><mml:mtext>Agreement</mml:mtext><mml:mrow><mml:mi>E</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mtext>Number of domains in</mml:mtext><mml:mtext mathvariant="bold">T</mml:mtext></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
In the first formula, note that each of the terms in the summation is ∼1 whenever a domain <italic>s</italic> is similar to some domain in the test collection (with respect to endpoint agreement), and is ∼0 whenever <italic>s</italic> is not similar to any domain in the test collection. Therefore, the summation in the numerator approximates the number of <bold>R</bold> domains with good representatives in <bold>T</bold>, so the fraction as a whole estimates the proportion of domains in <bold>R</bold> which also ‘appear’ in <bold>T</bold>. Conversely, the second formula estimates the proportion of domains in <bold>T</bold> which also ‘appear’ in <bold>R</bold>.</p>
      </sec>
      <sec>
        <title>Midpoint agreement</title>
        <p>In some cases (such as low-identity alignments or overly conservative reference annotations), a good alignment algorithm may systematically overalign or underalign annotated domains in the reference data. If this occurs in a roughly symmetric fashion, then the midpoints of the predicted segments may still match with annotations, even when their exact boundaries do not. In these cases, we can use the midpoint agreement of <italic>s</italic> and <italic>t</italic>, defined as follows:
<disp-formula><mml:math id="M12" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>Agreement</mml:mtext></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>f</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:mfrac><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mi>s</mml:mi><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mi>t</mml:mi><mml:mo> </mml:mo><mml:mtext>come from the same sequence</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>
</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
Based on this measure, we can define midpoint domain sensitivity and midpoint domain specificity by using midpoint agreement instead of endpoint agreement in the formulas above.</p>
      </sec>
      <sec>
        <title>3. Cluster-level accuracy</title>
        <p>Finally, we define a measure that describes how well domains are clustered into globally alignable sets. In particular, our measure assumes that the reference annotation is complete and correct. An aligner should not fail to cluster homologous sequences: segments belonging to the same reference cluster should appear in the same predicted cluster. Conversely, an aligner should not overpredict homology: segments belonging to the same predicted cluster should belong to the same reference cluster.</p>
        <p>Let <italic>s</italic><sub>1</sub> and <italic>s</italic><sub>2</sub> be two distinct aligned domains <italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub> in <bold>R</bold> (i.e. <italic>s</italic><sub>1</sub> and <italic>s</italic><sub>2</sub> belong to the same PLA). If there exist distinct aligned domains <italic>t</italic><sub>1</sub>, <italic>t</italic><sub>2</sub> in <bold>T</bold> such that <italic>s</italic><sub>1</sub> and <italic>t</italic><sub>1</sub> overlap in at least 50% of their respective lengths, and similarly for <italic>s</italic><sub>2</sub> and <italic>t</italic><sub>2</sub>, then we say that <italic>s</italic><sub>1</sub> and <italic>s</italic><sub>2</sub> are alignable through <bold>T</bold>. Then, we may define cluster sensitivity and cluster specificity as follows:
<disp-formula><mml:math id="M13" overflow="scroll"><mml:mrow><mml:mrow><mml:mtext>Cluster sensitivity</mml:mtext><mml:mo>(</mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:mo>;
</mml:mo><mml:mtext mathvariant="bold">T</mml:mtext><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>Number of aligned domain pairs in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:mo> </mml:mo><mml:mtext>that are alignable through</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">T</mml:mtext></mml:mrow><mml:mrow><mml:mtext>Number of aligned domain pairs in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="M14" overflow="scroll"><mml:mrow><mml:mrow><mml:mtext>Cluster specificity</mml:mtext><mml:mo>(</mml:mo><mml:mtext mathvariant="bold">R</mml:mtext><mml:mo>;</mml:mo><mml:mtext mathvariant="bold">T</mml:mtext><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext>Number of aligned domain pairs in</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">T</mml:mtext><mml:mo> </mml:mo><mml:mtext>that are alignable through</mml:mtext><mml:mo> </mml:mo><mml:mtext mathvariant="bold">R</mml:mtext></mml:mrow><mml:mrow><mml:mtext>Number of aligned domain pairs in</mml:mtext><mml:mtext mathvariant="bold">T</mml:mtext></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
Intuitively, these two measures compute the proportion of pairwise homologies in one collection of PLAs that are supported by a corresponding homology in the other collection of PLAs.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>RESULTS</title>
    <p>We performed an empirical evaluation of ProDA on existing reference alignments with repeats and rearrangements. Our experiments measured the ability of ProDA to identify correct residue pairings, find domain boundaries and group similar domains of related proteins.</p>
    <sec>
      <title>Testing methodology</title>
      <p>Most existing global and local alignment algorithms find ordered homologies, but deal with neither the occurrence of repeated/shuffled domains nor the issue of domain boundary identification. To illustrate the amount of homology sacrificed when imposing the order constraint, we evaluated the residue-level accuracy of several existing tools—the local aligner DIALIGN 2.2 (<xref rid="b8" ref-type="bibr">8</xref>,<xref rid="b17" ref-type="bibr">17</xref>,<xref rid="b35" ref-type="bibr">35</xref>,<xref rid="b36" ref-type="bibr">36</xref>), and three popular global aligners ClustalW 1.83 (<xref rid="b37" ref-type="bibr">37</xref>), MUSCLE 3.6 (<xref rid="b38" ref-type="bibr">38</xref>) and ProbCons 1.1 (<xref rid="b10" ref-type="bibr">10</xref>)—on reference 6 of the BAliBASE 2.0 alignment benchmark (<xref rid="b15" ref-type="bibr">15</xref>), a publicly available collection of 86 hand-annotated multiple alignments of protein sequences with repeats and rearrangements. (The RAlign program (33), which computes global alignments taking repeats into account, was not available for evaluation).</p>
      <p>Reference 6 is organized into seven subsets containing sequences with different configurations of protein domains: subsets C1a and C1b consist of a few sequences with repeated domains of the same subtype; C2a, C2b and C2c, sequences with repeats of different subtypes; C3, sequences containing repeated domain and an additional non-repeated domain; and C4, sequences with shuffled domains from different protein families.</p>
      <p>We also tested two repeat finders, RADAR (<xref rid="b30" ref-type="bibr">30</xref>) and TRUST (<xref rid="b32" ref-type="bibr">32</xref>), which were originally designed to identify homologous blocks in single sequences. To adapt these methods for generating multiple sequence homologous block sets, we used a straightforward reduction to transform our problem into an instance of repeat finding in a single sequence: given multiple input sequences, we provided the concatenation of the sequences as input to the repeat finder; any repeats identified that encompassed sequence boundaries were split, and the final set of identified repeats was filtered to eliminate homologous segments less than five residues in length.</p>
      <p>For the task of uncovering domain organization in multiple sequence sets, the ABA program (<xref rid="b12" ref-type="bibr">12</xref>) is currently the only existing program that directly computes the set of homologous regions common to multiple sequences. The original implementation of ABA computes alignments for homologous segments of one or more sequences using ClustalW and projects these down to a single consensus sequence. In order to obtain a measure of ABA's residue level accuracy, we modified the ABA script to output the intermediate ClustalW multiple alignments for homologous segments directly, and retained all segments containing at least two aligned sequences.</p>
      <p>Finally, we tested our implementation of the ProDA algorithm with minimum alignment length <italic>L</italic><sub>min</sub> = 20, using either the Viterbi or posterior decoding algorithms for computing initial pairwise alignments (Materials and Methods). In all experiments, emission probabilities for the pair HMM were adapted from the BLOSUM62 scoring matrix (<xref rid="b39" ref-type="bibr">39</xref>). The default transition parameters of ProDA were trained via unsupervised expectation–maximization (EM) on unaligned sequences from references 1–5 of the BAliBASE database (<xref rid="b40" ref-type="bibr">40</xref>). Note that we did not train on reference 6, nor did we use any reference annotations from BAliBASE.</p>
      <p>We note that a number of the programs crashed on one or more of the alignments; in particular, on an Intel Xeon 3.2 GHz machine with 6 GB memory, ABA failed on 8 alignments, TRUST failed on 10 alignments and RADAR failed on 1 alignment. To provide a fair comparison, we excluded these alignments from our evaluation, assuming that the excluded alignments do not result in major biases in overall performance.</p>
    </sec>
    <sec>
      <title>Residue-level accuracy</title>
      <p>In our first set of experiments, we assessed the residue-level accuracies of all methods using our defined residue-level accuracy measures. The results for each subset of reference 6 and the entire reference are shown in <xref rid="tbl1" ref-type="table">Table 1</xref>.</p>
      <table-wrap position="float" id="tbl1">
        <label>
Table 1
</label>
        <caption>
          <p>Residue-level accuracy of aligners on BAliBASE reference 6</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left" rowspan="1" colspan="1">Score</th>
              <th align="left" rowspan="1" colspan="1">Method</th>
              <th align="left" rowspan="1" colspan="1">C1a (4)</th>
              <th align="left" rowspan="1" colspan="1">C1b (6)</th>
              <th align="left" rowspan="1" colspan="1">C2a (10)</th>
              <th align="left" rowspan="1" colspan="1">C2b (20)</th>
              <th align="left" rowspan="1" colspan="1">C2c (20)</th>
              <th align="left" rowspan="1" colspan="1">C3 (5)</th>
              <th align="left" rowspan="1" colspan="1">C4 (5)</th>
              <th align="left" rowspan="1" colspan="1">Overall (70)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="1" colspan="1">Residue sensitivity</td>
              <td align="left" rowspan="1" colspan="1">ClustalW</td>
              <td align="left" rowspan="1" colspan="1">0.30</td>
              <td align="left" rowspan="1" colspan="1">0.26</td>
              <td align="left" rowspan="1" colspan="1">0.12</td>
              <td align="left" rowspan="1" colspan="1">0.15</td>
              <td align="left" rowspan="1" colspan="1">0.16</td>
              <td align="left" rowspan="1" colspan="1">0.09</td>
              <td align="left" rowspan="1" colspan="1">0.11</td>
              <td align="left" rowspan="1" colspan="1">0.16</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">DIALIGN</td>
              <td align="left" rowspan="1" colspan="1">0.25</td>
              <td align="left" rowspan="1" colspan="1">0.25</td>
              <td align="left" rowspan="1" colspan="1">0.12</td>
              <td align="left" rowspan="1" colspan="1">0.14</td>
              <td align="left" rowspan="1" colspan="1">0.18</td>
              <td align="left" rowspan="1" colspan="1">0.10</td>
              <td align="left" rowspan="1" colspan="1">0.12</td>
              <td align="left" rowspan="1" colspan="1">0.16</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">MUSCLE</td>
              <td align="left" rowspan="1" colspan="1">0.32</td>
              <td align="left" rowspan="1" colspan="1">0.27</td>
              <td align="left" rowspan="1" colspan="1">0.12</td>
              <td align="left" rowspan="1" colspan="1">0.15</td>
              <td align="left" rowspan="1" colspan="1">0.19</td>
              <td align="left" rowspan="1" colspan="1">0.09</td>
              <td align="left" rowspan="1" colspan="1">0.12</td>
              <td align="left" rowspan="1" colspan="1">0.17</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProbCons</td>
              <td align="left" rowspan="1" colspan="1">0.37</td>
              <td align="left" rowspan="1" colspan="1">0.28</td>
              <td align="left" rowspan="1" colspan="1">0.12</td>
              <td align="left" rowspan="1" colspan="1">0.16</td>
              <td align="left" rowspan="1" colspan="1">0.20</td>
              <td align="left" rowspan="1" colspan="1">0.11</td>
              <td align="left" rowspan="1" colspan="1">0.14</td>
              <td align="left" rowspan="1" colspan="1">0.18</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ABA</td>
              <td align="left" rowspan="1" colspan="1">0.74</td>
              <td align="left" rowspan="1" colspan="1">0.51</td>
              <td align="left" rowspan="1" colspan="1">0.12</td>
              <td align="left" rowspan="1" colspan="1">0.31</td>
              <td align="left" rowspan="1" colspan="1">0.22</td>
              <td align="left" rowspan="1" colspan="1">0.09</td>
              <td align="left" rowspan="1" colspan="1">0.20</td>
              <td align="left" rowspan="1" colspan="1">0.27</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">TRUST</td>
              <td align="left" rowspan="1" colspan="1">0.38</td>
              <td align="left" rowspan="1" colspan="1">0.42</td>
              <td align="left" rowspan="1" colspan="1">0.26</td>
              <td align="left" rowspan="1" colspan="1">0.22</td>
              <td align="left" rowspan="1" colspan="1">0.31</td>
              <td align="left" rowspan="1" colspan="1">0.31</td>
              <td align="left" rowspan="1" colspan="1">0.19</td>
              <td align="left" rowspan="1" colspan="1">0.28</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">RADAR</td>
              <td align="left" rowspan="1" colspan="1">0.58</td>
              <td align="left" rowspan="1" colspan="1">0.52</td>
              <td align="left" rowspan="1" colspan="1">0.42</td>
              <td align="left" rowspan="1" colspan="1">0.38</td>
              <td align="left" rowspan="1" colspan="1">0.47</td>
              <td align="left" rowspan="1" colspan="1">0.60</td>
              <td align="left" rowspan="1" colspan="1">0.35</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Posterior</td>
              <td align="left" rowspan="1" colspan="1">0.59</td>
              <td align="left" rowspan="1" colspan="1">0.60</td>
              <td align="left" rowspan="1" colspan="1">0.32</td>
              <td align="left" rowspan="1" colspan="1">0.40</td>
              <td align="left" rowspan="1" colspan="1">0.40</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
              <td align="left" rowspan="1" colspan="1">0.39</td>
              <td align="left" rowspan="1" colspan="1">0.42</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Viterbi</td>
              <td align="left" rowspan="1" colspan="1">0.62</td>
              <td align="left" rowspan="1" colspan="1">0.62</td>
              <td align="left" rowspan="1" colspan="1">0.37</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
              <td align="left" rowspan="1" colspan="1">0.44</td>
              <td align="left" rowspan="1" colspan="1">0.51</td>
              <td align="left" rowspan="1" colspan="1">0.47</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Residue specificity</td>
              <td align="left" rowspan="1" colspan="1">ClustalW</td>
              <td align="left" rowspan="1" colspan="1">0.47</td>
              <td align="left" rowspan="1" colspan="1">0.34</td>
              <td align="left" rowspan="1" colspan="1">0.63</td>
              <td align="left" rowspan="1" colspan="1">0.55</td>
              <td align="left" rowspan="1" colspan="1">0.33</td>
              <td align="left" rowspan="1" colspan="1">0.14</td>
              <td align="left" rowspan="1" colspan="1">0.25</td>
              <td align="left" rowspan="1" colspan="1">0.42</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">DIALIGN</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
              <td align="left" rowspan="1" colspan="1">0.63</td>
              <td align="left" rowspan="1" colspan="1">0.60</td>
              <td align="left" rowspan="1" colspan="1">0.47</td>
              <td align="left" rowspan="1" colspan="1">0.28</td>
              <td align="left" rowspan="1" colspan="1">0.40</td>
              <td align="left" rowspan="1" colspan="1">0.50</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">MUSCLE</td>
              <td align="left" rowspan="1" colspan="1">0.51</td>
              <td align="left" rowspan="1" colspan="1">0.35</td>
              <td align="left" rowspan="1" colspan="1">0.63</td>
              <td align="left" rowspan="1" colspan="1">0.56</td>
              <td align="left" rowspan="1" colspan="1">0.39</td>
              <td align="left" rowspan="1" colspan="1">0.15</td>
              <td align="left" rowspan="1" colspan="1">0.30</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProbCons</td>
              <td align="left" rowspan="1" colspan="1">0.61</td>
              <td align="left" rowspan="1" colspan="1">0.44</td>
              <td align="left" rowspan="1" colspan="1">0.63</td>
              <td align="left" rowspan="1" colspan="1">0.60</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
              <td align="left" rowspan="1" colspan="1">0.22</td>
              <td align="left" rowspan="1" colspan="1">0.39</td>
              <td align="left" rowspan="1" colspan="1">0.51</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ABA</td>
              <td align="left" rowspan="1" colspan="1">0.80</td>
              <td align="left" rowspan="1" colspan="1">0.56</td>
              <td align="left" rowspan="1" colspan="1">0.59</td>
              <td align="left" rowspan="1" colspan="1">0.48</td>
              <td align="left" rowspan="1" colspan="1">0.28</td>
              <td align="left" rowspan="1" colspan="1">0.05</td>
              <td align="left" rowspan="1" colspan="1">0.35</td>
              <td align="left" rowspan="1" colspan="1">0.42</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">TRUST</td>
              <td align="left" rowspan="1" colspan="1">0.57</td>
              <td align="left" rowspan="1" colspan="1">0.56</td>
              <td align="left" rowspan="1" colspan="1">0.65</td>
              <td align="left" rowspan="1" colspan="1">0.62</td>
              <td align="left" rowspan="1" colspan="1">0.59</td>
              <td align="left" rowspan="1" colspan="1">0.56</td>
              <td align="left" rowspan="1" colspan="1">0.54</td>
              <td align="left" rowspan="1" colspan="1">0.60</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">RADAR</td>
              <td align="left" rowspan="1" colspan="1">0.60</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
              <td align="left" rowspan="1" colspan="1">0.55</td>
              <td align="left" rowspan="1" colspan="1">0.57</td>
              <td align="left" rowspan="1" colspan="1">0.65</td>
              <td align="left" rowspan="1" colspan="1">0.62</td>
              <td align="left" rowspan="1" colspan="1">0.61</td>
              <td align="left" rowspan="1" colspan="1">0.59</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Posterior</td>
              <td align="left" rowspan="1" colspan="1">0.76</td>
              <td align="left" rowspan="1" colspan="1">0.73</td>
              <td align="left" rowspan="1" colspan="1">0.64</td>
              <td align="left" rowspan="1" colspan="1">0.73</td>
              <td align="left" rowspan="1" colspan="1">0.73</td>
              <td align="left" rowspan="1" colspan="1">0.67</td>
              <td align="left" rowspan="1" colspan="1">0.67</td>
              <td align="left" rowspan="1" colspan="1">0.71</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Viterbi</td>
              <td align="left" rowspan="1" colspan="1">0.83</td>
              <td align="left" rowspan="1" colspan="1">0.69</td>
              <td align="left" rowspan="1" colspan="1">0.67</td>
              <td align="left" rowspan="1" colspan="1">0.75</td>
              <td align="left" rowspan="1" colspan="1">0.70</td>
              <td align="left" rowspan="1" colspan="1">0.67</td>
              <td align="left" rowspan="1" colspan="1">0.69</td>
              <td align="left" rowspan="1" colspan="1">0.71</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>As expected, the local aligner and three global aligners have the lowest SP scores, owing to the restriction that all elements must appear in the same order in all aligned sequences. The ABA aligner, designed specifically for these types of alignments, shows better sensitivity but in fact performs worse than the modified repeat finders. The best sensitivities are obtained by RADAR and ProDA, though both versions of ProDA significantly outperform RADAR in terms of residue-level specificity. Between the two versions of ProDA that differ in their initial pairwise alignment step, posterior decoding performs slightly worse than Viterbi decoding for residue-level accuracy.</p>
    </sec>
    <sec>
      <title>Domain-level accuracy</title>
      <p>Next, we measured the domain-level accuracy of TRUST, RADAR, ABA and ProDA in recovering known segment endpoints and midpoints. All scores were calculated with <italic>c</italic> = 10 (i.e. we only require endpoint and midpoint predictions to be correct to within 10 positions). Note that this value of <italic>c</italic> makes the endpoint measures more strict than measures used previously (<xref rid="b14" ref-type="bibr">14</xref>,<xref rid="b41" ref-type="bibr">41</xref>), where endpoints within 20 residues from the reference endpoints were counted as correct. The results are summarized in <xref rid="tbl2" ref-type="table">Table 2</xref>.</p>
      <table-wrap position="float" id="tbl2">
        <label>
Table 2
</label>
        <caption>
          <p>Domain-level accuracy of aligners on BAliBASE reference 6</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left" rowspan="1" colspan="1">Score</th>
              <th align="left" rowspan="1" colspan="1">Method</th>
              <th align="left" rowspan="1" colspan="1">C1a (4)</th>
              <th align="left" rowspan="1" colspan="1">C1b (6)</th>
              <th align="left" rowspan="1" colspan="1">C2a (10)</th>
              <th align="left" rowspan="1" colspan="1">C2b (20)</th>
              <th align="left" rowspan="1" colspan="1">C2c (20)</th>
              <th align="left" rowspan="1" colspan="1">C3 (5)</th>
              <th align="left" rowspan="1" colspan="1">C4 (5)</th>
              <th align="left" rowspan="1" colspan="1">Overall (70)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="1" colspan="1">Domain endpoint sensitivity</td>
              <td align="left" rowspan="1" colspan="1">ABA</td>
              <td align="left" rowspan="1" colspan="1">0.79</td>
              <td align="left" rowspan="1" colspan="1">0.51</td>
              <td align="left" rowspan="1" colspan="1">0.06</td>
              <td align="left" rowspan="1" colspan="1">0.24</td>
              <td align="left" rowspan="1" colspan="1">0.20</td>
              <td align="left" rowspan="1" colspan="1">0.11</td>
              <td align="left" rowspan="1" colspan="1">0.30</td>
              <td align="left" rowspan="1" colspan="1">0.25</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">TRUST</td>
              <td align="left" rowspan="1" colspan="1">0.48</td>
              <td align="left" rowspan="1" colspan="1">0.62</td>
              <td align="left" rowspan="1" colspan="1">0.24</td>
              <td align="left" rowspan="1" colspan="1">0.33</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
              <td align="left" rowspan="1" colspan="1">0.58</td>
              <td align="left" rowspan="1" colspan="1">0.30</td>
              <td align="left" rowspan="1" colspan="1">0.42</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">RADAR</td>
              <td align="left" rowspan="1" colspan="1">0.80</td>
              <td align="left" rowspan="1" colspan="1">0.58</td>
              <td align="left" rowspan="1" colspan="1">0.67</td>
              <td align="left" rowspan="1" colspan="1">0.71</td>
              <td align="left" rowspan="1" colspan="1">0.68</td>
              <td align="left" rowspan="1" colspan="1">0.87</td>
              <td align="left" rowspan="1" colspan="1">0.72</td>
              <td align="left" rowspan="1" colspan="1">0.70</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Viterbi</td>
              <td align="left" rowspan="1" colspan="1">0.73</td>
              <td align="left" rowspan="1" colspan="1">0.73</td>
              <td align="left" rowspan="1" colspan="1">0.82</td>
              <td align="left" rowspan="1" colspan="1">0.77</td>
              <td align="left" rowspan="1" colspan="1">0.76</td>
              <td align="left" rowspan="1" colspan="1">0.79</td>
              <td align="left" rowspan="1" colspan="1">0.86</td>
              <td align="left" rowspan="1" colspan="1">0.78</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Posterior</td>
              <td align="left" rowspan="1" colspan="1">0.88</td>
              <td align="left" rowspan="1" colspan="1">0.73</td>
              <td align="left" rowspan="1" colspan="1">0.91</td>
              <td align="left" rowspan="1" colspan="1">0.80</td>
              <td align="left" rowspan="1" colspan="1">0.75</td>
              <td align="left" rowspan="1" colspan="1">0.79</td>
              <td align="left" rowspan="1" colspan="1">0.86</td>
              <td align="left" rowspan="1" colspan="1">0.80</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Domain endpoint specificity</td>
              <td align="left" rowspan="1" colspan="1">ABA</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
              <td align="left" rowspan="1" colspan="1">0.24</td>
              <td align="left" rowspan="1" colspan="1">0.19</td>
              <td align="left" rowspan="1" colspan="1">0.23</td>
              <td align="left" rowspan="1" colspan="1">0.16</td>
              <td align="left" rowspan="1" colspan="1">0.05</td>
              <td align="left" rowspan="1" colspan="1">0.26</td>
              <td align="left" rowspan="1" colspan="1">0.21</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">TRUST</td>
              <td align="left" rowspan="1" colspan="1">0.38</td>
              <td align="left" rowspan="1" colspan="1">0.50</td>
              <td align="left" rowspan="1" colspan="1">0.38</td>
              <td align="left" rowspan="1" colspan="1">0.40</td>
              <td align="left" rowspan="1" colspan="1">0.49</td>
              <td align="left" rowspan="1" colspan="1">0.49</td>
              <td align="left" rowspan="1" colspan="1">0.56</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">RADAR</td>
              <td align="left" rowspan="1" colspan="1">0.43</td>
              <td align="left" rowspan="1" colspan="1">0.28</td>
              <td align="left" rowspan="1" colspan="1">0.55</td>
              <td align="left" rowspan="1" colspan="1">0.51</td>
              <td align="left" rowspan="1" colspan="1">0.40</td>
              <td align="left" rowspan="1" colspan="1">0.48</td>
              <td align="left" rowspan="1" colspan="1">0.44</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Viterbi</td>
              <td align="left" rowspan="1" colspan="1">0.46</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
              <td align="left" rowspan="1" colspan="1">0.61</td>
              <td align="left" rowspan="1" colspan="1">0.60</td>
              <td align="left" rowspan="1" colspan="1">0.48</td>
              <td align="left" rowspan="1" colspan="1">0.47</td>
              <td align="left" rowspan="1" colspan="1">0.52</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Posterior</td>
              <td align="left" rowspan="1" colspan="1">0.60</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
              <td align="left" rowspan="1" colspan="1">0.70</td>
              <td align="left" rowspan="1" colspan="1">0.63</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
              <td align="left" rowspan="1" colspan="1">0.50</td>
              <td align="left" rowspan="1" colspan="1">0.58</td>
              <td align="left" rowspan="1" colspan="1">0.58</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Domain midpoint sensitivity</td>
              <td align="left" rowspan="1" colspan="1">ABA</td>
              <td align="left" rowspan="1" colspan="1">0.73</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
              <td align="left" rowspan="1" colspan="1">0.10</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
              <td align="left" rowspan="1" colspan="1">0.18</td>
              <td align="left" rowspan="1" colspan="1">0.20</td>
              <td align="left" rowspan="1" colspan="1">0.42</td>
              <td align="left" rowspan="1" colspan="1">0.32</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">TRUST</td>
              <td align="left" rowspan="1" colspan="1">0.50</td>
              <td align="left" rowspan="1" colspan="1">0.54</td>
              <td align="left" rowspan="1" colspan="1">0.31</td>
              <td align="left" rowspan="1" colspan="1">0.31</td>
              <td align="left" rowspan="1" colspan="1">0.51</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
              <td align="left" rowspan="1" colspan="1">0.30</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">RADAR</td>
              <td align="left" rowspan="1" colspan="1">0.72</td>
              <td align="left" rowspan="1" colspan="1">0.51</td>
              <td align="left" rowspan="1" colspan="1">0.68</td>
              <td align="left" rowspan="1" colspan="1">0.81</td>
              <td align="left" rowspan="1" colspan="1">0.66</td>
              <td align="left" rowspan="1" colspan="1">0.85</td>
              <td align="left" rowspan="1" colspan="1">0.72</td>
              <td align="left" rowspan="1" colspan="1">0.71</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Viterbi</td>
              <td align="left" rowspan="1" colspan="1">0.91</td>
              <td align="left" rowspan="1" colspan="1">0.71</td>
              <td align="left" rowspan="1" colspan="1">0.90</td>
              <td align="left" rowspan="1" colspan="1">0.85</td>
              <td align="left" rowspan="1" colspan="1">0.83</td>
              <td align="left" rowspan="1" colspan="1">0.90</td>
              <td align="left" rowspan="1" colspan="1">0.91</td>
              <td align="left" rowspan="1" colspan="1">0.85</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Posterior</td>
              <td align="left" rowspan="1" colspan="1">0.92</td>
              <td align="left" rowspan="1" colspan="1">0.75</td>
              <td align="left" rowspan="1" colspan="1">0.93</td>
              <td align="left" rowspan="1" colspan="1">0.86</td>
              <td align="left" rowspan="1" colspan="1">0.84</td>
              <td align="left" rowspan="1" colspan="1">0.95</td>
              <td align="left" rowspan="1" colspan="1">0.87</td>
              <td align="left" rowspan="1" colspan="1">0.86</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Domain midpoint specificity</td>
              <td align="left" rowspan="1" colspan="1">ABA</td>
              <td align="left" rowspan="1" colspan="1">0.38</td>
              <td align="left" rowspan="1" colspan="1">0.18</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
              <td align="left" rowspan="1" colspan="1">0.30</td>
              <td align="left" rowspan="1" colspan="1">0.05</td>
              <td align="left" rowspan="1" colspan="1">0.07</td>
              <td align="left" rowspan="1" colspan="1">0.23</td>
              <td align="left" rowspan="1" colspan="1">0.22</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">TRUST</td>
              <td align="left" rowspan="1" colspan="1">0.28</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
              <td align="left" rowspan="1" colspan="1">0.67</td>
              <td align="left" rowspan="1" colspan="1">0.40</td>
              <td align="left" rowspan="1" colspan="1">0.43</td>
              <td align="left" rowspan="1" colspan="1">0.46</td>
              <td align="left" rowspan="1" colspan="1">0.54</td>
              <td align="left" rowspan="1" colspan="1">0.46</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">RADAR</td>
              <td align="left" rowspan="1" colspan="1">0.33</td>
              <td align="left" rowspan="1" colspan="1">0.19</td>
              <td align="left" rowspan="1" colspan="1">0.58</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
              <td align="left" rowspan="1" colspan="1">0.37</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
              <td align="left" rowspan="1" colspan="1">0.43</td>
              <td align="left" rowspan="1" colspan="1">0.44</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Viterbi</td>
              <td align="left" rowspan="1" colspan="1">0.48</td>
              <td align="left" rowspan="1" colspan="1">0.39</td>
              <td align="left" rowspan="1" colspan="1">0.65</td>
              <td align="left" rowspan="1" colspan="1">0.63</td>
              <td align="left" rowspan="1" colspan="1">0.48</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
              <td align="left" rowspan="1" colspan="1">0.55</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Posterior</td>
              <td align="left" rowspan="1" colspan="1">0.56</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
              <td align="left" rowspan="1" colspan="1">0.71</td>
              <td align="left" rowspan="1" colspan="1">0.66</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
              <td align="left" rowspan="1" colspan="1">0.59</td>
              <td align="left" rowspan="1" colspan="1">0.58</td>
              <td align="left" rowspan="1" colspan="1">0.59</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>In these tests, ABA performs moderately well on subsets 1a and 1b, which contain only repeats of a unique domain subtype, but significantly worse on the other sets, which either contain variable subtypes or additional conserved domains. TRUST outperforms ABA, achieving comparable specificity to RADAR, but considerably lower endpoint and midpoint sensitivity. RADAR, which achieved comparable sensitivity to ProDA at the residue-level, has lower sensitivity and specificity compared to ProDA at the domain-level. Here, RADAR may be overextending domain boundaries on average, thus yielding similar residue-level sensitivity but lower accuracy in the other measures; this hypothesis is consistent with the observation that conserved segments identified by RADAR and ProDA average 52 and 33 residues in length, respectively.</p>
      <p>The two ProDA versions stand alone in achieving both the highest sensitivity and specificity for domain endpoint and midpoint identification. ProDA's midpoint accuracies are higher than its endpoint accuracies, indicating that in many cases, ProDA correctly identifies a conserved segment but chooses different boundaries from those in the reference set, owing to overalignment or underalignment. Overall, we conclude that ProDA correctly identifies the boundaries or midpoints of ∼80–85% of protein domains on average.</p>
      <p>Looking closer at alignments with low scores, we found two general types of domain configurations that proved difficult for the algorithm:
<list list-type="order"><list-item><p>Long domains that contain weakly conserved regions. In such cases, the pairwise alignment step finds only fragments of domains. Each final alignment therefore contains conserved fragments from different domains. Here we do not miss whole domains, but we cannot find accurate boundaries. An example is the family of <italic>Dead</italic> domains.</p></list-item><list-item><p>Short domain repeats that are located close to each other. In such cases, the pairwise alignment step tends to over-align and finds local alignments that contain whole domains along with parts of their neighbors. The neighbors are therefore missed. Then, the algorithm outputs alignments containing fewer domains than in references but with accurate boundaries.</p></list-item></list></p>
      <p>In both cases, errors can be traced to decisions made during the pairwise alignment step.</p>
    </sec>
    <sec>
      <title>Cluster-level accuracy</title>
      <p>Finally, we measured the cluster-level accuracy of the five alignment algorithms tested in the previous section. The performances of the five aligners on Reference 6 are shown in <xref rid="tbl3" ref-type="table">Table 3</xref>.</p>
      <table-wrap position="float" id="tbl3">
        <label>
Table 3
</label>
        <caption>
          <p>Cluster-level accuracy of aligners on BAliBASE reference 6</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left" rowspan="1" colspan="1">Score</th>
              <th align="left" rowspan="1" colspan="1">Method</th>
              <th align="left" rowspan="1" colspan="1">C1a (4)</th>
              <th align="left" rowspan="1" colspan="1">C1b (6)</th>
              <th align="left" rowspan="1" colspan="1">C2a (10)</th>
              <th align="left" rowspan="1" colspan="1">C2b (20)</th>
              <th align="left" rowspan="1" colspan="1">C2c (20)</th>
              <th align="left" rowspan="1" colspan="1">C3 (5)</th>
              <th align="left" rowspan="1" colspan="1">C4 (5)</th>
              <th align="left" rowspan="1" colspan="1">Overall (70)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="1" colspan="1">Cluster sensitivity</td>
              <td align="left" rowspan="1" colspan="1">ABA</td>
              <td align="left" rowspan="1" colspan="1">0.86</td>
              <td align="left" rowspan="1" colspan="1">0.33</td>
              <td align="left" rowspan="1" colspan="1">0.00</td>
              <td align="left" rowspan="1" colspan="1">0.25</td>
              <td align="left" rowspan="1" colspan="1">0.13</td>
              <td align="left" rowspan="1" colspan="1">0.00</td>
              <td align="left" rowspan="1" colspan="1">0.10</td>
              <td align="left" rowspan="1" colspan="1">0.19</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">TRUST</td>
              <td align="left" rowspan="1" colspan="1">0.39</td>
              <td align="left" rowspan="1" colspan="1">0.28</td>
              <td align="left" rowspan="1" colspan="1">0.11</td>
              <td align="left" rowspan="1" colspan="1">0.12</td>
              <td align="left" rowspan="1" colspan="1">0.31</td>
              <td align="left" rowspan="1" colspan="1">0.27</td>
              <td align="left" rowspan="1" colspan="1">0.16</td>
              <td align="left" rowspan="1" colspan="1">0.21</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">RADAR</td>
              <td align="left" rowspan="1" colspan="1">0.83</td>
              <td align="left" rowspan="1" colspan="1">0.60</td>
              <td align="left" rowspan="1" colspan="1">0.41</td>
              <td align="left" rowspan="1" colspan="1">0.50</td>
              <td align="left" rowspan="1" colspan="1">0.56</td>
              <td align="left" rowspan="1" colspan="1">0.74</td>
              <td align="left" rowspan="1" colspan="1">0.46</td>
              <td align="left" rowspan="1" colspan="1">0.55</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Viterbi</td>
              <td align="left" rowspan="1" colspan="1">0.93</td>
              <td align="left" rowspan="1" colspan="1">0.65</td>
              <td align="left" rowspan="1" colspan="1">0.49</td>
              <td align="left" rowspan="1" colspan="1">0.44</td>
              <td align="left" rowspan="1" colspan="1">0.52</td>
              <td align="left" rowspan="1" colspan="1">0.63</td>
              <td align="left" rowspan="1" colspan="1">0.68</td>
              <td align="left" rowspan="1" colspan="1">0.55</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Posterior</td>
              <td align="left" rowspan="1" colspan="1">0.87</td>
              <td align="left" rowspan="1" colspan="1">0.79</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
              <td align="left" rowspan="1" colspan="1">0.42</td>
              <td align="left" rowspan="1" colspan="1">0.71</td>
              <td align="left" rowspan="1" colspan="1">0.45</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Cluster specificity</td>
              <td align="left" rowspan="1" colspan="1">ABA</td>
              <td align="left" rowspan="1" colspan="1">0.32</td>
              <td align="left" rowspan="1" colspan="1">0.18</td>
              <td align="left" rowspan="1" colspan="1">0.00</td>
              <td align="left" rowspan="1" colspan="1">0.10</td>
              <td align="left" rowspan="1" colspan="1">0.07</td>
              <td align="left" rowspan="1" colspan="1">0.00</td>
              <td align="left" rowspan="1" colspan="1">0.15</td>
              <td align="left" rowspan="1" colspan="1">0.09</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">TRUST</td>
              <td align="left" rowspan="1" colspan="1">0.47</td>
              <td align="left" rowspan="1" colspan="1">0.43</td>
              <td align="left" rowspan="1" colspan="1">0.17</td>
              <td align="left" rowspan="1" colspan="1">0.29</td>
              <td align="left" rowspan="1" colspan="1">0.44</td>
              <td align="left" rowspan="1" colspan="1">0.56</td>
              <td align="left" rowspan="1" colspan="1">0.55</td>
              <td align="left" rowspan="1" colspan="1">0.38</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">RADAR</td>
              <td align="left" rowspan="1" colspan="1">0.65</td>
              <td align="left" rowspan="1" colspan="1">0.37</td>
              <td align="left" rowspan="1" colspan="1">0.46</td>
              <td align="left" rowspan="1" colspan="1">0.55</td>
              <td align="left" rowspan="1" colspan="1">0.51</td>
              <td align="left" rowspan="1" colspan="1">0.70</td>
              <td align="left" rowspan="1" colspan="1">0.65</td>
              <td align="left" rowspan="1" colspan="1">0.53</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Viterbi</td>
              <td align="left" rowspan="1" colspan="1">0.75</td>
              <td align="left" rowspan="1" colspan="1">0.56</td>
              <td align="left" rowspan="1" colspan="1">0.76</td>
              <td align="left" rowspan="1" colspan="1">0.72</td>
              <td align="left" rowspan="1" colspan="1">0.61</td>
              <td align="left" rowspan="1" colspan="1">0.71</td>
              <td align="left" rowspan="1" colspan="1">0.78</td>
              <td align="left" rowspan="1" colspan="1">0.69</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">ProDA-Posterior</td>
              <td align="left" rowspan="1" colspan="1">0.74</td>
              <td align="left" rowspan="1" colspan="1">0.60</td>
              <td align="left" rowspan="1" colspan="1">0.76</td>
              <td align="left" rowspan="1" colspan="1">0.77</td>
              <td align="left" rowspan="1" colspan="1">0.59</td>
              <td align="left" rowspan="1" colspan="1">0.78</td>
              <td align="left" rowspan="1" colspan="1">0.71</td>
              <td align="left" rowspan="1" colspan="1">0.70</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Here, ABA and TRUST have the least success in recovering pairwise homologous segments, each detecting ∼20% of the aligned segment pairs in the reference annotation. RADAR and the two versions of ProDA achieve comparable sensitivities, both recovering slightly more than half of these homologies; however, ProDA is considerably more specific with respect to not declaring pairwise homologous segments that are unsupported in the reference set.</p>
      <p>For most of the subsets of reference 6 (except C4), the reference contains only one repeat cluster per family. Instead of finding one cluster per family, however, we observed that most aligners output several smaller clusters all belonging to the same family. This reflects the fact that domains from the same family have different degrees of conservation to each other; here, the extent of cluster fragmentation depends on the threshold used for detecting segment homology. In such a situation, we expect relatively high cluster specificities (as all domains within a predicted cluster will necessarily belong to the same cluster in the reference collection) yet low cluster sensitivities (as domains in the single reference cluster will match poorly with the split clusters in the predicted collection). This hypothesis is consistent with the data, as most methods (except ABA) achieve considerably higher cluster specificity than sensitivity.</p>
    </sec>
  </sec>
  <sec>
    <title>DISCUSSION</title>
    <p>We have described a new algorithm, ProDA, for alignment of protein sequences with repeated and shuffled domains. Given a set of sequences, ProDA first infers repeat and domain structures based on all-versus-all pairwise local alignments. It then performs progressive multiple alignment for each inferred protein block. To ensure reliability of the alignments found, ProDA uses a cascade of heuristic filters to remove spurious alignments both during alignment construction and post-processing. Unlike other multiple alignment algorithms which either ignore the problem of repeats and shuffles, or which leave the user to decide on the proper domain structure of an alignment manually, ProDA attempts to handle these issues automatically, thus presenting the user with a clear view of domain organization within proteins.</p>
    <p>Ideally, given a set of protein sequences, an alignment tool should produce all significant homologies without imposing biologically unrealistic restrictions on how these homologies are organized. ProDA represents a significant step towards redefining the goals and expectations of such a protein multiple alignment system.</p>
    <p>In practice, a number of challenges still remain. When the true alignment is in fact global, traditional multiple alignment methods, which do not need to decide whether observed similarity is sufficiently strong to report, tend to have an advantage. Indeed, on the globally aligned references 1–5 of BAliBASE, ProDA's average SP score of 0.73 is lower than ClustalW's average SP score, 0.86. Nevertheless, for sequences with repeats and rearrangements, empirical tests show that ProDA recovers known protein domain structures with high accuracy while using reasonable computational resources. On reference 6 of BAliBASE, ProDA achieves significantly higher scores than other alignment programs, obtaining state-of-the-art sensitivity and substantially better specificity than previous methods.</p>
    <p>We conclude that ProDA is a practical tool that should aid molecular biologists in tasks requiring automatic analysis of related multi-domain proteins with unknown domain architectures. Source code and executables for ProDA, along with testing scripts used to perform the evaluations, are publicly available at <ext-link xlink:href="http://proda.stanford.edu" ext-link-type="uri"/>.</p>
  </sec>
</body>
<back>
  <ack>
    <p>Most of this work was done when T.M.P. was visiting Stanford University. We thank anonymous referees for helpful comments and suggestions. T.M.P. was supported by a Fulbright fellowship. CBD was supported by an NDSEG fellowship. This project was funded in part by the NSF CAREER Award. Funding to pay the Open Access publication charges for this article was provided by the NSF CAREER Award.</p>
    <p><italic>Conflict of interest statement.</italic> None declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="b1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bateman</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Coin</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Finn</surname>
            <given-names>R.D.</given-names>
          </name>
          <name>
            <surname>Hollich</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>Griffiths-Jones</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Khanna</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Moxon</surname>
            <given-names>M.M.</given-names>
          </name>
          <name>
            <surname>Sonnhammer</surname>
            <given-names>E.L.</given-names>
          </name>
          <name>
            <surname>Studholme</surname>
            <given-names>D.J.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The Pfam protein families database</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>D138</fpage>
        <lpage>D141</lpage>
        <pub-id pub-id-type="pmid">14681378</pub-id>
      </element-citation>
    </ref>
    <ref id="b2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Phillips</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Janies</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Wheeler</surname>
            <given-names>W.</given-names>
          </name>
        </person-group>
        <article-title>Multiple sequence alignments in phylogenetic analysis</article-title>
        <source>Mol. Phylogenet. Evol.</source>
        <year>2000</year>
        <volume>16</volume>
        <fpage>317</fpage>
        <lpage>330</lpage>
        <pub-id pub-id-type="pmid">10991785</pub-id>
      </element-citation>
    </ref>
    <ref id="b3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rost</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Sander</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>Combining evolutionary information and neural networks to predict protein secondary structure</article-title>
        <source>Proteins</source>
        <year>1994</year>
        <volume>19</volume>
        <fpage>55</fpage>
        <lpage>72</lpage>
        <pub-id pub-id-type="pmid">8066087</pub-id>
      </element-citation>
    </ref>
    <ref id="b4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Livingstone</surname>
            <given-names>C.D.</given-names>
          </name>
          <name>
            <surname>Barton</surname>
            <given-names>G.J.</given-names>
          </name>
        </person-group>
        <article-title>Protein sequence alignments: a strategy for the hierarchical analysis of residue conservation</article-title>
        <source>Comput. Appl. Biosci.</source>
        <year>1993</year>
        <volume>9</volume>
        <fpage>745</fpage>
        <lpage>756</lpage>
        <pub-id pub-id-type="pmid">8143162</pub-id>
      </element-citation>
    </ref>
    <ref id="b5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thompson</surname>
            <given-names>J.D.</given-names>
          </name>
          <name>
            <surname>Plewniak</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Poch</surname>
            <given-names>O.</given-names>
          </name>
        </person-group>
        <article-title>A comprehensive comparison of multiple sequence alignment programs</article-title>
        <source>Nucleic Acids Res.</source>
        <year>1999</year>
        <volume>27</volume>
        <fpage>2682</fpage>
        <lpage>2690</lpage>
        <pub-id pub-id-type="pmid">10373585</pub-id>
      </element-citation>
    </ref>
    <ref id="b6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Apic</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Gough</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Teichmann</surname>
            <given-names>S.A.</given-names>
          </name>
        </person-group>
        <article-title>Domain combinations in archaeal, eubacterial, and eukaryotic proteomes</article-title>
        <source>J. Mol. Biol.</source>
        <year>2001</year>
        <volume>310</volume>
        <fpage>311</fpage>
        <lpage>325</lpage>
        <pub-id pub-id-type="pmid">11428892</pub-id>
      </element-citation>
    </ref>
    <ref id="b7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>George</surname>
            <given-names>R.A.</given-names>
          </name>
          <name>
            <surname>Heringa</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Protein domain identification and improved sequence similarity searching using PSI-BLAST</article-title>
        <source>Proteins</source>
        <year>2002</year>
        <volume>48</volume>
        <fpage>672</fpage>
        <lpage>681</lpage>
        <pub-id pub-id-type="pmid">12211035</pub-id>
      </element-citation>
    </ref>
    <ref id="b8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Morgenstern</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Frech</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Dress</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Werner</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <article-title>DIALIGN: finding local similarities by multiple sequence alignment</article-title>
        <source>Bioinformatics</source>
        <year>1998</year>
        <volume>14</volume>
        <fpage>290</fpage>
        <lpage>294</lpage>
        <pub-id pub-id-type="pmid">9614273</pub-id>
      </element-citation>
    </ref>
    <ref id="b9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Feng</surname>
            <given-names>D.F.</given-names>
          </name>
          <name>
            <surname>Doolittle</surname>
            <given-names>R.F.</given-names>
          </name>
        </person-group>
        <article-title>Progressive sequence alignment as a prerequisite to correct phylogenetic trees</article-title>
        <source>J. Mol. Evol.</source>
        <year>1987</year>
        <volume>25</volume>
        <fpage>351</fpage>
        <lpage>360</lpage>
        <pub-id pub-id-type="pmid">3118049</pub-id>
      </element-citation>
    </ref>
    <ref id="b10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Do</surname>
            <given-names>C.B.</given-names>
          </name>
          <name>
            <surname>Mahabhashyam</surname>
            <given-names>M.S.B.</given-names>
          </name>
          <name>
            <surname>Brudno</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Batzoglou</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>ProbCons: probabilistic consistency-based multiple sequence alignment</article-title>
        <source>Genome Res.</source>
        <year>2005</year>
        <volume>15</volume>
        <fpage>330</fpage>
        <lpage>340</lpage>
        <pub-id pub-id-type="pmid">15687296</pub-id>
      </element-citation>
    </ref>
    <ref id="b11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pellegrini</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Marcotte</surname>
            <given-names>E.M.</given-names>
          </name>
          <name>
            <surname>Yeates</surname>
            <given-names>T.O.</given-names>
          </name>
        </person-group>
        <article-title>A fast algorithm for genome-wide analysis of proteins with repeated sequences</article-title>
        <source>Proteins</source>
        <year>1999</year>
        <volume>35</volume>
        <fpage>440</fpage>
        <lpage>446</lpage>
        <pub-id pub-id-type="pmid">10382671</pub-id>
      </element-citation>
    </ref>
    <ref id="b12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Raphael</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Zhi</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>A novel method for multiple alignment of sequences with repeated and shuffled elements</article-title>
        <source>Genome Res.</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>2336</fpage>
        <lpage>2346</lpage>
        <pub-id pub-id-type="pmid">15520295</pub-id>
      </element-citation>
    </ref>
    <ref id="b13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>T.F.</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>M.S.</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J. Mol. Biol.</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </element-citation>
    </ref>
    <ref id="b14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wheelan</surname>
            <given-names>S.J.</given-names>
          </name>
          <name>
            <surname>Marchler-Bauer</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Bryant</surname>
            <given-names>S.H.</given-names>
          </name>
        </person-group>
        <article-title>Domain size distributions can predict domain boundaries</article-title>
        <source>Bioinformatics</source>
        <year>2000</year>
        <volume>16</volume>
        <fpage>613</fpage>
        <lpage>618</lpage>
        <pub-id pub-id-type="pmid">11038331</pub-id>
      </element-citation>
    </ref>
    <ref id="b15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bahr</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Thompson</surname>
            <given-names>J.D.</given-names>
          </name>
          <name>
            <surname>Thiery</surname>
            <given-names>J.-C.</given-names>
          </name>
          <name>
            <surname>Poch</surname>
            <given-names>O.</given-names>
          </name>
        </person-group>
        <article-title>BAliBASE (Benchmark Alignment dataBASE): enhancements for repeats, transmembrane sequences and circular permutations</article-title>
        <source>Nucleic Acid Res.</source>
        <year>2001</year>
        <volume>29</volume>
        <fpage>323</fpage>
        <lpage>326</lpage>
        <pub-id pub-id-type="pmid">11125126</pub-id>
      </element-citation>
    </ref>
    <ref id="b16">
      <label>16</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Durbin</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Eddy</surname>
            <given-names>S.R.</given-names>
          </name>
          <name>
            <surname>Krogh</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Mitchison</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <source>Biological Sequence Analysis: Probabilistic Models of Proteins and Nucleic Acids</source>
        <year>1998</year>
        <publisher-loc>Cambridge, UK</publisher-loc>
        <publisher-name>Cambridge University Press</publisher-name>
      </element-citation>
    </ref>
    <ref id="b17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Morgenstern</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Dress</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Werner</surname>
            <given-names>T.</given-names>
          </name>
        </person-group>
        <article-title>Multiple DNA and protein sequence alignment based on segment-to-segment comparison</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>1996</year>
        <volume>93</volume>
        <fpage>12098</fpage>
        <lpage>12103</lpage>
        <pub-id pub-id-type="pmid">8901539</pub-id>
      </element-citation>
    </ref>
    <ref id="b18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brocchieri</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Karlin</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>A symmetric-iterated method for the multiple alignment of protein sequences</article-title>
        <source>J. Mol. Biol.</source>
        <year>1998</year>
        <volume>276</volume>
        <fpage>249</fpage>
        <lpage>264</lpage>
        <pub-id pub-id-type="pmid">9514731</pub-id>
      </element-citation>
    </ref>
    <ref id="b19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Edgar</surname>
            <given-names>R.C.</given-names>
          </name>
          <name>
            <surname>Sjölander</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <article-title>SATCHMO: sequence alignment and tree construction using hidden Markov models</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <fpage>1404</fpage>
        <lpage>1411</lpage>
        <pub-id pub-id-type="pmid">12874053</pub-id>
      </element-citation>
    </ref>
    <ref id="b20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lee</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Grasso</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Sharlow</surname>
            <given-names>M.F.</given-names>
          </name>
        </person-group>
        <article-title>Multiple sequence alignment using partial order graphs</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <fpage>452</fpage>
        <lpage>464</lpage>
        <pub-id pub-id-type="pmid">11934745</pub-id>
      </element-citation>
    </ref>
    <ref id="b21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bailey</surname>
            <given-names>T.L.</given-names>
          </name>
          <name>
            <surname>Elkan</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>Fitting a mixture model by expectation maximization to discover motifs in biopolymers</article-title>
        <source>Proc. Int. Conf. Intell. Syst. Mol. Biol.</source>
        <year>1994</year>
        <volume>2</volume>
        <fpage>28</fpage>
        <lpage>36</lpage>
        <pub-id pub-id-type="pmid">7584402</pub-id>
      </element-citation>
    </ref>
    <ref id="b22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hertz</surname>
            <given-names>G.Z.</given-names>
          </name>
          <name>
            <surname>Stormo</surname>
            <given-names>G.D.</given-names>
          </name>
        </person-group>
        <article-title>Identifying DNA and protein patterns with statistically significant alignments of multiple sequences</article-title>
        <source>Bioinformatics</source>
        <year>1999</year>
        <volume>15</volume>
        <fpage>563</fpage>
        <lpage>577</lpage>
        <pub-id pub-id-type="pmid">10487864</pub-id>
      </element-citation>
    </ref>
    <ref id="b23">
      <label>23</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lawrence</surname>
            <given-names>C.E.</given-names>
          </name>
          <name>
            <surname>Altschul</surname>
            <given-names>S.F.</given-names>
          </name>
          <name>
            <surname>Boguski</surname>
            <given-names>M.S.</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>J.S.</given-names>
          </name>
          <name>
            <surname>Neuwald</surname>
            <given-names>A.F.</given-names>
          </name>
          <name>
            <surname>Wootton</surname>
            <given-names>J.C.</given-names>
          </name>
        </person-group>
        <article-title>Detecting subtle sequence signals: a Gibbs sampling strategy for multiple alignment</article-title>
        <source>Science</source>
        <year>1993</year>
        <volume>262</volume>
        <fpage>208</fpage>
        <lpage>214</lpage>
        <pub-id pub-id-type="pmid">8211139</pub-id>
      </element-citation>
    </ref>
    <ref id="b24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>S.F.</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>E.W.</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>D.J.</given-names>
          </name>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>J. Mol. Biol.</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </element-citation>
    </ref>
    <ref id="b25">
      <label>25</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>S.F.</given-names>
          </name>
          <name>
            <surname>Madden</surname>
            <given-names>T.L.</given-names>
          </name>
          <name>
            <surname>Schaffer</surname>
            <given-names>A.A.</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Z.</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>D.J.</given-names>
          </name>
        </person-group>
        <article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>
        <source>Nucleic Acids Res.</source>
        <year>1997</year>
        <volume>25</volume>
        <fpage>3389</fpage>
        <lpage>3402</lpage>
        <pub-id pub-id-type="pmid">9254694</pub-id>
      </element-citation>
    </ref>
    <ref id="b26">
      <label>26</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schuler</surname>
            <given-names>G.D.</given-names>
          </name>
          <name>
            <surname>Altschul</surname>
            <given-names>S.F.</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>D.J.</given-names>
          </name>
        </person-group>
        <article-title>A workbench for multiple alignment construction and analysis</article-title>
        <source>Proteins</source>
        <year>1991</year>
        <volume>9</volume>
        <fpage>180</fpage>
        <lpage>190</lpage>
        <pub-id pub-id-type="pmid">2006136</pub-id>
      </element-citation>
    </ref>
    <ref id="b27">
      <label>27</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sonnhammer</surname>
            <given-names>E.L.L.</given-names>
          </name>
          <name>
            <surname>Kahn</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>Modular arrangement of proteins as inferred from analysis of homology</article-title>
        <source>Protein Sci.</source>
        <year>1994</year>
        <volume>3</volume>
        <fpage>482</fpage>
        <lpage>492</lpage>
        <pub-id pub-id-type="pmid">8019419</pub-id>
      </element-citation>
    </ref>
    <ref id="b28">
      <label>28</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bru</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Courcelle</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Carrère</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Beausse</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Dalmar</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Kahn</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>The ProDom database of protein domain families: more emphasis on 3D</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2005</year>
        <volume>33</volume>
        <fpage>D212</fpage>
        <lpage>D215</lpage>
        <pub-id pub-id-type="pmid">15608179</pub-id>
      </element-citation>
    </ref>
    <ref id="b29">
      <label>29</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Notredame</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>Mocca: semi-automatic method for domain hunting</article-title>
        <source>Bioinformatics</source>
        <year>2001</year>
        <volume>17</volume>
        <fpage>373</fpage>
        <lpage>374</lpage>
        <pub-id pub-id-type="pmid">11301309</pub-id>
      </element-citation>
    </ref>
    <ref id="b30">
      <label>30</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Heger</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Holm</surname>
            <given-names>L.</given-names>
          </name>
        </person-group>
        <article-title>Rapid automatic detection and alignment of repeats in protein sequences</article-title>
        <source>Proteins</source>
        <year>2000</year>
        <volume>41</volume>
        <fpage>224</fpage>
        <lpage>237</lpage>
        <pub-id pub-id-type="pmid">10966575</pub-id>
      </element-citation>
    </ref>
    <ref id="b31">
      <label>31</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Heringa</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Argos</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>A method to recognize distant repeats in protein sequences</article-title>
        <source>Proteins</source>
        <year>1993</year>
        <volume>17</volume>
        <fpage>391</fpage>
        <lpage>401</lpage>
        <pub-id pub-id-type="pmid">8108381</pub-id>
      </element-citation>
    </ref>
    <ref id="b32">
      <label>32</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Szklarczyk</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Heringa</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Tracking repeats using significance and transitivity</article-title>
        <source>Bioinformatics</source>
        <year>2004</year>
        <volume>20</volume>
        <fpage>I311</fpage>
        <lpage>I317</lpage>
        <pub-id pub-id-type="pmid">15262814</pub-id>
      </element-citation>
    </ref>
    <ref id="b33">
      <label>33</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sammeth</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Heringa</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Global multiple-sequence alignment with repeats</article-title>
        <source>Proteins</source>
        <year>2006</year>
        <volume>64</volume>
        <fpage>263</fpage>
        <lpage>274</lpage>
        <pub-id pub-id-type="pmid">16609972</pub-id>
      </element-citation>
    </ref>
    <ref id="b34">
      <label>34</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Waterman</surname>
            <given-names>M.S.</given-names>
          </name>
          <name>
            <surname>Eggert</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>A new algorithm for best subsequence alignments with application to tRNA-tRNA comparisons</article-title>
        <source>J. Mol. Biol.</source>
        <year>1987</year>
        <volume>197</volume>
        <fpage>723</fpage>
        <lpage>728</lpage>
        <pub-id pub-id-type="pmid">2448477</pub-id>
      </element-citation>
    </ref>
    <ref id="b35">
      <label>35</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Morgenstern</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <article-title>DIALIGN 2: improvement of the segment-to-segment approach to multiple sequence alignment</article-title>
        <source>Bioninformatics</source>
        <year>1999</year>
        <volume>15</volume>
        <fpage>211</fpage>
        <lpage>218</lpage>
      </element-citation>
    </ref>
    <ref id="b36">
      <label>36</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Subramanian</surname>
            <given-names>A.R.</given-names>
          </name>
          <name>
            <surname>Weyer-Menkhoff</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Kaufmann</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Morgenstern</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <article-title>DIALIGN-T: an improved algorithm for segment-based multiple sequence alignment</article-title>
        <source>BMC Bioinformatics</source>
        <year>2005</year>
        <volume>6</volume>
        <fpage>66</fpage>
        <pub-id pub-id-type="pmid">15784139</pub-id>
      </element-citation>
    </ref>
    <ref id="b37">
      <label>37</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thompson</surname>
            <given-names>J.D.</given-names>
          </name>
          <name>
            <surname>Higgins</surname>
            <given-names>D.G.</given-names>
          </name>
          <name>
            <surname>Gibson</surname>
            <given-names>T.J.</given-names>
          </name>
        </person-group>
        <article-title>CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice</article-title>
        <source>Nucleic Acids Res.</source>
        <year>1994</year>
        <volume>22</volume>
        <fpage>4673</fpage>
        <lpage>4680</lpage>
        <pub-id pub-id-type="pmid">7984417</pub-id>
      </element-citation>
    </ref>
    <ref id="b38">
      <label>38</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Edgar</surname>
            <given-names>R.C.</given-names>
          </name>
        </person-group>
        <article-title>MUSCLE: multiple sequence alignment with high accuracy and high throughput</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>1792</fpage>
        <lpage>1797</lpage>
        <pub-id pub-id-type="pmid">15034147</pub-id>
      </element-citation>
    </ref>
    <ref id="b39">
      <label>39</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Henikoff</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Henikoff</surname>
            <given-names>J.G.</given-names>
          </name>
        </person-group>
        <article-title>Amino acid substitution matrices from protein blocks</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>1992</year>
        <volume>89</volume>
        <fpage>10915</fpage>
        <lpage>10919</lpage>
        <pub-id pub-id-type="pmid">1438297</pub-id>
      </element-citation>
    </ref>
    <ref id="b40">
      <label>40</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thompson</surname>
            <given-names>J.D.</given-names>
          </name>
          <name>
            <surname>Plewniak</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Poch</surname>
            <given-names>O.</given-names>
          </name>
        </person-group>
        <article-title>BAliBASE: a benchmark alignment database for the evaluation of multiple alignment programs</article-title>
        <source>Bioinformatics</source>
        <year>1999</year>
        <volume>15</volume>
        <fpage>87</fpage>
        <lpage>88</lpage>
        <pub-id pub-id-type="pmid">10068696</pub-id>
      </element-citation>
    </ref>
    <ref id="b41">
      <label>41</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nagarajan</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Yona</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>Automatic prediction of protein domains from sequence information using a hybrid learning system</article-title>
        <source>Bioinformatics</source>
        <year>2004</year>
        <volume>20</volume>
        <fpage>1335</fpage>
        <lpage>1360</lpage>
        <pub-id pub-id-type="pmid">14962932</pub-id>
      </element-citation>
    </ref>
    <ref id="b42">
      <label>42</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sonnhammer</surname>
            <given-names>E.L.L.</given-names>
          </name>
          <name>
            <surname>Eddy</surname>
            <given-names>S.R.</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Bateman</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Pfam: multiple sequence alignments and HMM-profiles of protein domains</article-title>
        <source>Nucleic Acids Res.</source>
        <year>1998</year>
        <volume>26</volume>
        <fpage>320</fpage>
        <lpage>322</lpage>
        <pub-id pub-id-type="pmid">9399864</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
